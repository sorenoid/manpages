{"name":"sched_setaffinity","description":"sched_setaffinity, sched_getaffinity - set and get a thread&rsquo;s CPU affinity mask","body":"\n\n<h1 align=\"center\">SCHED_SETAFFINITY</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sched_setaffinity,\nsched_getaffinity - set and get a thread&rsquo;s CPU\naffinity mask</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;sched.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nsched_setaffinity(pid_t</b> <i>pid</i><b>, size_t</b>\n<i>cpusetsize</i><b>, <br>\nconst cpu_set_t *</b><i>mask</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nsched_getaffinity(pid_t</b> <i>pid</i><b>, size_t</b>\n<i>cpusetsize</i><b>, <br>\ncpu_set_t *</b><i>mask</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\nthread&rsquo;s CPU affinity mask determines the set of CPUs\non which it is eligible to run. On a multiprocessor system,\nsetting the CPU affinity mask can be used to obtain\nperformance benefits. For example, by dedicating one CPU to\na particular thread (i.e., setting the affinity mask of that\nthread to specify a single CPU, and setting the affinity\nmask of all other threads to exclude that CPU), it is\npossible to ensure maximum execution speed for that thread.\nRestricting a thread to run on a single CPU also avoids the\nperformance cost caused by the cache invalidation that\noccurs when a thread ceases to execute on one CPU and then\nrecommences execution on a different CPU.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A CPU affinity\nmask is represented by the <i>cpu_set_t</i> structure, a\n&quot;CPU set&quot;, pointed to by <i>mask</i>. A set of\nmacros for manipulating CPU sets is described in\n<a href=\"https://man.page/3/CPU_SET\">CPU_SET(3)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>sched_setaffinity</b>()\nsets the CPU affinity mask of the thread whose ID is\n<i>pid</i> to the value specified by <i>mask</i>. If\n<i>pid</i> is zero, then the calling thread is used. The\nargument <i>cpusetsize</i> is the length (in bytes) of the\ndata pointed to by <i>mask</i>. Normally this argument would\nbe specified as <i>sizeof(cpu_set_t)</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the thread\nspecified by <i>pid</i> is not currently running on one of\nthe CPUs specified in <i>mask</i>, then that thread is\nmigrated to one of the CPUs specified in <i>mask</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>sched_getaffinity</b>()\nwrites the affinity mask of the thread whose ID is\n<i>pid</i> into the <i>cpu_set_t</i> structure pointed to by\n<i>mask</i>. The <i>cpusetsize</i> argument specifies the\nsize (in bytes) of <i>mask</i>. If <i>pid</i> is zero, then\nthe mask of the calling thread is returned.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>sched_setaffinity</b>() and <b>sched_getaffinity</b>()\nreturn 0 (but see &quot;C library/kernel differences&quot;\nbelow, which notes that the underlying\n<b>sched_getaffinity</b>() differs in its return value). On\nerror, -1 is returned, and <i>errno</i> is set\nappropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">A supplied memory address was\ninvalid.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The affinity bit mask <i>mask</i> contains no processors\nthat are currently physically on the system and permitted to\nthe thread according to any restrictions that may be imposed\nby <i>cpuset</i> cgroups or the &quot;cpuset&quot; mechanism\ndescribed in <a href=\"https://man.page/7/cpuset\">cpuset(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>sched_getaffinity</b>() and, in kernels before\n2.6.9, <b>sched_setaffinity</b>()) <i>cpusetsize</i> is\nsmaller than the size of the affinity mask used by the\nkernel.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>sched_setaffinity</b>()) The calling thread does not\nhave appropriate privileges. The caller needs an effective\nuser ID equal to the real user ID or effective user ID of\nthe thread identified by <i>pid</i>, or it must possess the\n<b>CAP_SYS_NICE</b> capability in the user namespace of the\nthread <i>pid</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESRCH</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The thread whose ID is <i>pid</i> could not be\nfound.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The CPU\naffinity system calls were introduced in Linux kernel 2.5.8.\nThe system call wrappers were introduced in glibc 2.3.\nInitially, the glibc interfaces included a <i>cpusetsize</i>\nargument, typed as <i>unsigned int</i>. In glibc 2.3.3, the\n<i>cpusetsize</i> argument was removed, but was then\nrestored in glibc 2.3.4, with type <i>size_t</i>.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls are Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">After a call to\n<b>sched_setaffinity</b>(), the set of CPUs on which the\nthread will actually run is the intersection of the set\nspecified in the <i>mask</i> argument and the set of CPUs\nactually present on the system. The system may further\nrestrict the set of CPUs on which the thread runs if the\n&quot;cpuset&quot; mechanism described in <a href=\"https://man.page/7/cpuset\">cpuset(7)</a>\nis being used. These restrictions on the actual set of CPUs\non which the thread will run are silently imposed by the\nkernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are\nvarious ways of determining the number of CPUs available on\nthe system, including: inspecting the contents of\n<i>/proc/cpuinfo</i>; using <a href=\"https://man.page/3/sysconf\">sysconf(3)</a> to obtain the\nvalues of the <b>_SC_NPROCESSORS_CONF</b> and\n<b>_SC_NPROCESSORS_ONLN</b> parameters; and inspecting the\nlist of CPU directories under\n<i>/sys/devices/system/cpu/</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/7/sched\">sched(7)</a>\nhas a description of the Linux scheduling scheme.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The affinity\nmask is a per-thread attribute that can be adjusted\nindependently for each of the threads in a thread group. The\nvalue returned from a call to <a href=\"https://man.page/2/gettid\">gettid(2)</a> can be passed\nin the argument <i>pid</i>. Specifying <i>pid</i> as 0 will\nset the attribute for the calling thread, and passing the\nvalue returned from a call to <a href=\"https://man.page/2/getpid\">getpid(2)</a> will set the\nattribute for the main thread of the thread group. (If you\nare using the POSIX threads API, then use\n<a href=\"https://man.page/3/pthread_setaffinity_np\">pthread_setaffinity_np(3)</a> instead of\n<b>sched_setaffinity</b>().)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>isolcpus</i> boot option can be used to isolate one or\nmore CPUs at boot time, so that no processes are scheduled\nonto those CPUs. Following the use of this boot option, the\nonly way to schedule processes onto the isolated CPUs is via\n<b>sched_setaffinity</b>() or the <a href=\"https://man.page/7/cpuset\">cpuset(7)</a>\nmechanism. For further information, see the kernel source\nfile <i>Documentation/admin-guide/kernel-parameters.txt</i>.\nAs noted in that file, <i>isolcpus</i> is the preferred\nmechanism of isolating CPUs (versus the alternative of\nmanually setting the CPU affinity of all processes on the\nsystem).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child created\nvia <a href=\"https://man.page/2/fork\">fork(2)</a> inherits its parent&rsquo;s CPU affinity\nmask. The affinity mask is preserved across an\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nThis manual page describes the glibc interface for the CPU\naffinity calls. The actual system call interface is slightly\ndifferent, with the <i>mask</i> being typed as <i>unsigned\nlong&nbsp;*</i>, reflecting the fact that the underlying\nimplementation of CPU sets is a simple bit mask.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success, the\nraw <b>sched_getaffinity</b>() system call returns the\nnumber of bytes placed copied into the <i>mask</i> buffer;\nthis will be the minimum of <i>cpusetsize</i> and the size\n(in bytes) of the <i>cpumask_t</i> data type that is used\ninternally by the kernel to represent the CPU set bit\nmask.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Handling\nsystems with large CPU affinity masks</b> <br>\nThe underlying system calls (which represent CPU masks as\nbit masks of type <i>unsigned long&nbsp;*</i>) impose no\nrestriction on the size of the CPU mask. However, the\n<i>cpu_set_t</i> data type used by glibc has a fixed size of\n128 bytes, meaning that the maximum CPU number that can be\nrepresented is 1023. If the kernel CPU affinity mask is\nlarger than 1024, then calls of the form:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sched_getaffinity(pid,\nsizeof(cpu_set_t), &amp;mask);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fail with the\nerror <b>EINVAL</b>, the error produced by the underlying\nsystem call for the case where the <i>mask</i> size\nspecified in <i>cpusetsize</i> is smaller than the size of\nthe affinity mask used by the kernel. (Depending on the\nsystem CPU topology, the kernel affinity mask can be\nsubstantially larger than the number of active CPUs in the\nsystem.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When working on\nsystems with large kernel CPU affinity masks, one must\ndynamically allocate the <i>mask</i> argument (see\n<a href=\"https://man.page/3/CPU_ALLOC\">CPU_ALLOC(3)</a>). Currently, the only way to do this is\nby probing for the size of the required mask using\n<b>sched_getaffinity</b>() calls with increasing mask sizes\n(until the call does not fail with the error\n<b>EINVAL</b>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Be aware that\n<a href=\"https://man.page/3/CPU_ALLOC\">CPU_ALLOC(3)</a> may allocate a slightly larger CPU set\nthan requested (because CPU sets are implemented as bit\nmasks allocated in units of <i>sizeof(long)</i>).\nConsequently, <b>sched_getaffinity</b>() can set bits beyond\nthe requested allocation size, because the kernel sees a few\nadditional bits. Therefore, the caller should iterate over\nthe bits in the returned set, counting those which are set,\nand stop upon reaching the value returned by\n<a href=\"https://man.page/3/CPU_COUNT\">CPU_COUNT(3)</a> (rather than iterating over the number\nof bits requested to be allocated).</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow creates a child process. The parent and child then\neach assign themselves to a specified CPU and execute\nidentical loops that consume some CPU time. Before\nterminating, the parent waits for the child to complete. The\nprogram takes three command-line arguments: the CPU number\nfor the parent, the CPU number for the child, and the number\nof loop iterations that both processes should perform.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As the sample\nruns below demonstrate, the amount of real and CPU time\nconsumed when running the program will depend on intra-core\ncaching effects and whether the processes are using the same\nCPU.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">We first employ\n<a href=\"https://man.page/1/lscpu\">lscpu(1)</a> to determine that this (x86) system has two\ncores, each with two CPUs:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>lscpu |\negrep -i 'core.*:|socket'</b> <br>\nThread(s) per core: 2 <br>\nCore(s) per socket: 2 <br>\nSocket(s): 1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">We then time\nthe operation of the example program for three cases: both\nprocesses running on the same CPU; both processes running on\ndifferent CPUs on the same core; and both processes running\non different CPUs on different cores.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>time -p\n./a.out 0 0 100000000</b> <br>\nreal 14.75 <br>\nuser 3.02 <br>\nsys 11.73 <br>\n$ <b>time -p ./a.out 0 1 100000000</b> <br>\nreal 11.52 <br>\nuser 3.98 <br>\nsys 19.06 <br>\n$ <b>time -p ./a.out 0 3 100000000</b> <br>\nreal 7.89 <br>\nuser 3.29 <br>\nsys 12.07</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;sched.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/wait.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\ncpu_set_t set; <br>\nint parentCPU, childCPU; <br>\nint nloops;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 4)\n{ <br>\nfprintf(stderr, &quot;Usage: %s parent-cpu child-cpu\nnum-loops\\n&quot;, <br>\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">parentCPU =\natoi(argv[1]); <br>\nchildCPU = atoi(argv[2]); <br>\nnloops = atoi(argv[3]);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">CPU_ZERO(&amp;set);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">switch (fork())\n{ <br>\ncase -1: /* Error */ <br>\nerrExit(&quot;fork&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">case 0: /*\nChild */ <br>\nCPU_SET(childCPU, &amp;set);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(sched_setaffinity(getpid(), sizeof(set), &amp;set) == -1)\n<br>\nerrExit(&quot;sched_setaffinity&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; nloops; j++) <br>\ngetppid();</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">default: /*\nParent */ <br>\nCPU_SET(parentCPU, &amp;set);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(sched_setaffinity(getpid(), sizeof(set), &amp;set) == -1)\n<br>\nerrExit(&quot;sched_setaffinity&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; nloops; j++) <br>\ngetppid();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">wait(NULL); /*\nWait for child to terminate */ <br>\nexit(EXIT_SUCCESS); <br>\n} <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/lscpu\">lscpu(1)</a>,\n<a href=\"https://man.page/1/nproc\">nproc(1)</a>, <a href=\"https://man.page/1/taskset\">taskset(1)</a>, <a href=\"https://man.page/2/clone\">clone(2)</a>,\n<a href=\"https://man.page/2/getcpu\">getcpu(2)</a>, <a href=\"https://man.page/2/getpriority\">getpriority(2)</a>, <a href=\"https://man.page/2/gettid\">gettid(2)</a>,\n<a href=\"https://man.page/2/nice\">nice(2)</a>, <a href=\"https://man.page/2/sched_get_priority_max\">sched_get_priority_max(2)</a>,\n<a href=\"https://man.page/2/sched_get_priority_min\">sched_get_priority_min(2)</a>,\n<a href=\"https://man.page/2/sched_getscheduler\">sched_getscheduler(2)</a>, <a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a>,\n<a href=\"https://man.page/2/setpriority\">setpriority(2)</a>, <a href=\"https://man.page/3/CPU_SET\">CPU_SET(3)</a>,\n<a href=\"https://man.page/3/get_nprocs\">get_nprocs(3)</a>, <a href=\"https://man.page/3/pthread_setaffinity_np\">pthread_setaffinity_np(3)</a>,\n<a href=\"https://man.page/3/sched_getcpu\">sched_getcpu(3)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/cpuset\">cpuset(7)</a>, <a href=\"https://man.page/7/sched\">sched(7)</a>, <b>numactl</b>(8)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}