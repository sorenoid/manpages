{"name":"ioctl_tty","description":"ioctl_tty - ioctls for terminals and serial lines","body":"\n\n<h1 align=\"center\">IOCTL_TTY</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioctl_tty -\nioctls for terminals and serial lines</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;termios.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nioctl(int</b> <i>fd</i><b>, int</b> <i>cmd</i><b>,\n...);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> call for terminals and serial ports accepts\nmany possible command arguments. Most require a third\nargument, of varying type, here called <i>argp</i> or\n<i>arg</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Use of\n<i>ioctl</i> makes for nonportable programs. Use the POSIX\ninterface described in <a href=\"https://man.page/3/termios\">termios(3)</a> whenever\npossible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Get and set\nterminal attributes</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TCGETS</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"8%\"></td>\n<td width=\"77%\">\n\n\n<p><b>struct termios *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Equivalent to <i>tcgetattr(fd,\nargp)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Get the current\nserial port settings.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TCSETS</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"8%\"></td>\n<td width=\"77%\">\n\n\n<p><b>const struct termios *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Equivalent to <i>tcsetattr(fd,\nTCSANOW, argp)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Set the current\nserial port settings.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TCSETSW</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"8%\"></td>\n<td width=\"77%\">\n\n\n<p><b>const struct termios *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Equivalent to <i>tcsetattr(fd,\nTCSADRAIN, argp)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Allow the\noutput buffer to drain, and set the current serial port\nsettings.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TCSETSF</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"8%\"></td>\n<td width=\"77%\">\n\n\n<p><b>const struct termios *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Equivalent to <i>tcsetattr(fd,\nTCSAFLUSH, argp)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Allow the\noutput buffer to drain, discard pending input, and set the\ncurrent serial port settings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nfour ioctls are just like <b>TCGETS</b>, <b>TCSETS</b>,\n<b>TCSETSW</b>, <b>TCSETSF</b>, except that they take a\n<i>struct termio&nbsp;*</i> instead of a <i>struct\ntermios&nbsp;*</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"-14%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p><b>TCGETA</b></p></td>\n<td width=\"77%\">\n\n\n<p><b>struct termio *</b><i>argp</i></p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"-14%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p><b>TCSETA</b></p></td>\n<td width=\"77%\">\n\n\n<p><b>const struct termio *</b><i>argp</i></p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"-14%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p><b>TCSETAW</b></p></td>\n<td width=\"77%\">\n\n\n<p><b>const struct termio *</b><i>argp</i></p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"-14%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p><b>TCSETAF</b></p></td>\n<td width=\"77%\">\n\n\n<p><b>const struct termio *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Locking the\ntermios structure</b> <br>\nThe <i>termios</i> structure of a terminal can be locked.\nThe lock is itself a <i>termios</i> structure, with nonzero\nbits or fields indicating a locked value.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TIOCGLCKTRMIOS</b></p></td>\n<td width=\"15%\"></td>\n<td width=\"8%\"></td>\n<td width=\"69%\">\n\n\n<p><b>struct termios *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Gets the locking status of the\n<i>termios</i> structure of the terminal.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TIOCSLCKTRMIOS</b></p></td>\n<td width=\"15%\"></td>\n<td width=\"8%\"></td>\n<td width=\"69%\">\n\n\n<p><b>const struct termios *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Sets the locking status of the\n<i>termios</i> structure of the terminal. Only a process\nwith the <b>CAP_SYS_ADMIN</b> capability can do this.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Get and set\nwindow size</b> <br>\nWindow sizes are kept in the kernel, but not used by the\nkernel (except in the case of virtual consoles, where the\nkernel will update the window size when the size of the\nvirtual console changes, for example, by loading a new\nfont).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nconstants and structure are defined in\n<i>&lt;sys/ioctl.h&gt;</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TIOCGWINSZ</b></p></td>\n<td width=\"15%\"></td>\n<td width=\"8%\"></td>\n<td width=\"69%\">\n\n\n<p><b>struct winsize *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Get window size.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"-3%\">\n\n\n<p><b>TIOCSWINSZ</b></p></td>\n<td width=\"15%\"></td>\n<td width=\"8%\"></td>\n<td width=\"69%\">\n\n\n<p><b>const struct winsize *</b><i>argp</i></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Set window size.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The struct used\nby these ioctls is defined as</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct winsize\n{ <br>\nunsigned short ws_row; <br>\nunsigned short ws_col; <br>\nunsigned short ws_xpixel; /* unused */ <br>\nunsigned short ws_ypixel; /* unused */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the window\nsize changes, a <b>SIGWINCH</b> signal is sent to the\nforeground process group.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Sending a\nbreak <br>\nTCSBRK int</b> <i>arg</i></p>\n\n<p style=\"margin-left:22%;\">Equivalent to\n<i>tcsendbreak(fd, arg)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the terminal\nis using asynchronous serial data transmission, and\n<i>arg</i> is zero, then send a break (a stream of zero\nbits) for between 0.25 and 0.5 seconds. If the terminal is\nnot using asynchronous serial data transmission, then either\na break is sent, or the function returns without doing\nanything. When <i>arg</i> is nonzero, nobody knows what will\nhappen.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">(SVr4,\nUnixWare, Solaris, Linux treat <i>tcsendbreak(fd,arg)</i>\nwith nonzero <i>arg</i> like <i>tcdrain(fd)</i>. SunOS\ntreats <i>arg</i> as a multiplier, and sends a stream of\nbits <i>arg</i> times as long as done for zero <i>arg</i>.\nDG/UX and AIX treat <i>arg</i> (when nonzero) as a time\ninterval measured in milliseconds. HP-UX ignores\n<i>arg</i>.)</p>\n\n<p style=\"margin-left:11%;\"><b>TCSBRKP int</b>\n<i>arg</i></p>\n\n<p style=\"margin-left:22%;\">So-called &quot;POSIX\nversion&quot; of <b>TCSBRK</b>. It treats nonzero <i>arg</i>\nas a time interval measured in deciseconds, and does nothing\nwhen the driver does not support breaks.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCSBRK void</b></p>\n\n<p style=\"margin-left:22%;\">Turn break on, that is, start\nsending zero bits.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCCBRK void</b></p>\n\n<p style=\"margin-left:22%;\">Turn break off, that is, stop\nsending zero bits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Software\nflow control <br>\nTCXONC int</b> <i>arg</i></p>\n\n<p style=\"margin-left:22%;\">Equivalent to <i>tcflow(fd,\narg)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">See\n<a href=\"https://man.page/3/tcflow\">tcflow(3)</a> for the argument values <b>TCOOFF</b>,\n<b>TCOON</b>, <b>TCIOFF</b>, <b>TCION</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Buffer count\nand flushing <br>\nFIONREAD int *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Get the number of bytes in the\ninput buffer.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCINQ int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Same as <b>FIONREAD</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCOUTQ int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Get the number of bytes in the\noutput buffer.</p>\n\n<p style=\"margin-left:11%;\"><b>TCFLSH int</b>\n<i>arg</i></p>\n\n<p style=\"margin-left:22%;\">Equivalent to <i>tcflush(fd,\narg)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">See\n<a href=\"https://man.page/3/tcflush\">tcflush(3)</a> for the argument values <b>TCIFLUSH</b>,\n<b>TCOFLUSH</b>, <b>TCIOFLUSH</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Faking input\n<br>\nTIOCSTI const char *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Insert the given byte in the\ninput queue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Redirecting\nconsole output <br>\nTIOCCONS void</b></p>\n\n<p style=\"margin-left:22%;\">Redirect output that would have\ngone to <i>/dev/console</i> or <i>/dev/tty0</i> to the given\nterminal. If that was a pseudoterminal master, send it to\nthe slave. In Linux before version 2.6.10, anybody can do\nthis as long as the output was not redirected yet; since\nversion 2.6.10, only a process with the <b>CAP_SYS_ADMIN</b>\ncapability may do this. If output was redirected already,\nthen <b>EBUSY</b> is returned, but redirection can be\nstopped by using this ioctl with <i>fd</i> pointing at\n<i>/dev/console</i> or <i>/dev/tty0</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Controlling\nterminal <br>\nTIOCSCTTY int</b> <i>arg</i></p>\n\n<p style=\"margin-left:22%;\">Make the given terminal the\ncontrolling terminal of the calling process. The calling\nprocess must be a session leader and not have a controlling\nterminal already. For this case, <i>arg</i> should be\nspecified as zero.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If this\nterminal is already the controlling terminal of a different\nsession group, then the ioctl fails with <b>EPERM</b>,\nunless the caller has the <b>CAP_SYS_ADMIN</b> capability\nand <i>arg</i> equals 1, in which case the terminal is\nstolen, and all processes that had it as controlling\nterminal lose it.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCNOTTY void</b></p>\n\n<p style=\"margin-left:22%;\">If the given terminal was the\ncontrolling terminal of the calling process, give up this\ncontrolling terminal. If the process was session leader,\nthen send <b>SIGHUP</b> and <b>SIGCONT</b> to the foreground\nprocess group and all processes in the current session lose\ntheir controlling terminal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Process\ngroup and session ID <br>\nTIOCGPGRP pid_t *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">When successful, equivalent to\n<i>*argp = tcgetpgrp(fd)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Get the process\ngroup ID of the foreground process group on this\nterminal.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCSPGRP const pid_t\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Equivalent to <i>tcsetpgrp(fd,\n*argp)</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Set the\nforeground process group ID of this terminal.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCGSID pid_t\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Get the session ID of the given\nterminal. This fails with the error <b>ENOTTY</b> if the\nterminal is not a master pseudoterminal and not our\ncontrolling terminal. Strange.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Exclusive\nmode <br>\nTIOCEXCL void</b></p>\n\n<p style=\"margin-left:22%;\">Put the terminal into exclusive\nmode. No further <a href=\"https://man.page/2/open\">open(2)</a> operations on the terminal\nare permitted. (They fail with <b>EBUSY</b>, except for a\nprocess with the <b>CAP_SYS_ADMIN</b> capability.)</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCGEXCL int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">(since Linux 3.8) If the\nterminal is currently in exclusive mode, place a nonzero\nvalue in the location pointed to by <i>argp</i>; otherwise,\nplace zero in <i>*argp</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCNXCL void</b></p>\n\n<p style=\"margin-left:22%;\">Disable exclusive mode.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Line\ndiscipline <br>\nTIOCGETD int *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Get the line discipline of the\nterminal.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCSETD const int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Set the line discipline of the\nterminal.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Pseudoterminal\nioctls <br>\nTIOCPKT const int *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Enable (when *<i>argp</i> is\nnonzero) or disable packet mode. Can be applied to the\nmaster side of a pseudoterminal only (and will return\n<b>ENOTTY</b> otherwise). In packet mode, each subsequent\n<a href=\"https://man.page/2/read\">read(2)</a> will return a packet that either contains a\nsingle nonzero control byte, or has a single byte containing\nzero ('\\0') followed by data written on the slave side of\nthe pseudoterminal. If the first byte is not\n<b>TIOCPKT_DATA</b> (0), it is an OR of one or more of the\nfollowing bits:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3242411.png\" alt=\"Image grohtml-3242411.png\"></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">While packet\nmode is in use, the presence of control status information\nto be read from the master side may be detected by a\n<a href=\"https://man.page/2/select\">select(2)</a> for exceptional conditions or a\n<a href=\"https://man.page/2/poll\">poll(2)</a> for the <b>POLLPRI</b> event.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This mode is\nused by <a href=\"https://man.page/1/rlogin\">rlogin(1)</a> and <b>rlogind</b>(8) to implement\na remote-echoed, locally <b>^S</b>/<b>^Q</b> flow-controlled\nremote login.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCGPKT const int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">(since Linux 3.8) Return the\ncurrent packet mode setting in the integer pointed to by\n<i>argp</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCSPTLCK int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Set (if <i>*argp</i> is\nnonzero) or remove (if <i>*argp</i> is zero) the lock on the\npseudoterminal slave device. (See also\n<a href=\"https://man.page/3/unlockpt\">unlockpt(3)</a>.)</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCGPTLCK int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">(since Linux 3.8) Place the\ncurrent lock state of the pseudoterminal slave device in the\nlocation pointed to by <i>argp</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCGPTPEER int</b>\n<i>flags</i></p>\n\n<p style=\"margin-left:22%;\">(since Linux 4.13) Given a file\ndescriptor in <i>fd</i> that refers to a pseudoterminal\nmaster, open (with the given <a href=\"https://man.page/2/open\">open(2)</a>-style\n<i>flags</i>) and return a new file descriptor that refers\nto the peer pseudoterminal slave device. This operation can\nbe performed regardless of whether the pathname of the slave\ndevice is accessible through the calling process&rsquo;s\nmount namespace.</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\">Security-conscious\nprograms interacting with namespaces may wish to use this\noperation rather than <a href=\"https://man.page/2/open\">open(2)</a> with the pathname\nreturned by <a href=\"https://man.page/3/ptsname\">ptsname(3)</a>, and similar library functions\nthat have insecure APIs. (For example, confusion can occur\nin some cases using <a href=\"https://man.page/3/ptsname\">ptsname(3)</a> with a pathname where\na devpts filesystem has been mounted in a different mount\nnamespace.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The BSD ioctls\n<b>TIOCSTOP</b>, <b>TIOCSTART</b>, <b>TIOCUCNTL</b>,\n<b>TIOCREMOTE</b> have not been implemented under Linux.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Modem\ncontrol <br>\nTIOCMGET int *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Get the status of modem\nbits.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCMSET const int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Set the status of modem\nbits.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCMBIC const int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Clear the indicated modem\nbits.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCMBIS const int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Set the indicated modem\nbits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nbits are used by the above ioctls:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3242412.png\" alt=\"Image grohtml-3242412.png\"></p>\n\n<p style=\"margin-left:11%;\"><b>TIOCMIWAIT int</b>\n<i>arg</i></p>\n\n<p style=\"margin-left:22%;\">Wait for any of the 4 modem\nbits (DCD, RI, DSR, CTS) to change. The bits of interest are\nspecified as a bit mask in <i>arg</i>, by ORing together any\nof the bit values, <b>TIOCM_RNG</b>, <b>TIOCM_DSR</b>,\n<b>TIOCM_CD</b>, and <b>TIOCM_CTS</b>. The caller should use\n<b>TIOCGICOUNT</b> to see which bit has changed.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCGICOUNT struct\nserial_icounter_struct *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Get counts of input serial line\ninterrupts (DCD, RI, DSR, CTS). The counts are written to\nthe <i>serial_icounter_struct</i> structure pointed to by\n<i>argp</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note: both\n1-&gt;0 and 0-&gt;1 transitions are counted, except for RI,\nwhere only 0-&gt;1 transitions are counted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Marking a\nline as local <br>\nTIOCGSOFTCAR int *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">(&quot;Get software carrier\nflag&quot;) Get the status of the CLOCAL flag in the c_cflag\nfield of the <i>termios</i> structure.</p>\n\n<p style=\"margin-left:11%;\"><b>TIOCSSOFTCAR const int\n*</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">(&quot;Set software carrier\nflag&quot;) Set the CLOCAL flag in the <i>termios</i>\nstructure when *<i>argp</i> is nonzero, and clear it\notherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>CLOCAL</b> flag for a line is off, the hardware carrier\ndetect (DCD) signal is significant, and an <a href=\"https://man.page/2/open\">open(2)</a> of\nthe corresponding terminal will block until DCD is asserted,\nunless the <b>O_NONBLOCK</b> flag is given. If <b>CLOCAL</b>\nis set, the line behaves as if DCD is always asserted. The\nsoftware carrier flag is usually turned on for local\ndevices, and is off for lines with modems.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Linux-specific</b>\n<br>\nFor the <b>TIOCLINUX</b> ioctl, see\n<a href=\"https://man.page/2/ioctl_console\">ioctl_console(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Kernel\ndebugging <br>\n#include &lt;linux/tty.h&gt; <br>\nTIOCTTYGSTRUCT struct tty_struct *</b><i>argp</i></p>\n\n<p style=\"margin-left:22%;\">Get the <i>tty_struct</i>\ncorresponding to <i>fd</i>. This command was removed in\nLinux 2.5.67.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> system call returns 0 on success. On error,\nit returns -1 and sets <i>errno</i> appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p style=\"margin-top: 1em\">Invalid command parameter.</p></td>\n<td width=\"38%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOIOCTLCMD</b></p>\n\n<p style=\"margin-left:22%;\">Unknown command.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOTTY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"36%\">\n\n\n<p>Inappropriate <i>fd</i>.</p></td>\n<td width=\"42%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"36%\">\n\n\n<p>Insufficient permission.</p></td>\n<td width=\"42%\">\n</td></tr>\n</table>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Check the\ncondition of DTR on the serial port.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;termios.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;sys/ioctl.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(void) <br>\n{ <br>\nint fd, serial;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(&quot;/dev/ttyS0&quot;, O_RDONLY); <br>\nioctl(fd, TIOCMGET, &amp;serial); <br>\nif (serial &amp; TIOCM_DTR) <br>\nputs(&quot;TIOCM_DTR is set&quot;); <br>\nelse <br>\nputs(&quot;TIOCM_DTR is not set&quot;); <br>\nclose(fd); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/ldattach\">ldattach(1)</a>,\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a>, <a href=\"https://man.page/2/ioctl_console\">ioctl_console(2)</a>, <a href=\"https://man.page/3/termios\">termios(3)</a>,\n<a href=\"https://man.page/7/pty\">pty(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}