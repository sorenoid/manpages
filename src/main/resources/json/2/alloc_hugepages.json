{"name":"alloc_hugepages","description":"alloc_hugepages, free_hugepages - allocate or free huge pages","body":"\n\n<h1 align=\"center\">ALLOC_HUGEPAGES</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">alloc_hugepages,\nfree_hugepages - allocate or free huge pages</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*alloc_hugepages(int</b> <i>key</i><b>, void\n*</b><i>addr</i><b>, size_t</b> <i>len</i><b>, <br>\nint</b> <i>prot</i><b>, int</b> <i>flag</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nfree_hugepages(void *</b><i>addr</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The system\ncalls <b>alloc_hugepages</b>() and <b>free_hugepages</b>()\nwere introduced in Linux 2.5.36 and removed again in 2.5.54.\nThey existed only on i386 and ia64 (when built with\n<b>CONFIG_HUGETLB_PAGE</b>). In Linux 2.4.20, the syscall\nnumbers exist, but the calls fail with the error\n<b>ENOSYS</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On i386 the\nmemory management hardware knows about ordinary pages\n(4&nbsp;KiB) and huge pages (2 or 4&nbsp;MiB). Similarly\nia64 knows about huge pages of several sizes. These system\ncalls serve to map huge pages into the process&rsquo;s\nmemory or to free them again. Huge pages are locked into\nmemory, and are not swapped.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>key</i>\nargument is an identifier. When zero the pages are private,\nand not inherited by children. When positive the pages are\nshared with other applications using the same <i>key</i>,\nand inherited by child processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>addr</i>\nargument of <b>free_hugepages</b>() tells which page is\nbeing freed: it was the return value of a call to\n<b>alloc_hugepages</b>(). (The memory is first actually\nfreed when all users have released it.) The <i>addr</i>\nargument of <b>alloc_hugepages</b>() is a hint, that the\nkernel may or may not follow. Addresses must be properly\naligned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>len</i>\nargument is the length of the required segment. It must be a\nmultiple of the huge page size.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>prot</i>\nargument specifies the memory protection of the segment. It\nis one of <b>PROT_READ</b>, <b>PROT_WRITE</b>,\n<b>PROT_EXEC</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>flag</i>\nargument is ignored, unless <i>key</i> is positive. In that\ncase, if <i>flag</i> is <b>IPC_CREAT</b>, then a new huge\npage segment is created when none with the given key\nexisted. If this flag is not set, then <b>ENOENT</b> is\nreturned when no segment with the given key exists.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>alloc_hugepages</b>() returns the allocated virtual\naddress, and <b>free_hugepages</b>() returns zero. On error,\n-1 is returned, and <i>errno</i> is set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"73%\">\n\n\n<p style=\"margin-top: 1em\">The system call is not supported\non this kernel.</p></td>\n<td width=\"5%\">\n</td></tr>\n</table>\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>/proc/sys/vm/nr_hugepages</i></p>\n\n<p style=\"margin-left:22%;\">Number of configured hugetlb\npages. This can be read and written.</p>\n\n<p style=\"margin-left:11%;\"><i>/proc/meminfo</i></p>\n\n<p style=\"margin-left:22%;\">Gives info on the number of\nconfigured hugetlb pages and on their size in the three\nvariables HugePages_Total, HugePages_Free, Hugepagesize.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These calls are\nspecific to Linux on Intel processors, and should not be\nused in programs intended to be portable.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls are gone; they existed only in Linux 2.5.36 through to\n2.5.54. Now the hugetlbfs filesystem can be used instead.\nMemory backed by huge pages (if the CPU supports them) is\nobtained by using <a href=\"https://man.page/2/mmap\">mmap(2)</a> to map files in this\nvirtual filesystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The maximal\nnumber of huge pages can be specified using the\n<b>hugepages=</b> boot parameter.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#FILES\">FILES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}