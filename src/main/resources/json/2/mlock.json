{"name":"mlock","description":"mlock, mlock2,\nmunlock, mlockall, munlockall - lock and unlock memory","body":"\n\n<h1 align=\"center\">MLOCK</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">mlock, mlock2,\nmunlock, mlockall, munlockall - lock and unlock memory</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/mman.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nmlock(const void *</b><i>addr</i><b>, size_t</b>\n<i>len</i><b>); <br>\nint mlock2(const void *</b><i>addr</i><b>, size_t</b>\n<i>len</i><b>, int</b> <i>flags</i><b>); <br>\nint munlock(const void *</b><i>addr</i><b>, size_t</b>\n<i>len</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nmlockall(int</b> <i>flags</i><b>); <br>\nint munlockall(void);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mlock</b>(),\n<b>mlock2</b>(), and <b>mlockall</b>() lock part or all of\nthe calling process&rsquo;s virtual address space into RAM,\npreventing that memory from being paged to the swap\narea.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>munlock</b>()\nand <b>munlockall</b>() perform the converse operation,\nunlocking part or all of the calling process&rsquo;s virtual\naddress space, so that pages in the specified virtual\naddress range may once more to be swapped out if required by\nthe kernel memory manager.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Memory locking\nand unlocking are performed in units of whole pages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mlock(),\nmlock2(), and munlock() <br>\nmlock</b>() locks pages in the address range starting at\n<i>addr</i> and continuing for <i>len</i> bytes. All pages\nthat contain a part of the specified address range are\nguaranteed to be resident in RAM when the call returns\nsuccessfully; the pages are guaranteed to stay in RAM until\nlater unlocked.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mlock2</b>()\nalso locks pages in the specified range starting at\n<i>addr</i> and continuing for <i>len</i> bytes. However,\nthe state of the pages contained in that range after the\ncall returns successfully will depend on the value in the\n<i>flags</i> argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument can be either 0 or the following\nconstant: <b><br>\nMLOCK_ONFAULT</b></p>\n\n<p style=\"margin-left:22%;\">Lock pages that are currently\nresident and mark the entire range so that the remaining\nnonresident pages are locked when they are populated by a\npage fault.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>flags</i>\nis 0, <b>mlock2</b>() behaves exactly the same as\n<b>mlock</b>().</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>munlock</b>()\nunlocks pages in the address range starting at <i>addr</i>\nand continuing for <i>len</i> bytes. After this call, all\npages that contain a part of the specified memory range can\nbe moved to external swap space again by the kernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mlockall()\nand munlockall() <br>\nmlockall</b>() locks all pages mapped into the address space\nof the calling process. This includes the pages of the code,\ndata and stack segment, as well as shared libraries, user\nspace kernel data, shared memory, and memory-mapped files.\nAll mapped pages are guaranteed to be resident in RAM when\nthe call returns successfully; the pages are guaranteed to\nstay in RAM until later unlocked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument is constructed as the bitwise OR of\none or more of the following constants: <b><br>\nMCL_CURRENT</b></p>\n\n<p style=\"margin-left:22%;\">Lock all pages which are\ncurrently mapped into the address space of the process.</p>\n\n<p style=\"margin-left:11%;\"><b>MCL_FUTURE</b></p>\n\n<p style=\"margin-left:22%;\">Lock all pages which will\nbecome mapped into the address space of the process in the\nfuture. These could be, for instance, new pages required by\na growing heap and stack as well as new memory-mapped files\nor shared memory regions.</p>\n\n<p style=\"margin-left:11%;\"><b>MCL_ONFAULT</b> (since Linux\n4.4)</p>\n\n<p style=\"margin-left:22%;\">Used together with\n<b>MCL_CURRENT</b>, <b>MCL_FUTURE</b>, or both. Mark all\ncurrent (with <b>MCL_CURRENT</b>) or future (with\n<b>MCL_FUTURE</b>) mappings to lock pages when they are\nfaulted in. When used with <b>MCL_CURRENT</b>, all present\npages are locked, but <b>mlockall</b>() will not fault in\nnon-present pages. When used with <b>MCL_FUTURE</b>, all\nfuture mappings will be marked to lock pages when they are\nfaulted in, but they will not be populated by the lock when\nthe mapping is created. <b>MCL_ONFAULT</b> must be used with\neither <b>MCL_CURRENT</b> or <b>MCL_FUTURE</b> or both.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>MCL_FUTURE</b> has been specified, then a later system\ncall (e.g., <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/sbrk\">sbrk(2)</a>,\n<a href=\"https://man.page/3/malloc\">malloc(3)</a>), may fail if it would cause the number of\nlocked bytes to exceed the permitted maximum (see below). In\nthe same circumstances, stack growth may likewise fail: the\nkernel will deny stack expansion and deliver a\n<b>SIGSEGV</b> signal to the process.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>munlockall</b>()\nunlocks all pages mapped into the address space of the\ncalling process.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\nthese system calls return 0. On error, -1 is returned,\n<i>errno</i> is set appropriately, and no changes are made\nto any locks in the address space of the process.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">(Linux 2.6.9 and later) the\ncaller had a nonzero <b>RLIMIT_MEMLOCK</b> soft resource\nlimit, but tried to lock more memory than the limit\npermitted. This limit is not enforced if the process is\nprivileged (<b>CAP_IPC_LOCK</b>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(Linux 2.4 and earlier) the calling process tried to\nlock more than half of RAM.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The caller is not privileged, but needs privilege\n(<b>CAP_IPC_LOCK</b>) to perform the requested\noperation.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>mlock</b>(), <b>mlock2</b>(), and <b>munlock</b>():</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Some or all of the specified\naddress range could not be locked.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The result of the addition <i>addr</i>+<i>len</i> was\nless than <i>addr</i> (e.g., the addition may have resulted\nin an overflow).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(Not on Linux) <i>addr</i> was not a multiple of the\npage size.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Some of the specified address range does not correspond\nto mapped pages in the address space of the process.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Locking or unlocking a region would result in the total\nnumber of mappings with distinct attributes (e.g., locked\nversus unlocked) exceeding the allowed maximum. (For\nexample, unlocking a range in the middle of a currently\nlocked mapping would result in three mappings: two locked\nmappings at each end and an unlocked mapping in the\nmiddle.)</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>mlock2</b>():</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"44%\">\n\n\n<p style=\"margin-top: 1em\">Unknown <i>flags</i> were\nspecified.</p> </td>\n<td width=\"34%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>mlockall</b>():</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Unknown <i>flags</i> were\nspecified or <b>MCL_ONFAULT</b> was specified without either\n<b>MCL_FUTURE</b> or <b>MCL_CURRENT</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>munlockall</b>():</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">(Linux 2.6.8 and earlier) The\ncaller was not privileged (<b>CAP_IPC_LOCK</b>).</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mlock2</b>()\nis available since Linux 4.4; glibc support was added in\nversion 2.27.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008, SVr4.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mlock2</b>()\nis Linux specific.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On POSIX\nsystems on which <b>mlock</b>() and <b>munlock</b>() are\navailable, <b>_POSIX_MEMLOCK_RANGE</b> is defined in\n<i>&lt;unistd.h&gt;</i> and the number of bytes in a page\ncan be determined from the constant <b>PAGESIZE</b> (if\ndefined) in <i>&lt;limits.h&gt;</i> or by calling\n<i>sysconf(_SC_PAGESIZE)</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On POSIX\nsystems on which <b>mlockall</b>() and <b>munlockall</b>()\nare available, <b>_POSIX_MEMLOCK</b> is defined in\n<i>&lt;unistd.h&gt;</i> to a value greater than 0. (See also\n<a href=\"https://man.page/3/sysconf\">sysconf(3)</a>.)</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Memory locking\nhas two main applications: real-time algorithms and\nhigh-security data processing. Real-time applications\nrequire deterministic timing, and, like scheduling, paging\nis one major cause of unexpected program execution delays.\nReal-time applications will usually also switch to a\nreal-time scheduler with <a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a>.\nCryptographic security software often handles critical bytes\nlike passwords or secret keys as data structures. As a\nresult of paging, these secrets could be transferred onto a\npersistent swap store medium, where they might be accessible\nto the enemy long after the security software has erased the\nsecrets in RAM and terminated. (But be aware that the\nsuspend mode on laptops and some desktop computers will save\na copy of the system&rsquo;s RAM to disk, regardless of\nmemory locks.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Real-time\nprocesses that are using <b>mlockall</b>() to prevent delays\non page faults should reserve enough locked stack pages\nbefore entering the time-critical section, so that no page\nfault can be caused by function calls. This can be achieved\nby calling a function that allocates a sufficiently large\nautomatic variable (an array) and writes to the memory\noccupied by this array in order to touch these stack pages.\nThis way, enough pages will be mapped for the stack and can\nbe locked into RAM. The dummy writes ensure that not even\ncopy-on-write page faults can occur in the critical\nsection.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Memory locks\nare not inherited by a child created via <a href=\"https://man.page/2/fork\">fork(2)</a> and\nare automatically removed (unlocked) during an\n<a href=\"https://man.page/2/execve\">execve(2)</a> or when the process terminates. The\n<b>mlockall</b>() <b>MCL_FUTURE</b> and <b>MCL_FUTURE |\nMCL_ONFAULT</b> settings are not inherited by a child\ncreated via <a href=\"https://man.page/2/fork\">fork(2)</a> and are cleared during an\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\n<a href=\"https://man.page/2/fork\">fork(2)</a> will prepare the address space for a\ncopy-on-write operation. The consequence is that any write\naccess that follows will cause a page fault that in turn may\ncause high latencies for a real-time process. Therefore, it\nis crucial not to invoke <a href=\"https://man.page/2/fork\">fork(2)</a> after an\n<b>mlockall</b>() or <b>mlock</b>() operation&mdash;not even\nfrom a thread which runs at a low priority within a process\nwhich also has a thread running at elevated priority.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The memory lock\non an address range is automatically removed if the address\nrange is unmapped via <a href=\"https://man.page/2/munmap\">munmap(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Memory locks do\nnot stack, that is, pages which have been locked several\ntimes by calls to <b>mlock</b>(), <b>mlock2</b>(), or\n<b>mlockall</b>() will be unlocked by a single call to\n<b>munlock</b>() for the corresponding range or by\n<b>munlockall</b>(). Pages which are mapped to several\nlocations or by several processes stay locked into RAM as\nlong as they are locked at least at one location or by at\nleast one process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a call to\n<b>mlockall</b>() which uses the <b>MCL_FUTURE</b> flag is\nfollowed by another call that does not specify this flag,\nthe changes made by the <b>MCL_FUTURE</b> call will be\nlost.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>mlock2</b>() <b>MLOCK_ONFAULT</b> flag and the\n<b>mlockall</b>() <b>MCL_ONFAULT</b> flag allow efficient\nmemory locking for applications that deal with large\nmappings where only a (small) portion of pages in the\nmapping are touched. In such cases, locking all of the pages\nin a mapping would incur a significant penalty for memory\nlocking.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Linux\nnotes</b> <br>\nUnder Linux, <b>mlock</b>(), <b>mlock2</b>(), and\n<b>munlock</b>() automatically round <i>addr</i> down to the\nnearest page boundary. However, the POSIX.1 specification of\n<b>mlock</b>() and <b>munlock</b>() allows an implementation\nto require that <i>addr</i> is page aligned, so portable\napplications should ensure this.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>VmLck</i> field of the Linux-specific\n<i>/proc/[pid]/status</i> file shows how many kilobytes of\nmemory the process with ID <i>PID</i> has locked using\n<b>mlock</b>(), <b>mlock2</b>(), <b>mlockall</b>(), and\n<a href=\"https://man.page/2/mmap\">mmap(2)</a> <b>MAP_LOCKED</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Limits and\npermissions</b> <br>\nIn Linux 2.6.8 and earlier, a process must be privileged\n(<b>CAP_IPC_LOCK</b>) in order to lock memory and the\n<b>RLIMIT_MEMLOCK</b> soft resource limit defines a limit on\nhow much memory the process may lock.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6.9, no limits are placed on the amount of memory that a\nprivileged process can lock and the <b>RLIMIT_MEMLOCK</b>\nsoft resource limit instead defines a limit on how much\nmemory an unprivileged process may lock.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux 4.8\nand earlier, a bug in the kernel&rsquo;s accounting of\nlocked memory for unprivileged processes (i.e., without\n<b>CAP_IPC_LOCK</b>) meant that if the region specified by\n<i>addr</i> and <i>len</i> overlapped an existing lock, then\nthe already locked bytes in the overlapping region were\ncounted twice when checking against the limit. Such double\naccounting could incorrectly calculate a &quot;total locked\nmemory&quot; value for the process that exceeded the\n<b>RLIMIT_MEMLOCK</b> limit, with the result that\n<b>mlock</b>() and <b>mlock2</b>() would fail on requests\nthat should have succeeded. This bug was fixed in Linux\n4.9.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the 2.4\nseries Linux kernels up to and including 2.4.17, a bug\ncaused the <b>mlockall</b>() <b>MCL_FUTURE</b> flag to be\ninherited across a <a href=\"https://man.page/2/fork\">fork(2)</a>. This was rectified in\nkernel 2.4.18.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since kernel\n2.6.9, if a privileged process calls\n<i>mlockall(MCL_FUTURE)</i> and later drops privileges\n(loses the <b>CAP_IPC_LOCK</b> capability by, for example,\nsetting its effective UID to a nonzero value), then\nsubsequent memory allocations (e.g., <a href=\"https://man.page/2/mmap\">mmap(2)</a>,\n<a href=\"https://man.page/2/brk\">brk(2)</a>) will fail if the <b>RLIMIT_MEMLOCK</b>\nresource limit is encountered.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/mincore\">mincore(2)</a>,\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>, <a href=\"https://man.page/2/shmctl\">shmctl(2)</a>,\n<a href=\"https://man.page/3/sysconf\">sysconf(3)</a>, <a href=\"https://man.page/5/proc\">proc(5)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}