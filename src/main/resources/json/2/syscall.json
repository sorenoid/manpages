{"name":"syscall","description":"syscall - indirect system call","body":"\n\n<h1 align=\"center\">SYSCALL</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">syscall -\nindirect system call</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;unistd.h&gt; <br>\n#include &lt;sys/syscall.h&gt;</b> /* For SYS_xxx\ndefinitions */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>long\nsyscall(long</b> <i>number</i><b>, ...);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n<p style=\"margin-left:11%;\"><b>syscall</b>():</p>\n\n<p style=\"margin-left:17%;\">Since glibc 2.19:</p>\n\n<p style=\"margin-left:23%;\">_DEFAULT_SOURCE</p>\n\n<p style=\"margin-left:17%;\">Before glibc 2.19:</p>\n\n<p style=\"margin-left:23%;\">_BSD_SOURCE || _SVID_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>syscall</b>()\nis a small library function that invokes the system call\nwhose assembly language interface has the specified\n<i>number</i> with the specified arguments. Employing\n<b>syscall</b>() is useful, for example, when invoking a\nsystem call that has no wrapper function in the C\nlibrary.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>syscall</b>()\nsaves CPU registers before making the system call, restores\nthe registers upon return from the system call, and stores\nany error returned by the system call in\n<a href=\"https://man.page/3/errno\">errno(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Symbolic\nconstants for system call numbers can be found in the header\nfile <i>&lt;sys/syscall.h&gt;</i>.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The return\nvalue is defined by the system call being invoked. In\ngeneral, a 0 return value indicates success. A -1 return\nvalue indicates an error, and an error number is stored in\n<i>errno</i>.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>syscall</b>()\nfirst appeared in 4BSD.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Architecture-specific\nrequirements</b> <br>\nEach architecture ABI has its own requirements on how system\ncall arguments are passed to the kernel. For system calls\nthat have a glibc wrapper (e.g., most system calls), glibc\nhandles the details of copying arguments to the right\nregisters in a manner suitable for the architecture.\nHowever, when using <b>syscall</b>() to make a system call,\nthe caller might need to handle architecture-dependent\ndetails; this requirement is most commonly encountered on\ncertain 32-bit architectures.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example, on\nthe ARM architecture Embedded ABI (EABI), a 64-bit value\n(e.g., <i>long long</i>) must be aligned to an even register\npair. Thus, using <b>syscall</b>() instead of the wrapper\nprovided by glibc, the <a href=\"https://man.page/2/readahead\">readahead(2)</a> system call would\nbe invoked as follows on the ARM architecture with the EABI\nin little endian mode:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">syscall(SYS_readahead,\nfd, 0, <br>\n(unsigned int) (offset &amp; 0xFFFFFFFF), <br>\n(unsigned int) (offset &gt;&gt; 32), <br>\ncount);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since the\noffset argument is 64 bits, and the first argument\n(<i>fd</i>) is passed in <i>r0</i>, the caller must manually\nsplit and align the 64-bit value so that it is passed in the\n<i>r2</i>/<i>r3</i> register pair. That means inserting a\ndummy value into <i>r1</i> (the second argument of 0). Care\nalso must be taken so that the split follows endian\nconventions (according to the C ABI for the platform).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Similar issues\ncan occur on MIPS with the O32 ABI, on PowerPC and parisc\nwith the 32-bit ABI, and on Xtensa.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that while\nthe parisc C ABI also uses aligned register pairs, it uses a\nshim layer to hide the issue from user space.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The affected\nsystem calls are <a href=\"https://man.page/2/fadvise64_64\">fadvise64_64(2)</a>,\n<a href=\"https://man.page/2/ftruncate64\">ftruncate64(2)</a>, <a href=\"https://man.page/2/posix_fadvise\">posix_fadvise(2)</a>,\n<a href=\"https://man.page/2/pread64\">pread64(2)</a>, <a href=\"https://man.page/2/pwrite64\">pwrite64(2)</a>, <a href=\"https://man.page/2/readahead\">readahead(2)</a>,\n<a href=\"https://man.page/2/sync_file_range\">sync_file_range(2)</a>, and <a href=\"https://man.page/2/truncate64\">truncate64(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This does not\naffect syscalls that manually split and assemble 64-bit\nvalues such as <a href=\"https://man.page/2/_llseek\">_llseek(2)</a>, <a href=\"https://man.page/2/preadv\">preadv(2)</a>,\n<a href=\"https://man.page/2/preadv2\">preadv2(2)</a>, <a href=\"https://man.page/2/pwritev\">pwritev(2)</a>, and\n<a href=\"https://man.page/2/pwritev2\">pwritev2(2)</a>. Welcome to the wonderful world of\nhistorical baggage.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Architecture\ncalling conventions</b> <br>\nEvery architecture has its own way of invoking and passing\narguments to the kernel. The details for various\narchitectures are listed in the two tables below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first table\nlists the instruction used to transition to kernel mode\n(which might not be the fastest or best way to transition to\nthe kernel, so you might have to refer to <a href=\"https://man.page/7/vdso\">vdso(7)</a>),\nthe register used to indicate the system call number, the\nregister(s) used to return the system call result, and the\nregister used to signal an error.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3248071.png\" alt=\"Image grohtml-3248071.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notes:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>[1]</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>On a few architectures, a register is used as a boolean\n(0 indicating no error, and -1 indicating an error) to\nsignal that the system call failed. The actual error value\nis still contained in the return register. On sparc, the\ncarry bit (<i>csr</i>) in the processor status register\n(<i>psr</i>) is used instead of a full register. On\npowerpc64, the summary overflow bit (<i>SO</i>) in field 0\nof the condition register (<i>cr0</i>) is used.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>[2]</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p><i>NR</i> is the system call number.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>[3]</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>For s390 and s390x, <i>NR</i> (the system call number)\nmay be passed directly with <i>svc&nbsp;NR</i> if it is less\nthan 256.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>[4]</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>On SuperH, the trap number controls the maximum number\nof arguments passed. A <i>trap&nbsp;#0x10</i> can be used\nwith only 0-argument system calls, a <i>trap&nbsp;#0x11</i>\ncan be used with 0- or 1-argument system calls, and so on up\nto <i>trap #0x17</i> for 7-argument system calls.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>[5]</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>The x32 ABI shares syscall table with x86-64 ABI, but\nthere are some nuances:</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\"></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">In order to indicate that a\nsystem call is called under the x32 ABI, an additional bit,\n<b>__X32_SYSCALL_BIT</b>, is bitwise-ORed with the system\ncall number. The ABI used by a process affects some process\nbehaviors, including signal handling or system call\nrestarting.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p>&bull;</p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Since x32 has different sizes for <i>long</i> and\npointer types, layouts of some (but not all; <i>struct\ntimeval</i> or <i>struct rlimit</i> are 64-bit, for example)\nstructures are different. In order to handle this,\nadditional system calls are added to the system call table,\nstarting from number 512 (without the\n<b>__X32_SYSCALL_BIT</b>). For example, <b>__NR_readv</b> is\ndefined as 19 for the x86-64 ABI and as\n<i>__X32_SYSCALL_BIT</i> | <b>515</b> for the x32 ABI. Most\nof these additional system calls are actually identical to\nthe system calls used for providing i386 compat. There are\nsome notable exceptions, however, such as <a href=\"https://man.page/2/preadv2\">preadv2(2)</a>,\nwhich uses <i>struct iovec</i> entities with 4-byte pointers\nand sizes (&quot;compat_iovec&quot; in kernel terms), but\npasses an 8-byte <i>pos</i> argument in a single register\nand not two, as is done in every other ABI.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p>[6]</p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Some\narchitectures (namely, Alpha, IA-64, MIPS, SuperH, sparc/32,\nand sparc/64) use an additional register\n(&quot;Retval2&quot; in the above table) to pass back a\nsecond return value from the <a href=\"https://man.page/2/pipe\">pipe(2)</a> system call;\nAlpha uses this technique in the architecture-specific\n<a href=\"https://man.page/2/getxpid\">getxpid(2)</a>, <a href=\"https://man.page/2/getxuid\">getxuid(2)</a>, and <a href=\"https://man.page/2/getxgid\">getxgid(2)</a>\nsystem calls as well. Other architectures do not use the\nsecond return value register in the system call interface,\neven if it is defined in the System V ABI.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second\ntable shows the registers used to pass the system call\narguments.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3248072.png\" alt=\"Image grohtml-3248072.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notes:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">[1]</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">The mips/o32 system call\nconvention passes arguments 5 through 8 on the user\nstack.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that these\ntables don&rsquo;t cover the entire calling\nconvention&mdash;some architectures may indiscriminately\nclobber other registers not listed here.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\n_GNU_SOURCE <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/syscall.h&gt; <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;signal.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\npid_t tid;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">tid =\nsyscall(SYS_gettid); <br>\nsyscall(SYS_tgkill, getpid(), tid, SIGHUP); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/_syscall\">_syscall(2)</a>,\n<a href=\"https://man.page/2/intro\">intro(2)</a>, <a href=\"https://man.page/2/syscalls\">syscalls(2)</a>, <a href=\"https://man.page/3/errno\">errno(3)</a>,\n<a href=\"https://man.page/7/vdso\">vdso(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}