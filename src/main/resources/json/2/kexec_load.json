{"name":"kexec_load","description":"kexec_load, kexec_file_load - load a new kernel for later execution","body":"\n\n<h1 align=\"center\">KEXEC_LOAD</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">kexec_load,\nkexec_file_load - load a new kernel for later execution</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;linux/kexec.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>long\nkexec_load(unsigned long</b> <i>entry</i><b>, unsigned\nlong</b> <i>nr_segments</i><b>, <br>\nstruct kexec_segment *</b><i>segments</i><b>, unsigned\nlong</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>long\nkexec_file_load(int</b> <i>kernel_fd</i><b>, int</b>\n<i>initrd_fd</i><b>, <br>\nunsigned long</b> <i>cmdline_len</i><b>, const char\n*</b><i>cmdline</i><b>, <br>\nunsigned long</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere are no glibc wrappers for these system calls; see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>kexec_load</b>() system call loads a new kernel that can\nbe executed later by <a href=\"https://man.page/2/reboot\">reboot(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument is a bit mask that controls the\noperation of the call. The following values can be specified\nin <i>flags</i>: <b><br>\nKEXEC_ON_CRASH</b> (since Linux 2.6.13)</p>\n\n<p style=\"margin-left:22%;\">Execute the new kernel\nautomatically on a system crash. This &quot;crash\nkernel&quot; is loaded into an area of reserved memory that\nis determined at boot time using the <i>crashkernel</i>\nkernel command-line parameter. The location of this reserved\nmemory is exported to user space via the <i>/proc/iomem</i>\nfile, in an entry labeled &quot;Crash kernel&quot;. A\nuser-space application can parse this file and prepare a\nlist of segments (see below) that specify this reserved\nmemory as destination. If this flag is specified, the kernel\nchecks that the target segments specified in <i>segments</i>\nfall within the reserved region.</p>\n\n<p style=\"margin-left:11%;\"><b>KEXEC_PRESERVE_CONTEXT</b>\n(since Linux 2.6.27)</p>\n\n<p style=\"margin-left:22%;\">Preserve the system hardware\nand software states before executing the new kernel. This\ncould be used for system suspend. This flag is available\nonly if the kernel was configured with\n<b>CONFIG_KEXEC_JUMP</b>, and is effective only if\n<i>nr_segments</i> is greater than 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The high-order\nbits (corresponding to the mask 0xffff0000) of <i>flags</i>\ncontain the architecture of the to-be-executed kernel.\nSpecify (OR) the constant <b>KEXEC_ARCH_DEFAULT</b> to use\nthe current architecture, or one of the following\narchitecture constants <b>KEXEC_ARCH_386</b>,\n<b>KEXEC_ARCH_68K</b>, <b>KEXEC_ARCH_X86_64</b>,\n<b>KEXEC_ARCH_PPC</b>, <b>KEXEC_ARCH_PPC64</b>,\n<b>KEXEC_ARCH_IA_64</b>, <b>KEXEC_ARCH_ARM</b>,\n<b>KEXEC_ARCH_S390</b>, <b>KEXEC_ARCH_SH</b>,\n<b>KEXEC_ARCH_MIPS</b>, and <b>KEXEC_ARCH_MIPS_LE</b>. The\narchitecture must be executable on the CPU of the\nsystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>entry</i> argument is the physical entry address in the\nkernel image. The <i>nr_segments</i> argument is the number\nof segments pointed to by the <i>segments</i> pointer; the\nkernel imposes an (arbitrary) limit of 16 on the number of\nsegments. The <i>segments</i> argument is an array of\n<i>kexec_segment</i> structures which define the kernel\nlayout:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nkexec_segment { <br>\nvoid *buf; /* Buffer in user space */ <br>\nsize_t bufsz; /* Buffer length in user space */ <br>\nvoid *mem; /* Physical address of kernel */ <br>\nsize_t memsz; /* Physical address length */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\nimage defined by <i>segments</i> is copied from the calling\nprocess into the kernel either in regular memory or in\nreserved memory (if <b>KEXEC_ON_CRASH</b> is set). The\nkernel first performs various sanity checks on the\ninformation passed in <i>segments</i>. If these checks pass,\nthe kernel copies the segment data to kernel memory. Each\nsegment specified in <i>segments</i> is copied as\nfollows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>buf</i> and <i>bufsz</i> identify a memory region in\nthe caller&rsquo;s virtual address space that is the source\nof the copy. The value in <i>bufsz</i> may not exceed the\nvalue in the <i>memsz</i> field.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>mem</i> and <i>memsz</i> specify a physical address\nrange that is the target of the copy. The values specified\nin both fields must be multiples of the system page\nsize.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>bufsz</i> bytes are copied from the source buffer to\nthe target kernel buffer. If <i>bufsz</i> is less than\n<i>memsz</i>, then the excess bytes in the kernel buffer are\nzeroed out.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In case of a\nnormal kexec (i.e., the <b>KEXEC_ON_CRASH</b> flag is not\nset), the segment data is loaded in any available memory and\nis moved to the final destination at kexec reboot time\n(e.g., when the <b>kexec</b>(8) command is executed with the\n<i>-e</i> option).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In case of\nkexec on panic (i.e., the <b>KEXEC_ON_CRASH</b> flag is\nset), the segment data is loaded to reserved memory at the\ntime of the call, and, after a crash, the kexec mechanism\nsimply passes control to that kernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>kexec_load</b>() system call is available only if the\nkernel was configured with <b>CONFIG_KEXEC</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>kexec_file_load()</b>\n<br>\nThe <b>kexec_file_load</b>() system call is similar to\n<b>kexec_load</b>(), but it takes a different set of\narguments. It reads the kernel to be loaded from the file\nreferred to by the file descriptor <i>kernel_fd</i>, and the\ninitrd (initial RAM disk) to be loaded from file referred to\nby the file descriptor <i>initrd_fd</i>. The <i>cmdline</i>\nargument is a pointer to a buffer containing the command\nline for the new kernel. The <i>cmdline_len</i> argument\nspecifies size of the buffer. The last byte in the buffer\nmust be a null byte ('\\0').</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument is a bit mask which modifies the\nbehavior of the call. The following values can be specified\nin <i>flags</i>: <b><br>\nKEXEC_FILE_UNLOAD</b></p>\n\n<p style=\"margin-left:22%;\">Unload the currently loaded\nkernel.</p>\n\n<p style=\"margin-left:11%;\"><b>KEXEC_FILE_ON_CRASH</b></p>\n\n<p style=\"margin-left:22%;\">Load the new kernel in the\nmemory region reserved for the crash kernel (as for\n<b>KEXEC_ON_CRASH</b>). This kernel is booted if the\ncurrently running kernel crashes.</p>\n\n\n<p style=\"margin-left:11%;\"><b>KEXEC_FILE_NO_INITRAMFS</b></p>\n\n<p style=\"margin-left:22%;\">Loading initrd/initramfs is\noptional. Specify this flag if no initramfs is being loaded.\nIf this flag is set, the value passed in <i>initrd_fd</i> is\nignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>kexec_file_load</b>() system call was added to provide\nsupport for systems where &quot;kexec&quot; loading should\nbe restricted to only kernels that are signed. This system\ncall is available only if the kernel was configured with\n<b>CONFIG_KEXEC_FILE</b>.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\nthese system calls returns 0. On error, -1 is returned and\n<i>errno</i> is set to indicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>EADDRNOTAVAIL</b></p>\n\n<p style=\"margin-left:22%;\">The <b>KEXEC_ON_CRASH</b> flags\nwas specified, but the region specified by the <i>mem</i>\nand <i>memsz</i> fields of one of the <i>segments</i>\nentries lies outside the range of memory reserved for the\ncrash kernel.</p>\n\n<p style=\"margin-left:11%;\"><b>EADDRNOTAVAIL</b></p>\n\n<p style=\"margin-left:22%;\">The value in a <i>mem</i> or\n<i>memsz</i> field in one of the <i>segments</i> entries is\nnot a multiple of the system page size.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>kernel_fd</i> or <i>initrd_fd</i> is not a valid file\ndescriptor.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Another crash kernel is already being loaded or a crash\nkernel is already in use.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>flags</i> is invalid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The value of a <i>bufsz</i> field in one of the\n<i>segments</i> entries exceeds the value in the\ncorresponding <i>memsz</i> field.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>nr_segments</i> exceeds <b>KEXEC_SEGMENT_MAX</b>\n(16).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Two or more of the kernel target buffers overlap.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The value in <i>cmdline[cmdline_len-1]</i> is not\n'\\0'.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The file referred to by <i>kernel_fd</i> or\n<i>initrd_fd</i> is empty (length zero).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOEXEC</b></p>\n\n<p style=\"margin-left:22%;\"><i>kernel_fd</i> does not refer\nto an open file, or the kernel can&rsquo;t load this file.\nCurrently, the file must be a bzImage and contain an x86\nkernel that is loadable above 4&nbsp;GiB in memory (see the\nkernel source file <i>Documentation/x86/boot.txt</i>).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Could not allocate memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The caller does not have the <b>CAP_SYS_BOOT</b>\ncapability.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>kexec_load</b>() system call first appeared in Linux\n2.6.13. The <b>kexec_file_load</b>() system call first\nappeared in Linux 3.17.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls are Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Currently,\nthere is no glibc support for these system calls. Call them\nusing <a href=\"https://man.page/2/syscall\">syscall(2)</a>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/reboot\">reboot(2)</a>,\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>, <b>kexec</b>(8)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\nsource files <i>Documentation/kdump/kdump.txt</i> and\n<i>Documentation/admin-guide/kernel-parameters.txt</i></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}