{"name":"userfaultfd","description":"userfaultfd -\ncreate a file descriptor for handling page faults in user\nspace","body":"\n\n<h1 align=\"center\">USERFAULTFD</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">userfaultfd -\ncreate a file descriptor for handling page faults in user\nspace</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/types.h&gt; <br>\n#include &lt;linux/userfaultfd.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nuserfaultfd(int</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere is no glibc wrapper for this system call; see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>userfaultfd</b>()\ncreates a new userfaultfd object that can be used for\ndelegation of page-fault handling to a user-space\napplication, and returns a file descriptor that refers to\nthe new object. The new userfaultfd object is configured\nusing <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once the\nuserfaultfd object is configured, the application can use\n<a href=\"https://man.page/2/read\">read(2)</a> to receive userfaultfd notifications. The\nreads from userfaultfd may be blocking or non-blocking,\ndepending on the value of <i>flags</i> used for the creation\nof the userfaultfd or subsequent calls to\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nvalues may be bitwise ORed in <i>flags</i> to change the\nbehavior of <b>userfaultfd</b>(): <b><br>\nO_CLOEXEC</b></p>\n\n<p style=\"margin-left:22%;\">Enable the close-on-exec flag\nfor the new userfaultfd file descriptor. See the description\nof the <b>O_CLOEXEC</b> flag in <a href=\"https://man.page/2/open\">open(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>O_NONBLOCK</b></p>\n\n<p style=\"margin-left:22%;\">Enables non-blocking operation\nfor the userfaultfd object. See the description of the\n<b>O_NONBLOCK</b> flag in <a href=\"https://man.page/2/open\">open(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the last\nfile descriptor referring to a userfaultfd object is closed,\nall memory ranges that were registered with the object are\nunregistered and unread events are flushed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Usage</b>\n<br>\nThe userfaultfd mechanism is designed to allow a thread in a\nmultithreaded program to perform user-space paging for the\nother threads in the process. When a page fault occurs for\none of the regions registered to the userfaultfd object, the\nfaulting thread is put to sleep and an event is generated\nthat can be read via the userfaultfd file descriptor. The\nfault-handling thread reads events from this file descriptor\nand services them using the operations described in\n<a href=\"https://man.page/2/ioctl_userfaultfd\">ioctl_userfaultfd(2)</a>. When servicing the page fault\nevents, the fault-handling thread can trigger a wake-up for\nthe sleeping thread.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is possible\nfor the faulting threads and the fault-handling threads to\nrun in the context of different processes. In this case,\nthese threads may belong to different programs, and the\nprogram that executes the faulting threads will not\nnecessarily cooperate with the program that handles the page\nfaults. In such non-cooperative mode, the process that\nmonitors userfaultfd and handles page faults needs to be\naware of the changes in the virtual memory layout of the\nfaulting process to avoid memory corruption.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting from\nLinux 4.11, userfaultfd can also notify the fault-handling\nthreads about changes in the virtual memory layout of the\nfaulting process. In addition, if the faulting process\ninvokes <a href=\"https://man.page/2/fork\">fork(2)</a>, the userfaultfd objects associated\nwith the parent may be duplicated into the child process and\nthe userfaultfd monitor will be notified (via the\n<b>UFFD_EVENT_FORK</b> described below) about the file\ndescriptor associated with the userfault objects created for\nthe child process, which allows the userfaultfd monitor to\nperform user-space paging for the child process. Unlike page\nfaults which have to be synchronous and require an explicit\nor implicit wakeup, all other events are delivered\nasynchronously and the non-cooperative process resumes\nexecution as soon as the userfaultfd manager executes\n<a href=\"https://man.page/2/read\">read(2)</a>. The userfaultfd manager should carefully\nsynchronize calls to <b>UFFDIO_COPY</b> with the processing\nof events.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The current\nasynchronous model of the event delivery is optimal for\nsingle threaded non-cooperative userfaultfd manager\nimplementations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Userfaultfd\noperation</b> <br>\nAfter the userfaultfd object is created with\n<b>userfaultfd</b>(), the application must enable it using\nthe <b>UFFDIO_API ioctl</b>(2) operation. This operation\nallows a handshake between the kernel and user space to\ndetermine the API version and supported features. This\noperation must be performed before any of the other\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operations described below (or those\noperations fail with the <b>EINVAL</b> error).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After a\nsuccessful <b>UFFDIO_API</b> operation, the application then\nregisters memory address ranges using the <b>UFFDIO_REGISTER\nioctl</b>(2) operation. After successful completion of a\n<b>UFFDIO_REGISTER</b> operation, a page fault occurring in\nthe requested memory range, and satisfying the mode defined\nat the registration time, will be forwarded by the kernel to\nthe user-space application. The application can then use the\n<b>UFFDIO_COPY</b> or <b>UFFDIO_ZEROPAGE ioctl</b>(2)\noperations to resolve the page fault.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting from\nLinux 4.14, if the application sets the\n<b>UFFD_FEATURE_SIGBUS</b> feature bit using the\n<b>UFFDIO_API ioctl</b>(2), no page-fault notification will\nbe forwarded to user space. Instead a <b>SIGBUS</b> signal\nis delivered to the faulting process. With this feature,\nuserfaultfd can be used for robustness purposes to simply\ncatch any access to areas within the registered address\nrange that do not have pages allocated, without having to\nlisten to userfaultfd events. No userfaultfd monitor will be\nrequired for dealing with such memory accesses. For example,\nthis feature can be useful for applications that want to\nprevent the kernel from automatically allocating pages and\nfilling holes in sparse files when the hole is accessed\nthrough a memory mapping.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>UFFD_FEATURE_SIGBUS</b> feature is implicitly inherited\nthrough <a href=\"https://man.page/2/fork\">fork(2)</a> if used in combination with\n<b>UFFD_FEATURE_FORK</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Details of the\nvarious <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operations can be found in\n<a href=\"https://man.page/2/ioctl_userfaultfd\">ioctl_userfaultfd(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n4.11, events other than page-fault may enabled during\n<b>UFFDIO_API</b> operation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Up to Linux\n4.11, userfaultfd can be used only with anonymous private\nmemory mappings. Since Linux 4.11, userfaultfd can be also\nused with hugetlbfs and shared memory mappings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading from\nthe userfaultfd structure</b> <br>\nEach <a href=\"https://man.page/2/read\">read(2)</a> from the userfaultfd file descriptor\nreturns one or more <i>uffd_msg</i> structures, each of\nwhich describes a page-fault event or an event required for\nthe non-cooperative userfaultfd usage:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct uffd_msg\n{ <br>\n__u8 event; /* Type of event */ <br>\n... <br>\nunion { <br>\nstruct { <br>\n__u64 flags; /* Flags describing fault */ <br>\n__u64 address; /* Faulting address */ <br>\n} pagefault;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct { /*\nSince Linux 4.11 */ <br>\n__u32 ufd; /* Userfault file descriptor <br>\nof the child process */ <br>\n} fork;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct { /*\nSince Linux 4.11 */ <br>\n__u64 from; /* Old address of remapped area */ <br>\n__u64 to; /* New address of remapped area */ <br>\n__u64 len; /* Original mapping length */ <br>\n} remap;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct { /*\nSince Linux 4.11 */ <br>\n__u64 start; /* Start address of removed area */ <br>\n__u64 end; /* End address of removed area */ <br>\n} remove; <br>\n... <br>\n} arg;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Padding\nfields omitted */ <br>\n} __packed;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If multiple\nevents are available and the supplied buffer is large\nenough, <a href=\"https://man.page/2/read\">read(2)</a> returns as many events as will fit in\nthe supplied buffer. If the buffer supplied to\n<a href=\"https://man.page/2/read\">read(2)</a> is smaller than the size of the\n<i>uffd_msg</i> structure, the <a href=\"https://man.page/2/read\">read(2)</a> fails with the\nerror <b>EINVAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields set\nin the <i>uffd_msg</i> structure are as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>event</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>The type of event. Depending of the event type,\ndifferent fields of the <i>arg</i> union represent details\nrequired for the event processing. The non-page-fault events\nare generated only when appropriate feature is enabled\nduring API handshake with <b>UFFDIO_API ioctl</b>(2).</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The following\nvalues can appear in the <i>event</i> field: <b><br>\nUFFD_EVENT_PAGEFAULT</b> (since Linux 4.3)</p>\n\n<p style=\"margin-left:32%;\">A page-fault event. The\npage-fault details are available in the <i>pagefault</i>\nfield.</p>\n\n<p style=\"margin-left:22%;\"><b>UFFD_EVENT_FORK</b> (since\nLinux 4.11)</p>\n\n<p style=\"margin-left:32%;\">Generated when the faulting\nprocess invokes <a href=\"https://man.page/2/fork\">fork(2)</a> (or <a href=\"https://man.page/2/clone\">clone(2)</a> without\nthe <b>CLONE_VM</b> flag). The event details are available\nin the <i>fork</i> field.</p>\n\n<p style=\"margin-left:22%;\"><b>UFFD_EVENT_REMAP</b> (since\nLinux 4.11)</p>\n\n<p style=\"margin-left:32%;\">Generated when the faulting\nprocess invokes <a href=\"https://man.page/2/mremap\">mremap(2)</a>. The event details are\navailable in the <i>remap</i> field.</p>\n\n<p style=\"margin-left:22%;\"><b>UFFD_EVENT_REMOVE</b> (since\nLinux 4.11)</p>\n\n<p style=\"margin-left:32%;\">Generated when the faulting\nprocess invokes <a href=\"https://man.page/2/madvise\">madvise(2)</a> with <b>MADV_DONTNEED</b>\nor <b>MADV_REMOVE</b> advice. The event details are\navailable in the <i>remove</i> field.</p>\n\n<p style=\"margin-left:22%;\"><b>UFFD_EVENT_UNMAP</b> (since\nLinux 4.11)</p>\n\n<p style=\"margin-left:32%;\">Generated when the faulting\nprocess unmaps a memory range, either explicitly using\n<a href=\"https://man.page/2/munmap\">munmap(2)</a> or implicitly during <a href=\"https://man.page/2/mmap\">mmap(2)</a> or\n<a href=\"https://man.page/2/mremap\">mremap(2)</a>. The event details are available in the\n<i>remove</i> field.</p>\n\n<p style=\"margin-left:11%;\"><i>pagefault.address</i></p>\n\n<p style=\"margin-left:22%;\">The address that triggered the\npage fault.</p>\n\n<p style=\"margin-left:11%;\"><i>pagefault.flags</i></p>\n\n<p style=\"margin-left:22%;\">A bit mask of flags that\ndescribe the event. For <b>UFFD_EVENT_PAGEFAULT</b>, the\nfollowing flag may appear: <b><br>\nUFFD_PAGEFAULT_FLAG_WRITE</b></p>\n\n<p style=\"margin-left:32%;\">If the address is in a range\nthat was registered with the\n<b>UFFDIO_REGISTER_MODE_MISSING</b> flag (see\n<a href=\"https://man.page/2/ioctl_userfaultfd\">ioctl_userfaultfd(2)</a>) and this flag is set, this a\nwrite fault; otherwise it is a read fault.</p>\n\n<p style=\"margin-left:11%;\"><i>fork.ufd</i></p>\n\n<p style=\"margin-left:22%;\">The file descriptor associated\nwith the userfault object created for the child created by\n<a href=\"https://man.page/2/fork\">fork(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><i>remap.from</i></p>\n\n<p style=\"margin-left:22%;\">The original address of the\nmemory range that was remapped using <a href=\"https://man.page/2/mremap\">mremap(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><i>remap.to</i></p>\n\n<p style=\"margin-left:22%;\">The new address of the memory\nrange that was remapped using <a href=\"https://man.page/2/mremap\">mremap(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><i>remap.len</i></p>\n\n<p style=\"margin-left:22%;\">The original length of the\nmemory range that was remapped using <a href=\"https://man.page/2/mremap\">mremap(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><i>remove.start</i></p>\n\n<p style=\"margin-left:22%;\">The start address of the memory\nrange that was freed using <a href=\"https://man.page/2/madvise\">madvise(2)</a> or unmapped</p>\n\n<p style=\"margin-left:11%;\"><i>remove.end</i></p>\n\n<p style=\"margin-left:22%;\">The end address of the memory\nrange that was freed using <a href=\"https://man.page/2/madvise\">madvise(2)</a> or unmapped</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<a href=\"https://man.page/2/read\">read(2)</a> on a userfaultfd file descriptor can fail\nwith the following errors:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The userfaultfd object has not yet been enabled using\nthe <b>UFFDIO_API ioctl</b>(2) operation</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>O_NONBLOCK</b> flag is enabled in the associated open\nfile description, the userfaultfd file descriptor can be\nmonitored with <a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>, and\n<a href=\"https://man.page/7/epoll\">epoll(7)</a>. When events are available, the file\ndescriptor indicates as readable. If the <b>O_NONBLOCK</b>\nflag is not enabled, then <a href=\"https://man.page/2/poll\">poll(2)</a> (always) indicates\nthe file as having a <b>POLLERR</b> condition, and\n<a href=\"https://man.page/2/select\">select(2)</a> indicates the file descriptor as both\nreadable and writable.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>userfaultfd</b>() returns a new file descriptor that\nrefers to the userfaultfd object. On error, -1 is returned,\nand <i>errno</i> is set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">An unsupported value was\nspecified in <i>flags</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The per-process limit on the number of open file\ndescriptors has been reached</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The system-wide limit on the total number of open files\nhas been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Insufficient kernel memory was available.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EPERM</b> (since Linux\n5.2)</p>\n\n<p style=\"margin-left:22%;\">The caller is not privileged\n(does not have the <b>CAP_SYS_PTRACE</b> capability in the\ninitial user namespace), and\n<i>/proc/sys/vm/unprivileged_userfaultfd</i> has the value\n0.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>userfaultfd</b>() system call first appeared in Linux\n4.3.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The support for\nhugetlbfs and shared memory areas and non-page-fault events\nwas added in Linux 4.11</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>userfaultfd</b>()\nis Linux-specific and should not be used in programs\nintended to be portable.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glibc does not\nprovide a wrapper for this system call; call it using\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The userfaultfd\nmechanism can be used as an alternative to traditional\nuser-space paging techniques based on the use of the\n<b>SIGSEGV</b> signal and <a href=\"https://man.page/2/mmap\">mmap(2)</a>. It can also be\nused to implement lazy restore for checkpoint/restore\nmechanisms, as well as post-copy migration to allow (nearly)\nuninterrupted execution when transferring virtual machines\nand Linux containers from one host to another.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>UFFD_FEATURE_EVENT_FORK</b> is enabled and a system call\nfrom the <a href=\"https://man.page/2/fork\">fork(2)</a> family is interrupted by a signal or\nfailed, a stale userfaultfd descriptor might be created. In\nthis case, a spurious <b>UFFD_EVENT_FORK</b> will be\ndelivered to the userfaultfd monitor.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow demonstrates the use of the userfaultfd mechanism. The\nprogram creates two threads, one of which acts as the\npage-fault handler for the process, for the pages in a\ndemand-page zero region created using <a href=\"https://man.page/2/mmap\">mmap(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\ntakes one command-line argument, which is the number of\npages that will be created in a mapping whose page faults\nwill be handled via userfaultfd. After creating a\nuserfaultfd object, the program then creates an anonymous\nprivate mapping of the specified size and registers the\naddress range of that mapping using the <b>UFFDIO_REGISTER\nioctl</b>(2) operation. The program then creates a second\nthread that will perform the task of handling page\nfaults.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The main thread\nthen walks through the pages of the mapping fetching bytes\nfrom successive pages. Because the pages have not yet been\naccessed, the first access of a byte in each page will\ntrigger a page-fault event on the userfaultfd file\ndescriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each of the\npage-fault events is handled by the second thread, which\nsits in a loop processing input from the userfaultfd file\ndescriptor. In each loop iteration, the second thread first\ncalls <a href=\"https://man.page/2/poll\">poll(2)</a> to check the state of the file\ndescriptor, and then reads an event from the file\ndescriptor. All such events should be\n<b>UFFD_EVENT_PAGEFAULT</b> events, which the thread handles\nby copying a page of data into the faulting region using the\n<b>UFFDIO_COPY ioctl</b>(2) operation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nis an example of what we see when running the program:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./userfaultfd_demo 3</b> <br>\nAddress returned by mmap() = 0x7fd30106c000</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">fault_handler_thread():\n<br>\npoll() returns: nready = 1; POLLIN = 1; POLLERR = 0 <br>\nUFFD_EVENT_PAGEFAULT event: flags = 0; address =\n7fd30106c00f <br>\n(uffdio_copy.copy returned 4096) <br>\nRead address 0x7fd30106c00f in main(): A <br>\nRead address 0x7fd30106c40f in main(): A <br>\nRead address 0x7fd30106c80f in main(): A <br>\nRead address 0x7fd30106cc0f in main(): A</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">fault_handler_thread():\n<br>\npoll() returns: nready = 1; POLLIN = 1; POLLERR = 0 <br>\nUFFD_EVENT_PAGEFAULT event: flags = 0; address =\n7fd30106d00f <br>\n(uffdio_copy.copy returned 4096) <br>\nRead address 0x7fd30106d00f in main(): B <br>\nRead address 0x7fd30106d40f in main(): B <br>\nRead address 0x7fd30106d80f in main(): B <br>\nRead address 0x7fd30106dc0f in main(): B</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">fault_handler_thread():\n<br>\npoll() returns: nready = 1; POLLIN = 1; POLLERR = 0 <br>\nUFFD_EVENT_PAGEFAULT event: flags = 0; address =\n7fd30106e00f <br>\n(uffdio_copy.copy returned 4096) <br>\nRead address 0x7fd30106e00f in main(): C <br>\nRead address 0x7fd30106e40f in main(): C <br>\nRead address 0x7fd30106e80f in main(): C <br>\nRead address 0x7fd30106ec0f in main(): C</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n/* userfaultfd_demo.c</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nthe GNU General Public License version 2 or later. <br>\n*/ <br>\n#define _GNU_SOURCE <br>\n#include &lt;inttypes.h&gt; <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;linux/userfaultfd.h&gt; <br>\n#include &lt;pthread.h&gt; <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;signal.h&gt; <br>\n#include &lt;poll.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;sys/mman.h&gt; <br>\n#include &lt;sys/syscall.h&gt; <br>\n#include &lt;sys/ioctl.h&gt; <br>\n#include &lt;poll.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int\npage_size;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void *\n<br>\nfault_handler_thread(void *arg) <br>\n{ <br>\nstatic struct uffd_msg msg; /* Data read from userfaultfd */\n<br>\nstatic int fault_cnt = 0; /* Number of faults so far handled\n*/ <br>\nlong uffd; /* userfaultfd file descriptor */ <br>\nstatic char *page = NULL; <br>\nstruct uffdio_copy uffdio_copy; <br>\nssize_t nread;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">uffd = (long)\narg;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create a\npage that will be copied into the faulting region */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (page ==\nNULL) { <br>\npage = mmap(NULL, page_size, PROT_READ | PROT_WRITE, <br>\nMAP_PRIVATE | MAP_ANONYMOUS, -1, 0); <br>\nif (page == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Loop,\nhandling incoming events on the userfaultfd <br>\nfile descriptor */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* See what\npoll() tells us about the userfaultfd */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct pollfd\npollfd; <br>\nint nready; <br>\npollfd.fd = uffd; <br>\npollfd.events = POLLIN; <br>\nnready = poll(&amp;pollfd, 1, -1); <br>\nif (nready == -1) <br>\nerrExit(&quot;poll&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;\\nfault_handler_thread():\\n&quot;);\n<br>\nprintf(&quot; poll() returns: nready = %d; &quot; <br>\n&quot;POLLIN = %d; POLLERR = %d\\n&quot;, nready, <br>\n(pollfd.revents &amp; POLLIN) != 0, <br>\n(pollfd.revents &amp; POLLERR) != 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read an\nevent from the userfaultfd */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nread =\nread(uffd, &amp;msg, sizeof(msg)); <br>\nif (nread == 0) { <br>\nprintf(&quot;EOF on userfaultfd!\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (nread ==\n-1) <br>\nerrExit(&quot;read&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* We expect\nonly one kind of event; verify that assumption */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (msg.event\n!= UFFD_EVENT_PAGEFAULT) { <br>\nfprintf(stderr, &quot;Unexpected event on\nuserfaultfd\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Display info\nabout the page-fault event */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;\nUFFD_EVENT_PAGEFAULT event: &quot;); <br>\nprintf(&quot;flags = %&quot;PRIx64&quot;; &quot;,\nmsg.arg.pagefault.flags); <br>\nprintf(&quot;address = %&quot;PRIx64&quot;\\n&quot;,\nmsg.arg.pagefault.address);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Copy the\npage pointed to by 'page' into the faulting <br>\nregion. Vary the contents that are copied in, so that it\n<br>\nis more obvious that each fault is handled separately.\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(page,\n'A' + fault_cnt % 20, page_size); <br>\nfault_cnt++;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">uffdio_copy.src\n= (unsigned long) page;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* We need to\nhandle page faults in units of pages(!). <br>\nSo, round faulting address down to page boundary */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">uffdio_copy.dst\n= (unsigned long) msg.arg.pagefault.address &amp; <br>\n~(page_size - 1); <br>\nuffdio_copy.len = page_size; <br>\nuffdio_copy.mode = 0; <br>\nuffdio_copy.copy = 0; <br>\nif (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == -1) <br>\nerrExit(&quot;ioctl-UFFDIO_COPY&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;\n(uffdio_copy.copy returned %&quot;PRId64&quot;)\\n&quot;,\n<br>\nuffdio_copy.copy); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nlong uffd; /* userfaultfd file descriptor */ <br>\nchar *addr; /* Start of region handled by userfaultfd */\n<br>\nuint64_t len; /* Length of region handled by userfaultfd */\n<br>\npthread_t thr; /* ID of thread that handles page faults */\n<br>\nstruct uffdio_api uffdio_api; <br>\nstruct uffdio_register uffdio_register; <br>\nint s;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Usage: %s num-pages\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">page_size =\nsysconf(_SC_PAGE_SIZE); <br>\nlen = strtoull(argv[1], NULL, 0) * page_size;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create and\nenable userfaultfd object */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">uffd =\nsyscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); <br>\nif (uffd == -1) <br>\nerrExit(&quot;userfaultfd&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">uffdio_api.api\n= UFFD_API; <br>\nuffdio_api.features = 0; <br>\nif (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == -1) <br>\nerrExit(&quot;ioctl-UFFDIO_API&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create a\nprivate anonymous mapping. The memory will be <br>\ndemand-zero paged--that is, not yet allocated. When we <br>\nactually touch the memory, it will be allocated via <br>\nthe userfaultfd. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">addr =\nmmap(NULL, len, PROT_READ | PROT_WRITE, <br>\nMAP_PRIVATE | MAP_ANONYMOUS, -1, 0); <br>\nif (addr == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Address\nreturned by mmap() = %p\\n&quot;, addr);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Register the\nmemory range of the mapping we just created for <br>\nhandling by the userfaultfd object. In mode, we request to\ntrack <br>\nmissing pages (i.e., pages that have not yet been faulted\nin). */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">uffdio_register.range.start\n= (unsigned long) addr; <br>\nuffdio_register.range.len = len; <br>\nuffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING; <br>\nif (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) ==\n-1) <br>\nerrExit(&quot;ioctl-UFFDIO_REGISTER&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create a\nthread that will process the userfaultfd events */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_create(&amp;thr, NULL, fault_handler_thread, (void\n*) uffd); <br>\nif (s != 0) { <br>\nerrno = s; <br>\nerrExit(&quot;pthread_create&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Main thread\nnow touches memory in the mapping, touching <br>\nlocations 1024 bytes apart. This will trigger userfaultfd\n<br>\nevents for all pages in the region. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int l; <br>\nl = 0xf; /* Ensure that faulting address is not on a page\n<br>\nboundary, in order to test that we correctly <br>\nhandle that case in fault_handling_thread() */ <br>\nwhile (l &lt; len) { <br>\nchar c = addr[l]; <br>\nprintf(&quot;Read address %p in main(): &quot;, addr + l);\n<br>\nprintf(&quot;%c\\n&quot;, c); <br>\nl += 1024; <br>\nusleep(100000); /* Slow things down a little */ <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/fcntl\">fcntl(2)</a>,\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a>, <a href=\"https://man.page/2/ioctl_userfaultfd\">ioctl_userfaultfd(2)</a>,\n<a href=\"https://man.page/2/madvise\">madvise(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Documentation/admin-guide/mm/userfaultfd.rst</i>\nin the Linux kernel source tree</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}