{"name":"open_by_handle_at","body":"\n\n<h1 align=\"center\">OPEN_BY_HANDLE_AT</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">name_to_handle_at,\nopen_by_handle_at - obtain handle for a pathname and open\nfile via a handle</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;sys/stat.h&gt; <br>\n#include &lt;fcntl.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nname_to_handle_at(int</b> <i>dirfd</i><b>, const char\n*</b><i>pathname</i><b>, <br>\nstruct file_handle *</b><i>handle</i><b>, <br>\nint *</b><i>mount_id</i><b>, int</b>\n<i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nopen_by_handle_at(int</b> <i>mount_fd</i><b>, struct\nfile_handle *</b><i>handle</i><b>, <br>\nint</b> <i>flags</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>name_to_handle_at</b>() and <b>open_by_handle_at</b>()\nsystem calls split the functionality of <a href=\"https://man.page/2/openat\">openat(2)</a>\ninto two parts: <b>name_to_handle_at</b>() returns an opaque\nhandle that corresponds to a specified file;\n<b>open_by_handle_at</b>() opens the file corresponding to a\nhandle returned by a previous call to\n<b>name_to_handle_at</b>() and returns an open file\ndescriptor.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>name_to_handle_at()</b>\n<br>\nThe <b>name_to_handle_at</b>() system call returns a file\nhandle and a mount ID corresponding to the file specified by\nthe <i>dirfd</i> and <i>pathname</i> arguments. The file\nhandle is returned via the argument <i>handle</i>, which is\na pointer to a structure of the following form:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfile_handle { <br>\nunsigned int handle_bytes; /* Size of f_handle [in, out] */\n<br>\nint handle_type; /* Handle type [out] */ <br>\nunsigned char f_handle[0]; /* File identifier (sized by <br>\ncaller) [out] */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is the\ncaller&rsquo;s responsibility to allocate the structure with\na size large enough to hold the handle returned in\n<i>f_handle</i>. Before the call, the <i>handle_bytes</i>\nfield should be initialized to contain the allocated size\nfor <i>f_handle</i>. (The constant <b>MAX_HANDLE_SZ</b>,\ndefined in <i>&lt;fcntl.h&gt;</i>, specifies the maximum\nexpected size for a file handle. It is not a guaranteed\nupper limit as future filesystems may require more space.)\nUpon successful return, the <i>handle_bytes</i> field is\nupdated to contain the number of bytes actually written to\n<i>f_handle</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The caller can\ndiscover the required size for the <i>file_handle</i>\nstructure by making a call in which\n<i>handle-&gt;handle_bytes</i> is zero; in this case, the\ncall fails with the error <b>EOVERFLOW</b> and\n<i>handle-&gt;handle_bytes</i> is set to indicate the\nrequired size; the caller can then use this information to\nallocate a structure of the correct size (see EXAMPLES\nbelow). Some care is needed here as <b>EOVERFLOW</b> can\nalso indicate that no file handle is available for this\nparticular name in a filesystem which does normally support\nfile-handle lookup. This case can be detected when the\n<b>EOVERFLOW</b> error is returned without\n<i>handle_bytes</i> being increased.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other than the\nuse of the <i>handle_bytes</i> field, the caller should\ntreat the <i>file_handle</i> structure as an opaque data\ntype: the <i>handle_type</i> and <i>f_handle</i> fields are\nneeded only by a subsequent call to\n<b>open_by_handle_at</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument is a bit mask constructed by ORing\ntogether zero or more of <b>AT_EMPTY_PATH</b> and\n<b>AT_SYMLINK_FOLLOW</b>, described below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Together, the\n<i>pathname</i> and <i>dirfd</i> arguments identify the file\nfor which a handle is to be obtained. There are four\ndistinct cases:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If <i>pathname</i> is a nonempty string containing an\nabsolute pathname, then a handle is returned for the file\nreferred to by that pathname. In this case, <i>dirfd</i> is\nignored.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If <i>pathname</i> is a nonempty string containing a\nrelative pathname and <i>dirfd</i> has the special value\n<b>AT_FDCWD</b>, then <i>pathname</i> is interpreted\nrelative to the current working directory of the caller, and\na handle is returned for the file to which it refers.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If <i>pathname</i> is a nonempty string containing a\nrelative pathname and <i>dirfd</i> is a file descriptor\nreferring to a directory, then <i>pathname</i> is\ninterpreted relative to the directory referred to by\n<i>dirfd</i>, and a handle is returned for the file to which\nit refers. (See <a href=\"https://man.page/2/openat\">openat(2)</a> for an explanation of why\n&quot;directory file descriptors&quot; are useful.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If <i>pathname</i> is an empty string and <i>flags</i>\nspecifies the value <b>AT_EMPTY_PATH</b>, then <i>dirfd</i>\ncan be an open file descriptor referring to any type of\nfile, or <b>AT_FDCWD</b>, meaning the current working\ndirectory, and a handle is returned for the file to which it\nrefers.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>mount_id</i> argument returns an identifier for the\nfilesystem mount that corresponds to <i>pathname</i>. This\ncorresponds to the first field in one of the records in\n<i>/proc/self/mountinfo</i>. Opening the pathname in the\nfifth field of that record yields a file descriptor for the\nmount point; that file descriptor can be used in a\nsubsequent call to <b>open_by_handle_at</b>().\n<i>mount_id</i> is returned both for a successful call and\nfor a call that results in the error <b>EOVERFLOW</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\n<b>name_to_handle_at</b>() does not dereference\n<i>pathname</i> if it is a symbolic link, and thus returns a\nhandle for the link itself. If <b>AT_SYMLINK_FOLLOW</b> is\nspecified in <i>flags</i>, <i>pathname</i> is dereferenced\nif it is a symbolic link (so that the call returns a handle\nfor the file referred to by the link).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>name_to_handle_at</b>()\ndoes not trigger a mount when the final component of the\npathname is an automount point. When a filesystem supports\nboth file handles and automount points, a\n<b>name_to_handle_at</b>() call on an automount point will\nreturn with error <b>EOVERFLOW</b> without having increased\n<i>handle_bytes</i>. This can happen since Linux 4.13 with\nNFS when accessing a directory which is on a separate\nfilesystem on the server. In this case, the automount can be\ntriggered by adding a &quot;/&quot; to the end of the\npathname.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>open_by_handle_at()</b>\n<br>\nThe <b>open_by_handle_at</b>() system call opens the file\nreferred to by <i>handle</i>, a file handle returned by a\nprevious call to <b>name_to_handle_at</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>mount_fd</i> argument is a file descriptor for any object\n(file, directory, etc.) in the mounted filesystem with\nrespect to which <i>handle</i> should be interpreted. The\nspecial value <b>AT_FDCWD</b> can be specified, meaning the\ncurrent working directory of the caller.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument is as for <a href=\"https://man.page/2/open\">open(2)</a>. If\n<i>handle</i> refers to a symbolic link, the caller must\nspecify the <b>O_PATH</b> flag, and the symbolic link is not\ndereferenced; the <b>O_NOFOLLOW</b> flag, if specified, is\nignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The caller must\nhave the <b>CAP_DAC_READ_SEARCH</b> capability to invoke\n<b>open_by_handle_at</b>().</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>name_to_handle_at</b>() returns 0, and\n<b>open_by_handle_at</b>() returns a file descriptor (a\nnonnegative integer).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the event of\nan error, both system calls return -1 and set <i>errno</i>\nto indicate the cause of the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>name_to_handle_at</b>()\nand <b>open_by_handle_at</b>() can fail for the same errors\nas <a href=\"https://man.page/2/openat\">openat(2)</a>. In addition, they can fail with the\nerrors noted below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>name_to_handle_at</b>()\ncan fail with the following errors:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><i>pathname</i>,\n<i>mount_id</i>, or <i>handle</i> points outside your\naccessible address space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>flags</i> includes an invalid bit value.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>handle-&gt;handle_bytes</i> is greater than\n<b>MAX_HANDLE_SZ</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>pathname</i> is an empty string, but\n<b>AT_EMPTY_PATH</b> was not specified in <i>flags</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTDIR</b></p>\n\n<p style=\"margin-left:22%;\">The file descriptor supplied in\n<i>dirfd</i> does not refer to a directory, and it is not\nthe case that both <i>flags</i> includes\n<b>AT_EMPTY_PATH</b> and <i>pathname</i> is an empty\nstring.</p>\n\n<p style=\"margin-left:11%;\"><b>EOPNOTSUPP</b></p>\n\n<p style=\"margin-left:22%;\">The filesystem does not support\ndecoding of a pathname to a file handle.</p>\n\n<p style=\"margin-left:11%;\"><b>EOVERFLOW</b></p>\n\n<p style=\"margin-left:22%;\">The\n<i>handle-&gt;handle_bytes</i> value passed into the call\nwas too small. When this error occurs,\n<i>handle-&gt;handle_bytes</i> is updated to indicate the\nrequired size for the handle.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>open_by_handle_at</b>()\ncan fail with the following errors:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>mount_fd</i> is not an open file descriptor.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>handle</i> points outside your accessible address\nspace.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>handle-&gt;handle_bytes</i> is greater than\n<b>MAX_HANDLE_SZ</b> or is equal to zero.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ELOOP</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>handle</i> refers to a symbolic link, but\n<b>O_PATH</b> was not specified in <i>flags</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The caller does not have the <b>CAP_DAC_READ_SEARCH</b>\ncapability.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESTALE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The specified <i>handle</i> is not valid. This error\nwill occur if, for example, the file has been deleted.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls first appeared in Linux 2.6.39. Library support is\nprovided in glibc since version 2.14.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls are nonstandard Linux extensions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">FreeBSD has a\nbroadly similar pair of system calls in the form of\n<b>getfh</b>() and <b>openfh</b>().</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A file handle\ncan be generated in one process using\n<b>name_to_handle_at</b>() and later used in a different\nprocess that calls <b>open_by_handle_at</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some filesystem\ndon&rsquo;t support the translation of pathnames to file\nhandles, for example, <i>/proc</i>, <i>/sys</i>, and various\nnetwork filesystems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A file handle\nmay become invalid (&quot;stale&quot;) if a file is deleted,\nor for other filesystem-specific reasons. Invalid handles\nare notified by an <b>ESTALE</b> error from\n<b>open_by_handle_at</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls are designed for use by user-space file servers. For\nexample, a user-space NFS server might generate a file\nhandle and pass it to an NFS client. Later, when the client\nwants to open the file, it could pass the handle back to the\nserver. This sort of functionality allows a user-space file\nserver to operate in a stateless fashion with respect to the\nfiles it serves.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>pathname</i> refers to a symbolic link and <i>flags</i>\ndoes not specify <b>AT_SYMLINK_FOLLOW</b>, then\n<b>name_to_handle_at</b>() returns a handle for the link\n(rather than the file to which it refers). The process\nreceiving the handle can later perform operations on the\nsymbolic link by converting the handle to a file descriptor\nusing <b>open_by_handle_at</b>() with the <b>O_PATH</b>\nflag, and then passing the file descriptor as the\n<i>dirfd</i> argument in system calls such as\n<a href=\"https://man.page/2/readlinkat\">readlinkat(2)</a> and <a href=\"https://man.page/2/fchownat\">fchownat(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Obtaining a\npersistent filesystem ID</b> <br>\nThe mount IDs in <i>/proc/self/mountinfo</i> can be reused\nas filesystems are unmounted and mounted. Therefore, the\nmount ID returned by <b>name_to_handle_at</b>() (in\n<i>*mount_id</i>) should not be treated as a persistent\nidentifier for the corresponding mounted filesystem.\nHowever, an application can use the information in the\n<i>mountinfo</i> record that corresponds to the mount ID to\nderive a persistent identifier.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\none can use the device name in the fifth field of the\n<i>mountinfo</i> record to search for the corresponding\ndevice UUID via the symbolic links in\n<i>/dev/disks/by-uuid</i>. (A more comfortable way of\nobtaining the UUID is to use the <a href=\"https://man.page/3/libblkid\">libblkid(3)</a>\nlibrary.) That process can then be reversed, using the UUID\nto look up the device name, and then obtaining the\ncorresponding mount point, in order to produce the\n<i>mount_fd</i> argument used by\n<b>open_by_handle_at</b>().</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The two\nprograms below demonstrate the use of\n<b>name_to_handle_at</b>() and <b>open_by_handle_at</b>().\nThe first program (<i>t_name_to_handle_at.c</i>) uses\n<b>name_to_handle_at</b>() to obtain the file handle and\nmount ID for the file specified in its command-line\nargument; the handle and mount ID are written to standard\noutput.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second\nprogram (<i>t_open_by_handle_at.c</i>) reads a mount ID and\nfile handle from standard input. The program then employs\n<b>open_by_handle_at</b>() to open the file using that\nhandle. If an optional command-line argument is supplied,\nthen the <i>mount_fd</i> argument for\n<b>open_by_handle_at</b>() is obtained by opening the\ndirectory named in that argument. Otherwise, <i>mount_fd</i>\nis obtained by scanning <i>/proc/self/mountinfo</i> to find\na record whose mount ID matches the mount ID read from\nstandard input, and the mount directory specified in that\nrecord is opened. (These programs do not deal with the fact\nthat mount IDs are not persistent.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session demonstrates the use of these two\nprograms:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>echo 'Can\nyou please think about it?' &gt; cecilia.txt</b> <br>\n$ <b>./t_name_to_handle_at cecilia.txt &gt; fh</b> <br>\n$ <b>./t_open_by_handle_at &lt; fh</b> <br>\nopen_by_handle_at: Operation not permitted <br>\n$ <b>sudo ./t_open_by_handle_at &lt; fh</b> # Need\nCAP_SYS_ADMIN <br>\nRead 31 bytes <br>\n$ <b>rm cecilia.txt</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now we delete\nand (quickly) re-create the file so that it has the same\ncontent and (by chance) the same inode. Nevertheless,\n<b>open_by_handle_at</b>() recognizes that the original file\nreferred to by the file handle no longer exists.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>stat\n--printf=&quot;%i\\n&quot; cecilia.txt</b> # Display inode\nnumber <br>\n4072121 <br>\n$ <b>rm cecilia.txt</b> <br>\n$ <b>echo 'Can you please think about it?' &gt;\ncecilia.txt</b> <br>\n$ <b>stat --printf=&quot;%i\\n&quot; cecilia.txt</b> # Check\ninode number <br>\n4072121 <br>\n$ <b>sudo ./t_open_by_handle_at &lt; fh</b> <br>\nopen_by_handle_at: Stale NFS file handle</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: t_name_to_handle_at.c</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;sys/stat.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct file_handle *fhp; <br>\nint mount_id, fhsize, flags, dirfd; <br>\nchar *pathname;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Usage: %s pathname\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pathname =\nargv[1];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Allocate\nfile_handle structure */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fhsize =\nsizeof(*fhp); <br>\nfhp = malloc(fhsize); <br>\nif (fhp == NULL) <br>\nerrExit(&quot;malloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Make an\ninitial call to name_to_handle_at() to discover <br>\nthe size required for file handle */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">dirfd =\nAT_FDCWD; /* For name_to_handle_at() calls */ <br>\nflags = 0; /* For name_to_handle_at() calls */ <br>\nfhp-&gt;handle_bytes = 0; <br>\nif (name_to_handle_at(dirfd, pathname, fhp, <br>\n&amp;mount_id, flags) != -1 || errno != EOVERFLOW) { <br>\nfprintf(stderr, &quot;Unexpected result from\nname_to_handle_at()\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Reallocate\nfile_handle structure with correct size */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fhsize =\nsizeof(*fhp) + fhp-&gt;handle_bytes; <br>\nfhp = realloc(fhp, fhsize); /* Copies fhp-&gt;handle_bytes\n*/ <br>\nif (fhp == NULL) <br>\nerrExit(&quot;realloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Get file\nhandle from pathname supplied on command line */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(name_to_handle_at(dirfd, pathname, fhp, &amp;mount_id,\nflags) == -1) <br>\nerrExit(&quot;name_to_handle_at&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Write mount\nID, file handle size, and file handle to stdout, <br>\nfor later reuse by t_open_by_handle_at.c */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;%d\\n&quot;,\nmount_id); <br>\nprintf(&quot;%u %d &quot;, fhp-&gt;handle_bytes,\nfhp-&gt;handle_type); <br>\nfor (int j = 0; j &lt; fhp-&gt;handle_bytes; j++) <br>\nprintf(&quot; %02x&quot;, fhp-&gt;f_handle[j]); <br>\nprintf(&quot;\\n&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: t_open_by_handle_at.c</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;sys/stat.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;limits.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Scan\n/proc/self/mountinfo to find the line whose mount ID matches\n<br>\n'mount_id'. (An easier way to do this is to install and use\nthe <br>\n'libmount' library provided by the 'util-linux' project.)\n<br>\nOpen the corresponding mount path and return the resulting\nfile <br>\ndescriptor. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\nopen_mount_path_by_id(int mount_id) <br>\n{ <br>\nchar *linep; <br>\nsize_t lsize; <br>\nchar mount_path[PATH_MAX]; <br>\nint mi_mount_id, found; <br>\nssize_t nread; <br>\nFILE *fp;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fp =\nfopen(&quot;/proc/self/mountinfo&quot;, &quot;r&quot;); <br>\nif (fp == NULL) <br>\nerrExit(&quot;fopen&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">found = 0; <br>\nlinep = NULL; <br>\nwhile (!found) { <br>\nnread = getline(&amp;linep, &amp;lsize, fp); <br>\nif (nread == -1) <br>\nbreak;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nread =\nsscanf(linep, &quot;%d %*d %*s %*s %s&quot;, <br>\n&amp;mi_mount_id, mount_path); <br>\nif (nread != 2) { <br>\nfprintf(stderr, &quot;Bad sscanf()\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (mi_mount_id\n== mount_id) <br>\nfound = 1; <br>\n} <br>\nfree(linep);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fclose(fp);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (!found) {\n<br>\nfprintf(stderr, &quot;Could not find mount point\\n&quot;);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return\nopen(mount_path, O_RDONLY); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct file_handle *fhp; <br>\nint mount_id, fd, mount_fd, handle_bytes; <br>\nssize_t nread; <br>\nchar buf[1000]; <br>\n#define LINE_SIZE 100 <br>\nchar line1[LINE_SIZE], line2[LINE_SIZE]; <br>\nchar *nextp;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if ((argc &gt;\n1 &amp;&amp; strcmp(argv[1], &quot;--help&quot;) == 0) ||\nargc &gt; 2) { <br>\nfprintf(stderr, &quot;Usage: %s [mount-path]\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Standard\ninput contains mount ID and file handle information:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Line 1:\n&lt;mount_id&gt; <br>\nLine 2: &lt;handle_bytes&gt; &lt;handle_type&gt; &lt;bytes\nof handle in hex&gt; <br>\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n((fgets(line1, sizeof(line1), stdin) == NULL) || <br>\n(fgets(line2, sizeof(line2), stdin) == NULL)) { <br>\nfprintf(stderr, &quot;Missing mount_id / file\nhandle\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">mount_id =\natoi(line1);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">handle_bytes =\nstrtoul(line2, &amp;nextp, 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Given\nhandle_bytes, we can now allocate file_handle structure\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fhp =\nmalloc(sizeof(*fhp) + handle_bytes); <br>\nif (fhp == NULL) <br>\nerrExit(&quot;malloc&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fhp-&gt;handle_bytes\n= handle_bytes;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fhp-&gt;handle_type\n= strtoul(nextp, &amp;nextp, 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; fhp-&gt;handle_bytes; j++) <br>\nfhp-&gt;f_handle[j] = strtoul(nextp, &amp;nextp, 16);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Obtain file\ndescriptor for mount point, either by opening <br>\nthe pathname specified on the command line, or by scanning\n<br>\n/proc/self/mounts to find a mount that matches the\n'mount_id' <br>\nthat we received from stdin. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &gt;\n1) <br>\nmount_fd = open(argv[1], O_RDONLY); <br>\nelse <br>\nmount_fd = open_mount_path_by_id(mount_id);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (mount_fd ==\n-1) <br>\nerrExit(&quot;opening mount fd&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Open file\nusing handle and mount point */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen_by_handle_at(mount_fd, fhp, O_RDONLY); <br>\nif (fd == -1) <br>\nerrExit(&quot;open_by_handle_at&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Try reading\na few bytes from the file */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nread =\nread(fd, buf, sizeof(buf)); <br>\nif (nread == -1) <br>\nerrExit(&quot;read&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Read\n%zd bytes\\n&quot;, nread);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/open\">open(2)</a>,\n<a href=\"https://man.page/3/libblkid\">libblkid(3)</a>, <b>blkid</b>(8), <b>findfs</b>(8),\n<b>mount</b>(8)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>libblkid</i> and <i>libmount</i> documentation in the\nlatest <i>util-linux</i> release at\n<a href=\"https://www.kernel.org/pub/linux/utils/util-linux/\">https://www.kernel.org/pub/linux/utils/util-linux/</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}