{"name":"wait","body":"\n\n<h1 align=\"center\">WAIT</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">wait, waitpid,\nwaitid - wait for process to change state</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/types.h&gt; <br>\n#include &lt;sys/wait.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pid_t\nwait(int *</b><i>wstatus</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pid_t\nwaitpid(pid_t</b> <i>pid</i><b>, int *</b><i>wstatus</i><b>,\nint</b> <i>options</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nwaitid(idtype_t</b> <i>idtype</i><b>, id_t</b> <i>id</i><b>,\nsiginfo_t *</b><i>infop</i><b>, int</b>\n<i>options</i><b>);</b> <br>\n/* This is the glibc and POSIX interface; see <br>\nNOTES for information on the raw system call. */</p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>waitid</b>():</p>\n\n<p style=\"margin-left:17%;\">Since glibc 2.26: _XOPEN_SOURCE\n&gt;= 500 || <br>\n_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200809L <br>\nGlibc 2.25 and earlier: <br>\n_XOPEN_SOURCE <br>\n|| /* Since glibc 2.12: */\n_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200809L <br>\n|| /* Glibc versions &lt;= 2.19: */ _BSD_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">All of these\nsystem calls are used to wait for state changes in a child\nof the calling process, and obtain information about the\nchild whose state has changed. A state change is considered\nto be: the child terminated; the child was stopped by a\nsignal; or the child was resumed by a signal. In the case of\na terminated child, performing a wait allows the system to\nrelease the resources associated with the child; if a wait\nis not performed, then the terminated child remains in a\n&quot;zombie&quot; state (see NOTES below).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a child has\nalready changed state, then these calls return immediately.\nOtherwise, they block until either a child changes state or\na signal handler interrupts the call (assuming that system\ncalls are not automatically restarted using the\n<b>SA_RESTART</b> flag of <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>). In the\nremainder of this page, a child whose state has changed and\nwhich has not yet been waited upon by one of these system\ncalls is termed <i>waitable</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>wait() and\nwaitpid()</b> <br>\nThe <b>wait</b>() system call suspends execution of the\ncalling thread until one of its children terminates. The\ncall <i>wait(&amp;wstatus)</i> is equivalent to:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">waitpid(-1,\n&amp;wstatus, 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>waitpid</b>() system call suspends execution of the\ncalling thread until a child specified by <i>pid</i>\nargument has changed state. By default, <b>waitpid</b>()\nwaits only for terminated children, but this behavior is\nmodifiable via the <i>options</i> argument, as described\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The value of\n<i>pid</i> can be:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>&lt; -1</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>meaning wait for any child process whose process group\nID is equal to the absolute value of <i>pid</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>-1</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>meaning wait for any child process.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>0</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>meaning wait for any child process whose process group\nID is equal to that of the calling process at the time of\nthe call to <b>waitpid</b>().</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>&gt; 0</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>meaning wait for the child whose process ID is equal to\nthe value of <i>pid</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The value of\n<i>options</i> is an OR of zero or more of the following\nconstants: <b><br>\nWNOHANG</b></p>\n\n<p style=\"margin-left:22%;\">return immediately if no child\nhas exited.</p>\n\n<p style=\"margin-left:11%;\"><b>WUNTRACED</b></p>\n\n<p style=\"margin-left:22%;\">also return if a child has\nstopped (but not traced via <a href=\"https://man.page/2/ptrace\">ptrace(2)</a>). Status for\n<i>traced</i> children which have stopped is provided even\nif this option is not specified.</p>\n\n<p style=\"margin-left:11%;\"><b>WCONTINUED</b> (since Linux\n2.6.10)</p>\n\n<p style=\"margin-left:22%;\">also return if a stopped child\nhas been resumed by delivery of <b>SIGCONT</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(For Linux-only\noptions, see below.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>wstatus</i> is not NULL, <b>wait</b>() and\n<b>waitpid</b>() store status information in the <i>int</i>\nto which it points. This integer can be inspected with the\nfollowing macros (which take the integer itself as an\nargument, not a pointer to it, as is done in <b>wait</b>()\nand <b>waitpid</b>()!): <b><br>\nWIFEXITED(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">returns true if the child\nterminated normally, that is, by calling <a href=\"https://man.page/3/exit\">exit(3)</a> or\n<a href=\"https://man.page/2/_exit\">_exit(2)</a>, or by returning from main().</p>\n\n\n<p style=\"margin-left:11%;\"><b>WEXITSTATUS(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">returns the exit status of the\nchild. This consists of the least significant 8 bits of the\n<i>status</i> argument that the child specified in a call to\n<a href=\"https://man.page/3/exit\">exit(3)</a> or <a href=\"https://man.page/2/_exit\">_exit(2)</a> or as the argument for a\nreturn statement in main(). This macro should be employed\nonly if <b>WIFEXITED</b> returned true.</p>\n\n\n<p style=\"margin-left:11%;\"><b>WIFSIGNALED(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">returns true if the child\nprocess was terminated by a signal.</p>\n\n\n<p style=\"margin-left:11%;\"><b>WTERMSIG(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">returns the number of the\nsignal that caused the child process to terminate. This\nmacro should be employed only if <b>WIFSIGNALED</b> returned\ntrue.</p>\n\n\n<p style=\"margin-left:11%;\"><b>WCOREDUMP(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">returns true if the child\nproduced a core dump (see <a href=\"https://man.page/5/core\">core(5)</a>). This macro should\nbe employed only if <b>WIFSIGNALED</b> returned true.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This macro is\nnot specified in POSIX.1-2001 and is not available on some\nUNIX implementations (e.g., AIX, SunOS). Therefore, enclose\nits use inside <i>#ifdef WCOREDUMP ... #endif</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>WIFSTOPPED(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">returns true if the child\nprocess was stopped by delivery of a signal; this is\npossible only if the call was done using <b>WUNTRACED</b> or\nwhen the child is being traced (see <a href=\"https://man.page/2/ptrace\">ptrace(2)</a>).</p>\n\n\n<p style=\"margin-left:11%;\"><b>WSTOPSIG(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">returns the number of the\nsignal which caused the child to stop. This macro should be\nemployed only if <b>WIFSTOPPED</b> returned true.</p>\n\n\n<p style=\"margin-left:11%;\"><b>WIFCONTINUED(</b><i>wstatus</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\">(since Linux 2.6.10) returns\ntrue if the child process was resumed by delivery of\n<b>SIGCONT</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>waitid()</b>\n<br>\nThe <b>waitid</b>() system call (available since Linux\n2.6.9) provides more precise control over which child state\nchanges to wait for.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>idtype</i> and <i>id</i> arguments select the child(ren)\nto wait for, as follows: <i><br>\nidtype</i> == <b>P_PID</b></p>\n\n<p style=\"margin-left:22%;\">Wait for the child whose\nprocess ID matches <i>id</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>idtype</i> == <b>P_PIDFD</b>\n(since Linux 5.4)</p>\n\n<p style=\"margin-left:22%;\">Wait for the child referred to\nby the PID file descriptor specified in <i>id</i>. (See\n<a href=\"https://man.page/2/pidfd_open\">pidfd_open(2)</a> for further information on PID file\ndescriptors.)</p>\n\n<p style=\"margin-left:11%;\"><i>idtype</i> ==\n<b>P_PGID</b></p>\n\n<p style=\"margin-left:22%;\">Wait for any child whose\nprocess group ID matches <i>id</i>. Since Linux 5.4, if\n<i>id</i> is zero, then wait for any child that is in the\nsame process group as the caller&rsquo;s process group at\nthe time of the call.</p>\n\n<p style=\"margin-left:11%;\"><i>idtype</i> ==\n<b>P_ALL</b></p>\n\n<p style=\"margin-left:22%;\">Wait for any child; <i>id</i>\nis ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The child state\nchanges to wait for are specified by ORing one or more of\nthe following flags in <i>options</i>: <b><br>\nWEXITED</b></p>\n\n<p style=\"margin-left:22%;\">Wait for children that have\nterminated.</p>\n\n<p style=\"margin-left:11%;\"><b>WSTOPPED</b></p>\n\n<p style=\"margin-left:22%;\">Wait for children that have\nbeen stopped by delivery of a signal.</p>\n\n<p style=\"margin-left:11%;\"><b>WCONTINUED</b></p>\n\n<p style=\"margin-left:22%;\">Wait for (previously stopped)\nchildren that have been resumed by delivery of\n<b>SIGCONT</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nflags may additionally be ORed in <i>options</i>: <b><br>\nWNOHANG</b></p>\n\n<p style=\"margin-left:22%;\">As for <b>waitpid</b>().</p>\n\n<p style=\"margin-left:11%;\"><b>WNOWAIT</b></p>\n\n<p style=\"margin-left:22%;\">Leave the child in a waitable\nstate; a later wait call can be used to again retrieve the\nchild status information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Upon successful\nreturn, <b>waitid</b>() fills in the following fields of the\n<i>siginfo_t</i> structure pointed to by <i>infop</i>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><i>si_pid</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The process ID of the child.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><i>si_uid</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The real user ID of the child. (This field is not set on\nmost other implementations.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>si_signo</i></p>\n\n<p style=\"margin-left:22%;\">Always set to\n<b>SIGCHLD</b>.</p>\n\n<p style=\"margin-left:11%;\"><i>si_status</i></p>\n\n<p style=\"margin-left:22%;\">Either the exit status of the\nchild, as given to <a href=\"https://man.page/2/_exit\">_exit(2)</a> (or <a href=\"https://man.page/3/exit\">exit(3)</a>), or\nthe signal that caused the child to terminate, stop, or\ncontinue. The <i>si_code</i> field can be used to determine\nhow to interpret this field.</p>\n\n<p style=\"margin-left:11%;\"><i>si_code</i></p>\n\n<p style=\"margin-left:22%;\">Set to one of:\n<b>CLD_EXITED</b> (child called <a href=\"https://man.page/2/_exit\">_exit(2)</a>);\n<b>CLD_KILLED</b> (child killed by signal);\n<b>CLD_DUMPED</b> (child killed by signal, and dumped core);\n<b>CLD_STOPPED</b> (child stopped by signal);\n<b>CLD_TRAPPED</b> (traced child has trapped); or\n<b>CLD_CONTINUED</b> (child continued by\n<b>SIGCONT</b>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>WNOHANG</b> was specified in <i>options</i> and there\nwere no children in a waitable state, then <b>waitid</b>()\nreturns 0 immediately and the state of the <i>siginfo_t</i>\nstructure pointed to by <i>infop</i> depends on the\nimplementation. To (portably) distinguish this case from\nthat where a child was in a waitable state, zero out the\n<i>si_pid</i> field before the call and check for a nonzero\nvalue in this field after the call returns.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2008\nTechnical Corrigendum 1 (2013) adds the requirement that\nwhen <b>WNOHANG</b> is specified in <i>options</i> and there\nwere no children in a waitable state, then <b>waitid</b>()\nshould zero out the <i>si_pid</i> and <i>si_signo</i> fields\nof the structure. On Linux and other implementations that\nadhere to this requirement, it is not necessary to zero out\nthe <i>si_pid</i> field before calling <b>waitid</b>().\nHowever, not all implementations follow the POSIX.1\nspecification on this point.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>wait</b>():\non success, returns the process ID of the terminated child;\non error, -1 is returned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>waitpid</b>():\non success, returns the process ID of the child whose state\nhas changed; if <b>WNOHANG</b> was specified and one or more\nchild(ren) specified by <i>pid</i> exist, but have not yet\nchanged state, then 0 is returned. On error, -1 is\nreturned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>waitid</b>():\nreturns 0 on success or if <b>WNOHANG</b> was specified and\nno child(ren) specified by <i>id</i> has yet changed state;\non error, -1 is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each of these\ncalls sets <i>errno</i> to an appropriate value in the case\nof an error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>ECHILD</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">(for <b>wait</b>()) The calling\nprocess does not have any unwaited-for children.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ECHILD</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(for <b>waitpid</b>() or <b>waitid</b>()) The process\nspecified by <i>pid</i> (<b>waitpid</b>()) or <i>idtype</i>\nand <i>id</i> (<b>waitid</b>()) does not exist or is not a\nchild of the calling process. (This can happen for\none&rsquo;s own child if the action for <b>SIGCHLD</b> is\nset to <b>SIG_IGN</b>. See also the <i>Linux Notes</i>\nsection about threads.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>WNOHANG</b> was not set and an unblocked signal or a\n<b>SIGCHLD</b> was caught; see <a href=\"https://man.page/7/signal\">signal(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>options</i> argument was invalid.</p></td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SVr4, 4.3BSD,\nPOSIX.1-2001.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child that\nterminates, but has not been waited for becomes a\n&quot;zombie&quot;. The kernel maintains a minimal set of\ninformation about the zombie process (PID, termination\nstatus, resource usage information) in order to allow the\nparent to later perform a wait to obtain information about\nthe child. As long as a zombie is not removed from the\nsystem via a wait, it will consume a slot in the kernel\nprocess table, and if this table fills, it will not be\npossible to create further processes. If a parent process\nterminates, then its &quot;zombie&quot; children (if any)\nare adopted by <a href=\"https://man.page/1/init\">init(1)</a>, (or by the nearest\n&quot;subreaper&quot; process as defined through the use of\nthe <a href=\"https://man.page/2/prctl\">prctl(2)</a> <b>PR_SET_CHILD_SUBREAPER</b>\noperation); <a href=\"https://man.page/1/init\">init(1)</a> automatically performs a wait to\nremove the zombies.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001\nspecifies that if the disposition of <b>SIGCHLD</b> is set\nto <b>SIG_IGN</b> or the <b>SA_NOCLDWAIT</b> flag is set for\n<b>SIGCHLD</b> (see <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>), then children that\nterminate do not become zombies and a call to <b>wait</b>()\nor <b>waitpid</b>() will block until all children have\nterminated, and then fail with <i>errno</i> set to\n<b>ECHILD</b>. (The original POSIX standard left the\nbehavior of setting <b>SIGCHLD</b> to <b>SIG_IGN</b>\nunspecified. Note that even though the default disposition\nof <b>SIGCHLD</b> is &quot;ignore&quot;, explicitly setting\nthe disposition to <b>SIG_IGN</b> results in different\ntreatment of zombie process children.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux 2.6\nconforms to the POSIX requirements. However, Linux 2.4 (and\nearlier) does not: if a <b>wait</b>() or <b>waitpid</b>()\ncall is made while <b>SIGCHLD</b> is being ignored, the call\nbehaves just as though <b>SIGCHLD</b> were not being\nignored, that is, the call blocks until the next child\nterminates and then returns the process ID and status of\nthat child.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Linux\nnotes</b> <br>\nIn the Linux kernel, a kernel-scheduled thread is not a\ndistinct construct from a process. Instead, a thread is\nsimply a process that is created using the Linux-unique\n<a href=\"https://man.page/2/clone\">clone(2)</a> system call; other routines such as the\nportable <a href=\"https://man.page/3/pthread_create\">pthread_create(3)</a> call are implemented using\n<a href=\"https://man.page/2/clone\">clone(2)</a>. Before Linux 2.4, a thread was just a\nspecial case of a process, and as a consequence one thread\ncould not wait on the children of another thread, even when\nthe latter belongs to the same thread group. However, POSIX\nprescribes such functionality, and since Linux 2.4 a thread\ncan, and by default will, wait on children of other threads\nin the same thread group.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nLinux-specific <i>options</i> are for use with children\ncreated using <a href=\"https://man.page/2/clone\">clone(2)</a>; they can also, since Linux\n4.7, be used with <b>waitid</b>(): <b><br>\n__WCLONE</b></p>\n\n<p style=\"margin-left:22%;\">Wait for &quot;clone&quot;\nchildren only. If omitted, then wait for\n&quot;non-clone&quot; children only. (A &quot;clone&quot;\nchild is one which delivers no signal, or a signal other\nthan <b>SIGCHLD</b> to its parent upon termination.) This\noption is ignored if <b>__WALL</b> is also specified.</p>\n\n<p style=\"margin-left:11%;\"><b>__WALL</b> (since Linux\n2.4)</p>\n\n<p style=\"margin-left:22%;\">Wait for all children,\nregardless of type (&quot;clone&quot; or\n&quot;non-clone&quot;).</p>\n\n<p style=\"margin-left:11%;\"><b>__WNOTHREAD</b> (since Linux\n2.4)</p>\n\n<p style=\"margin-left:22%;\">Do not wait for children of\nother threads in the same thread group. This was the default\nbefore Linux 2.4.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n4.7, the <b>__WALL</b> flag is automatically implied if the\nchild is being ptraced.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences <br>\nwait</b>() is actually a library function that (in glibc) is\nimplemented as a call to <a href=\"https://man.page/2/wait4\">wait4(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On some\narchitectures, there is no <b>waitpid</b>() system call;\ninstead, this interface is implemented via a C library\nwrapper function that calls <a href=\"https://man.page/2/wait4\">wait4(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The raw\n<b>waitid</b>() system call takes a fifth argument, of type\n<i>struct rusage&nbsp;*</i>. If this argument is non-NULL,\nthen it is used to return resource usage information about\nthe child, in the same manner as <a href=\"https://man.page/2/wait4\">wait4(2)</a>. See\n<a href=\"https://man.page/2/getrusage\">getrusage(2)</a> for details.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1-2008, an application calling <b>waitid</b>() must\nensure that <i>infop</i> points to a <i>siginfo_t</i>\nstructure (i.e., that it is a non-null pointer). On Linux,\nif <i>infop</i> is NULL, <b>waitid</b>() succeeds, and\nreturns the process ID of the waited-for child. Applications\nshould avoid relying on this inconsistent, nonstandard, and\nunnecessary feature.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram demonstrates the use of <a href=\"https://man.page/2/fork\">fork(2)</a> and\n<b>waitpid</b>(). The program creates a child process. If no\ncommand-line argument is supplied to the program, then the\nchild suspends its execution using <a href=\"https://man.page/2/pause\">pause(2)</a>, to allow\nthe user to send signals to the child. Otherwise, if a\ncommand-line argument is supplied, then the child exits\nimmediately, using the integer supplied on the command line\nas the exit status. The parent process executes a loop that\nmonitors the child using <b>waitpid</b>(), and uses the W*()\nmacros described above to analyze the wait status value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session demonstrates the use of the program:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out\n&amp;</b> <br>\nChild PID is 32360 <br>\n[1] 32359 <br>\n$ <b>kill -STOP 32360</b> <br>\nstopped by signal 19 <br>\n$ <b>kill -CONT 32360</b> <br>\ncontinued <br>\n$ <b>kill -TERM 32360</b> <br>\nkilled by signal 15 <br>\n[1]+ Done ./a.out <br>\n$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;sys/wait.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdio.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\npid_t cpid, w; <br>\nint wstatus;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">cpid = fork();\n<br>\nif (cpid == -1) { <br>\nperror(&quot;fork&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (cpid == 0)\n{ /* Code executed by child */ <br>\nprintf(&quot;Child PID is %jd\\n&quot;, (intmax_t) getpid());\n<br>\nif (argc == 1) <br>\npause(); /* Wait for signals */ <br>\n_exit(atoi(argv[1]));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">} else { /*\nCode executed by parent */ <br>\ndo { <br>\nw = waitpid(cpid, &amp;wstatus, WUNTRACED | WCONTINUED);\n<br>\nif (w == -1) { <br>\nperror(&quot;waitpid&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(WIFEXITED(wstatus)) { <br>\nprintf(&quot;exited, status=%d\\n&quot;,\nWEXITSTATUS(wstatus)); <br>\n} else if (WIFSIGNALED(wstatus)) { <br>\nprintf(&quot;killed by signal %d\\n&quot;,\nWTERMSIG(wstatus)); <br>\n} else if (WIFSTOPPED(wstatus)) { <br>\nprintf(&quot;stopped by signal %d\\n&quot;,\nWSTOPSIG(wstatus)); <br>\n} else if (WIFCONTINUED(wstatus)) { <br>\nprintf(&quot;continued\\n&quot;); <br>\n} <br>\n} while (!WIFEXITED(wstatus) &amp;&amp;\n!WIFSIGNALED(wstatus)); <br>\nexit(EXIT_SUCCESS); <br>\n} <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/_exit\">_exit(2)</a>,\n<a href=\"https://man.page/2/clone\">clone(2)</a>, <a href=\"https://man.page/2/fork\">fork(2)</a>, <a href=\"https://man.page/2/kill\">kill(2)</a>,\n<a href=\"https://man.page/2/ptrace\">ptrace(2)</a>, <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>, <a href=\"https://man.page/2/signal\">signal(2)</a>,\n<a href=\"https://man.page/2/wait4\">wait4(2)</a>, <a href=\"https://man.page/3/pthread_create\">pthread_create(3)</a>, <a href=\"https://man.page/5/core\">core(5)</a>,\n<a href=\"https://man.page/7/credentials\">credentials(7)</a>, <a href=\"https://man.page/7/signal\">signal(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}