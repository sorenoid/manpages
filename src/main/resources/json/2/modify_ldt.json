{"name":"modify_ldt","description":"modify_ldt -\nget or set a per-process LDT entry","body":"\n\n<h1 align=\"center\">MODIFY_LDT</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">modify_ldt -\nget or set a per-process LDT entry</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/types.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nmodify_ldt(int</b> <i>func</i><b>, void *</b><i>ptr</i><b>,\nunsigned long</b> <i>bytecount</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere is no glibc wrapper for this system call; see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>modify_ldt</b>()\nreads or writes the local descriptor table (LDT) for a\nprocess. The LDT is an array of segment descriptors that can\nbe referenced by user code. Linux allows processes to\nconfigure a per-process (actually per-mm) LDT. For more\ninformation about the LDT, see the Intel Software\nDeveloper&rsquo;s Manual or the AMD Architecture Programming\nManual.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<i>func</i> is 0, <b>modify_ldt</b>() reads the LDT into the\nmemory pointed to by <i>ptr</i>. The number of bytes read is\nthe smaller of <i>bytecount</i> and the actual size of the\nLDT, although the kernel may act as though the LDT is padded\nwith additional trailing zero bytes. On success,\n<b>modify_ldt</b>() will return the number of bytes\nread.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<i>func</i> is 1 or 0x11, <b>modify_ldt</b>() modifies the\nLDT entry indicated by <i>ptr-&gt;entry_number</i>.\n<i>ptr</i> points to a <i>user_desc</i> structure and\n<i>bytecount</i> must equal the size of this structure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>user_desc</i> structure is defined in\n<i>&lt;asm/ldt.h&gt;</i> as:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nuser_desc { <br>\nunsigned int entry_number; <br>\nunsigned int base_addr; <br>\nunsigned int limit; <br>\nunsigned int seg_32bit:1; <br>\nunsigned int contents:2; <br>\nunsigned int read_exec_only:1; <br>\nunsigned int limit_in_pages:1; <br>\nunsigned int seg_not_present:1; <br>\nunsigned int useable:1; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux 2.4\nand earlier, this structure was named\n<i>modify_ldt_ldt_s</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>contents</i> field is the segment type (data, expand-down\ndata, non-conforming code, or conforming code). The other\nfields match their descriptions in the CPU manual, although\n<b>modify_ldt</b>() cannot set the hardware-defined\n&quot;accessed&quot; bit described in the CPU manual.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<i>user_desc</i> is considered &quot;empty&quot; if\n<i>read_exec_only</i> and <i>seg_not_present</i> are set to\n1 and all of the other fields are 0. An LDT entry can be\ncleared by setting it to an &quot;empty&quot;\n<i>user_desc</i> or, if <i>func</i> is 1, by setting both\n<i>base</i> and <i>limit</i> to 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A conforming\ncode segment (i.e., one with <i>contents==3</i>) will be\nrejected if <i>func</i> is 1 or if <i>seg_not_present</i> is\n0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<i>func</i> is 2, <b>modify_ldt</b>() will read zeros. This\nappears to be a leftover from Linux 2.4.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>modify_ldt</b>() returns either the actual number of\nbytes read (for reading) or 0 (for writing). On failure,\n<b>modify_ldt</b>() returns -1 and sets <i>errno</i> to\nindicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><i>ptr</i> points outside the\naddress space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>ptr</i> is 0, or <i>func</i> is 1 and\n<i>bytecount</i> is not equal to the size of the structure\n<i>user_desc</i>, or <i>func</i> is 1 or 0x11 and the new\nLDT entry has invalid values.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>func</i> is neither 0, 1, 2, nor 0x11.</p></td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This call is\nLinux-specific and should not be used in programs intended\nto be portable.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glibc does not\nprovide a wrapper for this system call; call it using\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>modify_ldt</b>()\nshould not be used for thread-local storage, as it slows\ndown context switches and only supports a limited number of\nthreads. Threading libraries should use\n<a href=\"https://man.page/2/set_thread_area\">set_thread_area(2)</a> or <a href=\"https://man.page/2/arch_prctl\">arch_prctl(2)</a> instead,\nexcept on extremely old kernels that do not support those\nsystem calls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The normal use\nfor <b>modify_ldt</b>() is to run legacy 16-bit or segmented\n32-bit code. Not all kernels allow 16-bit segments to be\ninstalled, however.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Even on 64-bit\nkernels, <b>modify_ldt</b>() cannot be used to create a long\nmode (i.e., 64-bit) code segment. The undocumented field\n&quot;lm&quot; in <i>user_desc</i> is not useful, and,\ndespite its name, does not result in a long mode\nsegment.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On 64-bit\nkernels before Linux 3.19, setting the &quot;lm&quot; bit in\n<i>user_desc</i> prevents the descriptor from being\nconsidered empty. Keep in mind that the &quot;lm&quot; bit\ndoes not exist in the 32-bit headers, but these buggy\nkernels will still notice the bit even when set in a 32-bit\nprocess.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/arch_prctl\">arch_prctl(2)</a>,\n<a href=\"https://man.page/2/set_thread_area\">set_thread_area(2)</a>, <a href=\"https://man.page/2/vm86\">vm86(2)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}