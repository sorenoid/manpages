{"name":"recvmmsg","body":"\n\n<h1 align=\"center\">RECVMMSG</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">recvmmsg -\nreceive multiple messages on a socket</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;sys/socket.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nrecvmmsg(int</b> <i>sockfd</i><b>, struct mmsghdr\n*</b><i>msgvec</i><b>, unsigned int</b> <i>vlen</i><b>, <br>\nint</b> <i>flags</i><b>, struct timespec\n*</b><i>timeout</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>recvmmsg</b>() system call is an extension of\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a> that allows the caller to receive multiple\nmessages from a socket using a single system call. (This has\nperformance benefits for some applications.) A further\nextension over <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a> is support for a timeout on\nthe receive operation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>sockfd</i> argument is the file descriptor of the socket\nto receive data from.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>msgvec</i> argument is a pointer to an array of\n<i>mmsghdr</i> structures. The size of this array is\nspecified in <i>vlen</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>mmsghdr</i> structure is defined in\n<i>&lt;sys/socket.h&gt;</i> as:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct mmsghdr\n{ <br>\nstruct msghdr msg_hdr; /* Message header */ <br>\nunsigned int msg_len; /* Number of received bytes for header\n*/ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>msg_hdr</i> field is a <i>msghdr</i> structure, as\ndescribed in <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>. The <i>msg_len</i> field is\nthe number of bytes returned for the message in the entry.\nThis field has the same value as the return value of a\nsingle <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a> on the header.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument contains flags ORed together. The\nflags are the same as documented for <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>, with\nthe following addition: <b><br>\nMSG_WAITFORONE</b> (since Linux 2.6.34)</p>\n\n<p style=\"margin-left:22%;\">Turns on <b>MSG_DONTWAIT</b>\nafter the first message has been received.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>timeout</i> argument points to a <i>struct timespec</i>\n(see <a href=\"https://man.page/2/clock_gettime\">clock_gettime(2)</a>) defining a timeout (seconds\nplus nanoseconds) for the receive operation (<i>but see\nBUGS!</i>). (This interval will be rounded up to the system\nclock granularity, and kernel scheduling delays mean that\nthe blocking interval may overrun by a small amount.) If\n<i>timeout</i> is NULL, then the operation blocks\nindefinitely.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A blocking\n<b>recvmmsg</b>() call blocks until <i>vlen</i> messages\nhave been received or until the timeout expires. A\nnonblocking call reads as many messages as are available (up\nto the limit specified by <i>vlen</i>) and returns\nimmediately.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On return from\n<b>recvmmsg</b>(), successive elements of <i>msgvec</i> are\nupdated to contain information about each received message:\n<i>msg_len</i> contains the size of the received message;\nthe subfields of <i>msg_hdr</i> are updated as described in\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>. The return value of the call indicates\nthe number of elements of <i>msgvec</i> that have been\nupdated.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>recvmmsg</b>() returns the number of messages received in\n<i>msgvec</i>; on error, -1 is returned, and <i>errno</i> is\nset to indicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Errors are as\nfor <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>. In addition, the following error can\noccur:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"29%\">\n\n\n<p><i>timeout</i> is invalid.</p></td>\n<td width=\"49%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See also\nBUGS.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>recvmmsg</b>() system call was added in Linux 2.6.33.\nSupport in glibc was added in version 2.12.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>recvmmsg</b>()\nis Linux-specific.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>timeout</i> argument does not work as intended. The\ntimeout is checked only after the receipt of each datagram,\nso that if up to <i>vlen-1</i> datagrams are received before\nthe timeout expires, but then no further datagrams are\nreceived, the call will block forever.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If an error\noccurs after at least one message has been received, the\ncall succeeds, and returns the number of messages received.\nThe error code is expected to be returned on a subsequent\ncall to <b>recvmmsg</b>(). In the current implementation,\nhowever, the error code can be overwritten in the meantime\nby an unrelated network event on a socket, for example an\nincoming ICMP packet.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram uses <b>recvmmsg</b>() to receive multiple messages\non a socket and stores them in multiple buffers. The call\nreturns if all buffers are filled or if the timeout\nspecified has expired.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsnippet periodically generates UDP datagrams containing a\nrandom number:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>while\ntrue; do echo $RANDOM &gt; /dev/udp/127.0.0.1/1234; <br>\nsleep 0.25; done</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These datagrams\nare read by the example application, which can give the\nfollowing output:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./a.out</b> <br>\n5 messages received <br>\n1 11782 <br>\n2 11345 <br>\n3 304 <br>\n4 13514 <br>\n5 28421</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;netinet/ip.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;sys/socket.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(void) <br>\n{ <br>\n#define VLEN 10 <br>\n#define BUFSIZE 200 <br>\n#define TIMEOUT 1 <br>\nint sockfd, retval; <br>\nstruct sockaddr_in addr; <br>\nstruct mmsghdr msgs[VLEN]; <br>\nstruct iovec iovecs[VLEN]; <br>\nchar bufs[VLEN][BUFSIZE+1]; <br>\nstruct timespec timeout;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sockfd =\nsocket(AF_INET, SOCK_DGRAM, 0); <br>\nif (sockfd == -1) { <br>\nperror(&quot;socket()&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">addr.sin_family\n= AF_INET; <br>\naddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); <br>\naddr.sin_port = htons(1234); <br>\nif (bind(sockfd, (struct sockaddr *) &amp;addr,\nsizeof(addr)) == -1) { <br>\nperror(&quot;bind()&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(msgs, 0,\nsizeof(msgs)); <br>\nfor (int i = 0; i &lt; VLEN; i++) { <br>\niovecs[i].iov_base = bufs[i]; <br>\niovecs[i].iov_len = BUFSIZE; <br>\nmsgs[i].msg_hdr.msg_iov = &amp;iovecs[i]; <br>\nmsgs[i].msg_hdr.msg_iovlen = 1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">timeout.tv_sec\n= TIMEOUT; <br>\ntimeout.tv_nsec = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">retval =\nrecvmmsg(sockfd, msgs, VLEN, 0, &amp;timeout); <br>\nif (retval == -1) { <br>\nperror(&quot;recvmmsg()&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;%d\nmessages received\\n&quot;, retval); <br>\nfor (int i = 0; i &lt; retval; i++) { <br>\nbufs[i][msgs[i].msg_len] = 0; <br>\nprintf(&quot;%d %s&quot;, i+1, bufs[i]); <br>\n} <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/clock_gettime\">clock_gettime(2)</a>,\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>, <a href=\"https://man.page/2/sendmmsg\">sendmmsg(2)</a>, <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>,\n<a href=\"https://man.page/2/socket\">socket(2)</a>, <a href=\"https://man.page/7/socket\">socket(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}