{"name":"semop","body":"\n\n<h1 align=\"center\">SEMOP</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">semop,\nsemtimedop - System V semaphore operations</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/types.h&gt; <br>\n#include &lt;sys/ipc.h&gt; <br>\n#include &lt;sys/sem.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nsemop(int</b> <i>semid</i><b>, struct sembuf\n*</b><i>sops</i><b>, size_t</b> <i>nsops</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nsemtimedop(int</b> <i>semid</i><b>, struct sembuf\n*</b><i>sops</i><b>, size_t</b> <i>nsops</i><b>, <br>\nconst struct timespec *</b><i>timeout</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>semtimedop</b>():\n_GNU_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each semaphore\nin a System&nbsp;V semaphore set has the following\nassociated values:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">unsigned short\nsemval; /* semaphore value */ <br>\nunsigned short semzcnt; /* # waiting for zero */ <br>\nunsigned short semncnt; /* # waiting for increase */ <br>\npid_t sempid; /* PID of process that last</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>semop</b>()\nperforms operations on selected semaphores in the set\nindicated by <i>semid</i>. Each of the <i>nsops</i> elements\nin the array pointed to by <i>sops</i> is a structure that\nspecifies an operation to be performed on a single\nsemaphore. The elements of this structure are of type\n<i>struct sembuf</i>, containing the following members:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">unsigned short\nsem_num; /* semaphore number */ <br>\nshort sem_op; /* semaphore operation */ <br>\nshort sem_flg; /* operation flags */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Flags\nrecognized in <i>sem_flg</i> are <b>IPC_NOWAIT</b> and\n<b>SEM_UNDO</b>. If an operation specifies <b>SEM_UNDO</b>,\nit will be automatically undone when the process\nterminates.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The set of\noperations contained in <i>sops</i> is performed in <i>array\norder</i>, and <i>atomically</i>, that is, the operations\nare performed either as a complete unit, or not at all. The\nbehavior of the system call if not all operations can be\nperformed immediately depends on the presence of the\n<b>IPC_NOWAIT</b> flag in the individual <i>sem_flg</i>\nfields, as noted below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each operation\nis performed on the <i>sem_num</i>-th semaphore of the\nsemaphore set, where the first semaphore of the set is\nnumbered 0. There are three types of operation,\ndistinguished by the value of <i>sem_op</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>sem_op</i> is a positive integer, the operation adds this\nvalue to the semaphore value (<i>semval</i>). Furthermore,\nif <b>SEM_UNDO</b> is specified for this operation, the\nsystem subtracts the value <i>sem_op</i> from the semaphore\nadjustment (<i>semadj</i>) value for this semaphore. This\noperation can always proceed&mdash;it never forces a thread\nto wait. The calling process must have alter permission on\nthe semaphore set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>sem_op</i> is zero, the process must have read permission\non the semaphore set. This is a &quot;wait-for-zero&quot;\noperation: if <i>semval</i> is zero, the operation can\nimmediately proceed. Otherwise, if <b>IPC_NOWAIT</b> is\nspecified in <i>sem_flg</i>, <b>semop</b>() fails with\n<i>errno</i> set to <b>EAGAIN</b> (and none of the\noperations in <i>sops</i> is performed). Otherwise,\n<i>semzcnt</i> (the count of threads waiting until this\nsemaphore&rsquo;s value becomes zero) is incremented by one\nand the thread sleeps until one of the following occurs:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>semval</i> becomes 0, at which time the value of\n<i>semzcnt</i> is decremented.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The semaphore set is removed: <b>semop</b>() fails, with\n<i>errno</i> set to <b>EIDRM</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The calling thread catches a signal: the value of\n<i>semzcnt</i> is decremented and <b>semop</b>() fails, with\n<i>errno</i> set to <b>EINTR</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>sem_op</i> is less than zero, the process must have alter\npermission on the semaphore set. If <i>semval</i> is greater\nthan or equal to the absolute value of <i>sem_op</i>, the\noperation can proceed immediately: the absolute value of\n<i>sem_op</i> is subtracted from <i>semval</i>, and, if\n<b>SEM_UNDO</b> is specified for this operation, the system\nadds the absolute value of <i>sem_op</i> to the semaphore\nadjustment (<i>semadj</i>) value for this semaphore. If the\nabsolute value of <i>sem_op</i> is greater than\n<i>semval</i>, and <b>IPC_NOWAIT</b> is specified in\n<i>sem_flg</i>, <b>semop</b>() fails, with <i>errno</i> set\nto <b>EAGAIN</b> (and none of the operations in <i>sops</i>\nis performed). Otherwise, <i>semncnt</i> (the counter of\nthreads waiting for this semaphore&rsquo;s value to\nincrease) is incremented by one and the thread sleeps until\none of the following occurs:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\"><i>semval</i> becomes greater\nthan or equal to the absolute value of <i>sem_op</i>: the\noperation now proceeds, as described above.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The semaphore set is removed from the system:\n<b>semop</b>() fails, with <i>errno</i> set to\n<b>EIDRM</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The calling thread catches a signal: the value of\n<i>semncnt</i> is decremented and <b>semop</b>() fails, with\n<i>errno</i> set to <b>EINTR</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On successful\ncompletion, the <i>sempid</i> value for each semaphore\nspecified in the array pointed to by <i>sops</i> is set to\nthe caller&rsquo;s process ID. In addition, the\n<i>sem_otime</i> is set to the current time.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>semtimedop()\n<br>\nsemtimedop</b>() behaves identically to <b>semop</b>()\nexcept that in those cases where the calling thread would\nsleep, the duration of that sleep is limited by the amount\nof elapsed time specified by the <i>timespec</i> structure\nwhose address is passed in the <i>timeout</i> argument.\n(This sleep interval will be rounded up to the system clock\ngranularity, and kernel scheduling delays mean that the\ninterval may overrun by a small amount.) If the specified\ntime limit has been reached, <b>semtimedop</b>() fails with\n<i>errno</i> set to <b>EAGAIN</b> (and none of the\noperations in <i>sops</i> is performed). If the\n<i>timeout</i> argument is NULL, then <b>semtimedop</b>()\nbehaves exactly like <b>semop</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that if\n<b>semtimedop</b>() is interrupted by a signal, causing the\ncall to fail with the error <b>EINTR</b>, the contents of\n<i>timeout</i> are left unchanged.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If successful,\n<b>semop</b>() and <b>semtimedop</b>() return 0; otherwise\nthey return -1 with <i>errno</i> indicating the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On failure,\n<i>errno</i> is set to one of the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>E2BIG</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The argument <i>nsops</i> is\ngreater than <b>SEMOPM</b>, the maximum number of operations\nallowed per system call.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The calling process does not have the permissions\nrequired to perform the specified semaphore operations, and\ndoes not have the <b>CAP_IPC_OWNER</b> capability in the\nuser namespace that governs its IPC namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An operation could not proceed immediately and either\n<b>IPC_NOWAIT</b> was specified in <i>sem_flg</i> or the\ntime limit specified in <i>timeout</i> expired.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An address specified in either the <i>sops</i> or the\n<i>timeout</i> argument isn&rsquo;t accessible.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFBIG</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>For some operation the value of <i>sem_num</i> is less\nthan 0 or greater than or equal to the number of semaphores\nin the set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIDRM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The semaphore set was removed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>While blocked in this system call, the thread caught a\nsignal; see <a href=\"https://man.page/7/signal\">signal(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The semaphore set doesn&rsquo;t exist, or <i>semid</i>\nis less than zero, or <i>nsops</i> has a nonpositive\nvalue.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>sem_flg</i> of some operation specified\n<b>SEM_UNDO</b> and the system does not have enough memory\nto allocate the undo structure.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ERANGE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>For some operation <i>sem_op+semval</i> is greater than\n<b>SEMVMX</b>, the implementation dependent maximum value\nfor <i>semval</i>.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>semtimedop</b>()\nfirst appeared in Linux 2.5.52, and was subsequently\nbackported into kernel 2.4.22. Glibc support for\n<b>semtimedop</b>() first appeared in version 2.3.3.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008, SVr4.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inclusion\nof <i>&lt;sys/types.h&gt;</i> and <i>&lt;sys/ipc.h&gt;</i>\nisn&rsquo;t required on Linux or by any version of POSIX.\nHowever, some old implementations required the inclusion of\nthese header files, and the SVID also documented their\ninclusion. Applications intended to be portable to such old\nsystems may need to include these header files.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>sem_undo</i> structures of a process aren&rsquo;t\ninherited by the child produced by <a href=\"https://man.page/2/fork\">fork(2)</a>, but they\nare inherited across an <a href=\"https://man.page/2/execve\">execve(2)</a> system call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>semop</b>()\nis never automatically restarted after being interrupted by\na signal handler, regardless of the setting of the\n<b>SA_RESTART</b> flag when establishing a signal\nhandler.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A semaphore\nadjustment (<i>semadj</i>) value is a per-process,\nper-semaphore integer that is the negated sum of all\noperations performed on a semaphore specifying the\n<b>SEM_UNDO</b> flag. Each process has a list of\n<i>semadj</i> values&mdash;one value for each semaphore on\nwhich it has operated using <b>SEM_UNDO</b>. When a process\nterminates, each of its per-semaphore <i>semadj</i> values\nis added to the corresponding semaphore, thus undoing the\neffect of that process&rsquo;s operations on the semaphore\n(but see BUGS below). When a semaphore&rsquo;s value is\ndirectly set using the <b>SETVAL</b> or <b>SETALL</b>\nrequest to <a href=\"https://man.page/2/semctl\">semctl(2)</a>, the corresponding <i>semadj</i>\nvalues in all processes are cleared. The <a href=\"https://man.page/2/clone\">clone(2)</a>\n<b>CLONE_SYSVSEM</b> flag allows more than one process to\nshare a <i>semadj</i> list; see <a href=\"https://man.page/2/clone\">clone(2)</a> for\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>semval</i>, <i>sempid</i>, <i>semzcnt</i>, and\n<i>semnct</i> values for a semaphore can all be retrieved\nusing appropriate <a href=\"https://man.page/2/semctl\">semctl(2)</a> calls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Semaphore\nlimits</b> <br>\nThe following limits on semaphore set resources affect the\n<b>semop</b>() call:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>SEMOPM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Maximum number of operations\nallowed for one <b>semop</b>() call. Before Linux 3.19, the\ndefault value for this limit was 32. Since Linux 3.19, the\ndefault value is 500. On Linux, this limit can be read and\nmodified via the third field of <i>/proc/sys/kernel/sem</i>.\n<i>Note</i>: this limit should not be raised above 1000,\nbecause of the risk of that <b>semop</b>() fails due to\nkernel memory fragmentation when allocating memory to copy\nthe <i>sops</i> array.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>SEMVMX</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Maximum allowable value for <i>semval</i>:\nimplementation dependent (32767).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nimplementation has no intrinsic limits for the adjust on\nexit maximum value (<b>SEMAEM</b>), the system wide maximum\nnumber of undo structures (<b>SEMMNU</b>) and the\nper-process maximum number of undo entries system\nparameters.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a process\nterminates, its set of associated <i>semadj</i> structures\nis used to undo the effect of all of the semaphore\noperations it performed with the <b>SEM_UNDO</b> flag. This\nraises a difficulty: if one (or more) of these semaphore\nadjustments would result in an attempt to decrease a\nsemaphore&rsquo;s value below zero, what should an\nimplementation do? One possible approach would be to block\nuntil all the semaphore adjustments could be performed. This\nis however undesirable since it could force process\ntermination to block for arbitrarily long periods. Another\npossibility is that such semaphore adjustments could be\nignored altogether (somewhat analogously to failing when\n<b>IPC_NOWAIT</b> is specified for a semaphore operation).\nLinux adopts a third approach: decreasing the semaphore\nvalue as far as possible (i.e., to zero) and allowing\nprocess termination to proceed immediately.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In kernels\n2.6.x, x &lt;= 10, there is a bug that in some circumstances\nprevents a thread that is waiting for a semaphore value to\nbecome zero from being woken up when the value does actually\nbecome zero. This bug is fixed in kernel 2.6.11.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\ncode segment uses <b>semop</b>() to atomically wait for the\nvalue of semaphore 0 to become zero, and then increment the\nsemaphore value by one.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct sembuf\nsops[2]; <br>\nint semid;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Code to set\n<i>semid</i> omitted */</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">sops[0].sem_num\n= 0; /* Operate on semaphore 0 */ <br>\nsops[0].sem_op = 0; /* Wait for value to equal 0 */ <br>\nsops[0].sem_flg = 0;</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">sops[1].sem_num\n= 0; /* Operate on semaphore 0 */ <br>\nsops[1].sem_op = 1; /* Increment value by one */ <br>\nsops[1].sem_flg = 0;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(semop(semid, sops, 2) == -1) { <br>\nperror(&quot;semop&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A further\nexample of the use of <b>semop</b>() can be found in\n<a href=\"https://man.page/2/shmop\">shmop(2)</a>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/clone\">clone(2)</a>,\n<a href=\"https://man.page/2/semctl\">semctl(2)</a>, <a href=\"https://man.page/2/semget\">semget(2)</a>, <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/sem_overview\">sem_overview(7)</a>,\n<a href=\"https://man.page/7/sysvipc\">sysvipc(7)</a>, <a href=\"https://man.page/7/time\">time(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}