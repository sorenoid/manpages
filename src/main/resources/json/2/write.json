{"name":"write","body":"\n\n<h1 align=\"center\">WRITE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">write - write\nto a file descriptor</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;unistd.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ssize_t\nwrite(int</b> <i>fd</i><b>, const void *</b><i>buf</i><b>,\nsize_t</b> <i>count</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>write</b>()\nwrites up to <i>count</i> bytes from the buffer starting at\n<i>buf</i> to the file referred to by the file descriptor\n<i>fd</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The number of\nbytes written may be less than <i>count</i> if, for example,\nthere is insufficient space on the underlying physical\nmedium, or the <b>RLIMIT_FSIZE</b> resource limit is\nencountered (see <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>), or the call was\ninterrupted by a signal handler after having written less\nthan <i>count</i> bytes. (See also <a href=\"https://man.page/7/pipe\">pipe(7)</a>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a seekable\nfile (i.e., one to which <a href=\"https://man.page/2/lseek\">lseek(2)</a> may be applied, for\nexample, a regular file) writing takes place at the file\noffset, and the file offset is incremented by the number of\nbytes actually written. If the file was <a href=\"https://man.page/2/open\">open(2)</a>ed\nwith <b>O_APPEND</b>, the file offset is first set to the\nend of the file before writing. The adjustment of the file\noffset and the write operation are performed as an atomic\nstep.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX requires\nthat a <a href=\"https://man.page/2/read\">read(2)</a> that can be proved to occur after a\n<b>write</b>() has returned will return the new data. Note\nthat not all filesystems are POSIX conforming.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1, if <i>count</i> is greater than <b>SSIZE_MAX</b>,\nthe result is implementation-defined; see NOTES for the\nupper limit on Linux.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success, the\nnumber of bytes written is returned. On error, -1 is\nreturned, and <i>errno</i> is set to indicate the cause of\nthe error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that a\nsuccessful <b>write</b>() may transfer fewer than\n<i>count</i> bytes. Such partial writes can occur for\nvarious reasons; for example, because there was insufficient\nspace on the disk device to write all of the requested\nbytes, or because a blocked <b>write</b>() to a socket,\npipe, or similar was interrupted by a signal handler after\nit had transferred some, but before it had transferred all\nof the requested bytes. In the event of a partial write, the\ncaller can make another <b>write</b>() call to transfer the\nremaining bytes. The subsequent call will either transfer\nfurther bytes or may result in an error (e.g., if the disk\nis now full).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>count</i>\nis zero and <i>fd</i> refers to a regular file, then\n<b>write</b>() may return a failure status if one of the\nerrors below is detected. If no errors are detected, or\nerror detection is not performed, 0 will be returned without\ncausing any other effect. If <i>count</i> is zero and\n<i>fd</i> refers to a file other than a regular file, the\nresults are not specified.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The file descriptor <i>fd</i>\nrefers to a file other than a socket and has been marked\nnonblocking (<b>O_NONBLOCK</b>), and the write would block.\nSee <a href=\"https://man.page/2/open\">open(2)</a> for further details on the\n<b>O_NONBLOCK</b> flag.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EAGAIN</b> or\n<b>EWOULDBLOCK</b></p>\n\n<p style=\"margin-left:22%;\">The file descriptor <i>fd</i>\nrefers to a socket and has been marked nonblocking\n(<b>O_NONBLOCK</b>), and the write would block. POSIX.1-2001\nallows either error to be returned for this case, and does\nnot require these constants to have the same value, so a\nportable application should check for both\npossibilities.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is not a valid file descriptor or is not open\nfor writing.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EDESTADDRREQ</b></p>\n\n<p style=\"margin-left:22%;\"><i>fd</i> refers to a datagram\nsocket for which a peer address has not been set using\n<a href=\"https://man.page/2/connect\">connect(2)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EDQUOT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The user&rsquo;s quota of disk blocks on the filesystem\ncontaining the file referred to by <i>fd</i> has been\nexhausted.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>buf</i> is outside your accessible address space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFBIG</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An attempt was made to write a file that exceeds the\nimplementation-defined maximum file size or the\nprocess&rsquo;s file size limit, or to write at a position\npast the maximum allowed offset.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The call was interrupted by a signal before any data was\nwritten; see <a href=\"https://man.page/7/signal\">signal(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is attached to an object which is unsuitable\nfor writing; or the file was opened with the <b>O_DIRECT</b>\nflag, and either the address specified in <i>buf</i>, the\nvalue specified in <i>count</i>, or the file offset is not\nsuitably aligned.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A low-level I/O error occurred while modifying the\ninode. This error may relate to the write-back of data\nwritten by an earlier <b>write</b>(), which may have been\nissued to a different file descriptor on the same file.\nSince Linux 4.13, errors from write-back come with a promise\nthat they <i>may</i> be reported by subsequent.\n<b>write</b>() requests, and <i>will</i> be reported by a\nsubsequent <a href=\"https://man.page/2/fsync\">fsync(2)</a> (whether or not they were also\nreported by <b>write</b>()). An alternate cause of\n<b>EIO</b> on networked filesystems is when an advisory lock\nhad been taken out on the file descriptor and this lock has\nbeen lost. See the <i>Lost locks</i> section of\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a> for further details.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSPC</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The device containing the file referred to by <i>fd</i>\nhas no room for the data.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The operation was prevented by a file seal; see\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPIPE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is connected to a pipe or socket whose reading\nend is closed. When this happens the writing process will\nalso receive a <b>SIGPIPE</b> signal. (Thus, the write\nreturn value is seen only if the program catches, blocks or\nignores this signal.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other errors\nmay occur, depending on the object connected to\n<i>fd</i>.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SVr4, 4.3BSD,\nPOSIX.1-2001.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Under SVr4 a\nwrite may be interrupted and return <b>EINTR</b> at any\npoint, not just before any data is written.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The types\n<i>size_t</i> and <i>ssize_t</i> are, respectively, unsigned\nand signed integer data types specified by POSIX.1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A successful\nreturn from <b>write</b>() does not make any guarantee that\ndata has been committed to disk. On some filesystems,\nincluding NFS, it does not even guarantee that space has\nsuccessfully been reserved for the data. In this case, some\nerrors might be delayed until a future <b>write</b>(),\n<a href=\"https://man.page/2/fsync\">fsync(2)</a>, or even <a href=\"https://man.page/2/close\">close(2)</a>. The only way to be\nsure is to call <a href=\"https://man.page/2/fsync\">fsync(2)</a> after you are done writing\nall your data.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a\n<b>write</b>() is interrupted by a signal handler before any\nbytes are written, then the call fails with the error\n<b>EINTR</b>; if it is interrupted after at least one byte\nhas been written, the call succeeds, and returns the number\nof bytes written.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux,\n<b>write</b>() (and similar system calls) will transfer at\nmost 0x7ffff000 (2,147,479,552) bytes, returning the number\nof bytes actually transferred. (This is true on both 32-bit\nand 64-bit systems.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An error return\nvalue while performing <b>write</b>() using direct I/O does\nnot mean the entire write has failed. Partial data may be\nwritten and the data at the file offset on which the\n<b>write</b>() was attempted should be considered\ninconsistent.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1-2008/SUSv4 Section XSI 2.9.7 (&quot;Thread\nInteractions with Regular File Operations&quot;):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">All of the\nfollowing functions shall be atomic with respect to each\nother in the effects specified in POSIX.1-2008 when they\noperate on regular files or symbolic links: ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Among the APIs\nsubsequently listed are <b>write</b>() and <a href=\"https://man.page/2/writev\">writev(2)</a>.\nAnd among the effects that should be atomic across threads\n(and processes) are updates of the file offset. However, on\nLinux before version 3.14, this was not the case: if two\nprocesses that share an open file description (see\n<a href=\"https://man.page/2/open\">open(2)</a>) perform a <b>write</b>() (or\n<a href=\"https://man.page/2/writev\">writev(2)</a>) at the same time, then the I/O operations\nwere not atomic with respect updating the file offset, with\nthe result that the blocks of data output by the two\nprocesses might (incorrectly) overlap. This problem was\nfixed in Linux 3.14.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/close\">close(2)</a>,\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, <a href=\"https://man.page/2/fsync\">fsync(2)</a>, <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>,\n<a href=\"https://man.page/2/lseek\">lseek(2)</a>, <a href=\"https://man.page/2/open\">open(2)</a>, <a href=\"https://man.page/2/pwrite\">pwrite(2)</a>,\n<a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/writev\">writev(2)</a>,\n<a href=\"https://man.page/3/fwrite\">fwrite(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}