{"name":"poll","description":"poll, ppoll - wait for some event on a file descriptor","body":"\n\n<h1 align=\"center\">POLL</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">poll, ppoll -\nwait for some event on a file descriptor</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;poll.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\npoll(struct pollfd *</b><i>fds</i><b>, nfds_t</b>\n<i>nfds</i><b>, int</b> <i>timeout</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;signal.h&gt; <br>\n#include &lt;poll.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nppoll(struct pollfd *</b><i>fds</i><b>, nfds_t</b>\n<i>nfds</i><b>, <br>\nconst struct timespec *</b><i>tmo_p</i><b>, const sigset_t\n*</b><i>sigmask</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>poll</b>()\nperforms a similar task to <a href=\"https://man.page/2/select\">select(2)</a>: it waits for\none of a set of file descriptors to become ready to perform\nI/O. The Linux-specific <a href=\"https://man.page/7/epoll\">epoll(7)</a> API performs a\nsimilar task, but offers features beyond those found in\n<b>poll</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The set of file\ndescriptors to be monitored is specified in the <i>fds</i>\nargument, which is an array of structures of the following\nform:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct pollfd {\n<br>\nint fd; /* file descriptor */ <br>\nshort events; /* requested events */ <br>\nshort revents; /* returned events */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The caller\nshould specify the number of items in the <i>fds</i> array\nin <i>nfds</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The field\n<i>fd</i> contains a file descriptor for an open file. If\nthis field is negative, then the corresponding <i>events</i>\nfield is ignored and the <i>revents</i> field returns zero.\n(This provides an easy way of ignoring a file descriptor for\na single <b>poll</b>() call: simply negate the <i>fd</i>\nfield. Note, however, that this technique can&rsquo;t be\nused to ignore file descriptor 0.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The field\n<i>events</i> is an input parameter, a bit mask specifying\nthe events the application is interested in for the file\ndescriptor <i>fd</i>. This field may be specified as zero,\nin which case the only events that can be returned in\n<i>revents</i> are <b>POLLHUP</b>, <b>POLLERR</b>, and\n<b>POLLNVAL</b> (see below).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The field\n<i>revents</i> is an output parameter, filled by the kernel\nwith the events that actually occurred. The bits returned in\n<i>revents</i> can include any of those specified in\n<i>events</i>, or one of the values <b>POLLERR</b>,\n<b>POLLHUP</b>, or <b>POLLNVAL</b>. (These three bits are\nmeaningless in the <i>events</i> field, and will be set in\nthe <i>revents</i> field whenever the corresponding\ncondition is true.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If none of the\nevents requested (and no error) has occurred for any of the\nfile descriptors, then <b>poll</b>() blocks until one of the\nevents occurs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>timeout</i> argument specifies the number of milliseconds\nthat <b>poll</b>() should block waiting for a file\ndescriptor to become ready. The call will block until\neither:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"72%\">\n\n\n<p>a file descriptor becomes ready;</p></td>\n<td width=\"14%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"72%\">\n\n\n<p>the call is interrupted by a signal handler; or</p></td>\n<td width=\"14%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"72%\">\n\n\n<p>the timeout expires.</p></td>\n<td width=\"14%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\n<i>timeout</i> interval will be rounded up to the system\nclock granularity, and kernel scheduling delays mean that\nthe blocking interval may overrun by a small amount.\nSpecifying a negative value in <i>timeout</i> means an\ninfinite timeout. Specifying a <i>timeout</i> of zero causes\n<b>poll</b>() to return immediately, even if no file\ndescriptors are ready.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The bits that\nmay be set/returned in <i>events</i> and <i>revents</i> are\ndefined in <i>&lt;poll.h&gt;</i>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>POLLIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"33%\">\n\n\n<p style=\"margin-top: 1em\">There is data to read.</p></td>\n<td width=\"45%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>POLLPRI</b></p>\n\n<p style=\"margin-left:22%;\">There is some exceptional\ncondition on the file descriptor. Possibilities include:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"75%\">\n\n\n<p>There is out-of-band data on a TCP socket (see\n<a href=\"https://man.page/7/tcp\">tcp(7)</a>).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"75%\">\n\n\n<p>A pseudoterminal master in packet mode has seen a state\nchange on the slave (see <a href=\"https://man.page/2/ioctl_tty\">ioctl_tty(2)</a>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"75%\">\n\n\n<p>A <i>cgroup.events</i> file has been modified (see\n<a href=\"https://man.page/7/cgroups\">cgroups(7)</a>).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>POLLOUT</b></p>\n\n<p style=\"margin-left:22%;\">Writing is now possible, though\na write larger than the available space in a socket or pipe\nwill still block (unless <b>O_NONBLOCK</b> is set).</p>\n\n<p style=\"margin-left:11%;\"><b>POLLRDHUP</b> (since Linux\n2.6.17)</p>\n\n<p style=\"margin-left:22%;\">Stream socket peer closed\nconnection, or shut down writing half of connection. The\n<b>_GNU_SOURCE</b> feature test macro must be defined\n(before including <i>any</i> header files) in order to\nobtain this definition.</p>\n\n<p style=\"margin-left:11%;\"><b>POLLERR</b></p>\n\n<p style=\"margin-left:22%;\">Error condition (only returned\nin <i>revents</i>; ignored in <i>events</i>). This bit is\nalso set for a file descriptor referring to the write end of\na pipe when the read end has been closed.</p>\n\n<p style=\"margin-left:11%;\"><b>POLLHUP</b></p>\n\n<p style=\"margin-left:22%;\">Hang up (only returned in\n<i>revents</i>; ignored in <i>events</i>). Note that when\nreading from a channel such as a pipe or a stream socket,\nthis event merely indicates that the peer closed its end of\nthe channel. Subsequent reads from the channel will return 0\n(end of file) only after all outstanding data in the channel\nhas been consumed.</p>\n\n<p style=\"margin-left:11%;\"><b>POLLNVAL</b></p>\n\n<p style=\"margin-left:22%;\">Invalid request: <i>fd</i> not\nopen (only returned in <i>revents</i>; ignored in\n<i>events</i>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When compiling\nwith <b>_XOPEN_SOURCE</b> defined, one also has the\nfollowing, which convey no further information beyond the\nbits listed above: <b><br>\nPOLLRDNORM</b></p>\n\n<p style=\"margin-left:22%;\">Equivalent to\n<b>POLLIN</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>POLLRDBAND</b></p>\n\n<p style=\"margin-left:22%;\">Priority band data can be read\n(generally unused on Linux).</p>\n\n<p style=\"margin-left:11%;\"><b>POLLWRNORM</b></p>\n\n<p style=\"margin-left:22%;\">Equivalent to\n<b>POLLOUT</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>POLLWRBAND</b></p>\n\n<p style=\"margin-left:22%;\">Priority data may be\nwritten.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux also\nknows about, but does not use <b>POLLMSG</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ppoll()</b>\n<br>\nThe relationship between <b>poll</b>() and <b>ppoll</b>() is\nanalogous to the relationship between <a href=\"https://man.page/2/select\">select(2)</a> and\n<a href=\"https://man.page/2/pselect\">pselect(2)</a>: like <a href=\"https://man.page/2/pselect\">pselect(2)</a>, <b>ppoll</b>()\nallows an application to safely wait until either a file\ndescriptor becomes ready or until a signal is caught.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other than the\ndifference in the precision of the <i>timeout</i> argument,\nthe following <b>ppoll</b>() call:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">ready =\nppoll(&amp;fds, nfds, tmo_p, &amp;sigmask);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is nearly\nequivalent to <i>atomically</i> executing the following\ncalls:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sigset_t\norigmask; <br>\nint timeout;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">timeout =\n(tmo_p == NULL) ? -1 : <br>\n(tmo_p-&gt;tv_sec * 1000 + tmo_p-&gt;tv_nsec / 1000000);\n<br>\npthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);\n<br>\nready = poll(&amp;fds, nfds, timeout); <br>\npthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The above code\nsegment is described as <i>nearly</i> equivalent because\nwhereas a negative <i>timeout</i> value for <b>poll</b>() is\ninterpreted as an infinite timeout, a negative value\nexpressed in <i>*tmo_p</i> results in an error from\n<b>ppoll</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\ndescription of <a href=\"https://man.page/2/pselect\">pselect(2)</a> for an explanation of why\n<b>ppoll</b>() is necessary.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<i>sigmask</i> argument is specified as NULL, then no signal\nmask manipulation is performed (and thus <b>ppoll</b>()\ndiffers from <b>poll</b>() only in the precision of the\n<i>timeout</i> argument).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>tmo_p</i> argument specifies an upper limit on the amount\nof time that <b>ppoll</b>() will block. This argument is a\npointer to a structure of the following form:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct timespec\n{ <br>\nlong tv_sec; /* seconds */ <br>\nlong tv_nsec; /* nanoseconds */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>tmo_p</i>\nis specified as NULL, then <b>ppoll</b>() can block\nindefinitely.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>poll</b>() returns a nonnegative value which is the\nnumber of elements in the <i>pollfds</i> whose\n<i>revents</i> fields have been set to a nonzero value\n(indicating an event or an error). A return value of zero\nindicates that the system call timed out before any file\ndescriptors became read.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set to indicate the cause of\nthe error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><i>fds</i> points outside the\nprocess&rsquo;s accessible address space. The array given as\nargument was not contained in the calling program&rsquo;s\naddress space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A signal occurred before any requested event; see\n<a href=\"https://man.page/7/signal\">signal(7)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>nfds</i> value exceeds the <b>RLIMIT_NOFILE</b>\nvalue.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>ppoll</b>()) The timeout value expressed in\n<i>*ip</i> is invalid (negative).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Unable to allocate memory for kernel data\nstructures.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>poll</b>() system call was introduced in Linux 2.1.23. On\nolder kernels that lack this system call, the glibc\n<b>poll</b>() wrapper function provides emulation using\n<a href=\"https://man.page/2/select\">select(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>ppoll</b>() system call was added to Linux in kernel\n2.6.16. The <b>ppoll</b>() library call was added in glibc\n2.4.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>poll</b>()\nconforms to POSIX.1-2001 and POSIX.1-2008. <b>ppoll</b>() is\nLinux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The operation\nof <b>poll</b>() and <b>ppoll</b>() is not affected by the\n<b>O_NONBLOCK</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On some other\nUNIX systems, <b>poll</b>() can fail with the error\n<b>EAGAIN</b> if the system fails to allocate\nkernel-internal resources, rather than <b>ENOMEM</b> as\nLinux does. POSIX permits this behavior. Portable programs\nmay wish to check for <b>EAGAIN</b> and loop, just as with\n<b>EINTR</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some\nimplementations define the nonstandard constant\n<b>INFTIM</b> with the value -1 for use as a <i>timeout</i>\nfor <b>poll</b>(). This constant is not provided in\nglibc.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a\ndiscussion of what may happen if a file descriptor being\nmonitored by <b>poll</b>() is closed in another thread, see\n<a href=\"https://man.page/2/select\">select(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nThe Linux <b>ppoll</b>() system call modifies its\n<i>tmo_p</i> argument. However, the glibc wrapper function\nhides this behavior by using a local variable for the\ntimeout argument that is passed to the system call. Thus,\nthe glibc <b>ppoll</b>() function does not modify its\n<i>tmo_p</i> argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The raw\n<b>ppoll</b>() system call has a fifth argument, <i>size_t\nsigsetsize</i>, which specifies the size in bytes of the\n<i>sigmask</i> argument. The glibc <b>ppoll</b>() wrapper\nfunction specifies this argument as a fixed value (equal to\n<i>sizeof(kernel_sigset_t)</i>). See <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>\nfor a discussion on the differences between the kernel and\nthe libc notion of the sigset.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\ndiscussion of spurious readiness notifications under the\nBUGS section of <a href=\"https://man.page/2/select\">select(2)</a>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow opens each of the files named in its command-line\narguments and monitors the resulting file descriptors for\nreadiness to read (<b>POLLIN</b>). The program loops,\nrepeatedly using <b>poll</b>() to monitor the file\ndescriptors, printing the number of ready file descriptors\non return. For each ready file descriptor, the program:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">displays the returned\n<i>revents</i> field in a human-readable form;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>if the file descriptor is readable, reads some data from\nit, and displays that data on standard output; and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>if the file descriptors was not readable, but some other\nevent occurred (presumably <b>POLLHUP</b>), closes the file\ndescriptor.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose we run\nthe program in one terminal, asking it to open a FIFO:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>mkfifo\nmyfifo</b> <br>\n$ <b>./poll_input myfifo</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a second\nterminal window, we then open the FIFO for writing, write\nsome data to it, and close the FIFO:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>echo\naaaaabbbbbccccc &gt; myfifo</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the terminal\nwhere we are running the program, we would then see:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Opened\n&quot;myfifo&quot; on fd 3 <br>\nAbout to poll() <br>\nReady: 1 <br>\nfd=3; events: POLLIN POLLHUP <br>\nread 10 bytes: aaaaabbbbb <br>\nAbout to poll() <br>\nReady: 1 <br>\nfd=3; events: POLLIN POLLHUP <br>\nread 6 bytes: ccccc</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">About to poll()\n<br>\nReady: 1 <br>\nfd=3; events: POLLHUP <br>\nclosing fd 3 <br>\nAll file descriptors closed; bye</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the above\noutput, we see that <b>poll</b>() returned three times:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">On the first return, the bits\nreturned in the <i>revents</i> field were <b>POLLIN</b>,\nindicating that the file descriptor is readable, and\n<b>POLLHUP</b>, indicating that the other end of the FIFO\nhas been closed. The program then consumed some of the\navailable input.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The second return from <b>poll</b>() also indicated\n<b>POLLIN</b> and <b>POLLHUP</b>; the program then consumed\nthe last of the available input.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>On the final return, <b>poll</b>() indicated only\n<b>POLLHUP</b> on the FIFO, at which point the file\ndescriptor was closed and the program terminated.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n/* poll_input.c</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nGNU General Public License v2 or later. <br>\n*/ <br>\n#include &lt;poll.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint nfds, num_open_fds; <br>\nstruct pollfd *pfds;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s file...\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">num_open_fds =\nnfds = argc - 1; <br>\npfds = calloc(nfds, sizeof(struct pollfd)); <br>\nif (pfds == NULL) <br>\nerrExit(&quot;malloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Open each\nfile on command line, and add it 'pfds' array */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; nfds; j++) { <br>\npfds[j].fd = open(argv[j + 1], O_RDONLY); <br>\nif (pfds[j].fd == -1) <br>\nerrExit(&quot;open&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Opened\n\\&quot;%s\\&quot; on fd %d\\n&quot;, argv[j + 1],\npfds[j].fd);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pfds[j].events\n= POLLIN; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Keep calling\npoll() as long as at least one file descriptor is <br>\nopen */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while\n(num_open_fds &gt; 0) { <br>\nint ready;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;About\nto poll()\\n&quot;); <br>\nready = poll(pfds, nfds, -1); <br>\nif (ready == -1) <br>\nerrExit(&quot;poll&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Ready:\n%d\\n&quot;, ready);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Deal with\narray returned by poll() */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; nfds; j++) { <br>\nchar buf[10];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(pfds[j].revents != 0) { <br>\nprintf(&quot; fd=%d; events: %s%s%s\\n&quot;, pfds[j].fd,\n<br>\n(pfds[j].revents &amp; POLLIN) ? &quot;POLLIN &quot; :\n&quot;&quot;, <br>\n(pfds[j].revents &amp; POLLHUP) ? &quot;POLLHUP &quot; :\n&quot;&quot;, <br>\n(pfds[j].revents &amp; POLLERR) ? &quot;POLLERR &quot; :\n&quot;&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(pfds[j].revents &amp; POLLIN) { <br>\nssize_t s = read(pfds[j].fd, buf, sizeof(buf)); <br>\nif (s == -1) <br>\nerrExit(&quot;read&quot;); <br>\nprintf(&quot; read %zd bytes: %.*s\\n&quot;, <br>\ns, (int) s, buf); <br>\n} else { /* POLLERR | POLLHUP */ <br>\nprintf(&quot; closing fd %d\\n&quot;, pfds[j].fd); <br>\nif (close(pfds[j].fd) == -1) <br>\nerrExit(&quot;close&quot;); <br>\nnum_open_fds--; <br>\n} <br>\n} <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;All\nfile descriptors closed; bye\\n&quot;); <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/restart_syscall\">restart_syscall(2)</a>,\n<a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/select_tut\">select_tut(2)</a>, <a href=\"https://man.page/7/epoll\">epoll(7)</a>,\n<a href=\"https://man.page/7/time\">time(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}