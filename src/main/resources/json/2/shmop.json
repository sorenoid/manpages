{"name":"shmop","description":"shmat, shmdt - System V shared memory operations","body":"\n\n<h1 align=\"center\">SHMOP</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">shmat, shmdt -\nSystem V shared memory operations</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/types.h&gt; <br>\n#include &lt;sys/shm.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*shmat(int</b> <i>shmid</i><b>, const void\n*</b><i>shmaddr</i><b>, int</b> <i>shmflg</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nshmdt(const void *</b><i>shmaddr</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>shmat() <br>\nshmat</b>() attaches the System&nbsp;V shared memory segment\nidentified by <i>shmid</i> to the address space of the\ncalling process. The attaching address is specified by\n<i>shmaddr</i> with one of the following criteria:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>If <i>shmaddr</i> is NULL, the system chooses a suitable\n(unused) page-aligned address to attach the segment.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>If <i>shmaddr</i> isn&rsquo;t NULL and <b>SHM_RND</b> is\nspecified in <i>shmflg</i>, the attach occurs at the address\nequal to <i>shmaddr</i> rounded down to the nearest multiple\nof <b>SHMLBA</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Otherwise, <i>shmaddr</i> must be a page-aligned address\nat which the attach occurs.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition to\n<b>SHM_RND</b>, the following flags may be specified in the\n<i>shmflg</i> bit-mask argument: <b><br>\nSHM_EXEC</b> (Linux-specific; since Linux 2.6.9)</p>\n\n<p style=\"margin-left:22%;\">Allow the contents of the\nsegment to be executed. The caller must have execute\npermission on the segment.</p>\n\n<p style=\"margin-left:11%;\"><b>SHM_RDONLY</b></p>\n\n<p style=\"margin-left:22%;\">Attach the segment for\nread-only access. The process must have read permission for\nthe segment. If this flag is not specified, the segment is\nattached for read and write access, and the process must\nhave read and write permission for the segment. There is no\nnotion of a write-only shared memory segment.</p>\n\n<p style=\"margin-left:11%;\"><b>SHM_REMAP</b>\n(Linux-specific)</p>\n\n<p style=\"margin-left:22%;\">This flag specifies that the\nmapping of the segment should replace any existing mapping\nin the range starting at <i>shmaddr</i> and continuing for\nthe size of the segment. (Normally, an <b>EINVAL</b> error\nwould result if a mapping already exists in this address\nrange.) In this case, <i>shmaddr</i> must not be NULL.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/brk\">brk(2)</a> value of the calling process is not altered by\nthe attach. The segment will automatically be detached at\nprocess exit. The same segment may be attached as a read and\nas a read-write one, and more than once, in the\nprocess&rsquo;s address space.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A successful\n<b>shmat</b>() call updates the members of the\n<i>shmid_ds</i> structure (see <a href=\"https://man.page/2/shmctl\">shmctl(2)</a>) associated\nwith the shared memory segment as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>shm_atime</i> is set to the current time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>shm_lpid</i> is set to the process-ID of the calling\nprocess.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>shm_nattch</i> is incremented by one.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>shmdt() <br>\nshmdt</b>() detaches the shared memory segment located at\nthe address specified by <i>shmaddr</i> from the address\nspace of the calling process. The to-be-detached segment\nmust be currently attached with <i>shmaddr</i> equal to the\nvalue returned by the attaching <b>shmat</b>() call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On a successful\n<b>shmdt</b>() call, the system updates the members of the\n<i>shmid_ds</i> structure associated with the shared memory\nsegment as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\"><i>shm_dtime</i> is set to the\ncurrent time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>shm_lpid</i> is set to the process-ID of the calling\nprocess.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>shm_nattch</i> is decremented by one. If it becomes 0\nand the segment is marked for deletion, the segment is\ndeleted.</p> </td></tr>\n</table>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>shmat</b>() returns the address of the attached shared\nmemory segment; on error, <i>(void&nbsp;*)&nbsp;-1</i> is\nreturned, and <i>errno</i> is set to indicate the cause of\nthe error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>shmdt</b>() returns 0; on error -1 is returned, and\n<i>errno</i> is set to indicate the cause of the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<b>shmat</b>() fails, <i>errno</i> is set to one of the\nfollowing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The calling process does not\nhave the required permissions for the requested attach type,\nand does not have the <b>CAP_IPC_OWNER</b> capability in the\nuser namespace that governs its IPC namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIDRM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>shmid</i> points to a removed identifier.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Invalid <i>shmid</i> value, unaligned (i.e., not\npage-aligned and <b>SHM_RND</b> was not specified) or\ninvalid <i>shmaddr</i> value, or can&rsquo;t attach segment\nat <i>shmaddr</i>, or <b>SHM_REMAP</b> was specified and\n<i>shmaddr</i> was NULL.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Could not allocate memory for the descriptor or for the\npage tables.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<b>shmdt</b>() fails, <i>errno</i> is set as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">There is no shared memory\nsegment attached at <i>shmaddr</i>; or, <i>shmaddr</i> is\nnot aligned on a page boundary.</p></td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008, SVr4.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In SVID 3 (or\nperhaps earlier), the type of the <i>shmaddr</i> argument\nwas changed from <i>char&nbsp;*</i> into <i>const\nvoid&nbsp;*</i>, and the returned type of <b>shmat</b>()\nfrom <i>char&nbsp;*</i> into <i>void&nbsp;*</i>.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">After a\n<a href=\"https://man.page/2/fork\">fork(2)</a>, the child inherits the attached shared\nmemory segments.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After an\n<a href=\"https://man.page/2/execve\">execve(2)</a>, all attached shared memory segments are\ndetached from the process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Upon\n<a href=\"https://man.page/2/_exit\">_exit(2)</a>, all attached shared memory segments are\ndetached from the process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using\n<b>shmat</b>() with <i>shmaddr</i> equal to NULL is the\npreferred, portable way of attaching a shared memory\nsegment. Be aware that the shared memory segment attached in\nthis way may be attached at different addresses in different\nprocesses. Therefore, any pointers maintained within the\nshared memory must be made relative (typically to the\nstarting address of the segment), rather than absolute.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux, it is\npossible to attach a shared memory segment even if it is\nalready marked to be deleted. However, POSIX.1 does not\nspecify this behavior and many other implementations do not\nsupport it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsystem parameter affects <b>shmat</b>():</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>SHMLBA</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Segment low boundary address\nmultiple. When explicitly specifying an attach address in a\ncall to <b>shmat</b>(), the caller should ensure that the\naddress is a multiple of this value. This is necessary on\nsome architectures, in order either to ensure good CPU cache\nperformance or to ensure that different attaches of the same\nsegment have consistent views within the CPU cache.\n<b>SHMLBA</b> is normally some multiple of the system page\nsize. (On many Linux architectures, <b>SHMLBA</b> is the\nsame as the system page size.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nimplementation places no intrinsic per-process limit on the\nnumber of shared memory segments (<b>SHMSEG</b>).</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The two\nprograms shown below exchange a string using a shared memory\nsegment. Further details about the programs are given below.\nFirst, we show a shell session demonstrating their use.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In one terminal\nwindow, we run the &quot;reader&quot; program, which creates\na System V shared memory segment and a System V semaphore\nset. The program prints out the IDs of the created objects,\nand then waits for the semaphore to change value.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./svshm_string_read</b> <br>\nshmid = 1114194; semid = 15</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In another\nterminal window, we run the &quot;writer&quot; program. The\n&quot;writer&quot; program takes three command-line\narguments: the IDs of the shared memory segment and\nsemaphore set created by the &quot;reader&quot;, and a\nstring. It attaches the existing shared memory segment,\ncopies the string to the shared memory, and modifies the\nsemaphore value.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./svshm_string_write 1114194 15 'Hello, world'</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returning to\nthe terminal where the &quot;reader&quot; is running, we see\nthat the program has ceased waiting on the semaphore and has\nprinted the string that was copied into the shared memory\nsegment by the writer:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Hello,\nworld</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: svshm_string.h</b> <br>\nThe following header file is included by the\n&quot;reader&quot; and &quot;writer&quot; programs.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#include\n&lt;sys/types.h&gt; <br>\n#include &lt;sys/ipc.h&gt; <br>\n#include &lt;sys/shm.h&gt; <br>\n#include &lt;sys/sem.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">union semun {\n/* Used in calls to semctl() */ <br>\nint val; <br>\nstruct semid_ds * buf; <br>\nunsigned short * array; <br>\n#if defined(__linux__) <br>\nstruct seminfo * __buf; <br>\n#endif <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define\nMEM_SIZE 4096</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: svshm_string_read.c</b> <br>\nThe &quot;reader&quot; program creates a shared memory\nsegment and a semaphore set containing one semaphore. It\nthen attaches the shared memory object into its address\nspace and initializes the semaphore value to 1. Finally, the\nprogram waits for the semaphore value to become 0, and\nafterwards prints the string that has been copied into the\nshared memory segment by the &quot;writer&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/*\nsvshm_string_read.c</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Licensed under\nGNU General Public License v2 or later. <br>\n*/ <br>\n#include &quot;svshm_string.h&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint semid, shmid; <br>\nunion semun arg, dummy; <br>\nstruct sembuf sop; <br>\nchar *addr;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Create\nshared memory and semaphore set containing one <br>\nsemaphore */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">shmid =\nshmget(IPC_PRIVATE, MEM_SIZE, IPC_CREAT | 0600); <br>\nif (shmid == -1) <br>\nerrExit(&quot;shmget&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">semid =\nsemget(IPC_PRIVATE, 1, IPC_CREAT | 0600); <br>\nif (shmid == -1) <br>\nerrExit(&quot;shmget&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Attach\nshared memory into our address space */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">addr =\nshmat(shmid, NULL, SHM_RDONLY); <br>\nif (addr == (void *) -1) <br>\nerrExit(&quot;shmat&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Initialize\nsemaphore 0 in set with value 1 */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">arg.val = 1;\n<br>\nif (semctl(semid, 0, SETVAL, arg) == -1) <br>\nerrExit(&quot;semctl&quot;);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">printf(&quot;shmid\n= %d; semid = %d\\n&quot;, shmid, semid);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Wait for\nsemaphore value to become 0 */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sop.sem_num =\n0; <br>\nsop.sem_op = 0; <br>\nsop.sem_flg = 0;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(semop(semid, &amp;sop, 1) == -1) <br>\nerrExit(&quot;semop&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Print the\nstring from shared memory */</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">printf(&quot;%s\\n&quot;,\naddr);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Remove\nshared memory and semaphore set */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(shmctl(shmid, IPC_RMID, NULL) == -1) <br>\nerrExit(&quot;shmctl&quot;); <br>\nif (semctl(semid, 0, IPC_RMID, dummy) == -1) <br>\nerrExit(&quot;semctl&quot;);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: svshm_string_write.c</b> <br>\nThe writer program takes three command-line arguments: the\nIDs of the shared memory segment and semaphore set that have\nalready been created by the &quot;reader&quot;, and a\nstring. It attaches the shared memory segment into its\naddress space, and then decrements the semaphore value to 0\nin order to inform the &quot;reader&quot; that it can now\nexamine the contents of the shared memory.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/*\nsvshm_string_write.c</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Licensed under\nGNU General Public License v2 or later. <br>\n*/ <br>\n#include &quot;svshm_string.h&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint semid, shmid; <br>\nstruct sembuf sop; <br>\nchar *addr; <br>\nsize_t len;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (argc != 4)\n{ <br>\nfprintf(stderr, &quot;Usage: %s shmid semid string\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">len =\nstrlen(argv[3]) + 1; /* +1 to include trailing '\\0' */ <br>\nif (len &gt; MEM_SIZE) { <br>\nfprintf(stderr, &quot;String is too big!\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Get object\nIDs from command-line */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">shmid =\natoi(argv[1]); <br>\nsemid = atoi(argv[2]);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Attach\nshared memory into our address space and copy string <br>\n(including trailing null byte) into memory. */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">addr =\nshmat(shmid, NULL, 0); <br>\nif (addr == (void *) -1) <br>\nerrExit(&quot;shmat&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">memcpy(addr,\nargv[3], len);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Decrement\nsemaphore to 0 */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sop.sem_num =\n0; <br>\nsop.sem_op = -1; <br>\nsop.sem_flg = 0;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(semop(semid, &amp;sop, 1) == -1) <br>\nerrExit(&quot;semop&quot;);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/brk\">brk(2)</a>,\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/shmctl\">shmctl(2)</a>, <a href=\"https://man.page/2/shmget\">shmget(2)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/shm_overview\">shm_overview(7)</a>,\n<a href=\"https://man.page/7/sysvipc\">sysvipc(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}