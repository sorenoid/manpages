{"name":"fcntl","body":"\n\n<h1 align=\"center\">FCNTL</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fcntl -\nmanipulate file descriptor</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;unistd.h&gt; <br>\n#include &lt;fcntl.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nfcntl(int</b> <i>fd</i><b>, int</b> <i>cmd</i><b>, ...\n/*</b> <i>arg</i> <b>*/ );</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>fcntl</b>()\nperforms one of the operations described below on the open\nfile descriptor <i>fd</i>. The operation is determined by\n<i>cmd</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>fcntl</b>()\ncan take an optional third argument. Whether or not this\nargument is required is determined by <i>cmd</i>. The\nrequired argument type is indicated in parentheses after\neach <i>cmd</i> name (in most cases, the required type is\n<i>int</i>, and we identify the argument using the name\n<i>arg</i>), or <i>void</i> is specified if the argument is\nnot required.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Certain of the\noperations below are supported only since a particular Linux\nkernel version. The preferred method of checking whether the\nhost kernel supports a particular operation is to invoke\n<b>fcntl</b>() with the desired <i>cmd</i> value and then\ntest whether the call failed with <b>EINVAL</b>, indicating\nthat the kernel does not recognize this value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Duplicating\na file descriptor <br>\nF_DUPFD</b> (<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Duplicate the file descriptor\n<i>fd</i> using the lowest-numbered available file\ndescriptor greater than or equal to <i>arg</i>. This is\ndifferent from <a href=\"https://man.page/2/dup2\">dup2(2)</a>, which uses exactly the file\ndescriptor specified.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">On success, the\nnew file descriptor is returned.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">See\n<a href=\"https://man.page/2/dup\">dup(2)</a> for further details.</p>\n\n<p style=\"margin-left:11%;\"><b>F_DUPFD_CLOEXEC</b>\n(<i>int</i>; since Linux 2.6.24)</p>\n\n<p style=\"margin-left:22%;\">As for <b>F_DUPFD</b>, but\nadditionally set the close-on-exec flag for the duplicate\nfile descriptor. Specifying this flag permits a program to\navoid an additional <b>fcntl</b>() <b>F_SETFD</b> operation\nto set the <b>FD_CLOEXEC</b> flag. For an explanation of why\nthis flag is useful, see the description of <b>O_CLOEXEC</b>\nin <a href=\"https://man.page/2/open\">open(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File\ndescriptor flags</b> <br>\nThe following commands manipulate the flags associated with\na file descriptor. Currently, only one such flag is defined:\n<b>FD_CLOEXEC</b>, the close-on-exec flag. If the\n<b>FD_CLOEXEC</b> bit is set, the file descriptor will\nautomatically be closed during a successful\n<a href=\"https://man.page/2/execve\">execve(2)</a>. (If the <a href=\"https://man.page/2/execve\">execve(2)</a> fails, the file\ndescriptor is left open.) If the <b>FD_CLOEXEC</b> bit is\nnot set, the file descriptor will remain open across an\n<a href=\"https://man.page/2/execve\">execve(2)</a>. <b><br>\nF_GETFD</b> (<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Return (as the function result)\nthe file descriptor flags; <i>arg</i> is ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SETFD</b> (<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the file descriptor flags\nto the value specified by <i>arg</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In\nmultithreaded programs, using <b>fcntl</b>() <b>F_SETFD</b>\nto set the close-on-exec flag at the same time as another\nthread performs a <a href=\"https://man.page/2/fork\">fork(2)</a> plus <a href=\"https://man.page/2/execve\">execve(2)</a> is\nvulnerable to a race condition that may unintentionally leak\nthe file descriptor to the program executed in the child\nprocess. See the discussion of the <b>O_CLOEXEC</b> flag in\n<a href=\"https://man.page/2/open\">open(2)</a> for details and a remedy to the problem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File status\nflags</b> <br>\nEach open file description has certain associated status\nflags, initialized by <a href=\"https://man.page/2/open\">open(2)</a> and possibly modified\nby <b>fcntl</b>(). Duplicated file descriptors (made with\n<a href=\"https://man.page/2/dup\">dup(2)</a>, <b>fcntl</b>(F_DUPFD), <a href=\"https://man.page/2/fork\">fork(2)</a>, etc.)\nrefer to the same open file description, and thus share the\nsame file status flags.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The file status\nflags and their semantics are described in <a href=\"https://man.page/2/open\">open(2)</a>.\n<b><br>\nF_GETFL</b> (<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Return (as the function result)\nthe file access mode and the file status flags; <i>arg</i>\nis ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SETFL</b> (<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the file status flags to\nthe value specified by <i>arg</i>. File access mode\n(<b>O_RDONLY</b>, <b>O_WRONLY</b>, <b>O_RDWR</b>) and file\ncreation flags (i.e., <b>O_CREAT</b>, <b>O_EXCL</b>,\n<b>O_NOCTTY</b>, <b>O_TRUNC</b>) in <i>arg</i> are ignored.\nOn Linux, this command can change only the <b>O_APPEND</b>,\n<b>O_ASYNC</b>, <b>O_DIRECT</b>, <b>O_NOATIME</b>, and\n<b>O_NONBLOCK</b> flags. It is not possible to change the\n<b>O_DSYNC</b> and <b>O_SYNC</b> flags; see BUGS, below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Advisory\nrecord locking</b> <br>\nLinux implements traditional\n(&quot;process-associated&quot;) UNIX record locks, as\nstandardized by POSIX. For a Linux-specific alternative with\nbetter semantics, see the discussion of open file\ndescription locks below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_SETLK</b>,\n<b>F_SETLKW</b>, and <b>F_GETLK</b> are used to acquire,\nrelease, and test for the existence of record locks (also\nknown as byte-range, file-segment, or file-region locks).\nThe third argument, <i>lock</i>, is a pointer to a structure\nthat has at least the following fields (in unspecified\norder).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct flock {\n<br>\n... <br>\nshort l_type; /* Type of lock: F_RDLCK, <br>\nF_WRLCK, F_UNLCK */ <br>\nshort l_whence; /* How to interpret l_start: <br>\nSEEK_SET, SEEK_CUR, SEEK_END */ <br>\noff_t l_start; /* Starting offset for lock */ <br>\noff_t l_len; /* Number of bytes to lock */ <br>\npid_t l_pid; /* PID of process blocking our lock <br>\n(set by F_GETLK and F_OFD_GETLK) */ <br>\n... <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of\nthis structure specify the range of bytes we wish to lock.\nBytes past the end of the file may be locked, but not bytes\nbefore the start of the file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>l_start</i>\nis the starting offset for the lock, and is interpreted\nrelative to either: the start of the file (if\n<i>l_whence</i> is <b>SEEK_SET</b>); the current file offset\n(if <i>l_whence</i> is <b>SEEK_CUR</b>); or the end of the\nfile (if <i>l_whence</i> is <b>SEEK_END</b>). In the final\ntwo cases, <i>l_start</i> can be a negative number provided\nthe offset does not lie before the start of the file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>l_len</i>\nspecifies the number of bytes to be locked. If <i>l_len</i>\nis positive, then the range to be locked covers bytes\n<i>l_start</i> up to and including\n<i>l_start</i>+<i>l_len</i>-1. Specifying 0 for <i>l_len</i>\nhas the special meaning: lock all bytes starting at the\nlocation specified by <i>l_whence</i> and <i>l_start</i>\nthrough to the end of file, no matter how large the file\ngrows.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001\nallows (but does not require) an implementation to support a\nnegative <i>l_len</i> value; if <i>l_len</i> is negative,\nthe interval described by <i>lock</i> covers bytes\n<i>l_start</i>+<i>l_len</i> up to and including\n<i>l_start</i>-1. This is supported by Linux since kernel\nversions 2.4.21 and 2.5.49.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>l_type</i> field can be used to place a read\n(<b>F_RDLCK</b>) or a write (<b>F_WRLCK</b>) lock on a file.\nAny number of processes may hold a read lock (shared lock)\non a file region, but only one process may hold a write lock\n(exclusive lock). An exclusive lock excludes all other\nlocks, both shared and exclusive. A single process can hold\nonly one type of lock on a file region; if a new lock is\napplied to an already-locked region, then the existing lock\nis converted to the new lock type. (Such conversions may\ninvolve splitting, shrinking, or coalescing with an existing\nlock if the byte range specified by the new lock does not\nprecisely coincide with the range of the existing lock.)\n<b><br>\nF_SETLK</b> (<i>struct flock *</i>)</p>\n\n<p style=\"margin-left:22%;\">Acquire a lock (when\n<i>l_type</i> is <b>F_RDLCK</b> or <b>F_WRLCK</b>) or\nrelease a lock (when <i>l_type</i> is <b>F_UNLCK</b>) on the\nbytes specified by the <i>l_whence</i>, <i>l_start</i>, and\n<i>l_len</i> fields of <i>lock</i>. If a conflicting lock is\nheld by another process, this call returns -1 and sets\n<i>errno</i> to <b>EACCES</b> or <b>EAGAIN</b>. (The error\nreturned in this case differs across implementations, so\nPOSIX requires a portable application to check for both\nerrors.)</p>\n\n<p style=\"margin-left:11%;\"><b>F_SETLKW</b> (<i>struct\nflock *</i>)</p>\n\n<p style=\"margin-left:22%;\">As for <b>F_SETLK</b>, but if a\nconflicting lock is held on the file, then wait for that\nlock to be released. If a signal is caught while waiting,\nthen the call is interrupted and (after the signal handler\nhas returned) returns immediately (with return value -1 and\n<i>errno</i> set to <b>EINTR</b>; see <a href=\"https://man.page/7/signal\">signal(7)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETLK</b> (<i>struct flock\n*</i>)</p>\n\n<p style=\"margin-left:22%;\">On input to this call,\n<i>lock</i> describes a lock we would like to place on the\nfile. If the lock could be placed, <b>fcntl</b>() does not\nactually place it, but returns <b>F_UNLCK</b> in the\n<i>l_type</i> field of <i>lock</i> and leaves the other\nfields of the structure unchanged.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If one or more\nincompatible locks would prevent this lock being placed,\nthen <b>fcntl</b>() returns details about one of those locks\nin the <i>l_type</i>, <i>l_whence</i>, <i>l_start</i>, and\n<i>l_len</i> fields of <i>lock</i>. If the conflicting lock\nis a traditional (process-associated) record lock, then the\n<i>l_pid</i> field is set to the PID of the process holding\nthat lock. If the conflicting lock is an open file\ndescription lock, then <i>l_pid</i> is set to -1. Note that\nthe returned information may already be out of date by the\ntime the caller inspects it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to\nplace a read lock, <i>fd</i> must be open for reading. In\norder to place a write lock, <i>fd</i> must be open for\nwriting. To place both types of lock, open a file\nread-write.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When placing\nlocks with <b>F_SETLKW</b>, the kernel detects\n<i>deadlocks</i>, whereby two or more processes have their\nlock requests mutually blocked by locks held by the other\nprocesses. For example, suppose process A holds a write lock\non byte 100 of a file, and process B holds a write lock on\nbyte 200. If each process then attempts to lock the byte\nalready locked by the other process using <b>F_SETLKW</b>,\nthen, without deadlock detection, both processes would\nremain blocked indefinitely. When the kernel detects such\ndeadlocks, it causes one of the blocking lock requests to\nimmediately fail with the error <b>EDEADLK</b>; an\napplication that encounters such an error should release\nsome of its locks to allow other applications to proceed\nbefore attempting regain the locks that it requires.\nCircular deadlocks involving more than two processes are\nalso detected. Note, however, that there are limitations to\nthe kernel&rsquo;s deadlock-detection algorithm; see\nBUGS.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As well as\nbeing removed by an explicit <b>F_UNLCK</b>, record locks\nare automatically released when the process terminates.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Record locks\nare not inherited by a child created via <a href=\"https://man.page/2/fork\">fork(2)</a>, but\nare preserved across an <a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because of the\nbuffering performed by the <a href=\"https://man.page/3/stdio\">stdio(3)</a> library, the use\nof record locking with routines in that package should be\navoided; use <a href=\"https://man.page/2/read\">read(2)</a> and <a href=\"https://man.page/2/write\">write(2)</a> instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The record\nlocks described above are associated with the process\n(unlike the open file description locks described below).\nThis has some unfortunate consequences:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If a process closes <i>any</i> file descriptor referring\nto a file, then all of the process&rsquo;s locks on that\nfile are released, regardless of the file descriptor(s) on\nwhich the locks were obtained. This is bad: it means that a\nprocess can lose its locks on a file such as\n<i>/etc/passwd</i> or <i>/etc/mtab</i> when for some reason\na library function decides to open, read, and close the same\nfile.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The threads in a process share locks. In other words, a\nmultithreaded program can&rsquo;t use record locking to\nensure that threads don&rsquo;t simultaneously access the\nsame region of a file.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Open file\ndescription locks solve both of these problems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Open file\ndescription locks (non-POSIX)</b> <br>\nOpen file description locks are advisory byte-range locks\nwhose operation is in most respects identical to the\ntraditional record locks described above. This lock type is\nLinux-specific, and available since Linux 3.15. (There is a\nproposal with the Austin Group to include this lock type in\nthe next revision of POSIX.1.) For an explanation of open\nfile descriptions, see <a href=\"https://man.page/2/open\">open(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The principal\ndifference between the two lock types is that whereas\ntraditional record locks are associated with a process, open\nfile description locks are associated with the open file\ndescription on which they are acquired, much like locks\nacquired with <a href=\"https://man.page/2/flock\">flock(2)</a>. Consequently (and unlike\ntraditional advisory record locks), open file description\nlocks are inherited across <a href=\"https://man.page/2/fork\">fork(2)</a> (and\n<a href=\"https://man.page/2/clone\">clone(2)</a> with <b>CLONE_FILES</b>), and are only\nautomatically released on the last close of the open file\ndescription, instead of being released on any close of the\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Conflicting\nlock combinations (i.e., a read lock and a write lock or two\nwrite locks) where one lock is an open file description lock\nand the other is a traditional record lock conflict even\nwhen they are acquired by the same process on the same file\ndescriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Open file\ndescription locks placed via the same open file description\n(i.e., via the same file descriptor, or via a duplicate of\nthe file descriptor created by <a href=\"https://man.page/2/fork\">fork(2)</a>,\n<a href=\"https://man.page/2/dup\">dup(2)</a>, <b>fcntl</b>() <b>F_DUPFD</b>, and so on) are\nalways compatible: if a new lock is placed on an already\nlocked region, then the existing lock is converted to the\nnew lock type. (Such conversions may result in splitting,\nshrinking, or coalescing with an existing lock as discussed\nabove.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On the other\nhand, open file description locks may conflict with each\nother when they are acquired via different open file\ndescriptions. Thus, the threads in a multithreaded program\ncan use open file description locks to synchronize access to\na file region by having each thread perform its own\n<a href=\"https://man.page/2/open\">open(2)</a> on the file and applying locks via the\nresulting file descriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As with\ntraditional advisory locks, the third argument to\n<b>fcntl</b>(), <i>lock</i>, is a pointer to an <i>flock</i>\nstructure. By contrast with traditional record locks, the\n<i>l_pid</i> field of that structure must be set to zero\nwhen using the commands described below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The commands\nfor working with open file description locks are analogous\nto those used with traditional locks: <b><br>\nF_OFD_SETLK</b> (<i>struct flock *</i>)</p>\n\n<p style=\"margin-left:22%;\">Acquire an open file\ndescription lock (when <i>l_type</i> is <b>F_RDLCK</b> or\n<b>F_WRLCK</b>) or release an open file description lock\n(when <i>l_type</i> is <b>F_UNLCK</b>) on the bytes\nspecified by the <i>l_whence</i>, <i>l_start</i>, and\n<i>l_len</i> fields of <i>lock</i>. If a conflicting lock is\nheld by another process, this call returns -1 and sets\n<i>errno</i> to <b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>F_OFD_SETLKW</b> (<i>struct\nflock *</i>)</p>\n\n<p style=\"margin-left:22%;\">As for <b>F_OFD_SETLK</b>, but\nif a conflicting lock is held on the file, then wait for\nthat lock to be released. If a signal is caught while\nwaiting, then the call is interrupted and (after the signal\nhandler has returned) returns immediately (with return value\n-1 and <i>errno</i> set to <b>EINTR</b>; see\n<a href=\"https://man.page/7/signal\">signal(7)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>F_OFD_GETLK</b> (<i>struct\nflock *</i>)</p>\n\n<p style=\"margin-left:22%;\">On input to this call,\n<i>lock</i> describes an open file description lock we would\nlike to place on the file. If the lock could be placed,\n<b>fcntl</b>() does not actually place it, but returns\n<b>F_UNLCK</b> in the <i>l_type</i> field of <i>lock</i> and\nleaves the other fields of the structure unchanged. If one\nor more incompatible locks would prevent this lock being\nplaced, then details about one of these locks are returned\nvia <i>lock</i>, as described above for <b>F_GETLK</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the current\nimplementation, no deadlock detection is performed for open\nfile description locks. (This contrasts with\nprocess-associated record locks, for which the kernel does\nperform deadlock detection.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Mandatory\nlocking</b> <i><br>\nWarning</i>: the Linux implementation of mandatory locking\nis unreliable. See BUGS below. Because of these bugs, and\nthe fact that the feature is believed to be little used,\nsince Linux 4.5, mandatory locking has been made an optional\nfeature, governed by a configuration option\n(<b>CONFIG_MANDATORY_FILE_LOCKING</b>). This is an initial\nstep toward removing this feature completely.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nboth traditional (process-associated) and open file\ndescription record locks are advisory. Advisory locks are\nnot enforced and are useful only between cooperating\nprocesses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both lock types\ncan also be mandatory. Mandatory locks are enforced for all\nprocesses. If a process tries to perform an incompatible\naccess (e.g., <a href=\"https://man.page/2/read\">read(2)</a> or <a href=\"https://man.page/2/write\">write(2)</a>) on a file\nregion that has an incompatible mandatory lock, then the\nresult depends upon whether the <b>O_NONBLOCK</b> flag is\nenabled for its open file description. If the\n<b>O_NONBLOCK</b> flag is not enabled, then the system call\nis blocked until the lock is removed or converted to a mode\nthat is compatible with the access. If the <b>O_NONBLOCK</b>\nflag is enabled, then the system call fails with the error\n<b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To make use of\nmandatory locks, mandatory locking must be enabled both on\nthe filesystem that contains the file to be locked, and on\nthe file itself. Mandatory locking is enabled on a\nfilesystem using the &quot;-o mand&quot; option to\n<b>mount</b>(8), or the <b>MS_MANDLOCK</b> flag for\n<a href=\"https://man.page/2/mount\">mount(2)</a>. Mandatory locking is enabled on a file by\ndisabling group execute permission on the file and enabling\nthe set-group-ID permission bit (see <a href=\"https://man.page/1/chmod\">chmod(1)</a> and\n<a href=\"https://man.page/2/chmod\">chmod(2)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Mandatory\nlocking is not specified by POSIX. Some other systems also\nsupport mandatory locking, although the details of how to\nenable it vary across systems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Lost\nlocks</b> <br>\nWhen an advisory lock is obtained on a networked filesystem\nsuch as NFS it is possible that the lock might get lost.\nThis may happen due to administrative action on the server,\nor due to a network partition (i.e., loss of network\nconnectivity with the server) which lasts long enough for\nthe server to assume that the client is no longer\nfunctioning.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\nfilesystem determines that a lock has been lost, future\n<a href=\"https://man.page/2/read\">read(2)</a> or <a href=\"https://man.page/2/write\">write(2)</a> requests may fail with the\nerror <b>EIO</b>. This error will persist until the lock is\nremoved or the file descriptor is closed. Since Linux 3.12,\nthis happens at least for NFSv4 (including all minor\nversions).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some versions\nof UNIX send a signal (<b>SIGLOST</b>) in this circumstance.\nLinux does not define this signal, and does not provide any\nasynchronous notification of lost locks.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Managing\nsignals <br>\nF_GETOWN</b>, <b>F_SETOWN</b>, <b>F_GETOWN_EX</b>,\n<b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and <b>F_SETSIG</b> are\nused to manage I/O availability signals: <b><br>\nF_GETOWN</b> (<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Return (as the function result)\nthe process ID or process group ID currently receiving\n<b>SIGIO</b> and <b>SIGURG</b> signals for events on file\ndescriptor <i>fd</i>. Process IDs are returned as positive\nvalues; process group IDs are returned as negative values\n(but see BUGS below). <i>arg</i> is ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SETOWN</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the process ID or process\ngroup ID that will receive <b>SIGIO</b> and <b>SIGURG</b>\nsignals for events on the file descriptor <i>fd</i>. The\ntarget process or process group ID is specified in\n<i>arg</i>. A process ID is specified as a positive value; a\nprocess group ID is specified as a negative value. Most\ncommonly, the calling process specifies itself as the owner\n(that is, <i>arg</i> is specified as <a href=\"https://man.page/2/getpid\">getpid(2)</a>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">As well as\nsetting the file descriptor owner, one must also enable\ngeneration of signals on the file descriptor. This is done\nby using the <b>fcntl</b>() <b>F_SETFL</b> command to set\nthe <b>O_ASYNC</b> file status flag on the file descriptor.\nSubsequently, a <b>SIGIO</b> signal is sent whenever input\nor output becomes possible on the file descriptor. The\n<b>fcntl</b>() <b>F_SETSIG</b> command can be used to obtain\ndelivery of a signal other than <b>SIGIO</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Sending a\nsignal to the owner process (group) specified by\n<b>F_SETOWN</b> is subject to the same permissions checks as\nare described for <a href=\"https://man.page/2/kill\">kill(2)</a>, where the sending process\nis the one that employs <b>F_SETOWN</b> (but see BUGS\nbelow). If this permission check fails, then the signal is\nsilently discarded. <i>Note</i>: The <b>F_SETOWN</b>\noperation records the caller&rsquo;s credentials at the time\nof the <b>fcntl</b>() call, and it is these saved\ncredentials that are used for the permission checks.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the file\ndescriptor <i>fd</i> refers to a socket, <b>F_SETOWN</b>\nalso selects the recipient of <b>SIGURG</b> signals that are\ndelivered when out-of-band data arrives on that socket.\n(<b>SIGURG</b> is sent in any situation where\n<a href=\"https://man.page/2/select\">select(2)</a> would report the socket as having an\n&quot;exceptional condition&quot;.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The following\nwas true in 2.6.x kernels up to and including kernel\n2.6.11:</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If a nonzero\nvalue is given to <b>F_SETSIG</b> in a multithreaded process\nrunning with a threading library that supports thread groups\n(e.g., NPTL), then a positive value given to <b>F_SETOWN</b>\nhas a different meaning: instead of being a process ID\nidentifying a whole process, it is a thread ID identifying a\nspecific thread within a process. Consequently, it may be\nnecessary to pass <b>F_SETOWN</b> the result of\n<a href=\"https://man.page/2/gettid\">gettid(2)</a> instead of <a href=\"https://man.page/2/getpid\">getpid(2)</a> to get sensible\nresults when <b>F_SETSIG</b> is used. (In current Linux\nthreading implementations, a main thread&rsquo;s thread ID\nis the same as its process ID. This means that a\nsingle-threaded program can equally use <a href=\"https://man.page/2/gettid\">gettid(2)</a> or\n<a href=\"https://man.page/2/getpid\">getpid(2)</a> in this scenario.) Note, however, that the\nstatements in this paragraph do not apply to the\n<b>SIGURG</b> signal generated for out-of-band data on a\nsocket: this signal is always sent to either a process or a\nprocess group, depending on the value given to\n<b>F_SETOWN</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The above\nbehavior was accidentally dropped in Linux 2.6.12, and\nwon&rsquo;t be restored. From Linux 2.6.32 onward, use\n<b>F_SETOWN_EX</b> to target <b>SIGIO</b> and <b>SIGURG</b>\nsignals at a particular thread.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETOWN_EX</b> (<i>struct\nf_owner_ex *</i>) (since Linux 2.6.32)</p>\n\n<p style=\"margin-left:22%;\">Return the current file\ndescriptor owner settings as defined by a previous\n<b>F_SETOWN_EX</b> operation. The information is returned in\nthe structure pointed to by <i>arg</i>, which has the\nfollowing form:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nf_owner_ex { <br>\nint type; <br>\npid_t pid; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>type</i>\nfield will have one of the values <b>F_OWNER_TID</b>,\n<b>F_OWNER_PID</b>, or <b>F_OWNER_PGRP</b>. The <i>pid</i>\nfield is a positive integer representing a thread ID,\nprocess ID, or process group ID. See <b>F_SETOWN_EX</b> for\nmore details.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SETOWN_EX</b> (<i>struct\nf_owner_ex *</i>) (since Linux 2.6.32)</p>\n\n<p style=\"margin-left:22%;\">This operation performs a\nsimilar task to <b>F_SETOWN</b>. It allows the caller to\ndirect I/O availability signals to a specific thread,\nprocess, or process group. The caller specifies the target\nof signals via <i>arg</i>, which is a pointer to a\n<i>f_owner_ex</i> structure. The <i>type</i> field has one\nof the following values, which define how <i>pid</i> is\ninterpreted: <b><br>\nF_OWNER_TID</b></p>\n\n<p style=\"margin-left:32%;\">Send the signal to the thread\nwhose thread ID (the value returned by a call to\n<a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/gettid\">gettid(2)</a>) is specified in\n<i>pid</i>.</p>\n\n<p style=\"margin-left:22%;\"><b>F_OWNER_PID</b></p>\n\n<p style=\"margin-left:32%;\">Send the signal to the process\nwhose ID is specified in <i>pid</i>.</p>\n\n<p style=\"margin-left:22%;\"><b>F_OWNER_PGRP</b></p>\n\n<p style=\"margin-left:32%;\">Send the signal to the process\ngroup whose ID is specified in <i>pid</i>. (Note that,\nunlike with <b>F_SETOWN</b>, a process group ID is specified\nas a positive value here.)</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETSIG</b>\n(<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Return (as the function result)\nthe signal sent when input or output becomes possible. A\nvalue of zero means <b>SIGIO</b> is sent. Any other value\n(including <b>SIGIO</b>) is the signal sent instead, and in\nthis case additional info is available to the signal handler\nif installed with <b>SA_SIGINFO</b>. <i>arg</i> is\nignored.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SETSIG</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the signal sent when input\nor output becomes possible to the value given in <i>arg</i>.\nA value of zero means to send the default <b>SIGIO</b>\nsignal. Any other value (including <b>SIGIO</b>) is the\nsignal to send instead, and in this case additional info is\navailable to the signal handler if installed with\n<b>SA_SIGINFO</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">By using\n<b>F_SETSIG</b> with a nonzero value, and setting\n<b>SA_SIGINFO</b> for the signal handler (see\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>), extra information about I/O events is\npassed to the handler in a <i>siginfo_t</i> structure. If\nthe <i>si_code</i> field indicates the source is\n<b>SI_SIGIO</b>, the <i>si_fd</i> field gives the file\ndescriptor associated with the event. Otherwise, there is no\nindication which file descriptors are pending, and you\nshould use the usual mechanisms (<a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a> with <b>O_NONBLOCK</b> set\netc.) to determine which file descriptors are available for\nI/O.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note that the\nfile descriptor provided in <i>si_fd</i> is the one that was\nspecified during the <b>F_SETSIG</b> operation. This can\nlead to an unusual corner case. If the file descriptor is\nduplicated (<a href=\"https://man.page/2/dup\">dup(2)</a> or similar), and the original file\ndescriptor is closed, then I/O events will continue to be\ngenerated, but the <i>si_fd</i> field will contain the\nnumber of the now closed file descriptor.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">By selecting a\nreal time signal (value &gt;= <b>SIGRTMIN</b>), multiple I/O\nevents may be queued using the same signal numbers. (Queuing\nis dependent on available memory.) Extra information is\navailable if <b>SA_SIGINFO</b> is set for the signal\nhandler, as above.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note that Linux\nimposes a limit on the number of real-time signals that may\nbe queued to a process (see <a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a> and\n<a href=\"https://man.page/7/signal\">signal(7)</a>) and if this limit is reached, then the\nkernel reverts to delivering <b>SIGIO</b>, and this signal\nis delivered to the entire process rather than to a specific\nthread.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using these\nmechanisms, a program can implement fully asynchronous I/O\nwithout using <a href=\"https://man.page/2/select\">select(2)</a> or <a href=\"https://man.page/2/poll\">poll(2)</a> most of the\ntime.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The use of\n<b>O_ASYNC</b> is specific to BSD and Linux. The only use of\n<b>F_GETOWN</b> and <b>F_SETOWN</b> specified in POSIX.1 is\nin conjunction with the use of the <b>SIGURG</b> signal on\nsockets. (POSIX does not specify the <b>SIGIO</b> signal.)\n<b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and\n<b>F_SETSIG</b> are Linux-specific. POSIX has asynchronous\nI/O and the <i>aio_sigevent</i> structure to achieve similar\nthings; these are also available in Linux as part of the GNU\nC Library (Glibc).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Leases <br>\nF_SETLEASE</b> and <b>F_GETLEASE</b> (Linux 2.4 onward) are\nused to establish a new lease, and retrieve the current\nlease, on the open file description referred to by the file\ndescriptor <i>fd</i>. A file lease provides a mechanism\nwhereby the process holding the lease (the &quot;lease\nholder&quot;) is notified (via delivery of a signal) when a\nprocess (the &quot;lease breaker&quot;) tries to\n<a href=\"https://man.page/2/open\">open(2)</a> or <a href=\"https://man.page/2/truncate\">truncate(2)</a> the file referred to by\nthat file descriptor. <b><br>\nF_SETLEASE</b> (<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set or remove a file lease\naccording to which of the following values is specified in\nthe integer <i>arg</i>: <b><br>\nF_RDLCK</b></p>\n\n<p style=\"margin-left:32%;\">Take out a read lease. This\nwill cause the calling process to be notified when the file\nis opened for writing or is truncated. A read lease can be\nplaced only on a file descriptor that is opened\nread-only.</p>\n\n<p style=\"margin-left:22%;\"><b>F_WRLCK</b></p>\n\n<p style=\"margin-left:32%;\">Take out a write lease. This\nwill cause the caller to be notified when the file is opened\nfor reading or writing or is truncated. A write lease may be\nplaced on a file only if there are no other open file\ndescriptors for the file.</p>\n\n<p style=\"margin-left:22%;\"><b>F_UNLCK</b></p>\n\n<p style=\"margin-left:32%;\">Remove our lease from the\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Leases are\nassociated with an open file description (see\n<a href=\"https://man.page/2/open\">open(2)</a>). This means that duplicate file descriptors\n(created by, for example, <a href=\"https://man.page/2/fork\">fork(2)</a> or <a href=\"https://man.page/2/dup\">dup(2)</a>)\nrefer to the same lease, and this lease may be modified or\nreleased using any of these descriptors. Furthermore, the\nlease is released by either an explicit <b>F_UNLCK</b>\noperation on any of these duplicate file descriptors, or\nwhen all such file descriptors have been closed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Leases may be\ntaken out only on regular files. An unprivileged process may\ntake out a lease only on a file whose UID (owner) matches\nthe filesystem UID of the process. A process with the\n<b>CAP_LEASE</b> capability may take out leases on arbitrary\nfiles. <b><br>\nF_GETLEASE</b> (<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Indicates what type of lease is\nassociated with the file descriptor <i>fd</i> by returning\neither <b>F_RDLCK</b>, <b>F_WRLCK</b>, or <b>F_UNLCK</b>,\nindicating, respectively, a read lease , a write lease, or\nno lease. <i>arg</i> is ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a process\n(the &quot;lease breaker&quot;) performs an <a href=\"https://man.page/2/open\">open(2)</a>\nor <a href=\"https://man.page/2/truncate\">truncate(2)</a> that conflicts with a lease\nestablished via <b>F_SETLEASE</b>, the system call is\nblocked by the kernel and the kernel notifies the lease\nholder by sending it a signal (<b>SIGIO</b> by default). The\nlease holder should respond to receipt of this signal by\ndoing whatever cleanup is required in preparation for the\nfile to be accessed by another process (e.g., flushing\ncached buffers) and then either remove or downgrade its\nlease. A lease is removed by performing an <b>F_SETLEASE</b>\ncommand specifying <i>arg</i> as <b>F_UNLCK</b>. If the\nlease holder currently holds a write lease on the file, and\nthe lease breaker is opening the file for reading, then it\nis sufficient for the lease holder to downgrade the lease to\na read lease. This is done by performing an\n<b>F_SETLEASE</b> command specifying <i>arg</i> as\n<b>F_RDLCK</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the lease\nholder fails to downgrade or remove the lease within the\nnumber of seconds specified in\n<i>/proc/sys/fs/lease-break-time</i>, then the kernel\nforcibly removes or downgrades the lease holder&rsquo;s\nlease.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once a lease\nbreak has been initiated, <b>F_GETLEASE</b> returns the\ntarget lease type (either <b>F_RDLCK</b> or <b>F_UNLCK</b>,\ndepending on what would be compatible with the lease\nbreaker) until the lease holder voluntarily downgrades or\nremoves the lease or the kernel forcibly does so after the\nlease break timer expires.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once the lease\nhas been voluntarily or forcibly removed or downgraded, and\nassuming the lease breaker has not unblocked its system\ncall, the kernel permits the lease breaker&rsquo;s system\ncall to proceed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the lease\nbreaker&rsquo;s blocked <a href=\"https://man.page/2/open\">open(2)</a> or <a href=\"https://man.page/2/truncate\">truncate(2)</a>\nis interrupted by a signal handler, then the system call\nfails with the error <b>EINTR</b>, but the other steps still\noccur as described above. If the lease breaker is killed by\na signal while blocked in <a href=\"https://man.page/2/open\">open(2)</a> or\n<a href=\"https://man.page/2/truncate\">truncate(2)</a>, then the other steps still occur as\ndescribed above. If the lease breaker specifies the\n<b>O_NONBLOCK</b> flag when calling <a href=\"https://man.page/2/open\">open(2)</a>, then the\ncall immediately fails with the error <b>EWOULDBLOCK</b>,\nbut the other steps still occur as described above.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\nsignal used to notify the lease holder is <b>SIGIO</b>, but\nthis can be changed using the <b>F_SETSIG</b> command to\n<b>fcntl</b>(). If a <b>F_SETSIG</b> command is performed\n(even one specifying <b>SIGIO</b>), and the signal handler\nis established using <b>SA_SIGINFO</b>, then the handler\nwill receive a <i>siginfo_t</i> structure as its second\nargument, and the <i>si_fd</i> field of this argument will\nhold the file descriptor of the leased file that has been\naccessed by another process. (This is useful if the caller\nholds leases against multiple files.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File and\ndirectory change notification (dnotify) <br>\nF_NOTIFY</b> (<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">(Linux 2.4 onward) Provide\nnotification when the directory referred to by <i>fd</i> or\nany of the files that it contains is changed. The events to\nbe notified are specified in <i>arg</i>, which is a bit mask\nspecified by ORing together zero or more of the following\nbits: <b><br>\nDN_ACCESS</b></p>\n\n<p style=\"margin-left:32%;\">A file was accessed\n(<a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/pread\">pread(2)</a>, <a href=\"https://man.page/2/readv\">readv(2)</a>, and\nsimilar)</p>\n\n<p style=\"margin-left:22%;\"><b>DN_MODIFY</b></p>\n\n<p style=\"margin-left:32%;\">A file was modified\n(<a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/2/pwrite\">pwrite(2)</a>, <a href=\"https://man.page/2/writev\">writev(2)</a>,\n<a href=\"https://man.page/2/truncate\">truncate(2)</a>, <a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>, and similar).</p>\n\n<p style=\"margin-left:22%;\"><b>DN_CREATE</b></p>\n\n<p style=\"margin-left:32%;\">A file was created\n(<a href=\"https://man.page/2/open\">open(2)</a>, <a href=\"https://man.page/2/creat\">creat(2)</a>, <a href=\"https://man.page/2/mknod\">mknod(2)</a>,\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, <a href=\"https://man.page/2/link\">link(2)</a>, <a href=\"https://man.page/2/symlink\">symlink(2)</a>,\n<a href=\"https://man.page/2/rename\">rename(2)</a> into this directory).</p>\n\n<p style=\"margin-left:22%;\"><b>DN_DELETE</b></p>\n\n<p style=\"margin-left:32%;\">A file was unlinked\n(<a href=\"https://man.page/2/unlink\">unlink(2)</a>, <a href=\"https://man.page/2/rename\">rename(2)</a> to another directory,\n<a href=\"https://man.page/2/rmdir\">rmdir(2)</a>).</p>\n\n<p style=\"margin-left:22%;\"><b>DN_RENAME</b></p>\n\n<p style=\"margin-left:32%;\">A file was renamed within this\ndirectory (<a href=\"https://man.page/2/rename\">rename(2)</a>).</p>\n\n<p style=\"margin-left:22%;\"><b>DN_ATTRIB</b></p>\n\n<p style=\"margin-left:32%;\">The attributes of a file were\nchanged (<a href=\"https://man.page/2/chown\">chown(2)</a>, <a href=\"https://man.page/2/chmod\">chmod(2)</a>, <a href=\"https://man.page/2/utime\">utime(2)</a>,\n<a href=\"https://man.page/2/utimensat\">utimensat(2)</a>, and similar).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">(In order to\nobtain these definitions, the <b>_GNU_SOURCE</b> feature\ntest macro must be defined before including <i>any</i>\nheader files.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Directory\nnotifications are normally &quot;one-shot&quot;, and the\napplication must reregister to receive further\nnotifications. Alternatively, if <b>DN_MULTISHOT</b> is\nincluded in <i>arg</i>, then notification will remain in\neffect until explicitly removed.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A series of\n<b>F_NOTIFY</b> requests is cumulative, with the events in\n<i>arg</i> being added to the set already monitored. To\ndisable notification of all events, make an <b>F_NOTIFY</b>\ncall specifying <i>arg</i> as 0.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Notification\noccurs via delivery of a signal. The default signal is\n<b>SIGIO</b>, but this can be changed using the\n<b>F_SETSIG</b> command to <b>fcntl</b>(). (Note that\n<b>SIGIO</b> is one of the nonqueuing standard signals;\nswitching to the use of a real-time signal means that\nmultiple notifications can be queued to the process.) In the\nlatter case, the signal handler receives a <i>siginfo_t</i>\nstructure as its second argument (if the handler was\nestablished using <b>SA_SIGINFO</b>) and the <i>si_fd</i>\nfield of this structure contains the file descriptor which\ngenerated the notification (useful when establishing\nnotification on multiple directories).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Especially when\nusing <b>DN_MULTISHOT</b>, a real time signal should be used\nfor notification, so that multiple notifications can be\nqueued.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>NOTE:</b>\nNew applications should use the <i>inotify</i> interface\n(available since kernel 2.6.13), which provides a much\nsuperior interface for obtaining notifications of filesystem\nevents. See <a href=\"https://man.page/7/inotify\">inotify(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Changing the\ncapacity of a pipe <br>\nF_SETPIPE_SZ</b> (<i>int</i>; since Linux 2.6.35)</p>\n\n<p style=\"margin-left:22%;\">Change the capacity of the pipe\nreferred to by <i>fd</i> to be at least <i>arg</i> bytes. An\nunprivileged process can adjust the pipe capacity to any\nvalue between the system page size and the limit defined in\n<i>/proc/sys/fs/pipe-max-size</i> (see <a href=\"https://man.page/5/proc\">proc(5)</a>).\nAttempts to set the pipe capacity below the page size are\nsilently rounded up to the page size. Attempts by an\nunprivileged process to set the pipe capacity above the\nlimit in <i>/proc/sys/fs/pipe-max-size</i> yield the error\n<b>EPERM</b>; a privileged process (<b>CAP_SYS_RESOURCE</b>)\ncan override the limit.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">When allocating\nthe buffer for the pipe, the kernel may use a capacity\nlarger than <i>arg</i>, if that is convenient for the\nimplementation. (In the current implementation, the\nallocation is the next higher power-of-two page-size\nmultiple of the requested size.) The actual capacity (in\nbytes) that is set is returned as the function result.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Attempting to\nset the pipe capacity smaller than the amount of buffer\nspace currently used to store data produces the error\n<b>EBUSY</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note that\nbecause of the way the pages of the pipe buffer are employed\nwhen data is written to the pipe, the number of bytes that\ncan be written may be less than the nominal size, depending\non the size of the writes.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETPIPE_SZ</b>\n(<i>void</i>; since Linux 2.6.35)</p>\n\n<p style=\"margin-left:22%;\">Return (as the function result)\nthe capacity of the pipe referred to by <i>fd</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File\nSealing</b> <br>\nFile seals limit the set of allowed operations on a given\nfile. For each seal that is set on a file, a specific set of\noperations will fail with <b>EPERM</b> on this file from now\non. The file is said to be sealed. The default set of seals\ndepends on the type of the underlying file and filesystem.\nFor an overview of file sealing, a discussion of its\npurpose, and some code examples, see\n<a href=\"https://man.page/2/memfd_create\">memfd_create(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Currently, file\nseals can be applied only to a file descriptor returned by\n<a href=\"https://man.page/2/memfd_create\">memfd_create(2)</a> (if the <b>MFD_ALLOW_SEALING</b> was\nemployed). On other filesystems, all <b>fcntl</b>()\noperations that operate on seals will return\n<b>EINVAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Seals are a\nproperty of an inode. Thus, all open file descriptors\nreferring to the same inode share the same set of seals.\nFurthermore, seals can never be removed, only added. <b><br>\nF_ADD_SEALS</b> (<i>int</i>; since Linux 3.17)</p>\n\n<p style=\"margin-left:22%;\">Add the seals given in the\nbit-mask argument <i>arg</i> to the set of seals of the\ninode referred to by the file descriptor <i>fd</i>. Seals\ncannot be removed again. Once this call succeeds, the seals\nare enforced by the kernel immediately. If the current set\nof seals includes <b>F_SEAL_SEAL</b> (see below), then this\ncall will be rejected with <b>EPERM</b>. Adding a seal that\nis already set is a no-op, in case <b>F_SEAL_SEAL</b> is not\nset already. In order to place a seal, the file descriptor\n<i>fd</i> must be writable.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GET_SEALS</b>\n(<i>void</i>; since Linux 3.17)</p>\n\n<p style=\"margin-left:22%;\">Return (as the function result)\nthe current set of seals of the inode referred to by\n<i>fd</i>. If no seals are set, 0 is returned. If the file\ndoes not support sealing, -1 is returned and <i>errno</i> is\nset to <b>EINVAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nseals are available: <b><br>\nF_SEAL_SEAL</b></p>\n\n<p style=\"margin-left:22%;\">If this seal is set, any\nfurther call to <b>fcntl</b>() with <b>F_ADD_SEALS</b> fails\nwith the error <b>EPERM</b>. Therefore, this seal prevents\nany modifications to the set of seals itself. If the initial\nset of seals of a file includes <b>F_SEAL_SEAL</b>, then\nthis effectively causes the set of seals to be constant and\nlocked.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SEAL_SHRINK</b></p>\n\n<p style=\"margin-left:22%;\">If this seal is set, the file\nin question cannot be reduced in size. This affects\n<a href=\"https://man.page/2/open\">open(2)</a> with the <b>O_TRUNC</b> flag as well as\n<a href=\"https://man.page/2/truncate\">truncate(2)</a> and <a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>. Those calls fail\nwith <b>EPERM</b> if you try to shrink the file in question.\nIncreasing the file size is still possible.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SEAL_GROW</b></p>\n\n<p style=\"margin-left:22%;\">If this seal is set, the size\nof the file in question cannot be increased. This affects\n<a href=\"https://man.page/2/write\">write(2)</a> beyond the end of the file,\n<a href=\"https://man.page/2/truncate\">truncate(2)</a>, <a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>, and\n<a href=\"https://man.page/2/fallocate\">fallocate(2)</a>. These calls fail with <b>EPERM</b> if\nyou use them to increase the file size. If you keep the size\nor shrink it, those calls still work as expected.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SEAL_WRITE</b></p>\n\n<p style=\"margin-left:22%;\">If this seal is set, you cannot\nmodify the contents of the file. Note that shrinking or\ngrowing the size of the file is still possible and allowed.\nThus, this seal is normally used in combination with one of\nthe other seals. This seal affects <a href=\"https://man.page/2/write\">write(2)</a> and\n<a href=\"https://man.page/2/fallocate\">fallocate(2)</a> (only in combination with the\n<b>FALLOC_FL_PUNCH_HOLE</b> flag). Those calls fail with\n<b>EPERM</b> if this seal is set. Furthermore, trying to\ncreate new shared, writable memory-mappings via\n<a href=\"https://man.page/2/mmap\">mmap(2)</a> will also fail with <b>EPERM</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Using the\n<b>F_ADD_SEALS</b> operation to set the <b>F_SEAL_WRITE</b>\nseal fails with <b>EBUSY</b> if any writable, shared mapping\nexists. Such mappings must be unmapped before you can add\nthis seal. Furthermore, if there are any asynchronous I/O\noperations (<a href=\"https://man.page/2/io_submit\">io_submit(2)</a>) pending on the file, all\noutstanding writes will be discarded.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SEAL_FUTURE_WRITE</b>\n(since Linux 5.1)</p>\n\n<p style=\"margin-left:22%;\">The effect of this seal is\nsimilar to <b>F_SEAL_WRITE</b>, but the contents of the file\ncan still be modified via shared writable mappings that were\ncreated prior to the seal being set. Any attempt to create a\nnew writable mapping on the file via <a href=\"https://man.page/2/mmap\">mmap(2)</a> will\nfail with <b>EPERM</b>. Likewise, an attempt to write to the\nfile via <a href=\"https://man.page/2/write\">write(2)</a> will fail with <b>EPERM</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Using this\nseal, one process can create a memory buffer that it can\ncontinue to modify while sharing that buffer on a\n&quot;read-only&quot; basis with other processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File\nread/write hints</b> <br>\nWrite lifetime hints can be used to inform the kernel about\nthe relative expected lifetime of writes on a given inode or\nvia a particular open file description. (See <a href=\"https://man.page/2/open\">open(2)</a>\nfor an explanation of open file descriptions.) In this\ncontext, the term &quot;write lifetime&quot; means the\nexpected time the data will live on media, before being\noverwritten or erased.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An application\nmay use the different hint values specified below to\nseparate writes into different write classes, so that\nmultiple users or applications running on a single storage\nback-end can aggregate their I/O patterns in a consistent\nmanner. However, there are no functional semantics implied\nby these flags, and different I/O classes can use the write\nlifetime hints in arbitrary ways, so long as the hints are\nused consistently.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\noperations can be applied to the file descriptor, <i>fd</i>:\n<b><br>\nF_GET_RW_HINT</b> (<i>uint64_t *</i>; since Linux 4.13)</p>\n\n<p style=\"margin-left:22%;\">Returns the value of the\nread/write hint associated with the underlying inode\nreferred to by <i>fd</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SET_RW_HINT</b>\n(<i>uint64_t *</i>; since Linux 4.13)</p>\n\n<p style=\"margin-left:22%;\">Sets the read/write hint value\nassociated with the underlying inode referred to by\n<i>fd</i>. This hint persists until either it is explicitly\nmodified or the underlying filesystem is unmounted.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GET_FILE_RW_HINT</b>\n(<i>uint64_t *</i>; since Linux 4.13)</p>\n\n<p style=\"margin-left:22%;\">Returns the value of the\nread/write hint associated with the open file description\nreferred to by <i>fd</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>F_SET_FILE_RW_HINT</b>\n(<i>uint64_t *</i>; since Linux 4.13)</p>\n\n<p style=\"margin-left:22%;\">Sets the read/write hint value\nassociated with the open file description referred to by\n<i>fd</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If an open file\ndescription has not been assigned a read/write hint, then it\nshall use the value assigned to the inode, if any.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nread/write hints are valid since Linux 4.13: <b><br>\nRWH_WRITE_LIFE_NOT_SET</b></p>\n\n<p style=\"margin-left:22%;\">No specific hint has been set.\nThis is the default value.</p>\n\n<p style=\"margin-left:11%;\"><b>RWH_WRITE_LIFE_NONE</b></p>\n\n<p style=\"margin-left:22%;\">No specific write lifetime is\nassociated with this file or inode.</p>\n\n\n<p style=\"margin-left:11%;\"><b>RWH_WRITE_LIFE_SHORT</b></p>\n\n<p style=\"margin-left:22%;\">Data written to this inode or\nvia this open file description is expected to have a short\nlifetime.</p>\n\n\n<p style=\"margin-left:11%;\"><b>RWH_WRITE_LIFE_MEDIUM</b></p>\n\n<p style=\"margin-left:22%;\">Data written to this inode or\nvia this open file description is expected to have a\nlifetime longer than data written with\n<b>RWH_WRITE_LIFE_SHORT</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>RWH_WRITE_LIFE_LONG</b></p>\n\n<p style=\"margin-left:22%;\">Data written to this inode or\nvia this open file description is expected to have a\nlifetime longer than data written with\n<b>RWH_WRITE_LIFE_MEDIUM</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>RWH_WRITE_LIFE_EXTREME</b></p>\n\n<p style=\"margin-left:22%;\">Data written to this inode or\nvia this open file description is expected to have a\nlifetime longer than data written with\n<b>RWH_WRITE_LIFE_LONG</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All the\nwrite-specific hints are relative to each other, and no\nindividual absolute meaning should be attributed to\nthem.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a\nsuccessful call, the return value depends on the operation:\n<b><br>\nF_DUPFD</b></p>\n\n<p style=\"margin-left:22%;\">The new file descriptor.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETFD</b></p>\n\n<p style=\"margin-left:22%;\">Value of file descriptor\nflags.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETFL</b></p>\n\n<p style=\"margin-left:22%;\">Value of file status flags.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETLEASE</b></p>\n\n<p style=\"margin-left:22%;\">Type of lease held on file\ndescriptor.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETOWN</b></p>\n\n<p style=\"margin-left:22%;\">Value of file descriptor\nowner.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETSIG</b></p>\n\n<p style=\"margin-left:22%;\">Value of signal sent when read\nor write becomes possible, or zero for traditional\n<b>SIGIO</b> behavior.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GETPIPE_SZ</b>,\n<b>F_SETPIPE_SZ</b></p>\n\n<p style=\"margin-left:22%;\">The pipe capacity.</p>\n\n<p style=\"margin-left:11%;\"><b>F_GET_SEALS</b></p>\n\n<p style=\"margin-left:22%;\">A bit mask identifying the\nseals that have been set for the inode referred to by\n<i>fd</i>.</p>\n\n<p style=\"margin-left:11%;\">All other commands</p>\n\n<p style=\"margin-left:22%;\">Zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>EACCES</b>\nor <b>EAGAIN</b></p>\n\n<p style=\"margin-left:22%;\">Operation is prohibited by\nlocks held by other processes.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The operation is prohibited because the file has been\nmemory-mapped by another process.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is not an open file descriptor</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_SETLK</b> or <b>F_SETLKW</b> and the\nfile descriptor open mode doesn&rsquo;t match with the type\nof lock requested.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_SETPIPE_SZ</b> and the new pipe\ncapacity specified in <i>arg</i> is smaller than the amount\nof buffer space currently used to store data in the\npipe.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_ADD_SEALS</b>, <i>arg</i> includes\n<b>F_SEAL_WRITE</b>, and there exists a writable, shared\nmapping on the file referred to by <i>fd</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EDEADLK</b></p>\n\n<p style=\"margin-left:22%;\">It was detected that the\nspecified <b>F_SETLKW</b> command would cause a\ndeadlock.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>lock</i> is outside your accessible address\nspace.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_SETLKW</b> or <b>F_OFD_SETLKW</b> and\nthe operation was interrupted by a signal; see\n<a href=\"https://man.page/7/signal\">signal(7)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_GETLK</b>, <b>F_SETLK</b>,\n<b>F_OFD_GETLK</b>, or <b>F_OFD_SETLK</b>, and the operation\nwas interrupted by a signal before the lock was checked or\nacquired. Most likely when locking a remote file (e.g.,\nlocking over NFS), but can sometimes happen locally.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The value specified in <i>cmd</i> is not recognized by\nthis kernel.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_ADD_SEALS</b> and <i>arg</i> includes\nan unrecognized sealing bit.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_ADD_SEALS</b> or <b>F_GET_SEALS</b>\nand the filesystem containing the inode referred to by\n<i>fd</i> does not support sealing.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_DUPFD</b> and <i>arg</i> is negative\nor is greater than the maximum allowable value (see the\ndiscussion of <b>RLIMIT_NOFILE</b> in\n<a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_SETSIG</b> and <i>arg</i> is not an\nallowable signal number.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>,\nor <b>F_OFD_GETLK</b>, and <i>l_pid</i> was not specified as\nzero.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_DUPFD</b> and the per-process limit\non the number of open file descriptors has been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOLCK</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Too many segment locks open, lock table is full, or a\nremote locking protocol failed (e.g., locking over NFS).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTDIR</b></p>\n\n<p style=\"margin-left:22%;\"><b>F_NOTIFY</b> was specified\nin <i>cmd</i>, but <i>fd</i> does not refer to a\ndirectory.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> is <b>F_SETPIPE_SZ</b> and the soft or hard\nuser pipe limit has been reached; see <a href=\"https://man.page/7/pipe\">pipe(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to clear the <b>O_APPEND</b> flag on a file\nthat has the append-only attribute set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><i>cmd</i> was <b>F_ADD_SEALS</b>, but <i>fd</i> was not\nopen for writing or the current set of seals on the file\nalready includes <b>F_SEAL_SEAL</b>.</p></td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SVr4, 4.3BSD,\nPOSIX.1-2001. Only the operations <b>F_DUPFD</b>,\n<b>F_GETFD</b>, <b>F_SETFD</b>, <b>F_GETFL</b>,\n<b>F_SETFL</b>, <b>F_GETLK</b>, <b>F_SETLK</b>, and\n<b>F_SETLKW</b> are specified in POSIX.1-2001.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_GETOWN</b>\nand <b>F_SETOWN</b> are specified in POSIX.1-2001. (To get\ntheir definitions, define either <b>_XOPEN_SOURCE</b> with\nthe value 500 or greater, or <b>_POSIX_C_SOURCE</b> with the\nvalue 200809L or greater.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_DUPFD_CLOEXEC</b>\nis specified in POSIX.1-2008. (To get this definition,\ndefine <b>_POSIX_C_SOURCE</b> with the value 200809L or\ngreater, or <b>_XOPEN_SOURCE</b> with the value 700 or\ngreater.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_GETOWN_EX</b>,\n<b>F_SETOWN_EX</b>, <b>F_SETPIPE_SZ</b>,\n<b>F_GETPIPE_SZ</b>, <b>F_GETSIG</b>, <b>F_SETSIG</b>,\n<b>F_NOTIFY</b>, <b>F_GETLEASE</b>, and <b>F_SETLEASE</b>\nare Linux-specific. (Define the <b>_GNU_SOURCE</b> macro to\nobtain these definitions.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_OFD_SETLK</b>,\n<b>F_OFD_SETLKW</b>, and <b>F_OFD_GETLK</b> are\nLinux-specific (and one must define <b>_GNU_SOURCE</b> to\nobtain their definitions), but work is being done to have\nthem included in the next version of POSIX.1.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_ADD_SEALS</b>\nand <b>F_GET_SEALS</b> are Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The errors\nreturned by <a href=\"https://man.page/2/dup2\">dup2(2)</a> are different from those returned\nby <b>F_DUPFD</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File\nlocking</b> <br>\nThe original Linux <b>fcntl</b>() system call was not\ndesigned to handle large file offsets (in the <i>flock</i>\nstructure). Consequently, an <b>fcntl64</b>() system call\nwas added in Linux 2.4. The newer system call employs a\ndifferent structure for file locking, <i>flock64</i>, and\ncorresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>,\nand <b>F_SETLKW64</b>. However, these details can be ignored\nby applications using glibc, whose <b>fcntl</b>() wrapper\nfunction transparently employs the more recent system call\nwhere it is available.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Record\nlocks</b> <br>\nSince kernel 2.0, there is no interaction between the types\nof lock placed by <a href=\"https://man.page/2/flock\">flock(2)</a> and <b>fcntl</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Several systems\nhave more fields in <i>struct flock</i> such as, for\nexample, <i>l_sysid</i> (to identify the machine where the\nlock is held). Clearly, <i>l_pid</i> alone is not going to\nbe very useful if the process holding the lock may live on a\ndifferent machine; on Linux, while present on some\narchitectures (such as MIPS32), this field is not used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The original\nLinux <b>fcntl</b>() system call was not designed to handle\nlarge file offsets (in the <i>flock</i> structure).\nConsequently, an <b>fcntl64</b>() system call was added in\nLinux 2.4. The newer system call employs a different\nstructure for file locking, <i>flock64</i>, and\ncorresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>,\nand <b>F_SETLKW64</b>. However, these details can be ignored\nby applications using glibc, whose <b>fcntl</b>() wrapper\nfunction transparently employs the more recent system call\nwhere it is available.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Record\nlocking and NFS</b> <br>\nBefore Linux 3.12, if an NFSv4 client loses contact with the\nserver for a period of time (defined as more than 90 seconds\nwith no communication), it might lose and regain a lock\nwithout ever being aware of the fact. (The period of time\nafter which contact is assumed lost is known as the NFSv4\nleasetime. On a Linux NFS server, this can be determined by\nlooking at <i>/proc/fs/nfsd/nfsv4leasetime</i>, which\nexpresses the period in seconds. The default value for this\nfile is 90.) This scenario potentially risks data\ncorruption, since another process might acquire a lock in\nthe intervening period and perform file I/O.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n3.12, if an NFSv4 client loses contact with the server, any\nI/O to the file by a process which &quot;thinks&quot; it\nholds a lock will fail until that process closes and reopens\nthe file. A kernel parameter, <i>nfs.recover_lost_locks</i>,\ncan be set to 1 to obtain the pre-3.12 behavior, whereby the\nclient will attempt to recover lost locks when contact is\nreestablished with the server. Because of the attendant risk\nof data corruption, this parameter defaults to 0\n(disabled).</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_SETFL</b>\n<br>\nIt is not possible to use <b>F_SETFL</b> to change the state\nof the <b>O_DSYNC</b> and <b>O_SYNC</b> flags. Attempts to\nchange the state of these flags are silently ignored.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_GETOWN</b>\n<br>\nA limitation of the Linux system call conventions on some\narchitectures (notably i386) means that if a (negative)\nprocess group ID to be returned by <b>F_GETOWN</b> falls in\nthe range -1 to -4095, then the return value is wrongly\ninterpreted by glibc as an error in the system call; that\nis, the return value of <b>fcntl</b>() will be -1, and\n<i>errno</i> will contain the (positive) process group ID.\nThe Linux-specific <b>F_GETOWN_EX</b> operation avoids this\nproblem. Since glibc version 2.11, glibc makes the kernel\n<b>F_GETOWN</b> problem invisible by implementing\n<b>F_GETOWN</b> using <b>F_GETOWN_EX</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>F_SETOWN</b>\n<br>\nIn Linux 2.4 and earlier, there is bug that can occur when\nan unprivileged process uses <b>F_SETOWN</b> to specify the\nowner of a socket file descriptor as a process (group) other\nthan the caller. In this case, <b>fcntl</b>() can return -1\nwith <i>errno</i> set to <b>EPERM</b>, even when the owner\nprocess (group) is one that the caller has permission to\nsend signals to. Despite this error return, the file\ndescriptor owner is set, and signals will be sent to the\nowner.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Deadlock\ndetection</b> <br>\nThe deadlock-detection algorithm employed by the kernel when\ndealing with <b>F_SETLKW</b> requests can yield both false\nnegatives (failures to detect deadlocks, leaving a set of\ndeadlocked processes blocked indefinitely) and false\npositives (<b>EDEADLK</b> errors when there is no deadlock).\nFor example, the kernel limits the lock depth of its\ndependency search to 10 steps, meaning that circular\ndeadlock chains that exceed that size will not be detected.\nIn addition, the kernel may falsely indicate a deadlock when\ntwo or more processes created using the <a href=\"https://man.page/2/clone\">clone(2)</a>\n<b>CLONE_FILES</b> flag place locks that appear (to the\nkernel) to conflict.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Mandatory\nlocking</b> <br>\nThe Linux implementation of mandatory locking is subject to\nrace conditions which render it unreliable: a\n<a href=\"https://man.page/2/write\">write(2)</a> call that overlaps with a lock may modify\ndata after the mandatory lock is acquired; a <a href=\"https://man.page/2/read\">read(2)</a>\ncall that overlaps with a lock may detect changes to data\nthat were made only after a write lock was acquired. Similar\nraces exist between mandatory locks and <a href=\"https://man.page/2/mmap\">mmap(2)</a>. It\nis therefore inadvisable to rely on mandatory locking.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/dup2\">dup2(2)</a>,\n<a href=\"https://man.page/2/flock\">flock(2)</a>, <a href=\"https://man.page/2/open\">open(2)</a>, <a href=\"https://man.page/2/socket\">socket(2)</a>,\n<a href=\"https://man.page/3/lockf\">lockf(3)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>, <b>lslocks</b>(8)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>locks.txt</i>,\n<i>mandatory-locking.txt</i>, and <i>dnotify.txt</i> in the\nLinux kernel source directory\n<i>Documentation/filesystems/</i> (on older kernels, these\nfiles are directly under the <i>Documentation/</i>\ndirectory, and <i>mandatory-locking.txt</i> is called\n<i>mandatory.txt</i>)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}