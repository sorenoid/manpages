{"name":"ioctl_fat","body":"\n\n<h1 align=\"center\">IOCTL_FAT</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioctl_fat -\nmanipulating the FAT filesystem</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;linux/msdos_fs.h&gt; <br>\n#include &lt;sys/ioctl.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nioctl(int</b> <i>fd</i><b>, FAT_IOCTL_GET_ATTRIBUTES,\nuint32_t *</b><i>attr</i><b>); <br>\nint ioctl(int</b> <i>fd</i><b>, FAT_IOCTL_SET_ATTRIBUTES,\nuint32_t *</b><i>attr</i><b>); <br>\nint ioctl(int</b> <i>fd</i><b>, FAT_IOCTL_GET_VOLUME_ID,\nuint32_t *</b><i>id</i><b>); <br>\nint ioctl(int</b> <i>fd</i><b>, VFAT_IOCTL_READDIR_BOTH,\n<br>\nstruct __fat_dirent[2]</b> <i>entry</i><b>); <br>\nint ioctl(int</b> <i>fd</i><b>, VFAT_IOCTL_READDIR_SHORT,\n<br>\nstruct __fat_dirent[2]</b> <i>entry</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> system call can be used to read and write\nmetadata of FAT filesystems that are not accessible using\nother system calls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading and\nsetting file attributes</b> <br>\nFiles and directories in the FAT filesystem possess an\nattribute bit mask that can be read with\n<b>FAT_IOCTL_GET_ATTRIBUTES</b> and written with\n<b>FAT_IOCTL_SET_ATTRIBUTES</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>fd</i>\nargument contains a file descriptor for a file or directory.\nIt is sufficient to create the file descriptor by calling\n<a href=\"https://man.page/2/open\">open(2)</a> with the <b>O_RDONLY</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>attr</i>\nargument contains a pointer to a bit mask. The bits of the\nbit mask are: <b><br>\nATTR_RO</b></p>\n\n<p style=\"margin-left:22%;\">This bit specifies that the\nfile or directory is read-only.</p>\n\n<p style=\"margin-left:11%;\"><b>ATTR_HIDDEN</b></p>\n\n<p style=\"margin-left:22%;\">This bit specifies that the\nfile or directory is hidden.</p>\n\n<p style=\"margin-left:11%;\"><b>ATTR_SYS</b></p>\n\n<p style=\"margin-left:22%;\">This bit specifies that the\nfile is a system file.</p>\n\n<p style=\"margin-left:11%;\"><b>ATTR_VOLUME</b></p>\n\n<p style=\"margin-left:22%;\">This bit specifies that the\nfile is a volume label. This attribute is read-only.</p>\n\n<p style=\"margin-left:11%;\"><b>ATTR_DIR</b></p>\n\n<p style=\"margin-left:22%;\">This bit specifies that this is\na directory. This attribute is read-only.</p>\n\n<p style=\"margin-left:11%;\"><b>ATTR_ARCH</b></p>\n\n<p style=\"margin-left:22%;\">This bit indicates that this\nfile or directory should be archived. It is set when a file\nis created or modified. It is reset by an archiving\nsystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The zero value\n<b>ATTR_NONE</b> can be used to indicate that no attribute\nbit is set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading the\nvolume ID</b> <br>\nFAT filesystems are identified by a volume ID. The volume ID\ncan be read with <b>FAT_IOCTL_GET_VOLUME_ID</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>fd</i>\nargument can be a file descriptor for any file or directory\nof the filesystem. It is sufficient to create the file\ndescriptor by calling <a href=\"https://man.page/2/open\">open(2)</a> with the\n<b>O_RDONLY</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>id</i>\nargument is a pointer to the field that will be filled with\nthe volume ID. Typically the volume ID is displayed to the\nuser as a group of two 16-bit fields:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">printf(&quot;Volume\nID %04x-%04x\\n&quot;, id &gt;&gt; 16, id &amp; 0xFFFF);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading\nshort filenames of a directory</b> <br>\nA file or directory on a FAT filesystem always has a short\nfilename consisting of up to 8 capital letters, optionally\nfollowed by a period and up to 3 capital letters for the\nfile extension. If the actual filename does not fit into\nthis scheme, it is stored as a long filename of up to 255\nUTF-16 characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The short\nfilenames in a directory can be read with\n<b>VFAT_IOCTL_READDIR_SHORT</b>.\n<b>VFAT_IOCTL_READDIR_BOTH</b> reads both the short and the\nlong filenames.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>fd</i>\nargument must be a file descriptor for a directory. It is\nsufficient to create the file descriptor by calling\n<a href=\"https://man.page/2/open\">open(2)</a> with the <b>O_RDONLY</b> flag. The file\ndescriptor can be used only once to iterate over the\ndirectory entries by calling <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> repeatedly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>entry</i> argument is a two-element array of the\nfollowing structures:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\n__fat_dirent { <br>\nlong d_ino; <br>\n__kernel_off_t d_off; <br>\nuint32_t short d_reclen; <br>\nchar d_name[256]; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first entry\nin the array is for the short filename. The second entry is\nfor the long filename.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>d_ino</i> and <i>d_off</i> fields are filled only for\nlong filenames. The <i>d_ino</i> field holds the inode\nnumber of the directory. The <i>d_off</i> field holds the\noffset of the file entry in the directory. As these values\nare not available for short filenames, the user code should\nsimply ignore them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The field\n<i>d_reclen</i> contains the length of the filename in the\nfield <i>d_name</i>. To keep backward compatibility, a\nlength of 0 for the short filename signals that the end of\nthe directory has been reached. However, the preferred\nmethod for detecting the end of the directory is to test the\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> return value. If no long filename exists,\nfield <i>d_reclen</i> is set to 0 and <i>d_name</i> is a\ncharacter string of length 0 for the long filename.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set to indicate the error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>VFAT_IOCTL_READDIR_BOTH</b> and\n<b>VFAT_IOCTL_READDIR_SHORT</b> a return value of 1 signals\nthat a new directory entry has been read and a return value\nof 0 signals that the end of the directory has been\nreached.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">This error is returned by\n<b>VFAT_IOCTL_READDIR_BOTH</b> and\n<b>VFAT_IOCTL_READDIR_SHORT</b> if the file descriptor\n<i>fd</i> refers to a removed, but still open directory.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTDIR</b></p>\n\n<p style=\"margin-left:22%;\">This error is returned by\n<b>VFAT_IOCTL_READDIR_BOTH</b> and\n<b>VFAT_IOCTL_READDIR_SHORT</b> if the file descriptor\n<i>fd</i> does not refer to a directory.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOTTY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The file descriptor <i>fd</i> does not refer to an\nobject in a FAT filesystem.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For further\nerror values, see <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>VFAT_IOCTL_READDIR_BOTH</b>\nand <b>VFAT_IOCTL_READDIR_SHORT</b> first appeared in Linux\n2.0.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>FAT_IOCTL_GET_ATTRIBUTES</b>\nand <b>FAT_IOCTL_SET_ATTRIBUTES</b> first appeared in Linux\n2.6.12.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>FAT_IOCTL_GET_VOLUME_ID</b>\nwas introduced in version 3.11 of the Linux kernel.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This API is\nLinux-specific.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Toggling the\narchive flag</b> <br>\nThe following program demonstrates the usage of\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> to manipulate file attributes. The program\nreads and displays the archive attribute of a file. After\ninverting the value of the attribute, the program reads and\ndisplays the attribute again.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nwas recorded when applying the program for the file\n<i>/mnt/user/foo</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#\n./toggle_fat_archive_flag /mnt/user/foo <br>\nArchive flag is set <br>\nToggling archive flag <br>\nArchive flag is not set</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource (toggle_fat_archive_flag.c)</b> <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;linux/msdos_fs.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/ioctl.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Read file attributes of a file on a FAT filesystem. <br>\n* Output the state of the archive flag. <br>\n*/ <br>\nstatic uint32_t <br>\nreadattr(int fd) <br>\n{ <br>\nuint32_t attr; <br>\nint ret;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret = ioctl(fd,\nFAT_IOCTL_GET_ATTRIBUTES, &amp;attr); <br>\nif (ret == -1) { <br>\nperror(&quot;ioctl&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (attr &amp;\nATTR_ARCH) <br>\nprintf(&quot;Archive flag is set\\n&quot;); <br>\nelse <br>\nprintf(&quot;Archive flag is not set\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return attr;\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nuint32_t attr; <br>\nint fd; <br>\nint ret;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nprintf(&quot;Usage: %s FILENAME\\n&quot;, argv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(argv[1], O_RDONLY); <br>\nif (fd == -1) { <br>\nperror(&quot;open&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Read and display the FAT file attributes. <br>\n*/ <br>\nattr = readattr(fd);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Invert archive attribute. <br>\n*/ <br>\nprintf(&quot;Toggling archive flag\\n&quot;); <br>\nattr ^= ATTR_ARCH;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Write the changed FAT file attributes. <br>\n*/ <br>\nret = ioctl(fd, FAT_IOCTL_SET_ATTRIBUTES, &amp;attr); <br>\nif (ret == -1) { <br>\nperror(&quot;ioctl&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Read and display the FAT file attributes. <br>\n*/ <br>\nreadattr(fd);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(fd);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading the\nvolume ID</b> <br>\nThe following program demonstrates the use of\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> to display the volume ID of a FAT\nfilesystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\noutput was recorded when applying the program for directory\n<i>/mnt/user</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n./display_fat_volume_id /mnt/user <br>\nVolume ID 6443-6241</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource (display_fat_volume_id.c)</b> <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;linux/msdos_fs.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/ioctl.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nuint32_t id; <br>\nint fd; <br>\nint ret;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nprintf(&quot;Usage: %s FILENAME\\n&quot;, argv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(argv[1], O_RDONLY); <br>\nif (fd == -1) { <br>\nperror(&quot;open&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Read volume ID. <br>\n*/ <br>\nret = ioctl(fd, FAT_IOCTL_GET_VOLUME_ID, &amp;id); <br>\nif (ret == -1) { <br>\nperror(&quot;ioctl&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Format the output as two groups of 16 bits each. <br>\n*/ <br>\nprintf(&quot;Volume ID %04x-%04x\\n&quot;, id &gt;&gt; 16, id\n&amp; 0xFFFF);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(fd);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Listing a\ndirectory</b> <br>\nThe following program demonstrates the use of\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> to list a directory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nwas recorded when applying the program to the directory\n<i>/mnt/user</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./fat_dir\n/mnt/user</b> <br>\n. -&gt; '' <br>\n.. -&gt; '' <br>\nALONGF~1.TXT -&gt; 'a long filename.txt' <br>\nUPPER.TXT -&gt; '' <br>\nLOWER.TXT -&gt; 'lower.txt'</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b></p>\n\n<p style=\"margin-left:17%;\">#include &lt;fcntl.h&gt; <br>\n#include &lt;linux/msdos_fs.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/ioctl.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct __fat_dirent entry[2]; <br>\nint fd; <br>\nint ret;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (argc != 2)\n{ <br>\nprintf(&quot;Usage: %s DIRECTORY\\n&quot;, argv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* Open file descriptor for the directory. <br>\n*/ <br>\nfd = open(argv[1], O_RDONLY | O_DIRECTORY); <br>\nif (fd == -1) { <br>\nperror(&quot;open&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for (;;) {</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* Read next directory entry. <br>\n*/ <br>\nret = ioctl( fd, VFAT_IOCTL_READDIR_BOTH, entry);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* If an error occurs, the return value is -1. <br>\n* If the end of the directory list has been reached, <br>\n* the return value is 0. <br>\n* For backward compatibility the end of the directory <br>\n* list is also signaled by d_reclen == 0. <br>\n*/ <br>\nif (ret &lt; 1) <br>\nbreak;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* Write both the short name and the long name. <br>\n*/ <br>\nprintf(&quot;%s -&gt; '%s'\\n&quot;, entry[0].d_name,\nentry[1].d_name); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (ret == -1)\n{ <br>\nperror(&quot;VFAT_IOCTL_READDIR_BOTH&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* Close the file descriptor. <br>\n*/ <br>\nclose(fd);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/ioctl\">ioctl(2)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}