{"name":"clone","description":"clone,\n__clone2, clone3 - create a child process","body":"\n\n<h1 align=\"center\">CLONE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">clone,\n__clone2, clone3 - create a child process</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Prototype\nfor the glibc wrapper function */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE <br>\n#include &lt;sched.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nclone(int (*</b><i>fn</i><b>)(void *), void\n*</b><i>stack</i><b>, int</b> <i>flags</i><b>, void\n*</b><i>arg</i><b>, ... <br>\n/* pid_t *</b><i>parent_tid</i><b>, void *</b><i>tls</i><b>,\npid_t *</b><i>child_tid</i> <b>*/ );</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* For the\nprototype of the raw clone() system call, see NOTES */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>long\nclone3(struct clone_args *</b><i>cl_args</i><b>, size_t</b>\n<i>size</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere is not yet a glibc wrapper for <b>clone3</b>(); see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls create a new (&quot;child&quot;) process, in a manner\nsimilar to <a href=\"https://man.page/2/fork\">fork(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By contrast\nwith <a href=\"https://man.page/2/fork\">fork(2)</a>, these system calls provide more precise\ncontrol over what pieces of execution context are shared\nbetween the calling process and the child process. For\nexample, using these system calls, the caller can control\nwhether or not the two processes share the virtual address\nspace, the table of file descriptors, and the table of\nsignal handlers. These system calls also allow the new child\nprocess to be placed in separate <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that in\nthis manual page, &quot;calling process&quot; normally\ncorresponds to &quot;parent process&quot;. But see the\ndescriptions of <b>CLONE_PARENT</b> and <b>CLONE_THREAD</b>\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page\ndescribes the following interfaces:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The glibc <b>clone</b>() wrapper function and the\nunderlying system call on which it is based. The main text\ndescribes the wrapper function; the differences for the raw\nsystem call are described toward the end of this page.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The newer <b>clone3</b>() system call.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the\nremainder of this page, the terminology &quot;the clone\ncall&quot; is used when noting details that apply to all of\nthese interfaces,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The clone()\nwrapper function</b> <br>\nWhen the child process is created with the <b>clone</b>()\nwrapper function, it commences execution by calling the\nfunction pointed to by the argument <i>fn</i>. (This differs\nfrom <a href=\"https://man.page/2/fork\">fork(2)</a>, where execution continues in the child\nfrom the point of the <a href=\"https://man.page/2/fork\">fork(2)</a> call.) The <i>arg</i>\nargument is passed as the argument of the function\n<i>fn</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\n<i>fn</i>(<i>arg</i>) function returns, the child process\nterminates. The integer returned by <i>fn</i> is the exit\nstatus for the child process. The child process may also\nterminate explicitly by calling <a href=\"https://man.page/2/exit\">exit(2)</a> or after\nreceiving a fatal signal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>stack</i> argument specifies the location of the stack\nused by the child process. Since the child and calling\nprocess may share memory, it is not possible for the child\nprocess to execute in the same stack as the calling process.\nThe calling process must therefore set up memory space for\nthe child stack and pass a pointer to this space to\n<b>clone</b>(). Stacks grow downward on all processors that\nrun Linux (except the HP PA processors), so <i>stack</i>\nusually points to the topmost address of the memory space\nset up for the child stack. Note that <b>clone</b>() does\nnot provide a means whereby the caller can inform the kernel\nof the size of the stack area.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The remaining\narguments to <b>clone</b>() are discussed below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clone3()</b>\n<br>\nThe <b>clone3</b>() system call provides a superset of the\nfunctionality of the older <b>clone</b>() interface. It also\nprovides a number of API improvements, including: space for\nadditional flags bits; cleaner separation in the use of\nvarious arguments; and the ability to specify the size of\nthe child&rsquo;s stack area.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As with\n<a href=\"https://man.page/2/fork\">fork(2)</a>, <b>clone3</b>() returns in both the parent\nand the child. It returns 0 in the child process and returns\nthe PID of the child in the parent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cl_args</i> argument of <b>clone3</b>() is a structure of\nthe following form:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nclone_args { <br>\nu64 flags; /* Flags bit mask */ <br>\nu64 pidfd; /* Where to store PID file descriptor <br>\n(<i>pid_t *</i>) */ <br>\nu64 child_tid; /* Where to store child TID, <br>\nin child's memory (<i>pid_t *</i>) */ <br>\nu64 parent_tid; /* Where to store child TID, <br>\nin parent's memory (<i>int *</i>) */ <br>\nu64 exit_signal; /* Signal to deliver to parent on <br>\nchild termination */ <br>\nu64 stack; /* Pointer to lowest byte of stack */ <br>\nu64 stack_size; /* Size of stack */ <br>\nu64 tls; /* Location of new TLS */ <br>\nu64 set_tid; /* Pointer to a <i>pid_t</i> array <br>\n(since Linux 5.5) */ <br>\nu64 set_tid_size; /* Number of elements in <i>set_tid</i>\n<br>\n(since Linux 5.5) */ <br>\nu64 cgroup; /* File descriptor for target cgroup <br>\nof child (since Linux 5.7) */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>size</i>\nargument that is supplied to <b>clone3</b>() should be\ninitialized to the size of this structure. (The existence of\nthe <i>size</i> argument permits future extensions to the\n<i>clone_args</i> structure.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The stack for\nthe child process is specified via <i>cl_args.stack</i>,\nwhich points to the lowest byte of the stack area, and\n<i>cl_args.stack_size</i>, which specifies the size of the\nstack in bytes. In the case where the <b>CLONE_VM</b> flag\n(see below) is specified, a stack must be explicitly\nallocated and specified. Otherwise, these two fields can be\nspecified as NULL and 0, which causes the child to use the\nsame stack area as the parent (in the child&rsquo;s own\nvirtual address space).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The remaining\nfields in the <i>cl_args</i> argument are discussed\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Equivalence\nbetween clone() and clone3() arguments</b> <br>\nUnlike the older <b>clone</b>() interface, where arguments\nare passed individually, in the newer <b>clone3</b>()\ninterface the arguments are packaged into the\n<i>clone_args</i> structure shown above. This structure\nallows for a superset of the information passed via the\n<b>clone</b>() arguments.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\ntable shows the equivalence between the arguments of\n<b>clone</b>() and the fields in the <i>clone_args</i>\nargument supplied to <b>clone3</b>():</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3253871.png\" alt=\"Image grohtml-3253871.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The child\ntermination signal</b> <br>\nWhen the child process terminates, a signal may be sent to\nthe parent. The termination signal is specified in the low\nbyte of <i>flags</i> (<b>clone</b>()) or in\n<i>cl_args.exit_signal</i> (<b>clone3</b>()). If this signal\nis specified as anything other than <b>SIGCHLD</b>, then the\nparent process must specify the <b>__WALL</b> or\n<b>__WCLONE</b> options when waiting for the child with\n<a href=\"https://man.page/2/wait\">wait(2)</a>. If no signal (i.e., zero) is specified, then\nthe parent process is not signaled when the child\nterminates.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The set_tid\narray</b> <br>\nBy default, the kernel chooses the next sequential PID for\nthe new process in each of the PID namespaces where it is\npresent. When creating a process with <b>clone3</b>(), the\n<i>set_tid</i> array (available since Linux 5.5) can be used\nto select specific PIDs for the process in some or all of\nthe PID namespaces where it is present. If the PID of the\nnewly created process should be set only for the current PID\nnamespace or in the newly created PID namespace (if\n<i>flags</i> contains <b>CLONE_NEWPID</b>) then the first\nelement in the <i>set_tid</i> array has to be the desired\nPID and <i>set_tid_size</i> needs to be 1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the PID of\nthe newly created process should have a certain value in\nmultiple PID namespaces, then the <i>set_tid</i> array can\nhave multiple entries. The first entry defines the PID in\nthe most deeply nested PID namespace and each of the\nfollowing entries contains the PID in the corresponding\nancestor PID namespace. The number of PID namespaces in\nwhich a PID should be set is defined by <i>set_tid_size</i>\nwhich cannot be larger than the number of currently nested\nPID namespaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To create a\nprocess with the following PIDs in a PID namespace\nhierarchy:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3253872.png\" alt=\"Image grohtml-3253872.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Set the array\nto:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">set_tid[0] = 7;\n<br>\nset_tid[1] = 42; <br>\nset_tid[2] = 31496; <br>\nset_tid_size = 3;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If only the\nPIDs in the two innermost PID namespaces need to be\nspecified, set the array to:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">set_tid[0] = 7;\n<br>\nset_tid[1] = 42; <br>\nset_tid_size = 2;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The PID in the\nPID namespaces outside the two innermost PID namespaces will\nbe selected the same way as any other PID is selected.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>set_tid</i> feature requires <b>CAP_SYS_ADMIN</b> or\n(since Linux 5.9) <b>CAP_CHECKPOINT_RESTORE</b> in all\nowning user namespaces of the target PID namespaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Callers may\nonly choose a PID greater than 1 in a given PID namespace if\nan <b>init</b> process (i.e., a process with PID 1) already\nexists in that namespace. Otherwise the PID entry for this\nPID namespace must be 1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The flags\nmask</b> <br>\nBoth <b>clone</b>() and <b>clone3</b>() allow a flags bit\nmask that modifies their behavior and allows the caller to\nspecify what is shared between the calling process and the\nchild process. This bit mask&mdash;the <i>flags</i> argument\nof <b>clone</b>() or the <i>cl_args.flags</i> field passed\nto <b>clone3</b>()&mdash;is referred to as the <i>flags</i>\nmask in the remainder of this page.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> mask is specified as a bitwise-OR of zero or\nmore of the constants listed below. Except as noted below,\nthese flags are available (and have the same effect) in both\n<b>clone</b>() and <b>clone3</b>(). <b><br>\nCLONE_CHILD_CLEARTID</b> (since Linux 2.5.49)</p>\n\n<p style=\"margin-left:22%;\">Clear (zero) the child thread\nID at the location pointed to by <i>child_tid</i>\n(<b>clone</b>()) or <i>cl_args.child_tid</i>\n(<b>clone3</b>()) in child memory when the child exits, and\ndo a wakeup on the futex at that address. The address\ninvolved may be changed by the <a href=\"https://man.page/2/set_tid_address\">set_tid_address(2)</a>\nsystem call. This is used by threading libraries.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_CHILD_SETTID</b>\n(since Linux 2.5.49)</p>\n\n<p style=\"margin-left:22%;\">Store the child thread ID at\nthe location pointed to by <i>child_tid</i> (<b>clone</b>())\nor <i>cl_args.child_tid</i> (<b>clone3</b>()) in the\nchild&rsquo;s memory. The store operation completes before\nthe clone call returns control to user space in the child\nprocess. (Note that the store operation may not have\ncompleted before the clone call returns in the parent\nprocess, which will be relevant if the <b>CLONE_VM</b> flag\nis also employed.)</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_CLEAR_SIGHAND</b>\n(since Linux 5.5)</p>\n\n<p style=\"margin-left:22%;\">By default, signal dispositions\nin the child thread are the same as in the parent. If this\nflag is specified, then all signals that are handled in the\nparent are reset to their default dispositions\n(<b>SIG_DFL</b>) in the child.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Specifying this\nflag together with <b>CLONE_SIGHAND</b> is nonsensical and\ndisallowed.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_DETACHED</b>\n(historical)</p>\n\n<p style=\"margin-left:22%;\">For a while (during the Linux\n2.5 development series) there was a <b>CLONE_DETACHED</b>\nflag, which caused the parent not to receive a signal when\nthe child terminated. Ultimately, the effect of this flag\nwas subsumed under the <b>CLONE_THREAD</b> flag and by the\ntime Linux 2.6.0 was released, this flag had no effect.\nStarting in Linux 2.6.2, the need to give this flag together\nwith <b>CLONE_THREAD</b> disappeared.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This flag is\nstill defined, but it is usually ignored when calling\n<b>clone</b>(). However, see the description of\n<b>CLONE_PIDFD</b> for some exceptions.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_FILES</b> (since Linux\n2.0)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_FILES</b> is set,\nthe calling process and the child process share the same\nfile descriptor table. Any file descriptor created by the\ncalling process or by the child process is also valid in the\nother process. Similarly, if one of the processes closes a\nfile descriptor, or changes its associated flags (using the\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_SETFD</b> operation), the other process\nis also affected. If a process sharing a file descriptor\ntable calls <a href=\"https://man.page/2/execve\">execve(2)</a>, its file descriptor table is\nduplicated (unshared).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_FILES</b> is not set, the child process inherits a\ncopy of all file descriptors opened in the calling process\nat the time of the clone call. Subsequent operations that\nopen or close file descriptors, or change file descriptor\nflags, performed by either the calling process or the child\nprocess do not affect the other process. Note, however, that\nthe duplicated file descriptors in the child refer to the\nsame open file descriptions as the corresponding file\ndescriptors in the calling process, and thus share file\noffsets and file status flags (see <a href=\"https://man.page/2/open\">open(2)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_FS</b> (since Linux\n2.0)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_FS</b> is set, the\ncaller and the child process share the same filesystem\ninformation. This includes the root of the filesystem, the\ncurrent working directory, and the umask. Any call to\n<a href=\"https://man.page/2/chroot\">chroot(2)</a>, <a href=\"https://man.page/2/chdir\">chdir(2)</a>, or <a href=\"https://man.page/2/umask\">umask(2)</a>\nperformed by the calling process or the child process also\naffects the other process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_FS</b> is not set, the child process works on a\ncopy of the filesystem information of the calling process at\nthe time of the clone call. Calls to <a href=\"https://man.page/2/chroot\">chroot(2)</a>,\n<a href=\"https://man.page/2/chdir\">chdir(2)</a>, or <a href=\"https://man.page/2/umask\">umask(2)</a> performed later by one\nof the processes do not affect the other process.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_INTO_CGROUP</b> (since\nLinux 5.7)</p>\n\n<p style=\"margin-left:22%;\">By default, a child process is\nplaced in the same version 2 cgroup as its parent. The\n<b>CLONE_INTO_CGROUP</b> flag allows the child process to be\ncreated in a different version 2 cgroup. (Note that\n<b>CLONE_INTO_CGROUP</b> has effect only for version 2\ncgroups.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In order to\nplace the child process in a different cgroup, the caller\nspecifies <b>CLONE_INTO_CGROUP</b> in <i>cl_args.flags</i>\nand passes a file descriptor that refers to a version 2\ncgroup in the <i>cl_args.cgroup</i> field. (This file\ndescriptor can be obtained by opening a cgroup v2 directory\nusing either the <b>O_RDONLY</b> or the <b>O_PATH</b> flag.)\nNote that all of the usual restrictions (described in\n<a href=\"https://man.page/7/cgroups\">cgroups(7)</a>) on placing a process into a version 2\ncgroup apply.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Among the\npossible use cases for <b>CLONE_INTO_CGROUP</b> are the\nfollowing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>Spawning a process into a cgroup different from the\nparent&rsquo;s cgroup makes it possible for a service\nmanager to directly spawn new services into dedicated\ncgroups. This eliminates the accounting jitter that would be\ncaused if the child process was first created in the same\ncgroup as the parent and then moved into the target cgroup.\nFurthermore, spawning the child process directly into a\ntarget cgroup is significantly cheaper than moving the child\nprocess into the target cgroup after it has been\ncreated.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The <b>CLONE_INTO_CGROUP</b> flag also allows the\ncreation of frozen child processes by spawning them into a\nfrozen cgroup. (See <a href=\"https://man.page/7/cgroups\">cgroups(7)</a> for a description of\nthe freezer controller.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>For threaded applications (or even thread\nimplementations which make use of cgroups to limit\nindividual threads), it is possible to establish a fixed\ncgroup layout before spawning each thread directly into its\ntarget cgroup.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>CLONE_IO</b> (since Linux\n2.6.25)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_IO</b> is set, then\nthe new process shares an I/O context with the calling\nprocess. If this flag is not set, then (as with\n<a href=\"https://man.page/2/fork\">fork(2)</a>) the new process has its own I/O context.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The I/O context\nis the I/O scope of the disk scheduler (i.e., what the I/O\nscheduler uses to model scheduling of a process&rsquo;s\nI/O). If processes share the same I/O context, they are\ntreated as one by the I/O scheduler. As a consequence, they\nget to share disk time. For some I/O schedulers, if two\nprocesses share an I/O context, they will be allowed to\ninterleave their disk access. If several threads are doing\nI/O on behalf of the same process (<a href=\"https://man.page/3/aio_read\">aio_read(3)</a>, for\ninstance), they should employ <b>CLONE_IO</b> to get better\nI/O performance.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the kernel\nis not configured with the <b>CONFIG_BLOCK</b> option, this\nflag is a no-op.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_NEWCGROUP</b> (since\nLinux 4.6)</p>\n\n<p style=\"margin-left:22%;\">Create the process in a new\ncgroup namespace. If this flag is not set, then (as with\n<a href=\"https://man.page/2/fork\">fork(2)</a>) the process is created in the same cgroup\nnamespaces as the calling process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ninformation on cgroup namespaces, see\n<a href=\"https://man.page/7/cgroup_namespaces\">cgroup_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Only a\nprivileged process (<b>CAP_SYS_ADMIN</b>) can employ\n<b>CLONE_NEWCGROUP</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_NEWIPC</b> (since\nLinux 2.6.19)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_NEWIPC</b> is set,\nthen create the process in a new IPC namespace. If this flag\nis not set, then (as with <a href=\"https://man.page/2/fork\">fork(2)</a>), the process is\ncreated in the same IPC namespace as the calling\nprocess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ninformation on IPC namespaces, see\n<a href=\"https://man.page/7/ipc_namespaces\">ipc_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Only a\nprivileged process (<b>CAP_SYS_ADMIN</b>) can employ\n<b>CLONE_NEWIPC</b>. This flag can&rsquo;t be specified in\nconjunction with <b>CLONE_SYSVSEM</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_NEWNET</b> (since\nLinux 2.6.24)</p>\n\n<p style=\"margin-left:22%;\">(The implementation of this\nflag was completed only by about kernel version 2.6.29.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_NEWNET</b> is set, then create the process in a new\nnetwork namespace. If this flag is not set, then (as with\n<a href=\"https://man.page/2/fork\">fork(2)</a>) the process is created in the same network\nnamespace as the calling process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ninformation on network namespaces, see\n<a href=\"https://man.page/7/network_namespaces\">network_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Only a\nprivileged process (<b>CAP_SYS_ADMIN</b>) can employ\n<b>CLONE_NEWNET</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_NEWNS</b> (since Linux\n2.4.19)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_NEWNS</b> is set,\nthe cloned child is started in a new mount namespace,\ninitialized with a copy of the namespace of the parent. If\n<b>CLONE_NEWNS</b> is not set, the child lives in the same\nmount namespace as the parent.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ninformation on mount namespaces, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>\nand <a href=\"https://man.page/7/mount_namespaces\">mount_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Only a\nprivileged process (<b>CAP_SYS_ADMIN</b>) can employ\n<b>CLONE_NEWNS</b>. It is not permitted to specify both\n<b>CLONE_NEWNS</b> and <b>CLONE_FS</b> in the same clone\ncall.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_NEWPID</b> (since\nLinux 2.6.24)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_NEWPID</b> is set,\nthen create the process in a new PID namespace. If this flag\nis not set, then (as with <a href=\"https://man.page/2/fork\">fork(2)</a>) the process is\ncreated in the same PID namespace as the calling\nprocess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ninformation on PID namespaces, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a> and\n<a href=\"https://man.page/7/pid_namespaces\">pid_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Only a\nprivileged process (<b>CAP_SYS_ADMIN</b>) can employ\n<b>CLONE_NEWPID</b>. This flag can&rsquo;t be specified in\nconjunction with <b>CLONE_THREAD</b> or\n<b>CLONE_PARENT</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_NEWUSER</b></p>\n\n<p style=\"margin-left:22%;\">(This flag first became\nmeaningful for <b>clone</b>() in Linux 2.6.23, the current\n<b>clone</b>() semantics were merged in Linux 3.5, and the\nfinal pieces to make the user namespaces completely usable\nwere merged in Linux 3.8.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_NEWUSER</b> is set, then create the process in a\nnew user namespace. If this flag is not set, then (as with\n<a href=\"https://man.page/2/fork\">fork(2)</a>) the process is created in the same user\nnamespace as the calling process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ninformation on user namespaces, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a> and\n<a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Before Linux\n3.8, use of <b>CLONE_NEWUSER</b> required that the caller\nhave three capabilities: <b>CAP_SYS_ADMIN</b>,\n<b>CAP_SETUID</b>, and <b>CAP_SETGID</b>. Starting with\nLinux 3.8, no privileges are needed to create a user\nnamespace.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This flag\ncan&rsquo;t be specified in conjunction with\n<b>CLONE_THREAD</b> or <b>CLONE_PARENT</b>. For security\nreasons, <b>CLONE_NEWUSER</b> cannot be specified in\nconjunction with <b>CLONE_FS</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_NEWUTS</b> (since\nLinux 2.6.19)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_NEWUTS</b> is set,\nthen create the process in a new UTS namespace, whose\nidentifiers are initialized by duplicating the identifiers\nfrom the UTS namespace of the calling process. If this flag\nis not set, then (as with <a href=\"https://man.page/2/fork\">fork(2)</a>) the process is\ncreated in the same UTS namespace as the calling\nprocess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ninformation on UTS namespaces, see\n<a href=\"https://man.page/7/uts_namespaces\">uts_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Only a\nprivileged process (<b>CAP_SYS_ADMIN</b>) can employ\n<b>CLONE_NEWUTS</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_PARENT</b> (since\nLinux 2.3.12)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_PARENT</b> is set,\nthen the parent of the new child (as returned by\n<a href=\"https://man.page/2/getppid\">getppid(2)</a>) will be the same as that of the calling\nprocess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_PARENT</b> is not set, then (as with\n<a href=\"https://man.page/2/fork\">fork(2)</a>) the child&rsquo;s parent is the calling\nprocess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note that it is\nthe parent process, as returned by <a href=\"https://man.page/2/getppid\">getppid(2)</a>, which\nis signaled when the child terminates, so that if\n<b>CLONE_PARENT</b> is set, then the parent of the calling\nprocess, rather than the calling process itself, will be\nsignaled.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>CLONE_PARENT</b> flag can&rsquo;t be used in clone calls\nby the global init process (PID 1 in the initial PID\nnamespace) and init processes in other PID namespaces. This\nrestriction prevents the creation of multi-rooted process\ntrees as well as the creation of unreapable zombies in the\ninitial PID namespace.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_PARENT_SETTID</b>\n(since Linux 2.5.49)</p>\n\n<p style=\"margin-left:22%;\">Store the child thread ID at\nthe location pointed to by <i>parent_tid</i>\n(<b>clone</b>()) or <i>cl_args.parent_tid</i>\n(<b>clone3</b>()) in the parent&rsquo;s memory. (In Linux\n2.5.32-2.5.48 there was a flag <b>CLONE_SETTID</b> that did\nthis.) The store operation completes before the clone call\nreturns control to user space.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_PID</b> (Linux 2.0 to\n2.5.15)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_PID</b> is set, the\nchild process is created with the same process ID as the\ncalling process. This is good for hacking the system, but\notherwise of not much use. From Linux 2.3.21 onward, this\nflag could be specified only by the system boot process (PID\n0). The flag disappeared completely from the kernel sources\nin Linux 2.5.16. Subsequently, the kernel silently ignored\nthis bit if it was specified in the <i>flags</i> mask. Much\nlater, the same bit was recycled for use as the\n<b>CLONE_PIDFD</b> flag.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_PIDFD</b> (since Linux\n5.2)</p>\n\n<p style=\"margin-left:22%;\">If this flag is specified, a\nPID file descriptor referring to the child process is\nallocated and placed at a specified location in the\nparent&rsquo;s memory. The close-on-exec flag is set on this\nnew file descriptor. PID file descriptors can be used for\nthe purposes described in <a href=\"https://man.page/2/pidfd_open\">pidfd_open(2)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>When using <b>clone3</b>(), the PID file descriptor is\nplaced at the location pointed to by\n<i>cl_args.pidfd</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>When using <b>clone</b>(), the PID file descriptor is\nplaced at the location pointed to by <i>parent_tid</i>.\nSince the <i>parent_tid</i> argument is used to return the\nPID file descriptor, <b>CLONE_PIDFD</b> cannot be used with\n<b>CLONE_PARENT_SETTID</b> when calling <b>clone</b>().</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">It is currently\nnot possible to use this flag together with\n<b>CLONE_THREAD.</b> This means that the process identified\nby the PID file descriptor will always be a thread group\nleader.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the obsolete\n<b>CLONE_DETACHED</b> flag is specified alongside\n<b>CLONE_PIDFD</b> when calling <b>clone</b>(), an error is\nreturned. An error also results if <b>CLONE_DETACHED</b> is\nspecified when calling <b>clone3</b>(). This error behavior\nensures that the bit corresponding to <b>CLONE_DETACHED</b>\ncan be reused for further PID file descriptor features in\nthe future.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_PTRACE</b> (since\nLinux 2.2)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_PTRACE</b> is\nspecified, and the calling process is being traced, then\ntrace the child also (see <a href=\"https://man.page/2/ptrace\">ptrace(2)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_SETTLS</b> (since\nLinux 2.5.32)</p>\n\n<p style=\"margin-left:22%;\">The TLS (Thread Local Storage)\ndescriptor is set to <i>tls</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\ninterpretation of <i>tls</i> and the resulting effect is\narchitecture dependent. On x86, <i>tls</i> is interpreted as\na <i>struct user_desc&nbsp;*</i> (see\n<a href=\"https://man.page/2/set_thread_area\">set_thread_area(2)</a>). On x86-64 it is the new value to\nbe set for the %fs base register (see the <b>ARCH_SET_FS</b>\nargument to <a href=\"https://man.page/2/arch_prctl\">arch_prctl(2)</a>). On architectures with a\ndedicated TLS register, it is the new value of that\nregister.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Use of this\nflag requires detailed knowledge and generally it should not\nbe used except in libraries implementing threading.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_SIGHAND</b> (since\nLinux 2.0)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_SIGHAND</b> is set,\nthe calling process and the child process share the same\ntable of signal handlers. If the calling process or child\nprocess calls <a href=\"https://man.page/2/sigaction\">sigaction(2)</a> to change the behavior\nassociated with a signal, the behavior is changed in the\nother process as well. However, the calling process and\nchild processes still have distinct signal masks and sets of\npending signals. So, one of them may block or unblock\nsignals using <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a> without affecting the\nother process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_SIGHAND</b> is not set, the child process inherits\na copy of the signal handlers of the calling process at the\ntime of the clone call. Calls to <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>\nperformed later by one of the processes have no effect on\nthe other process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux\n2.6.0, the <i>flags</i> mask must also include\n<b>CLONE_VM</b> if <b>CLONE_SIGHAND</b> is specified</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_STOPPED</b> (since\nLinux 2.6.0)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_STOPPED</b> is set,\nthen the child is initially stopped (as though it was sent a\n<b>SIGSTOP</b> signal), and must be resumed by sending it a\n<b>SIGCONT</b> signal.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This flag was\n<i>deprecated</i> from Linux 2.6.25 onward, and was\n<i>removed</i> altogether in Linux 2.6.38. Since then, the\nkernel silently ignores it without error. Starting with\nLinux 4.6, the same bit was reused for the\n<b>CLONE_NEWCGROUP</b> flag.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_SYSVSEM</b> (since\nLinux 2.5.10)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_SYSVSEM</b> is set,\nthen the child and the calling process share a single list\nof System V semaphore adjustment (<i>semadj</i>) values (see\n<a href=\"https://man.page/2/semop\">semop(2)</a>). In this case, the shared list accumulates\n<i>semadj</i> values across all processes sharing the list,\nand semaphore adjustments are performed only when the last\nprocess that is sharing the list terminates (or ceases\nsharing the list using <a href=\"https://man.page/2/unshare\">unshare(2)</a>). If this flag is\nnot set, then the child has a separate <i>semadj</i> list\nthat is initially empty.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_THREAD</b> (since\nLinux 2.4.0)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_THREAD</b> is set,\nthe child is placed in the same thread group as the calling\nprocess. To make the remainder of the discussion of\n<b>CLONE_THREAD</b> more readable, the term\n&quot;thread&quot; is used to refer to the processes within\na thread group.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Thread groups\nwere a feature added in Linux 2.4 to support the POSIX\nthreads notion of a set of threads that share a single PID.\nInternally, this shared PID is the so-called thread group\nidentifier (TGID) for the thread group. Since Linux 2.4,\ncalls to <a href=\"https://man.page/2/getpid\">getpid(2)</a> return the TGID of the caller.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The threads\nwithin a group can be distinguished by their (system-wide)\nunique thread IDs (TID). A new thread&rsquo;s TID is\navailable as the function result returned to the caller, and\na thread can obtain its own TID using <a href=\"https://man.page/2/gettid\">gettid(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">When a clone\ncall is made without specifying <b>CLONE_THREAD</b>, then\nthe resulting thread is placed in a new thread group whose\nTGID is the same as the thread&rsquo;s TID. This thread is\nthe <i>leader</i> of the new thread group.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A new thread\ncreated with <b>CLONE_THREAD</b> has the same parent process\nas the process that made the clone call (i.e., like\n<b>CLONE_PARENT</b>), so that calls to <a href=\"https://man.page/2/getppid\">getppid(2)</a>\nreturn the same value for all of the threads in a thread\ngroup. When a <b>CLONE_THREAD</b> thread terminates, the\nthread that created it is not sent a <b>SIGCHLD</b> (or\nother termination) signal; nor can the status of such a\nthread be obtained using <a href=\"https://man.page/2/wait\">wait(2)</a>. (The thread is said\nto be <i>detached</i>.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">After all of\nthe threads in a thread group terminate the parent process\nof the thread group is sent a <b>SIGCHLD</b> (or other\ntermination) signal.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If any of the\nthreads in a thread group performs an <a href=\"https://man.page/2/execve\">execve(2)</a>, then\nall threads other than the thread group leader are\nterminated, and the new program is executed in the thread\ngroup leader.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If one of the\nthreads in a thread group creates a child using\n<a href=\"https://man.page/2/fork\">fork(2)</a>, then any thread in the group can\n<a href=\"https://man.page/2/wait\">wait(2)</a> for that child.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux\n2.5.35, the <i>flags</i> mask must also include\n<b>CLONE_SIGHAND</b> if <b>CLONE_THREAD</b> is specified\n(and note that, since Linux 2.6.0, <b>CLONE_SIGHAND</b> also\nrequires <b>CLONE_VM</b> to be included).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Signal\ndispositions and actions are process-wide: if an unhandled\nsignal is delivered to a thread, then it will affect\n(terminate, stop, continue, be ignored in) all members of\nthe thread group.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Each thread has\nits own signal mask, as set by <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A signal may be\nprocess-directed or thread-directed. A process-directed\nsignal is targeted at a thread group (i.e., a TGID), and is\ndelivered to an arbitrarily selected thread from among those\nthat are not blocking the signal. A signal may be\nprocess-directed because it was generated by the kernel for\nreasons other than a hardware exception, or because it was\nsent using <a href=\"https://man.page/2/kill\">kill(2)</a> or <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>. A\nthread-directed signal is targeted at (i.e., delivered to) a\nspecific thread. A signal may be thread directed because it\nwas sent using <a href=\"https://man.page/2/tgkill\">tgkill(2)</a> or\n<a href=\"https://man.page/3/pthread_sigqueue\">pthread_sigqueue(3)</a>, or because the thread executed a\nmachine language instruction that triggered a hardware\nexception (e.g., invalid memory access triggering\n<b>SIGSEGV</b> or a floating-point exception triggering\n<b>SIGFPE</b>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A call to\n<a href=\"https://man.page/2/sigpending\">sigpending(2)</a> returns a signal set that is the union\nof the pending process-directed signals and the signals that\nare pending for the calling thread.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If a\nprocess-directed signal is delivered to a thread group, and\nthe thread group has installed a handler for the signal,\nthen the handler will be invoked in exactly one, arbitrarily\nselected member of the thread group that has not blocked the\nsignal. If multiple threads in a group are waiting to accept\nthe same signal using <a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>, the kernel will\narbitrarily select one of these threads to receive the\nsignal.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_UNTRACED</b> (since\nLinux 2.5.46)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_UNTRACED</b> is\nspecified, then a tracing process cannot force\n<b>CLONE_PTRACE</b> on this child process.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_VFORK</b> (since Linux\n2.2)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_VFORK</b> is set,\nthe execution of the calling process is suspended until the\nchild releases its virtual memory resources via a call to\n<a href=\"https://man.page/2/execve\">execve(2)</a> or <a href=\"https://man.page/2/_exit\">_exit(2)</a> (as with\n<a href=\"https://man.page/2/vfork\">vfork(2)</a>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_VFORK</b> is not set, then both the calling process\nand the child are schedulable after the call, and an\napplication should not rely on execution occurring in any\nparticular order.</p>\n\n<p style=\"margin-left:11%;\"><b>CLONE_VM</b> (since Linux\n2.0)</p>\n\n<p style=\"margin-left:22%;\">If <b>CLONE_VM</b> is set, the\ncalling process and the child process run in the same memory\nspace. In particular, memory writes performed by the calling\nprocess or by the child process are also visible in the\nother process. Moreover, any memory mapping or unmapping\nperformed with <a href=\"https://man.page/2/mmap\">mmap(2)</a> or <a href=\"https://man.page/2/munmap\">munmap(2)</a> by the\nchild or calling process also affects the other process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>CLONE_VM</b> is not set, the child process runs in a\nseparate copy of the memory space of the calling process at\nthe time of the clone call. Memory writes or file\nmappings/unmappings performed by one of the processes do not\naffect the other, as with <a href=\"https://man.page/2/fork\">fork(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the\n<b>CLONE_VM</b> flag is specified and the <b>CLONE_VM</b>\nflag is not specified, then any alternate signal stack that\nwas established by <a href=\"https://man.page/2/sigaltstack\">sigaltstack(2)</a> is cleared in the\nchild process.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success, the\nthread ID of the child process is returned in the\ncaller&rsquo;s thread of execution. On failure, -1 is\nreturned in the caller&rsquo;s context, no child process\nwill be created, and <i>errno</i> will be set\nappropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Too many processes are already\nrunning; see <a href=\"https://man.page/2/fork\">fork(2)</a>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EBUSY</b> (<b>clone3</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_INTO_CGROUP</b> was\nspecified in <i>cl_args.flags</i>, but the file descriptor\nspecified in <i>cl_args.cgroup</i> refers to a version 2\ncgroup in which a domain controller is enabled.</p>\n\n<p style=\"margin-left:11%;\"><b>EEXIST</b> (<b>clone3</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\">One (or more) of the PIDs\nspecified in <i>set_tid</i> already exists in the\ncorresponding PID namespace.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Both <b>CLONE_SIGHAND</b> and <b>CLONE_CLEAR_SIGHAND</b>\nwere specified in the <i>flags</i> mask.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_SIGHAND</b> was specified in the <i>flags</i>\nmask, but <b>CLONE_VM</b> was not. (Since Linux 2.6.0.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_THREAD</b> was specified in the <i>flags</i>\nmask, but <b>CLONE_SIGHAND</b> was not. (Since Linux\n2.5.35.)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_THREAD</b> was specified in the <i>flags</i>\nmask, but the current process previously called\n<a href=\"https://man.page/2/unshare\">unshare(2)</a> with the <b>CLONE_NEWPID</b> flag or used\n<a href=\"https://man.page/2/setns\">setns(2)</a> to reassociate itself with a PID\nnamespace.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Both <b>CLONE_FS</b> and <b>CLONE_NEWNS</b> were\nspecified in the <i>flags</i> mask.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (since Linux\n3.9)</p>\n\n<p style=\"margin-left:22%;\">Both <b>CLONE_NEWUSER</b> and\n<b>CLONE_FS</b> were specified in the <i>flags</i> mask.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Both <b>CLONE_NEWIPC</b> and <b>CLONE_SYSVSEM</b> were\nspecified in the <i>flags</i> mask.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>One (or both) of <b>CLONE_NEWPID</b> or\n<b>CLONE_NEWUSER</b> and one (or both) of\n<b>CLONE_THREAD</b> or <b>CLONE_PARENT</b> were specified in\nthe <i>flags</i> mask.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (since Linux\n2.6.32)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_PARENT</b> was\nspecified, and the caller is an init process.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned by the glibc <b>clone</b>() wrapper function\nwhen <i>fn</i> or <i>stack</i> is specified as NULL.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_NEWIPC</b> was specified in the <i>flags</i>\nmask, but the kernel was not configured with the\n<b>CONFIG_SYSVIPC</b> and <b>CONFIG_IPC_NS</b> options.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_NEWNET</b> was specified in the <i>flags</i>\nmask, but the kernel was not configured with the\n<b>CONFIG_NET_NS</b> option.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_NEWPID</b> was specified in the <i>flags</i>\nmask, but the kernel was not configured with the\n<b>CONFIG_PID_NS</b> option.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_NEWUSER</b> was specified in the <i>flags</i>\nmask, but the kernel was not configured with the\n<b>CONFIG_USER_NS</b> option.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_NEWUTS</b> was specified in the <i>flags</i>\nmask, but the kernel was not configured with the\n<b>CONFIG_UTS_NS</b> option.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>stack</i> is not aligned to a suitable boundary for\nthis architecture. For example, on aarch64, <i>stack</i>\nmust be a multiple of 16.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (<b>clone3</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_DETACHED</b> was\nspecified in the <i>flags</i> mask.</p>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (<b>clone</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_PIDFD</b> was\nspecified together with <b>CLONE_DETACHED</b> in the\n<i>flags</i> mask.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_PIDFD</b> was specified together with\n<b>CLONE_THREAD</b> in the <i>flags</i> mask.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (<b>clone</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_PIDFD</b> was\nspecified together with <b>CLONE_PARENT_SETTID</b> in the\n<i>flags</i> mask.</p>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (<b>clone3</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\"><i>set_tid_size</i> is greater\nthan the number of nested PID namespaces.</p>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (<b>clone3</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\">One of the PIDs specified in\n<i>set_tid</i> was an invalid.</p>\n\n<p style=\"margin-left:11%;\"><b>EINVAL</b> (AArch64 only,\nLinux 4.6 and earlier)</p>\n\n<p style=\"margin-left:22%;\"><i>stack</i> was not aligned to\na 126-bit boundary.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Cannot allocate sufficient memory to allocate a task\nstructure for the child, or to copy those parts of the\ncaller&rsquo;s context that need to be copied.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOSPC</b> (since Linux\n3.7)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_NEWPID</b> was\nspecified in the <i>flags</i> mask, but the limit on the\nnesting depth of PID namespaces would have been exceeded;\nsee <a href=\"https://man.page/7/pid_namespaces\">pid_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>ENOSPC</b> (since Linux 4.9;\nbeforehand <b>EUSERS</b>)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_NEWUSER</b> was\nspecified in the <i>flags</i> mask, and the call would cause\nthe limit on the number of nested user namespaces to be\nexceeded. See <a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">From Linux 3.11\nto Linux 4.8, the error diagnosed in this case was\n<b>EUSERS</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>ENOSPC</b> (since Linux\n4.9)</p>\n\n<p style=\"margin-left:22%;\">One of the values in the\n<i>flags</i> mask specified the creation of a new user\nnamespace, but doing so would have caused the limit defined\nby the corresponding file in <i>/proc/sys/user</i> to be\nexceeded. For further details, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>EOPNOTSUPP</b>\n(<b>clone3</b>() only)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_INTO_CGROUP</b> was\nspecified in <i>cl_args.flags</i>, but the file descriptor\nspecified in <i>cl_args.cgroup</i> refers to a version 2\ncgroup that is in the <i>domain invalid</i> state.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_NEWCGROUP</b>, <b>CLONE_NEWIPC</b>,\n<b>CLONE_NEWNET</b>, <b>CLONE_NEWNS</b>,\n<b>CLONE_NEWPID</b>, or <b>CLONE_NEWUTS</b> was specified by\nan unprivileged process (process without\n<b>CAP_SYS_ADMIN</b>).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_PID</b> was specified by a process other than\nprocess 0. (This error occurs only on Linux 2.5.15 and\nearlier.)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><b>CLONE_NEWUSER</b> was specified in the <i>flags</i>\nmask, but either the effective user ID or the effective\ngroup ID of the caller does not have a mapping in the parent\nnamespace (see <a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a>).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EPERM</b> (since Linux\n3.9)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_NEWUSER</b> was\nspecified in the <i>flags</i> mask and the caller is in a\nchroot environment (i.e., the caller&rsquo;s root directory\ndoes not match the root directory of the mount namespace in\nwhich it resides).</p>\n\n<p style=\"margin-left:11%;\"><b>EPERM</b> (<b>clone3</b>()\nonly)</p>\n\n<p style=\"margin-left:22%;\"><i>set_tid_size</i> was greater\nthan zero, and the caller lacks the <b>CAP_SYS_ADMIN</b>\ncapability in one or more of the user namespaces that own\nthe corresponding PID namespaces.</p>\n\n<p style=\"margin-left:11%;\"><b>ERESTARTNOINTR</b> (since\nLinux 2.6.17)</p>\n\n<p style=\"margin-left:22%;\">System call was interrupted by\na signal and will be restarted. (This can be seen only\nduring a trace.)</p>\n\n<p style=\"margin-left:11%;\"><b>EUSERS</b> (Linux 3.11 to\nLinux 4.8)</p>\n\n<p style=\"margin-left:22%;\"><b>CLONE_NEWUSER</b> was\nspecified in the <i>flags</i> mask, and the limit on the\nnumber of nested user namespaces would be exceeded. See the\ndiscussion of the <b>ENOSPC</b> error above.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>clone3</b>() system call first appeared in Linux 5.3.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls are Linux-specific and should not be used in programs\nintended to be portable.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">One use of\nthese systems calls is to implement threads: multiple flows\nof control in a program that run concurrently in a shared\naddress space.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glibc does not\nprovide a wrapper for <b>clone3</b>(); call it using\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nglibc <b>clone</b>() wrapper function makes some changes in\nthe memory pointed to by <i>stack</i> (changes required to\nset the stack up correctly for the child) <i>before</i>\ninvoking the <b>clone</b>() system call. So, in cases where\n<b>clone</b>() is used to recursively create children, do\nnot use the buffer employed for the parent&rsquo;s stack as\nthe stack of the child.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/kcmp\">kcmp(2)</a> system call can be used to test whether two\nprocesses share various resources such as a file descriptor\ntable, System V semaphore undo operations, or a virtual\naddress space.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Handlers\nregistered using <a href=\"https://man.page/3/pthread_atfork\">pthread_atfork(3)</a> are not executed\nduring a clone call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the Linux\n2.4.x series, <b>CLONE_THREAD</b> generally does not make\nthe parent of the new thread the same as the parent of the\ncalling process. However, for kernel versions 2.4.7 to\n2.4.18 the <b>CLONE_THREAD</b> flag implied the\n<b>CLONE_PARENT</b> flag (as in Linux 2.6.0 and later).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On i386,\n<b>clone</b>() should not be called through vsyscall, but\ndirectly through <i>int $0x80</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nThe raw <b>clone</b>() system call corresponds more closely\nto <a href=\"https://man.page/2/fork\">fork(2)</a> in that execution in the child continues\nfrom the point of the call. As such, the <i>fn</i> and\n<i>arg</i> arguments of the <b>clone</b>() wrapper function\nare omitted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In contrast to\nthe glibc wrapper, the raw <b>clone</b>() system call\naccepts NULL as a <i>stack</i> argument (and <b>clone3</b>()\nlikewise allows <i>cl_args.stack</i> to be NULL). In this\ncase, the child uses a duplicate of the parent&rsquo;s\nstack. (Copy-on-write semantics ensure that the child gets\nseparate copies of stack pages when either process modifies\nthe stack.) In this case, for correct operation, the\n<b>CLONE_VM</b> option should not be specified. (If the\nchild <i>shares</i> the parent&rsquo;s memory because of the\nuse of the <b>CLONE_VM</b> flag, then no copy-on-write\nduplication occurs and chaos is likely to result.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The order of\nthe arguments also differs in the raw system call, and there\nare variations in the arguments across architectures, as\ndetailed in the following paragraphs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The raw system\ncall interface on x86-64 and some other architectures\n(including sh, tile, and alpha) is:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>long\nclone(unsigned long</b> <i>flags</i><b>, void\n*</b><i>stack</i><b>, <br>\nint *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,\n<br>\nunsigned long</b> <i>tls</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On x86-32, and\nseveral other common architectures (including score, ARM,\nARM 64, PA-RISC, arc, Power PC, xtensa, and MIPS), the order\nof the last two arguments is reversed:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>long\nclone(unsigned long</b> <i>flags</i><b>, void\n*</b><i>stack</i><b>, <br>\nint *</b><i>parent_tid</i><b>, unsigned long</b>\n<i>tls</i><b>, <br>\nint *</b><i>child_tid</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On the cris and\ns390 architectures, the order of the first two arguments is\nreversed:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>long\nclone(void *</b><i>stack</i><b>, unsigned long</b>\n<i>flags</i><b>, <br>\nint *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,\n<br>\nunsigned long</b> <i>tls</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On the\nmicroblaze architecture, an additional argument is\nsupplied:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>long\nclone(unsigned long</b> <i>flags</i><b>, void\n*</b><i>stack</i><b>, <br>\nint</b> <i>stack_size</i><b>,</b> /* Size of stack */\n<b><br>\nint *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,\n<br>\nunsigned long</b> <i>tls</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>blackfin,\nm68k, and sparc</b> <br>\nThe argument-passing conventions on blackfin, m68k, and\nsparc are different from the descriptions above. For\ndetails, see the kernel (and glibc) source.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ia64</b>\n<br>\nOn ia64, a different interface is used:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>int\n__clone2(int (*</b><i>fn</i><b>)(void *), <br>\nvoid *</b><i>stack_base</i><b>, size_t</b>\n<i>stack_size</i><b>, <br>\nint</b> <i>flags</i><b>, void *</b><i>arg</i><b>, ... <br>\n/* pid_t *</b><i>parent_tid</i><b>, struct user_desc\n*</b><i>tls</i><b>, <br>\npid_t *</b><i>child_tid</i> <b>*/ );</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The prototype\nshown above is for the glibc wrapper function; for the\nsystem call itself, the prototype can be described as\nfollows (it is identical to the <b>clone</b>() prototype on\nmicroblaze):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>long\nclone2(unsigned long</b> <i>flags</i><b>, void\n*</b><i>stack_base</i><b>, <br>\nint</b> <i>stack_size</i><b>,</b> /* Size of stack */\n<b><br>\nint *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,\n<br>\nunsigned long</b> <i>tls</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>__clone2</b>()\noperates in the same way as <b>clone</b>(), except that\n<i>stack_base</i> points to the lowest address of the\nchild&rsquo;s stack area, and <i>stack_size</i> specifies\nthe size of the stack pointed to by <i>stack_base</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Linux 2.4\nand earlier</b> <br>\nIn Linux 2.4 and earlier, <b>clone</b>() does not take\narguments <i>parent_tid</i>, <i>tls</i>, and\n<i>child_tid</i>.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">GNU C library\nversions 2.3.4 up to and including 2.24 contained a wrapper\nfunction for <a href=\"https://man.page/2/getpid\">getpid(2)</a> that performed caching of\nPIDs. This caching relied on support in the glibc wrapper\nfor <b>clone</b>(), but limitations in the implementation\nmeant that the cache was not up to date in some\ncircumstances. In particular, if a signal was delivered to\nthe child immediately after the <b>clone</b>() call, then a\ncall to <a href=\"https://man.page/2/getpid\">getpid(2)</a> in a handler for the signal could\nreturn the PID of the calling process (&quot;the\nparent&quot;), if the clone wrapper had not yet had a chance\nto update the PID cache in the child. (This discussion\nignores the case where the child was created using\n<b>CLONE_THREAD</b>, when <a href=\"https://man.page/2/getpid\">getpid(2)</a> <i>should</i>\nreturn the same value in the child and in the process that\ncalled <b>clone</b>(), since the caller and the child are in\nthe same thread group. The stale-cache problem also does not\noccur if the <i>flags</i> argument includes\n<b>CLONE_VM</b>.) To get the truth, it was sometimes\nnecessary to use code such as the following:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#include\n&lt;syscall.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">pid_t\nmypid;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mypid =\nsyscall(SYS_getpid);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because of the\nstale-cache problem, as well as other problems noted in\n<a href=\"https://man.page/2/getpid\">getpid(2)</a>, the PID caching feature was removed in\nglibc 2.25.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram demonstrates the use of <b>clone</b>() to create a\nchild process that executes in a separate UTS namespace. The\nchild changes the hostname in its UTS namespace. Both parent\nand child then display the system hostname, making it\npossible to see that the hostname differs in the UTS\nnamespaces of the parent and child. For an example of the\nuse of this program, see <a href=\"https://man.page/2/setns\">setns(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Within the\nsample program, we allocate the memory that is to be used\nfor the child&rsquo;s stack using <a href=\"https://man.page/2/mmap\">mmap(2)</a> rather than\n<a href=\"https://man.page/3/malloc\">malloc(3)</a> for the following reasons:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/mmap\">mmap(2)</a> allocates a block of memory that starts\non a page boundary and is a multiple of the page size. This\nis useful if we want to establish a guard page (a page with\nprotection <b>PROT_NONE</b>) at the end of the stack using\n<a href=\"https://man.page/2/mprotect\">mprotect(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>We can specify the <b>MAP_STACK</b> flag to request a\nmapping that is suitable for a stack. For the moment, this\nflag is a no-op on Linux, but it exists and has effect on\nsome other systems, so we should include it for\nportability.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;sys/wait.h&gt; <br>\n#include &lt;sys/utsname.h&gt; <br>\n#include &lt;sched.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/mman.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int /*\nStart function for cloned child */ <br>\nchildFunc(void *arg) <br>\n{ <br>\nstruct utsname uts;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Change\nhostname in UTS namespace of child */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(sethostname(arg, strlen(arg)) == -1) <br>\nerrExit(&quot;sethostname&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Retrieve and\ndisplay hostname */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(uname(&amp;uts) == -1) <br>\nerrExit(&quot;uname&quot;); <br>\nprintf(&quot;uts.nodename in child: %s\\n&quot;,\nuts.nodename);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Keep the\nnamespace open for a while, by sleeping. <br>\nThis allows some experimentation--for example, another <br>\nprocess might join the namespace. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sleep(200);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return 0; /*\nChild terminates now */ <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nSTACK_SIZE (1024 * 1024) /* Stack size for cloned child\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nchar *stack; /* Start of stack buffer */ <br>\nchar *stackTop; /* End of stack buffer */ <br>\npid_t pid; <br>\nstruct utsname uts;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s\n&lt;child-hostname&gt;\\n&quot;, argv[0]); <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Allocate\nmemory to be used for the stack of the child */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">stack =\nmmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, <br>\nMAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0); <br>\nif (stack == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">stackTop =\nstack + STACK_SIZE; /* Assume stack grows downward */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create child\nthat has its own UTS namespace; <br>\nchild commences execution in childFunc() */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pid =\nclone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n<br>\nif (pid == -1) <br>\nerrExit(&quot;clone&quot;); <br>\nprintf(&quot;clone() returned %jd\\n&quot;, (intmax_t)\npid);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Parent falls\nthrough to here */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sleep(1); /*\nGive child time to change its hostname */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Display\nhostname in parent's UTS namespace. This will be <br>\ndifferent from hostname in child's UTS namespace. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(uname(&amp;uts) == -1) <br>\nerrExit(&quot;uname&quot;); <br>\nprintf(&quot;uts.nodename in parent: %s\\n&quot;,\nuts.nodename);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(waitpid(pid, NULL, 0) == -1) /* Wait for child */ <br>\nerrExit(&quot;waitpid&quot;); <br>\nprintf(&quot;child has terminated\\n&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/fork\">fork(2)</a>,\n<a href=\"https://man.page/2/futex\">futex(2)</a>, <a href=\"https://man.page/2/getpid\">getpid(2)</a>, <a href=\"https://man.page/2/gettid\">gettid(2)</a>,\n<a href=\"https://man.page/2/kcmp\">kcmp(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/pidfd_open\">pidfd_open(2)</a>,\n<a href=\"https://man.page/2/set_thread_area\">set_thread_area(2)</a>, <a href=\"https://man.page/2/set_tid_address\">set_tid_address(2)</a>,\n<a href=\"https://man.page/2/setns\">setns(2)</a>, <a href=\"https://man.page/2/tkill\">tkill(2)</a>, <a href=\"https://man.page/2/unshare\">unshare(2)</a>,\n<a href=\"https://man.page/2/wait\">wait(2)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/namespaces\">namespaces(7)</a>, <a href=\"https://man.page/7/pthreads\">pthreads(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}