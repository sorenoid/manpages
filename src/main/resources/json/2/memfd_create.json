{"name":"memfd_create","description":"memfd_create - create an anonymous file","body":"\n\n<h1 align=\"center\">MEMFD_CREATE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memfd_create -\ncreate an anonymous file</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;sys/mman.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nmemfd_create(const char *</b><i>name</i><b>, unsigned\nint</b> <i>flags</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>memfd_create</b>()\ncreates an anonymous file and returns a file descriptor that\nrefers to it. The file behaves like a regular file, and so\ncan be modified, truncated, memory-mapped, and so on.\nHowever, unlike a regular file, it lives in RAM and has a\nvolatile backing storage. Once all references to the file\nare dropped, it is automatically released. Anonymous memory\nis used for all backing pages of the file. Therefore, files\ncreated by <b>memfd_create</b>() have the same semantics as\nother anonymous memory allocations such as those allocated\nusing <a href=\"https://man.page/2/mmap\">mmap(2)</a> with the <b>MAP_ANONYMOUS</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The initial\nsize of the file is set to 0. Following the call, the file\nsize should be set using <a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>.\n(Alternatively, the file may be populated by calls to\n<a href=\"https://man.page/2/write\">write(2)</a> or similar.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The name\nsupplied in <i>name</i> is used as a filename and will be\ndisplayed as the target of the corresponding symbolic link\nin the directory <i>/proc/self/fd/</i>. The displayed name\nis always prefixed with <i>memfd:</i> and serves only for\ndebugging purposes. Names do not affect the behavior of the\nfile descriptor, and as such multiple files can have the\nsame name without any side effects.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nvalues may be bitwise ORed in <i>flags</i> to change the\nbehavior of <b>memfd_create</b>(): <b><br>\nMFD_CLOEXEC</b></p>\n\n<p style=\"margin-left:22%;\">Set the close-on-exec\n(<b>FD_CLOEXEC</b>) flag on the new file descriptor. See the\ndescription of the <b>O_CLOEXEC</b> flag in <a href=\"https://man.page/2/open\">open(2)</a>\nfor reasons why this may be useful.</p>\n\n<p style=\"margin-left:11%;\"><b>MFD_ALLOW_SEALING</b></p>\n\n<p style=\"margin-left:22%;\">Allow sealing operations on\nthis file. See the discussion of the <b>F_ADD_SEALS</b> and\n<b>F_GET_SEALS</b> operations in <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, and also\nNOTES, below. The initial set of seals is empty. If this\nflag is not set, the initial set of seals will be\n<b>F_SEAL_SEAL</b>, meaning that no other seals can be set\non the file.</p>\n\n<p style=\"margin-left:11%;\"><b>MFD_HUGETLB</b> (since Linux\n4.14)</p>\n\n<p style=\"margin-left:22%;\">The anonymous file will be\ncreated in the hugetlbfs filesystem using huge pages. See\nthe Linux kernel source file\n<i>Documentation/admin-guide/mm/hugetlbpage.rst</i> for more\ninformation about hugetlbfs. Specifying both\n<b>MFD_HUGETLB</b> and <b>MFD_ALLOW_SEALING</b> in\n<i>flags</i> is supported since Linux 4.16.</p>\n\n<p style=\"margin-left:11%;\"><b>MFD_HUGE_2MB</b>,\n<b>MFD_HUGE_1GB</b>, <b>...</b></p>\n\n<p style=\"margin-left:22%;\">Used in conjunction with\n<b>MFD_HUGETLB</b> to select alternative hugetlb page sizes\n(respectively, 2&nbsp;MB, 1&nbsp;GB, ...) on systems that\nsupport multiple hugetlb page sizes. Definitions for known\nhuge page sizes are included in the header file\n<i>&lt;linux/memfd.h&gt;.</i></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For details on\nencoding huge page sizes not included in the header file,\nsee the discussion of the similarly named constants in\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Unused bits in\n<i>flags</i> must be 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As its return\nvalue, <b>memfd_create</b>() returns a new file descriptor\nthat can be used to refer to the file. This file descriptor\nis opened for both reading and writing (<b>O_RDWR</b>) and\n<b>O_LARGEFILE</b> is set for the file descriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With respect to\n<a href=\"https://man.page/2/fork\">fork(2)</a> and <a href=\"https://man.page/2/execve\">execve(2)</a>, the usual semantics\napply for the file descriptor created by\n<b>memfd_create</b>(). A copy of the file descriptor is\ninherited by the child produced by <a href=\"https://man.page/2/fork\">fork(2)</a> and refers\nto the same file. The file descriptor is preserved across\n<a href=\"https://man.page/2/execve\">execve(2)</a>, unless the close-on-exec flag has been\nset.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>memfd_create</b>() returns a new file descriptor. On\nerror, -1 is returned and <i>errno</i> is set to indicate\nthe error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The address in <i>name</i>\npoints to invalid memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>flags</i> included unknown bits.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>name</i> was too long. (The limit is 249 bytes,\nexcluding the terminating null byte.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Both <b>MFD_HUGETLB</b> and <b>MFD_ALLOW_SEALING</b>\nwere specified in <i>flags</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The per-process limit on the number of open file\ndescriptors has been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The system-wide limit on the total number of open files\nhas been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>There was insufficient memory to create a new anonymous\nfile.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>memfd_create</b>() system call first appeared in Linux\n3.17; glibc support was added in version 2.27.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>memfd_create</b>() system call is Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>memfd_create</b>() system call provides a simple\nalternative to manually mounting a <a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a>\nfilesystem and creating and opening a file in that\nfilesystem. The primary purpose of <b>memfd_create</b>() is\nto create files and associated file descriptors that are\nused with the file-sealing APIs provided by\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>memfd_create</b>() system call also has uses without file\nsealing (which is why file-sealing is disabled, unless\nexplicitly requested with the <b>MFD_ALLOW_SEALING</b>\nflag). In particular, it can be used as an alternative to\ncreating files in <i>tmp</i> or as an alternative to using\nthe <a href=\"https://man.page/2/open\">open(2)</a> <b>O_TMPFILE</b> in cases where there is\nno intention to actually link the resulting file into the\nfilesystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File\nsealing</b> <br>\nIn the absence of file sealing, processes that communicate\nvia shared memory must either trust each other, or take\nmeasures to deal with the possibility that an untrusted peer\nmay manipulate the shared memory region in problematic ways.\nFor example, an untrusted peer might modify the contents of\nthe shared memory at any time, or shrink the shared memory\nregion. The former possibility leaves the local process\nvulnerable to time-of-check-to-time-of-use race conditions\n(typically dealt with by copying data from the shared memory\nregion before checking and using it). The latter possibility\nleaves the local process vulnerable to <b>SIGBUS</b> signals\nwhen an attempt is made to access a now-nonexistent location\nin the shared memory region. (Dealing with this possibility\nnecessitates the use of a handler for the <b>SIGBUS</b>\nsignal.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Dealing with\nuntrusted peers imposes extra complexity on code that\nemploys shared memory. Memory sealing enables that extra\ncomplexity to be eliminated, by allowing a process to\noperate secure in the knowledge that its peer can&rsquo;t\nmodify the shared memory in an undesired fashion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An example of\nthe usage of the sealing mechanism is as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The first process creates a\n<a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a> file using <b>memfd_create</b>(). The call\nyields a file descriptor used in subsequent steps.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>The first process sizes the file created in the previous\nstep using <a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>, maps it using\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>, and populates the shared memory with the\ndesired data.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>The first process uses the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>\n<b>F_ADD_SEALS</b> operation to place one or more seals on\nthe file, in order to restrict further modifications on the\nfile. (If placing the seal <b>F_SEAL_WRITE</b>, then it will\nbe necessary to first unmap the shared writable mapping\ncreated in the previous step. Otherwise, behavior similar to\n<b>F_SEAL_WRITE</b> can be achieved by using\n<b>F_SEAL_FUTURE_WRITE</b>, which will prevent future writes\nvia <a href=\"https://man.page/2/mmap\">mmap(2)</a> and <a href=\"https://man.page/2/write\">write(2)</a> from succeeding while\nkeeping existing shared writable mappings).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>A second process obtains a file descriptor for the\n<a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a> file and maps it. Among the possible ways in\nwhich this could happen are the following:</p></td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">*</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\"></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">The process that called\n<b>memfd_create</b>() could transfer the resulting file\ndescriptor to the second process via a UNIX domain socket\n(see <a href=\"https://man.page/7/unix\">unix(7)</a> and <a href=\"https://man.page/3/cmsg\">cmsg(3)</a>). The second process\nthen maps the file using <a href=\"https://man.page/2/mmap\">mmap(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>The second process is created via <a href=\"https://man.page/2/fork\">fork(2)</a> and\nthus automatically inherits the file descriptor and mapping.\n(Note that in this case and the next, there is a natural\ntrust relationship between the two processes, since they are\nrunning under the same user ID. Therefore, file sealing\nwould not normally be necessary.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>The second process opens the file\n<i>/proc/&lt;pid&gt;/fd/&lt;fd&gt;</i>, where\n<i>&lt;pid&gt;</i> is the PID of the first process (the one\nthat called <b>memfd_create</b>()), and <i>&lt;fd&gt;</i> is\nthe number of the file descriptor returned by the call to\n<b>memfd_create</b>() in that process. The second process\nthen maps the file using <a href=\"https://man.page/2/mmap\">mmap(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>5.</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">The second\nprocess uses the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_GET_SEALS</b>\noperation to retrieve the bit mask of seals that has been\napplied to the file. This bit mask can be inspected in order\nto determine what kinds of restrictions have been placed on\nfile modifications. If desired, the second process can apply\nfurther seals to impose additional restrictions (so long as\nthe <b>F_SEAL_SEAL</b> seal has not yet been applied).</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Below are shown\ntwo example programs that demonstrate the use of\n<b>memfd_create</b>() and the file sealing API.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first\nprogram, <i>t_memfd_create.c</i>, creates a <a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a>\nfile using <b>memfd_create</b>(), sets a size for the file,\nmaps it into memory, and optionally places some seals on the\nfile. The program accepts up to three command-line\narguments, of which the first two are required. The first\nargument is the name to associate with the file, the second\nargument is the size to be set for the file, and the\noptional third argument is a string of characters that\nspecify seals to be set on file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second\nprogram, <i>t_get_seals.c</i>, can be used to open an\nexisting file that was created via <b>memfd_create</b>() and\ninspect the set of seals that have been applied to that\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session demonstrates the use of these programs. First\nwe create a <a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a> file and set some seals on\nit:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./t_memfd_create my_memfd_file 4096 sw &amp;</b> <br>\n[1] 11775 <br>\nPID: 11775; fd: 3; /proc/11775/fd/3</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">At this point,\nthe <i>t_memfd_create</i> program continues to run in the\nbackground. From another program, we can obtain a file\ndescriptor for the file created by <b>memfd_create</b>() by\nopening the <i>/proc/[pid]/fd</i> file that corresponds to\nthe file descriptor opened by <b>memfd_create</b>(). Using\nthat pathname, we inspect the content of the\n<i>/proc/[pid]/fd</i> symbolic link, and use our\n<i>t_get_seals</i> program to view the seals that have been\nplaced on the file:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>readlink\n/proc/11775/fd/3</b> <br>\n/memfd:my_memfd_file (deleted) <br>\n$ <b>./t_get_seals /proc/11775/fd/3</b> <br>\nExisting seals: WRITE SHRINK</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: t_memfd_create.c</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;sys/mman.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;stdio.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint fd; <br>\nunsigned int seals; <br>\nchar *addr; <br>\nchar *name, *seals_arg; <br>\nssize_t len;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n3) { <br>\nfprintf(stderr, &quot;%s name size [seals]\\n&quot;,\nargv[0]); <br>\nfprintf(stderr, &quot;\\t'seals' can contain any of the\n&quot; <br>\n&quot;following characters:\\n&quot;); <br>\nfprintf(stderr, &quot;\\t\\tg - F_SEAL_GROW\\n&quot;); <br>\nfprintf(stderr, &quot;\\t\\ts - F_SEAL_SHRINK\\n&quot;); <br>\nfprintf(stderr, &quot;\\t\\tw - F_SEAL_WRITE\\n&quot;); <br>\nfprintf(stderr, &quot;\\t\\tW - F_SEAL_FUTURE_WRITE\\n&quot;);\n<br>\nfprintf(stderr, &quot;\\t\\tS - F_SEAL_SEAL\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">name = argv[1];\n<br>\nlen = atoi(argv[2]); <br>\nseals_arg = argv[3];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create an\nanonymous file in tmpfs; allow seals to be <br>\nplaced on the file */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nmemfd_create(name, MFD_ALLOW_SEALING); <br>\nif (fd == -1) <br>\nerrExit(&quot;memfd_create&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Size the\nfile as specified on the command line */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(ftruncate(fd, len) == -1) <br>\nerrExit(&quot;truncate&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;PID:\n%jd; fd: %d; /proc/%jd/fd/%d\\n&quot;, <br>\n(intmax_t) getpid(), fd, (intmax_t) getpid(), fd);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Code to map\nthe file and populate the mapping with data <br>\nomitted */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* If a 'seals'\ncommand-line argument was supplied, set some <br>\nseals on the file */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (seals_arg\n!= NULL) { <br>\nseals = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(strchr(seals_arg, 'g') != NULL) <br>\nseals |= F_SEAL_GROW; <br>\nif (strchr(seals_arg, 's') != NULL) <br>\nseals |= F_SEAL_SHRINK; <br>\nif (strchr(seals_arg, 'w') != NULL) <br>\nseals |= F_SEAL_WRITE; <br>\nif (strchr(seals_arg, 'W') != NULL) <br>\nseals |= F_SEAL_FUTURE_WRITE; <br>\nif (strchr(seals_arg, 'S') != NULL) <br>\nseals |= F_SEAL_SEAL;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fcntl(fd,\nF_ADD_SEALS, seals) == -1) <br>\nerrExit(&quot;fcntl&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Keep\nrunning, so that the file created by memfd_create() <br>\ncontinues to exist */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pause();</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: t_get_seals.c</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;sys/mman.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;stdio.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint fd; <br>\nunsigned int seals;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;%s /proc/PID/fd/FD\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(argv[1], O_RDWR); <br>\nif (fd == -1) <br>\nerrExit(&quot;open&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">seals =\nfcntl(fd, F_GET_SEALS); <br>\nif (seals == -1) <br>\nerrExit(&quot;fcntl&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Existing\nseals:&quot;); <br>\nif (seals &amp; F_SEAL_SEAL) <br>\nprintf(&quot; SEAL&quot;); <br>\nif (seals &amp; F_SEAL_GROW) <br>\nprintf(&quot; GROW&quot;); <br>\nif (seals &amp; F_SEAL_WRITE) <br>\nprintf(&quot; WRITE&quot;); <br>\nif (seals &amp; F_SEAL_FUTURE_WRITE) <br>\nprintf(&quot; FUTURE_WRITE&quot;); <br>\nif (seals &amp; F_SEAL_SHRINK) <br>\nprintf(&quot; SHRINK&quot;); <br>\nprintf(&quot;\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Code to map\nthe file and access the contents of the <br>\nresulting mapping omitted */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/fcntl\">fcntl(2)</a>,\n<a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/shmget\">shmget(2)</a>,\n<a href=\"https://man.page/3/shm_open\">shm_open(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}