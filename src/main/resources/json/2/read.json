{"name":"read","description":"read - read from a file descriptor","body":"\n\n<h1 align=\"center\">READ</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">read - read\nfrom a file descriptor</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;unistd.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ssize_t\nread(int</b> <i>fd</i><b>, void *</b><i>buf</i><b>,\nsize_t</b> <i>count</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>read</b>()\nattempts to read up to <i>count</i> bytes from file\ndescriptor <i>fd</i> into the buffer starting at\n<i>buf</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On files that\nsupport seeking, the read operation commences at the file\noffset, and the file offset is incremented by the number of\nbytes read. If the file offset is at or past the end of\nfile, no bytes are read, and <b>read</b>() returns zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>count</i>\nis zero, <b>read</b>() <i>may</i> detect the errors\ndescribed below. In the absence of any errors, or if\n<b>read</b>() does not check for errors, a <b>read</b>()\nwith a <i>count</i> of 0 returns zero and has no other\neffects.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1, if <i>count</i> is greater than <b>SSIZE_MAX</b>,\nthe result is implementation-defined; see NOTES for the\nupper limit on Linux.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success, the\nnumber of bytes read is returned (zero indicates end of\nfile), and the file position is advanced by this number. It\nis not an error if this number is smaller than the number of\nbytes requested; this may happen for example because fewer\nbytes are actually available right now (maybe because we\nwere close to end-of-file, or because we are reading from a\npipe, or from a terminal), or because <b>read</b>() was\ninterrupted by a signal. See also NOTES.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set appropriately. In this\ncase, it is left unspecified whether the file position (if\nany) changes.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The file descriptor <i>fd</i>\nrefers to a file other than a socket and has been marked\nnonblocking (<b>O_NONBLOCK</b>), and the read would block.\nSee <a href=\"https://man.page/2/open\">open(2)</a> for further details on the\n<b>O_NONBLOCK</b> flag.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EAGAIN</b> or\n<b>EWOULDBLOCK</b></p>\n\n<p style=\"margin-left:22%;\">The file descriptor <i>fd</i>\nrefers to a socket and has been marked nonblocking\n(<b>O_NONBLOCK</b>), and the read would block. POSIX.1-2001\nallows either error to be returned for this case, and does\nnot require these constants to have the same value, so a\nportable application should check for both\npossibilities.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is not a valid file descriptor or is not open\nfor reading.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>buf</i> is outside your accessible address space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The call was interrupted by a signal before any data was\nread; see <a href=\"https://man.page/7/signal\">signal(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is attached to an object which is unsuitable\nfor reading; or the file was opened with the <b>O_DIRECT</b>\nflag, and either the address specified in <i>buf</i>, the\nvalue specified in <i>count</i>, or the file offset is not\nsuitably aligned.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> was created via a call to\n<a href=\"https://man.page/2/timerfd_create\">timerfd_create(2)</a> and the wrong size buffer was given\nto <b>read</b>(); see <a href=\"https://man.page/2/timerfd_create\">timerfd_create(2)</a> for further\ninformation.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>I/O error. This will happen for example when the process\nis in a background process group, tries to read from its\ncontrolling terminal, and either it is ignoring or blocking\n<b>SIGTTIN</b> or its process group is orphaned. It may also\noccur when there is a low-level I/O error while reading from\na disk or tape. A further possible cause of <b>EIO</b> on\nnetworked filesystems is when an advisory lock had been\ntaken out on the file descriptor and this lock has been\nlost. See the <i>Lost locks</i> section of <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>\nfor further details.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EISDIR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> refers to a directory.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other errors\nmay occur, depending on the object connected to\n<i>fd</i>.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SVr4, 4.3BSD,\nPOSIX.1-2001.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The types\n<i>size_t</i> and <i>ssize_t</i> are, respectively, unsigned\nand signed integer data types specified by POSIX.1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux,\n<b>read</b>() (and similar system calls) will transfer at\nmost 0x7ffff000 (2,147,479,552) bytes, returning the number\nof bytes actually transferred. (This is true on both 32-bit\nand 64-bit systems.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On NFS\nfilesystems, reading small amounts of data will update the\ntimestamp only the first time, subsequent calls may not do\nso. This is caused by client side attribute caching, because\nmost if not all NFS clients leave <i>st_atime</i> (last file\naccess time) updates to the server, and client side reads\nsatisfied from the client&rsquo;s cache will not cause\n<i>st_atime</i> updates on the server as there are no\nserver-side reads. UNIX semantics can be obtained by\ndisabling client-side attribute caching, but in most\nsituations this will substantially increase server load and\ndecrease performance.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1-2008/SUSv4 Section XSI 2.9.7 (&quot;Thread\nInteractions with Regular File Operations&quot;):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">All of the\nfollowing functions shall be atomic with respect to each\nother in the effects specified in POSIX.1-2008 when they\noperate on regular files or symbolic links: ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Among the APIs\nsubsequently listed are <b>read</b>() and <a href=\"https://man.page/2/readv\">readv(2)</a>.\nAnd among the effects that should be atomic across threads\n(and processes) are updates of the file offset. However, on\nLinux before version 3.14, this was not the case: if two\nprocesses that share an open file description (see\n<a href=\"https://man.page/2/open\">open(2)</a>) perform a <b>read</b>() (or <a href=\"https://man.page/2/readv\">readv(2)</a>)\nat the same time, then the I/O operations were not atomic\nwith respect updating the file offset, with the result that\nthe reads in the two processes might (incorrectly) overlap\nin the blocks of data that they obtained. This problem was\nfixed in Linux 3.14.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/close\">close(2)</a>,\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>, <a href=\"https://man.page/2/lseek\">lseek(2)</a>,\n<a href=\"https://man.page/2/open\">open(2)</a>, <a href=\"https://man.page/2/pread\">pread(2)</a>, <a href=\"https://man.page/2/readdir\">readdir(2)</a>,\n<a href=\"https://man.page/2/readlink\">readlink(2)</a>, <a href=\"https://man.page/2/readv\">readv(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/3/fread\">fread(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}