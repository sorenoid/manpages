{"name":"shmctl","body":"\n\n<h1 align=\"center\">SHMCTL</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">shmctl - System\nV shared memory control</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/ipc.h&gt; <br>\n#include &lt;sys/shm.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nshmctl(int</b> <i>shmid</i><b>, int</b> <i>cmd</i><b>,\nstruct shmid_ds *</b><i>buf</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>shmctl</b>()\nperforms the control operation specified by <i>cmd</i> on\nthe System&nbsp;V shared memory segment whose identifier is\ngiven in <i>shmid</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>buf</i>\nargument is a pointer to a <i>shmid_ds</i> structure,\ndefined in <i>&lt;sys/shm.h&gt;</i> as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct shmid_ds\n{ <br>\nstruct ipc_perm shm_perm; /* Ownership and permissions */\n<br>\nsize_t shm_segsz; /* Size of segment (bytes) */ <br>\ntime_t shm_atime; /* Last attach time */ <br>\ntime_t shm_dtime; /* Last detach time */ <br>\ntime_t shm_ctime; /* Creation time/time of last <br>\nmodification via shmctl() */ <br>\npid_t shm_cpid; /* PID of creator */ <br>\npid_t shm_lpid; /* PID of last shmat(2)/shmdt(2) */ <br>\nshmatt_t shm_nattch; /* No. of current attaches */ <br>\n... <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthe <i>shmid_ds</i> structure are as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_perm</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>This is an <i>ipc_perm</i> structure (see below) that\nspecifies the access permissions on the shared memory\nsegment.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_segsz</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>Size in bytes of the shared memory segment.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_atime</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>Time of the last <a href=\"https://man.page/2/shmat\">shmat(2)</a> system call that\nattached this segment.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_dtime</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>Time of the last <a href=\"https://man.page/2/shmdt\">shmdt(2)</a> system call that\ndetached tgis segment.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_ctime</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>Time of creation of segment or time of the last\n<b>shmctl</b>() <b>IPC_SET</b> operation.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_cpid</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>ID of the process that created the shared memory\nsegment.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_lpid</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>ID of the last process that executed a <a href=\"https://man.page/2/shmat\">shmat(2)</a>\nor <a href=\"https://man.page/2/shmdt\">shmdt(2)</a> system call on this segment.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><i>shm_nattch</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"71%\">\n\n\n<p>Number of processes that have this segment attached.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>ipc_perm</i> structure is defined as follows (the\nhighlighted fields are settable using <b>IPC_SET</b>):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct ipc_perm\n{ <br>\nkey_t __key; /* Key supplied to shmget(2) */ <br>\nuid_t <b>uid</b>; /* Effective UID of owner */ <br>\ngid_t <b>gid</b>; /* Effective GID of owner */ <br>\nuid_t cuid; /* Effective UID of creator */ <br>\ngid_t cgid; /* Effective GID of creator */ <br>\nunsigned short <b>mode</b>; /* <b>Permissions</b> + SHM_DEST\nand <br>\nSHM_LOCKED flags */ <br>\nunsigned short __seq; /* Sequence number */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The least\nsignificant 9 bits of the <i>mode</i> field of the\n<i>ipc_perm</i> structure define the access permissions for\nthe shared memory segment. The permission bits are as\nfollows:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3245261.png\" alt=\"Image grohtml-3245261.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Bits 0100,\n0010, and 0001 (the execute bits) are unused by the system.\n(It is not necessary to have execute permission on a segment\nin order to perform a <a href=\"https://man.page/2/shmat\">shmat(2)</a> call with the\n<b>SHM_EXEC</b> flag.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Valid values\nfor <i>cmd</i> are: <b><br>\nIPC_STAT</b></p>\n\n<p style=\"margin-left:22%;\">Copy information from the\nkernel data structure associated with <i>shmid</i> into the\n<i>shmid_ds</i> structure pointed to by <i>buf</i>. The\ncaller must have read permission on the shared memory\nsegment.</p>\n\n<p style=\"margin-left:11%;\"><b>IPC_SET</b></p>\n\n<p style=\"margin-left:22%;\">Write the values of some\nmembers of the <i>shmid_ds</i> structure pointed to by\n<i>buf</i> to the kernel data structure associated with this\nshared memory segment, updating also its <i>shm_ctime</i>\nmember.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The following\nfields are updated: <i>shm_perm.uid</i>,\n<i>shm_perm.gid</i>, and (the least significant 9 bits of)\n<i>shm_perm.mode</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The effective\nUID of the calling process must match the owner\n(<i>shm_perm.uid</i>) or creator (<i>shm_perm.cuid</i>) of\nthe shared memory segment, or the caller must be\nprivileged.</p>\n\n<p style=\"margin-left:11%;\"><b>IPC_RMID</b></p>\n\n<p style=\"margin-left:22%;\">Mark the segment to be\ndestroyed. The segment will actually be destroyed only after\nthe last process detaches it (i.e., when the\n<i>shm_nattch</i> member of the associated structure\n<i>shmid_ds</i> is zero). The caller must be the owner or\ncreator of the segment, or be privileged. The <i>buf</i>\nargument is ignored.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If a segment\nhas been marked for destruction, then the (nonstandard)\n<b>SHM_DEST</b> flag of the <i>shm_perm.mode</i> field in\nthe associated data structure retrieved by <b>IPC_STAT</b>\nwill be set.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The caller\n<i>must</i> ensure that a segment is eventually destroyed;\notherwise its pages that were faulted in will remain in\nmemory or swap.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">See also the\ndescription of <i>/proc/sys/kernel/shm_rmid_forced</i> in\n<a href=\"https://man.page/5/proc\">proc(5)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>IPC_INFO</b>\n(Linux-specific)</p>\n\n<p style=\"margin-left:22%;\">Return information about\nsystem-wide shared memory limits and parameters in the\nstructure pointed to by <i>buf</i>. This structure is of\ntype <i>shminfo</i> (thus, a cast is required), defined in\n<i>&lt;sys/shm.h&gt;</i> if the <b>_GNU_SOURCE</b> feature\ntest macro is defined:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct shminfo\n{ <br>\nunsigned long shmmax; /* Maximum segment size */ <br>\nunsigned long shmmin; /* Minimum segment size; <br>\nalways 1 */ <br>\nunsigned long shmmni; /* Maximum number of segments */ <br>\nunsigned long shmseg; /* Maximum number of segments <br>\nthat a process can attach; <br>\nunused within kernel */ <br>\nunsigned long shmall; /* Maximum number of pages of <br>\nshared memory, system-wide */ <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>shmmni</i>, <i>shmmax</i>, and <i>shmall</i> settings can\nbe changed via <i>/proc</i> files of the same name; see\n<a href=\"https://man.page/5/proc\">proc(5)</a> for details.</p>\n\n<p style=\"margin-left:11%;\"><b>SHM_INFO</b>\n(Linux-specific)</p>\n\n<p style=\"margin-left:22%;\">Return a <i>shm_info</i>\nstructure whose fields contain information about system\nresources consumed by shared memory. This structure is\ndefined in <i>&lt;sys/shm.h&gt;</i> if the\n<b>_GNU_SOURCE</b> feature test macro is defined:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct shm_info\n{ <br>\nint used_ids; /* # of currently existing <br>\nsegments */ <br>\nunsigned long shm_tot; /* Total number of shared <br>\nmemory pages */ <br>\nunsigned long shm_rss; /* # of resident shared <br>\nmemory pages */ <br>\nunsigned long shm_swp; /* # of swapped shared <br>\nmemory pages */ <br>\nunsigned long swap_attempts; <br>\n/* Unused since Linux 2.4 */ <br>\nunsigned long swap_successes; <br>\n/* Unused since Linux 2.4 */ <br>\n};</p>\n\n<p style=\"margin-left:11%;\"><b>SHM_STAT</b>\n(Linux-specific)</p>\n\n<p style=\"margin-left:22%;\">Return a <i>shmid_ds</i>\nstructure as for <b>IPC_STAT</b>. However, the <i>shmid</i>\nargument is not a segment identifier, but instead an index\ninto the kernel&rsquo;s internal array that maintains\ninformation about all shared memory segments on the\nsystem.</p>\n\n<p style=\"margin-left:11%;\"><b>SHM_STAT_ANY</b>\n(Linux-specific, since Linux 4.17)</p>\n\n<p style=\"margin-left:22%;\">Return a <i>shmid_ds</i>\nstructure as for <b>SHM_STAT</b>. However,\n<i>shm_perm.mode</i> is not checked for read access for\n<i>shmid</i>, meaning that any user can employ this\noperation (just as any user may read\n<i>/proc/sysvipc/shm</i> to obtain the same\ninformation).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The caller can\nprevent or allow swapping of a shared memory segment with\nthe following <i>cmd</i> values: <b><br>\nSHM_LOCK</b> (Linux-specific)</p>\n\n<p style=\"margin-left:22%;\">Prevent swapping of the shared\nmemory segment. The caller must fault in any pages that are\nrequired to be present after locking is enabled. If a\nsegment has been locked, then the (nonstandard)\n<b>SHM_LOCKED</b> flag of the <i>shm_perm.mode</i> field in\nthe associated data structure retrieved by <b>IPC_STAT</b>\nwill be set.</p>\n\n<p style=\"margin-left:11%;\"><b>SHM_UNLOCK</b>\n(Linux-specific)</p>\n\n<p style=\"margin-left:22%;\">Unlock the segment, allowing it\nto be swapped out.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In kernels\nbefore 2.6.10, only a privileged process could employ\n<b>SHM_LOCK</b> and <b>SHM_UNLOCK</b>. Since kernel 2.6.10,\nan unprivileged process can employ these operations if its\neffective UID matches the owner or creator UID of the\nsegment, and (for <b>SHM_LOCK</b>) the amount of memory to\nbe locked falls within the <b>RLIMIT_MEMLOCK</b> resource\nlimit (see <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>).</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A successful\n<b>IPC_INFO</b> or <b>SHM_INFO</b> operation returns the\nindex of the highest used entry in the kernel&rsquo;s\ninternal array recording information about all shared memory\nsegments. (This information can be used with repeated\n<b>SHM_STAT</b> or <b>SHM_STAT_ANY</b> operations to obtain\ninformation about all shared memory segments on the system.)\nA successful <b>SHM_STAT</b> operation returns the\nidentifier of the shared memory segment whose index was\ngiven in <i>shmid</i>. Other operations return 0 on\nsuccess.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>IPC_STAT</b> or\n<b>SHM_STAT</b> is requested and <i>shm_perm.mode</i> does\nnot allow read access for <i>shmid</i>, and the calling\nprocess does not have the <b>CAP_IPC_OWNER</b> capability in\nthe user namespace that governs its IPC namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The argument <i>cmd</i> has value <b>IPC_SET</b> or\n<b>IPC_STAT</b> but the address pointed to by <i>buf</i>\nisn&rsquo;t accessible.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIDRM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>shmid</i> points to a removed identifier.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>shmid</i> is not a valid identifier, or <i>cmd</i> is\nnot a valid command. Or: for a <b>SHM_STAT</b> or\n<b>SHM_STAT_ANY</b> operation, the index value specified in\n<i>shmid</i> referred to an array slot that is currently\nunused.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(In kernels since 2.6.9), <b>SHM_LOCK</b> was specified\nand the size of the to-be-locked segment would mean that the\ntotal bytes in locked shared memory segments would exceed\nthe limit for the real user ID of the calling process. This\nlimit is defined by the <b>RLIMIT_MEMLOCK</b> soft resource\nlimit (see <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EOVERFLOW</b></p>\n\n<p style=\"margin-left:22%;\"><b>IPC_STAT</b> is attempted,\nand the GID or UID value is too large to be stored in the\nstructure pointed to by <i>buf</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><b>IPC_SET</b> or <b>IPC_RMID</b> is attempted, and the\neffective user ID of the calling process is not that of the\ncreator (found in <i>shm_perm.cuid</i>), or the owner (found\nin <i>shm_perm.uid</i>), and the process was not privileged\n(Linux: did not have the <b>CAP_SYS_ADMIN</b>\ncapability).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Or (in kernels\nbefore 2.6.9), <b>SHM_LOCK</b> or <b>SHM_UNLOCK</b> was\nspecified, but the process was not privileged (Linux: did\nnot have the <b>CAP_IPC_LOCK</b> capability). (Since Linux\n2.6.9, this error can also occur if the\n<b>RLIMIT_MEMLOCK</b> is 0 and the caller is not\nprivileged.)</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008, SVr4.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inclusion\nof <i>&lt;sys/types.h&gt;</i> and <i>&lt;sys/ipc.h&gt;</i>\nisn&rsquo;t required on Linux or by any version of POSIX.\nHowever, some old implementations required the inclusion of\nthese header files, and the SVID also documented their\ninclusion. Applications intended to be portable to such old\nsystems may need to include these header files.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>IPC_INFO</b>, <b>SHM_STAT</b>, and <b>SHM_INFO</b>\noperations are used by the <a href=\"https://man.page/1/ipcs\">ipcs(1)</a> program to provide\ninformation on allocated resources. In the future, these may\nmodified or moved to a <i>/proc</i> filesystem\ninterface.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux permits a\nprocess to attach (<a href=\"https://man.page/2/shmat\">shmat(2)</a>) a shared memory segment\nthat has already been marked for deletion using\n<i>shmctl(IPC_RMID)</i>. This feature is not available on\nother UNIX implementations; portable applications should\navoid relying on it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Various fields\nin a <i>struct shmid_ds</i> were typed as <i>short</i> under\nLinux 2.2 and have become <i>long</i> under Linux 2.4. To\ntake advantage of this, a recompilation under glibc-2.1.91\nor later should suffice. (The kernel distinguishes old and\nnew calls by an <b>IPC_64</b> flag in <i>cmd</i>.)</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/mlock\">mlock(2)</a>,\n<a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>, <a href=\"https://man.page/2/shmget\">shmget(2)</a>, <a href=\"https://man.page/2/shmop\">shmop(2)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/sysvipc\">sysvipc(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}