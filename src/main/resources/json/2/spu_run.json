{"name":"spu_run","body":"\n\n<h1 align=\"center\">SPU_RUN</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">spu_run -\nexecute an SPU context</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/spu.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nspu_run(int</b> <i>fd</i><b>, unsigned int\n*</b><i>npc</i><b>, unsigned int\n*</b><i>event</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere is no glibc wrapper for this system call; see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>spu_run</b>() system call is used on PowerPC machines\nthat implement the Cell Broadband Engine Architecture in\norder to access Synergistic Processor Units (SPUs). The\n<i>fd</i> argument is a file descriptor returned by\n<a href=\"https://man.page/2/spu_create\">spu_create(2)</a> that refers to a specific SPU context.\nWhen the context gets scheduled to a physical SPU, it starts\nexecution at the instruction pointer passed in\n<i>npc</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Execution of\nSPU code happens synchronously, meaning that\n<b>spu_run</b>() blocks while the SPU is still running. If\nthere is a need to execute SPU code in parallel with other\ncode on either the main CPU or other SPUs, a new thread of\nexecution must be created first (e.g., using\n<a href=\"https://man.page/3/pthread_create\">pthread_create(3)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<b>spu_run</b>() returns, the current value of the SPU\nprogram counter is written to <i>npc</i>, so successive\ncalls to <b>spu_run</b>() can use the same <i>npc</i>\npointer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>event</i> argument provides a buffer for an extended\nstatus code. If the SPU context was created with the\n<b>SPU_CREATE_EVENTS_ENABLED</b> flag, then this buffer is\npopulated by the Linux kernel before <b>spu_run</b>()\nreturns.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The status code\nmay be one (or more) of the following constants: <b><br>\nSPE_EVENT_DMA_ALIGNMENT</b></p>\n\n<p style=\"margin-left:22%;\">A DMA alignment error\noccurred.</p>\n\n\n<p style=\"margin-left:11%;\"><b>SPE_EVENT_INVALID_DMA</b></p>\n\n<p style=\"margin-left:22%;\">An invalid MFC DMA command was\nattempted.</p>\n\n\n<p style=\"margin-left:11%;\"><b>SPE_EVENT_SPE_DATA_STORAGE</b></p>\n\n<p style=\"margin-left:22%;\">A DMA storage error\noccurred.</p>\n\n<p style=\"margin-left:11%;\"><b>SPE_EVENT_SPE_ERROR</b></p>\n\n<p style=\"margin-left:22%;\">An illegal instruction was\nexecuted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">NULL is a valid\nvalue for the <i>event</i> argument. In this case, the\nevents will not be reported to the calling process.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>spu_run</b>() returns the value of the <i>spu_status</i>\nregister. On error, it returns -1 and sets <i>errno</i> to\none of the error codes listed below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>spu_status</i> register value is a bit mask of status\ncodes and optionally a 14-bit code returned from the\n<b>stop-and-signal</b> instruction on the SPU. The bit masks\nfor the status codes are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><b>0x02</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"75%\">\n\n\n<p>SPU was stopped by a <b>stop-and-signal</b>\ninstruction.</p> </td>\n<td width=\"3%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><b>0x04</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"75%\">\n\n\n<p>SPU was stopped by a <b>halt</b> instruction.</p></td>\n<td width=\"3%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><b>0x08</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"75%\">\n\n\n<p>SPU is waiting for a channel.</p></td>\n<td width=\"3%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><b>0x10</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"75%\">\n\n\n<p>SPU is in single-step mode.</p></td>\n<td width=\"3%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><b>0x20</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"75%\">\n\n\n<p>SPU has tried to execute an invalid instruction.</p></td>\n<td width=\"3%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><b>0x40</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"75%\">\n\n\n<p>SPU has tried to access an invalid channel.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>0x3fff0000</b></p>\n\n<p style=\"margin-left:22%;\">The bits masked with this value\ncontain the code returned from a <b>stop-and-signal</b>\ninstruction. These bits are valid only if the 0x02 bit is\nset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>spu_run</b>() has not returned an error, one or more bits\namong the lower eight ones are always set.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><i>fd</i> is not a valid file\ndescriptor.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>npc</i> is not a valid pointer, or <i>event</i> is\nnon-NULL and an invalid pointer.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A signal occurred while <b>spu_run</b>() was in\nprogress; see <a href=\"https://man.page/7/signal\">signal(7)</a>. The <i>npc</i> value has\nbeen updated to the new program counter value if\nnecessary.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is not a valid file descriptor returned from\n<a href=\"https://man.page/2/spu_create\">spu_create(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>There was not enough memory available to handle a page\nfault resulting from a Memory Flow Controller (MFC) direct\nmemory access.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The functionality is not provided by the current system,\nbecause either the hardware does not provide SPUs or the\nspufs module is not loaded.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>spu_run</b>() system call was added to Linux in kernel\n2.6.16.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This call is\nLinux-specific and implemented only by the PowerPC\narchitecture. Programs using this system call are not\nportable.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glibc does not\nprovide a wrapper for this system call; call it using\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>. Note however, that <b>spu_run</b>() is\nmeant to be used from libraries that implement a more\nabstract interface to SPUs, not to be used from regular\napplications. See\n<a href=\"http://www.bsc.es/projects/deepcomputing/linuxoncell/\">http://www.bsc.es/projects/deepcomputing/linuxoncell/</a>\nfor the recommended libraries.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nis an example of running a simple, one-instruction SPU\nprogram with the <b>spu_run</b>() system call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stdlib.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;fcntl.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error(msg) \\ <br>\ndo { perror(msg); exit(EXIT_FAILURE); } while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int main(void)\n<br>\n{ <br>\nint context, fd, spu_status; <br>\nuint32_t instruction, npc;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">context =\nspu_create(&quot;/spu/example-context&quot;, 0, 0755); <br>\nif (context == -1) <br>\nhandle_error(&quot;spu_create&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* write a\n'stop 0x1234' instruction to the SPU's <br>\n* local store memory <br>\n*/ <br>\ninstruction = 0x00001234;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(&quot;/spu/example-context/mem&quot;, O_RDWR); <br>\nif (fd == -1) <br>\nhandle_error(&quot;open&quot;); <br>\nwrite(fd, &amp;instruction, sizeof(instruction));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* set npc to\nthe starting instruction address of the <br>\n* SPU program. Since we wrote the instruction at the <br>\n* start of the mem file, the entry point will be 0x0 <br>\n*/ <br>\nnpc = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">spu_status =\nspu_run(context, &amp;npc, NULL); <br>\nif (spu_status == -1) <br>\nhandle_error(&quot;open&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* we should\nsee a status code of 0x1234002: <br>\n* 0x00000002 (spu was stopped due to stop-and-signal) <br>\n* | 0x12340000 (the stop-and-signal code) <br>\n*/ <br>\nprintf(&quot;SPU Status: %#08x\\n&quot;, spu_status);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/close\">close(2)</a>,\n<a href=\"https://man.page/2/spu_create\">spu_create(2)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/spufs\">spufs(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}