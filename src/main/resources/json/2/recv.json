{"name":"recv","description":"recv, recvfrom,\nrecvmsg - receive a message from a socket","body":"\n\n<h1 align=\"center\">RECV</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">recv, recvfrom,\nrecvmsg - receive a message from a socket</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/types.h&gt; <br>\n#include &lt;sys/socket.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ssize_t\nrecv(int</b> <i>sockfd</i><b>, void *</b><i>buf</i><b>,\nsize_t</b> <i>len</i><b>, int</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ssize_t\nrecvfrom(int</b> <i>sockfd</i><b>, void *</b><i>buf</i><b>,\nsize_t</b> <i>len</i><b>, int</b> <i>flags</i><b>, <br>\nstruct sockaddr *</b><i>src_addr</i><b>, socklen_t\n*</b><i>addrlen</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ssize_t\nrecvmsg(int</b> <i>sockfd</i><b>, struct msghdr\n*</b><i>msg</i><b>, int</b> <i>flags</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>recv</b>(), <b>recvfrom</b>(), and <b>recvmsg</b>() calls\nare used to receive messages from a socket. They may be used\nto receive data on both connectionless and\nconnection-oriented sockets. This page first describes\ncommon features of all three system calls, and then\ndescribes the differences between the calls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The only\ndifference between <b>recv</b>() and <a href=\"https://man.page/2/read\">read(2)</a> is the\npresence of <i>flags</i>. With a zero <i>flags</i> argument,\n<b>recv</b>() is generally equivalent to <a href=\"https://man.page/2/read\">read(2)</a> (but\nsee NOTES). Also, the following call</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">recv(sockfd,\nbuf, len, flags);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is equivalent\nto</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">recvfrom(sockfd,\nbuf, len, flags, NULL, NULL);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All three calls\nreturn the length of the message on successful completion.\nIf a message is too long to fit in the supplied buffer,\nexcess bytes may be discarded depending on the type of\nsocket the message is received from.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If no messages\nare available at the socket, the receive calls wait for a\nmessage to arrive, unless the socket is nonblocking (see\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>), in which case the value -1 is returned and\nthe external variable <i>errno</i> is set to <b>EAGAIN</b>\nor <b>EWOULDBLOCK</b>. The receive calls normally return any\ndata available, up to the requested amount, rather than\nwaiting for receipt of the full amount requested.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An application\ncan use <a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, or <a href=\"https://man.page/7/epoll\">epoll(7)</a>\nto determine when more data arrives on a socket.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The flags\nargument</b> <br>\nThe <i>flags</i> argument is formed by ORing one or more of\nthe following values: <b><br>\nMSG_CMSG_CLOEXEC</b> (<b>recvmsg</b>() only; since Linux\n2.6.23)</p>\n\n<p style=\"margin-left:22%;\">Set the close-on-exec flag for\nthe file descriptor received via a UNIX domain file\ndescriptor using the <b>SCM_RIGHTS</b> operation (described\nin <a href=\"https://man.page/7/unix\">unix(7)</a>). This flag is useful for the same reasons\nas the <b>O_CLOEXEC</b> flag of <a href=\"https://man.page/2/open\">open(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_DONTWAIT</b> (since\nLinux 2.2)</p>\n\n<p style=\"margin-left:22%;\">Enables nonblocking operation;\nif the operation would block, the call fails with the error\n<b>EAGAIN</b> or <b>EWOULDBLOCK</b>. This provides similar\nbehavior to setting the <b>O_NONBLOCK</b> flag (via the\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_SETFL</b> operation), but differs in\nthat <b>MSG_DONTWAIT</b> is a per-call option, whereas\n<b>O_NONBLOCK</b> is a setting on the open file description\n(see <a href=\"https://man.page/2/open\">open(2)</a>), which will affect all threads in the\ncalling process and as well as other processes that hold\nfile descriptors referring to the same open file\ndescription.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_ERRQUEUE</b> (since\nLinux 2.2)</p>\n\n<p style=\"margin-left:22%;\">This flag specifies that queued\nerrors should be received from the socket error queue. The\nerror is passed in an ancillary message with a type\ndependent on the protocol (for IPv4 <b>IP_RECVERR</b>). The\nuser should supply a buffer of sufficient size. See\n<a href=\"https://man.page/3/cmsg\">cmsg(3)</a> and <a href=\"https://man.page/7/ip\">ip(7)</a> for more information. The\npayload of the original packet that caused the error is\npassed as normal data via <i>msg_iovec</i>. The original\ndestination address of the datagram that caused the error is\nsupplied via <i>msg_name</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The error is\nsupplied in a <i>sock_extended_err</i> structure:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">#define\nSO_EE_ORIGIN_NONE 0 <br>\n#define SO_EE_ORIGIN_LOCAL 1 <br>\n#define SO_EE_ORIGIN_ICMP 2 <br>\n#define SO_EE_ORIGIN_ICMP6 3</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nsock_extended_err <br>\n{ <br>\nuint32_t ee_errno; /* Error number */ <br>\nuint8_t ee_origin; /* Where the error originated */ <br>\nuint8_t ee_type; /* Type */ <br>\nuint8_t ee_code; /* Code */ <br>\nuint8_t ee_pad; /* Padding */ <br>\nuint32_t ee_info; /* Additional information */ <br>\nuint32_t ee_data; /* Other data */ <br>\n/* More data may follow */ <br>\n};</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct sockaddr\n*SO_EE_OFFENDER(struct sock_extended_err *);</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>ee_errno</i>\ncontains the <i>errno</i> number of the queued error.\n<i>ee_origin</i> is the origin code of where the error\noriginated. The other fields are protocol-specific. The\nmacro <b>SOCK_EE_OFFENDER</b> returns a pointer to the\naddress of the network object where the error originated\nfrom given a pointer to the ancillary message. If this\naddress is not known, the <i>sa_family</i> member of the\n<i>sockaddr</i> contains <b>AF_UNSPEC</b> and the other\nfields of the <i>sockaddr</i> are undefined. The payload of\nthe packet that caused the error is passed as normal\ndata.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For local\nerrors, no address is passed (this can be checked with the\n<i>cmsg_len</i> member of the <i>cmsghdr</i>). For error\nreceives, the <b>MSG_ERRQUEUE</b> flag is set in the\n<i>msghdr</i>. After an error has been passed, the pending\nsocket error is regenerated based on the next queued error\nand will be passed on the next socket operation.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_OOB</b></p>\n\n<p style=\"margin-left:22%;\">This flag requests receipt of\nout-of-band data that would not be received in the normal\ndata stream. Some protocols place expedited data at the head\nof the normal data queue, and thus this flag cannot be used\nwith such protocols.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_PEEK</b></p>\n\n<p style=\"margin-left:22%;\">This flag causes the receive\noperation to return data from the beginning of the receive\nqueue without removing that data from the queue. Thus, a\nsubsequent receive call will return the same data.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_TRUNC</b> (since Linux\n2.2)</p>\n\n<p style=\"margin-left:22%;\">For raw (<b>AF_PACKET</b>),\nInternet datagram (since Linux 2.4.27/2.6.8), netlink (since\nLinux 2.6.22), and UNIX datagram (since Linux 3.4) sockets:\nreturn the real length of the packet or datagram, even when\nit was longer than the passed buffer.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For use with\nInternet stream sockets, see <a href=\"https://man.page/7/tcp\">tcp(7)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_WAITALL</b> (since Linux\n2.2)</p>\n\n<p style=\"margin-left:22%;\">This flag requests that the\noperation block until the full request is satisfied.\nHowever, the call may still return less data than requested\nif a signal is caught, an error or disconnect occurs, or the\nnext data to be received is of a different type than that\nreturned. This flag has no effect for datagram sockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>recvfrom()\n<br>\nrecvfrom</b>() places the received message into the buffer\n<i>buf</i>. The caller must specify the size of the buffer\nin <i>len</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>src_addr</i> is not NULL, and the underlying protocol\nprovides the source address of the message, that source\naddress is placed in the buffer pointed to by\n<i>src_addr</i>. In this case, <i>addrlen</i> is a\nvalue-result argument. Before the call, it should be\ninitialized to the size of the buffer associated with\n<i>src_addr</i>. Upon return, <i>addrlen</i> is updated to\ncontain the actual size of the source address. The returned\naddress is truncated if the buffer provided is too small; in\nthis case, <i>addrlen</i> will return a value greater than\nwas supplied to the call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the caller\nis not interested in the source address, <i>src_addr</i> and\n<i>addrlen</i> should be specified as NULL.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>recv()</b>\n<br>\nThe <b>recv</b>() call is normally used only on a\n<i>connected</i> socket (see <a href=\"https://man.page/2/connect\">connect(2)</a>). It is\nequivalent to the call:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">recvfrom(fd,\nbuf, len, flags, NULL, 0);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>recvmsg()</b>\n<br>\nThe <b>recvmsg</b>() call uses a <i>msghdr</i> structure to\nminimize the number of directly supplied arguments. This\nstructure is defined as follows in\n<i>&lt;sys/socket.h&gt;</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct iovec {\n/* Scatter/gather array items */ <br>\nvoid *iov_base; /* Starting address */ <br>\nsize_t iov_len; /* Number of bytes to transfer */ <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct msghdr {\n<br>\nvoid *msg_name; /* Optional address */ <br>\nsocklen_t msg_namelen; /* Size of address */ <br>\nstruct iovec *msg_iov; /* Scatter/gather array */ <br>\nsize_t msg_iovlen; /* # elements in msg_iov */ <br>\nvoid *msg_control; /* Ancillary data, see below */ <br>\nsize_t msg_controllen; /* Ancillary data buffer len */ <br>\nint msg_flags; /* Flags on received message */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>msg_name</i> field points to a caller-allocated buffer\nthat is used to return the source address if the socket is\nunconnected. The caller should set <i>msg_namelen</i> to the\nsize of this buffer before this call; upon return from a\nsuccessful call, <i>msg_namelen</i> will contain the length\nof the returned address. If the application does not need to\nknow the source address, <i>msg_name</i> can be specified as\nNULL.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields\n<i>msg_iov</i> and <i>msg_iovlen</i> describe scatter-gather\nlocations, as discussed in <a href=\"https://man.page/2/readv\">readv(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The field\n<i>msg_control</i>, which has length <i>msg_controllen</i>,\npoints to a buffer for other protocol control-related\nmessages or miscellaneous ancillary data. When\n<b>recvmsg</b>() is called, <i>msg_controllen</i> should\ncontain the length of the available buffer in\n<i>msg_control</i>; upon return from a successful call it\nwill contain the length of the control message sequence.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The messages\nare of the form:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct cmsghdr\n{ <br>\nsize_t cmsg_len; /* Data byte count, including header <br>\n(type is socklen_t in POSIX) */ <br>\nint cmsg_level; /* Originating protocol */ <br>\nint cmsg_type; /* Protocol-specific type */ <br>\n/* followed by <br>\nunsigned char cmsg_data[]; */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Ancillary data\nshould be accessed only by the macros defined in\n<a href=\"https://man.page/3/cmsg\">cmsg(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As an example,\nLinux uses this ancillary data mechanism to pass extended\nerrors, IP options, or file descriptors over UNIX domain\nsockets. For further information on the use of ancillary\ndata in various socket domains, see <a href=\"https://man.page/7/unix\">unix(7)</a> and\n<a href=\"https://man.page/7/ip\">ip(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>msg_flags</i> field in the <i>msghdr</i> is set on return\nof <b>recvmsg</b>(). It can contain several flags: <b><br>\nMSG_EOR</b></p>\n\n<p style=\"margin-left:22%;\">indicates end-of-record; the\ndata returned completed a record (generally used with\nsockets of type <b>SOCK_SEQPACKET</b>).</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_TRUNC</b></p>\n\n<p style=\"margin-left:22%;\">indicates that the trailing\nportion of a datagram was discarded because the datagram was\nlarger than the buffer supplied.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_CTRUNC</b></p>\n\n<p style=\"margin-left:22%;\">indicates that some control\ndata was discarded due to lack of space in the buffer for\nancillary data.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_OOB</b></p>\n\n<p style=\"margin-left:22%;\">is returned to indicate that\nexpedited or out-of-band data was received.</p>\n\n<p style=\"margin-left:11%;\"><b>MSG_ERRQUEUE</b></p>\n\n<p style=\"margin-left:22%;\">indicates that no data was\nreceived but an extended error from the socket error\nqueue.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These calls\nreturn the number of bytes received, or -1 if an error\noccurred. In the event of an error, <i>errno</i> is set to\nindicate the error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a stream\nsocket peer has performed an orderly shutdown, the return\nvalue will be 0 (the traditional &quot;end-of-file&quot;\nreturn).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Datagram\nsockets in various domains (e.g., the UNIX and Internet\ndomains) permit zero-length datagrams. When such a datagram\nis received, the return value is 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The value 0 may\nalso be returned if the requested number of bytes to receive\nfrom a stream socket was 0.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These are some\nstandard errors generated by the socket layer. Additional\nerrors may be generated and returned from the underlying\nprotocol modules; see their manual pages. <b><br>\nEAGAIN</b> or <b>EWOULDBLOCK</b></p>\n\n<p style=\"margin-left:22%;\">The socket is marked\nnonblocking and the receive operation would block, or a\nreceive timeout had been set and the timeout expired before\ndata was received. POSIX.1 allows either error to be\nreturned for this case, and does not require these constants\nto have the same value, so a portable application should\ncheck for both possibilities.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"76%\">\n\n\n<p>The argument <i>sockfd</i> is an invalid file\ndescriptor.</p> </td>\n<td width=\"2%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ECONNREFUSED</b></p>\n\n<p style=\"margin-left:22%;\">A remote host refused to allow\nthe network connection (typically because it is not running\nthe requested service).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The receive buffer pointer(s) point outside the\nprocess&rsquo;s address space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The receive was interrupted by delivery of a signal\nbefore any data was available; see <a href=\"https://man.page/7/signal\">signal(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Invalid argument passed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Could not allocate memory for <b>recvmsg</b>().</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTCONN</b></p>\n\n<p style=\"margin-left:22%;\">The socket is associated with a\nconnection-oriented protocol and has not been connected (see\n<a href=\"https://man.page/2/connect\">connect(2)</a> and <a href=\"https://man.page/2/accept\">accept(2)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>ENOTSOCK</b></p>\n\n<p style=\"margin-left:22%;\">The file descriptor\n<i>sockfd</i> does not refer to a socket.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008, 4.4BSD (these interfaces first appeared in\n4.2BSD).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1\ndescribes only the <b>MSG_OOB</b>, <b>MSG_PEEK</b>, and\n<b>MSG_WAITALL</b> flags.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a\nzero-length datagram is pending, <a href=\"https://man.page/2/read\">read(2)</a> and\n<b>recv</b>() with a <i>flags</i> argument of zero provide\ndifferent behavior. In this circumstance, <a href=\"https://man.page/2/read\">read(2)</a> has\nno effect (the datagram remains pending), while\n<b>recv</b>() consumes the pending datagram.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>socklen_t</i> type was invented by POSIX. See also\n<a href=\"https://man.page/2/accept\">accept(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1, the <i>msg_controllen</i> field of the\n<i>msghdr</i> structure should be typed as <i>socklen_t</i>,\nand the <i>msg_iovlen</i> field should be typed as\n<i>int</i>, but glibc currently types both as\n<i>size_t</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/2/recvmmsg\">recvmmsg(2)</a> for information about a Linux-specific\nsystem call that can be used to receive multiple datagrams\nin a single call.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">An example of\nthe use of <b>recvfrom</b>() is shown in\n<a href=\"https://man.page/3/getaddrinfo\">getaddrinfo(3)</a>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/fcntl\">fcntl(2)</a>,\n<a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/recvmmsg\">recvmmsg(2)</a>,\n<a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/shutdown\">shutdown(2)</a>, <a href=\"https://man.page/2/socket\">socket(2)</a>,\n<a href=\"https://man.page/3/cmsg\">cmsg(3)</a>, <a href=\"https://man.page/3/sockatmark\">sockatmark(3)</a>, <a href=\"https://man.page/7/ip\">ip(7)</a>,\n<a href=\"https://man.page/7/ipv6\">ipv6(7)</a>, <a href=\"https://man.page/7/socket\">socket(7)</a>, <a href=\"https://man.page/7/tcp\">tcp(7)</a>,\n<a href=\"https://man.page/7/udp\">udp(7)</a>, <a href=\"https://man.page/7/unix\">unix(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}