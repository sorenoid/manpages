{"name":"mremap","description":"mremap - remap\na virtual memory address","body":"\n\n<h1 align=\"center\">MREMAP</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">mremap - remap\na virtual memory address</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;sys/mman.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*mremap(void *</b><i>old_address</i><b>, size_t</b>\n<i>old_size</i><b>, <br>\nsize_t</b> <i>new_size</i><b>, int</b> <i>flags</i><b>, ...\n/* void *</b><i>new_address</i> <b>*/);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mremap</b>()\nexpands (or shrinks) an existing memory mapping, potentially\nmoving it at the same time (controlled by the <i>flags</i>\nargument and the available virtual address space).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>old_address</i>\nis the old address of the virtual memory block that you want\nto expand (or shrink). Note that <i>old_address</i> has to\nbe page aligned. <i>old_size</i> is the old size of the\nvirtual memory block. <i>new_size</i> is the requested size\nof the virtual memory block after the resize. An optional\nfifth argument, <i>new_address</i>, may be provided; see the\ndescription of <b>MREMAP_FIXED</b> below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the value of\n<i>old_size</i> is zero, and <i>old_address</i> refers to a\nshareable mapping (see <a href=\"https://man.page/2/mmap\">mmap(2)</a> <b>MAP_SHARED</b>),\nthen <b>mremap</b>() will create a new mapping of the same\npages. <i>new_size</i> will be the size of the new mapping\nand the location of the new mapping may be specified with\n<i>new_address</i>; see the description of\n<b>MREMAP_FIXED</b> below. If a new mapping is requested via\nthis method, then the <b>MREMAP_MAYMOVE</b> flag must also\nbe specified.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> bit-mask argument may be 0, or include the\nfollowing flags: <b><br>\nMREMAP_MAYMOVE</b></p>\n\n<p style=\"margin-left:22%;\">By default, if there is not\nsufficient space to expand a mapping at its current\nlocation, then <b>mremap</b>() fails. If this flag is\nspecified, then the kernel is permitted to relocate the\nmapping to a new virtual address, if necessary. If the\nmapping is relocated, then absolute pointers into the old\nmapping location become invalid (offsets relative to the\nstarting address of the mapping should be employed).</p>\n\n<p style=\"margin-left:11%;\"><b>MREMAP_FIXED</b> (since\nLinux 2.3.31)</p>\n\n<p style=\"margin-left:22%;\">This flag serves a similar\npurpose to the <b>MAP_FIXED</b> flag of <a href=\"https://man.page/2/mmap\">mmap(2)</a>. If\nthis flag is specified, then <b>mremap</b>() accepts a fifth\nargument, <i>void&nbsp;*new_address</i>, which specifies a\npage-aligned address to which the mapping must be moved. Any\nprevious mapping at the address range specified by\n<i>new_address</i> and <i>new_size</i> is unmapped.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>MREMAP_FIXED</b> is specified, then <b>MREMAP_MAYMOVE</b>\nmust also be specified.</p>\n\n<p style=\"margin-left:11%;\"><b>MREMAP_DONTUNMAP</b> (since\nLinux 5.7)</p>\n\n<p style=\"margin-left:22%;\">This flag, which must be used\nin conjunction with <b>MREMAP_MAYMOVE</b>, remaps a mapping\nto a new address but does not unmap the mapping at\n<i>old_address</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>MREMAP_DONTUNMAP</b> flag can be used only with private\nanonymous mappings (see the description of\n<b>MAP_PRIVATE</b> and <b>MAP_ANONYMOUS</b> in\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">After\ncompletion, any access to the range specified by\n<i>old_address</i> and <i>old_size</i> will result in a page\nfault. The page fault will be handled by a\n<a href=\"https://man.page/2/userfaultfd\">userfaultfd(2)</a> handler if the address is in a range\npreviously registered with <a href=\"https://man.page/2/userfaultfd\">userfaultfd(2)</a>. Otherwise,\nthe kernel allocates a zero-filled page to handle the\nfault.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>MREMAP_DONTUNMAP</b> flag may be used to atomically move\na mapping while leaving the source mapped. See NOTES for\nsome possible applications of <b>MREMAP_DONTUNMAP</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the memory\nsegment specified by <i>old_address</i> and <i>old_size</i>\nis locked (using <a href=\"https://man.page/2/mlock\">mlock(2)</a> or similar), then this lock\nis maintained when the segment is resized and/or relocated.\nAs a consequence, the amount of memory locked by the process\nmay change.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success\n<b>mremap</b>() returns a pointer to the new virtual memory\narea. On error, the value <b>MAP_FAILED</b> (that is,\n<i>(void&nbsp;*)&nbsp;-1</i>) is returned, and <i>errno</i>\nis set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The caller tried to expand a\nmemory segment that is locked, but this was not possible\nwithout exceeding the <b>RLIMIT_MEMLOCK</b> resource\nlimit.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Some address in the range <i>old_address</i> to\n<i>old_address</i>+<i>old_size</i> is an invalid virtual\nmemory address for this process. You can also get\n<b>EFAULT</b> even if there exist mappings that cover the\nwhole address space requested, but those mappings are of\ndifferent types.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An invalid argument was given. Possible causes are:</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">*</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\"></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\"><i>old_address</i> was not page\naligned;</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>a value other than <b>MREMAP_MAYMOVE</b> or\n<b>MREMAP_FIXED</b> or <b>MREMAP_DONTUNMAP</b> was specified\nin <i>flags</i>;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><i>new_size</i> was zero;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><i>new_size</i> or <i>new_address</i> was invalid;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>the new address range specified by <i>new_address</i>\nand <i>new_size</i> overlapped the old address range\nspecified by <i>old_address</i> and <i>old_size</i>;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>MREMAP_FIXED</b> or <b>MREMAP_DONTUNMAP</b> was\nspecified without also specifying <b>MREMAP_MAYMOVE</b>;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>MREMAP_DONTUNMAP</b> was specified, but one or more\npages in the range specified by <i>old_address</i> and\n<i>old_size</i> were not private anonymous;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>MREMAP_DONTUNMAP</b> was specified and\n<i>old_size</i> was not equal to <i>new_size</i>;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><i>old_size</i> was zero and <i>old_address</i> does not\nrefer to a shareable mapping (but see BUGS);</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><i>old_size</i> was zero and the <b>MREMAP_MAYMOVE</b>\nflag was not specified.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Not enough\nmemory was available to complete the operation. Possible\ncauses are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\">The memory area cannot be\nexpanded at the current virtual address, and the\n<b>MREMAP_MAYMOVE</b> flag is not set in <i>flags</i>. Or,\nthere is not enough (virtual) memory available.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>MREMAP_DONTUNMAP</b> was used causing a new mapping\nto be created that would exceed the (virtual) memory\navailable. Or, it would exceed the maximum number of allowed\nmappings.</p> </td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This call is\nLinux-specific, and should not be used in programs intended\nto be portable.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mremap</b>()\nchanges the mapping between virtual addresses and memory\npages. This can be used to implement a very efficient\n<a href=\"https://man.page/3/realloc\">realloc(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux,\nmemory is divided into pages. A process has (one or) several\nlinear virtual memory segments. Each virtual memory segment\nhas one or more mappings to real memory pages (in the page\ntable). Each virtual memory segment has its own protection\n(access rights), which may cause a segmentation violation\n(<b>SIGSEGV</b>) if the memory is accessed incorrectly\n(e.g., writing to a read-only segment). Accessing virtual\nmemory outside of the segments will also cause a\nsegmentation violation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>mremap</b>() is used to move or expand an area locked\nwith <a href=\"https://man.page/2/mlock\">mlock(2)</a> or equivalent, the <b>mremap</b>() call\nwill make a best effort to populate the new area but will\nnot fail with <b>ENOMEM</b> if the area cannot be\npopulated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prior to\nversion 2.4, glibc did not expose the definition of\n<b>MREMAP_FIXED</b>, and the prototype for <b>mremap</b>()\ndid not allow for the <i>new_address</i> argument.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>MREMAP_DONTUNMAP\nuse cases</b> <br>\nPossible applications for <b>MREMAP_DONTUNMAP</b>\ninclude:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Non-cooperative\n<a href=\"https://man.page/2/userfaultfd\">userfaultfd(2)</a>: an application can yank out a virtual\naddress range using <b>MREMAP_DONTUNMAP</b> and then employ\na <a href=\"https://man.page/2/userfaultfd\">userfaultfd(2)</a> handler to handle the page faults\nthat subsequently occur as other threads in the process\ntouch pages in the yanked range.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Garbage collection: <b>MREMAP_DONTUNMAP</b> can be used\nin conjunction with <a href=\"https://man.page/2/userfaultfd\">userfaultfd(2)</a> to implement\ngarbage collection algorithms (e.g., in a Java virtual\nmachine). Such an implementation can be cheaper (and\nsimpler) than conventional garbage collection techniques\nthat involve marking pages with protection <b>PROT_NONE</b>\nin conjunction with the of a <b>SIGSEGV</b> handler to catch\naccesses to those pages.</p></td></tr>\n</table>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n4.14, if <i>old_size</i> was zero and the mapping referred\nto by <i>old_address</i> was a private mapping\n(<a href=\"https://man.page/2/mmap\">mmap(2)</a> <b>MAP_PRIVATE</b>), <b>mremap</b>() created\na new private mapping unrelated to the original mapping.\nThis behavior was unintended and probably unexpected in\nuser-space applications (since the intention of\n<b>mremap</b>() is to create a new mapping based on the\noriginal mapping). Since Linux 4.14, <b>mremap</b>() fails\nwith the error <b>EINVAL</b> in this scenario.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/brk\">brk(2)</a>,\n<a href=\"https://man.page/2/getpagesize\">getpagesize(2)</a>, <a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>, <a href=\"https://man.page/2/mlock\">mlock(2)</a>,\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/sbrk\">sbrk(2)</a>, <a href=\"https://man.page/3/malloc\">malloc(3)</a>,\n<a href=\"https://man.page/3/realloc\">realloc(3)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Your favorite\ntext book on operating systems for more information on paged\nmemory (e.g., <i>Modern Operating Systems</i> by Andrew S.\nTanenbaum, <i>Inside Linux</i> by Randolph Bentson, <i>The\nDesign of the UNIX Operating System</i> by Maurice J.\nBach)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}