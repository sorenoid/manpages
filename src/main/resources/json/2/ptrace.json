{"name":"ptrace","description":"ptrace - process trace","body":"\n\n<h1 align=\"center\">PTRACE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace -\nprocess trace</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/ptrace.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>long\nptrace(enum __ptrace_request</b> <i>request</i><b>,\npid_t</b> <i>pid</i><b>, <br>\nvoid *</b><i>addr</i><b>, void *</b><i>data</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>ptrace</b>() system call provides a means by which one\nprocess (the &quot;tracer&quot;) may observe and control the\nexecution of another process (the &quot;tracee&quot;), and\nexamine and change the tracee&rsquo;s memory and registers.\nIt is primarily used to implement breakpoint debugging and\nsystem call tracing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A tracee first\nneeds to be attached to the tracer. Attachment and\nsubsequent commands are per thread: in a multithreaded\nprocess, every thread can be individually attached to a\n(potentially different) tracer, or left not attached and\nthus not debugged. Therefore, &quot;tracee&quot; always\nmeans &quot;(one) thread&quot;, never &quot;a (possibly\nmultithreaded) process&quot;. Ptrace commands are always\nsent to a specific tracee using a call of the form</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_foo,\npid, ...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where\n<i>pid</i> is the thread ID of the corresponding Linux\nthread.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(Note that in\nthis page, a &quot;multithreaded process&quot; means a\nthread group consisting of threads created using the\n<a href=\"https://man.page/2/clone\">clone(2)</a> <b>CLONE_THREAD</b> flag.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process can\ninitiate a trace by calling <a href=\"https://man.page/2/fork\">fork(2)</a> and having the\nresulting child do a <b>PTRACE_TRACEME</b>, followed\n(typically) by an <a href=\"https://man.page/2/execve\">execve(2)</a>. Alternatively, one\nprocess may commence tracing another process using\n<b>PTRACE_ATTACH</b> or <b>PTRACE_SEIZE</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">While being\ntraced, the tracee will stop each time a signal is\ndelivered, even if the signal is being ignored. (An\nexception is <b>SIGKILL</b>, which has its usual effect.)\nThe tracer will be notified at its next call to\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> (or one of the related &quot;wait&quot;\nsystem calls); that call will return a <i>status</i> value\ncontaining information that indicates the cause of the stop\nin the tracee. While the tracee is stopped, the tracer can\nuse various ptrace requests to inspect and modify the\ntracee. The tracer then causes the tracee to continue,\noptionally ignoring the delivered signal (or even delivering\na different signal instead).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>PTRACE_O_TRACEEXEC</b> option is not in effect, all\nsuccessful calls to <a href=\"https://man.page/2/execve\">execve(2)</a> by the traced process\nwill cause it to be sent a <b>SIGTRAP</b> signal, giving the\nparent a chance to gain control before the new program\nbegins execution.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the tracer\nis finished tracing, it can cause the tracee to continue\nexecuting in a normal, untraced mode via\n<b>PTRACE_DETACH</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The value of\n<i>request</i> determines the action to be performed:\n<b><br>\nPTRACE_TRACEME</b></p>\n\n<p style=\"margin-left:22%;\">Indicate that this process is\nto be traced by its parent. A process probably\nshouldn&rsquo;t make this request if its parent isn&rsquo;t\nexpecting to trace it. (<i>pid</i>, <i>addr</i>, and\n<i>data</i> are ignored.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>PTRACE_TRACEME</b> request is used only by the tracee;\nthe remaining requests are used only by the tracer. In the\nfollowing requests, <i>pid</i> specifies the thread ID of\nthe tracee to be acted on. For requests other than\n<b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>,\n<b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>, the tracee\nmust be stopped.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_PEEKTEXT</b>,\n<b>PTRACE_PEEKDATA</b></p>\n\n<p style=\"margin-left:22%;\">Read a word at the address\n<i>addr</i> in the tracee&rsquo;s memory, returning the word\nas the result of the <b>ptrace</b>() call. Linux does not\nhave separate text and data address spaces, so these two\nrequests are currently equivalent. (<i>data</i> is ignored;\nbut see NOTES.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_PEEKUSER</b></p>\n\n<p style=\"margin-left:22%;\">Read a word at offset\n<i>addr</i> in the tracee&rsquo;s USER area, which holds the\nregisters and other information about the process (see\n<i>&lt;sys/user.h&gt;</i>). The word is returned as the\nresult of the <b>ptrace</b>() call. Typically, the offset\nmust be word-aligned, though this might vary by\narchitecture. See NOTES. (<i>data</i> is ignored; but see\nNOTES.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_POKETEXT</b>,\n<b>PTRACE_POKEDATA</b></p>\n\n<p style=\"margin-left:22%;\">Copy the word <i>data</i> to\nthe address <i>addr</i> in the tracee&rsquo;s memory. As for\n<b>PTRACE_PEEKTEXT</b> and <b>PTRACE_PEEKDATA</b>, these two\nrequests are currently equivalent.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_POKEUSER</b></p>\n\n<p style=\"margin-left:22%;\">Copy the word <i>data</i> to\noffset <i>addr</i> in the tracee&rsquo;s USER area. As for\n<b>PTRACE_PEEKUSER</b>, the offset must typically be\nword-aligned. In order to maintain the integrity of the\nkernel, some modifications to the USER area are\ndisallowed.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_GETREGS</b>,\n<b>PTRACE_GETFPREGS</b></p>\n\n<p style=\"margin-left:22%;\">Copy the tracee&rsquo;s\ngeneral-purpose or floating-point registers, respectively,\nto the address <i>data</i> in the tracer. See\n<i>&lt;sys/user.h&gt;</i> for information on the format of\nthis data. (<i>addr</i> is ignored.) Note that SPARC systems\nhave the meaning of <i>data</i> and <i>addr</i> reversed;\nthat is, <i>data</i> is ignored and the registers are copied\nto the address <i>addr</i>. <b>PTRACE_GETREGS</b> and\n<b>PTRACE_GETFPREGS</b> are not present on all\narchitectures.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_GETREGSET</b> (since\nLinux 2.6.34)</p>\n\n<p style=\"margin-left:22%;\">Read the tracee&rsquo;s\nregisters. <i>addr</i> specifies, in an\narchitecture-dependent way, the type of registers to be\nread. <b>NT_PRSTATUS</b> (with numerical value 1) usually\nresults in reading of general-purpose registers. If the CPU\nhas, for example, floating-point and/or vector registers,\nthey can be retrieved by setting <i>addr</i> to the\ncorresponding <b>NT_foo</b> constant. <i>data</i> points to\na <b>struct iovec</b>, which describes the destination\nbuffer&rsquo;s location and length. On return, the kernel\nmodifies <b>iov.len</b> to indicate the actual number of\nbytes returned.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SETREGS</b>,\n<b>PTRACE_SETFPREGS</b></p>\n\n<p style=\"margin-left:22%;\">Modify the tracee&rsquo;s\ngeneral-purpose or floating-point registers, respectively,\nfrom the address <i>data</i> in the tracer. As for\n<b>PTRACE_POKEUSER</b>, some general-purpose register\nmodifications may be disallowed. (<i>addr</i> is ignored.)\nNote that SPARC systems have the meaning of <i>data</i> and\n<i>addr</i> reversed; that is, <i>data</i> is ignored and\nthe registers are copied from the address <i>addr</i>.\n<b>PTRACE_SETREGS</b> and <b>PTRACE_SETFPREGS</b> are not\npresent on all architectures.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SETREGSET</b> (since\nLinux 2.6.34)</p>\n\n<p style=\"margin-left:22%;\">Modify the tracee&rsquo;s\nregisters. The meaning of <i>addr</i> and <i>data</i> is\nanalogous to <b>PTRACE_GETREGSET</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_GETSIGINFO</b> (since\nLinux 2.3.99-pre6)</p>\n\n<p style=\"margin-left:22%;\">Retrieve information about the\nsignal that caused the stop. Copy a <i>siginfo_t</i>\nstructure (see <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>) from the tracee to the\naddress <i>data</i> in the tracer. (<i>addr</i> is\nignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SETSIGINFO</b> (since\nLinux 2.3.99-pre6)</p>\n\n<p style=\"margin-left:22%;\">Set signal information: copy a\n<i>siginfo_t</i> structure from the address <i>data</i> in\nthe tracer to the tracee. This will affect only signals that\nwould normally be delivered to the tracee and were caught by\nthe tracer. It may be difficult to tell these normal signals\nfrom synthetic signals generated by <b>ptrace</b>() itself.\n(<i>addr</i> is ignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_PEEKSIGINFO</b>\n(since Linux 3.10)</p>\n\n<p style=\"margin-left:22%;\">Retrieve <i>siginfo_t</i>\nstructures without removing signals from a queue.\n<i>addr</i> points to a <i>ptrace_peeksiginfo_args</i>\nstructure that specifies the ordinal position from which\ncopying of signals should start, and the number of signals\nto copy. <i>siginfo_t</i> structures are copied into the\nbuffer pointed to by <i>data</i>. The return value contains\nthe number of copied signals (zero indicates that there is\nno signal corresponding to the specified ordinal position).\nWithin the returned <i>siginfo</i> structures, the\n<i>si_code</i> field includes information (<b>__SI_CHLD</b>,\n<b>__SI_FAULT</b>, etc.) that are not otherwise exposed to\nuser space.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nptrace_peeksiginfo_args { <br>\nu64 off; /* Ordinal position in queue at which <br>\nto start copying signals */ <br>\nu32 flags; /* PTRACE_PEEKSIGINFO_SHARED or 0 */ <br>\ns32 nr; /* Number of signals to copy */ <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Currently,\nthere is only one flag, <b>PTRACE_PEEKSIGINFO_SHARED</b>,\nfor dumping signals from the process-wide signal queue. If\nthis flag is not set, signals are read from the per-thread\nqueue of the specified thread.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_GETSIGMASK</b> (since\nLinux 3.11)</p>\n\n<p style=\"margin-left:22%;\">Place a copy of the mask of\nblocked signals (see <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>) in the buffer\npointed to by <i>data</i>, which should be a pointer to a\nbuffer of type <i>sigset_t</i>. The <i>addr</i> argument\ncontains the size of the buffer pointed to by <i>data</i>\n(i.e., <i>sizeof(sigset_t)</i>).</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SETSIGMASK</b> (since\nLinux 3.11)</p>\n\n<p style=\"margin-left:22%;\">Change the mask of blocked\nsignals (see <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>) to the value specified\nin the buffer pointed to by <i>data</i>, which should be a\npointer to a buffer of type <i>sigset_t</i>. The <i>addr</i>\nargument contains the size of the buffer pointed to by\n<i>data</i> (i.e., <i>sizeof(sigset_t)</i>).</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SETOPTIONS</b> (since\nLinux 2.4.6; see BUGS for caveats)</p>\n\n<p style=\"margin-left:22%;\">Set ptrace options from\n<i>data</i>. (<i>addr</i> is ignored.) <i>data</i> is\ninterpreted as a bit mask of options, which are specified by\nthe following flags: <b><br>\nPTRACE_O_EXITKILL</b> (since Linux 3.8)</p>\n\n<p style=\"margin-left:32%;\">Send a <b>SIGKILL</b> signal to\nthe tracee if the tracer exits. This option is useful for\nptrace jailers that want to ensure that tracees can never\nescape the tracer&rsquo;s control.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACECLONE</b>\n(since Linux 2.5.46)</p>\n\n<p style=\"margin-left:32%;\">Stop the tracee at the next\n<a href=\"https://man.page/2/clone\">clone(2)</a> and automatically start tracing the newly\ncloned process, which will start with a <b>SIGSTOP</b>, or\n<b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> by the tracer will return a <i>status</i>\nvalue such that</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">status&gt;&gt;8\n== (SIGTRAP | (PTRACE_EVENT_CLONE&lt;&lt;8))</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The PID of the\nnew process can be retrieved with\n<b>PTRACE_GETEVENTMSG</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This option may\nnot catch <a href=\"https://man.page/2/clone\">clone(2)</a> calls in all cases. If the tracee\ncalls <a href=\"https://man.page/2/clone\">clone(2)</a> with the <b>CLONE_VFORK</b> flag,\n<b>PTRACE_EVENT_VFORK</b> will be delivered instead if\n<b>PTRACE_O_TRACEVFORK</b> is set; otherwise if the tracee\ncalls <a href=\"https://man.page/2/clone\">clone(2)</a> with the exit signal set to\n<b>SIGCHLD</b>, <b>PTRACE_EVENT_FORK</b> will be delivered\nif <b>PTRACE_O_TRACEFORK</b> is set.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACEEXEC</b>\n(since Linux 2.5.46)</p>\n\n<p style=\"margin-left:32%;\">Stop the tracee at the next\n<a href=\"https://man.page/2/execve\">execve(2)</a>. A <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> by the tracer will\nreturn a <i>status</i> value such that</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">status&gt;&gt;8\n== (SIGTRAP | (PTRACE_EVENT_EXEC&lt;&lt;8))</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the execing\nthread is not a thread group leader, the thread ID is reset\nto thread group leader&rsquo;s ID before this stop. Since\nLinux 3.0, the former thread ID can be retrieved with\n<b>PTRACE_GETEVENTMSG</b>.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACEEXIT</b>\n(since Linux 2.5.60)</p>\n\n<p style=\"margin-left:32%;\">Stop the tracee at exit. A\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> by the tracer will return a <i>status</i>\nvalue such that</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">status&gt;&gt;8\n== (SIGTRAP | (PTRACE_EVENT_EXIT&lt;&lt;8))</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\ntracee&rsquo;s exit status can be retrieved with\n<b>PTRACE_GETEVENTMSG</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The tracee is\nstopped early during process exit, when registers are still\navailable, allowing the tracer to see where the exit\noccurred, whereas the normal exit notification is done after\nthe process is finished exiting. Even though context is\navailable, the tracer cannot prevent the exit from happening\nat this point.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACEFORK</b>\n(since Linux 2.5.46)</p>\n\n<p style=\"margin-left:32%;\">Stop the tracee at the next\n<a href=\"https://man.page/2/fork\">fork(2)</a> and automatically start tracing the newly\nforked process, which will start with a <b>SIGSTOP</b>, or\n<b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> by the tracer will return a <i>status</i>\nvalue such that</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">status&gt;&gt;8\n== (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8))</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The PID of the\nnew process can be retrieved with\n<b>PTRACE_GETEVENTMSG</b>.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACESYSGOOD</b>\n(since Linux 2.4.6)</p>\n\n<p style=\"margin-left:32%;\">When delivering system call\ntraps, set bit 7 in the signal number (i.e., deliver\n<i>SIGTRAP|0x80</i>). This makes it easy for the tracer to\ndistinguish normal traps from those caused by a system\ncall.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACEVFORK</b>\n(since Linux 2.5.46)</p>\n\n<p style=\"margin-left:32%;\">Stop the tracee at the next\n<a href=\"https://man.page/2/vfork\">vfork(2)</a> and automatically start tracing the newly\nvforked process, which will start with a <b>SIGSTOP</b>, or\n<b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> by the tracer will return a <i>status</i>\nvalue such that</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">status&gt;&gt;8\n== (SIGTRAP | (PTRACE_EVENT_VFORK&lt;&lt;8))</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The PID of the\nnew process can be retrieved with\n<b>PTRACE_GETEVENTMSG</b>.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACEVFORKDONE</b>\n(since Linux 2.5.60)</p>\n\n<p style=\"margin-left:32%;\">Stop the tracee at the\ncompletion of the next <a href=\"https://man.page/2/vfork\">vfork(2)</a>. A <a href=\"https://man.page/2/waitpid\">waitpid(2)</a>\nby the tracer will return a <i>status</i> value such\nthat</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">status&gt;&gt;8\n== (SIGTRAP | (PTRACE_EVENT_VFORK_DONE&lt;&lt;8))</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The PID of the\nnew process can (since Linux 2.6.18) be retrieved with\n<b>PTRACE_GETEVENTMSG</b>.</p>\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_TRACESECCOMP</b>\n(since Linux 3.5)</p>\n\n<p style=\"margin-left:32%;\">Stop the tracee when a\n<a href=\"https://man.page/2/seccomp\">seccomp(2)</a> <b>SECCOMP_RET_TRACE</b> rule is\ntriggered. A <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> by the tracer will return a\n<i>status</i> value such that</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">status&gt;&gt;8\n== (SIGTRAP | (PTRACE_EVENT_SECCOMP&lt;&lt;8))</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">While this\ntriggers a <b>PTRACE_EVENT</b> stop, it is similar to a\nsyscall-enter-stop. For details, see the note on\n<b>PTRACE_EVENT_SECCOMP</b> below. The seccomp event message\ndata (from the <b>SECCOMP_RET_DATA</b> portion of the\nseccomp filter rule) can be retrieved with\n<b>PTRACE_GETEVENTMSG</b>.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PTRACE_O_SUSPEND_SECCOMP</b>\n(since Linux 4.3)</p>\n\n<p style=\"margin-left:32%;\">Suspend the tracee&rsquo;s\nseccomp protections. This applies regardless of mode, and\ncan be used when the tracee has not yet installed seccomp\nfilters. That is, a valid use case is to suspend a\ntracee&rsquo;s seccomp protections before they are installed\nby the tracee, let the tracee install the filters, and then\nclear this flag when the filters should be resumed. Setting\nthis option requires that the tracer have the\n<b>CAP_SYS_ADMIN</b> capability, not have any seccomp\nprotections installed, and not have\n<b>PTRACE_O_SUSPEND_SECCOMP</b> set on itself.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_GETEVENTMSG</b>\n(since Linux 2.5.46)</p>\n\n<p style=\"margin-left:22%;\">Retrieve a message (as an\n<i>unsigned long</i>) about the ptrace event that just\nhappened, placing it at the address <i>data</i> in the\ntracer. For <b>PTRACE_EVENT_EXIT</b>, this is the\ntracee&rsquo;s exit status. For <b>PTRACE_EVENT_FORK</b>,\n<b>PTRACE_EVENT_VFORK</b>, <b>PTRACE_EVENT_VFORK_DONE</b>,\nand <b>PTRACE_EVENT_CLONE</b>, this is the PID of the new\nprocess. For <b>PTRACE_EVENT_SECCOMP</b>, this is the\n<a href=\"https://man.page/2/seccomp\">seccomp(2)</a> filter&rsquo;s <b>SECCOMP_RET_DATA</b>\nassociated with the triggered rule. (<i>addr</i> is\nignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_CONT</b></p>\n\n<p style=\"margin-left:22%;\">Restart the stopped tracee\nprocess. If <i>data</i> is nonzero, it is interpreted as the\nnumber of a signal to be delivered to the tracee; otherwise,\nno signal is delivered. Thus, for example, the tracer can\ncontrol whether a signal sent to the tracee is delivered or\nnot. (<i>addr</i> is ignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SYSCALL</b>,\n<b>PTRACE_SINGLESTEP</b></p>\n\n<p style=\"margin-left:22%;\">Restart the stopped tracee as\nfor <b>PTRACE_CONT</b>, but arrange for the tracee to be\nstopped at the next entry to or exit from a system call, or\nafter execution of a single instruction, respectively. (The\ntracee will also, as usual, be stopped upon receipt of a\nsignal.) From the tracer&rsquo;s perspective, the tracee\nwill appear to have been stopped by receipt of a\n<b>SIGTRAP</b>. So, for <b>PTRACE_SYSCALL</b>, for example,\nthe idea is to inspect the arguments to the system call at\nthe first stop, then do another <b>PTRACE_SYSCALL</b> and\ninspect the return value of the system call at the second\nstop. The <i>data</i> argument is treated as for\n<b>PTRACE_CONT</b>. (<i>addr</i> is ignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SET_SYSCALL</b>\n(since Linux 2.6.16)</p>\n\n<p style=\"margin-left:22%;\">When in syscall-enter-stop,\nchange the number of the system call that is about to be\nexecuted to the number specified in the <i>data</i>\nargument. The <i>addr</i> argument is ignored. This request\nis currently supported only on arm (and arm64, though only\nfor backwards compatibility), but most other architectures\nhave other means of accomplishing this (usually by changing\nthe register that the userland code passed the system call\nnumber in).</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SYSEMU</b>,\n<b>PTRACE_SYSEMU_SINGLESTEP</b> (since Linux 2.6.14)</p>\n\n<p style=\"margin-left:22%;\">For <b>PTRACE_SYSEMU</b>,\ncontinue and stop on entry to the next system call, which\nwill not be executed. See the documentation on syscall-stops\nbelow. For <b>PTRACE_SYSEMU_SINGLESTEP</b>, do the same but\nalso singlestep if not a system call. This call is used by\nprograms like User Mode Linux that want to emulate all the\ntracee&rsquo;s system calls. The <i>data</i> argument is\ntreated as for <b>PTRACE_CONT</b>. The <i>addr</i> argument\nis ignored. These requests are currently supported only on\nx86.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_LISTEN</b> (since\nLinux 3.4)</p>\n\n<p style=\"margin-left:22%;\">Restart the stopped tracee, but\nprevent it from executing. The resulting state of the tracee\nis similar to a process which has been stopped by a\n<b>SIGSTOP</b> (or other stopping signal). See the\n&quot;group-stop&quot; subsection for additional\ninformation. <b>PTRACE_LISTEN</b> works only on tracees\nattached by <b>PTRACE_SEIZE</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_KILL</b></p>\n\n<p style=\"margin-left:22%;\">Send the tracee a\n<b>SIGKILL</b> to terminate it. (<i>addr</i> and <i>data</i>\nare ignored.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>This\noperation is deprecated; do not use it!</i> Instead, send a\n<b>SIGKILL</b> directly using <a href=\"https://man.page/2/kill\">kill(2)</a> or\n<a href=\"https://man.page/2/tgkill\">tgkill(2)</a>. The problem with <b>PTRACE_KILL</b> is\nthat it requires the tracee to be in signal-delivery-stop,\notherwise it may not work (i.e., may complete successfully\nbut won&rsquo;t kill the tracee). By contrast, sending a\n<b>SIGKILL</b> directly has no such limitation.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_INTERRUPT</b> (since\nLinux 3.4)</p>\n\n<p style=\"margin-left:22%;\">Stop a tracee. If the tracee is\nrunning or sleeping in kernel space and\n<b>PTRACE_SYSCALL</b> is in effect, the system call is\ninterrupted and syscall-exit-stop is reported. (The\ninterrupted system call is restarted when the tracee is\nrestarted.) If the tracee was already stopped by a signal\nand <b>PTRACE_LISTEN</b> was sent to it, the tracee stops\nwith <b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i>\nreturns the stop signal. If any other ptrace-stop is\ngenerated at the same time (for example, if a signal is sent\nto the tracee), this ptrace-stop happens. If none of the\nabove applies (for example, if the tracee is running in user\nspace), it stops with <b>PTRACE_EVENT_STOP</b> with\n<i>WSTOPSIG(status)</i> == <b>SIGTRAP</b>.\n<b>PTRACE_INTERRUPT</b> only works on tracees attached by\n<b>PTRACE_SEIZE</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_ATTACH</b></p>\n\n<p style=\"margin-left:22%;\">Attach to the process specified\nin <i>pid</i>, making it a tracee of the calling process.\nThe tracee is sent a <b>SIGSTOP</b>, but will not\nnecessarily have stopped by the completion of this call; use\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> to wait for the tracee to stop. See the\n&quot;Attaching and detaching&quot; subsection for\nadditional information. (<i>addr</i> and <i>data</i> are\nignored.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Permission to\nperform a <b>PTRACE_ATTACH</b> is governed by a ptrace\naccess mode <b>PTRACE_MODE_ATTACH_REALCREDS</b> check; see\nbelow.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SEIZE</b> (since\nLinux 3.4)</p>\n\n<p style=\"margin-left:22%;\">Attach to the process specified\nin <i>pid</i>, making it a tracee of the calling process.\nUnlike <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b> does not\nstop the process. Group-stops are reported as\n<b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i> returns\nthe stop signal. Automatically attached children stop with\n<b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i> returns\n<b>SIGTRAP</b> instead of having <b>SIGSTOP</b> signal\ndelivered to them. <a href=\"https://man.page/2/execve\">execve(2)</a> does not deliver an\nextra <b>SIGTRAP</b>. Only a <b>PTRACE_SEIZE</b>d process\ncan accept <b>PTRACE_INTERRUPT</b> and <b>PTRACE_LISTEN</b>\ncommands. The &quot;seized&quot; behavior just described is\ninherited by children that are automatically attached using\n<b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, and\n<b>PTRACE_O_TRACECLONE</b>. <i>addr</i> must be zero.\n<i>data</i> contains a bit mask of ptrace options to\nactivate immediately.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Permission to\nperform a <b>PTRACE_SEIZE</b> is governed by a ptrace access\nmode <b>PTRACE_MODE_ATTACH_REALCREDS</b> check; see\nbelow.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SECCOMP_GET_FILTER</b>\n(since Linux 4.4)</p>\n\n<p style=\"margin-left:22%;\">This operation allows the\ntracer to dump the tracee&rsquo;s classic BPF filters.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>addr</i> is\nan integer specifying the index of the filter to be dumped.\nThe most recently installed filter has the index 0. If\n<i>addr</i> is greater than the number of installed filters,\nthe operation fails with the error <b>ENOENT</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>data</i> is\neither a pointer to a <i>struct sock_filter</i> array that\nis large enough to store the BPF program, or NULL if the\nprogram is not to be stored.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Upon success,\nthe return value is the number of instructions in the BPF\nprogram. If <i>data</i> was NULL, then this return value can\nbe used to correctly size the <i>struct sock_filter</i>\narray passed in a subsequent call.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This operation\nfails with the error <b>EACCES</b> if the caller does not\nhave the <b>CAP_SYS_ADMIN</b> capability or if the caller is\nin strict or filter seccomp mode. If the filter referred to\nby <i>addr</i> is not a classic BPF filter, the operation\nfails with the error <b>EMEDIUMTYPE</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This operation\nis available if the kernel was configured with both the\n<b>CONFIG_SECCOMP_FILTER</b> and the\n<b>CONFIG_CHECKPOINT_RESTORE</b> options.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_DETACH</b></p>\n\n<p style=\"margin-left:22%;\">Restart the stopped tracee as\nfor <b>PTRACE_CONT</b>, but first detach from it. Under\nLinux, a tracee can be detached in this way regardless of\nwhich method was used to initiate tracing. (<i>addr</i> is\nignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_GET_THREAD_AREA</b>\n(since Linux 2.6.0)</p>\n\n<p style=\"margin-left:22%;\">This operation performs a\nsimilar task to <a href=\"https://man.page/2/get_thread_area\">get_thread_area(2)</a>. It reads the TLS\nentry in the GDT whose index is given in <i>addr</i>,\nplacing a copy of the entry into the <i>struct user_desc</i>\npointed to by <i>data</i>. (By contrast with\n<a href=\"https://man.page/2/get_thread_area\">get_thread_area(2)</a>, the <i>entry_number</i> of the\n<i>struct user_desc</i> is ignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_SET_THREAD_AREA</b>\n(since Linux 2.6.0)</p>\n\n<p style=\"margin-left:22%;\">This operation performs a\nsimilar task to <a href=\"https://man.page/2/set_thread_area\">set_thread_area(2)</a>. It sets the TLS\nentry in the GDT whose index is given in <i>addr</i>,\nassigning it the data supplied in the <i>struct\nuser_desc</i> pointed to by <i>data</i>. (By contrast with\n<a href=\"https://man.page/2/set_thread_area\">set_thread_area(2)</a>, the <i>entry_number</i> of the\n<i>struct user_desc</i> is ignored; in other words, this\nptrace operation can&rsquo;t be used to allocate a free TLS\nentry.)</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_GET_SYSCALL_INFO</b>\n(since Linux 5.3)</p>\n\n<p style=\"margin-left:22%;\">Retrieve information about the\nsystem call that caused the stop. The information is placed\ninto the buffer pointed by the <i>data</i> argument, which\nshould be a pointer to a buffer of type <i>struct\nptrace_syscall_info</i>. The <i>addr</i> argument contains\nthe size of the buffer pointed to by the <i>data</i>\nargument (i.e., <i>sizeof(struct ptrace_syscall_info)</i>).\nThe return value contains the number of bytes available to\nbe written by the kernel. If the size of the data to be\nwritten by the kernel exceeds the size specified by the\n<i>addr</i> argument, the output data is truncated.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>ptrace_syscall_info</i> structure contains the following\nfields:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nptrace_syscal_info { <br>\n__u8 op; /* Type of system call stop */ <br>\n__u32 arch; /* AUDIT_ARCH_* value; see seccomp(2) */ <br>\n__u64 instruction_pointer; /* CPU instruction pointer */\n<br>\n__u64 stack_pointer; /* CPU stack pointer */ <br>\nunion { <br>\nstruct { /* op == PTRACE_SYSCALL_INFO_ENTRY */ <br>\n__u64 nr; /* System call number */ <br>\n__u64 args[6]; /* System call arguments */ <br>\n} entry; <br>\nstruct { /* op == PTRACE_SYSCALL_INFO_EXIT */ <br>\n__s64 rval; /* System call return value */ <br>\n__u8 is_error; /* System call error flag; <br>\nBoolean: does rval contain <br>\nan error value (-ERRCODE) or <br>\na nonerror return value? */ <br>\n} exit; <br>\nstruct { /* op == PTRACE_SYSCALL_INFO_SECCOMP */ <br>\n__u64 nr; /* System call number */ <br>\n__u64 args[6]; /* System call arguments */ <br>\n__u32 ret_data; /* SECCOMP_RET_DATA portion <br>\nof SECCOMP_RET_TRACE <br>\nreturn value */ <br>\n} seccomp; <br>\n}; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>op</i>,\n<i>arch</i>, <i>instruction_pointer</i>, and\n<i>stack_pointer</i> fields are defined for all kinds of\nptrace system call stops. The rest of the structure is a\nunion; one should read only those fields that are meaningful\nfor the kind of system call stop specified by the <i>op</i>\nfield.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>op</i>\nfield has one of the following values (defined in\n<i>&lt;linux/ptrace.h&gt;)</i> indicating what type of stop\noccurred and which part of the union is filled: <b><br>\nPTRACE_SYSCALL_INFO_ENTRY</b></p>\n\n<p style=\"margin-left:32%;\">The <i>entry</i> component of\nthe union contains information relating to a system call\nentry stop.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PTRACE_SYSCALL_INFO_EXIT</b></p>\n\n<p style=\"margin-left:32%;\">The <i>exit</i> component of\nthe union contains information relating to a system call\nexit stop.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PTRACE_SYSCALL_INFO_SECCOMP</b></p>\n\n<p style=\"margin-left:32%;\">The <i>seccomp</i> component of\nthe union contains information relating to a\n<b>PTRACE_EVENT_SECCOMP</b> stop.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PTRACE_SYSCALL_INFO_NONE</b></p>\n\n<p style=\"margin-left:32%;\">No component of the union\ncontains relevant information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Death under\nptrace</b> <br>\nWhen a (possibly multithreaded) process receives a killing\nsignal (one whose disposition is set to <b>SIG_DFL</b> and\nwhose default action is to kill the process), all threads\nexit. Tracees report their death to their tracer(s).\nNotification of this event is delivered via\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nkilling signal will first cause signal-delivery-stop (on one\ntracee only), and only after it is injected by the tracer\n(or after it was dispatched to a thread which isn&rsquo;t\ntraced), will death from the signal happen on <i>all</i>\ntracees within a multithreaded process. (The term\n&quot;signal-delivery-stop&quot; is explained below.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SIGKILL</b>\ndoes not generate signal-delivery-stop and therefore the\ntracer can&rsquo;t suppress it. <b>SIGKILL</b> kills even\nwithin system calls (syscall-exit-stop is not generated\nprior to death by <b>SIGKILL</b>). The net effect is that\n<b>SIGKILL</b> always kills the process (all its threads),\neven if some threads of the process are ptraced.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the tracee\ncalls <a href=\"https://man.page/2/_exit\">_exit(2)</a>, it reports its death to its tracer.\nOther threads are not affected.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When any thread\nexecutes <a href=\"https://man.page/2/exit_group\">exit_group(2)</a>, every tracee in its thread\ngroup reports its death to its tracer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>PTRACE_O_TRACEEXIT</b> option is on,\n<b>PTRACE_EVENT_EXIT</b> will happen before actual death.\nThis applies to exits via <a href=\"https://man.page/2/exit\">exit(2)</a>,\n<a href=\"https://man.page/2/exit_group\">exit_group(2)</a>, and signal deaths (except\n<b>SIGKILL</b>, depending on the kernel version; see BUGS\nbelow), and when threads are torn down on <a href=\"https://man.page/2/execve\">execve(2)</a>\nin a multithreaded process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The tracer\ncannot assume that the ptrace-stopped tracee exists. There\nare many scenarios when the tracee may die while stopped\n(such as <b>SIGKILL</b>). Therefore, the tracer must be\nprepared to handle an <b>ESRCH</b> error on any ptrace\noperation. Unfortunately, the same error is returned if the\ntracee exists but is not ptrace-stopped (for commands which\nrequire a stopped tracee), or if it is not traced by the\nprocess which issued the ptrace call. The tracer needs to\nkeep track of the stopped/running state of the tracee, and\ninterpret <b>ESRCH</b> as &quot;tracee died\nunexpectedly&quot; only if it knows that the tracee has been\nobserved to enter ptrace-stop. Note that there is no\nguarantee that <i>waitpid(WNOHANG)</i> will reliably report\nthe tracee&rsquo;s death status if a ptrace operation\nreturned <b>ESRCH</b>. <i>waitpid(WNOHANG)</i> may return 0\ninstead. In other words, the tracee may be &quot;not yet\nfully dead&quot;, but already refusing ptrace requests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The tracer\ncan&rsquo;t assume that the tracee <i>always</i> ends its\nlife by reporting <i>WIFEXITED(status)</i> or\n<i>WIFSIGNALED(status)</i>; there are cases where this does\nnot occur. For example, if a thread other than thread group\nleader does an <a href=\"https://man.page/2/execve\">execve(2)</a>, it disappears; its PID will\nnever be seen again, and any subsequent ptrace stops will be\nreported under the thread group leader&rsquo;s PID.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Stopped\nstates</b> <br>\nA tracee can be in two states: running or stopped. For the\npurposes of ptrace, a tracee which is blocked in a system\ncall (such as <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/pause\">pause(2)</a>, etc.) is\nnevertheless considered to be running, even if the tracee is\nblocked for a long time. The state of the tracee after\n<b>PTRACE_LISTEN</b> is somewhat of a gray area: it is not\nin any ptrace-stop (ptrace commands won&rsquo;t work on it,\nand it will deliver <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> notifications), but it\nalso may be considered &quot;stopped&quot; because it is not\nexecuting instructions (is not scheduled), and if it was in\ngroup-stop before <b>PTRACE_LISTEN</b>, it will not respond\nto signals until <b>SIGCONT</b> is received.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are many\nkinds of states when the tracee is stopped, and in ptrace\ndiscussions they are often conflated. Therefore, it is\nimportant to use precise terms.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In this manual\npage, any stopped state in which the tracee is ready to\naccept ptrace commands from the tracer is called\n<i>ptrace-stop</i>. Ptrace-stops can be further subdivided\ninto <i>signal-delivery-stop</i>, <i>group-stop</i>,\n<i>syscall-stop</i>, <i>PTRACE_EVENT stops</i>, and so on.\nThese stopped states are described in detail below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\nrunning tracee enters ptrace-stop, it notifies its tracer\nusing <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> (or one of the other\n&quot;wait&quot; system calls). Most of this manual page\nassumes that the tracer waits with:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pid =\nwaitpid(pid_or_minus_1, &amp;status, __WALL);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Ptrace-stopped\ntracees are reported as returns with <i>pid</i> greater than\n0 and <i>WIFSTOPPED(status)</i> true.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>__WALL</b> flag does not include the <b>WSTOPPED</b> and\n<b>WEXITED</b> flags, but implies their functionality.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Setting the\n<b>WCONTINUED</b> flag when calling <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> is not\nrecommended: the &quot;continued&quot; state is per-process\nand consuming it can confuse the real parent of the\ntracee.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Use of the\n<b>WNOHANG</b> flag may cause <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> to return 0\n(&quot;no wait results available yet&quot;) even if the\ntracer knows there should be a notification. Example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">errno = 0; <br>\nptrace(PTRACE_CONT, pid, 0L, 0L); <br>\nif (errno == ESRCH) { <br>\n/* tracee is dead */ <br>\nr = waitpid(tracee, &amp;status, __WALL | WNOHANG); <br>\n/* r can still be 0 here! */ <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nkinds of ptrace-stops exist: signal-delivery-stops,\ngroup-stops, <b>PTRACE_EVENT</b> stops, syscall-stops. They\nall are reported by <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> with\n<i>WIFSTOPPED(status)</i> true. They may be differentiated\nby examining the value <i>status&gt;&gt;8</i>, and if there\nis ambiguity in that value, by querying\n<b>PTRACE_GETSIGINFO</b>. (Note: the <i>WSTOPSIG(status)</i>\nmacro can&rsquo;t be used to perform this examination,\nbecause it returns the value\n<i>(status&gt;&gt;8)&nbsp;&amp;&nbsp;0xff</i>.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Signal-delivery-stop</b>\n<br>\nWhen a (possibly multithreaded) process receives any signal\nexcept <b>SIGKILL</b>, the kernel selects an arbitrary\nthread which handles the signal. (If the signal is generated\nwith <a href=\"https://man.page/2/tgkill\">tgkill(2)</a>, the target thread can be explicitly\nselected by the caller.) If the selected thread is traced,\nit enters signal-delivery-stop. At this point, the signal is\nnot yet delivered to the process, and can be suppressed by\nthe tracer. If the tracer doesn&rsquo;t suppress the signal,\nit passes the signal to the tracee in the next ptrace\nrestart request. This second step of signal delivery is\ncalled <i>signal injection</i> in this manual page. Note\nthat if the signal is blocked, signal-delivery-stop\ndoesn&rsquo;t happen until the signal is unblocked, with the\nusual exception that <b>SIGSTOP</b> can&rsquo;t be\nblocked.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Signal-delivery-stop\nis observed by the tracer as <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> returning\nwith <i>WIFSTOPPED(status)</i> true, with the signal\nreturned by <i>WSTOPSIG(status)</i>. If the signal is\n<b>SIGTRAP</b>, this may be a different kind of ptrace-stop;\nsee the &quot;Syscall-stops&quot; and &quot;execve&quot;\nsections below for details. If <i>WSTOPSIG(status)</i>\nreturns a stopping signal, this may be a group-stop; see\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Signal\ninjection and suppression</b> <br>\nAfter signal-delivery-stop is observed by the tracer, the\ntracer should restart the tracee with the call</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_restart,\npid, 0, sig)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where\n<b>PTRACE_restart</b> is one of the restarting ptrace\nrequests. If <i>sig</i> is 0, then a signal is not\ndelivered. Otherwise, the signal <i>sig</i> is delivered.\nThis operation is called <i>signal injection</i> in this\nmanual page, to distinguish it from\nsignal-delivery-stop.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>sig</i>\nvalue may be different from the <i>WSTOPSIG(status)</i>\nvalue: the tracer can cause a different signal to be\ninjected.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that a\nsuppressed signal still causes system calls to return\nprematurely. In this case, system calls will be restarted:\nthe tracer will observe the tracee to reexecute the\ninterrupted system call (or <a href=\"https://man.page/2/restart_syscall\">restart_syscall(2)</a> system\ncall for a few system calls which use a different mechanism\nfor restarting) if the tracer uses <b>PTRACE_SYSCALL</b>.\nEven system calls (such as <a href=\"https://man.page/2/poll\">poll(2)</a>) which are not\nrestartable after signal are restarted after signal is\nsuppressed; however, kernel bugs exist which cause some\nsystem calls to fail with <b>EINTR</b> even though no\nobservable signal is injected to the tracee.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Restarting\nptrace commands issued in ptrace-stops other than\nsignal-delivery-stop are not guaranteed to inject a signal,\neven if <i>sig</i> is nonzero. No error is reported; a\nnonzero <i>sig</i> may simply be ignored. Ptrace users\nshould not try to &quot;create a new signal&quot; this way:\nuse <a href=\"https://man.page/2/tgkill\">tgkill(2)</a> instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fact that\nsignal injection requests may be ignored when restarting the\ntracee after ptrace stops that are not signal-delivery-stops\nis a cause of confusion among ptrace users. One typical\nscenario is that the tracer observes group-stop, mistakes it\nfor signal-delivery-stop, restarts the tracee with</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_restart,\npid, 0, stopsig)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">with the\nintention of injecting <i>stopsig</i>, but <i>stopsig</i>\ngets ignored and the tracee continues to run.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>SIGCONT</b> signal has a side effect of waking up (all\nthreads of) a group-stopped process. This side effect\nhappens before signal-delivery-stop. The tracer can&rsquo;t\nsuppress this side effect (it can only suppress signal\ninjection, which only causes the <b>SIGCONT</b> handler to\nnot be executed in the tracee, if such a handler is\ninstalled). In fact, waking up from group-stop may be\nfollowed by signal-delivery-stop for signal(s) <i>other\nthan</i> <b>SIGCONT</b>, if they were pending when\n<b>SIGCONT</b> was delivered. In other words, <b>SIGCONT</b>\nmay be not the first signal observed by the tracee after it\nwas sent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Stopping\nsignals cause (all threads of) a process to enter\ngroup-stop. This side effect happens after signal injection,\nand therefore can be suppressed by the tracer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux 2.4\nand earlier, the <b>SIGSTOP</b> signal can&rsquo;t be\ninjected.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_GETSIGINFO</b>\ncan be used to retrieve a <i>siginfo_t</i> structure which\ncorresponds to the delivered signal.\n<b>PTRACE_SETSIGINFO</b> may be used to modify it. If\n<b>PTRACE_SETSIGINFO</b> has been used to alter\n<i>siginfo_t</i>, the <i>si_signo</i> field and the\n<i>sig</i> parameter in the restarting command must match,\notherwise the result is undefined.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Group-stop</b>\n<br>\nWhen a (possibly multithreaded) process receives a stopping\nsignal, all threads stop. If some threads are traced, they\nenter a group-stop. Note that the stopping signal will first\ncause signal-delivery-stop (on one tracee only), and only\nafter it is injected by the tracer (or after it was\ndispatched to a thread which isn&rsquo;t traced), will\ngroup-stop be initiated on <i>all</i> tracees within the\nmultithreaded process. As usual, every tracee reports its\ngroup-stop separately to the corresponding tracer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Group-stop is\nobserved by the tracer as <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> returning with\n<i>WIFSTOPPED(status)</i> true, with the stopping signal\navailable via <i>WSTOPSIG(status)</i>. The same result is\nreturned by some other classes of ptrace-stops, therefore\nthe recommended practice is to perform the call</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_GETSIGINFO,\npid, 0, &amp;siginfo)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The call can be\navoided if the signal is not <b>SIGSTOP</b>, <b>SIGTSTP</b>,\n<b>SIGTTIN</b>, or <b>SIGTTOU</b>; only these four signals\nare stopping signals. If the tracer sees something else, it\ncan&rsquo;t be a group-stop. Otherwise, the tracer needs to\ncall <b>PTRACE_GETSIGINFO</b>. If <b>PTRACE_GETSIGINFO</b>\nfails with <b>EINVAL</b>, then it is definitely a\ngroup-stop. (Other failure codes are possible, such as\n<b>ESRCH</b> (&quot;no such process&quot;) if a\n<b>SIGKILL</b> killed the tracee.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If tracee was\nattached using <b>PTRACE_SEIZE</b>, group-stop is indicated\nby <b>PTRACE_EVENT_STOP</b>: <i>status&gt;&gt;16 ==\nPTRACE_EVENT_STOP</i>. This allows detection of group-stops\nwithout requiring an extra <b>PTRACE_GETSIGINFO</b>\ncall.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As of Linux\n2.6.38, after the tracer sees the tracee ptrace-stop and\nuntil it restarts or kills it, the tracee will not run, and\nwill not send notifications (except <b>SIGKILL</b> death) to\nthe tracer, even if the tracer enters into another\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\nbehavior described in the previous paragraph causes a\nproblem with transparent handling of stopping signals. If\nthe tracer restarts the tracee after group-stop, the\nstopping signal is effectively ignored&mdash;the tracee\ndoesn&rsquo;t remain stopped, it runs. If the tracer\ndoesn&rsquo;t restart the tracee before entering into the\nnext <a href=\"https://man.page/2/waitpid\">waitpid(2)</a>, future <b>SIGCONT</b> signals will\nnot be reported to the tracer; this would cause the\n<b>SIGCONT</b> signals to have no effect on the tracee.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n3.4, there is a method to overcome this problem: instead of\n<b>PTRACE_CONT</b>, a <b>PTRACE_LISTEN</b> command can be\nused to restart a tracee in a way where it does not execute,\nbut waits for a new event which it can report via\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> (such as when it is restarted by a\n<b>SIGCONT</b>).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_EVENT\nstops</b> <br>\nIf the tracer sets <b>PTRACE_O_TRACE_*</b> options, the\ntracee will enter ptrace-stops called <b>PTRACE_EVENT</b>\nstops.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_EVENT</b>\nstops are observed by the tracer as <a href=\"https://man.page/2/waitpid\">waitpid(2)</a>\nreturning with <i>WIFSTOPPED(status)</i>, and\n<i>WSTOPSIG(status)</i> returns <b>SIGTRAP</b> (or for\n<b>PTRACE_EVENT_STOP</b>, returns the stopping signal if\ntracee is in a group-stop). An additional bit is set in the\nhigher byte of the status word: the value\n<i>status&gt;&gt;8</i> will be</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">((PTRACE_EVENT_foo&lt;&lt;8)\n| SIGTRAP).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nevents exist: <b><br>\nPTRACE_EVENT_VFORK</b></p>\n\n<p style=\"margin-left:22%;\">Stop before return from\n<a href=\"https://man.page/2/vfork\">vfork(2)</a> or <a href=\"https://man.page/2/clone\">clone(2)</a> with the\n<b>CLONE_VFORK</b> flag. When the tracee is continued after\nthis stop, it will wait for child to exit/exec before\ncontinuing its execution (in other words, the usual behavior\non <a href=\"https://man.page/2/vfork\">vfork(2)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_EVENT_FORK</b></p>\n\n<p style=\"margin-left:22%;\">Stop before return from\n<a href=\"https://man.page/2/fork\">fork(2)</a> or <a href=\"https://man.page/2/clone\">clone(2)</a> with the exit signal set\nto <b>SIGCHLD</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_EVENT_CLONE</b></p>\n\n<p style=\"margin-left:22%;\">Stop before return from\n<a href=\"https://man.page/2/clone\">clone(2)</a>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTRACE_EVENT_VFORK_DONE</b></p>\n\n<p style=\"margin-left:22%;\">Stop before return from\n<a href=\"https://man.page/2/vfork\">vfork(2)</a> or <a href=\"https://man.page/2/clone\">clone(2)</a> with the\n<b>CLONE_VFORK</b> flag, but after the child unblocked this\ntracee by exiting or execing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For all four\nstops described above, the stop occurs in the parent (i.e.,\nthe tracee), not in the newly created thread.\n<b>PTRACE_GETEVENTMSG</b> can be used to retrieve the new\nthread&rsquo;s ID. <b><br>\nPTRACE_EVENT_EXEC</b></p>\n\n<p style=\"margin-left:22%;\">Stop before return from\n<a href=\"https://man.page/2/execve\">execve(2)</a>. Since Linux 3.0, <b>PTRACE_GETEVENTMSG</b>\nreturns the former thread ID.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_EVENT_EXIT</b></p>\n\n<p style=\"margin-left:22%;\">Stop before exit (including\ndeath from <a href=\"https://man.page/2/exit_group\">exit_group(2)</a>), signal death, or exit\ncaused by <a href=\"https://man.page/2/execve\">execve(2)</a> in a multithreaded process.\n<b>PTRACE_GETEVENTMSG</b> returns the exit status. Registers\ncan be examined (unlike when &quot;real&quot; exit happens).\nThe tracee is still alive; it needs to be\n<b>PTRACE_CONT</b>ed or <b>PTRACE_DETACH</b>ed to finish\nexiting.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_EVENT_STOP</b></p>\n\n<p style=\"margin-left:22%;\">Stop induced by\n<b>PTRACE_INTERRUPT</b> command, or group-stop, or initial\nptrace-stop when a new child is attached (only if attached\nusing <b>PTRACE_SEIZE</b>).</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTRACE_EVENT_SECCOMP</b></p>\n\n<p style=\"margin-left:22%;\">Stop triggered by a\n<a href=\"https://man.page/2/seccomp\">seccomp(2)</a> rule on tracee syscall entry when\n<b>PTRACE_O_TRACESECCOMP</b> has been set by the tracer. The\nseccomp event message data (from the <b>SECCOMP_RET_DATA</b>\nportion of the seccomp filter rule) can be retrieved with\n<b>PTRACE_GETEVENTMSG</b>. The semantics of this stop are\ndescribed in detail in a separate section below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_GETSIGINFO</b>\non <b>PTRACE_EVENT</b> stops returns <b>SIGTRAP</b> in\n<i>si_signo</i>, with <i>si_code</i> set to\n<i>(event&lt;&lt;8)&nbsp;|&nbsp;SIGTRAP</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Syscall-stops</b>\n<br>\nIf the tracee was restarted by <b>PTRACE_SYSCALL</b> or\n<b>PTRACE_SYSEMU</b>, the tracee enters syscall-enter-stop\njust prior to entering any system call (which will not be\nexecuted if the restart was using <b>PTRACE_SYSEMU</b>,\nregardless of any change made to registers at this point or\nhow the tracee is restarted after this stop). No matter\nwhich method caused the syscall-entry-stop, if the tracer\nrestarts the tracee with <b>PTRACE_SYSCALL</b>, the tracee\nenters syscall-exit-stop when the system call is finished,\nor if it is interrupted by a signal. (That is,\nsignal-delivery-stop never happens between\nsyscall-enter-stop and syscall-exit-stop; it happens\n<i>after</i> syscall-exit-stop.). If the tracee is continued\nusing any other method (including <b>PTRACE_SYSEMU</b>), no\nsyscall-exit-stop occurs. Note that all mentions\n<b>PTRACE_SYSEMU</b> apply equally to\n<b>PTRACE_SYSEMU_SINGLESTEP</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, even\nif the tracee was continued using <b>PTRACE_SYSCALL</b>, it\nis not guaranteed that the next stop will be a\nsyscall-exit-stop. Other possibilities are that the tracee\nmay stop in a <b>PTRACE_EVENT</b> stop (including seccomp\nstops), exit (if it entered <a href=\"https://man.page/2/_exit\">_exit(2)</a> or\n<a href=\"https://man.page/2/exit_group\">exit_group(2)</a>), be killed by <b>SIGKILL</b>, or die\nsilently (if it is a thread group leader, the\n<a href=\"https://man.page/2/execve\">execve(2)</a> happened in another thread, and that thread\nis not traced by the same tracer; this situation is\ndiscussed later).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Syscall-enter-stop\nand syscall-exit-stop are observed by the tracer as\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> returning with <i>WIFSTOPPED(status)</i>\ntrue, and <i>WSTOPSIG(status)</i> giving <b>SIGTRAP</b>. If\nthe <b>PTRACE_O_TRACESYSGOOD</b> option was set by the\ntracer, then <i>WSTOPSIG(status)</i> will give the value\n<i>(SIGTRAP&nbsp;|&nbsp;0x80)</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Syscall-stops\ncan be distinguished from signal-delivery-stop with\n<b>SIGTRAP</b> by querying <b>PTRACE_GETSIGINFO</b> for the\nfollowing cases: <i><br>\nsi_code</i> &lt;= 0</p>\n\n<p style=\"margin-left:22%;\"><b>SIGTRAP</b> was delivered as\na result of a user-space action, for example, a system call\n(<a href=\"https://man.page/2/tgkill\">tgkill(2)</a>, <a href=\"https://man.page/2/kill\">kill(2)</a>, <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>,\netc.), expiration of a POSIX timer, change of state on a\nPOSIX message queue, or completion of an asynchronous I/O\nrequest.</p>\n\n<p style=\"margin-left:11%;\"><i>si_code</i> == SI_KERNEL\n(0x80)</p>\n\n<p style=\"margin-left:22%;\"><b>SIGTRAP</b> was sent by the\nkernel.</p>\n\n<p style=\"margin-left:11%;\"><i>si_code</i> == SIGTRAP or\n<i>si_code</i> == (SIGTRAP|0x80)</p>\n\n<p style=\"margin-left:22%;\">This is a syscall-stop.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However,\nsyscall-stops happen very often (twice per system call), and\nperforming <b>PTRACE_GETSIGINFO</b> for every syscall-stop\nmay be somewhat expensive.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some\narchitectures allow the cases to be distinguished by\nexamining registers. For example, on x86, <i>rax</i> ==\n-<b>ENOSYS</b> in syscall-enter-stop. Since <b>SIGTRAP</b>\n(like any other signal) always happens <i>after</i>\nsyscall-exit-stop, and at this point <i>rax</i> almost never\ncontains -<b>ENOSYS</b>, the <b>SIGTRAP</b> looks like\n&quot;syscall-stop which is not syscall-enter-stop&quot;; in\nother words, it looks like a &quot;stray\nsyscall-exit-stop&quot; and can be detected this way. But\nsuch detection is fragile and is best avoided.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using the\n<b>PTRACE_O_TRACESYSGOOD</b> option is the recommended\nmethod to distinguish syscall-stops from other kinds of\nptrace-stops, since it is reliable and does not incur a\nperformance penalty.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Syscall-enter-stop\nand syscall-exit-stop are indistinguishable from each other\nby the tracer. The tracer needs to keep track of the\nsequence of ptrace-stops in order to not misinterpret\nsyscall-enter-stop as syscall-exit-stop or vice versa. In\ngeneral, a syscall-enter-stop is always followed by\nsyscall-exit-stop, <b>PTRACE_EVENT</b> stop, or the\ntracee&rsquo;s death; no other kinds of ptrace-stop can\noccur in between. However, note that seccomp stops (see\nbelow) can cause syscall-exit-stops, without preceding\nsyscall-entry-stops. If seccomp is in use, care needs to be\ntaken not to misinterpret such stops as\nsyscall-entry-stops.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If after\nsyscall-enter-stop, the tracer uses a restarting command\nother than <b>PTRACE_SYSCALL</b>, syscall-exit-stop is not\ngenerated.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_GETSIGINFO</b>\non syscall-stops returns <b>SIGTRAP</b> in <i>si_signo</i>,\nwith <i>si_code</i> set to <b>SIGTRAP</b> or\n<i>(SIGTRAP|0x80)</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_EVENT_SECCOMP\nstops (Linux 3.5 to 4.7)</b> <br>\nThe behavior of <b>PTRACE_EVENT_SECCOMP</b> stops and their\ninteraction with other kinds of ptrace stops has changed\nbetween kernel versions. This documents the behavior from\ntheir introduction until Linux 4.7 (inclusive). The behavior\nin later kernel versions is documented in the next\nsection.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<b>PTRACE_EVENT_SECCOMP</b> stop occurs whenever a\n<b>SECCOMP_RET_TRACE</b> rule is triggered. This is\nindependent of which methods was used to restart the system\ncall. Notably, seccomp still runs even if the tracee was\nrestarted using <b>PTRACE_SYSEMU</b> and this system call is\nunconditionally skipped.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Restarts from\nthis stop will behave as if the stop had occurred right\nbefore the system call in question. In particular, both\n<b>PTRACE_SYSCALL</b> and <b>PTRACE_SYSEMU</b> will normally\ncause a subsequent syscall-entry-stop. However, if after the\n<b>PTRACE_EVENT_SECCOMP</b> the system call number is\nnegative, both the syscall-entry-stop and the system call\nitself will be skipped. This means that if the system call\nnumber is negative after a <b>PTRACE_EVENT_SECCOMP</b> and\nthe tracee is restarted using <b>PTRACE_SYSCALL</b>, the\nnext observed stop will be a syscall-exit-stop, rather than\nthe syscall-entry-stop that might have been expected.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_EVENT_SECCOMP\nstops (since Linux 4.8)</b> <br>\nStarting with Linux 4.8, the <b>PTRACE_EVENT_SECCOMP</b>\nstop was reordered to occur between syscall-entry-stop and\nsyscall-exit-stop. Note that seccomp no longer runs (and no\n<b>PTRACE_EVENT_SECCOMP</b> will be reported) if the system\ncall is skipped due to <b>PTRACE_SYSEMU</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Functionally, a\n<b>PTRACE_EVENT_SECCOMP</b> stop functions comparably to a\nsyscall-entry-stop (i.e., continuations using\n<b>PTRACE_SYSCALL</b> will cause syscall-exit-stops, the\nsystem call number may be changed and any other modified\nregisters are visible to the to-be-executed system call as\nwell). Note that there may be, but need not have been a\npreceding syscall-entry-stop.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After a\n<b>PTRACE_EVENT_SECCOMP</b> stop, seccomp will be rerun,\nwith a <b>SECCOMP_RET_TRACE</b> rule now functioning the\nsame as a <b>SECCOMP_RET_ALLOW</b>. Specifically, this means\nthat if registers are not modified during the\n<b>PTRACE_EVENT_SECCOMP</b> stop, the system call will then\nbe allowed.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_SINGLESTEP\nstops</b> <br>\n[Details of these kinds of stops are yet to be\ndocumented.]</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Informational\nand restarting ptrace commands</b> <br>\nMost ptrace commands (all except <b>PTRACE_ATTACH</b>,\n<b>PTRACE_SEIZE</b>, <b>PTRACE_TRACEME</b>,\n<b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>) require the\ntracee to be in a ptrace-stop, otherwise they fail with\n<b>ESRCH</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the tracee\nis in ptrace-stop, the tracer can read and write data to the\ntracee using informational commands. These commands leave\nthe tracee in ptrace-stopped state:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER,\npid, addr, 0); <br>\nptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr,\nlong_val); <br>\nptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &amp;struct); <br>\nptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &amp;struct); <br>\nptrace(PTRACE_GETREGSET, pid, NT_foo, &amp;iov); <br>\nptrace(PTRACE_SETREGSET, pid, NT_foo, &amp;iov); <br>\nptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo); <br>\nptrace(PTRACE_SETSIGINFO, pid, 0, &amp;siginfo); <br>\nptrace(PTRACE_GETEVENTMSG, pid, 0, &amp;long_var); <br>\nptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that some\nerrors are not reported. For example, setting signal\ninformation (<i>siginfo</i>) may have no effect in some\nptrace-stops, yet the call may succeed (return 0 and not set\n<i>errno</i>); querying <b>PTRACE_GETEVENTMSG</b> may\nsucceed and return some random value if current ptrace-stop\nis not documented as returning a meaningful event\nmessage.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The call</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_SETOPTIONS,\npid, 0, PTRACE_O_flags);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">affects one\ntracee. The tracee&rsquo;s current flags are replaced. Flags\nare inherited by new tracees created and\n&quot;auto-attached&quot; via active\n<b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or\n<b>PTRACE_O_TRACECLONE</b> options.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another group\nof commands makes the ptrace-stopped tracee run. They have\nthe form:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(cmd,\npid, 0, sig);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where\n<i>cmd</i> is <b>PTRACE_CONT</b>, <b>PTRACE_LISTEN</b>,\n<b>PTRACE_DETACH</b>, <b>PTRACE_SYSCALL</b>,\n<b>PTRACE_SINGLESTEP</b>, <b>PTRACE_SYSEMU</b>, or\n<b>PTRACE_SYSEMU_SINGLESTEP</b>. If the tracee is in\nsignal-delivery-stop, <i>sig</i> is the signal to be\ninjected (if it is nonzero). Otherwise, <i>sig</i> may be\nignored. (When restarting a tracee from a ptrace-stop other\nthan signal-delivery-stop, recommended practice is to always\npass 0 in <i>sig</i>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Attaching\nand detaching</b> <br>\nA thread can be attached to the tracer using the call</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_ATTACH,\npid, 0, 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_SEIZE,\npid, 0, PTRACE_O_flags);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_ATTACH</b>\nsends <b>SIGSTOP</b> to this thread. If the tracer wants\nthis <b>SIGSTOP</b> to have no effect, it needs to suppress\nit. Note that if other signals are concurrently sent to this\nthread during attach, the tracer may see the tracee enter\nsignal-delivery-stop with other signal(s) first! The usual\npractice is to reinject these signals until <b>SIGSTOP</b>\nis seen, then suppress <b>SIGSTOP</b> injection. The design\nbug here is that a ptrace attach and a concurrently\ndelivered <b>SIGSTOP</b> may race and the concurrent\n<b>SIGSTOP</b> may be lost.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since attaching\nsends <b>SIGSTOP</b> and the tracer usually suppresses it,\nthis may cause a stray <b>EINTR</b> return from the\ncurrently executing system call in the tracee, as described\nin the &quot;Signal injection and suppression&quot;\nsection.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n3.4, <b>PTRACE_SEIZE</b> can be used instead of\n<b>PTRACE_ATTACH</b>. <b>PTRACE_SEIZE</b> does not stop the\nattached process. If you need to stop it after attach (or at\nany other time) without sending it any signals, use\n<b>PTRACE_INTERRUPT</b> command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The request</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_TRACEME,\n0, 0, 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">turns the\ncalling thread into a tracee. The thread continues to run\n(doesn&rsquo;t enter ptrace-stop). A common practice is to\nfollow the <b>PTRACE_TRACEME</b> with</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">raise(SIGSTOP);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and allow the\nparent (which is our tracer now) to observe our\nsignal-delivery-stop.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or\n<b>PTRACE_O_TRACECLONE</b> options are in effect, then\nchildren created by, respectively, <a href=\"https://man.page/2/vfork\">vfork(2)</a> or\n<a href=\"https://man.page/2/clone\">clone(2)</a> with the <b>CLONE_VFORK</b> flag,\n<a href=\"https://man.page/2/fork\">fork(2)</a> or <a href=\"https://man.page/2/clone\">clone(2)</a> with the exit signal set\nto <b>SIGCHLD</b>, and other kinds of <a href=\"https://man.page/2/clone\">clone(2)</a>, are\nautomatically attached to the same tracer which traced their\nparent. <b>SIGSTOP</b> is delivered to the children, causing\nthem to enter signal-delivery-stop after they exit the\nsystem call which created them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Detaching of\nthe tracee is performed by:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ptrace(PTRACE_DETACH,\npid, 0, sig);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PTRACE_DETACH</b>\nis a restarting operation; therefore it requires the tracee\nto be in ptrace-stop. If the tracee is in\nsignal-delivery-stop, a signal can be injected. Otherwise,\nthe <i>sig</i> parameter may be silently ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the tracee\nis running when the tracer wants to detach it, the usual\nsolution is to send <b>SIGSTOP</b> (using <a href=\"https://man.page/2/tgkill\">tgkill(2)</a>,\nto make sure it goes to the correct thread), wait for the\ntracee to stop in signal-delivery-stop for <b>SIGSTOP</b>\nand then detach it (suppressing <b>SIGSTOP</b> injection). A\ndesign bug is that this can race with concurrent\n<b>SIGSTOP</b>s. Another complication is that the tracee may\nenter other ptrace-stops and needs to be restarted and\nwaited for again, until <b>SIGSTOP</b> is seen. Yet another\ncomplication is to be sure that the tracee is not already\nptrace-stopped, because no signal delivery happens while it\nis&mdash;not even <b>SIGSTOP</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the tracer\ndies, all tracees are automatically detached and restarted,\nunless they were in group-stop. Handling of restart from\ngroup-stop is currently buggy, but the &quot;as\nplanned&quot; behavior is to leave tracee stopped and\nwaiting for <b>SIGCONT</b>. If the tracee is restarted from\nsignal-delivery-stop, the pending signal is injected.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>execve(2)\nunder ptrace</b> <br>\nWhen one thread in a multithreaded process calls\n<a href=\"https://man.page/2/execve\">execve(2)</a>, the kernel destroys all other threads in\nthe process, and resets the thread ID of the execing thread\nto the thread group ID (process ID). (Or, to put things\nanother way, when a multithreaded process does an\n<a href=\"https://man.page/2/execve\">execve(2)</a>, at completion of the call, it appears as\nthough the <a href=\"https://man.page/2/execve\">execve(2)</a> occurred in the thread group\nleader, regardless of which thread did the\n<a href=\"https://man.page/2/execve\">execve(2)</a>.) This resetting of the thread ID looks\nvery confusing to tracers:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>All other threads stop in <b>PTRACE_EVENT_EXIT</b> stop,\nif the <b>PTRACE_O_TRACEEXIT</b> option was turned on. Then\nall other threads except the thread group leader report\ndeath as if they exited via <a href=\"https://man.page/2/_exit\">_exit(2)</a> with exit code\n0.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The execing tracee changes its thread ID while it is in\nthe <a href=\"https://man.page/2/execve\">execve(2)</a>. (Remember, under ptrace, the\n&quot;pid&quot; returned from <a href=\"https://man.page/2/waitpid\">waitpid(2)</a>, or fed into\nptrace calls, is the tracee&rsquo;s thread ID.) That is, the\ntracee&rsquo;s thread ID is reset to be the same as its\nprocess ID, which is the same as the thread group\nleader&rsquo;s thread ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Then a <b>PTRACE_EVENT_EXEC</b> stop happens, if the\n<b>PTRACE_O_TRACEEXEC</b> option was turned on.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If the thread group leader has reported its\n<b>PTRACE_EVENT_EXIT</b> stop by this time, it appears to\nthe tracer that the dead thread leader &quot;reappears from\nnowhere&quot;. (Note: the thread group leader does not\nreport death via <i>WIFEXITED(status)</i> until there is at\nleast one other live thread. This eliminates the possibility\nthat the tracer will see it dying and then reappearing.) If\nthe thread group leader was still alive, for the tracer this\nmay look as if thread group leader returns from a different\nsystem call than it entered, or even &quot;returned from a\nsystem call even though it was not in any system call&quot;.\nIf the thread group leader was not traced (or was traced by\na different tracer), then during <a href=\"https://man.page/2/execve\">execve(2)</a> it will\nappear as if it has become a tracee of the tracer of the\nexecing tracee.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All of the\nabove effects are the artifacts of the thread ID change in\nthe tracee.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>PTRACE_O_TRACEEXEC</b> option is the recommended tool for\ndealing with this situation. First, it enables\n<b>PTRACE_EVENT_EXEC</b> stop, which occurs before\n<a href=\"https://man.page/2/execve\">execve(2)</a> returns. In this stop, the tracer can use\n<b>PTRACE_GETEVENTMSG</b> to retrieve the tracee&rsquo;s\nformer thread ID. (This feature was introduced in Linux\n3.0.) Second, the <b>PTRACE_O_TRACEEXEC</b> option disables\nlegacy <b>SIGTRAP</b> generation on <a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the tracer\nreceives <b>PTRACE_EVENT_EXEC</b> stop notification, it is\nguaranteed that except this tracee and the thread group\nleader, no other threads from the process are alive.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On receiving\nthe <b>PTRACE_EVENT_EXEC</b> stop notification, the tracer\nshould clean up all its internal data structures describing\nthe threads of this process, and retain only one data\nstructure&mdash;one which describes the single still running\ntracee, with</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">thread ID ==\nthread group ID == process ID.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Example: two\nthreads call <a href=\"https://man.page/2/execve\">execve(2)</a> at the same time:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">*** we get\nsyscall-enter-stop in thread 1: ** <br>\nPID1 execve(&quot;/bin/foo&quot;, &quot;foo&quot;\n&lt;unfinished ...&gt; <br>\n*** we issue PTRACE_SYSCALL for thread 1 ** <br>\n*** we get syscall-enter-stop in thread 2: ** <br>\nPID2 execve(&quot;/bin/bar&quot;, &quot;bar&quot;\n&lt;unfinished ...&gt; <br>\n*** we issue PTRACE_SYSCALL for thread 2 ** <br>\n*** we get PTRACE_EVENT_EXEC for PID0, we issue\nPTRACE_SYSCALL ** <br>\n*** we get syscall-exit-stop for PID0: ** <br>\nPID0 &lt;... execve resumed&gt; ) = 0</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>PTRACE_O_TRACEEXEC</b> option is <i>not</i> in effect for\nthe execing tracee, and if the tracee was\n<b>PTRACE_ATTACH</b>ed rather that <b>PTRACE_SEIZE</b>d, the\nkernel delivers an extra <b>SIGTRAP</b> to the tracee after\n<a href=\"https://man.page/2/execve\">execve(2)</a> returns. This is an ordinary signal\n(similar to one which can be generated by <i>kill\n-TRAP</i>), not a special kind of ptrace-stop. Employing\n<b>PTRACE_GETSIGINFO</b> for this signal returns\n<i>si_code</i> set to 0 (<i>SI_USER</i>). This signal may be\nblocked by signal mask, and thus may be delivered (much)\nlater.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Usually, the\ntracer (for example, <a href=\"https://man.page/1/strace\">strace(1)</a>) would not want to\nshow this extra post-execve <b>SIGTRAP</b> signal to the\nuser, and would suppress its delivery to the tracee (if\n<b>SIGTRAP</b> is set to <b>SIG_DFL</b>, it is a killing\nsignal). However, determining <i>which</i> <b>SIGTRAP</b> to\nsuppress is not easy. Setting the <b>PTRACE_O_TRACEEXEC</b>\noption or using <b>PTRACE_SEIZE</b> and thus suppressing\nthis extra <b>SIGTRAP</b> is the recommended approach.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Real\nparent</b> <br>\nThe ptrace API (ab)uses the standard UNIX parent/child\nsignaling over <a href=\"https://man.page/2/waitpid\">waitpid(2)</a>. This used to cause the\nreal parent of the process to stop receiving several kinds\nof <a href=\"https://man.page/2/waitpid\">waitpid(2)</a> notifications when the child process is\ntraced by some other process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many of these\nbugs have been fixed, but as of Linux 2.6.38 several still\nexist; see BUGS below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As of Linux\n2.6.38, the following is believed to work correctly:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">exit/death by signal is reported\nfirst to the tracer, then, when the tracer consumes the\n<a href=\"https://man.page/2/waitpid\">waitpid(2)</a> result, to the real parent (to the real\nparent only when the whole multithreaded process exits). If\nthe tracer and the real parent are the same process, the\nreport is sent only once.</p></td></tr>\n</table>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success, the\n<b>PTRACE_PEEK*</b> requests return the requested data (but\nsee NOTES), the <b>PTRACE_SECCOMP_GET_FILTER</b> request\nreturns the number of instructions in the BPF program, and\nother requests return zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, all\nrequests return -1, and <i>errno</i> is set appropriately.\nSince the value returned by a successful <b>PTRACE_PEEK*</b>\nrequest may be -1, the caller must clear <i>errno</i> before\nthe call, and then check it afterward to determine whether\nor not an error occurred.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">(i386 only) There was an error\nwith allocating or freeing a debug register.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>There was an attempt to read from or write to an invalid\narea in the tracer&rsquo;s or the tracee&rsquo;s memory,\nprobably because the area wasn&rsquo;t mapped or accessible.\nUnfortunately, under Linux, different variations of this\nfault will return <b>EIO</b> or <b>EFAULT</b> more or less\narbitrarily.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An attempt was made to set an invalid option.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>request</i> is invalid, or an attempt was made to\nread from or write to an invalid area in the tracer&rsquo;s\nor the tracee&rsquo;s memory, or there was a word-alignment\nviolation, or an invalid signal was specified during a\nrestart request.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The specified process cannot be traced. This could be\nbecause the tracer has insufficient privileges (the required\ncapability is <b>CAP_SYS_PTRACE</b>); unprivileged processes\ncannot trace processes that they cannot send signals to or\nthose running set-user-ID/set-group-ID programs, for obvious\nreasons. Alternatively, the process may already be being\ntraced, or (on kernels before 2.6.26) be <a href=\"https://man.page/1/init\">init(1)</a> (PID\n1).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESRCH</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The specified process does not exist, or is not\ncurrently being traced by the caller, or is not stopped (for\nrequests that require a stopped tracee).</p></td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SVr4,\n4.3BSD.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Although\narguments to <b>ptrace</b>() are interpreted according to\nthe prototype given, glibc currently declares\n<b>ptrace</b>() as a variadic function with only the\n<i>request</i> argument fixed. It is recommended to always\nsupply four arguments, even if the requested operation does\nnot use them, setting unused/ignored arguments to <i>0L</i>\nor <i>(void&nbsp;*)&nbsp;0</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux\nkernels before 2.6.26, <a href=\"https://man.page/1/init\">init(1)</a>, the process with PID\n1, may not be traced.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A tracees\nparent continues to be the tracer even if that tracer calls\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The layout of\nthe contents of memory and the USER area are quite\noperating-system- and architecture-specific. The offset\nsupplied, and the data returned, might not entirely match\nwith the definition of <i>struct user</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The size of a\n&quot;word&quot; is determined by the operating-system\nvariant (e.g., for 32-bit Linux it is 32 bits).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page\ndocuments the way the <b>ptrace</b>() call works currently\nin Linux. Its behavior differs significantly on other\nflavors of UNIX. In any case, use of <b>ptrace</b>() is\nhighly specific to the operating system and\narchitecture.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Ptrace\naccess mode checking</b> <br>\nVarious parts of the kernel-user-space API (not just\n<b>ptrace</b>() operations), require so-called &quot;ptrace\naccess mode&quot; checks, whose outcome determines whether\nan operation is permitted (or, in a few cases, causes a\n&quot;read&quot; operation to return sanitized data). These\nchecks are performed in cases where one process can inspect\nsensitive information about, or in some cases modify the\nstate of, another process. The checks are based on factors\nsuch as the credentials and capabilities of the two\nprocesses, whether or not the &quot;target&quot; process is\ndumpable, and the results of checks performed by any enabled\nLinux Security Module (LSM)&mdash;for example, SELinux,\nYama, or Smack&mdash;and by the commoncap LSM (which is\nalways invoked).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prior to Linux\n2.6.27, all access checks were of a single type. Since Linux\n2.6.27, two access mode levels are distinguished: <b><br>\nPTRACE_MODE_READ</b></p>\n\n<p style=\"margin-left:22%;\">For &quot;read&quot; operations\nor other operations that are less dangerous, such as:\n<a href=\"https://man.page/2/get_robust_list\">get_robust_list(2)</a>; <a href=\"https://man.page/2/kcmp\">kcmp(2)</a>; reading\n<i>/proc/[pid]/auxv</i>, <i>/proc/[pid]/environ</i>, or\n<i>/proc/[pid]/stat</i>; or <a href=\"https://man.page/2/readlink\">readlink(2)</a> of a\n<i>/proc/[pid]/ns/*</i> file.</p>\n\n<p style=\"margin-left:11%;\"><b>PTRACE_MODE_ATTACH</b></p>\n\n<p style=\"margin-left:22%;\">For &quot;write&quot;\noperations, or other operations that are more dangerous,\nsuch as: ptrace attaching (<b>PTRACE_ATTACH</b>) to another\nprocess or calling <a href=\"https://man.page/2/process_vm_writev\">process_vm_writev(2)</a>.\n(<b>PTRACE_MODE_ATTACH</b> was effectively the default\nbefore Linux 2.6.27.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n4.5, the above access mode checks are combined (ORed) with\none of the following modifiers: <b><br>\nPTRACE_MODE_FSCREDS</b></p>\n\n<p style=\"margin-left:22%;\">Use the caller&rsquo;s\nfilesystem UID and GID (see <a href=\"https://man.page/7/credentials\">credentials(7)</a>) or\neffective capabilities for LSM checks.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTRACE_MODE_REALCREDS</b></p>\n\n<p style=\"margin-left:22%;\">Use the caller&rsquo;s real UID\nand GID or permitted capabilities for LSM checks. This was\neffectively the default before Linux 4.5.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because\ncombining one of the credential modifiers with one of the\naforementioned access modes is typical, some macros are\ndefined in the kernel sources for the combinations: <b><br>\nPTRACE_MODE_READ_FSCREDS</b></p>\n\n<p style=\"margin-left:22%;\">Defined as <b>PTRACE_MODE_READ\n| PTRACE_MODE_FSCREDS</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTRACE_MODE_READ_REALCREDS</b></p>\n\n<p style=\"margin-left:22%;\">Defined as <b>PTRACE_MODE_READ\n| PTRACE_MODE_REALCREDS</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTRACE_MODE_ATTACH_FSCREDS</b></p>\n\n<p style=\"margin-left:22%;\">Defined as\n<b>PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTRACE_MODE_ATTACH_REALCREDS</b></p>\n\n<p style=\"margin-left:22%;\">Defined as\n<b>PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One further\nmodifier can be ORed with the access mode: <b><br>\nPTRACE_MODE_NOAUDIT</b> (since Linux 3.3)</p>\n\n<p style=\"margin-left:22%;\">Don&rsquo;t audit this access\nmode check. This modifier is employed for ptrace access mode\nchecks (such as checks when reading <i>/proc/[pid]/stat</i>)\nthat merely cause the output to be filtered or sanitized,\nrather than causing an error to be returned to the caller.\nIn these cases, accessing the file is not a security\nviolation and there is no reason to generate a security\naudit record. This modifier suppresses the generation of\nsuch an audit record for the particular access check.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that all\nof the <b>PTRACE_MODE_*</b> constants described in this\nsubsection are kernel-internal, and not visible to user\nspace. The constant names are mentioned here in order to\nlabel the various kinds of ptrace access mode checks that\nare performed for various system calls and accesses to\nvarious pseudofiles (e.g., under <i>/proc</i>). These names\nare used in other manual pages to provide a simple shorthand\nfor labeling the different kernel checks.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The algorithm\nemployed for ptrace access mode checking determines whether\nthe calling process is allowed to perform the corresponding\naction on the target process. (In the case of opening\n<i>/proc/[pid]</i> files, the &quot;calling process&quot; is\nthe one opening the file, and the process with the\ncorresponding PID is the &quot;target process&quot;.) The\nalgorithm is as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>If the calling thread and the target thread are in the\nsame thread group, access is always allowed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>If the access mode specifies <b>PTRACE_MODE_FSCREDS</b>,\nthen, for the check in the next step, employ the\ncaller&rsquo;s filesystem UID and GID. (As noted in\n<a href=\"https://man.page/7/credentials\">credentials(7)</a>, the filesystem UID and GID almost\nalways have the same values as the corresponding effective\nIDs.)</p> </td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">Otherwise, the\naccess mode specifies <b>PTRACE_MODE_REALCREDS</b>, so use\nthe caller&rsquo;s real UID and GID for the checks in the\nnext step. (Most APIs that check the caller&rsquo;s UID and\nGID use the effective IDs. For historical reasons, the\n<b>PTRACE_MODE_REALCREDS</b> check uses the real IDs\ninstead.)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\">Deny access if <i>neither</i> of\nthe following is true:</p></td>\n<td width=\"11%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\"></td>\n<td width=\"1%\"></td>\n<td width=\"82%\">\n\n\n<p style=\"margin-top: 1em\">The real, effective, and\nsaved-set user IDs of the target match the caller&rsquo;s\nuser ID, <i>and</i> the real, effective, and saved-set group\nIDs of the target match the caller&rsquo;s group ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"82%\">\n\n\n<p>The caller has the <b>CAP_SYS_PTRACE</b> capability in\nthe user namespace of the target.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>4.</p></td>\n<td width=\"1%\"></td>\n<td width=\"82%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">Deny access if\nthe target process &quot;dumpable&quot; attribute has a\nvalue other than 1 (<b>SUID_DUMP_USER</b>; see the\ndiscussion of <b>PR_SET_DUMPABLE</b> in <a href=\"https://man.page/2/prctl\">prctl(2)</a>),\nand the caller does not have the <b>CAP_SYS_PTRACE</b>\ncapability in the user namespace of the target process.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">5.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The kernel LSM\n<i>security_ptrace_access_check</i>() interface is invoked\nto see if ptrace access is permitted. The results depend on\nthe LSM(s). The implementation of this interface in the\ncommoncap LSM performs the following steps:</p></td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">a)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"3%\"></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">If the access mode includes\n<b>PTRACE_MODE_FSCREDS</b>, then use the caller&rsquo;s\n<i>effective</i> capability set in the following check;\notherwise (the access mode specifies\n<b>PTRACE_MODE_REALCREDS</b>, so) use the caller&rsquo;s\n<i>permitted</i> capability set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"3%\">\n\n\n<p>b)</p></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p>Deny access if <i>neither</i> of the following is\ntrue:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:20%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">The caller and the target\nprocess are in the same user namespace, and the\ncaller&rsquo;s capabilities are a superset of the target\nprocess&rsquo;s <i>permitted</i> capabilities.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>The caller has the <b>CAP_SYS_PTRACE</b> capability in\nthe target process&rsquo;s user namespace.</p></td></tr>\n</table>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Note that the\ncommoncap LSM does not distinguish between\n<b>PTRACE_MODE_READ</b> and <b>PTRACE_MODE_ATTACH</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">6.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">If access has not been denied by\nany of the preceding steps, then access is allowed.</p></td></tr>\n</table>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc/sys/kernel/yama/ptrace_scope</b>\n<br>\nOn systems with the Yama Linux Security Module (LSM)\ninstalled (i.e., the kernel was configured with\n<b>CONFIG_SECURITY_YAMA</b>), the\n<i>/proc/sys/kernel/yama/ptrace_scope</i> file (available\nsince Linux 3.4) can be used to restrict the ability to\ntrace a process with <b>ptrace</b>() (and thus also the\nability to use tools such as <a href=\"https://man.page/1/strace\">strace(1)</a> and\n<a href=\"https://man.page/1/gdb\">gdb(1)</a>). The goal of such restrictions is to prevent\nattack escalation whereby a compromised process can\nptrace-attach to other sensitive processes (e.g., a GPG\nagent or an SSH session) owned by the user in order to gain\nadditional credentials that may exist in memory and thus\nexpand the scope of the attack.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">More precisely,\nthe Yama LSM limits two types of operations:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Any operation that performs a\nptrace access mode <b>PTRACE_MODE_ATTACH</b> check&mdash;for\nexample, <b>ptrace</b>() <b>PTRACE_ATTACH</b>. (See the\n&quot;Ptrace access mode checking&quot; discussion\nabove.)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><b>ptrace</b>() <b>PTRACE_TRACEME</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process that\nhas the <b>CAP_SYS_PTRACE</b> capability can update the\n<i>/proc/sys/kernel/yama/ptrace_scope</i> file with one of\nthe following values: <br>\n0 (&quot;classic ptrace permissions&quot;)</p>\n\n<p style=\"margin-left:22%;\">No additional restrictions on\noperations that perform <b>PTRACE_MODE_ATTACH</b> checks\n(beyond those imposed by the commoncap and other LSMs).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The use of\n<b>PTRACE_TRACEME</b> is unchanged.</p>\n\n<p style=\"margin-left:11%;\">1 (&quot;restricted\nptrace&quot;) [default value]</p>\n\n<p style=\"margin-left:22%;\">When performing an operation\nthat requires a <b>PTRACE_MODE_ATTACH</b> check, the calling\nprocess must either have the <b>CAP_SYS_PTRACE</b>\ncapability in the user namespace of the target process or it\nmust have a predefined relationship with the target process.\nBy default, the predefined relationship is that the target\nprocess must be a descendant of the caller.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A target\nprocess can employ the <a href=\"https://man.page/2/prctl\">prctl(2)</a> <b>PR_SET_PTRACER</b>\noperation to declare an additional PID that is allowed to\nperform <b>PTRACE_MODE_ATTACH</b> operations on the target.\nSee the kernel source file\n<i>Documentation/admin-guide/LSM/Yama.rst</i> (or\n<i>Documentation/security/Yama.txt</i> before Linux 4.13)\nfor further details.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The use of\n<b>PTRACE_TRACEME</b> is unchanged.</p>\n\n<p style=\"margin-left:11%;\">2 (&quot;admin-only\nattach&quot;)</p>\n\n<p style=\"margin-left:22%;\">Only processes with the\n<b>CAP_SYS_PTRACE</b> capability in the user namespace of\nthe target process may perform <b>PTRACE_MODE_ATTACH</b>\noperations or trace children that employ\n<b>PTRACE_TRACEME</b>.</p>\n\n<p style=\"margin-left:11%;\">3 (&quot;no attach&quot;)</p>\n\n<p style=\"margin-left:22%;\">No process may perform\n<b>PTRACE_MODE_ATTACH</b> operations or trace children that\nemploy <b>PTRACE_TRACEME</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Once this value\nhas been written to the file, it cannot be changed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With respect to\nvalues 1 and 2, note that creating a new user namespace\neffectively removes the protection offered by Yama. This is\nbecause a process in the parent user namespace whose\neffective UID matches the UID of the creator of a child\nnamespace has all capabilities (including\n<b>CAP_SYS_PTRACE</b>) when performing operations within the\nchild user namespace (and further-removed descendants of\nthat namespace). Consequently, when a process tries to use\nuser namespaces to sandbox itself, it inadvertently weakens\nthe protections offered by the Yama LSM.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nAt the system call level, the <b>PTRACE_PEEKTEXT</b>,\n<b>PTRACE_PEEKDATA</b>, and <b>PTRACE_PEEKUSER</b> requests\nhave a different API: they store the result at the address\nspecified by the <i>data</i> parameter, and the return value\nis the error flag. The glibc wrapper function provides the\nAPI given in DESCRIPTION above, with the result being\nreturned via the function return value.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On hosts with\n2.6 kernel headers, <b>PTRACE_SETOPTIONS</b> is declared\nwith a different value than the one for 2.4. This leads to\napplications compiled with 2.6 kernel headers failing when\nrun on 2.4 kernels. This can be worked around by redefining\n<b>PTRACE_SETOPTIONS</b> to <b>PTRACE_OLDSETOPTIONS</b>, if\nthat is defined.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Group-stop\nnotifications are sent to the tracer, but not to real\nparent. Last confirmed on 2.6.38.6.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a thread\ngroup leader is traced and exits by calling <a href=\"https://man.page/2/_exit\">_exit(2)</a>,\na <b>PTRACE_EVENT_EXIT</b> stop will happen for it (if\nrequested), but the subsequent <b>WIFEXITED</b> notification\nwill not be delivered until all other threads exit. As\nexplained above, if one of other threads calls\n<a href=\"https://man.page/2/execve\">execve(2)</a>, the death of the thread group leader will\n<i>never</i> be reported. If the execed thread is not traced\nby this tracer, the tracer will never know that\n<a href=\"https://man.page/2/execve\">execve(2)</a> happened. One possible workaround is to\n<b>PTRACE_DETACH</b> the thread group leader instead of\nrestarting it in this case. Last confirmed on 2.6.38.6.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<b>SIGKILL</b> signal may still cause a\n<b>PTRACE_EVENT_EXIT</b> stop before actual signal death.\nThis may be changed in the future; <b>SIGKILL</b> is meant\nto always immediately kill tasks even under ptrace. Last\nconfirmed on Linux 3.13.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some system\ncalls return with <b>EINTR</b> if a signal was sent to a\ntracee, but delivery was suppressed by the tracer. (This is\nvery typical operation: it is usually done by debuggers on\nevery attach, in order to not introduce a bogus\n<b>SIGSTOP</b>). As of Linux 3.2.9, the following system\ncalls are affected (this list is likely incomplete):\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>, and <a href=\"https://man.page/2/read\">read(2)</a> from an\n<a href=\"https://man.page/7/inotify\">inotify(7)</a> file descriptor. The usual symptom of this\nbug is that when you attach to a quiescent process with the\ncommand</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">strace -p\n&lt;process-ID&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then, instead\nof the usual and expected one-line output such as</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">restart_syscall(&lt;...\nresuming interrupted call ...&gt;_</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">select(6, [5],\nNULL, [5], NULL_</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(&rsquo;_&rsquo;\ndenotes the cursor position), you observe more than one\nline. For example:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">clock_gettime(CLOCK_MONOTONIC,\n{15370, 690928118}) = 0 <br>\nepoll_wait(4,_</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">What is not\nvisible here is that the process was blocked in\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> before <a href=\"https://man.page/1/strace\">strace(1)</a> has attached to\nit. Attaching caused <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> to return to user\nspace with the error <b>EINTR</b>. In this particular case,\nthe program reacted to <b>EINTR</b> by checking the current\ntime, and then executing <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> again.\n(Programs which do not expect such &quot;stray&quot;\n<b>EINTR</b> errors may behave in an unintended way upon an\n<a href=\"https://man.page/1/strace\">strace(1)</a> attach.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Contrary to the\nnormal rules, the glibc wrapper for <b>ptrace</b>() can set\n<i>errno</i> to zero.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/gdb\">gdb(1)</a>,\n<a href=\"https://man.page/1/ltrace\">ltrace(1)</a>, <a href=\"https://man.page/1/strace\">strace(1)</a>, <a href=\"https://man.page/2/clone\">clone(2)</a>,\n<a href=\"https://man.page/2/execve\">execve(2)</a>, <a href=\"https://man.page/2/fork\">fork(2)</a>, <a href=\"https://man.page/2/gettid\">gettid(2)</a>,\n<a href=\"https://man.page/2/prctl\">prctl(2)</a>, <a href=\"https://man.page/2/seccomp\">seccomp(2)</a>, <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>,\n<a href=\"https://man.page/2/tgkill\">tgkill(2)</a>, <a href=\"https://man.page/2/vfork\">vfork(2)</a>, <a href=\"https://man.page/2/waitpid\">waitpid(2)</a>,\n<a href=\"https://man.page/3/exec\">exec(3)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/signal\">signal(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}