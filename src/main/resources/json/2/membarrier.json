{"name":"membarrier","body":"\n\n<h1 align=\"center\">MEMBARRIER</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">membarrier -\nissue memory barriers on a set of threads</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;linux/membarrier.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nmembarrier(int</b> <i>cmd</i><b>, unsigned int</b>\n<i>flags</i><b>, int</b> <i>cpu_id</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere is no glibc wrapper for this system call; see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>membarrier</b>() system call helps reducing the overhead\nof the memory barrier instructions required to order memory\naccesses on multi-core systems. However, this system call is\nheavier than a memory barrier, so using it effectively is\n<i>not</i> as simple as replacing memory barriers with this\nsystem call, but requires understanding of the details\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Use of memory\nbarriers needs to be done taking into account that a memory\nbarrier always needs to be either matched with its memory\nbarrier counterparts, or that the architecture&rsquo;s\nmemory model doesn&rsquo;t require the matching\nbarriers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are cases\nwhere one side of the matching barriers (which we will refer\nto as &quot;fast side&quot;) is executed much more often\nthan the other (which we will refer to as &quot;slow\nside&quot;). This is a prime target for the use of\n<b>membarrier</b>(). The key idea is to replace, for these\nmatching barriers, the fast-side memory barriers by simple\ncompiler barriers, for example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">asm volatile\n(&quot;&quot; : : : &quot;memory&quot;)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and replace the\nslow-side memory barriers by calls to\n<b>membarrier</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This will add\noverhead to the slow side, and remove overhead from the fast\nside, thus resulting in an overall performance increase as\nlong as the slow side is infrequent enough that the overhead\nof the <b>membarrier</b>() calls does not outweigh the\nperformance gain on the fast side.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>cmd</i>\nargument is one of the following: <b><br>\nMEMBARRIER_CMD_QUERY</b> (since Linux 4.3)</p>\n\n<p style=\"margin-left:22%;\">Query the set of supported\ncommands. The return value of the call is a bit mask of\nsupported commands. <b>MEMBARRIER_CMD_QUERY</b>, which has\nthe value 0, is not itself included in this bit mask. This\ncommand is always supported (on kernels where\n<b>membarrier</b>() is provided).</p>\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_GLOBAL</b>\n(since Linux 4.16)</p>\n\n<p style=\"margin-left:22%;\">Ensure that all threads from\nall processes on the system pass through a state where all\nmemory accesses to user-space addresses match program order\nbetween entry to and return from the <b>membarrier</b>()\nsystem call. All threads on the system are targeted by this\ncommand.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_GLOBAL_EXPEDITED</b>\n(since Linux 4.16)</p>\n\n<p style=\"margin-left:22%;\">Execute a memory barrier on all\nrunning threads of all processes that previously registered\nwith <b>MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Upon return\nfrom the system call, the calling thread has a guarantee\nthat all running threads have passed through a state where\nall memory accesses to user-space addresses match program\norder between entry to and return from the system call\n(non-running threads are de facto in such a state). This\nguarantee is provided only for the threads of processes that\npreviously registered with\n<b>MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Given that\nregistration is about the intent to receive the barriers, it\nis valid to invoke <b>MEMBARRIER_CMD_GLOBAL_EXPEDITED</b>\nfrom a process that has not employed\n<b>MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n&quot;expedited&quot; commands complete faster than the\nnon-expedited ones; they never block, but have the downside\nof causing extra overhead.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED</b>\n(since Linux 4.16)</p>\n\n<p style=\"margin-left:22%;\">Register the process&rsquo;s\nintent to receive <b>MEMBARRIER_CMD_GLOBAL_EXPEDITED</b>\nmemory barriers.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_PRIVATE_EXPEDITED</b>\n(since Linux 4.14)</p>\n\n<p style=\"margin-left:22%;\">Execute a memory barrier on\neach running thread belonging to the same process as the\ncalling thread.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Upon return\nfrom the system call, the calling thread has a guarantee\nthat all its running thread siblings have passed through a\nstate where all memory accesses to user-space addresses\nmatch program order between entry to and return from the\nsystem call (non-running threads are de facto in such a\nstate). This guarantee is provided only for threads in the\nsame process as the calling thread.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n&quot;expedited&quot; commands complete faster than the\nnon-expedited ones; they never block, but have the downside\nof causing extra overhead.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A process must\nregister its intent to use the private expedited command\nprior to using it.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED</b>\n(since Linux 4.14)</p>\n\n<p style=\"margin-left:22%;\">Register the process&rsquo;s\nintent to use <b>MEMBARRIER_CMD_PRIVATE_EXPEDITED</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</b>\n(since Linux 4.16)</p>\n\n<p style=\"margin-left:22%;\">In addition to providing the\nmemory ordering guarantees described in\n<b>MEMBARRIER_CMD_PRIVATE_EXPEDITED</b>, upon return from\nsystem call the calling thread has a guarantee that all its\nrunning thread siblings have executed a core serializing\ninstruction. This guarantee is provided only for threads in\nthe same process as the calling thread.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n&quot;expedited&quot; commands complete faster than the\nnon-expedited ones, they never block, but have the downside\nof causing extra overhead.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A process must\nregister its intent to use the private expedited sync core\ncommand prior to using it.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE</b>\n(since Linux 4.16)</p>\n\n<p style=\"margin-left:22%;\">Register the process&rsquo;s\nintent to use\n<b>MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ</b>\n(since Linux 5.10)</p>\n\n<p style=\"margin-left:22%;\">Ensure the caller thread, upon\nreturn from system call, that all its running thread\nsiblings have any currently running rseq critical sections\nrestarted if <i>flags</i> parameter is 0; if <i>flags</i>\nparameter is <b>MEMBARRIER_CMD_FLAG_CPU</b>, then this\noperation is performed only on CPU indicated by\n<i>cpu_id</i>. This guarantee is provided only for threads\nin the same process as the calling thread.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">RSEQ membarrier\nis only available in the &quot;private expedited&quot;\nform.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A process must\nregister its intent to use the private expedited rseq\ncommand prior to using it.</p>\n\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ</b>\n(since Linux 5.10)</p>\n\n<p style=\"margin-left:22%;\">Register the process&rsquo;s\nintent to use\n<b>MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>MEMBARRIER_CMD_SHARED</b>\n(since Linux 4.3)</p>\n\n<p style=\"margin-left:22%;\">This is an alias for\n<b>MEMBARRIER_CMD_GLOBAL</b> that exists for header backward\ncompatibility.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument must be specified as 0 unless the\ncommand is <b>MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ</b>, in\nwhich case <i>flags</i> can be either 0 or\n<b>MEMBARRIER_CMD_FLAG_CPU</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cpu_id</i> argument is ignored unless <i>flags</i> is\n<b>MEMBARRIER_CMD_FLAG_CPU</b>, in which case it must\nspecify the CPU targeted by this membarrier command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All memory\naccesses performed in program order from each targeted\nthread are guaranteed to be ordered with respect to\n<b>membarrier</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If we use the\nsemantic <i>barrier()</i> to represent a compiler barrier\nforcing memory accesses to be performed in program order\nacross the barrier, and <i>smp_mb()</i> to represent\nexplicit memory barriers forcing full memory ordering across\nthe barrier, we have the following ordering table for each\npairing of <i>barrier()</i>, <b>membarrier</b>(), and\n<i>smp_mb()</i>. The pair ordering is detailed as (O:\nordered, X: not ordered):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">barrier()\nsmp_mb() membarrier() <br>\nbarrier() X X O <br>\nsmp_mb() X O O <br>\nmembarrier() O O O</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success, the\n<b>MEMBARRIER_CMD_QUERY</b> operation returns a bit mask of\nsupported commands, and the <b>MEMBARRIER_CMD_GLOBAL</b>,\n<b>MEMBARRIER_CMD_GLOBAL_EXPEDITED</b>,\n<b>MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED</b>,\n<b>MEMBARRIER_CMD_PRIVATE_EXPEDITED</b>,\n<b>MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED</b>,\n<b>MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</b>, and\n<b>MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE</b>\noperations return zero. On error, -1 is returned, and\n<i>errno</i> is set appropriately.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a given\ncommand, with <i>flags</i> set to 0, this system call is\nguaranteed to always return the same value until reboot.\nFurther calls with the same arguments will lead to the same\nresult. Therefore, with <i>flags</i> set to 0, error\nhandling is required only for the first call to\n<b>membarrier</b>().</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><i>cmd</i> is invalid, or\n<i>flags</i> is nonzero, or the <b>MEMBARRIER_CMD_GLOBAL</b>\ncommand is disabled because the <i>nohz_full</i> CPU\nparameter has been set, or the\n<b>MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</b> and\n<b>MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE</b>\ncommands are not implemented by the architecture.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <b>membarrier</b>() system call is not implemented\nby this kernel.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The current process was not registered prior to using\nprivate expedited commands.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>membarrier</b>() system call was added in Linux 4.3.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n5.10, the prototype for <b>membarrier</b>() was:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>int\nmembarrier(int</b> <i>cmd</i><b>, int</b>\n<i>flags</i><b>);</b></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>membarrier</b>()\nis Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A memory\nbarrier instruction is part of the instruction set of\narchitectures with weakly ordered memory models. It orders\nmemory accesses prior to the barrier and after the barrier\nwith respect to matching barriers on other cores. For\ninstance, a load fence can order loads prior to and\nfollowing that fence with respect to stores ordered by store\nfences.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Program order\nis the order in which instructions are ordered in the\nprogram assembly code.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Examples where\n<b>membarrier</b>() can be useful include implementations of\nRead-Copy-Update libraries and garbage collectors.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glibc does not\nprovide a wrapper for this system call; call it using\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Assuming a\nmultithreaded application where &quot;fast_path()&quot; is\nexecuted very frequently, and where &quot;slow_path()&quot;\nis executed infrequently, the following code (x86) can be\ntransformed using <b>membarrier</b>():</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#include\n&lt;stdlib.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static volatile\nint a, b;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static void\n<br>\nfast_path(int *read_b) <br>\n{ <br>\na = 1; <br>\nasm volatile (&quot;mfence&quot; : : : &quot;memory&quot;);\n<br>\n*read_b = b; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static void\n<br>\nslow_path(int *read_a) <br>\n{ <br>\nb = 1; <br>\nasm volatile (&quot;mfence&quot; : : : &quot;memory&quot;);\n<br>\n*read_a = a; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nmain(int argc, char **argv) <br>\n{ <br>\nint read_a, read_b;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* Real applications would call fast_path() and slow_path()\n<br>\n* from different threads. Call those from main() to keep\n<br>\n* this example short. <br>\n*/</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">slow_path(&amp;read_a);\n<br>\nfast_path(&amp;read_b);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* read_b == 0 implies read_a == 1 and <br>\n* read_a == 0 implies read_b == 1. <br>\n*/</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (read_b == 0\n&amp;&amp; read_a == 0) <br>\nabort();</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The code above\ntransformed to use <b>membarrier</b>() becomes:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define\n_GNU_SOURCE <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/syscall.h&gt; <br>\n#include &lt;linux/membarrier.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static volatile\nint a, b;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static int <br>\nmembarrier(int cmd, unsigned int flags, int cpu_id) <br>\n{ <br>\nreturn syscall(__NR_membarrier, cmd, flags, cpu_id); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static int <br>\ninit_membarrier(void) <br>\n{ <br>\nint ret;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Check that\nmembarrier() is supported. */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">ret =\nmembarrier(MEMBARRIER_CMD_QUERY, 0, 0); <br>\nif (ret &lt; 0) { <br>\nperror(&quot;membarrier&quot;); <br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (!(ret &amp;\nMEMBARRIER_CMD_GLOBAL)) { <br>\nfprintf(stderr, <br>\n&quot;membarrier does not support\nMEMBARRIER_CMD_GLOBAL\\n&quot;); <br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">return 0; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static void\n<br>\nfast_path(int *read_b) <br>\n{ <br>\na = 1; <br>\nasm volatile (&quot;&quot; : : : &quot;memory&quot;); <br>\n*read_b = b; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static void\n<br>\nslow_path(int *read_a) <br>\n{ <br>\nb = 1; <br>\nmembarrier(MEMBARRIER_CMD_GLOBAL, 0, 0); <br>\n*read_a = a; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nmain(int argc, char **argv) <br>\n{ <br>\nint read_a, read_b;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(init_membarrier()) <br>\nexit(EXIT_FAILURE);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* Real applications would call fast_path() and slow_path()\n<br>\n* from different threads. Call those from main() to keep\n<br>\n* this example short. <br>\n*/</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">slow_path(&amp;read_a);\n<br>\nfast_path(&amp;read_b);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n* read_b == 0 implies read_a == 1 and <br>\n* read_a == 0 implies read_b == 1. <br>\n*/</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (read_b == 0\n&amp;&amp; read_a == 0) <br>\nabort();</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}