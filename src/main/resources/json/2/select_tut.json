{"name":"select_tut","body":"\n\n<h1 align=\"center\">SELECT_TUT</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">select, pselect\n- synchronous I/O multiplexing</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/2/select\">select(2)</a></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>select</b>() and <b>pselect</b>() system calls are used\nto efficiently monitor multiple file descriptors, to see if\nany of them is, or becomes, &quot;ready&quot;; that is, to\nsee whether I/O becomes possible, or an &quot;exceptional\ncondition&quot; has occurred on any of the file\ndescriptors.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page\nprovides background and tutorial information on the use of\nthese system calls. For details of the arguments and\nsemantics of <b>select</b>() and <b>pselect</b>(), see\n<a href=\"https://man.page/2/select\">select(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Combining\nsignal and data events <br>\npselect</b>() is useful if you are waiting for a signal as\nwell as for file descriptor(s) to become ready for I/O.\nPrograms that receive signals normally use the signal\nhandler only to raise a global flag. The global flag will\nindicate that the event must be processed in the main loop\nof the program. A signal will cause the <b>select</b>() (or\n<b>pselect</b>()) call to return with <i>errno</i> set to\n<b>EINTR</b>. This behavior is essential so that signals can\nbe processed in the main loop of the program, otherwise\n<b>select</b>() would block indefinitely.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, somewhere\nin the main loop will be a conditional to check the global\nflag. So we must ask: what if a signal arrives after the\nconditional, but before the <b>select</b>() call? The answer\nis that <b>select</b>() would block indefinitely, even\nthough an event is actually pending. This race condition is\nsolved by the <b>pselect</b>() call. This call can be used\nto set the signal mask to a set of signals that are to be\nreceived only within the <b>pselect</b>() call. For\ninstance, let us say that the event in question was the exit\nof a child process. Before the start of the main loop, we\nwould block <b>SIGCHLD</b> using <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>. Our\n<b>pselect</b>() call would enable <b>SIGCHLD</b> by using\nan empty signal mask. Our program would look like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static volatile\nsig_atomic_t got_SIGCHLD = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nchild_sig_handler(int sig) <br>\n{ <br>\ngot_SIGCHLD = 1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nsigset_t sigmask, empty_mask; <br>\nstruct sigaction sa; <br>\nfd_set readfds, writefds, exceptfds; <br>\nint r;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sigemptyset(&amp;sigmask);\n<br>\nsigaddset(&amp;sigmask, SIGCHLD); <br>\nif (sigprocmask(SIG_BLOCK, &amp;sigmask, NULL) == -1) { <br>\nperror(&quot;sigprocmask&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sa.sa_flags =\n0; <br>\nsa.sa_handler = child_sig_handler; <br>\nsigemptyset(&amp;sa.sa_mask); <br>\nif (sigaction(SIGCHLD, &amp;sa, NULL) == -1) { <br>\nperror(&quot;sigaction&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sigemptyset(&amp;empty_mask);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { /*\nmain loop */ <br>\n/* Initialize readfds, writefds, and exceptfds <br>\nbefore the pselect() call. (Code omitted.) */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">r =\npselect(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds,\n<br>\nNULL, &amp;empty_mask); <br>\nif (r == -1 &amp;&amp; errno != EINTR) { <br>\n/* Handle error */ <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(got_SIGCHLD) { <br>\ngot_SIGCHLD = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Handle\nsignalled event here; e.g., wait() for all <br>\nterminated children. (Code omitted.) */ <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* main body of\nprogram */ <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Practical</b>\n<br>\nSo what is the point of <b>select</b>()? Can&rsquo;t I just\nread and write to my file descriptors whenever I want? The\npoint of <b>select</b>() is that it watches multiple\ndescriptors at the same time and properly puts the process\nto sleep if there is no activity. UNIX programmers often\nfind themselves in a position where they have to handle I/O\nfrom more than one file descriptor where the data flow may\nbe intermittent. If you were to merely create a sequence of\n<a href=\"https://man.page/2/read\">read(2)</a> and <a href=\"https://man.page/2/write\">write(2)</a> calls, you would find\nthat one of your calls may block waiting for data from/to a\nfile descriptor, while another file descriptor is unused\nthough ready for I/O. <b>select</b>() efficiently copes with\nthis situation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Select\nlaw</b> <br>\nMany people who try to use <b>select</b>() come across\nbehavior that is difficult to understand and produces\nnonportable or borderline results. For instance, the above\nprogram is carefully written not to block at any point, even\nthough it does not set its file descriptors to nonblocking\nmode. It is easy to introduce subtle errors that will remove\nthe advantage of using <b>select</b>(), so here is a list of\nessentials to watch for when using <b>select</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>1.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>You should always try to use <b>select</b>() without a\ntimeout. Your program should have nothing to do if there is\nno data available. Code that depends on timeouts is not\nusually portable and is difficult to debug.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>2.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>The value <i>nfds</i> must be properly calculated for\nefficiency as explained above.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>3.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>No file descriptor must be added to any set if you do\nnot intend to check its result after the <b>select</b>()\ncall, and respond appropriately. See next rule.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>4.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>After <b>select</b>() returns, all file descriptors in\nall sets should be checked to see if they are ready.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>5.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>The functions <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/recv\">recv(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, and <a href=\"https://man.page/2/send\">send(2)</a> do <i>not</i>\nnecessarily read/write the full amount of data that you have\nrequested. If they do read/write the full amount, it&rsquo;s\nbecause you have a low traffic load and a fast stream. This\nis not always going to be the case. You should cope with the\ncase of your functions managing to send or receive only a\nsingle byte.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>6.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Never read/write only in single bytes at a time unless\nyou are really sure that you have a small amount of data to\nprocess. It is extremely inefficient not to read/write as\nmuch data as you can buffer each time. The buffers in the\nexample below are 1024 bytes although they could easily be\nmade larger.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>7.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Calls to <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/recv\">recv(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/2/send\">send(2)</a>, and <b>select</b>() can\nfail with the error <b>EINTR</b>, and calls to\n<a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/recv\">recv(2)</a> <a href=\"https://man.page/2/write\">write(2)</a>, and\n<a href=\"https://man.page/2/send\">send(2)</a> can fail with <i>errno</i> set to\n<b>EAGAIN</b> (<b>EWOULDBLOCK</b>). These results must be\nproperly managed (not done properly above). If your program\nis not going to receive any signals, then it is unlikely you\nwill get <b>EINTR</b>. If your program does not set\nnonblocking I/O, you will not get <b>EAGAIN</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>8.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Never call <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/recv\">recv(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, or <a href=\"https://man.page/2/send\">send(2)</a> with a buffer length of\nzero.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>9.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>If the functions <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/recv\">recv(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, and <a href=\"https://man.page/2/send\">send(2)</a> fail with errors other\nthan those listed in <b>7.</b>, or one of the input\nfunctions returns 0, indicating end of file, then you should\n<i>not</i> pass that file descriptor to <b>select</b>()\nagain. In the example below, I close the file descriptor\nimmediately, and then set it to -1 to prevent it being\nincluded in a set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>10.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>The timeout value must be initialized with each new call\nto <b>select</b>(), since some operating systems modify the\nstructure. <b>pselect</b>() however does not modify its\ntimeout structure.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>11.</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Since <b>select</b>() modifies its file descriptor sets,\nif the call is being used in a loop, then the sets must be\nreinitialized before each call.</p></td></tr>\n</table>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/2/select\">select(2)</a>.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Generally\nspeaking, all operating systems that support sockets also\nsupport <b>select</b>(). <b>select</b>() can be used to\nsolve many problems in a portable and efficient way that\nnaive programmers try to solve in a more complicated manner\nusing threads, forking, IPCs, signals, memory sharing, and\nso on.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/poll\">poll(2)</a> system call has the same functionality as\n<b>select</b>(), and is somewhat more efficient when\nmonitoring sparse file descriptor sets. It is nowadays\nwidely available, but historically was less portable than\n<b>select</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nLinux-specific <a href=\"https://man.page/7/epoll\">epoll(7)</a> API provides an interface\nthat is more efficient than <a href=\"https://man.page/2/select\">select(2)</a> and\n<a href=\"https://man.page/2/poll\">poll(2)</a> when monitoring large numbers of file\ndescriptors.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is an\nexample that better demonstrates the true utility of\n<b>select</b>(). The listing below is a TCP forwarding\nprogram that forwards from one TCP port to another.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stdlib.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/select.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;signal.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;netinet/in.h&gt; <br>\n#include &lt;arpa/inet.h&gt; <br>\n#include &lt;errno.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int\nforward_port;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#undef max <br>\n#define max(x,y) ((x) &gt; (y) ? (x) : (y))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\nlisten_socket(int listen_port) <br>\n{ <br>\nstruct sockaddr_in addr; <br>\nint lfd; <br>\nint yes;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">lfd =\nsocket(AF_INET, SOCK_STREAM, 0); <br>\nif (lfd == -1) { <br>\nperror(&quot;socket&quot;); <br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">yes = 1; <br>\nif (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, <br>\n&amp;yes, sizeof(yes)) == -1) { <br>\nperror(&quot;setsockopt&quot;); <br>\nclose(lfd); <br>\nreturn -1; <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(&amp;addr,\n0, sizeof(addr)); <br>\naddr.sin_port = htons(listen_port); <br>\naddr.sin_family = AF_INET; <br>\nif (bind(lfd, (struct sockaddr *) &amp;addr, sizeof(addr))\n== -1) { <br>\nperror(&quot;bind&quot;); <br>\nclose(lfd); <br>\nreturn -1; <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;accepting\nconnections on port %d\\n&quot;, listen_port); <br>\nlisten(lfd, 10); <br>\nreturn lfd; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\nconnect_socket(int connect_port, char *address) <br>\n{ <br>\nstruct sockaddr_in addr; <br>\nint cfd;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">cfd =\nsocket(AF_INET, SOCK_STREAM, 0); <br>\nif (cfd == -1) { <br>\nperror(&quot;socket&quot;); <br>\nreturn -1; <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(&amp;addr,\n0, sizeof(addr)); <br>\naddr.sin_port = htons(connect_port); <br>\naddr.sin_family = AF_INET;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(!inet_aton(address, (struct in_addr *)\n&amp;addr.sin_addr.s_addr)) { <br>\nfprintf(stderr, &quot;inet_aton(): bad IP address\nformat\\n&quot;); <br>\nclose(cfd); <br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(connect(cfd, (struct sockaddr *) &amp;addr, sizeof(addr))\n== -1) { <br>\nperror(&quot;connect()&quot;); <br>\nshutdown(cfd, SHUT_RDWR); <br>\nclose(cfd); <br>\nreturn -1; <br>\n} <br>\nreturn cfd; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nSHUT_FD1 do { \\ <br>\nif (fd1 &gt;= 0) { \\ <br>\nshutdown(fd1, SHUT_RDWR); \\ <br>\nclose(fd1); \\ <br>\nfd1 = -1; \\ <br>\n} \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nSHUT_FD2 do { \\ <br>\nif (fd2 &gt;= 0) { \\ <br>\nshutdown(fd2, SHUT_RDWR); \\ <br>\nclose(fd2); \\ <br>\nfd2 = -1; \\ <br>\n} \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nBUF_SIZE 1024</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint h; <br>\nint fd1 = -1, fd2 = -1; <br>\nchar buf1[BUF_SIZE], buf2[BUF_SIZE]; <br>\nint buf1_avail = 0, buf1_written = 0; <br>\nint buf2_avail = 0, buf2_written = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 4)\n{ <br>\nfprintf(stderr, &quot;Usage\\n\\tfwd &lt;listen-port&gt;\n&quot; <br>\n&quot;&lt;forward-to-port&gt;\n&lt;forward-to-ip-address&gt;\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">signal(SIGPIPE,\nSIG_IGN);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">forward_port =\natoi(argv[2]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">h =\nlisten_socket(atoi(argv[1])); <br>\nif (h == -1) <br>\nexit(EXIT_FAILURE);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { <br>\nint ready, nfds = 0; <br>\nssize_t nbytes; <br>\nfd_set readfds, writefds, exceptfds;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">FD_ZERO(&amp;readfds);\n<br>\nFD_ZERO(&amp;writefds); <br>\nFD_ZERO(&amp;exceptfds); <br>\nFD_SET(h, &amp;readfds); <br>\nnfds = max(nfds, h);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fd1 &gt; 0\n&amp;&amp; buf1_avail &lt; BUF_SIZE) <br>\nFD_SET(fd1, &amp;readfds); <br>\n/* Note: nfds is updated below, when fd1 is added to <br>\nexceptfds. */ <br>\nif (fd2 &gt; 0 &amp;&amp; buf2_avail &lt; BUF_SIZE) <br>\nFD_SET(fd2, &amp;readfds);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fd1 &gt; 0\n&amp;&amp; buf2_avail - buf2_written &gt; 0) <br>\nFD_SET(fd1, &amp;writefds); <br>\nif (fd2 &gt; 0 &amp;&amp; buf1_avail - buf1_written &gt; 0)\n<br>\nFD_SET(fd2, &amp;writefds);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fd1 &gt; 0)\n{ <br>\nFD_SET(fd1, &amp;exceptfds); <br>\nnfds = max(nfds, fd1); <br>\n} <br>\nif (fd2 &gt; 0) { <br>\nFD_SET(fd2, &amp;exceptfds); <br>\nnfds = max(nfds, fd2); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ready =\nselect(nfds + 1, &amp;readfds, &amp;writefds,\n&amp;exceptfds, NULL);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (ready == -1\n&amp;&amp; errno == EINTR) <br>\ncontinue;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (ready ==\n-1) { <br>\nperror(&quot;select()&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (FD_ISSET(h,\n&amp;readfds)) { <br>\nsocklen_t addrlen; <br>\nstruct sockaddr_in client_addr; <br>\nint fd;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">addrlen =\nsizeof(client_addr); <br>\nmemset(&amp;client_addr, 0, addrlen); <br>\nfd = accept(h, (struct sockaddr *) &amp;client_addr,\n&amp;addrlen); <br>\nif (fd == -1) { <br>\nperror(&quot;accept()&quot;); <br>\n} else { <br>\nSHUT_FD1; <br>\nSHUT_FD2; <br>\nbuf1_avail = buf1_written = 0; <br>\nbuf2_avail = buf2_written = 0; <br>\nfd1 = fd; <br>\nfd2 = connect_socket(forward_port, argv[3]); <br>\nif (fd2 == -1) <br>\nSHUT_FD1; <br>\nelse <br>\nprintf(&quot;connect from %s\\n&quot;, <br>\ninet_ntoa(client_addr.sin_addr));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Skip any\nevents on the old, closed file <br>\ndescriptors. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">continue; <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* NB: read OOB\ndata before normal reads */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fd1 &gt; 0\n&amp;&amp; FD_ISSET(fd1, &amp;exceptfds)) { <br>\nchar c;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nbytes =\nrecv(fd1, &amp;c, 1, MSG_OOB); <br>\nif (nbytes &lt; 1) <br>\nSHUT_FD1; <br>\nelse <br>\nsend(fd2, &amp;c, 1, MSG_OOB); <br>\n} <br>\nif (fd2 &gt; 0 &amp;&amp; FD_ISSET(fd2, &amp;exceptfds)) {\n<br>\nchar c;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nbytes =\nrecv(fd2, &amp;c, 1, MSG_OOB); <br>\nif (nbytes &lt; 1) <br>\nSHUT_FD2; <br>\nelse <br>\nsend(fd1, &amp;c, 1, MSG_OOB); <br>\n} <br>\nif (fd1 &gt; 0 &amp;&amp; FD_ISSET(fd1, &amp;readfds)) {\n<br>\nnbytes = read(fd1, buf1 + buf1_avail, <br>\nBUF_SIZE - buf1_avail); <br>\nif (nbytes &lt; 1) <br>\nSHUT_FD1; <br>\nelse <br>\nbuf1_avail += nbytes; <br>\n} <br>\nif (fd2 &gt; 0 &amp;&amp; FD_ISSET(fd2, &amp;readfds)) {\n<br>\nnbytes = read(fd2, buf2 + buf2_avail, <br>\nBUF_SIZE - buf2_avail); <br>\nif (nbytes &lt; 1) <br>\nSHUT_FD2; <br>\nelse <br>\nbuf2_avail += nbytes; <br>\n} <br>\nif (fd1 &gt; 0 &amp;&amp; FD_ISSET(fd1, &amp;writefds)\n&amp;&amp; buf2_avail &gt; 0) { <br>\nnbytes = write(fd1, buf2 + buf2_written, <br>\nbuf2_avail - buf2_written); <br>\nif (nbytes &lt; 1) <br>\nSHUT_FD1; <br>\nelse <br>\nbuf2_written += nbytes; <br>\n} <br>\nif (fd2 &gt; 0 &amp;&amp; FD_ISSET(fd2, &amp;writefds)\n&amp;&amp; buf1_avail &gt; 0) { <br>\nnbytes = write(fd2, buf1 + buf1_written, <br>\nbuf1_avail - buf1_written); <br>\nif (nbytes &lt; 1) <br>\nSHUT_FD2; <br>\nelse <br>\nbuf1_written += nbytes; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Check if\nwrite data has caught read data */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(buf1_written == buf1_avail) <br>\nbuf1_written = buf1_avail = 0; <br>\nif (buf2_written == buf2_avail) <br>\nbuf2_written = buf2_avail = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* One side has\nclosed the connection, keep <br>\nwriting to the other side until empty */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fd1 &lt; 0\n&amp;&amp; buf1_avail - buf1_written == 0) <br>\nSHUT_FD2; <br>\nif (fd2 &lt; 0 &amp;&amp; buf2_avail - buf2_written == 0)\n<br>\nSHUT_FD1; <br>\n} <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The above\nprogram properly forwards most kinds of TCP connections\nincluding OOB signal data transmitted by <b>telnet</b>\nservers. It handles the tricky problem of having data flow\nin both directions simultaneously. You might think it more\nefficient to use a <a href=\"https://man.page/2/fork\">fork(2)</a> call and devote a thread\nto each stream. This becomes more tricky than you might\nsuspect. Another idea is to set nonblocking I/O using\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>. This also has its problems because you end\nup using inefficient timeouts.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\ndoes not handle more than one simultaneous connection at a\ntime, although it could easily be extended to do this with a\nlinked list of buffers&mdash;one for each connection. At the\nmoment, new connections cause the current connection to be\ndropped.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/accept\">accept(2)</a>,\n<a href=\"https://man.page/2/connect\">connect(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>,\n<a href=\"https://man.page/2/recv\">recv(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/send\">send(2)</a>,\n<a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>, <a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/7/epoll\">epoll(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}