{"name":"signalfd","body":"\n\n<h1 align=\"center\">SIGNALFD</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">signalfd -\ncreate a file descriptor for accepting signals</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/signalfd.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nsignalfd(int</b> <i>fd</i><b>, const sigset_t\n*</b><i>mask</i><b>, int</b> <i>flags</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>signalfd</b>()\ncreates a file descriptor that can be used to accept signals\ntargeted at the caller. This provides an alternative to the\nuse of a signal handler or <a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>, and has\nthe advantage that the file descriptor may be monitored by\n<a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, and <a href=\"https://man.page/7/epoll\">epoll(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>mask</i>\nargument specifies the set of signals that the caller wishes\nto accept via the file descriptor. This argument is a signal\nset whose contents can be initialized using the macros\ndescribed in <a href=\"https://man.page/3/sigsetops\">sigsetops(3)</a>. Normally, the set of\nsignals to be received via the file descriptor should be\nblocked using <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>, to prevent the signals\nbeing handled according to their default dispositions. It is\nnot possible to receive <b>SIGKILL</b> or <b>SIGSTOP</b>\nsignals via a signalfd file descriptor; these signals are\nsilently ignored if specified in <i>mask</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<i>fd</i> argument is -1, then the call creates a new file\ndescriptor and associates the signal set specified in\n<i>mask</i> with that file descriptor. If <i>fd</i> is not\n-1, then it must specify a valid existing signalfd file\ndescriptor, and <i>mask</i> is used to replace the signal\nset associated with that file descriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting with\nLinux 2.6.27, the following values may be bitwise ORed in\n<i>flags</i> to change the behavior of\n<b>signalfd</b>():</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"18%\">\n\n\n<p><b>SFD_NONBLOCK</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"68%\">\n\n\n<p>Set the <b>O_NONBLOCK</b> file status flag on the open\nfile description (see <a href=\"https://man.page/2/open\">open(2)</a>) referred to by the new\nfile descriptor. Using this flag saves extra calls to\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a> to achieve the same result.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"18%\">\n\n\n<p><b>SFD_CLOEXEC</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"68%\">\n\n\n<p>Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the\nnew file descriptor. See the description of the\n<b>O_CLOEXEC</b> flag in <a href=\"https://man.page/2/open\">open(2)</a> for reasons why this\nmay be useful.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux up to\nversion 2.6.26, the <i>flags</i> argument is unused, and\nmust be specified as zero.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>signalfd</b>()\nreturns a file descriptor that supports the following\noperations: <b><br>\nread</b>(2)</p>\n\n<p style=\"margin-left:22%;\">If one or more of the signals\nspecified in <i>mask</i> is pending for the process, then\nthe buffer supplied to <a href=\"https://man.page/2/read\">read(2)</a> is used to return one\nor more <i>signalfd_siginfo</i> structures (see below) that\ndescribe the signals. The <a href=\"https://man.page/2/read\">read(2)</a> returns information\nfor as many signals as are pending and will fit in the\nsupplied buffer. The buffer must be at least\n<i>sizeof(struct signalfd_siginfo)</i> bytes. The return\nvalue of the <a href=\"https://man.page/2/read\">read(2)</a> is the total number of bytes\nread.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">As a\nconsequence of the <a href=\"https://man.page/2/read\">read(2)</a>, the signals are consumed,\nso that they are no longer pending for the process (i.e.,\nwill not be caught by signal handlers, and cannot be\naccepted using <a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If none of the\nsignals in <i>mask</i> is pending for the process, then the\n<a href=\"https://man.page/2/read\">read(2)</a> either blocks until one of the signals in\n<i>mask</i> is generated for the process, or fails with the\nerror <b>EAGAIN</b> if the file descriptor has been made\nnonblocking.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/poll\">poll(2)</a>,\n<a href=\"https://man.page/2/select\">select(2)</a> (and similar)</p>\n\n<p style=\"margin-left:22%;\">The file descriptor is readable\n(the <a href=\"https://man.page/2/select\">select(2)</a> <i>readfds</i> argument; the\n<a href=\"https://man.page/2/poll\">poll(2)</a> <b>POLLIN</b> flag) if one or more of the\nsignals in <i>mask</i> is pending for the process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The signalfd\nfile descriptor also supports the other file-descriptor\nmultiplexing APIs: <a href=\"https://man.page/2/pselect\">pselect(2)</a>, <a href=\"https://man.page/2/ppoll\">ppoll(2)</a>, and\n<a href=\"https://man.page/7/epoll\">epoll(7)</a>.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/close\">close(2)</a></p>\n\n<p style=\"margin-left:22%;\">When the file descriptor is no\nlonger required it should be closed. When all file\ndescriptors associated with the same signalfd object have\nbeen closed, the resources for object are freed by the\nkernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\nsignalfd_siginfo structure</b> <br>\nThe format of the <i>signalfd_siginfo</i> structure(s)\nreturned by <a href=\"https://man.page/2/read\">read(2)</a>s from a signalfd file descriptor\nis as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nsignalfd_siginfo { <br>\nuint32_t ssi_signo; /* Signal number */ <br>\nint32_t ssi_errno; /* Error number (unused) */ <br>\nint32_t ssi_code; /* Signal code */ <br>\nuint32_t ssi_pid; /* PID of sender */ <br>\nuint32_t ssi_uid; /* Real UID of sender */ <br>\nint32_t ssi_fd; /* File descriptor (SIGIO) */ <br>\nuint32_t ssi_tid; /* Kernel timer ID (POSIX timers) <br>\nuint32_t ssi_band; /* Band event (SIGIO) */ <br>\nuint32_t ssi_overrun; /* POSIX timer overrun count */ <br>\nuint32_t ssi_trapno; /* Trap number that caused signal */\n<br>\nint32_t ssi_status; /* Exit status or signal (SIGCHLD) */\n<br>\nint32_t ssi_int; /* Integer sent by sigqueue(3) */ <br>\nuint64_t ssi_ptr; /* Pointer sent by sigqueue(3) */ <br>\nuint64_t ssi_utime; /* User CPU time consumed (SIGCHLD) */\n<br>\nuint64_t ssi_stime; /* System CPU time consumed <br>\n(SIGCHLD) */ <br>\nuint64_t ssi_addr; /* Address that generated signal <br>\n(for hardware-generated signals) */ <br>\nuint16_t ssi_addr_lsb; /* Least significant bit of address\n<br>\n(SIGBUS; since Linux 2.6.37) <br>\nuint8_t pad[<i>X</i>]; /* Pad size to 128 bytes (allow for\n<br>\nadditional fields in the future) */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each of the\nfields in this structure is analogous to the similarly named\nfield in the <i>siginfo_t</i> structure. The\n<i>siginfo_t</i> structure is described in\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>. Not all fields in the returned\n<i>signalfd_siginfo</i> structure will be valid for a\nspecific signal; the set of valid fields can be determined\nfrom the value returned in the <i>ssi_code</i> field. This\nfield is the analog of the <i>siginfo_t si_code</i> field;\nsee <a href=\"https://man.page/2/sigaction\">sigaction(2)</a> for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>fork(2)\nsemantics</b> <br>\nAfter a <a href=\"https://man.page/2/fork\">fork(2)</a>, the child inherits a copy of the\nsignalfd file descriptor. A <a href=\"https://man.page/2/read\">read(2)</a> from the file\ndescriptor in the child will return information about\nsignals queued to the child.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Semantics of\nfile descriptor passing</b> <br>\nAs with other file descriptors, signalfd file descriptors\ncan be passed to another process via a UNIX domain socket\n(see <a href=\"https://man.page/7/unix\">unix(7)</a>). In the receiving process, a\n<a href=\"https://man.page/2/read\">read(2)</a> from the received file descriptor will return\ninformation about signals queued to that process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>execve(2)\nsemantics</b> <br>\nJust like any other file descriptor, a signalfd file\ndescriptor remains open across an <a href=\"https://man.page/2/execve\">execve(2)</a>, unless\nit has been marked for close-on-exec (see <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>).\nAny signals that were available for reading before the\n<a href=\"https://man.page/2/execve\">execve(2)</a> remain available to the newly loaded\nprogram. (This is analogous to traditional signal semantics,\nwhere a blocked signal that is pending remains pending\nacross an <a href=\"https://man.page/2/execve\">execve(2)</a>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Thread\nsemantics</b> <br>\nThe semantics of signalfd file descriptors in a\nmultithreaded program mirror the standard semantics for\nsignals. In other words, when a thread reads from a signalfd\nfile descriptor, it will read the signals that are directed\nto the thread itself and the signals that are directed to\nthe process (i.e., the entire thread group). (A thread will\nnot be able to read signals that are directed to other\nthreads in the process.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>epoll(7)\nsemantics</b> <br>\nIf a process adds (via <a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a>) a signalfd file\ndescriptor to an <a href=\"https://man.page/7/epoll\">epoll(7)</a> instance, then\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> returns events only for signals sent to\nthat process. In particular, if the process then uses\n<a href=\"https://man.page/2/fork\">fork(2)</a> to create a child process, then the child\nwill be able to <a href=\"https://man.page/2/read\">read(2)</a> signals that are sent to it\nusing the signalfd file descriptor, but <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>\nwill <b>not</b> indicate that the signalfd file descriptor\nis ready. In this scenario, a possible workaround is that\nafter the <a href=\"https://man.page/2/fork\">fork(2)</a>, the child process can close the\nsignalfd file descriptor that it inherited from the parent\nprocess and then create another signalfd file descriptor and\nadd it to the epoll instance. Alternatively, the parent and\nthe child could delay creating their (separate) signalfd\nfile descriptors and adding them to the epoll instance until\nafter the call to <a href=\"https://man.page/2/fork\">fork(2)</a>.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>signalfd</b>() returns a signalfd file descriptor; this\nis either a new file descriptor (if <i>fd</i> was -1), or\n<i>fd</i> if <i>fd</i> was a valid signalfd file descriptor.\nOn error, -1 is returned and <i>errno</i> is set to indicate\nthe error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The <i>fd</i> file descriptor is\nnot a valid file descriptor.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is not a valid signalfd file descriptor.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>flags</i> is invalid; or, in Linux 2.6.26 or earlier,\n<i>flags</i> is nonzero.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The per-process limit on the number of open file\ndescriptors has been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The system-wide limit on the total number of open files\nhas been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENODEV</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Could not mount (internal) anonymous inode device.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>There was insufficient memory to create a new signalfd\nfile descriptor.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>signalfd</b>()\nis available on Linux since kernel 2.6.22. Working support\nis provided in glibc since version 2.8. The\n<b>signalfd4</b>() system call (see NOTES) is available on\nLinux since kernel 2.6.27.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>signalfd</b>()\nand <b>signalfd4</b>() are Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process can\ncreate multiple signalfd file descriptors. This makes it\npossible to accept different signals on different file\ndescriptors. (This may be useful if monitoring the file\ndescriptors using <a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, or\n<a href=\"https://man.page/7/epoll\">epoll(7)</a>: the arrival of different signals will make\ndifferent file descriptors ready.) If a signal appears in\nthe <i>mask</i> of more than one of the file descriptors,\nthen occurrences of that signal can be read (once) from any\none of the file descriptors.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Attempts to\ninclude <b>SIGKILL</b> and <b>SIGSTOP</b> in <i>mask</i> are\nsilently ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The signal mask\nemployed by a signalfd file descriptor can be viewed via the\nentry for the corresponding file descriptor in the\nprocess&rsquo;s <i>/proc/[pid]/fdinfo</i> directory. See\n<a href=\"https://man.page/5/proc\">proc(5)</a> for further details.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Limitations</b>\n<br>\nThe signalfd mechanism can&rsquo;t be used to receive\nsignals that are synchronously generated, such as the\n<b>SIGSEGV</b> signal that results from accessing an invalid\nmemory address or the <b>SIGFPE</b> signal that results from\nan arithmetic error. Such signals can be caught only via\nsignal handler.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As described\nabove, in normal usage one blocks the signals that will be\naccepted via <b>signalfd</b>(). If spawning a child process\nto execute a helper program (that does not need the signalfd\nfile descriptor), then, after the call to <a href=\"https://man.page/2/fork\">fork(2)</a>,\nyou will normally want to unblock those signals before\ncalling <a href=\"https://man.page/2/execve\">execve(2)</a>, so that the helper program can see\nany signals that it expects to see. Be aware, however, that\nthis won&rsquo;t be possible in the case of a helper program\nspawned behind the scenes by any library function that the\nprogram may call. In such cases, one must fall back to using\na traditional signal handler that writes to a file\ndescriptor monitored by <a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, or\n<a href=\"https://man.page/7/epoll\">epoll(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nThe underlying Linux system call requires an additional\nargument, <i>size_t sizemask</i>, which specifies the size\nof the <i>mask</i> argument. The glibc <b>signalfd</b>()\nwrapper function does not include this argument, since it\nprovides the required value for the underlying system\ncall.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\nunderlying Linux system calls: <b>signalfd</b>() and the\nmore recent <b>signalfd4</b>(). The former system call does\nnot implement a <i>flags</i> argument. The latter system\ncall implements the <i>flags</i> values described above.\nStarting with glibc 2.9, the <b>signalfd</b>() wrapper\nfunction will use <b>signalfd4</b>() where it is\navailable.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In kernels\nbefore 2.6.25, the <i>ssi_ptr</i> and <i>ssi_int</i> fields\nare not filled in with the data accompanying a signal sent\nby <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow accepts the signals <b>SIGINT</b> and <b>SIGQUIT</b>\nvia a signalfd file descriptor. The program terminates after\naccepting a <b>SIGQUIT</b> signal. The following shell\nsession demonstrates the use of the program:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./signalfd_demo <br>\n^C</b> # Control-C generates SIGINT <br>\nGot SIGINT <b><br>\n^C</b> <br>\nGot SIGINT <b><br>\n^\\</b> # Control-\\ generates SIGQUIT <br>\nGot SIGQUIT <br>\n$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;sys/signalfd.h&gt; <br>\n#include &lt;signal.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;stdio.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error(msg) \\ <br>\ndo { perror(msg); exit(EXIT_FAILURE); } while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nsigset_t mask; <br>\nint sfd; <br>\nstruct signalfd_siginfo fdsi; <br>\nssize_t s;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sigemptyset(&amp;mask);\n<br>\nsigaddset(&amp;mask, SIGINT); <br>\nsigaddset(&amp;mask, SIGQUIT);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Block\nsignals so that they aren't handled <br>\naccording to their default dispositions */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(sigprocmask(SIG_BLOCK, &amp;mask, NULL) == -1) <br>\nhandle_error(&quot;sigprocmask&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sfd =\nsignalfd(-1, &amp;mask, 0); <br>\nif (sfd == -1) <br>\nhandle_error(&quot;signalfd&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { <br>\ns = read(sfd, &amp;fdsi, sizeof(fdsi)); <br>\nif (s != sizeof(fdsi)) <br>\nhandle_error(&quot;read&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fdsi.ssi_signo == SIGINT) { <br>\nprintf(&quot;Got SIGINT\\n&quot;); <br>\n} else if (fdsi.ssi_signo == SIGQUIT) { <br>\nprintf(&quot;Got SIGQUIT\\n&quot;); <br>\nexit(EXIT_SUCCESS); <br>\n} else { <br>\nprintf(&quot;Read unexpected signal\\n&quot;); <br>\n} <br>\n} <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/eventfd\">eventfd(2)</a>,\n<a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>, <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>,\n<a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>, <a href=\"https://man.page/2/timerfd_create\">timerfd_create(2)</a>,\n<a href=\"https://man.page/3/sigsetops\">sigsetops(3)</a>, <a href=\"https://man.page/3/sigwait\">sigwait(3)</a>, <a href=\"https://man.page/7/epoll\">epoll(7)</a>,\n<a href=\"https://man.page/7/signal\">signal(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}