{"name":"getitimer","description":"getitimer, setitimer - get or set value of an interval timer","body":"\n\n<h1 align=\"center\">GETITIMER</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">getitimer,\nsetitimer - get or set value of an interval timer</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/time.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ngetitimer(int</b> <i>which</i><b>, struct itimerval\n*</b><i>curr_value</i><b>); <br>\nint setitimer(int</b> <i>which</i><b>, const struct\nitimerval *</b><i>new_value</i><b>, <br>\nstruct itimerval *</b><i>old_value</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These system\ncalls provide access to interval timers, that is, timers\nthat initially expire at some point in the future, and\n(optionally) at regular intervals after that. When a timer\nexpires, a signal is generated for the calling process, and\nthe timer is reset to the specified interval (if the\ninterval is nonzero).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Three types of\ntimers&mdash;specified via the <i>which</i>\nargument&mdash;are provided, each of which counts against a\ndifferent clock and generates a different signal on timer\nexpiration: <b><br>\nITIMER_REAL</b></p>\n\n<p style=\"margin-left:22%;\">This timer counts down in real\n(i.e., wall clock) time. At each expiration, a\n<b>SIGALRM</b> signal is generated.</p>\n\n<p style=\"margin-left:11%;\"><b>ITIMER_VIRTUAL</b></p>\n\n<p style=\"margin-left:22%;\">This timer counts down against\nthe user-mode CPU time consumed by the process. (The\nmeasurement includes CPU time consumed by all threads in the\nprocess.) At each expiration, a <b>SIGVTALRM</b> signal is\ngenerated.</p>\n\n<p style=\"margin-left:11%;\"><b>ITIMER_PROF</b></p>\n\n<p style=\"margin-left:22%;\">This timer counts down against\nthe total (i.e., both user and system) CPU time consumed by\nthe process. (The measurement includes CPU time consumed by\nall threads in the process.) At each expiration, a\n<b>SIGPROF</b> signal is generated.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In conjunction\nwith <b>ITIMER_VIRTUAL</b>, this timer can be used to\nprofile user and system CPU time consumed by the\nprocess.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process has\nonly one of each of the three types of timers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Timer values\nare defined by the following structures:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nitimerval { <br>\nstruct timeval it_interval; /* Interval for periodic timer\n*/ <br>\nstruct timeval it_value; /* Time until next expiration */\n<br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct timeval\n{ <br>\ntime_t tv_sec; /* seconds */ <br>\nsuseconds_t tv_usec; /* microseconds */ <br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>getitimer()</b>\n<br>\nThe function <b>getitimer</b>() places the current value of\nthe timer specified by <i>which</i> in the buffer pointed to\nby <i>curr_value</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>it_value</i> substructure is populated with the amount of\ntime remaining until the next expiration of the specified\ntimer. This value changes as the timer counts down, and will\nbe reset to <i>it_interval</i> when the timer expires. If\nboth fields of <i>it_value</i> are zero, then this timer is\ncurrently disarmed (inactive).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>it_interval</i> substructure is populated with the timer\ninterval. If both fields of <i>it_interval</i> are zero,\nthen this is a single-shot timer (i.e., it expires just\nonce).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>setitimer()</b>\n<br>\nThe function <b>setitimer</b>() arms or disarms the timer\nspecified by <i>which</i>, by setting the timer to the value\nspecified by <i>new_value</i>. If <i>old_value</i> is\nnon-NULL, the buffer it points to is used to return the\nprevious value of the timer (i.e., the same information that\nis returned by <b>getitimer</b>()).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If either field\nin <i>new_value.it_value</i> is nonzero, then the timer is\narmed to initially expire at the specified time. If both\nfields in <i>new_value.it_value</i> are zero, then the timer\nis disarmed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>new_value.it_interval</i> field specifies the new\ninterval for the timer; if both of its subfields are zero,\nthe timer is single-shot.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\nzero is returned. On error, -1 is returned, and <i>errno</i>\nis set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><i>new_value</i>,\n<i>old_value</i>, or <i>curr_value</i> is not valid a\npointer.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>which</i> is not one of <b>ITIMER_REAL</b>,\n<b>ITIMER_VIRTUAL</b>, or <b>ITIMER_PROF</b>; or (since\nLinux 2.6.22) one of the <i>tv_usec</i> fields in the\nstructure pointed to by <i>new_value</i> contains a value\noutside the range 0 to 999999.</p></td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nSVr4, 4.4BSD (this call first appeared in 4.2BSD).\nPOSIX.1-2008 marks <b>getitimer</b>() and <b>setitimer</b>()\nobsolete, recommending the use of the POSIX timers API\n(<a href=\"https://man.page/2/timer_gettime\">timer_gettime(2)</a>, <a href=\"https://man.page/2/timer_settime\">timer_settime(2)</a>, etc.)\ninstead.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Timers will\nnever expire before the requested time, but may expire some\n(short) time afterward, which depends on the system timer\nresolution and on the system load; see <a href=\"https://man.page/7/time\">time(7)</a>. (But\nsee BUGS below.) If the timer expires while the process is\nactive (always true for <b>ITIMER_VIRTUAL</b>), the signal\nwill be delivered immediately when generated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child created\nvia <a href=\"https://man.page/2/fork\">fork(2)</a> does not inherit its parent&rsquo;s\ninterval timers. Interval timers are preserved across an\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1 leaves\nthe interaction between <b>setitimer</b>() and the three\ninterfaces <a href=\"https://man.page/2/alarm\">alarm(2)</a>, <a href=\"https://man.page/3/sleep\">sleep(3)</a>, and\n<a href=\"https://man.page/3/usleep\">usleep(3)</a> unspecified.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The standards\nare silent on the meaning of the call:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">setitimer(which,\nNULL, &amp;old_value);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many systems\n(Solaris, the BSDs, and perhaps others) treat this as\nequivalent to:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">getitimer(which,\n&amp;old_value);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux, this\nis treated as being equivalent to a call in which the\n<i>new_value</i> fields are zero; that is, the timer is\ndisabled. <i>Don&rsquo;t use this Linux misfeature</i>: it\nis nonportable and unnecessary.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The generation\nand delivery of a signal are distinct, and only one instance\nof each of the signals listed above may be pending for a\nprocess. Under very heavy loading, an <b>ITIMER_REAL</b>\ntimer may expire before the signal from a previous\nexpiration has been delivered. The second signal in such an\nevent will be lost.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux\nkernels before 2.6.16, timer values are represented in\njiffies. If a request is made set a timer with a value whose\njiffies representation exceeds <b>MAX_SEC_IN_JIFFIES</b>\n(defined in <i>include/linux/jiffies.h</i>), then the timer\nis silently truncated to this ceiling value. On Linux/i386\n(where, since Linux 2.6.13, the default jiffy is 0.004\nseconds), this means that the ceiling value for a timer is\napproximately 99.42 days. Since Linux 2.6.16, the kernel\nuses a different internal representation for times, and this\nceiling is removed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On certain\nsystems (including i386), Linux kernels before version\n2.6.12 have a bug which will produce premature timer\nexpirations of up to one jiffy under some circumstances.\nThis bug is fixed in kernel 2.6.12.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001\nsays that <b>setitimer</b>() should fail if a <i>tv_usec</i>\nvalue is specified that is outside of the range 0 to 999999.\nHowever, in kernels up to and including 2.6.21, Linux does\nnot give an error, but instead silently adjusts the\ncorresponding seconds value for the timer. From kernel\n2.6.22 onward, this nonconformance has been repaired: an\nimproper <i>tv_usec</i> value results in an <b>EINVAL</b>\nerror.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/gettimeofday\">gettimeofday(2)</a>,\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>, <a href=\"https://man.page/2/signal\">signal(2)</a>,\n<a href=\"https://man.page/2/timer_create\">timer_create(2)</a>, <a href=\"https://man.page/2/timerfd_create\">timerfd_create(2)</a>,\n<a href=\"https://man.page/7/time\">time(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}