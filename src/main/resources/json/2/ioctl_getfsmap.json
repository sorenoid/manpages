{"name":"ioctl_getfsmap","body":"\n\n<h1 align=\"center\">IOCTL_GETFSMAP</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioctl_getfsmap\n- retrieve the physical layout of the filesystem</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/ioctl.h&gt; <br>\n#include &lt;linux/fs.h&gt; <br>\n#include &lt;linux/fsmap.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nioctl(int</b> <i>fd</i><b>, FS_IOC_GETFSMAP, struct\nfsmap_head *</b> <i>arg</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operation retrieves physical extent mappings\nfor a filesystem. This information can be used to discover\nwhich files are mapped to a physical block, examine free\nspace, or find known bad blocks, among other things.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sole\nargument to this operation should be a pointer to a single\n<i>struct fsmap_head</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct fsmap {\n<br>\n__u32 fmr_device; /* Device ID */ <br>\n__u32 fmr_flags; /* Mapping flags */ <br>\n__u64 fmr_physical; /* Device offset of segment */ <br>\n__u64 fmr_owner; /* Owner ID */ <br>\n__u64 fmr_offset; /* File offset of segment */ <br>\n__u64 fmr_length; /* Length of segment */ <br>\n__u64 fmr_reserved[3]; /* Must be zero */ <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfsmap_head { <br>\n__u32 fmh_iflags; /* Control flags */ <br>\n__u32 fmh_oflags; /* Output flags */ <br>\n__u32 fmh_count; /* # of entries in array incl. input */\n<br>\n__u32 fmh_entries; /* # of entries filled in (output) */\n<br>\n__u64 fmh_reserved[6]; /* Must be zero */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct fsmap\nfmh_keys[2]; /* Low and high keys for <br>\nthe mapping search */ <br>\nstruct fsmap fmh_recs[]; /* Returned records */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The two\n<i>fmh_keys</i> array elements specify the lowest and\nhighest reverse-mapping key for which the application would\nlike physical mapping information. A reverse mapping key\nconsists of the tuple (device, block, owner, offset). The\nowner and offset fields are part of the key because some\nfilesystems support sharing physical blocks between multiple\nfiles and therefore may return multiple mappings for a given\nphysical block.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Filesystem\nmappings are copied into the <i>fmh_recs</i> array, which\nimmediately follows the header data.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Fields of\nstruct fsmap_head</b> <br>\nThe <i>fmh_iflags</i> field is a bit mask passed to the\nkernel to alter the output. No flags are currently defined,\nso the caller must set this value to zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmh_oflags</i> field is a bit mask of flags set by the\nkernel concerning the returned mappings. If\n<b>FMH_OF_DEV_T</b> is set, then the <i>fmr_device</i> field\nrepresents a <i>dev_t</i> structure containing the major and\nminor numbers of the block device.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmh_count</i> field contains the number of elements in\nthe array being passed to the kernel. If this value is 0,\n<i>fmh_entries</i> will be set to the number of records that\nwould have been returned had the array been large enough; no\nmapping information will be returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmh_entries</i> field contains the number of elements in\nthe <i>fmh_recs</i> array that contain useful\ninformation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmh_reserved</i> fields must be set to zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Keys</b>\n<br>\nThe two key records in <i>fsmap_head.fmh_keys</i> specify\nthe lowest and highest extent records in the keyspace that\nthe caller wants returned. A filesystem that can share\nblocks between files likely requires the tuple\n(<i>device</i>, <i>physical</i>, <i>owner</i>,\n<i>offset</i>, <i>flags</i>) to uniquely index any\nfilesystem mapping record. Classic non-sharing filesystems\nmight be able to identify any record with only\n(<i>device</i>, <i>physical</i>, <i>flags</i>). For example,\nif the low key is set to (8:0, 36864, 0, 0, 0), the\nfilesystem will only return records for extents starting at\nor above 36&nbsp;KiB on disk. If the high key is set to\n(8:0, 1048576, 0, 0, 0), only records below 1&nbsp;MiB will\nbe returned. The format of <i>fmr_device</i> in the keys\nmust match the format of the same field in the output\nrecords, as defined below. By convention, the field\n<i>fsmap_head.fmh_keys[0]</i> must contain the low key and\n<i>fsmap_head.fmh_keys[1]</i> must contain the high key for\nthe request.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\nconvenience, if <i>fmr_length</i> is set in the low key, it\nwill be added to <i>fmr_block</i> or <i>fmr_offset</i> as\nappropriate. The caller can take advantage of this subtlety\nto set up subsequent calls by copying\n<i>fsmap_head.fmh_recs[fsmap_head.fmh_entries - 1]</i> into\nthe low key. The function <i>fsmap_advance</i> (defined in\n<i>linux/fsmap.h</i>) provides this functionality.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Fields of\nstruct fsmap</b> <br>\nThe <i>fmr_device</i> field uniquely identifies the\nunderlying storage device. If the <b>FMH_OF_DEV_T</b> flag\nis set in the header&rsquo;s <i>fmh_oflags</i> field, this\nfield contains a <i>dev_t</i> from which major and minor\nnumbers can be extracted. If the flag is not set, this field\ncontains a value that must be unique for each unique storage\ndevice.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmr_physical</i> field contains the disk address of the\nextent in bytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmr_owner</i> field contains the owner of the extent.\nThis is an inode number unless <b>FMR_OF_SPECIAL_OWNER</b>\nis set in the <i>fmr_flags</i> field, in which case the\nvalue is determined by the filesystem. See the section below\nabout owner values for more details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmr_offset</i> field contains the logical address in the\nmapping record in bytes. This field has no meaning if the\n<b>FMR_OF_SPECIAL_OWNER</b> or <b>FMR_OF_EXTENT_MAP</b>\nflags are set in <i>fmr_flags</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmr_length</i> field contains the length of the extent in\nbytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmr_flags</i> field is a bit mask of extent state flags.\nThe bits are:</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OF_PREALLOC</b></p>\n\n<p style=\"margin-left:28%;\">The extent is allocated but not\nyet written.</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OF_ATTR_FORK</b></p>\n\n<p style=\"margin-left:28%;\">This extent contains extended\nattribute data.</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OF_EXTENT_MAP</b></p>\n\n<p style=\"margin-left:28%;\">This extent contains extent map\ninformation for the owner.</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OF_SHARED</b></p>\n\n<p style=\"margin-left:28%;\">Parts of this extent may be\nshared.</p>\n\n\n<p style=\"margin-left:17%;\"><b>FMR_OF_SPECIAL_OWNER</b></p>\n\n<p style=\"margin-left:28%;\">The <i>fmr_owner</i> field\ncontains a special value instead of an inode number.</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OF_LAST</b></p>\n\n<p style=\"margin-left:28%;\">This is the last record in the\ndata set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>fmr_reserved</i> field will be set to zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Owner\nvalues</b> <br>\nGenerally, the value of the <i>fmr_owner</i> field for\nnon-metadata extents should be an inode number. However,\nfilesystems are under no obligation to report inode numbers;\nthey may instead report <b>FMR_OWN_UNKNOWN</b> if the inode\nnumber cannot easily be retrieved, if the caller lacks\nsufficient privilege, if the filesystem does not support\nstable inode numbers, or for any other reason. If a\nfilesystem wishes to condition the reporting of inode\nnumbers based on process capabilities, it is strongly urged\nthat the <b>CAP_SYS_ADMIN</b> capability be used for this\npurpose. <br>\nThe following special owner values are generic to all\nfilesystems:</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OWN_FREE</b></p>\n\n<p style=\"margin-left:28%;\">Free space.</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OWN_UNKNOWN</b></p>\n\n<p style=\"margin-left:28%;\">This extent is in use but its\nowner is not known or not easily retrieved.</p>\n\n<p style=\"margin-left:17%;\"><b>FMR_OWN_METADATA</b></p>\n\n<p style=\"margin-left:28%;\">This extent is filesystem\nmetadata.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">XFS can return\nthe following special owner values:</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_FREE</b></p>\n\n<p style=\"margin-left:28%;\">Free space.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_UNKNOWN</b></p>\n\n<p style=\"margin-left:28%;\">This extent is in use but its\nowner is not known or not easily retrieved.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_FS</b></p>\n\n<p style=\"margin-left:28%;\">Static filesystem metadata\nwhich exists at a fixed address. These are the AG\nsuperblock, the AGF, the AGFL, and the AGI headers.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_LOG</b></p>\n\n<p style=\"margin-left:28%;\">The filesystem journal.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_AG</b></p>\n\n<p style=\"margin-left:28%;\">Allocation group metadata, such\nas the free space btrees and the reverse mapping btrees.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_INOBT</b></p>\n\n<p style=\"margin-left:28%;\">The inode and free inode\nbtrees.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_INODES</b></p>\n\n<p style=\"margin-left:28%;\">Inode records.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_REFC</b></p>\n\n<p style=\"margin-left:28%;\">Reference count\ninformation.</p>\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_COW</b></p>\n\n<p style=\"margin-left:28%;\">This extent is being used to\nstage a copy-on-write.</p>\n\n\n<p style=\"margin-left:17%;\"><b>XFS_FMR_OWN_DEFECTIVE:</b></p>\n\n<p style=\"margin-left:28%;\">This extent has been marked\ndefective either by the filesystem or the underlying\ndevice.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ext4 can return\nthe following special owner values:</p>\n\n<p style=\"margin-left:17%;\"><b>EXT4_FMR_OWN_FREE</b></p>\n\n<p style=\"margin-left:28%;\">Free space.</p>\n\n\n<p style=\"margin-left:17%;\"><b>EXT4_FMR_OWN_UNKNOWN</b></p>\n\n<p style=\"margin-left:28%;\">This extent is in use but its\nowner is not known or not easily retrieved.</p>\n\n<p style=\"margin-left:17%;\"><b>EXT4_FMR_OWN_FS</b></p>\n\n<p style=\"margin-left:28%;\">Static filesystem metadata\nwhich exists at a fixed address. This is the superblock and\nthe group descriptors.</p>\n\n<p style=\"margin-left:17%;\"><b>EXT4_FMR_OWN_LOG</b></p>\n\n<p style=\"margin-left:28%;\">The filesystem journal.</p>\n\n<p style=\"margin-left:17%;\"><b>EXT4_FMR_OWN_INODES</b></p>\n\n<p style=\"margin-left:28%;\">Inode records.</p>\n\n<p style=\"margin-left:17%;\"><b>EXT4_FMR_OWN_BLKBM</b></p>\n\n<p style=\"margin-left:28%;\">Block bit map.</p>\n\n<p style=\"margin-left:17%;\"><b>EXT4_FMR_OWN_INOBM</b></p>\n\n<p style=\"margin-left:28%;\">Inode bit map.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set to indicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The error\nplaced in <i>errno</i> can be one of, but is not limited to,\nthe following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"41%\">\n\n\n<p><i>fd</i> is not open for reading.</p></td>\n<td width=\"37%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EBADMSG</b></p>\n\n<p style=\"margin-left:22%;\">The filesystem has detected a\nchecksum error in the metadata.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The pointer passed in was not mapped to a valid memory\naddress.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The array is not long enough, the keys do not point to a\nvalid part of the filesystem, the low key points to a higher\npoint in the filesystem&rsquo;s physical storage address\nspace than the high key, or a nonzero value was passed in\none of the fields that must be zero.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Insufficient memory to process the request.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EOPNOTSUPP</b></p>\n\n<p style=\"margin-left:22%;\">The filesystem does not support\nthis command.</p>\n\n<p style=\"margin-left:11%;\"><b>EUCLEAN</b></p>\n\n<p style=\"margin-left:22%;\">The filesystem metadata is\ncorrupt and needs repair.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>FS_IOC_GETFSMAP</b> operation first appeared in Linux\n4.12.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This API is\nLinux-specific. Not all filesystems support it.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<i>io/fsmap.c</i> in the <i>xfsprogs</i> distribution for a\nsample program.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/ioctl\">ioctl(2)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}