{"name":"ioctl_ns","body":"\n\n<h1 align=\"center\">IOCTL_NS</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioctl_ns -\nioctl() operations for Linux namespaces</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Discovering\nnamespace relationships</b> <br>\nThe following <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operations are provided to\nallow discovery of namespace relationships (see\n<a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a> and <a href=\"https://man.page/7/pid_namespaces\">pid_namespaces(7)</a>). The\nform of the calls is:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">new_fd =\nioctl(fd, request);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In each case,\n<i>fd</i> refers to a <i>/proc/[pid]/ns/*</i> file. Both\noperations return a new file descriptor on success. <b><br>\nNS_GET_USERNS</b> (since Linux 4.9)</p>\n\n<p style=\"margin-left:22%;\">Returns a file descriptor that\nrefers to the owning user namespace for the namespace\nreferred to by <i>fd</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>NS_GET_PARENT</b> (since\nLinux 4.9)</p>\n\n<p style=\"margin-left:22%;\">Returns a file descriptor that\nrefers to the parent namespace of the namespace referred to\nby <i>fd</i>. This operation is valid only for hierarchical\nnamespaces (i.e., PID and user namespaces). For user\nnamespaces, <b>NS_GET_PARENT</b> is synonymous with\n<b>NS_GET_USERNS</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The new file\ndescriptor returned by these operations is opened with the\n<b>O_RDONLY</b> and <b>O_CLOEXEC</b> (close-on-exec; see\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>) flags.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By applying\n<a href=\"https://man.page/2/fstat\">fstat(2)</a> to the returned file descriptor, one obtains\na <i>stat</i> structure whose <i>st_dev</i> (resident\ndevice) and <i>st_ino</i> (inode number) fields together\nidentify the owning/parent namespace. This inode number can\nbe matched with the inode number of another\n<i>/proc/[pid]/ns/{pid,user}</i> file to determine whether\nthat is the owning/parent namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Either of these\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operations can fail with the following\nerrors:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The requested namespace is outside of the caller&rsquo;s\nnamespace scope. This error can occur if, for example, the\nowning user namespace is an ancestor of the caller&rsquo;s\ncurrent user namespace. It can also occur on attempts to\nobtain the parent of the initial user or PID namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOTTY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The operation is not supported by this kernel\nversion.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additionally,\nthe <b>NS_GET_PARENT</b> operation can fail with the\nfollowing error:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p style=\"margin-top: 1em\"><i>fd</i> refers to a\nnonhierarchical namespace.</p></td>\n<td width=\"15%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\nEXAMPLES section for an example of the use of these\noperations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Discovering\nthe namespace type</b> <br>\nThe <b>NS_GET_NSTYPE</b> operation (available since Linux\n4.11) can be used to discover the type of namespace referred\nto by the file descriptor <i>fd</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">nstype =\nioctl(fd, NS_GET_NSTYPE);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>fd</i>\nrefers to a <i>/proc/[pid]/ns/*</i> file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The return\nvalue is one of the <b>CLONE_NEW*</b> values that can be\nspecified to <a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a> in order\nto create a namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Discovering\nthe owner of a user namespace</b> <br>\nThe <b>NS_GET_OWNER_UID</b> operation (available since Linux\n4.11) can be used to discover the owner user ID of a user\nnamespace (i.e., the effective user ID of the process that\ncreated the user namespace). The form of the call is:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">uid_t uid; <br>\nioctl(fd, NS_GET_OWNER_UID, &amp;uid);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>fd</i>\nrefers to a <i>/proc/[pid]/ns/user</i> file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The owner user\nID is returned in the <i>uid_t</i> pointed to by the third\nargument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This operation\ncan fail with the following error:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"58%\">\n\n\n<p style=\"margin-top: 1em\"><i>fd</i> does not refer to a\nuser namespace.</p></td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Any of the\nabove <b>ioctl</b>() operations can return the following\nerrors:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>ENOTTY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p style=\"margin-top: 1em\"><i>fd</i> does not refer to a\n<i>/proc/[pid]/ns/*</i> file.</p></td>\n<td width=\"9%\">\n</td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Namespaces and\nthe operations described on this page are a\nLinux-specific.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The example\nshown below uses the <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operations described\nabove to perform simple discovery of namespace\nrelationships. The following shell sessions show various\nexamples of the use of this program.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Trying to get\nthe parent of the initial user namespace fails, since it has\nno parent:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./ns_show\n/proc/self/ns/user p</b> <br>\nThe parent namespace is outside your namespace scope</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Create a\nprocess running <a href=\"https://man.page/1/sleep\">sleep(1)</a> that resides in new user and\nUTS namespaces, and show that the new UTS namespace is\nassociated with the new user namespace:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>unshare\n-Uu sleep 1000 &amp;</b> <br>\n[1] 23235 <br>\n$ <b>./ns_show /proc/23235/ns/uts u</b> <br>\nDevice/Inode of owning user namespace is: [0,3] / 4026532448\n<br>\n$ <b>readlink /proc/23235/ns/user</b> <br>\nuser:[4026532448]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then show that\nthe parent of the new user namespace in the preceding\nexample is the initial user namespace:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>readlink\n/proc/self/ns/user</b> <br>\nuser:[4026531837] <br>\n$ <b>./ns_show /proc/23235/ns/user p</b> <br>\nDevice/Inode of parent namespace is: [0,3] / 4026531837</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Start a shell\nin a new user namespace, and show that from within this\nshell, the parent user namespace can&rsquo;t be discovered.\nSimilarly, the UTS namespace (which is associated with the\ninitial user namespace) can&rsquo;t be discovered.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>PS1=&quot;sh2$ &quot; unshare -U bash</b> <br>\nsh2$ <b>./ns_show /proc/self/ns/user p</b> <br>\nThe parent namespace is outside your namespace scope <br>\nsh2$ <b>./ns_show /proc/self/ns/uts u</b> <br>\nThe owning user namespace is outside your namespace\nscope</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n/* ns_show.c</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nthe GNU General Public License v2 or later. <br>\n*/ <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;sys/stat.h&gt; <br>\n#include &lt;sys/ioctl.h&gt; <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;sys/sysmacros.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#ifndef\nNS_GET_USERNS <br>\n#define NSIO 0xb7 <br>\n#define NS_GET_USERNS _IO(NSIO, 0x1) <br>\n#define NS_GET_PARENT _IO(NSIO, 0x2) <br>\n#endif</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint fd, userns_fd, parent_fd; <br>\nstruct stat sb;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s /proc/[pid]/ns/[file]\n[p|u]\\n&quot;, <br>\nargv[0]); <br>\nfprintf(stderr, &quot;\\nDisplay the result of one or both\n&quot; <br>\n&quot;of NS_GET_USERNS (u) or NS_GET_PARENT (p)\\n&quot; <br>\n&quot;for the specified /proc/[pid]/ns/[file]. If neither\n&quot; <br>\n&quot;'p' nor 'u' is specified,\\n&quot; <br>\n&quot;NS_GET_USERNS is the default.\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Obtain a\nfile descriptor for the 'ns' file specified <br>\nin argv[1] */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(argv[1], O_RDONLY); <br>\nif (fd == -1) { <br>\nperror(&quot;open&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Obtain a\nfile descriptor for the owning user namespace and <br>\nthen obtain and display the inode number of that namespace\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt; 3\n|| strchr(argv[2], 'u')) { <br>\nuserns_fd = ioctl(fd, NS_GET_USERNS);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (userns_fd\n== -1) { <br>\nif (errno == EPERM) <br>\nprintf(&quot;The owning user namespace is outside &quot;\n<br>\n&quot;your namespace scope\\n&quot;); <br>\nelse <br>\nperror(&quot;ioctl-NS_GET_USERNS&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fstat(userns_fd, &amp;sb) == -1) { <br>\nperror(&quot;fstat-userns&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nprintf(&quot;Device/Inode of owning user namespace is:\n&quot; <br>\n&quot;[%jx,%jx] / %ju\\n&quot;, <br>\n(uintmax_t) major(sb.st_dev), <br>\n(uintmax_t) minor(sb.st_dev), <br>\n(uintmax_t) sb.st_ino);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(userns_fd);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Obtain a\nfile descriptor for the parent namespace and <br>\nthen obtain and display the inode number of that namespace\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &gt; 2\n&amp;&amp; strchr(argv[2], 'p')) { <br>\nparent_fd = ioctl(fd, NS_GET_PARENT);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (parent_fd\n== -1) { <br>\nif (errno == EINVAL) <br>\nprintf(&quot;Can' get parent namespace of a &quot; <br>\n&quot;nonhierarchical namespace\\n&quot;); <br>\nelse if (errno == EPERM) <br>\nprintf(&quot;The parent namespace is outside &quot; <br>\n&quot;your namespace scope\\n&quot;); <br>\nelse <br>\nperror(&quot;ioctl-NS_GET_PARENT&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fstat(parent_fd, &amp;sb) == -1) { <br>\nperror(&quot;fstat-parentns&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nprintf(&quot;Device/Inode of parent namespace is: [%jx,%jx]\n/ %ju\\n&quot;, <br>\n(uintmax_t) major(sb.st_dev), <br>\n(uintmax_t) minor(sb.st_dev), <br>\n(uintmax_t) sb.st_ino);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(parent_fd);\n<br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/fstat\">fstat(2)</a>,\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a>, <a href=\"https://man.page/5/proc\">proc(5)</a>, <a href=\"https://man.page/7/namespaces\">namespaces(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}