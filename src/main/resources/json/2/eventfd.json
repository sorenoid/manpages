{"name":"eventfd","body":"\n\n<h1 align=\"center\">EVENTFD</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">eventfd -\ncreate a file descriptor for event notification</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/eventfd.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\neventfd(unsigned int</b> <i>initval</i><b>, int</b>\n<i>flags</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>eventfd</b>()\ncreates an &quot;eventfd object&quot; that can be used as an\nevent wait/notify mechanism by user-space applications, and\nby the kernel to notify user-space applications of events.\nThe object contains an unsigned 64-bit integer\n(<i>uint64_t</i>) counter that is maintained by the kernel.\nThis counter is initialized with the value specified in the\nargument <i>initval</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As its return\nvalue, <b>eventfd</b>() returns a new file descriptor that\ncan be used to refer to the eventfd object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nvalues may be bitwise ORed in <i>flags</i> to change the\nbehavior of <b>eventfd</b>(): <b><br>\nEFD_CLOEXEC</b> (since Linux 2.6.27)</p>\n\n<p style=\"margin-left:22%;\">Set the close-on-exec\n(<b>FD_CLOEXEC</b>) flag on the new file descriptor. See the\ndescription of the <b>O_CLOEXEC</b> flag in <a href=\"https://man.page/2/open\">open(2)</a>\nfor reasons why this may be useful.</p>\n\n<p style=\"margin-left:11%;\"><b>EFD_NONBLOCK</b> (since\nLinux 2.6.27)</p>\n\n<p style=\"margin-left:22%;\">Set the <b>O_NONBLOCK</b> file\nstatus flag on the open file description (see\n<a href=\"https://man.page/2/open\">open(2)</a>) referred to by the new file descriptor.\nUsing this flag saves extra calls to <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> to\nachieve the same result.</p>\n\n<p style=\"margin-left:11%;\"><b>EFD_SEMAPHORE</b> (since\nLinux 2.6.30)</p>\n\n<p style=\"margin-left:22%;\">Provide semaphore-like\nsemantics for reads from the new file descriptor. See\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux up to\nversion 2.6.26, the <i>flags</i> argument is unused, and\nmust be specified as zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\noperations can be performed on the file descriptor returned\nby <b>eventfd</b>(): <b><br>\nread</b>(2)</p>\n\n<p style=\"margin-left:22%;\">Each successful <a href=\"https://man.page/2/read\">read(2)</a>\nreturns an 8-byte integer. A <a href=\"https://man.page/2/read\">read(2)</a> fails with the\nerror <b>EINVAL</b> if the size of the supplied buffer is\nless than 8 bytes.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The value\nreturned by <a href=\"https://man.page/2/read\">read(2)</a> is in host byte order&mdash;that\nis, the native byte order for integers on the host\nmachine.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The semantics\nof <a href=\"https://man.page/2/read\">read(2)</a> depend on whether the eventfd counter\ncurrently has a nonzero value and whether the\n<b>EFD_SEMAPHORE</b> flag was specified when creating the\neventfd file descriptor:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>If <b>EFD_SEMAPHORE</b> was not specified and the\neventfd counter has a nonzero value, then a <a href=\"https://man.page/2/read\">read(2)</a>\nreturns 8 bytes containing that value, and the\ncounter&rsquo;s value is reset to zero.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>If <b>EFD_SEMAPHORE</b> was specified and the eventfd\ncounter has a nonzero value, then a <a href=\"https://man.page/2/read\">read(2)</a> returns 8\nbytes containing the value 1, and the counter&rsquo;s value\nis decremented by 1.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>If the eventfd counter is zero at the time of the call\nto <a href=\"https://man.page/2/read\">read(2)</a>, then the call either blocks until the\ncounter becomes nonzero (at which time, the <a href=\"https://man.page/2/read\">read(2)</a>\nproceeds as described above) or fails with the error\n<b>EAGAIN</b> if the file descriptor has been made\nnonblocking.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:22%;\">A <a href=\"https://man.page/2/write\">write(2)</a> call adds the\n8-byte integer value supplied in its buffer to the counter.\nThe maximum value that may be stored in the counter is the\nlargest unsigned 64-bit value minus 1 (i.e.,\n0xfffffffffffffffe). If the addition would cause the\ncounter&rsquo;s value to exceed the maximum, then the\n<a href=\"https://man.page/2/write\">write(2)</a> either blocks until a <a href=\"https://man.page/2/read\">read(2)</a> is\nperformed on the file descriptor, or fails with the error\n<b>EAGAIN</b> if the file descriptor has been made\nnonblocking.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A\n<a href=\"https://man.page/2/write\">write(2)</a> fails with the error <b>EINVAL</b> if the\nsize of the supplied buffer is less than 8 bytes, or if an\nattempt is made to write the value 0xffffffffffffffff.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/poll\">poll(2)</a>,\n<a href=\"https://man.page/2/select\">select(2)</a> (and similar)</p>\n\n<p style=\"margin-left:22%;\">The returned file descriptor\nsupports <a href=\"https://man.page/2/poll\">poll(2)</a> (and analogously <a href=\"https://man.page/7/epoll\">epoll(7)</a>)\nand <a href=\"https://man.page/2/select\">select(2)</a>, as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The file descriptor is readable (the <a href=\"https://man.page/2/select\">select(2)</a>\n<i>readfds</i> argument; the <a href=\"https://man.page/2/poll\">poll(2)</a> <b>POLLIN</b>\nflag) if the counter has a value greater than 0.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The file descriptor is writable (the <a href=\"https://man.page/2/select\">select(2)</a>\n<i>writefds</i> argument; the <a href=\"https://man.page/2/poll\">poll(2)</a> <b>POLLOUT</b>\nflag) if it is possible to write a value of at least\n&quot;1&quot; without blocking.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>If an overflow of the counter value was detected, then\n<a href=\"https://man.page/2/select\">select(2)</a> indicates the file descriptor as being both\nreadable and writable, and <a href=\"https://man.page/2/poll\">poll(2)</a> returns a\n<b>POLLERR</b> event. As noted above, <a href=\"https://man.page/2/write\">write(2)</a> can\nnever overflow the counter. However an overflow can occur if\n2^64 eventfd &quot;signal posts&quot; were performed by the\nKAIO subsystem (theoretically possible, but practically\nunlikely). If an overflow has occurred, then <a href=\"https://man.page/2/read\">read(2)</a>\nwill return that maximum <i>uint64_t</i> value (i.e.,\n0xffffffffffffffff).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The eventfd\nfile descriptor also supports the other file-descriptor\nmultiplexing APIs: <a href=\"https://man.page/2/pselect\">pselect(2)</a> and\n<a href=\"https://man.page/2/ppoll\">ppoll(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/close\">close(2)</a></p>\n\n<p style=\"margin-left:22%;\">When the file descriptor is no\nlonger required it should be closed. When all file\ndescriptors associated with the same eventfd object have\nbeen closed, the resources for object are freed by the\nkernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A copy of the\nfile descriptor created by <b>eventfd</b>() is inherited by\nthe child produced by <a href=\"https://man.page/2/fork\">fork(2)</a>. The duplicate file\ndescriptor is associated with the same eventfd object. File\ndescriptors created by <b>eventfd</b>() are preserved across\n<a href=\"https://man.page/2/execve\">execve(2)</a>, unless the close-on-exec flag has been\nset.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>eventfd</b>() returns a new eventfd file descriptor. On\nerror, -1 is returned and <i>errno</i> is set to indicate\nthe error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">An unsupported value was\nspecified in <i>flags</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The per-process limit on the number of open file\ndescriptors has been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The system-wide limit on the total number of open files\nhas been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENODEV</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Could not mount (internal) anonymous inode device.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>There was insufficient memory to create a new eventfd\nfile descriptor.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>eventfd</b>()\nis available on Linux since kernel 2.6.22. Working support\nis provided in glibc since version 2.8. The\n<b>eventfd2</b>() system call (see NOTES) is available on\nLinux since kernel 2.6.27. Since version 2.9, the glibc\n<b>eventfd</b>() wrapper will employ the <b>eventfd2</b>()\nsystem call, if it is supported by the kernel.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3272561.png\" alt=\"Image grohtml-3272561.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>eventfd</b>()\nand <b>eventfd2</b>() are Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Applications\ncan use an eventfd file descriptor instead of a pipe (see\n<a href=\"https://man.page/2/pipe\">pipe(2)</a>) in all cases where a pipe is used simply to\nsignal events. The kernel overhead of an eventfd file\ndescriptor is much lower than that of a pipe, and only one\nfile descriptor is required (versus the two required for a\npipe).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When used in\nthe kernel, an eventfd file descriptor can provide a bridge\nfrom kernel to user space, allowing, for example,\nfunctionalities like KAIO (kernel AIO) to signal to a file\ndescriptor that some operation is complete.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A key point\nabout an eventfd file descriptor is that it can be monitored\njust like any other file descriptor using <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/poll\">poll(2)</a>, or <a href=\"https://man.page/7/epoll\">epoll(7)</a>. This means that an\napplication can simultaneously monitor the readiness of\n&quot;traditional&quot; files and the readiness of other\nkernel mechanisms that support the eventfd interface.\n(Without the <b>eventfd</b>() interface, these mechanisms\ncould not be multiplexed via <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/poll\">poll(2)</a>, or <a href=\"https://man.page/7/epoll\">epoll(7)</a>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The current\nvalue of an eventfd counter can be viewed via the entry for\nthe corresponding file descriptor in the process&rsquo;s\n<i>/proc/[pid]/fdinfo</i> directory. See <a href=\"https://man.page/5/proc\">proc(5)</a> for\nfurther details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nThere are two underlying Linux system calls:\n<b>eventfd</b>() and the more recent <b>eventfd2</b>(). The\nformer system call does not implement a <i>flags</i>\nargument. The latter system call implements the <i>flags</i>\nvalues described above. The glibc wrapper function will use\n<b>eventfd2</b>() where it is available.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Additional\nglibc features</b> <br>\nThe GNU C library defines an additional type, and two\nfunctions that attempt to abstract some of the details of\nreading and writing on an eventfd file descriptor:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">typedef\nuint64_t eventfd_t;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int\neventfd_read(int fd, eventfd_t *value); <br>\nint eventfd_write(int fd, eventfd_t value);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\nperform the read and write operations on an eventfd file\ndescriptor, returning 0 if the correct number of bytes was\ntransferred, or -1 otherwise.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram creates an eventfd file descriptor and then forks to\ncreate a child process. While the parent briefly sleeps, the\nchild writes each of the integers supplied in the\nprogram&rsquo;s command-line arguments to the eventfd file\ndescriptor. When the parent has finished sleeping, it reads\nfrom the eventfd file descriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session shows a sample run of the program:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out 1\n2 4 7 14</b> <br>\nChild writing 1 to efd <br>\nChild writing 2 to efd <br>\nChild writing 4 to efd <br>\nChild writing 7 to efd <br>\nChild writing 14 to efd <br>\nChild completed write loop <br>\nParent about to read <br>\nParent read 28 (0x1c) from efd</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;sys/eventfd.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;inttypes.h&gt; /* Definition of PRIu64 &amp;\nPRIx64 */ <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdint.h&gt; /* Definition of uint64_t */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error(msg) \\ <br>\ndo { perror(msg); exit(EXIT_FAILURE); } while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint efd; <br>\nuint64_t u; <br>\nssize_t s;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s &lt;num&gt;...\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">efd =\neventfd(0, 0); <br>\nif (efd == -1) <br>\nhandle_error(&quot;eventfd&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">switch (fork())\n{ <br>\ncase 0: <br>\nfor (int j = 1; j &lt; argc; j++) { <br>\nprintf(&quot;Child writing %s to efd\\n&quot;, argv[j]); <br>\nu = strtoull(argv[j], NULL, 0); <br>\n/* strtoull() allows various bases */ <br>\ns = write(efd, &amp;u, sizeof(uint64_t)); <br>\nif (s != sizeof(uint64_t)) <br>\nhandle_error(&quot;write&quot;); <br>\n} <br>\nprintf(&quot;Child completed write loop\\n&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">default: <br>\nsleep(2);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Parent\nabout to read\\n&quot;); <br>\ns = read(efd, &amp;u, sizeof(uint64_t)); <br>\nif (s != sizeof(uint64_t)) <br>\nhandle_error(&quot;read&quot;); <br>\nprintf(&quot;Parent read %&quot;PRIu64&quot;\n(%#&quot;PRIx64&quot;) from efd\\n&quot;, u, u); <br>\nexit(EXIT_SUCCESS);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">case -1: <br>\nhandle_error(&quot;fork&quot;); <br>\n} <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/futex\">futex(2)</a>,\n<a href=\"https://man.page/2/pipe\">pipe(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>,\n<a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/signalfd\">signalfd(2)</a>,\n<a href=\"https://man.page/2/timerfd_create\">timerfd_create(2)</a>, <a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/7/epoll\">epoll(7)</a>,\n<a href=\"https://man.page/7/sem_overview\">sem_overview(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}