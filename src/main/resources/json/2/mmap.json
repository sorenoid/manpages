{"name":"mmap","body":"\n\n<h1 align=\"center\">MMAP</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">mmap, munmap -\nmap or unmap files or devices into memory</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/mman.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*mmap(void *</b><i>addr</i><b>, size_t</b> <i>length</i><b>,\nint</b> <i>prot</i><b>, int</b> <i>flags</i><b>, <br>\nint</b> <i>fd</i><b>, off_t</b> <i>offset</i><b>); <br>\nint munmap(void *</b><i>addr</i><b>, size_t</b>\n<i>length</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See NOTES for\ninformation on feature test macro requirements.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mmap</b>()\ncreates a new mapping in the virtual address space of the\ncalling process. The starting address for the new mapping is\nspecified in <i>addr</i>. The <i>length</i> argument\nspecifies the length of the mapping (which must be greater\nthan 0).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>addr</i>\nis NULL, then the kernel chooses the (page-aligned) address\nat which to create the mapping; this is the most portable\nmethod of creating a new mapping. If <i>addr</i> is not\nNULL, then the kernel takes it as a hint about where to\nplace the mapping; on Linux, the kernel will pick a nearby\npage boundary (but always above or equal to the value\nspecified by <i>/proc/sys/vm/mmap_min_addr</i>) and attempt\nto create the mapping there. If another mapping already\nexists there, the kernel picks a new address that may or may\nnot depend on the hint. The address of the new mapping is\nreturned as the result of the call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The contents of\na file mapping (as opposed to an anonymous mapping; see\n<b>MAP_ANONYMOUS</b> below), are initialized using\n<i>length</i> bytes starting at offset <i>offset</i> in the\nfile (or other object) referred to by the file descriptor\n<i>fd</i>. <i>offset</i> must be a multiple of the page size\nas returned by <i>sysconf(_SC_PAGE_SIZE)</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After the\n<b>mmap</b>() call has returned, the file descriptor,\n<i>fd</i>, can be closed immediately without invalidating\nthe mapping.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>prot</i>\nargument describes the desired memory protection of the\nmapping (and must not conflict with the open mode of the\nfile). It is either <b>PROT_NONE</b> or the bitwise OR of\none or more of the following flags:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><b>PROT_EXEC</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p>Pages may be executed.</p></td>\n<td width=\"32%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><b>PROT_READ</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p>Pages may be read.</p></td>\n<td width=\"32%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><b>PROT_WRITE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p>Pages may be written.</p></td>\n<td width=\"32%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p><b>PROT_NONE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p>Pages may not be accessed.</p></td>\n<td width=\"32%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The flags\nargument</b> <br>\nThe <i>flags</i> argument determines whether updates to the\nmapping are visible to other processes mapping the same\nregion, and whether updates are carried through to the\nunderlying file. This behavior is determined by including\nexactly one of the following values in <i>flags</i>: <b><br>\nMAP_SHARED</b></p>\n\n<p style=\"margin-left:22%;\">Share this mapping. Updates to\nthe mapping are visible to other processes mapping the same\nregion, and (in the case of file-backed mappings) are\ncarried through to the underlying file. (To precisely\ncontrol when updates are carried through to the underlying\nfile requires the use of <a href=\"https://man.page/2/msync\">msync(2)</a>.)</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_SHARED_VALIDATE</b>\n(since Linux 4.15)</p>\n\n<p style=\"margin-left:22%;\">This flag provides the same\nbehavior as <b>MAP_SHARED</b> except that <b>MAP_SHARED</b>\nmappings ignore unknown flags in <i>flags</i>. By contrast,\nwhen creating a mapping using <b>MAP_SHARED_VALIDATE</b>,\nthe kernel verifies all passed flags are known and fails the\nmapping with the error <b>EOPNOTSUPP</b> for unknown flags.\nThis mapping type is also required to be able to use some\nmapping flags (e.g., <b>MAP_SYNC</b>).</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_PRIVATE</b></p>\n\n<p style=\"margin-left:22%;\">Create a private copy-on-write\nmapping. Updates to the mapping are not visible to other\nprocesses mapping the same file, and are not carried through\nto the underlying file. It is unspecified whether changes\nmade to the file after the <b>mmap</b>() call are visible in\nthe mapped region.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both\n<b>MAP_SHARED</b> and <b>MAP_PRIVATE</b> are described in\nPOSIX.1-2001 and POSIX.1-2008. <b>MAP_SHARED_VALIDATE</b> is\na Linux extension.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nzero or more of the following values can be ORed in\n<i>flags</i>: <b><br>\nMAP_32BIT</b> (since Linux 2.4.20, 2.6)</p>\n\n<p style=\"margin-left:22%;\">Put the mapping into the first\n2 Gigabytes of the process address space. This flag is\nsupported only on x86-64, for 64-bit programs. It was added\nto allow thread stacks to be allocated somewhere in the\nfirst 2&nbsp;GB of memory, so as to improve context-switch\nperformance on some early 64-bit processors. Modern x86-64\nprocessors no longer have this performance problem, so use\nof this flag is not required on those systems. The\n<b>MAP_32BIT</b> flag is ignored when <b>MAP_FIXED</b> is\nset.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_ANON</b></p>\n\n<p style=\"margin-left:22%;\">Synonym for\n<b>MAP_ANONYMOUS</b>; provided for compatibility with other\nimplementations.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_ANONYMOUS</b></p>\n\n<p style=\"margin-left:22%;\">The mapping is not backed by\nany file; its contents are initialized to zero. The\n<i>fd</i> argument is ignored; however, some implementations\nrequire <i>fd</i> to be -1 if <b>MAP_ANONYMOUS</b> (or\n<b>MAP_ANON</b>) is specified, and portable applications\nshould ensure this. The <i>offset</i> argument should be\nzero. The use of <b>MAP_ANONYMOUS</b> in conjunction with\n<b>MAP_SHARED</b> is supported on Linux only since kernel\n2.4.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_DENYWRITE</b></p>\n\n<p style=\"margin-left:22%;\">This flag is ignored. (Long\nago&mdash;Linux 2.0 and earlier&mdash;it signaled that\nattempts to write to the underlying file should fail with\n<b>ETXTBSY</b>. But this was a source of denial-of-service\nattacks.)</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_EXECUTABLE</b></p>\n\n<p style=\"margin-left:22%;\">This flag is ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_FILE</b></p>\n\n<p style=\"margin-left:22%;\">Compatibility flag.\nIgnored.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_FIXED</b></p>\n\n<p style=\"margin-left:22%;\">Don&rsquo;t interpret\n<i>addr</i> as a hint: place the mapping at exactly that\naddress. <i>addr</i> must be suitably aligned: for most\narchitectures a multiple of the page size is sufficient;\nhowever, some architectures may impose additional\nrestrictions. If the memory region specified by <i>addr</i>\nand <i>len</i> overlaps pages of any existing mapping(s),\nthen the overlapped part of the existing mapping(s) will be\ndiscarded. If the specified address cannot be used,\n<b>mmap</b>() will fail.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Software that\naspires to be portable should use the <b>MAP_FIXED</b> flag\nwith care, keeping in mind that the exact layout of a\nprocess&rsquo;s memory mappings is allowed to change\nsignificantly between kernel versions, C library versions,\nand operating system releases. <i>Carefully read the\ndiscussion of this flag in NOTES!</i></p>\n\n<p style=\"margin-left:11%;\"><b>MAP_FIXED_NOREPLACE</b>\n(since Linux 4.17)</p>\n\n<p style=\"margin-left:22%;\">This flag provides behavior\nthat is similar to <b>MAP_FIXED</b> with respect to the\n<i>addr</i> enforcement, but differs in that\n<b>MAP_FIXED_NOREPLACE</b> never clobbers a preexisting\nmapped range. If the requested range would collide with an\nexisting mapping, then this call fails with the error\n<b>EEXIST.</b> This flag can therefore be used as a way to\natomically (with respect to other threads) attempt to map an\naddress range: one thread will succeed; all others will\nreport failure.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note that older\nkernels which do not recognize the\n<b>MAP_FIXED_NOREPLACE</b> flag will typically (upon\ndetecting a collision with a preexisting mapping) fall back\nto a &quot;non-<b>MAP_FIXED&quot; type of behavior:</b> they\nwill return an address that is different from the requested\naddress. Therefore, backward-compatible software should\ncheck the returned address against the requested\naddress.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_GROWSDOWN</b></p>\n\n<p style=\"margin-left:22%;\">This flag is used for stacks.\nIt indicates to the kernel virtual memory system that the\nmapping should extend downward in memory. The return address\nis one page lower than the memory area that is actually\ncreated in the process&rsquo;s virtual address space.\nTouching an address in the &quot;guard&quot; page below the\nmapping will cause the mapping to grow by a page. This\ngrowth can be repeated until the mapping grows to within a\npage of the high end of the next lower mapping, at which\npoint touching the &quot;guard&quot; page will result in a\n<b>SIGSEGV</b> signal.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_HUGETLB</b> (since Linux\n2.6.32)</p>\n\n<p style=\"margin-left:22%;\">Allocate the mapping using\n&quot;huge pages.&quot; See the Linux kernel source file\n<i>Documentation/admin-guide/mm/hugetlbpage.rst</i> for\nfurther information, as well as NOTES, below.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_HUGE_2MB</b>,\n<b>MAP_HUGE_1GB</b> (since Linux 3.8)</p>\n\n<p style=\"margin-left:22%;\">Used in conjunction with\n<b>MAP_HUGETLB</b> to select alternative hugetlb page sizes\n(respectively, 2&nbsp;MB and 1&nbsp;GB) on systems that\nsupport multiple hugetlb page sizes.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">More generally,\nthe desired huge page size can be configured by encoding the\nbase-2 logarithm of the desired page size in the six bits at\nthe offset <b>MAP_HUGE_SHIFT</b>. (A value of zero in this\nbit field provides the default huge page size; the default\nhuge page size can be discovered via the <i>Hugepagesize</i>\nfield exposed by <i>/proc/meminfo</i>.) Thus, the above two\nconstants are defined as:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">#define\nMAP_HUGE_2MB (21 &lt;&lt; MAP_HUGE_SHIFT) <br>\n#define MAP_HUGE_1GB (30 &lt;&lt; MAP_HUGE_SHIFT)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The range of\nhuge page sizes that are supported by the system can be\ndiscovered by listing the subdirectories in\n<i>/sys/kernel/mm/hugepages</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_LOCKED</b> (since Linux\n2.5.37)</p>\n\n<p style=\"margin-left:22%;\">Mark the mapped region to be\nlocked in the same way as <a href=\"https://man.page/2/mlock\">mlock(2)</a>. This\nimplementation will try to populate (prefault) the whole\nrange but the <b>mmap</b>() call doesn&rsquo;t fail with\n<b>ENOMEM</b> if this fails. Therefore major faults might\nhappen later on. So the semantic is not as strong as\n<a href=\"https://man.page/2/mlock\">mlock(2)</a>. One should use <b>mmap</b>() plus\n<a href=\"https://man.page/2/mlock\">mlock(2)</a> when major faults are not acceptable after\nthe initialization of the mapping. The <b>MAP_LOCKED</b>\nflag is ignored in older kernels.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_NONBLOCK</b> (since\nLinux 2.5.46)</p>\n\n<p style=\"margin-left:22%;\">This flag is meaningful only in\nconjunction with <b>MAP_POPULATE</b>. Don&rsquo;t perform\nread-ahead: create page tables entries only for pages that\nare already present in RAM. Since Linux 2.6.23, this flag\ncauses <b>MAP_POPULATE</b> to do nothing. One day, the\ncombination of <b>MAP_POPULATE</b> and <b>MAP_NONBLOCK</b>\nmay be reimplemented.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_NORESERVE</b></p>\n\n<p style=\"margin-left:22%;\">Do not reserve swap space for\nthis mapping. When swap space is reserved, one has the\nguarantee that it is possible to modify the mapping. When\nswap space is not reserved one might get <b>SIGSEGV</b> upon\na write if no physical memory is available. See also the\ndiscussion of the file <i>/proc/sys/vm/overcommit_memory</i>\nin <a href=\"https://man.page/5/proc\">proc(5)</a>. In kernels before 2.6, this flag had\neffect only for private writable mappings.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_POPULATE</b> (since\nLinux 2.5.46)</p>\n\n<p style=\"margin-left:22%;\">Populate (prefault) page tables\nfor a mapping. For a file mapping, this causes read-ahead on\nthe file. This will help to reduce blocking on page faults\nlater. <b>MAP_POPULATE</b> is supported for private mappings\nonly since Linux 2.6.23.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_STACK</b> (since Linux\n2.6.27)</p>\n\n<p style=\"margin-left:22%;\">Allocate the mapping at an\naddress suitable for a process or thread stack.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This flag is\ncurrently a no-op on Linux. However, by employing this flag,\napplications can ensure that they transparently obtain\nsupport if the flag is implemented in the future. Thus, it\nis used in the glibc threading implementation to allow for\nthe fact that some architectures may (later) require special\ntreatment for stack allocations. A further reason to employ\nthis flag is portability: <b>MAP_STACK</b> exists (and has\nan effect) on some other systems (e.g., some of the\nBSDs).</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_SYNC</b> (since Linux\n4.15)</p>\n\n<p style=\"margin-left:22%;\">This flag is available only\nwith the <b>MAP_SHARED_VALIDATE</b> mapping type; mappings\nof type <b>MAP_SHARED</b> will silently ignore this flag.\nThis flag is supported only for files supporting DAX (direct\nmapping of persistent memory). For other files, creating a\nmapping with this flag results in an <b>EOPNOTSUPP</b>\nerror.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Shared file\nmappings with this flag provide the guarantee that while\nsome memory is mapped writable in the address space of the\nprocess, it will be visible in the same file at the same\noffset even after the system crashes or is rebooted. In\nconjunction with the use of appropriate CPU instructions,\nthis provides users of such mappings with a more efficient\nway of making data modifications persistent.</p>\n\n<p style=\"margin-left:11%;\"><b>MAP_UNINITIALIZED</b> (since\nLinux 2.6.33)</p>\n\n<p style=\"margin-left:22%;\">Don&rsquo;t clear anonymous\npages. This flag is intended to improve performance on\nembedded devices. This flag is honored only if the kernel\nwas configured with the\n<b>CONFIG_MMAP_ALLOW_UNINITIALIZED</b> option. Because of\nthe security implications, that option is normally enabled\nonly on embedded devices (i.e., devices where one has\ncomplete control of the contents of user memory).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Of the above\nflags, only <b>MAP_FIXED</b> is specified in POSIX.1-2001\nand POSIX.1-2008. However, most systems also support\n<b>MAP_ANONYMOUS</b> (or its synonym <b>MAP_ANON</b>).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>munmap()</b>\n<br>\nThe <b>munmap</b>() system call deletes the mappings for the\nspecified address range, and causes further references to\naddresses within the range to generate invalid memory\nreferences. The region is also automatically unmapped when\nthe process is terminated. On the other hand, closing the\nfile descriptor does not unmap the region.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The address\n<i>addr</i> must be a multiple of the page size (but\n<i>length</i> need not be). All pages containing a part of\nthe indicated range are unmapped, and subsequent references\nto these pages will generate <b>SIGSEGV</b>. It is not an\nerror if the indicated range does not contain any mapped\npages.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>mmap</b>() returns a pointer to the mapped area. On\nerror, the value <b>MAP_FAILED</b> (that is,\n<i>(void&nbsp;*)&nbsp;-1</i>) is returned, and <i>errno</i>\nis set to indicate the cause of the error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>munmap</b>() returns 0. On failure, it returns -1, and\n<i>errno</i> is set to indicate the cause of the error\n(probably to <b>EINVAL</b>).</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">A file descriptor refers to a\nnon-regular file. Or a file mapping was requested, but\n<i>fd</i> is not open for reading. Or <b>MAP_SHARED</b> was\nrequested and <b>PROT_WRITE</b> is set, but <i>fd</i> is not\nopen in read/write (<b>O_RDWR</b>) mode. Or\n<b>PROT_WRITE</b> is set, but the file is append-only.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The file has been locked, or too much memory has been\nlocked (see <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is not a valid file descriptor (and\n<b>MAP_ANONYMOUS</b> was not set).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EEXIST</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>MAP_FIXED_NOREPLACE</b> was specified in\n<i>flags</i>, and the range covered by <i>addr</i> and\n<i>length</i> clashes with an existing mapping.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>We don&rsquo;t like <i>addr</i>, <i>length</i>, or\n<i>offset</i> (e.g., they are too large, or not aligned on a\npage boundary).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(since Linux 2.6.12) <i>length</i> was 0.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>flags</i> contained none of <b>MAP_PRIVATE</b>,\n<b>MAP_SHARED</b> or <b>MAP_SHARED_VALIDATE</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The system-wide limit on the total number of open files\nhas been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENODEV</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The underlying filesystem of the specified file does not\nsupport memory mapping.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>No memory is available.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The process&rsquo;s maximum number of mappings would\nhave been exceeded. This error can also occur for\n<b>munmap</b>(), when unmapping a region in the middle of an\nexisting mapping, since this results in two smaller mappings\non either side of the region being unmapped.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(since Linux 4.7) The process&rsquo;s <b>RLIMIT_DATA</b>\nlimit, described in <a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>, would have been\nexceeded.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EOVERFLOW</b></p>\n\n<p style=\"margin-left:22%;\">On 32-bit architecture together\nwith the large file extension (i.e., using 64-bit\n<i>off_t</i>): the number of pages used for <i>length</i>\nplus number of pages used for <i>offset</i> would overflow\n<i>unsigned long</i> (32 bits).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>prot</i> argument asks for <b>PROT_EXEC</b> but\nthe mapped area belongs to a file on a filesystem that was\nmounted no-exec.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>The operation was prevented by a file seal; see\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ETXTBSY</b></p>\n\n<p style=\"margin-left:22%;\"><b>MAP_DENYWRITE</b> was set\nbut the object specified by <i>fd</i> is open for\nwriting.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Use of a mapped\nregion can result in these signals: <b><br>\nSIGSEGV</b></p>\n\n<p style=\"margin-left:22%;\">Attempted write into a region\nmapped as read-only.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>SIGBUS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted access to a page of the buffer that lies\nbeyond the end of the mapped file. For an explanation of the\ntreatment of the bytes in the page that corresponds to the\nend of a mapped file that is not a multiple of the page\nsize, see NOTES.</p></td></tr>\n</table>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3251151.png\" alt=\"Image grohtml-3251151.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008, SVr4, 4.4BSD.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On POSIX\nsystems on which <b>mmap</b>(), <a href=\"https://man.page/2/msync\">msync(2)</a>, and\n<b>munmap</b>() are available, <b>_POSIX_MAPPED_FILES</b> is\ndefined in <i>&lt;unistd.h&gt;</i> to a value greater than\n0. (See also <a href=\"https://man.page/3/sysconf\">sysconf(3)</a>.)</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Memory mapped\nby <b>mmap</b>() is preserved across <a href=\"https://man.page/2/fork\">fork(2)</a>, with\nthe same attributes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A file is\nmapped in multiples of the page size. For a file that is not\na multiple of the page size, the remaining bytes in the\npartial page at the end of the mapping are zeroed when\nmapped, and modifications to that region are not written out\nto the file. The effect of changing the size of the\nunderlying file of a mapping on the pages that correspond to\nadded or removed regions of the file is unspecified.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On some\nhardware architectures (e.g., i386), <b>PROT_WRITE</b>\nimplies <b>PROT_READ</b>. It is architecture dependent\nwhether <b>PROT_READ</b> implies <b>PROT_EXEC</b> or not.\nPortable programs should always set <b>PROT_EXEC</b> if they\nintend to execute code in the new mapping.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The portable\nway to create a mapping is to specify <i>addr</i> as 0\n(NULL), and omit <b>MAP_FIXED</b> from <i>flags</i>. In this\ncase, the system chooses the address for the mapping; the\naddress is chosen so as not to conflict with any existing\nmapping, and will not be 0. If the <b>MAP_FIXED</b> flag is\nspecified, and <i>addr</i> is 0 (NULL), then the mapped\naddress will be 0 (NULL).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Certain\n<i>flags</i> constants are defined only if suitable feature\ntest macros are defined (possibly by default):\n<b>_DEFAULT_SOURCE</b> with glibc 2.19 or later; or\n<b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b> in glibc 2.19 and\nearlier. (Employing <b>_GNU_SOURCE</b> also suffices, and\nrequiring that macro specifically would have been more\nlogical, since these flags are all Linux-specific.) The\nrelevant flags are: <b>MAP_32BIT</b>, <b>MAP_ANONYMOUS</b>\n(and the synonym <b>MAP_ANON</b>), <b>MAP_DENYWRITE</b>,\n<b>MAP_EXECUTABLE</b>, <b>MAP_FILE</b>,\n<b>MAP_GROWSDOWN</b>, <b>MAP_HUGETLB</b>, <b>MAP_LOCKED</b>,\n<b>MAP_NONBLOCK</b>, <b>MAP_NORESERVE</b>,\n<b>MAP_POPULATE</b>, and <b>MAP_STACK</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An application\ncan determine which pages of a mapping are currently\nresident in the buffer/page cache using\n<a href=\"https://man.page/2/mincore\">mincore(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Using\nMAP_FIXED safely</b> <br>\nThe only safe use for <b>MAP_FIXED</b> is where the address\nrange specified by <i>addr</i> and <i>length</i> was\npreviously reserved using another mapping; otherwise, the\nuse of <b>MAP_FIXED</b> is hazardous because it forcibly\nremoves preexisting mappings, making it easy for a\nmultithreaded process to corrupt its own address space.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nsuppose that thread A looks through\n<i>/proc/&lt;pid&gt;/maps</i> in order to locate an unused\naddress range that it can map using <b>MAP_FIXED</b>, while\nthread B simultaneously acquires part or all of that same\naddress range. When thread A subsequently employs\n<b>mmap(MAP_FIXED)</b>, it will effectively clobber the\nmapping that thread B created. In this scenario, thread B\nneed not create a mapping directly; simply making a library\ncall that, internally, uses <a href=\"https://man.page/3/dlopen\">dlopen(3)</a> to load some\nother shared library, will suffice. The <a href=\"https://man.page/3/dlopen\">dlopen(3)</a>\ncall will map the library into the process&rsquo;s address\nspace. Furthermore, almost any library call may be\nimplemented in a way that adds memory mappings to the\naddress space, either with this technique, or by simply\nallocating memory. Examples include <a href=\"https://man.page/2/brk\">brk(2)</a>,\n<a href=\"https://man.page/3/malloc\">malloc(3)</a>, <a href=\"https://man.page/3/pthread_create\">pthread_create(3)</a>, and the PAM\nlibraries\n<a href=\"http://www.linux-pam.org\">http://www.linux-pam.org</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n4.17, a multithreaded program can use the\n<b>MAP_FIXED_NOREPLACE</b> flag to avoid the hazard\ndescribed above when attempting to create a mapping at a\nfixed address that has not been reserved by a preexisting\nmapping.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Timestamps\nchanges for file-backed mappings</b> <br>\nFor file-backed mappings, the <i>st_atime</i> field for the\nmapped file may be updated at any time between the\n<b>mmap</b>() and the corresponding unmapping; the first\nreference to a mapped page will update the field if it has\nnot been already.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>st_ctime</i> and <i>st_mtime</i> field for a file mapped\nwith <b>PROT_WRITE</b> and <b>MAP_SHARED</b> will be updated\nafter a write to the mapped region, and before a subsequent\n<a href=\"https://man.page/2/msync\">msync(2)</a> with the <b>MS_SYNC</b> or <b>MS_ASYNC</b>\nflag, if one occurs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Huge page\n(Huge TLB) mappings</b> <br>\nFor mappings that employ huge pages, the requirements for\nthe arguments of <b>mmap</b>() and <b>munmap</b>() differ\nsomewhat from the requirements for mappings that use the\nnative system page size.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>mmap</b>(), <i>offset</i> must be a multiple of the\nunderlying huge page size. The system automatically aligns\n<i>length</i> to be a multiple of the underlying huge page\nsize.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>munmap</b>(), <i>addr</i>, and <i>length</i> must both be\na multiple of the underlying huge page size.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nThis page describes the interface provided by the glibc\n<b>mmap</b>() wrapper function. Originally, this function\ninvoked a system call of the same name. Since kernel 2.4,\nthat system call has been superseded by <a href=\"https://man.page/2/mmap2\">mmap2(2)</a>, and\nnowadays the glibc <b>mmap</b>() wrapper function invokes\n<a href=\"https://man.page/2/mmap2\">mmap2(2)</a> with a suitably adjusted value for\n<i>offset</i>.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux, there\nare no guarantees like those suggested above under\n<b>MAP_NORESERVE</b>. By default, any process can be killed\nat any moment when the system runs out of memory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In kernels\nbefore 2.6.7, the <b>MAP_POPULATE</b> flag has effect only\nif <i>prot</i> is specified as <b>PROT_NONE</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">SUSv3 specifies\nthat <b>mmap</b>() should fail if <i>length</i> is 0.\nHowever, in kernels before 2.6.12, <b>mmap</b>() succeeded\nin this case: no mapping was created and the call returned\n<i>addr</i>. Since kernel 2.6.12, <b>mmap</b>() fails with\nthe error <b>EINVAL</b> for this case.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX specifies\nthat the system shall always zero fill any partial page at\nthe end of the object and that system will never write any\nmodification of the object beyond its end. On Linux, when\nyou write data to such partial page after the end of the\nobject, the data stays in the page cache even after the file\nis closed and unmapped and even though the data is never\nwritten to the file itself, subsequent mappings may see the\nmodified content. In some cases, this could be fixed by\ncalling <a href=\"https://man.page/2/msync\">msync(2)</a> before the unmap takes place;\nhowever, this doesn&rsquo;t work on <a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a> (for\nexample, when using the POSIX shared memory interface\ndocumented in <a href=\"https://man.page/7/shm_overview\">shm_overview(7)</a>).</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram prints part of the file specified in its first\ncommand-line argument to standard output. The range of bytes\nto be printed is specified via offset and length values in\nthe second and third command-line arguments. The program\ncreates a memory mapping of the required pages of the file\nand then uses <a href=\"https://man.page/2/write\">write(2)</a> to output the desired\nbytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;sys/mman.h&gt; <br>\n#include &lt;sys/stat.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error(msg) \\ <br>\ndo { perror(msg); exit(EXIT_FAILURE); } while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nchar *addr; <br>\nint fd; <br>\nstruct stat sb; <br>\noff_t offset, pa_offset; <br>\nsize_t length; <br>\nssize_t s;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt; 3\n|| argc &gt; 4) { <br>\nfprintf(stderr, &quot;%s file offset [length]\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(argv[1], O_RDONLY); <br>\nif (fd == -1) <br>\nhandle_error(&quot;open&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fstat(fd,\n&amp;sb) == -1) /* To obtain file size */ <br>\nhandle_error(&quot;fstat&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">offset =\natoi(argv[2]); <br>\npa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - 1); <br>\n/* offset for mmap() must be page aligned */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (offset\n&gt;= sb.st_size) { <br>\nfprintf(stderr, &quot;offset is past end of file\\n&quot;);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc == 4)\n{ <br>\nlength = atoi(argv[3]); <br>\nif (offset + length &gt; sb.st_size) <br>\nlength = sb.st_size - offset; <br>\n/* Can't display bytes past end of file */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">} else { /* No\nlength arg ==&gt; display to end of file */ <br>\nlength = sb.st_size - offset; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">addr =\nmmap(NULL, length + offset - pa_offset, PROT_READ, <br>\nMAP_PRIVATE, fd, pa_offset); <br>\nif (addr == MAP_FAILED) <br>\nhandle_error(&quot;mmap&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\nwrite(STDOUT_FILENO, addr + offset - pa_offset, length);\n<br>\nif (s != length) { <br>\nif (s == -1) <br>\nhandle_error(&quot;write&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fprintf(stderr,\n&quot;partial write&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">munmap(addr,\nlength + offset - pa_offset); <br>\nclose(fd);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>,\n<a href=\"https://man.page/2/getpagesize\">getpagesize(2)</a>, <a href=\"https://man.page/2/memfd_create\">memfd_create(2)</a>,\n<a href=\"https://man.page/2/mincore\">mincore(2)</a>, <a href=\"https://man.page/2/mlock\">mlock(2)</a>, <a href=\"https://man.page/2/mmap2\">mmap2(2)</a>,\n<a href=\"https://man.page/2/mprotect\">mprotect(2)</a>, <a href=\"https://man.page/2/mremap\">mremap(2)</a>, <a href=\"https://man.page/2/msync\">msync(2)</a>,\n<a href=\"https://man.page/2/remap_file_pages\">remap_file_pages(2)</a>, <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>,\n<a href=\"https://man.page/2/shmat\">shmat(2)</a>, <a href=\"https://man.page/2/userfaultfd\">userfaultfd(2)</a>, <a href=\"https://man.page/3/shm_open\">shm_open(3)</a>,\n<a href=\"https://man.page/7/shm_overview\">shm_overview(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\ndescriptions of the following files in <a href=\"https://man.page/5/proc\">proc(5)</a>:\n<i>/proc/[pid]/maps</i>, <i>/proc/[pid]/map_files</i>, and\n<i>/proc/[pid]/smaps</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">B.O.\nGallmeister, POSIX.4, O&rsquo;Reilly, pp. 128&ndash;129 and\n389&ndash;391.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}