{"name":"mbind","body":"\n\n<h1 align=\"center\">MBIND</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">mbind - set\nmemory policy for a memory range</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;numaif.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>long\nmbind(void *</b><i>addr</i><b>, unsigned long</b>\n<i>len</i><b>, int</b> <i>mode</i><b>, <br>\nconst unsigned long *</b><i>nodemask</i><b>, unsigned\nlong</b> <i>maxnode</i><b>, <br>\nunsigned</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Link with\n<i>-lnuma</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mbind</b>()\nsets the NUMA memory policy, which consists of a policy mode\nand zero or more nodes, for the memory range starting with\n<i>addr</i> and continuing for <i>len</i> bytes. The memory\npolicy defines from which node memory is allocated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the memory\nrange specified by the <i>addr</i> and <i>len</i> arguments\nincludes an &quot;anonymous&quot; region of\nmemory&mdash;that is a region of memory created using the\n<a href=\"https://man.page/2/mmap\">mmap(2)</a> system call with the\n<b>MAP_ANONYMOUS</b>&mdash;or a memory-mapped file, mapped\nusing the <a href=\"https://man.page/2/mmap\">mmap(2)</a> system call with the\n<b>MAP_PRIVATE</b> flag, pages will be allocated only\naccording to the specified policy when the application\nwrites (stores) to the page. For anonymous regions, an\ninitial read access will use a shared page in the kernel\ncontaining all zeros. For a file mapped with\n<b>MAP_PRIVATE</b>, an initial read access will allocate\npages according to the memory policy of the thread that\ncauses the page to be allocated. This may not be the thread\nthat called <b>mbind</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The specified\npolicy will be ignored for any <b>MAP_SHARED</b> mappings in\nthe specified memory range. Rather the pages will be\nallocated according to the memory policy of the thread that\ncaused the page to be allocated. Again, this may not be the\nthread that called <b>mbind</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nspecified memory range includes a shared memory region\ncreated using the <a href=\"https://man.page/2/shmget\">shmget(2)</a> system call and attached\nusing the <a href=\"https://man.page/2/shmat\">shmat(2)</a> system call, pages allocated for\nthe anonymous or shared memory region will be allocated\naccording to the policy specified, regardless of which\nprocess attached to the shared memory segment causes the\nallocation. If, however, the shared memory region was\ncreated with the <b>SHM_HUGETLB</b> flag, the huge pages\nwill be allocated according to the policy specified only if\nthe page allocation is caused by the process that calls\n<b>mbind</b>() for that region.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\n<b>mbind</b>() has an effect only for new allocations; if\nthe pages inside the range have been already touched before\nsetting the policy, then the policy has no effect. This\ndefault behavior may be overridden by the\n<b>MPOL_MF_MOVE</b> and <b>MPOL_MF_MOVE_ALL</b> flags\ndescribed below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>mode</i>\nargument must specify one of <b>MPOL_DEFAULT</b>,\n<b>MPOL_BIND</b>, <b>MPOL_INTERLEAVE</b>,\n<b>MPOL_PREFERRED</b>, or <b>MPOL_LOCAL</b> (which are\ndescribed in detail below). All policy modes except\n<b>MPOL_DEFAULT</b> require the caller to specify the node\nor nodes to which the mode applies, via the <i>nodemask</i>\nargument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>mode</i>\nargument may also include an optional <i>mode flag</i>. The\nsupported <i>mode flags</i> are: <b><br>\nMPOL_F_STATIC_NODES</b> (since Linux-2.6.26)</p>\n\n<p style=\"margin-left:22%;\">A nonempty <i>nodemask</i>\nspecifies physical node IDs. Linux does not remap the\n<i>nodemask</i> when the thread moves to a different cpuset\ncontext, nor when the set of nodes allowed by the\nthread&rsquo;s current cpuset context changes.</p>\n\n<p style=\"margin-left:11%;\"><b>MPOL_F_RELATIVE_NODES</b>\n(since Linux-2.6.26)</p>\n\n<p style=\"margin-left:22%;\">A nonempty <i>nodemask</i>\nspecifies node IDs that are relative to the set of node IDs\nallowed by the thread&rsquo;s current cpuset.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>nodemask</i>\npoints to a bit mask of nodes containing up to\n<i>maxnode</i> bits. The bit mask size is rounded to the\nnext multiple of <i>sizeof(unsigned long)</i>, but the\nkernel will use bits only up to <i>maxnode</i>. A NULL value\nof <i>nodemask</i> or a <i>maxnode</i> value of zero\nspecifies the empty set of nodes. If the value of\n<i>maxnode</i> is zero, the <i>nodemask</i> argument is\nignored. Where a <i>nodemask</i> is required, it must\ncontain at least one node that is on-line, allowed by the\nthread&rsquo;s current cpuset context (unless the\n<b>MPOL_F_STATIC_NODES</b> mode flag is specified), and\ncontains memory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>mode</i>\nargument must include one of the following values: <b><br>\nMPOL_DEFAULT</b></p>\n\n<p style=\"margin-left:22%;\">This mode requests that any\nnondefault policy be removed, restoring default behavior.\nWhen applied to a range of memory via <b>mbind</b>(), this\nmeans to use the thread memory policy, which may have been\nset with <a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>. If the mode of the thread\nmemory policy is also <b>MPOL_DEFAULT</b>, the system-wide\ndefault policy will be used. The system-wide default policy\nallocates pages on the node of the CPU that triggers the\nallocation. For <b>MPOL_DEFAULT</b>, the <i>nodemask</i> and\n<i>maxnode</i> arguments must be specify the empty set of\nnodes.</p>\n\n<p style=\"margin-left:11%;\"><b>MPOL_BIND</b></p>\n\n<p style=\"margin-left:22%;\">This mode specifies a strict\npolicy that restricts memory allocation to the nodes\nspecified in <i>nodemask</i>. If <i>nodemask</i> specifies\nmore than one node, page allocations will come from the node\nwith sufficient free memory that is closest to the node\nwhere the allocation takes place. Pages will not be\nallocated from any node not specified in the IR nodemask .\n(Before Linux 2.6.26, page allocations came from the node\nwith the lowest numeric node ID first, until that node\ncontained no free memory. Allocations then came from the\nnode with the next highest node ID specified in\n<i>nodemask</i> and so forth, until none of the specified\nnodes contained free memory.)</p>\n\n<p style=\"margin-left:11%;\"><b>MPOL_INTERLEAVE</b></p>\n\n<p style=\"margin-left:22%;\">This mode specifies that page\nallocations be interleaved across the set of nodes specified\nin <i>nodemask</i>. This optimizes for bandwidth instead of\nlatency by spreading out pages and memory accesses to those\npages across multiple nodes. To be effective the memory area\nshould be fairly large, at least 1&nbsp;MB or bigger with a\nfairly uniform access pattern. Accesses to a single page of\nthe area will still be limited to the memory bandwidth of a\nsingle node.</p>\n\n<p style=\"margin-left:11%;\"><b>MPOL_PREFERRED</b></p>\n\n<p style=\"margin-left:22%;\">This mode sets the preferred\nnode for allocation. The kernel will try to allocate pages\nfrom this node first and fall back to other nodes if the\npreferred nodes is low on free memory. If <i>nodemask</i>\nspecifies more than one node ID, the first node in the mask\nwill be selected as the preferred node. If the\n<i>nodemask</i> and <i>maxnode</i> arguments specify the\nempty set, then the memory is allocated on the node of the\nCPU that triggered the allocation.</p>\n\n<p style=\"margin-left:11%;\"><b>MPOL_LOCAL</b> (since Linux\n3.8)</p>\n\n<p style=\"margin-left:22%;\">This mode specifies &quot;local\nallocation&quot;; the memory is allocated on the node of the\nCPU that triggered the allocation (the &quot;local\nnode&quot;). The <i>nodemask</i> and <i>maxnode</i>\narguments must specify the empty set. If the &quot;local\nnode&quot; is low on free memory, the kernel will try to\nallocate memory from other nodes. The kernel will allocate\nmemory from the &quot;local node&quot; whenever memory for\nthis node is available. If the &quot;local node&quot; is not\nallowed by the thread&rsquo;s current cpuset context, the\nkernel will try to allocate memory from other nodes. The\nkernel will allocate memory from the &quot;local node&quot;\nwhenever it becomes allowed by the thread&rsquo;s current\ncpuset context. By contrast, <b>MPOL_DEFAULT</b> reverts to\nthe memory policy of the thread (which may be set via\n<a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>); that policy may be something other\nthan &quot;local allocation&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>MPOL_MF_STRICT</b> is passed in <i>flags</i> and\n<i>mode</i> is not <b>MPOL_DEFAULT</b>, then the call fails\nwith the error <b>EIO</b> if the existing pages in the\nmemory range don&rsquo;t follow the policy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>MPOL_MF_MOVE</b> is specified in <i>flags</i>, then the\nkernel will attempt to move all the existing pages in the\nmemory range so that they follow the policy. Pages that are\nshared with other processes will not be moved. If\n<b>MPOL_MF_STRICT</b> is also specified, then the call fails\nwith the error <b>EIO</b> if some pages could not be\nmoved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>MPOL_MF_MOVE_ALL</b> is passed in <i>flags</i>, then the\nkernel will attempt to move all existing pages in the memory\nrange regardless of whether other processes use the pages.\nThe calling thread must be privileged (<b>CAP_SYS_NICE</b>)\nto use this flag. If <b>MPOL_MF_STRICT</b> is also\nspecified, then the call fails with the error <b>EIO</b> if\nsome pages could not be moved.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>mbind</b>() returns 0; on error, -1 is returned and\n<i>errno</i> is set to indicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Part or all of the memory range\nspecified by <i>nodemask</i> and <i>maxnode</i> points\noutside your accessible address space. Or, there was an\nunmapped hole in the specified memory range specified by\n<i>addr</i> and <i>len</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An invalid value was specified for <i>flags</i> or\n<i>mode</i>; or <i>addr + len</i> was less than <i>addr</i>;\nor <i>addr</i> is not a multiple of the system page size.\nOr, <i>mode</i> is <b>MPOL_DEFAULT</b> and <i>nodemask</i>\nspecified a nonempty set; or <i>mode</i> is <b>MPOL_BIND</b>\nor <b>MPOL_INTERLEAVE</b> and <i>nodemask</i> is empty. Or,\n<i>maxnode</i> exceeds a kernel-imposed limit. Or,\n<i>nodemask</i> specifies one or more node IDs that are\ngreater than the maximum supported node ID. Or, none of the\nnode IDs specified by <i>nodemask</i> are on-line and\nallowed by the thread&rsquo;s current cpuset context, or\nnone of the specified nodes contain memory. Or, the\n<i>mode</i> argument specified both\n<b>MPOL_F_STATIC_NODES</b> and\n<b>MPOL_F_RELATIVE_NODES</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><b>MPOL_MF_STRICT</b> was specified and an existing page\nwas already on a node that does not follow the policy; or\n<b>MPOL_MF_MOVE</b> or <b>MPOL_MF_MOVE_ALL</b> was specified\nand the kernel was unable to move all existing pages in the\nrange.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Insufficient kernel memory was available.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>flags</i> argument included the\n<b>MPOL_MF_MOVE_ALL</b> flag and the caller does not have\nthe <b>CAP_SYS_NICE</b> privilege.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>mbind</b>() system call was added to the Linux kernel in\nversion 2.6.7.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This system\ncall is Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For information\non library support, see <a href=\"https://man.page/7/numa\">numa(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">NUMA policy is\nnot supported on a memory-mapped file range that was mapped\nwith the <b>MAP_SHARED</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>MPOL_DEFAULT</b> mode can have different effects for\n<b>mbind</b>() and <a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>. When\n<b>MPOL_DEFAULT</b> is specified for\n<a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>, the thread&rsquo;s memory policy\nreverts to the system default policy or local allocation.\nWhen <b>MPOL_DEFAULT</b> is specified for a range of memory\nusing <b>mbind</b>(), any pages subsequently allocated for\nthat range will use the thread&rsquo;s memory policy, as set\nby <a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>. This effectively removes the\nexplicit policy from the specified range, &quot;falling\nback&quot; to a possibly nondefault policy. To select\nexplicit &quot;local allocation&quot; for a memory range,\nspecify a <i>mode</i> of <b>MPOL_LOCAL</b> or\n<b>MPOL_PREFERRED</b> with an empty set of nodes. This\nmethod will work for <a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>, as well.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Support for\nhuge page policy was added with 2.6.16. For interleave\npolicy to be effective on huge page mappings the policied\nmemory needs to be tens of megabytes or larger.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n5.7. <b>MPOL_MF_STRICT</b> was ignored on huge page\nmappings.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>MPOL_MF_MOVE</b>\nand <b>MPOL_MF_MOVE_ALL</b> are available only on Linux\n2.6.16 and later.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/get_mempolicy\">get_mempolicy(2)</a>,\n<a href=\"https://man.page/2/getcpu\">getcpu(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>,\n<a href=\"https://man.page/2/shmat\">shmat(2)</a>, <a href=\"https://man.page/2/shmget\">shmget(2)</a>, <a href=\"https://man.page/3/numa\">numa(3)</a>,\n<a href=\"https://man.page/7/cpuset\">cpuset(7)</a>, <a href=\"https://man.page/7/numa\">numa(7)</a>, <b>numactl</b>(8)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}