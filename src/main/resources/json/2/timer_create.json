{"name":"timer_create","description":"timer_create - create a POSIX per-process timer","body":"\n\n<h1 align=\"center\">TIMER_CREATE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">timer_create -\ncreate a POSIX per-process timer</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;signal.h&gt; <br>\n#include &lt;time.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ntimer_create(clockid_t</b> <i>clockid</i><b>, struct\nsigevent *</b><i>sevp</i><b>, <br>\ntimer_t *</b><i>timerid</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Link with\n<i>-lrt</i>.</p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>timer_create</b>():\n_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;199309L</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>timer_create</b>()\ncreates a new per-process interval timer. The ID of the new\ntimer is returned in the buffer pointed to by\n<i>timerid</i>, which must be a non-null pointer. This ID is\nunique within the process, until the timer is deleted. The\nnew timer is initially disarmed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>clockid</i> argument specifies the clock that the new\ntimer uses to measure time. It can be specified as one of\nthe following values: <b><br>\nCLOCK_REALTIME</b></p>\n\n<p style=\"margin-left:22%;\">A settable system-wide\nreal-time clock.</p>\n\n<p style=\"margin-left:11%;\"><b>CLOCK_MONOTONIC</b></p>\n\n<p style=\"margin-left:22%;\">A nonsettable monotonically\nincreasing clock that measures time from some unspecified\npoint in the past that does not change after system\nstartup.</p>\n\n\n<p style=\"margin-left:11%;\"><b>CLOCK_PROCESS_CPUTIME_ID</b>\n(since Linux 2.6.12)</p>\n\n<p style=\"margin-left:22%;\">A clock that measures (user and\nsystem) CPU time consumed by (all of the threads in) the\ncalling process.</p>\n\n<p style=\"margin-left:11%;\"><b>CLOCK_THREAD_CPUTIME_ID</b>\n(since Linux 2.6.12)</p>\n\n<p style=\"margin-left:22%;\">A clock that measures (user and\nsystem) CPU time consumed by the calling thread.</p>\n\n<p style=\"margin-left:11%;\"><b>CLOCK_BOOTTIME</b> (Since\nLinux 2.6.39)</p>\n\n<p style=\"margin-left:22%;\">Like <b>CLOCK_MONOTONIC</b>,\nthis is a monotonically increasing clock. However, whereas\nthe <b>CLOCK_MONOTONIC</b> clock does not measure the time\nwhile a system is suspended, the <b>CLOCK_BOOTTIME</b> clock\ndoes include the time during which the system is suspended.\nThis is useful for applications that need to be\nsuspend-aware. <b>CLOCK_REALTIME</b> is not suitable for\nsuch applications, since that clock is affected by\ndiscontinuous changes to the system clock.</p>\n\n<p style=\"margin-left:11%;\"><b>CLOCK_REALTIME_ALARM</b>\n(since Linux 3.0)</p>\n\n<p style=\"margin-left:22%;\">This clock is like\n<b>CLOCK_REALTIME</b>, but will wake the system if it is\nsuspended. The caller must have the <b>CAP_WAKE_ALARM</b>\ncapability in order to set a timer against this clock.</p>\n\n<p style=\"margin-left:11%;\"><b>CLOCK_BOOTTIME_ALARM</b>\n(since Linux 3.0)</p>\n\n<p style=\"margin-left:22%;\">This clock is like\n<b>CLOCK_BOOTTIME</b>, but will wake the system if it is\nsuspended. The caller must have the <b>CAP_WAKE_ALARM</b>\ncapability in order to set a timer against this clock.</p>\n\n<p style=\"margin-left:11%;\"><b>CLOCK_TAI</b> (since Linux\n3.10)</p>\n\n<p style=\"margin-left:22%;\">A system-wide clock derived\nfrom wall-clock time but ignoring leap seconds.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/2/clock_getres\">clock_getres(2)</a> for some further details on the above\nclocks.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As well as the\nabove values, <i>clockid</i> can be specified as the\n<i>clockid</i> returned by a call to\n<a href=\"https://man.page/3/clock_getcpuclockid\">clock_getcpuclockid(3)</a> or\n<a href=\"https://man.page/3/pthread_getcpuclockid\">pthread_getcpuclockid(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>sevp</i>\nargument points to a <i>sigevent</i> structure that\nspecifies how the caller should be notified when the timer\nexpires. For the definition and general details of this\nstructure, see <a href=\"https://man.page/7/sigevent\">sigevent(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>sevp.sigev_notify</i> field can have the following\nvalues: <b><br>\nSIGEV_NONE</b></p>\n\n<p style=\"margin-left:22%;\">Don&rsquo;t asynchronously\nnotify when the timer expires. Progress of the timer can be\nmonitored using <a href=\"https://man.page/2/timer_gettime\">timer_gettime(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>SIGEV_SIGNAL</b></p>\n\n<p style=\"margin-left:22%;\">Upon timer expiration, generate\nthe signal <i>sigev_signo</i> for the process. See\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for general details. The <i>si_code</i>\nfield of the <i>siginfo_t</i> structure will be set to\n<b>SI_TIMER</b>. At any point in time, at most one signal is\nqueued to the process for a given timer; see\n<a href=\"https://man.page/2/timer_getoverrun\">timer_getoverrun(2)</a> for more details.</p>\n\n<p style=\"margin-left:11%;\"><b>SIGEV_THREAD</b></p>\n\n<p style=\"margin-left:22%;\">Upon timer expiration, invoke\n<i>sigev_notify_function</i> as if it were the start\nfunction of a new thread. See <a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for\ndetails.</p>\n\n<p style=\"margin-left:11%;\"><b>SIGEV_THREAD_ID</b>\n(Linux-specific)</p>\n\n<p style=\"margin-left:22%;\">As for <b>SIGEV_SIGNAL</b>, but\nthe signal is targeted at the thread whose ID is given in\n<i>sigev_notify_thread_id</i>, which must be a thread in the\nsame process as the caller. The\n<i>sigev_notify_thread_id</i> field specifies a kernel\nthread ID, that is, the value returned by <a href=\"https://man.page/2/clone\">clone(2)</a> or\n<a href=\"https://man.page/2/gettid\">gettid(2)</a>. This flag is intended only for use by\nthreading libraries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Specifying\n<i>sevp</i> as NULL is equivalent to specifying a pointer to\na <i>sigevent</i> structure in which <i>sigev_notify</i> is\n<b>SIGEV_SIGNAL</b>, <i>sigev_signo</i> is <b>SIGALRM</b>,\nand <i>sigev_value.sival_int</i> is the timer ID.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>timer_create</b>() returns 0, and the ID of the new timer\nis placed in <i>*timerid</i>. On failure, -1 is returned,\nand <i>errno</i> is set to indicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Temporary error during kernel\nallocation of timer structures.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Clock ID, <i>sigev_notify</i>, <i>sigev_signo</i>, or\n<i>sigev_notify_thread_id</i> is invalid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Could not allocate memory.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTSUP</b></p>\n\n<p style=\"margin-left:22%;\">The kernel does not support\ncreating a timer against this <i>clockid</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p><i>clockid</i> was <b>CLOCK_REALTIME_ALARM</b> or\n<b>CLOCK_BOOTTIME_ALARM</b> but the caller did not have the\n<b>CAP_WAKE_ALARM</b> capability.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This system\ncall is available since Linux 2.6.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A program may\ncreate multiple interval timers using\n<b>timer_create</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Timers are not\ninherited by the child of a <a href=\"https://man.page/2/fork\">fork(2)</a>, and are disarmed\nand deleted during an <a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\npreallocates a &quot;queued real-time signal&quot; for each\ntimer created using <b>timer_create</b>(). Consequently, the\nnumber of timers is limited by the <b>RLIMIT_SIGPENDING</b>\nresource limit (see <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The timers\ncreated by <b>timer_create</b>() are commonly known as\n&quot;POSIX (interval) timers&quot;. The POSIX timers API\nconsists of the following interfaces:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\"><b>timer_create</b>(): Create a\ntimer.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/timer_settime\">timer_settime(2)</a>: Arm (start) or disarm (stop) a\ntimer.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/timer_gettime\">timer_gettime(2)</a>: Fetch the time remaining until\nthe next expiration of a timer, along with the interval\nsetting of the timer.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/timer_getoverrun\">timer_getoverrun(2)</a>: Return the overrun count for\nthe last timer expiration.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/timer_delete\">timer_delete(2)</a>: Disarm and delete a timer.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n3.10, the <i>/proc/[pid]/timers</i> file can be used to list\nthe POSIX timers for the process with PID <i>pid</i>. See\n<a href=\"https://man.page/5/proc\">proc(5)</a> for further information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n4.10, support for POSIX timers is a configurable option that\nis enabled by default. Kernel support can be disabled via\nthe <b>CONFIG_POSIX_TIMERS</b> option.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nPart of the implementation of the POSIX timers API is\nprovided by glibc. In particular:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Much of the functionality for\n<b>SIGEV_THREAD</b> is implemented within glibc, rather than\nthe kernel. (This is necessarily so, since the thread\ninvolved in handling the notification is one that must be\nmanaged by the C library POSIX threads implementation.)\nAlthough the notification delivered to the process is via a\nthread, internally the NPTL implementation uses a\n<i>sigev_notify</i> value of <b>SIGEV_THREAD_ID</b> along\nwith a real-time signal that is reserved by the\nimplementation (see <a href=\"https://man.page/7/nptl\">nptl(7)</a>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The implementation of the default case where <i>evp</i>\nis NULL is handled inside glibc, which invokes the\nunderlying system call with a suitably populated\n<i>sigevent</i> structure.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The timer IDs presented at user level are maintained by\nglibc, which maps these IDs to the timer IDs employed by the\nkernel.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The POSIX\ntimers system calls first appeared in Linux 2.6. Prior to\nthis, glibc provided an incomplete user-space implementation\n(<b>CLOCK_REALTIME</b> timers only) using POSIX threads, and\nin glibc versions before 2.17, the implementation falls back\nto this technique on systems running pre-2.6 Linux\nkernels.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow takes two arguments: a sleep period in seconds, and a\ntimer frequency in nanoseconds. The program establishes a\nhandler for the signal it uses for the timer, blocks that\nsignal, creates and arms a timer that expires with the given\nfrequency, sleeps for the specified number of seconds, and\nthen unblocks the timer signal. Assuming that the timer\nexpired at least once while the program slept, the signal\nhandler will be invoked, and the handler displays some\ninformation about the timer notification. The program\nterminates after one invocation of the signal handler.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the\nfollowing example run, the program sleeps for 1 second,\nafter creating a timer that has a frequency of 100\nnanoseconds. By the time the signal is unblocked and\ndelivered, there have been around ten million overruns.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out 1\n100</b> <br>\nEstablishing handler for signal 34 <br>\nBlocking signal 34 <br>\ntimer ID is 0x804c008 <br>\nSleeping for 1 seconds <br>\nUnblocking signal 34 <br>\nCaught signal 34 <br>\nsival_ptr = 0xbfb174f4; *sival_ptr = 0x804c008 <br>\noverrun count = 10004886</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;signal.h&gt; <br>\n#include &lt;time.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define CLOCKID\nCLOCK_REALTIME <br>\n#define SIG SIGRTMIN</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nprint_siginfo(siginfo_t *si) <br>\n{ <br>\ntimer_t *tidp; <br>\nint or;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">tidp =\nsi-&gt;si_value.sival_ptr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;\nsival_ptr = %p; &quot;, si-&gt;si_value.sival_ptr); <br>\nprintf(&quot; *sival_ptr = %#jx\\n&quot;, (uintmax_t)\n*tidp);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or =\ntimer_getoverrun(*tidp); <br>\nif (or == -1) <br>\nerrExit(&quot;timer_getoverrun&quot;); <br>\nelse <br>\nprintf(&quot; overrun count = %d\\n&quot;, or); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nhandler(int sig, siginfo_t *si, void *uc) <br>\n{ <br>\n/* Note: calling printf() from a signal handler is not safe\n<br>\n(and should not be done in production programs), since <br>\nprintf() is not async-signal-safe; see signal-safety(7).\n<br>\nNevertheless, we use printf() here as a simple way of <br>\nshowing that the handler was called. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Caught\nsignal %d\\n&quot;, sig); <br>\nprint_siginfo(si); <br>\nsignal(sig, SIG_IGN); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\ntimer_t timerid; <br>\nstruct sigevent sev; <br>\nstruct itimerspec its; <br>\nlong long freq_nanosecs; <br>\nsigset_t mask; <br>\nstruct sigaction sa;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 3)\n{ <br>\nfprintf(stderr, &quot;Usage: %s &lt;sleep-secs&gt;\n&lt;freq-nanosecs&gt;\\n&quot;, <br>\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Establish\nhandler for timer signal */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Establishing\nhandler for signal %d\\n&quot;, SIG); <br>\nsa.sa_flags = SA_SIGINFO; <br>\nsa.sa_sigaction = handler; <br>\nsigemptyset(&amp;sa.sa_mask); <br>\nif (sigaction(SIG, &amp;sa, NULL) == -1) <br>\nerrExit(&quot;sigaction&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Block timer\nsignal temporarily */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Blocking\nsignal %d\\n&quot;, SIG); <br>\nsigemptyset(&amp;mask); <br>\nsigaddset(&amp;mask, SIG); <br>\nif (sigprocmask(SIG_SETMASK, &amp;mask, NULL) == -1) <br>\nerrExit(&quot;sigprocmask&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create the\ntimer */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sev.sigev_notify\n= SIGEV_SIGNAL; <br>\nsev.sigev_signo = SIG; <br>\nsev.sigev_value.sival_ptr = &amp;timerid; <br>\nif (timer_create(CLOCKID, &amp;sev, &amp;timerid) == -1)\n<br>\nerrExit(&quot;timer_create&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;timer\nID is %#jx\\n&quot;, (uintmax_t) timerid);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Start the\ntimer */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">freq_nanosecs =\natoll(argv[2]); <br>\nits.it_value.tv_sec = freq_nanosecs / 1000000000; <br>\nits.it_value.tv_nsec = freq_nanosecs % 1000000000; <br>\nits.it_interval.tv_sec = its.it_value.tv_sec; <br>\nits.it_interval.tv_nsec = its.it_value.tv_nsec;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(timer_settime(timerid, 0, &amp;its, NULL) == -1) <br>\nerrExit(&quot;timer_settime&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Sleep for a\nwhile; meanwhile, the timer may expire <br>\nmultiple times */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Sleeping\nfor %d seconds\\n&quot;, atoi(argv[1])); <br>\nsleep(atoi(argv[1]));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Unlock the\ntimer signal, so that timer notification <br>\ncan be delivered */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Unblocking\nsignal %d\\n&quot;, SIG); <br>\nif (sigprocmask(SIG_UNBLOCK, &amp;mask, NULL) == -1) <br>\nerrExit(&quot;sigprocmask&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/clock_gettime\">clock_gettime(2)</a>,\n<a href=\"https://man.page/2/setitimer\">setitimer(2)</a>, <a href=\"https://man.page/2/timer_delete\">timer_delete(2)</a>,\n<a href=\"https://man.page/2/timer_getoverrun\">timer_getoverrun(2)</a>, <a href=\"https://man.page/2/timer_settime\">timer_settime(2)</a>,\n<a href=\"https://man.page/2/timerfd_create\">timerfd_create(2)</a>, <a href=\"https://man.page/3/clock_getcpuclockid\">clock_getcpuclockid(3)</a>,\n<a href=\"https://man.page/3/pthread_getcpuclockid\">pthread_getcpuclockid(3)</a>, <a href=\"https://man.page/7/pthreads\">pthreads(7)</a>,\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a>, <a href=\"https://man.page/7/signal\">signal(7)</a>, <a href=\"https://man.page/7/time\">time(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}