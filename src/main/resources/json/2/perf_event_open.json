{"name":"perf_event_open","description":"perf_event_open\n- set up performance monitoring","body":"\n\n<h1 align=\"center\">PERF_EVENT_OPEN</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">perf_event_open\n- set up performance monitoring</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;linux/perf_event.h&gt; <br>\n#include &lt;linux/hw_breakpoint.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nperf_event_open(struct perf_event_attr *</b><i>attr</i><b>,\n<br>\npid_t</b> <i>pid</i><b>, int</b> <i>cpu</i><b>, int</b>\n<i>group_fd</i><b>, <br>\nunsigned long</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere is no glibc wrapper for this system call; see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given a list of\nparameters, <b>perf_event_open</b>() returns a file\ndescriptor, for use in subsequent system calls\n(<a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/prctl\">prctl(2)</a>,\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, etc.).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A call to\n<b>perf_event_open</b>() creates a file descriptor that\nallows measuring performance information. Each file\ndescriptor corresponds to one event that is measured; these\ncan be grouped together to measure multiple events\nsimultaneously.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Events can be\nenabled and disabled in two ways: via <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> and\nvia <a href=\"https://man.page/2/prctl\">prctl(2)</a>. When an event is disabled it does not\ncount or generate overflows but does continue to exist and\nmaintain its count value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Events come in\ntwo flavors: counting and sampled. A <i>counting</i> event\nis one that is used for counting the aggregate number of\nevents that occur. In general, counting event results are\ngathered with a <a href=\"https://man.page/2/read\">read(2)</a> call. A <i>sampling</i> event\nperiodically writes measurements to a buffer that can then\nbe accessed via <a href=\"https://man.page/2/mmap\">mmap(2)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Arguments</b>\n<br>\nThe <i>pid</i> and <i>cpu</i> arguments allow specifying\nwhich process and CPU to monitor: <b><br>\npid == 0</b> and <b>cpu == -1</b></p>\n\n<p style=\"margin-left:22%;\">This measures the calling\nprocess/thread on any CPU.</p>\n\n<p style=\"margin-left:11%;\"><b>pid == 0</b> and <b>cpu\n&gt;= 0</b></p>\n\n<p style=\"margin-left:22%;\">This measures the calling\nprocess/thread only when running on the specified CPU.</p>\n\n<p style=\"margin-left:11%;\"><b>pid &gt; 0</b> and <b>cpu ==\n-1</b></p>\n\n<p style=\"margin-left:22%;\">This measures the specified\nprocess/thread on any CPU.</p>\n\n<p style=\"margin-left:11%;\"><b>pid &gt; 0</b> and <b>cpu\n&gt;= 0</b></p>\n\n<p style=\"margin-left:22%;\">This measures the specified\nprocess/thread only when running on the specified CPU.</p>\n\n<p style=\"margin-left:11%;\"><b>pid == -1</b> and <b>cpu\n&gt;= 0</b></p>\n\n<p style=\"margin-left:22%;\">This measures all\nprocesses/threads on the specified CPU. This requires\n<b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b>\ncapability or a <i>/proc/sys/kernel/perf_event_paranoid</i>\nvalue of less than 1.</p>\n\n<p style=\"margin-left:11%;\"><b>pid == -1</b> and <b>cpu ==\n-1</b></p>\n\n<p style=\"margin-left:22%;\">This setting is invalid and\nwill return an error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When <i>pid</i>\nis greater than zero, permission to perform this system call\nis governed by <b>CAP_PERFMON</b> (since Linux 5.9) and a\nptrace access mode <b>PTRACE_MODE_READ_REALCREDS</b> check\non older Linux versions; see <a href=\"https://man.page/2/ptrace\">ptrace(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>group_fd</i> argument allows event groups to be created.\nAn event group has one event which is the group leader. The\nleader is created first, with <i>group_fd</i> = -1. The rest\nof the group members are created with subsequent\n<b>perf_event_open</b>() calls with <i>group_fd</i> being\nset to the file descriptor of the group leader. (A single\nevent on its own is created with <i>group_fd</i> = -1 and is\nconsidered to be a group with only 1 member.) An event group\nis scheduled onto the CPU as a unit: it will be put onto the\nCPU only if all of the events in the group can be put onto\nthe CPU. This means that the values of the member events can\nbe meaningfully compared&mdash;added, divided (to get\nratios), and so on&mdash;with each other, since they have\ncounted events for the same set of executed\ninstructions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>flags</i> argument is formed by ORing together zero or\nmore of the following values: <b><br>\nPERF_FLAG_FD_CLOEXEC</b> (since Linux 3.14)</p>\n\n<p style=\"margin-left:22%;\">This flag enables the\nclose-on-exec flag for the created event file descriptor, so\nthat the file descriptor is automatically closed on\n<a href=\"https://man.page/2/execve\">execve(2)</a>. Setting the close-on-exec flags at\ncreation time, rather than later with <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>,\navoids potential race conditions where the calling thread\ninvokes <b>perf_event_open</b>() and <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> at the\nsame time as another thread calls <a href=\"https://man.page/2/fork\">fork(2)</a> then\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_FLAG_FD_NO_GROUP</b></p>\n\n<p style=\"margin-left:22%;\">This flag tells the event to\nignore the <i>group_fd</i> parameter except for the purpose\nof setting up output redirection using the\n<b>PERF_FLAG_FD_OUTPUT</b> flag.</p>\n\n<p style=\"margin-left:11%;\"><b>PERF_FLAG_FD_OUTPUT</b>\n(broken since Linux 2.6.35)</p>\n\n<p style=\"margin-left:22%;\">This flag re-routes the\nevent&rsquo;s sampled output to instead be included in the\nmmap buffer of the event specified by <i>group_fd</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>PERF_FLAG_PID_CGROUP</b>\n(since Linux 2.6.39)</p>\n\n<p style=\"margin-left:22%;\">This flag activates\nper-container system-wide monitoring. A container is an\nabstraction that isolates a set of resources for\nfiner-grained control (CPUs, memory, etc.). In this mode,\nthe event is measured only if the thread running on the\nmonitored CPU belongs to the designated container (cgroup).\nThe cgroup is identified by passing a file descriptor opened\non its directory in the cgroupfs filesystem. For instance,\nif the cgroup to monitor is called <i>test</i>, then a file\ndescriptor opened on <i>/dev/cgroup/test</i> (assuming\ncgroupfs is mounted on <i>/dev/cgroup</i>) must be passed as\nthe <i>pid</i> parameter. cgroup monitoring is available\nonly for system-wide events and may therefore require extra\npermissions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>perf_event_attr</i> structure provides detailed\nconfiguration information for the event being created.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nperf_event_attr { <br>\n__u32 type; /* Type of event */ <br>\n__u32 size; /* Size of attribute structure */ <br>\n__u64 config; /* Type-specific configuration */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">union { <br>\n__u64 sample_period; /* Period of sampling */ <br>\n__u64 sample_freq; /* Frequency of sampling */ <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">__u64\nsample_type; /* Specifies values included in sample */ <br>\n__u64 read_format; /* Specifies values returned in read\n*/</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">__u64 disabled\n: 1, /* off by default */ <br>\ninherit : 1, /* children inherit it */ <br>\npinned : 1, /* must always be on PMU */ <br>\nexclusive : 1, /* only group on PMU */ <br>\nexclude_user : 1, /* don't count user */ <br>\nexclude_kernel : 1, /* don't count kernel */ <br>\nexclude_hv : 1, /* don't count hypervisor */ <br>\nexclude_idle : 1, /* don't count when idle */ <br>\nmmap : 1, /* include mmap data */ <br>\ncomm : 1, /* include comm data */ <br>\nfreq : 1, /* use freq, not period */ <br>\ninherit_stat : 1, /* per task counts */ <br>\nenable_on_exec : 1, /* next exec enables */ <br>\ntask : 1, /* trace fork/exit */ <br>\nwatermark : 1, /* wakeup_watermark */ <br>\nprecise_ip : 2, /* skid constraint */ <br>\nmmap_data : 1, /* non-exec mmap data */ <br>\nsample_id_all : 1, /* sample_type all events */ <br>\nexclude_host : 1, /* don't count in host */ <br>\nexclude_guest : 1, /* don't count in guest */ <br>\nexclude_callchain_kernel : 1, <br>\n/* exclude kernel callchains */ <br>\nexclude_callchain_user : 1, <br>\n/* exclude user callchains */ <br>\nmmap2 : 1, /* include mmap with inode data */ <br>\ncomm_exec : 1, /* flag comm events that are <br>\ndue to exec */ <br>\nuse_clockid : 1, /* use clockid for time fields */ <br>\ncontext_switch : 1, /* context switch data */ <br>\nwrite_backward : 1, /* Write ring buffer from end <br>\nto beginning */ <br>\nnamespaces : 1, /* include namespaces data */ <br>\nksymbol : 1, /* include ksymbol events */ <br>\nbpf_event : 1, /* include bpf events */ <br>\naux_output : 1, /* generate AUX records <br>\ninstead of events */ <br>\ncgroup : 1, /* include cgroup events */ <br>\ntext_poke : 1, /* include text poke events */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">__reserved_1 :\n30;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">union { <br>\n__u32 wakeup_events; /* wakeup every n events */ <br>\n__u32 wakeup_watermark; /* bytes before wakeup */ <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">__u32 bp_type;\n/* breakpoint type */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">union { <br>\n__u64 bp_addr; /* breakpoint address */ <br>\n__u64 kprobe_func; /* for perf_kprobe */ <br>\n__u64 uprobe_path; /* for perf_uprobe */ <br>\n__u64 config1; /* extension of config */ <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">union { <br>\n__u64 bp_len; /* breakpoint length */ <br>\n__u64 kprobe_addr; /* with kprobe_func == NULL */ <br>\n__u64 probe_offset; /* for perf_[k,u]probe */ <br>\n__u64 config2; /* extension of config1 */ <br>\n}; <br>\n__u64 branch_sample_type; /* enum perf_branch_sample_type */\n<br>\n__u64 sample_regs_user; /* user regs to dump on samples */\n<br>\n__u32 sample_stack_user; /* size of stack to dump on <br>\nsamples */ <br>\n__s32 clockid; /* clock to use for time fields */ <br>\n__u64 sample_regs_intr; /* regs to dump on samples */ <br>\n__u32 aux_watermark; /* aux bytes before wakeup */ <br>\n__u16 sample_max_stack; /* max frames in callchain */ <br>\n__u16 __reserved_2; /* align to u64 */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthe <i>perf_event_attr</i> structure are described in more\ndetail below:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>type</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This field specifies the overall event type. It has one\nof the following values:</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_TYPE_HARDWARE</b></p>\n\n<p style=\"margin-left:32%;\">This indicates one of the\n&quot;generalized&quot; hardware events provided by the\nkernel. See the <i>config</i> field definition for more\ndetails.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_TYPE_SOFTWARE</b></p>\n\n<p style=\"margin-left:32%;\">This indicates one of the\nsoftware-defined events provided by the kernel (even if no\nhardware support is available).</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_TYPE_TRACEPOINT</b></p>\n\n<p style=\"margin-left:32%;\">This indicates a tracepoint\nprovided by the kernel tracepoint infrastructure.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_TYPE_HW_CACHE</b></p>\n\n<p style=\"margin-left:32%;\">This indicates a hardware cache\nevent. This has a special encoding, described in the\n<i>config</i> field definition.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_TYPE_RAW</b></p>\n\n<p style=\"margin-left:32%;\">This indicates a\n&quot;raw&quot; implementation-specific event in the\n<i>config</i> field.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_TYPE_BREAKPOINT</b>\n(since Linux 2.6.33)</p>\n\n<p style=\"margin-left:32%;\">This indicates a hardware\nbreakpoint as provided by the CPU. Breakpoints can be\nread/write accesses to an address as well as execution of an\ninstruction address.</p>\n\n<p style=\"margin-left:22%;\">dynamic PMU</p>\n\n<p style=\"margin-left:32%;\">Since Linux 2.6.38,\n<b>perf_event_open</b>() can support multiple PMUs. To\nenable this, a value exported by the kernel can be used in\nthe <i>type</i> field to indicate which PMU to use. The\nvalue to use can be found in the sysfs filesystem: there is\na subdirectory per PMU instance under\n<i>/sys/bus/event_source/devices</i>. In each subdirectory\nthere is a <i>type</i> file whose content is an integer that\ncan be used in the <i>type</i> field. For instance,\n<i>/sys/bus/event_source/devices/cpu/type</i> contains the\nvalue for the core CPU PMU, which is usually 4.</p>\n\n<p style=\"margin-left:22%;\"><b>kprobe</b> and <b>uprobe</b>\n(since Linux 4.17)</p>\n\n<p style=\"margin-left:32%;\">These two dynamic PMUs create a\nkprobe/uprobe and attach it to the file descriptor generated\nby perf_event_open. The kprobe/uprobe will be destroyed on\nthe destruction of the file descriptor. See fields\n<i>kprobe_func</i>, <i>uprobe_path</i>, <i>kprobe_addr</i>,\nand <i>probe_offset</i> for more details.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>size</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>The size of the <i>perf_event_attr</i> structure for\nforward/backward compatibility. Set this using\n<i>sizeof(struct perf_event_attr)</i> to allow the kernel to\nsee the struct size at the time of compilation.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The related\ndefine <b>PERF_ATTR_SIZE_VER0</b> is set to 64; this was the\nsize of the first published struct.\n<b>PERF_ATTR_SIZE_VER1</b> is 72, corresponding to the\naddition of breakpoints in Linux 2.6.33.\n<b>PERF_ATTR_SIZE_VER2</b> is 80 corresponding to the\naddition of branch sampling in Linux 3.4.\n<b>PERF_ATTR_SIZE_VER3</b> is 96 corresponding to the\naddition of <i>sample_regs_user</i> and\n<i>sample_stack_user</i> in Linux 3.7.\n<b>PERF_ATTR_SIZE_VER4</b> is 104 corresponding to the\naddition of <i>sample_regs_intr</i> in Linux 3.19.\n<b>PERF_ATTR_SIZE_VER5</b> is 112 corresponding to the\naddition of <i>aux_watermark</i> in Linux 4.1.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><i>config</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">This specifies which event you\nwant, in conjunction with the <i>type</i> field. The\n<i>config1</i> and <i>config2</i> fields are also taken into\naccount in cases where 64 bits is not enough to fully\nspecify the event. The encoding of these fields are event\ndependent.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">There are\nvarious ways to set the <i>config</i> field that are\ndependent on the value of the previously described\n<i>type</i> field. What follows are various possible\nsettings for <i>config</i> separated out by <i>type</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>type</i>\nis <b>PERF_TYPE_HARDWARE</b>, we are measuring one of the\ngeneralized hardware CPU events. Not all of these are\navailable on all platforms. Set <i>config</i> to one of the\nfollowing:</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_CPU_CYCLES</b></p>\n\n<p style=\"margin-left:40%;\">Total cycles. Be wary of what\nhappens during CPU frequency scaling.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_INSTRUCTIONS</b></p>\n\n<p style=\"margin-left:40%;\">Retired instructions. Be\ncareful, these can be affected by various issues, most\nnotably hardware interrupt counts.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_CACHE_REFERENCES</b></p>\n\n<p style=\"margin-left:40%;\">Cache accesses. Usually this\nindicates Last Level Cache accesses but this may vary\ndepending on your CPU. This may include prefetches and\ncoherency messages; again this depends on the design of your\nCPU.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_CACHE_MISSES</b></p>\n\n<p style=\"margin-left:40%;\">Cache misses. Usually this\nindicates Last Level Cache misses; this is intended to be\nused in conjunction with the\n<b>PERF_COUNT_HW_CACHE_REFERENCES</b> event to calculate\ncache miss rates.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_BRANCH_INSTRUCTIONS</b></p>\n\n<p style=\"margin-left:40%;\">Retired branch instructions.\nPrior to Linux 2.6.35, this used the wrong event on AMD\nprocessors.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_BRANCH_MISSES</b></p>\n\n<p style=\"margin-left:40%;\">Mispredicted branch\ninstructions.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_BUS_CYCLES</b></p>\n\n<p style=\"margin-left:40%;\">Bus cycles, which can be\ndifferent from total cycles.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_STALLED_CYCLES_FRONTEND</b>\n(since Linux 3.0)</p>\n\n<p style=\"margin-left:40%;\">Stalled cycles during\nissue.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_STALLED_CYCLES_BACKEND</b>\n(since Linux 3.0)</p>\n\n<p style=\"margin-left:40%;\">Stalled cycles during\nretirement.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_HW_REF_CPU_CYCLES</b>\n(since Linux 3.3)</p>\n\n<p style=\"margin-left:40%;\">Total cycles; not affected by\nCPU frequency scaling.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>type</i>\nis <b>PERF_TYPE_SOFTWARE</b>, we are measuring software\nevents provided by the kernel. Set <i>config</i> to one of\nthe following:</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_CPU_CLOCK</b></p>\n\n<p style=\"margin-left:40%;\">This reports the CPU clock, a\nhigh-resolution per-CPU timer.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_TASK_CLOCK</b></p>\n\n<p style=\"margin-left:40%;\">This reports a clock count\nspecific to the task that is running.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_PAGE_FAULTS</b></p>\n\n<p style=\"margin-left:40%;\">This reports the number of page\nfaults.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_CONTEXT_SWITCHES</b></p>\n\n<p style=\"margin-left:40%;\">This counts context switches.\nUntil Linux 2.6.34, these were all reported as user-space\nevents, after that they are reported as happening in the\nkernel.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_CPU_MIGRATIONS</b></p>\n\n<p style=\"margin-left:40%;\">This reports the number of\ntimes the process has migrated to a new CPU.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_PAGE_FAULTS_MIN</b></p>\n\n<p style=\"margin-left:40%;\">This counts the number of minor\npage faults. These did not require disk I/O to handle.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_PAGE_FAULTS_MAJ</b></p>\n\n<p style=\"margin-left:40%;\">This counts the number of major\npage faults. These required disk I/O to handle.</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_ALIGNMENT_FAULTS</b>\n(since Linux 2.6.33)</p>\n\n<p style=\"margin-left:40%;\">This counts the number of\nalignment faults. These happen when unaligned memory\naccesses happen; the kernel can handle these but it reduces\nperformance. This happens only on some architectures (never\non x86).</p>\n\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_EMULATION_FAULTS</b>\n(since Linux 2.6.33)</p>\n\n<p style=\"margin-left:40%;\">This counts the number of\nemulation faults. The kernel sometimes traps on\nunimplemented instructions and emulates them for user space.\nThis can negatively impact performance.</p>\n\n<p style=\"margin-left:29%;\"><b>PERF_COUNT_SW_DUMMY</b>\n(since Linux 3.12)</p>\n\n<p style=\"margin-left:40%;\">This is a placeholder event\nthat counts nothing. Informational sample record types such\nas mmap or comm must be associated with an active event.\nThis dummy event allows gathering such records without\nrequiring a counting event.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>type</i>\nis <b>PERF_TYPE_TRACEPOINT</b>, then we are measuring kernel\ntracepoints. The value to use in <i>config</i> can be\nobtained from under debugfs <i>tracing/events/*/*/id</i> if\nftrace is enabled in the kernel.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>type</i>\nis <b>PERF_TYPE_HW_CACHE</b>, then we are measuring a\nhardware CPU cache event. To calculate the appropriate\n<i>config</i> value, use the following equation:</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">config =\n(perf_hw_cache_id) | <br>\n(perf_hw_cache_op_id &lt;&lt; 8) | <br>\n(perf_hw_cache_op_result_id &lt;&lt; 16);</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">where\n<i>perf_hw_cache_id</i> is one of:</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_L1D</b></p>\n\n<p style=\"margin-left:45%;\">for measuring Level 1 Data\nCache</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_L1I</b></p>\n\n<p style=\"margin-left:45%;\">for measuring Level 1\nInstruction Cache</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_LL</b></p>\n\n<p style=\"margin-left:45%;\">for measuring Last-Level\nCache</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_DTLB</b></p>\n\n<p style=\"margin-left:45%;\">for measuring the Data TLB</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_ITLB</b></p>\n\n<p style=\"margin-left:45%;\">for measuring the Instruction\nTLB</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_BPU</b></p>\n\n<p style=\"margin-left:45%;\">for measuring the branch\nprediction unit</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_NODE</b>\n(since Linux 3.1)</p>\n\n<p style=\"margin-left:45%;\">for measuring local memory\naccesses</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">and\n<i>perf_hw_cache_op_id</i> is one of:</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_OP_READ</b></p>\n\n<p style=\"margin-left:45%;\">for read accesses</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_OP_WRITE</b></p>\n\n<p style=\"margin-left:45%;\">for write accesses</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_OP_PREFETCH</b></p>\n\n<p style=\"margin-left:45%;\">for prefetch accesses</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">and\n<i>perf_hw_cache_op_result_id</i> is one of:</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_RESULT_ACCESS</b></p>\n\n<p style=\"margin-left:45%;\">to measure accesses</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_COUNT_HW_CACHE_RESULT_MISS</b></p>\n\n<p style=\"margin-left:45%;\">to measure misses</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>type</i>\nis <b>PERF_TYPE_RAW</b>, then a custom &quot;raw&quot;\n<i>config</i> value is needed. Most CPUs support events that\nare not covered by the &quot;generalized&quot; events. These\nare implementation defined; see your CPU manual (for example\nthe Intel Volume 3B documentation or the AMD BIOS and Kernel\nDeveloper Guide). The libpfm4 library can be used to\ntranslate from the name in the architectural manuals to the\nraw hex value <b>perf_event_open</b>() expects in this\nfield.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>type</i>\nis <b>PERF_TYPE_BREAKPOINT</b>, then leave <i>config</i> set\nto zero. Its parameters are set in other places.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>type</i>\nis <b>kprobe</b> or <b>uprobe</b>, set <i>retprobe</i> (bit\n0 of <i>config</i>, see\n<i>/sys/bus/event_source/devices/[k,u]probe/format/retprobe</i>)\nfor kretprobe/uretprobe. See fields <i>kprobe_func</i>,\n<i>uprobe_path</i>, <i>kprobe_addr</i>, and\n<i>probe_offset</i> for more details.</p>\n\n<p style=\"margin-left:11%;\"><i>kprobe_func</i>,\n<i>uprobe_path</i>, <i>kprobe_addr</i>, and\n<i>probe_offset</i></p>\n\n<p style=\"margin-left:22%;\">These fields describe the\nkprobe/uprobe for dynamic PMUs <b>kprobe</b> and\n<b>uprobe</b>. For <b>kprobe</b>: use <i>kprobe_func</i> and\n<i>probe_offset</i>, or use <i>kprobe_addr</i> and leave\n<i>kprobe_func</i> as NULL. For <b>uprobe</b>: use\n<i>uprobe_path</i> and <i>probe_offset</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>sample_period</i>,\n<i>sample_freq</i></p>\n\n<p style=\"margin-left:22%;\">A &quot;sampling&quot; event is\none that generates an overflow notification every N events,\nwhere N is given by <i>sample_period</i>. A sampling event\nhas <i>sample_period</i> &gt; 0. When an overflow occurs,\nrequested data is recorded in the mmap buffer. The\n<i>sample_type</i> field controls what data is recorded on\neach overflow.</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>sample_freq</i>\ncan be used if you wish to use frequency rather than period.\nIn this case, you set the <i>freq</i> flag. The kernel will\nadjust the sampling period to try and achieve the desired\nrate. The rate of adjustment is a timer tick.</p>\n\n<p style=\"margin-left:11%;\"><i>sample_type</i></p>\n\n<p style=\"margin-left:22%;\">The various bits in this field\nspecify which values to include in the sample. They will be\nrecorded in a ring-buffer, which is available to user space\nusing <a href=\"https://man.page/2/mmap\">mmap(2)</a>. The order in which the values are\nsaved in the sample are documented in the MMAP Layout\nsubsection below; it is not the <i>enum\nperf_event_sample_format</i> order. <b><br>\nPERF_SAMPLE_IP</b></p>\n\n<p style=\"margin-left:32%;\">Records instruction\npointer.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_TID</b></p>\n\n<p style=\"margin-left:32%;\">Records the process and thread\nIDs.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_TIME</b></p>\n\n<p style=\"margin-left:32%;\">Records a timestamp.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_ADDR</b></p>\n\n<p style=\"margin-left:32%;\">Records an address, if\napplicable.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_READ</b></p>\n\n<p style=\"margin-left:32%;\">Record counter values for all\nevents in a group, not just the group leader.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_CALLCHAIN</b></p>\n\n<p style=\"margin-left:32%;\">Records the callchain (stack\nbacktrace).</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_ID</b></p>\n\n<p style=\"margin-left:32%;\">Records a unique ID for the\nopened event&rsquo;s group leader.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_CPU</b></p>\n\n<p style=\"margin-left:32%;\">Records CPU number.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_PERIOD</b></p>\n\n<p style=\"margin-left:32%;\">Records the current sampling\nperiod.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_STREAM_ID</b></p>\n\n<p style=\"margin-left:32%;\">Records a unique ID for the\nopened event. Unlike <b>PERF_SAMPLE_ID</b> the actual ID is\nreturned, not the group leader. This ID is the same as the\none returned by <b>PERF_FORMAT_ID</b>.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_RAW</b></p>\n\n<p style=\"margin-left:32%;\">Records additional data, if\napplicable. Usually returned by tracepoint events.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_STACK</b>\n(since Linux 3.4)</p>\n\n<p style=\"margin-left:32%;\">This provides a record of\nrecent branches, as provided by CPU branch sampling hardware\n(such as Intel Last Branch Record). Not all hardware\nsupports this feature.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">See the\n<i>branch_sample_type</i> field for how to filter which\nbranches are reported.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_REGS_USER</b>\n(since Linux 3.7)</p>\n\n<p style=\"margin-left:32%;\">Records the current user-level\nCPU register state (the values in the process before the\nkernel was called).</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_STACK_USER</b>\n(since Linux 3.7)</p>\n\n<p style=\"margin-left:32%;\">Records the user level stack,\nallowing stack unwinding.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_WEIGHT</b>\n(since Linux 3.10)</p>\n\n<p style=\"margin-left:32%;\">Records a hardware provided\nweight value that expresses how costly the sampled event\nwas. This allows the hardware to highlight expensive events\nin a profile.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_DATA_SRC</b>\n(since Linux 3.10)</p>\n\n<p style=\"margin-left:32%;\">Records the data source: where\nin the memory hierarchy the data associated with the sampled\ninstruction came from. This is available only if the\nunderlying hardware supports this feature.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_IDENTIFIER</b>\n(since Linux 3.12)</p>\n\n<p style=\"margin-left:32%;\">Places the <b>SAMPLE_ID</b>\nvalue in a fixed position in the record, either at the\nbeginning (for sample events) or at the end (if a non-sample\nevent).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This was\nnecessary because a sample stream may have records from\nvarious different event sources with different\n<i>sample_type</i> settings. Parsing the event stream\nproperly was not possible because the format of the record\nwas needed to find <b>SAMPLE_ID</b>, but the format could\nnot be found without knowing what event the sample belonged\nto (causing a circular dependency).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<b>PERF_SAMPLE_IDENTIFIER</b> setting makes the event stream\nalways parsable by putting <b>SAMPLE_ID</b> in a fixed\nlocation, even though it means having duplicate\n<b>SAMPLE_ID</b> values in records.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_TRANSACTION</b>\n(since Linux 3.13)</p>\n\n<p style=\"margin-left:32%;\">Records reasons for\ntransactional memory abort events (for example, from Intel\nTSX transactional memory support).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>precise_ip</i> setting must be greater than 0 and a\ntransactional memory abort event must be measured or no\nvalues will be recorded. Also note that some perf_event\nmeasurements, such as sampled cycle counting, may cause\nextraneous aborts (by causing an interrupt during a\ntransaction).</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_REGS_INTR</b>\n(since Linux 3.19)</p>\n\n<p style=\"margin-left:32%;\">Records a subset of the current\nCPU register state as specified by <i>sample_regs_intr</i>.\nUnlike <b>PERF_SAMPLE_REGS_USER</b> the register values will\nreturn kernel register state if the overflow happened while\nkernel code is running. If the CPU supports hardware\nsampling of register state (i.e., PEBS on Intel x86) and\n<i>precise_ip</i> is set higher than zero then the register\nvalues returned are those captured by hardware at the time\nof the sampled instruction&rsquo;s retirement.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_PHYS_ADDR</b>\n(since Linux 4.13)</p>\n\n<p style=\"margin-left:32%;\">Records physical address of\ndata like in <b>PERF_SAMPLE_ADDR</b>.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_CGROUP</b>\n(since Linux 5.7)</p>\n\n<p style=\"margin-left:32%;\">Records (perf_event) cgroup ID\nof the process. This corresponds to the <i>id</i> field in\nthe <b>PERF_RECORD_CGROUP</b> event.</p>\n\n<p style=\"margin-left:11%;\"><i>read_format</i></p>\n\n<p style=\"margin-left:22%;\">This field specifies the format\nof the data returned by <a href=\"https://man.page/2/read\">read(2)</a> on a\n<b>perf_event_open</b>() file descriptor. <b><br>\nPERF_FORMAT_TOTAL_TIME_ENABLED</b></p>\n\n<p style=\"margin-left:32%;\">Adds the 64-bit\n<i>time_enabled</i> field. This can be used to calculate\nestimated totals if the PMU is overcommitted and\nmultiplexing is happening.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_FORMAT_TOTAL_TIME_RUNNING</b></p>\n\n<p style=\"margin-left:32%;\">Adds the 64-bit\n<i>time_running</i> field. This can be used to calculate\nestimated totals if the PMU is overcommitted and\nmultiplexing is happening.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_FORMAT_ID</b></p>\n\n<p style=\"margin-left:32%;\">Adds a 64-bit unique value that\ncorresponds to the event group.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_FORMAT_GROUP</b></p>\n\n<p style=\"margin-left:32%;\">Allows all counter values in an\nevent group to be read with one read.</p>\n\n<p style=\"margin-left:11%;\"><i>disabled</i></p>\n\n<p style=\"margin-left:22%;\">The <i>disabled</i> bit\nspecifies whether the counter starts out disabled or\nenabled. If disabled, the event can later be enabled by\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a>, <a href=\"https://man.page/2/prctl\">prctl(2)</a>, or\n<i>enable_on_exec</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">When creating\nan event group, typically the group leader is initialized\nwith <i>disabled</i> set to 1 and any child events are\ninitialized with <i>disabled</i> set to 0. Despite\n<i>disabled</i> being 0, the child events will not start\nuntil the group leader is enabled.</p>\n\n<p style=\"margin-left:11%;\"><i>inherit</i></p>\n\n<p style=\"margin-left:22%;\">The <i>inherit</i> bit\nspecifies that this counter should count events of child\ntasks as well as the task specified. This applies only to\nnew children, not to any existing children at the time the\ncounter is created (nor to any new children of existing\nchildren).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Inherit does\nnot work for some combinations of <i>read_format</i> values,\nsuch as <b>PERF_FORMAT_GROUP</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><i>pinned</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>pinned</i> bit specifies that the counter should\nalways be on the CPU if at all possible. It applies only to\nhardware counters and only to group leaders. If a pinned\ncounter cannot be put onto the CPU (e.g., because there are\nnot enough hardware counters or because of a conflict with\nsome other event), then the counter goes into an\n&rsquo;error&rsquo; state, where reads return end-of-file\n(i.e., <a href=\"https://man.page/2/read\">read(2)</a> returns 0) until the counter is\nsubsequently enabled or disabled.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>exclusive</i></p>\n\n<p style=\"margin-left:22%;\">The <i>exclusive</i> bit\nspecifies that when this counter&rsquo;s group is on the\nCPU, it should be the only group using the CPU&rsquo;s\ncounters. In the future this may allow monitoring programs\nto support PMU features that need to run alone so that they\ndo not disrupt other hardware counters.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note that many\nunexpected situations may prevent events with the\n<i>exclusive</i> bit set from ever running. This includes\nany users running a system-wide measurement as well as any\nkernel use of the performance counters (including the\ncommonly enabled NMI Watchdog Timer interface).</p>\n\n<p style=\"margin-left:11%;\"><i>exclude_user</i></p>\n\n<p style=\"margin-left:22%;\">If this bit is set, the count\nexcludes events that happen in user space.</p>\n\n<p style=\"margin-left:11%;\"><i>exclude_kernel</i></p>\n\n<p style=\"margin-left:22%;\">If this bit is set, the count\nexcludes events that happen in kernel space.</p>\n\n<p style=\"margin-left:11%;\"><i>exclude_hv</i></p>\n\n<p style=\"margin-left:22%;\">If this bit is set, the count\nexcludes events that happen in the hypervisor. This is\nmainly for PMUs that have built-in support for handling this\n(such as POWER). Extra support is needed for handling\nhypervisor measurements on most machines.</p>\n\n<p style=\"margin-left:11%;\"><i>exclude_idle</i></p>\n\n<p style=\"margin-left:22%;\">If set, don&rsquo;t count when\nthe CPU is running the idle task. While you can currently\nenable this for any event type, it is ignored for all but\nsoftware events.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>mmap</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>mmap</i> bit enables generation of\n<b>PERF_RECORD_MMAP</b> samples for every <a href=\"https://man.page/2/mmap\">mmap(2)</a>\ncall that has <b>PROT_EXEC</b> set. This allows tools to\nnotice new executable code being mapped into a program\n(dynamic shared libraries for example) so that addresses can\nbe mapped back to the original code.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>comm</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>comm</i> bit enables tracking of process command\nname as modified by the <a href=\"https://man.page/2/exec\">exec(2)</a> and\n<b>prctl</b>(PR_SET_NAME) system calls as well as writing to\n<i>/proc/self/comm</i>. If the <i>comm_exec</i> flag is also\nsuccessfully set (possible since Linux 3.16), then the misc\nflag <b>PERF_RECORD_MISC_COMM_EXEC</b> can be used to\ndifferentiate the <a href=\"https://man.page/2/exec\">exec(2)</a> case from the others.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>freq</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>If this bit is set, then <i>sample_frequency</i> not\n<i>sample_period</i> is used when setting up the sampling\ninterval.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>inherit_stat</i></p>\n\n<p style=\"margin-left:22%;\">This bit enables saving of\nevent counts on context switch for inherited tasks. This is\nmeaningful only if the <i>inherit</i> field is set.</p>\n\n<p style=\"margin-left:11%;\"><i>enable_on_exec</i></p>\n\n<p style=\"margin-left:22%;\">If this bit is set, a counter\nis automatically enabled after a call to <a href=\"https://man.page/2/exec\">exec(2)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>task</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>If this bit is set, then fork/exit notifications are\nincluded in the ring buffer.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>watermark</i></p>\n\n<p style=\"margin-left:22%;\">If set, have an overflow\nnotification happen when we cross the\n<i>wakeup_watermark</i> boundary. Otherwise, overflow\nnotifications happen after <i>wakeup_events</i> samples.</p>\n\n<p style=\"margin-left:11%;\"><i>precise_ip</i> (since Linux\n2.6.35)</p>\n\n<p style=\"margin-left:22%;\">This controls the amount of\nskid. Skid is how many instructions execute between an event\nof interest happening and the kernel being able to stop and\nrecord the event. Smaller skid is better and allows more\naccurate reporting of which events correspond to which\ninstructions, but hardware is often limited with how small\nthis can be.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The possible\nvalues of this field are the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>0</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>SAMPLE_IP</b> can have arbitrary skid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>1</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>SAMPLE_IP</b> must have constant skid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>2</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>SAMPLE_IP</b> requested to have 0 skid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>3</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>SAMPLE_IP</b> must have 0 skid. See also the\ndescription of <b>PERF_RECORD_MISC_EXACT_IP</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>mmap_data</i> (since Linux\n2.6.36)</p>\n\n<p style=\"margin-left:22%;\">This is the counterpart of the\n<i>mmap</i> field. This enables generation of\n<b>PERF_RECORD_MMAP</b> samples for <a href=\"https://man.page/2/mmap\">mmap(2)</a> calls\nthat do not have <b>PROT_EXEC</b> set (for example data and\nSysV shared memory).</p>\n\n<p style=\"margin-left:11%;\"><i>sample_id_all</i> (since\nLinux 2.6.38)</p>\n\n<p style=\"margin-left:22%;\">If set, then TID, TIME, ID,\nSTREAM_ID, and CPU can additionally be included in\nnon-<b>PERF_RECORD_SAMPLE</b>s if the corresponding\n<i>sample_type</i> is selected.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<b>PERF_SAMPLE_IDENTIFIER</b> is specified, then an\nadditional ID value is included as the last value to ease\nparsing the record stream. This may lead to the <i>id</i>\nvalue appearing twice.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The layout is\ndescribed by this pseudo-structure:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nsample_id { <br>\n{ u32 pid, tid; } /* if PERF_SAMPLE_TID set */ <br>\n{ u64 time; } /* if PERF_SAMPLE_TIME set */ <br>\n{ u64 id; } /* if PERF_SAMPLE_ID set */ <br>\n{ u64 stream_id;} /* if PERF_SAMPLE_STREAM_ID set */ <br>\n{ u32 cpu, res; } /* if PERF_SAMPLE_CPU set */ <br>\n{ u64 id; } /* if PERF_SAMPLE_IDENTIFIER set */ <br>\n};</p>\n\n<p style=\"margin-left:11%;\"><i>exclude_host</i> (since\nLinux 3.2)</p>\n\n<p style=\"margin-left:22%;\">When conducting measurements\nthat include processes running VM instances (i.e., have\nexecuted a <b>KVM_RUN ioctl</b>(2)), only measure events\nhappening inside a guest instance. This is only meaningful\noutside the guests; this setting does not change counts\ngathered inside of a guest. Currently, this functionality is\nx86 only.</p>\n\n<p style=\"margin-left:11%;\"><i>exclude_guest</i> (since\nLinux 3.2)</p>\n\n<p style=\"margin-left:22%;\">When conducting measurements\nthat include processes running VM instances (i.e., have\nexecuted a <b>KVM_RUN ioctl</b>(2)), do not measure events\nhappening inside guest instances. This is only meaningful\noutside the guests; this setting does not change counts\ngathered inside of a guest. Currently, this functionality is\nx86 only.</p>\n\n\n<p style=\"margin-left:11%;\"><i>exclude_callchain_kernel</i>\n(since Linux 3.7)</p>\n\n<p style=\"margin-left:22%;\">Do not include kernel\ncallchains.</p>\n\n<p style=\"margin-left:11%;\"><i>exclude_callchain_user</i>\n(since Linux 3.7)</p>\n\n<p style=\"margin-left:22%;\">Do not include user\ncallchains.</p>\n\n<p style=\"margin-left:11%;\"><i>mmap2</i> (since Linux\n3.16)</p>\n\n<p style=\"margin-left:22%;\">Generate an extended executable\nmmap record that contains enough additional information to\nuniquely identify shared mappings. The <i>mmap</i> flag must\nalso be set for this to work.</p>\n\n<p style=\"margin-left:11%;\"><i>comm_exec</i> (since Linux\n3.16)</p>\n\n<p style=\"margin-left:22%;\">This is purely a\nfeature-detection flag, it does not change kernel behavior.\nIf this flag can successfully be set, then, when <i>comm</i>\nis enabled, the <b>PERF_RECORD_MISC_COMM_EXEC</b> flag will\nbe set in the <i>misc</i> field of a comm record header if\nthe rename event being reported was caused by a call to\n<a href=\"https://man.page/2/exec\">exec(2)</a>. This allows tools to distinguish between the\nvarious types of process renaming.</p>\n\n<p style=\"margin-left:11%;\"><i>use_clockid</i> (since Linux\n4.1)</p>\n\n<p style=\"margin-left:22%;\">This allows selecting which\ninternal Linux clock to use when generating timestamps via\nthe <i>clockid</i> field. This can make it easier to\ncorrelate perf sample times with timestamps generated by\nother tools.</p>\n\n<p style=\"margin-left:11%;\"><i>context_switch</i> (since\nLinux 4.3)</p>\n\n<p style=\"margin-left:22%;\">This enables the generation of\n<b>PERF_RECORD_SWITCH</b> records when a context switch\noccurs. It also enables the generation of\n<b>PERF_RECORD_SWITCH_CPU_WIDE</b> records when sampling in\nCPU-wide mode. This functionality is in addition to existing\ntracepoint and software events for measuring context\nswitches. The advantage of this method is that it will give\nfull information even with strict <i>perf_event_paranoid</i>\nsettings.</p>\n\n<p style=\"margin-left:11%;\"><i>write_backward</i> (since\nLinux 4.6)</p>\n\n<p style=\"margin-left:22%;\">This causes the ring buffer to\nbe written from the end to the beginning. This is to support\nreading from overwritable ring buffer.</p>\n\n<p style=\"margin-left:11%;\"><i>namespaces</i> (since Linux\n4.11)</p>\n\n<p style=\"margin-left:22%;\">This enables the generation of\n<b>PERF_RECORD_NAMESPACES</b> records when a task enters a\nnew namespace. Each namespace has a combination of device\nand inode numbers.</p>\n\n<p style=\"margin-left:11%;\"><i>ksymbol</i> (since Linux\n5.0)</p>\n\n<p style=\"margin-left:22%;\">This enables the generation of\n<b>PERF_RECORD_KSYMBOL</b> records when new kernel symbols\nare registered or unregistered. This is analyzing dynamic\nkernel functions like eBPF.</p>\n\n<p style=\"margin-left:11%;\"><i>bpf_event</i> (since Linux\n5.0)</p>\n\n<p style=\"margin-left:22%;\">This enables the generation of\n<b>PERF_RECORD_BPF_EVENT</b> records when an eBPF program is\nloaded or unloaded.</p>\n\n<p style=\"margin-left:11%;\"><i>auxevent</i> (since Linux\n5.4)</p>\n\n<p style=\"margin-left:22%;\">This allows normal (non-AUX)\nevents to generate data for AUX events if the hardware\nsupports it.</p>\n\n<p style=\"margin-left:11%;\"><i>cgroup</i> (since Linux\n5.7)</p>\n\n<p style=\"margin-left:22%;\">This enables the generation of\n<b>PERF_RECORD_CGROUP</b> records when a new cgroup is\ncreated (and activated).</p>\n\n<p style=\"margin-left:11%;\"><i>text_poke</i> (since Linux\n5.8)</p>\n\n<p style=\"margin-left:22%;\">This enables the generation of\n<b>PERF_RECORD_TEXT_POKE</b> records when there&rsquo;s a\nchanges to the kernel text (i.e., self-modifying code).</p>\n\n<p style=\"margin-left:11%;\"><i>wakeup_events</i>,\n<i>wakeup_watermark</i></p>\n\n<p style=\"margin-left:22%;\">This union sets how many\nsamples (<i>wakeup_events</i>) or bytes\n(<i>wakeup_watermark</i>) happen before an overflow\nnotification happens. Which one is used is selected by the\n<i>watermark</i> bit flag.</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>wakeup_events</i>\ncounts only <b>PERF_RECORD_SAMPLE</b> record types. To\nreceive overflow notification for all <b>PERF_RECORD</b>\ntypes choose watermark and set <i>wakeup_watermark</i> to\n1.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Prior to Linux\n3.0, setting <i>wakeup_events</i> to 0 resulted in no\noverflow notifications; more recent kernels treat 0 the same\nas 1.</p>\n\n<p style=\"margin-left:11%;\"><i>bp_type</i> (since Linux\n2.6.33)</p>\n\n<p style=\"margin-left:22%;\">This chooses the breakpoint\ntype. It is one of: <b><br>\nHW_BREAKPOINT_EMPTY</b></p>\n\n<p style=\"margin-left:32%;\">No breakpoint.</p>\n\n<p style=\"margin-left:22%;\"><b>HW_BREAKPOINT_R</b></p>\n\n<p style=\"margin-left:32%;\">Count when we read the memory\nlocation.</p>\n\n<p style=\"margin-left:22%;\"><b>HW_BREAKPOINT_W</b></p>\n\n<p style=\"margin-left:32%;\">Count when we write the memory\nlocation.</p>\n\n<p style=\"margin-left:22%;\"><b>HW_BREAKPOINT_RW</b></p>\n\n<p style=\"margin-left:32%;\">Count when we read or write the\nmemory location.</p>\n\n<p style=\"margin-left:22%;\"><b>HW_BREAKPOINT_X</b></p>\n\n<p style=\"margin-left:32%;\">Count when we execute code at\nthe memory location.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The values can\nbe combined via a bitwise or, but the combination of\n<b>HW_BREAKPOINT_R</b> or <b>HW_BREAKPOINT_W</b> with\n<b>HW_BREAKPOINT_X</b> is not allowed.</p>\n\n<p style=\"margin-left:11%;\"><i>bp_addr</i> (since Linux\n2.6.33)</p>\n\n<p style=\"margin-left:22%;\">This is the address of the\nbreakpoint. For execution breakpoints, this is the memory\naddress of the instruction of interest; for read and write\nbreakpoints, it is the memory address of the memory location\nof interest.</p>\n\n<p style=\"margin-left:11%;\"><i>config1</i> (since Linux\n2.6.39)</p>\n\n<p style=\"margin-left:22%;\"><i>config1</i> is used for\nsetting events that need an extra register or otherwise do\nnot fit in the regular config field. Raw OFFCORE_EVENTS on\nNehalem/Westmere/SandyBridge use this field on Linux 3.3 and\nlater kernels.</p>\n\n<p style=\"margin-left:11%;\"><i>bp_len</i> (since Linux\n2.6.33)</p>\n\n<p style=\"margin-left:22%;\"><i>bp_len</i> is the length of\nthe breakpoint being measured if <i>type</i> is\n<b>PERF_TYPE_BREAKPOINT</b>. Options are\n<b>HW_BREAKPOINT_LEN_1</b>, <b>HW_BREAKPOINT_LEN_2</b>,\n<b>HW_BREAKPOINT_LEN_4</b>, and <b>HW_BREAKPOINT_LEN_8</b>.\nFor an execution breakpoint, set this to\n<i>sizeof(long)</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>config2</i> (since Linux\n2.6.39)</p>\n\n<p style=\"margin-left:22%;\"><i>config2</i> is a further\nextension of the <i>config1</i> field.</p>\n\n<p style=\"margin-left:11%;\"><i>branch_sample_type</i>\n(since Linux 3.4)</p>\n\n<p style=\"margin-left:22%;\">If\n<b>PERF_SAMPLE_BRANCH_STACK</b> is enabled, then this\nspecifies what branches to include in the branch record.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The first part\nof the value is the privilege level, which is a combination\nof one of the values listed below. If the user does not set\nprivilege level explicitly, the kernel will use the\nevent&rsquo;s privilege level. Event and branch privilege\nlevels do not have to match. <b><br>\nPERF_SAMPLE_BRANCH_USER</b></p>\n\n<p style=\"margin-left:32%;\">Branch target is in user\nspace.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_KERNEL</b></p>\n\n<p style=\"margin-left:32%;\">Branch target is in kernel\nspace.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_HV</b></p>\n\n<p style=\"margin-left:32%;\">Branch target is in\nhypervisor.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_PLM_ALL</b></p>\n\n<p style=\"margin-left:32%;\">A convenience value that is the\nthree preceding values ORed together.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In addition to\nthe privilege value, at least one or more of the following\nbits must be set. <b><br>\nPERF_SAMPLE_BRANCH_ANY</b></p>\n\n<p style=\"margin-left:32%;\">Any branch type.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_ANY_CALL</b></p>\n\n<p style=\"margin-left:32%;\">Any call branch (includes\ndirect calls, indirect calls, and far jumps).</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_IND_CALL</b></p>\n\n<p style=\"margin-left:32%;\">Indirect calls.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_CALL</b>\n(since Linux 4.4)</p>\n\n<p style=\"margin-left:32%;\">Direct calls.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_ANY_RETURN</b></p>\n\n<p style=\"margin-left:32%;\">Any return branch.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_IND_JUMP</b>\n(since Linux 4.2)</p>\n\n<p style=\"margin-left:32%;\">Indirect jumps.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_COND</b>\n(since Linux 3.16)</p>\n\n<p style=\"margin-left:32%;\">Conditional branches.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_ABORT_TX</b>\n(since Linux 3.11)</p>\n\n<p style=\"margin-left:32%;\">Transactional memory\naborts.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_IN_TX</b>\n(since Linux 3.11)</p>\n\n<p style=\"margin-left:32%;\">Branch in transactional memory\ntransaction.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_SAMPLE_BRANCH_NO_TX</b>\n(since Linux 3.11)</p>\n\n<p style=\"margin-left:32%;\">Branch not in transactional\nmemory transaction. <b>PERF_SAMPLE_BRANCH_CALL_STACK</b>\n(since Linux 4.1) Branch is part of a hardware-generated\ncall stack. This requires hardware support, currently only\nfound on Intel x86 Haswell or newer.</p>\n\n<p style=\"margin-left:11%;\"><i>sample_regs_user</i> (since\nLinux 3.7)</p>\n\n<p style=\"margin-left:22%;\">This bit mask defines the set\nof user CPU registers to dump on samples. The layout of the\nregister mask is architecture-specific and is described in\nthe kernel header file\n<i>arch/ARCH/include/uapi/asm/perf_regs.h</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>sample_stack_user</i> (since\nLinux 3.7)</p>\n\n<p style=\"margin-left:22%;\">This defines the size of the\nuser stack to dump if <b>PERF_SAMPLE_STACK_USER</b> is\nspecified.</p>\n\n<p style=\"margin-left:11%;\"><i>clockid</i> (since Linux\n4.1)</p>\n\n<p style=\"margin-left:22%;\">If <i>use_clockid</i> is set,\nthen this field selects which internal Linux timer to use\nfor timestamps. The available timers are defined in\n<i>linux/time.h</i>, with <b>CLOCK_MONOTONIC</b>,\n<b>CLOCK_MONOTONIC_RAW</b>, <b>CLOCK_REALTIME</b>,\n<b>CLOCK_BOOTTIME</b>, and <b>CLOCK_TAI</b> currently\nsupported.</p>\n\n<p style=\"margin-left:11%;\"><i>aux_watermark</i> (since\nLinux 4.1)</p>\n\n<p style=\"margin-left:22%;\">This specifies how much data is\nrequired to trigger a <b>PERF_RECORD_AUX</b> sample.</p>\n\n<p style=\"margin-left:11%;\"><i>sample_max_stack</i> (since\nLinux 4.8)</p>\n\n<p style=\"margin-left:22%;\">When <i>sample_type</i>\nincludes <b>PERF_SAMPLE_CALLCHAIN</b>, this field specifies\nhow many stack frames to report when generating the\ncallchain.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading\nresults</b> <br>\nOnce a <b>perf_event_open</b>() file descriptor has been\nopened, the values of the events can be read from the file\ndescriptor. The values that are there are specified by the\n<i>read_format</i> field in the <i>attr</i> structure at\nopen time.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you attempt\nto read into a buffer that is not big enough to hold the\ndata, the error <b>ENOSPC</b> results.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is the\nlayout of the data returned by a read:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>If <b>PERF_FORMAT_GROUP</b> was specified to allow\nreading all events in a group at once:</p></td></tr>\n</table>\n\n<p style=\"margin-left:20%; margin-top: 1em\">struct\nread_format { <br>\nu64 nr; /* The number of events */ <br>\nu64 time_enabled; /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n<br>\nu64 time_running; /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n<br>\nstruct { <br>\nu64 value; /* The value of the event */ <br>\nu64 id; /* if PERF_FORMAT_ID */ <br>\n} values[nr]; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p style=\"margin-top: 1em\">If <b>PERF_FORMAT_GROUP</b> was\n<i>not</i> specified:</p></td>\n<td width=\"26%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:20%; margin-top: 1em\">struct\nread_format { <br>\nu64 value; /* The value of the event */ <br>\nu64 time_enabled; /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n<br>\nu64 time_running; /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n<br>\nu64 id; /* if PERF_FORMAT_ID */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The values read\nare as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\"><i>nr</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The number of events in this\nfile descriptor. Available only if <b>PERF_FORMAT_GROUP</b>\nwas specified.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>time_enabled</i>,\n<i>time_running</i></p>\n\n<p style=\"margin-left:22%;\">Total time the event was\nenabled and running. Normally these values are the same.\nMultiplexing happens if the number of events is more than\nthe number of available PMU counter slots. In that case the\nevents run only part of the time and the <i>time_enabled</i>\nand <i>time running</i> values can be used to scale an\nestimated value for the count.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>value</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>An unsigned 64-bit value containing the counter\nresult.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>id</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>A globally unique value for this particular event; only\npresent if <b>PERF_FORMAT_ID</b> was specified in\n<i>read_format</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>MMAP\nlayout</b> <br>\nWhen using <b>perf_event_open</b>() in sampled mode,\nasynchronous events (like counter overflow or\n<b>PROT_EXEC</b> mmap tracking) are logged into a\nring-buffer. This ring-buffer is created and accessed\nthrough <a href=\"https://man.page/2/mmap\">mmap(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The mmap size\nshould be 1+2^n pages, where the first page is a metadata\npage (<i>struct perf_event_mmap_page</i>) that contains\nvarious bits of information such as where the ring-buffer\nhead is.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before kernel\n2.6.39, there is a bug that means you must allocate an mmap\nring buffer when sampling even if you do not plan to access\nit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The structure\nof the first metadata mmap page is as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nperf_event_mmap_page { <br>\n__u32 version; /* version number of this structure */ <br>\n__u32 compat_version; /* lowest version this is compat with\n*/ <br>\n__u32 lock; /* seqlock for synchronization */ <br>\n__u32 index; /* hardware counter identifier */ <br>\n__s64 offset; /* add to hardware counter value */ <br>\n__u64 time_enabled; /* time event active */ <br>\n__u64 time_running; /* time event on CPU */ <br>\nunion { <br>\n__u64 capabilities; <br>\nstruct { <br>\n__u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1, <br>\ncap_bit0_is_deprecated : 1, <br>\ncap_user_rdpmc : 1, <br>\ncap_user_time : 1, <br>\ncap_user_time_zero : 1, <br>\n}; <br>\n}; <br>\n__u16 pmc_width; <br>\n__u16 time_shift; <br>\n__u32 time_mult; <br>\n__u64 time_offset; <br>\n__u64 __reserved[120]; /* Pad to 1 k */ <br>\n__u64 data_head; /* head in the data section */ <br>\n__u64 data_tail; /* user-space written tail */ <br>\n__u64 data_offset; /* where the buffer starts */ <br>\n__u64 data_size; /* data buffer size */ <br>\n__u64 aux_head; <br>\n__u64 aux_tail; <br>\n__u64 aux_offset; <br>\n__u64 aux_size;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nlist describes the fields in the <i>perf_event_mmap_page</i>\nstructure in more detail: <i><br>\nversion</i></p>\n\n<p style=\"margin-left:22%;\">Version number of this\nstructure.</p>\n\n<p style=\"margin-left:11%;\"><i>compat_version</i></p>\n\n<p style=\"margin-left:22%;\">The lowest version this is\ncompatible with.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><i>lock</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A seqlock for synchronization.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><i>index</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A unique hardware counter identifier.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><i>offset</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>When using rdpmc for reads this offset value must be\nadded to the one returned by rdpmc to get the current total\nevent count.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>time_enabled</i></p>\n\n<p style=\"margin-left:22%;\">Time the event was active.</p>\n\n<p style=\"margin-left:11%;\"><i>time_running</i></p>\n\n<p style=\"margin-left:22%;\">Time the event was running.</p>\n\n<p style=\"margin-left:11%;\"><i>cap_usr_time</i> /\n<i>cap_usr_rdpmc</i> / <i>cap_bit0</i> (since Linux 3.4)</p>\n\n<p style=\"margin-left:22%;\">There was a bug in the\ndefinition of <i>cap_usr_time</i> and <i>cap_usr_rdpmc</i>\nfrom Linux 3.4 until Linux 3.11. Both bits were defined to\npoint to the same location, so it was impossible to know if\n<i>cap_usr_time</i> or <i>cap_usr_rdpmc</i> were actually\nset.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Starting with\nLinux 3.12, these are renamed to <i>cap_bit0</i> and you\nshould use the <i>cap_user_time</i> and\n<i>cap_user_rdpmc</i> fields instead.</p>\n\n<p style=\"margin-left:11%;\"><i>cap_bit0_is_deprecated</i>\n(since Linux 3.12)</p>\n\n<p style=\"margin-left:22%;\">If set, this bit indicates that\nthe kernel supports the properly separated\n<i>cap_user_time</i> and <i>cap_user_rdpmc</i> bits.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If not-set, it\nindicates an older kernel where <i>cap_usr_time</i> and\n<i>cap_usr_rdpmc</i> map to the same bit and thus both\nfeatures should be used with caution.</p>\n\n<p style=\"margin-left:11%;\"><i>cap_user_rdpmc</i> (since\nLinux 3.12)</p>\n\n<p style=\"margin-left:22%;\">If the hardware supports\nuser-space read of performance counters without syscall\n(this is the &quot;rdpmc&quot; instruction on x86), then the\nfollowing code can be used to do a read:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">u32 seq,\ntime_mult, time_shift, idx, width; <br>\nu64 count, enabled, running; <br>\nu64 cyc, time_offset;</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">do { <br>\nseq = pc-&gt;lock; <br>\nbarrier(); <br>\nenabled = pc-&gt;time_enabled; <br>\nrunning = pc-&gt;time_running;</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">if\n(pc-&gt;cap_usr_time &amp;&amp; enabled != running) { <br>\ncyc = rdtsc(); <br>\ntime_offset = pc-&gt;time_offset; <br>\ntime_mult = pc-&gt;time_mult; <br>\ntime_shift = pc-&gt;time_shift; <br>\n}</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">idx =\npc-&gt;index; <br>\ncount = pc-&gt;offset;</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">if\n(pc-&gt;cap_usr_rdpmc &amp;&amp; idx) { <br>\nwidth = pc-&gt;pmc_width; <br>\ncount += rdpmc(idx - 1); <br>\n}</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">barrier(); <br>\n} while (pc-&gt;lock != seq);</p>\n\n<p style=\"margin-left:11%;\"><i>cap_user_time</i> (since\nLinux 3.12)</p>\n\n<p style=\"margin-left:22%;\">This bit indicates the hardware\nhas a constant, nonstop timestamp counter (TSC on x86).</p>\n\n<p style=\"margin-left:11%;\"><i>cap_user_time_zero</i>\n(since Linux 3.12)</p>\n\n<p style=\"margin-left:22%;\">Indicates the presence of\n<i>time_zero</i> which allows mapping timestamp values to\nthe hardware clock.</p>\n\n<p style=\"margin-left:11%;\"><i>pmc_width</i></p>\n\n<p style=\"margin-left:22%;\">If <i>cap_usr_rdpmc</i>, this\nfield provides the bit-width of the value read using the\nrdpmc or equivalent instruction. This can be used to sign\nextend the result like:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">pmc &lt;&lt;=\n64 - pmc_width; <br>\npmc &gt;&gt;= 64 - pmc_width; // signed shift right <br>\ncount += pmc;</p>\n\n<p style=\"margin-left:11%;\"><i>time_shift</i>,\n<i>time_mult</i>, <i>time_offset</i></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>cap_usr_time</i>, these fields can be used to compute the\ntime delta since <i>time_enabled</i> (in nanoseconds) using\nrdtsc or similar.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">u64 quot, rem;\n<br>\nu64 delta;</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">quot = cyc\n&gt;&gt; time_shift; <br>\nrem = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1); <br>\ndelta = time_offset + quot * time_mult + <br>\n((rem * time_mult) &gt;&gt; time_shift);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Where\n<i>time_offset</i>, <i>time_mult</i>, <i>time_shift</i>, and\n<i>cyc</i> are read in the seqcount loop described above.\nThis delta can then be added to enabled and possible running\n(if idx), improving the scaling:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">enabled +=\ndelta; <br>\nif (idx) <br>\nrunning += delta; <br>\nquot = count / running; <br>\nrem = count % running; <br>\ncount = quot * enabled + (rem * enabled) / running;</p>\n\n<p style=\"margin-left:11%;\"><i>time_zero</i> (since Linux\n3.12)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>cap_usr_time_zero</i> is set, then the hardware clock\n(the TSC timestamp counter on x86) can be calculated from\nthe <i>time_zero</i>, <i>time_mult</i>, and\n<i>time_shift</i> values:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">time =\ntimestamp - time_zero; <br>\nquot = time / time_mult; <br>\nrem = time % time_mult; <br>\ncyc = (quot &lt;&lt; time_shift) + (rem &lt;&lt; time_shift)\n/ time_mult;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">And vice\nversa:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">quot = cyc\n&gt;&gt; time_shift; <br>\nrem = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1); <br>\ntimestamp = time_zero + quot * time_mult + <br>\n((rem * time_mult) &gt;&gt; time_shift);</p>\n\n<p style=\"margin-left:11%;\"><i>data_head</i></p>\n\n<p style=\"margin-left:22%;\">This points to the head of the\ndata section. The value continuously increases, it does not\nwrap. The value needs to be manually wrapped by the size of\nthe mmap buffer before accessing the samples.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">On SMP-capable\nplatforms, after reading the <i>data_head</i> value, user\nspace should issue an rmb().</p>\n\n<p style=\"margin-left:11%;\"><i>data_tail</i></p>\n\n<p style=\"margin-left:22%;\">When the mapping is\n<b>PROT_WRITE</b>, the <i>data_tail</i> value should be\nwritten by user space to reflect the last read data. In this\ncase, the kernel will not overwrite unread data.</p>\n\n<p style=\"margin-left:11%;\"><i>data_offset</i> (since Linux\n4.1)</p>\n\n<p style=\"margin-left:22%;\">Contains the offset of the\nlocation in the mmap buffer where perf sample data\nbegins.</p>\n\n<p style=\"margin-left:11%;\"><i>data_size</i> (since Linux\n4.1)</p>\n\n<p style=\"margin-left:22%;\">Contains the size of the perf\nsample region within the mmap buffer.</p>\n\n<p style=\"margin-left:11%;\"><i>aux_head</i>,\n<i>aux_tail</i>, <i>aux_offset</i>, <i>aux_size</i> (since\nLinux 4.1)</p>\n\n<p style=\"margin-left:22%;\">The AUX region allows\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>-ing a separate sample buffer for\nhigh-bandwidth data streams (separate from the main perf\nsample buffer). An example of a high-bandwidth stream is\ninstruction tracing support, as is found in newer Intel\nprocessors.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">To set up an\nAUX area, first <i>aux_offset</i> needs to be set with an\noffset greater than <i>data_offset</i>+<i>data_size</i> and\n<i>aux_size</i> needs to be set to the desired buffer size.\nThe desired offset and size must be page aligned, and the\nsize must be a power of two. These values are then passed to\nmmap in order to map the AUX buffer. Pages in the AUX buffer\nare included as part of the <b>RLIMIT_MEMLOCK</b> resource\nlimit (see <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>), and also as part of the\n<i>perf_event_mlock_kb</i> allowance.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">By default, the\nAUX buffer will be truncated if it will not fit in the\navailable space in the ring buffer. If the AUX buffer is\nmapped as a read only buffer, then it will operate in ring\nbuffer mode where old data will be overwritten by new. In\noverwrite mode, it might not be possible to infer where the\nnew data began, and it is the consumer&rsquo;s job to\ndisable measurement while reading to avoid possible data\nraces.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>aux_head</i> and <i>aux_tail</i> ring buffer pointers\nhave the same behavior and ordering rules as the previous\ndescribed <i>data_head</i> and <i>data_tail</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\n2^n ring-buffer pages have the layout described below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>perf_event_attr.sample_id_all</i> is set, then all event\ntypes will have the sample_type selected fields related to\nwhere/when (identity) an event took place (TID, TIME, ID,\nCPU, STREAM_ID) described in <b>PERF_RECORD_SAMPLE</b>\nbelow, it will be stashed just after the\n<i>perf_event_header</i> and the fields already present for\nthe existing fields, that is, at the end of the payload.\nThis allows a newer perf.data file to be supported by older\nperf tools, with the new optional fields being ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The mmap values\nstart with a header:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nperf_event_header { <br>\n__u32 type; <br>\n__u16 misc; <br>\n__u16 size; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Below, we\ndescribe the <i>perf_event_header</i> fields in more detail.\nFor ease of reading, the fields with shorter descriptions\nare presented first.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>size</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This indicates the size of the record.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>misc</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>misc</i> field contains additional information\nabout the sample.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The CPU mode\ncan be determined from this value by masking with\n<b>PERF_RECORD_MISC_CPUMODE_MASK</b> and looking for one of\nthe following (note these are not bit masks, only one can be\nset at a time): <b><br>\nPERF_RECORD_MISC_CPUMODE_UNKNOWN</b></p>\n\n<p style=\"margin-left:32%;\">Unknown CPU mode.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_KERNEL</b></p>\n\n<p style=\"margin-left:32%;\">Sample happened in the\nkernel.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_USER</b></p>\n\n<p style=\"margin-left:32%;\">Sample happened in user\ncode.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_HYPERVISOR</b></p>\n\n<p style=\"margin-left:32%;\">Sample happened in the\nhypervisor.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_GUEST_KERNEL</b>\n(since Linux 2.6.35)</p>\n\n<p style=\"margin-left:32%;\">Sample happened in the guest\nkernel.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_GUEST_USER\n(since Linux 2.6.35)</b></p>\n\n<p style=\"margin-left:32%;\">Sample happened in guest user\ncode.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since the\nfollowing three statuses are generated by different record\ntypes, they alias to the same bit: <b><br>\nPERF_RECORD_MISC_MMAP_DATA</b> (since Linux 3.10)</p>\n\n<p style=\"margin-left:32%;\">This is set when the mapping is\nnot executable; otherwise the mapping is executable.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_COMM_EXEC</b>\n(since Linux 3.16)</p>\n\n<p style=\"margin-left:32%;\">This is set for a\n<b>PERF_RECORD_COMM</b> record on kernels more recent than\nLinux 3.16 if a process name change was caused by an\n<a href=\"https://man.page/2/exec\">exec(2)</a> system call.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_SWITCH_OUT</b>\n(since Linux 4.3)</p>\n\n<p style=\"margin-left:32%;\">When a\n<b>PERF_RECORD_SWITCH</b> or\n<b>PERF_RECORD_SWITCH_CPU_WIDE</b> record is generated, this\nbit indicates that the context switch is away from the\ncurrent process (instead of into the current process).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In addition,\nthe following bits can be set: <b><br>\nPERF_RECORD_MISC_EXACT_IP</b></p>\n\n<p style=\"margin-left:32%;\">This indicates that the content\nof <b>PERF_SAMPLE_IP</b> points to the actual instruction\nthat triggered the event. See also\n<i>perf_event_attr.precise_ip</i>.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_EXT_RESERVED</b>\n(since Linux 2.6.35)</p>\n\n<p style=\"margin-left:32%;\">This indicates there is\nextended data available (currently not used).</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT</b></p>\n\n<p style=\"margin-left:32%;\">This bit is not set by the\nkernel. It is reserved for the user-space perf utility to\nindicate that <i>/proc/i[pid]/maps</i> parsing was taking\ntoo long and was stopped, and thus the mmap records may be\ntruncated.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>type</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>type</i> value is one of the below. The values in\nthe corresponding record (that follows the header) depend on\nthe <i>type</i> selected as shown.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MMAP</b></p>\n\n<p style=\"margin-left:28%;\">The MMAP events record the\n<b>PROT_EXEC</b> mappings so that we can correlate\nuser-space IPs to code. They have the following\nstructure:</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid, tid; <br>\nu64 addr; <br>\nu64 len; <br>\nu64 pgoff; <br>\nchar filename[]; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>pid</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the process ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>tid</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the thread ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>addr</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the address of the allocated memory. <i>len</i> is\nthe length of the allocated memory. <i>pgoff</i> is the page\noffset of the allocated memory. <i>filename</i> is a string\ndescribing the backing of the allocated memory.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_LOST</b></p>\n\n<p style=\"margin-left:28%;\">This record indicates when\nevents are lost.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 id; <br>\nu64 lost; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>id</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the unique event ID for the samples that were\nlost.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>lost</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the number of events that were lost.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_COMM</b></p>\n\n<p style=\"margin-left:28%;\">This record indicates a change\nin the process name.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid; <br>\nu32 tid; <br>\nchar comm[]; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>pid</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the process ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>tid</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the thread ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>comm</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is a string containing the new name of the process.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_EXIT</b></p>\n\n<p style=\"margin-left:28%;\">This record indicates a process\nexit event.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid, ppid; <br>\nu32 tid, ptid; <br>\nu64 time; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_THROTTLE</b>,\n<b>PERF_RECORD_UNTHROTTLE</b></p>\n\n<p style=\"margin-left:28%;\">This record indicates a\nthrottle/unthrottle event.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 time; <br>\nu64 id; <br>\nu64 stream_id; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_FORK</b></p>\n\n<p style=\"margin-left:28%;\">This record indicates a fork\nevent.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid, ppid; <br>\nu32 tid, ptid; <br>\nu64 time; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_READ</b></p>\n\n<p style=\"margin-left:28%;\">This record indicates a read\nevent.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid, tid; <br>\nstruct read_format values; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_SAMPLE</b></p>\n\n<p style=\"margin-left:28%;\">This record indicates a\nsample.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 sample_id; /* if PERF_SAMPLE_IDENTIFIER */ <br>\nu64 ip; /* if PERF_SAMPLE_IP */ <br>\nu32 pid, tid; /* if PERF_SAMPLE_TID */ <br>\nu64 time; /* if PERF_SAMPLE_TIME */ <br>\nu64 addr; /* if PERF_SAMPLE_ADDR */ <br>\nu64 id; /* if PERF_SAMPLE_ID */ <br>\nu64 stream_id; /* if PERF_SAMPLE_STREAM_ID */ <br>\nu32 cpu, res; /* if PERF_SAMPLE_CPU */ <br>\nu64 period; /* if PERF_SAMPLE_PERIOD */ <br>\nstruct read_format v; <br>\n/* if PERF_SAMPLE_READ */ <br>\nu64 nr; /* if PERF_SAMPLE_CALLCHAIN */ <br>\nu64 ips[nr]; /* if PERF_SAMPLE_CALLCHAIN */ <br>\nu32 size; /* if PERF_SAMPLE_RAW */ <br>\nchar data[size]; /* if PERF_SAMPLE_RAW */ <br>\nu64 bnr; /* if PERF_SAMPLE_BRANCH_STACK */ <br>\nstruct perf_branch_entry lbr[bnr]; <br>\n/* if PERF_SAMPLE_BRANCH_STACK */ <br>\nu64 abi; /* if PERF_SAMPLE_REGS_USER */ <br>\nu64 regs[weight(mask)]; <br>\n/* if PERF_SAMPLE_REGS_USER */ <br>\nu64 size; /* if PERF_SAMPLE_STACK_USER */ <br>\nchar data[size]; /* if PERF_SAMPLE_STACK_USER */ <br>\nu64 dyn_size; /* if PERF_SAMPLE_STACK_USER &amp;&amp; <br>\nsize != 0 */ <br>\nu64 weight; /* if PERF_SAMPLE_WEIGHT */ <br>\nu64 data_src; /* if PERF_SAMPLE_DATA_SRC */ <br>\nu64 transaction; /* if PERF_SAMPLE_TRANSACTION */ <br>\nu64 abi; /* if PERF_SAMPLE_REGS_INTR */ <br>\nu64 regs[weight(mask)]; <br>\n/* if PERF_SAMPLE_REGS_INTR */ <br>\nu64 phys_addr; /* if PERF_SAMPLE_PHYS_ADDR */ <br>\nu64 cgroup; /* if PERF_SAMPLE_CGROUP */ <br>\n};</p>\n\n<p style=\"margin-left:28%;\"><i>sample_id</i></p>\n\n<p style=\"margin-left:34%;\">If\n<b>PERF_SAMPLE_IDENTIFIER</b> is enabled, a 64-bit unique ID\nis included. This is a duplication of the\n<b>PERF_SAMPLE_ID</b> <i>id</i> value, but included at the\nbeginning of the sample so parsers can easily obtain the\nvalue.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"3%\">\n\n\n<p><i>ip</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"66%\">\n\n\n<p>If <b>PERF_SAMPLE_IP</b> is enabled, then a 64-bit\ninstruction pointer value is included.</p></td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>pid</i>, <i>tid</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_TID</b> is\nenabled, then a 32-bit process ID and 32-bit thread ID are\nincluded.</p>\n\n<p style=\"margin-left:28%;\"><i>time</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_TIME</b> is\nenabled, then a 64-bit timestamp is included. This is\nobtained via local_clock() which is a hardware timestamp if\navailable and the jiffies value if not.</p>\n\n<p style=\"margin-left:28%;\"><i>addr</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_ADDR</b> is\nenabled, then a 64-bit address is included. This is usually\nthe address of a tracepoint, breakpoint, or software event;\notherwise the value is 0.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"3%\">\n\n\n<p><i>id</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"66%\">\n\n\n<p>If <b>PERF_SAMPLE_ID</b> is enabled, a 64-bit unique ID\nis included. If the event is a member of an event group, the\ngroup leader ID is returned. This ID is the same as the one\nreturned by <b>PERF_FORMAT_ID</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>stream_id</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_STREAM_ID</b>\nis enabled, a 64-bit unique ID is included. Unlike\n<b>PERF_SAMPLE_ID</b> the actual ID is returned, not the\ngroup leader. This ID is the same as the one returned by\n<b>PERF_FORMAT_ID</b>.</p>\n\n<p style=\"margin-left:28%;\"><i>cpu</i>, <i>res</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_CPU</b> is\nenabled, this is a 32-bit value indicating which CPU was\nbeing used, in addition to a reserved (unused) 32-bit\nvalue.</p>\n\n<p style=\"margin-left:28%;\"><i>period</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_PERIOD</b> is\nenabled, a 64-bit value indicating the current sampling\nperiod is written.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"1%\">\n\n\n<p><i>v</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"66%\">\n\n\n<p>If <b>PERF_SAMPLE_READ</b> is enabled, a structure of\ntype read_format is included which has values for all events\nin the event group. The values included depend on the\n<i>read_format</i> value used at <b>perf_event_open</b>()\ntime.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>nr</i>, <i>ips[nr]</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_CALLCHAIN</b>\nis enabled, then a 64-bit number is included which indicates\nhow many following 64-bit instruction pointers will follow.\nThis is the current callchain.</p>\n\n<p style=\"margin-left:28%;\"><i>size</i>,\n<i>data[size]</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_RAW</b> is\nenabled, then a 32-bit value indicating size is included\nfollowed by an array of 8-bit values of length size. The\nvalues are padded with 0 to have 64-bit alignment.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">This RAW record\ndata is opaque with respect to the ABI. The ABI\ndoesn&rsquo;t make any promises with respect to the\nstability of its content, it may vary depending on event,\nhardware, and kernel version.</p>\n\n<p style=\"margin-left:28%;\"><i>bnr</i>, <i>lbr[bnr]</i></p>\n\n<p style=\"margin-left:34%;\">If\n<b>PERF_SAMPLE_BRANCH_STACK</b> is enabled, then a 64-bit\nvalue indicating the number of records is included, followed\nby <i>bnr perf_branch_entry</i> structures which each\ninclude the fields:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"34%\"></td>\n<td width=\"6%\">\n\n\n<p><i>from</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"55%\">\n\n\n<p>This indicates the source instruction (may not be a\nbranch).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"34%\"></td>\n<td width=\"6%\">\n\n\n<p><i>to</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"55%\">\n\n\n<p>The branch target.</p></td></tr>\n</table>\n\n<p style=\"margin-left:34%;\"><i>mispred</i></p>\n\n<p style=\"margin-left:45%;\">The branch target was\nmispredicted.</p>\n\n<p style=\"margin-left:34%;\"><i>predicted</i></p>\n\n<p style=\"margin-left:45%;\">The branch target was\npredicted.</p>\n\n<p style=\"margin-left:34%;\"><i>in_tx</i> (since Linux\n3.11)</p>\n\n<p style=\"margin-left:45%;\">The branch was in a\ntransactional memory transaction.</p>\n\n<p style=\"margin-left:34%;\"><i>abort</i> (since Linux\n3.11)</p>\n\n<p style=\"margin-left:45%;\">The branch was in an aborted\ntransactional memory transaction.</p>\n\n<p style=\"margin-left:34%;\"><i>cycles</i> (since Linux\n4.3)</p>\n\n<p style=\"margin-left:45%;\">This reports the number of\ncycles elapsed since the previous branch stack update.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">The entries are\nfrom most to least recent, so the first entry has the most\nrecent branch.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">Support for\n<i>mispred</i>, <i>predicted</i>, and <i>cycles</i> is\noptional; if not supported, those values will be 0.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">The type of\nbranches recorded is specified by the\n<i>branch_sample_type</i> field.</p>\n\n<p style=\"margin-left:28%;\"><i>abi</i>,\n<i>regs[weight(mask)]</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_REGS_USER</b>\nis enabled, then the user CPU registers are recorded.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">The <i>abi</i>\nfield is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,\n<b>PERF_SAMPLE_REGS_ABI_32</b>, or\n<b>PERF_SAMPLE_REGS_ABI_64</b>.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">The <i>regs</i>\nfield is an array of the CPU registers that were specified\nby the <i>sample_regs_user</i> attr field. The number of\nvalues is the number of bits set in the\n<i>sample_regs_user</i> bit mask.</p>\n\n<p style=\"margin-left:28%;\"><i>size</i>, <i>data[size]</i>,\n<i>dyn_size</i></p>\n\n<p style=\"margin-left:34%;\">If\n<b>PERF_SAMPLE_STACK_USER</b> is enabled, then the user\nstack is recorded. This can be used to generate stack\nbacktraces. <i>size</i> is the size requested by the user in\n<i>sample_stack_user</i> or else the maximum record size.\n<i>data</i> is the stack data (a raw dump of the memory\npointed to by the stack pointer at the time of sampling).\n<i>dyn_size</i> is the amount of data actually dumped (can\nbe less than <i>size</i>). Note that <i>dyn_size</i> is\nomitted if <i>size</i> is 0.</p>\n\n<p style=\"margin-left:28%;\"><i>weight</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_WEIGHT</b> is\nenabled, then a 64-bit value provided by the hardware is\nrecorded that indicates how costly the event was. This\nallows expensive events to stand out more clearly in\nprofiles.</p>\n\n<p style=\"margin-left:28%;\"><i>data_src</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_DATA_SRC</b>\nis enabled, then a 64-bit value is recorded that is made up\nof the following fields: <i><br>\nmem_op</i></p>\n\n<p style=\"margin-left:40%;\">Type of opcode, a bitwise\ncombination of:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"28%\">\n\n\n<p><b>PERF_MEM_OP_NA</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"23%\">\n\n\n<p>Not available</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"28%\">\n\n\n<p><b>PERF_MEM_OP_LOAD</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"23%\">\n\n\n<p>Load instruction</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"28%\">\n\n\n<p><b>PERF_MEM_OP_STORE</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"23%\">\n\n\n<p>Store instruction</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"28%\">\n\n\n<p><b>PERF_MEM_OP_PFETCH</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"23%\">\n\n\n<p>Prefetch</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"28%\">\n\n\n<p><b>PERF_MEM_OP_EXEC</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"23%\">\n\n\n<p>Executable code</p></td></tr>\n</table>\n\n<p style=\"margin-left:34%;\"><i>mem_lvl</i></p>\n\n<p style=\"margin-left:40%;\">Memory hierarchy level hit or\nmiss, a bitwise combination of the following, shifted left\nby <b>PERF_MEM_LVL_SHIFT</b>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_NA</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Not available</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_HIT</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Hit</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_MISS</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Miss</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_L1</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Level 1 cache</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_LFB</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Line fill buffer</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_L2</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Level 2 cache</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_L3</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Level 3 cache</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_LOC_RAM</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Local DRAM</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_REM_RAM1</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Remote DRAM 1 hop</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_REM_RAM2</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Remote DRAM 2 hops</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_REM_CCE1</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Remote cache 1 hop</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_REM_CCE2</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Remote cache 2 hops</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_IO</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>I/O memory</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"32%\">\n\n\n<p><b>PERF_MEM_LVL_UNC</b></p></td>\n<td width=\"5%\"></td>\n<td width=\"23%\">\n\n\n<p>Uncached memory</p></td></tr>\n</table>\n\n<p style=\"margin-left:34%;\"><i>mem_snoop</i></p>\n\n<p style=\"margin-left:40%;\">Snoop mode, a bitwise\ncombination of the following, shifted left by\n<b>PERF_MEM_SNOOP_SHIFT</b>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"29%\">\n\n\n<p><b>PERF_MEM_SNOOP_NA</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"23%\">\n\n\n<p>Not available</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"29%\">\n\n\n<p><b>PERF_MEM_SNOOP_NONE</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"23%\">\n\n\n<p>No snoop</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"29%\">\n\n\n<p><b>PERF_MEM_SNOOP_HIT</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"23%\">\n\n\n<p>Snoop hit</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"29%\">\n\n\n<p><b>PERF_MEM_SNOOP_MISS</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"23%\">\n\n\n<p>Snoop miss</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"29%\">\n\n\n<p><b>PERF_MEM_SNOOP_HITM</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"23%\">\n\n\n<p>Snoop hit modified</p></td></tr>\n</table>\n\n<p style=\"margin-left:34%;\"><i>mem_lock</i></p>\n\n<p style=\"margin-left:40%;\">Lock instruction, a bitwise\ncombination of the following, shifted left by\n<b>PERF_MEM_LOCK_SHIFT</b>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"31%\">\n\n\n<p><b>PERF_MEM_LOCK_NA</b></p></td>\n<td width=\"6%\"></td>\n<td width=\"23%\">\n\n\n<p>Not available</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"31%\">\n\n\n<p><b>PERF_MEM_LOCK_LOCKED</b></p></td>\n<td width=\"6%\"></td>\n<td width=\"23%\">\n\n\n<p>Locked transaction</p></td></tr>\n</table>\n\n<p style=\"margin-left:34%;\"><i>mem_dtlb</i></p>\n\n<p style=\"margin-left:40%;\">TLB access hit or miss, a\nbitwise combination of the following, shifted left by\n<b>PERF_MEM_TLB_SHIFT</b>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"26%\">\n\n\n<p><b>PERF_MEM_TLB_NA</b></p></td>\n<td width=\"11%\"></td>\n<td width=\"23%\">\n\n\n<p>Not available</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"26%\">\n\n\n<p><b>PERF_MEM_TLB_HIT</b></p></td>\n<td width=\"11%\"></td>\n<td width=\"23%\">\n\n\n<p>Hit</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"26%\">\n\n\n<p><b>PERF_MEM_TLB_MISS</b></p></td>\n<td width=\"11%\"></td>\n<td width=\"23%\">\n\n\n<p>Miss</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"26%\">\n\n\n<p><b>PERF_MEM_TLB_L1</b></p></td>\n<td width=\"11%\"></td>\n<td width=\"23%\">\n\n\n<p>Level 1 TLB</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"26%\">\n\n\n<p><b>PERF_MEM_TLB_L2</b></p></td>\n<td width=\"11%\"></td>\n<td width=\"23%\">\n\n\n<p>Level 2 TLB</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"26%\">\n\n\n<p><b>PERF_MEM_TLB_WK</b></p></td>\n<td width=\"11%\"></td>\n<td width=\"23%\">\n\n\n<p>Hardware walker</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"40%\"></td>\n<td width=\"26%\">\n\n\n<p><b>PERF_MEM_TLB_OS</b></p></td>\n<td width=\"11%\"></td>\n<td width=\"23%\">\n\n\n<p>OS fault handler</p></td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>transaction</i></p>\n\n<p style=\"margin-left:34%;\">If the\n<b>PERF_SAMPLE_TRANSACTION</b> flag is set, then a 64-bit\nfield is recorded describing the sources of any\ntransactional memory aborts.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">The field is a\nbitwise combination of the following values: <b><br>\nPERF_TXN_ELISION</b></p>\n\n<p style=\"margin-left:45%;\">Abort from an elision type\ntransaction (Intel-CPU-specific).</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_TXN_TRANSACTION</b></p>\n\n<p style=\"margin-left:45%;\">Abort from a generic\ntransaction.</p>\n\n<p style=\"margin-left:34%;\"><b>PERF_TXN_SYNC</b></p>\n\n<p style=\"margin-left:45%;\">Synchronous abort (related to\nthe reported instruction).</p>\n\n<p style=\"margin-left:34%;\"><b>PERF_TXN_ASYNC</b></p>\n\n<p style=\"margin-left:45%;\">Asynchronous abort (not related\nto the reported instruction).</p>\n\n<p style=\"margin-left:34%;\"><b>PERF_TXN_RETRY</b></p>\n\n<p style=\"margin-left:45%;\">Retryable abort (retrying the\ntransaction may have succeeded).</p>\n\n<p style=\"margin-left:34%;\"><b>PERF_TXN_CONFLICT</b></p>\n\n<p style=\"margin-left:45%;\">Abort due to memory conflicts\nwith other threads.</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_TXN_CAPACITY_WRITE</b></p>\n\n<p style=\"margin-left:45%;\">Abort due to write capacity\noverflow.</p>\n\n\n<p style=\"margin-left:34%;\"><b>PERF_TXN_CAPACITY_READ</b></p>\n\n<p style=\"margin-left:45%;\">Abort due to read capacity\noverflow.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">In addition, a\nuser-specified abort code can be obtained from the high 32\nbits of the field by shifting right by\n<b>PERF_TXN_ABORT_SHIFT</b> and masking with the value\n<b>PERF_TXN_ABORT_MASK</b>.</p>\n\n<p style=\"margin-left:28%;\"><i>abi</i>,\n<i>regs[weight(mask)]</i></p>\n\n<p style=\"margin-left:34%;\">If <b>PERF_SAMPLE_REGS_INTR</b>\nis enabled, then the user CPU registers are recorded.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">The <i>abi</i>\nfield is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,\n<b>PERF_SAMPLE_REGS_ABI_32</b>, or\n<b>PERF_SAMPLE_REGS_ABI_64</b>.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">The <i>regs</i>\nfield is an array of the CPU registers that were specified\nby the <i>sample_regs_intr</i> attr field. The number of\nvalues is the number of bits set in the\n<i>sample_regs_intr</i> bit mask.</p>\n\n<p style=\"margin-left:28%;\"><i>phys_addr</i></p>\n\n<p style=\"margin-left:34%;\">If the\n<b>PERF_SAMPLE_PHYS_ADDR</b> flag is set, then the 64-bit\nphysical address is recorded.</p>\n\n<p style=\"margin-left:28%;\"><i>cgroup</i></p>\n\n<p style=\"margin-left:34%;\">If the\n<b>PERF_SAMPLE_CGROUP</b> flag is set, then the 64-bit\ncgroup ID (for the perf_event subsystem) is recorded. To get\nthe pathname of the cgroup, the ID should match to one in a\n<b>PERF_RECORD_CGROUP .</b></p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_MMAP2</b></p>\n\n<p style=\"margin-left:28%;\">This record includes extended\ninformation on <a href=\"https://man.page/2/mmap\">mmap(2)</a> calls returning executable\nmappings. The format is similar to that of the\n<b>PERF_RECORD_MMAP</b> record, but includes extra values\nthat allow uniquely identifying shared mappings.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid; <br>\nu32 tid; <br>\nu64 addr; <br>\nu64 len; <br>\nu64 pgoff; <br>\nu32 maj; <br>\nu32 min; <br>\nu64 ino; <br>\nu64 ino_generation; <br>\nu32 prot; <br>\nu32 flags; <br>\nchar filename[]; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>pid</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the process ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>tid</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the thread ID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>addr</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the address of the allocated memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>len</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the length of the allocated memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>pgoff</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the page offset of the allocated memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>maj</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the major ID of the underlying device.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>min</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the minor ID of the underlying device.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>ino</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>is the inode number.</p></td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>ino_generation</i></p>\n\n<p style=\"margin-left:38%;\">is the inode generation.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>prot</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"47%\">\n\n\n<p>is the protection information.</p></td>\n<td width=\"15%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>flags</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"47%\">\n\n\n<p>is the flags information.</p></td>\n<td width=\"15%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>filename</i></p>\n\n<p style=\"margin-left:38%;\">is a string describing the\nbacking of the allocated memory.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_AUX</b> (since\nLinux 4.1)</p>\n\n<p style=\"margin-left:28%;\">This record reports that new\ndata is available in the separate AUX buffer region.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 aux_offset; <br>\nu64 aux_size; <br>\nu64 flags; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<p style=\"margin-left:28%;\"><i>aux_offset</i></p>\n\n<p style=\"margin-left:38%;\">offset in the AUX mmap region\nwhere the new data begins.</p>\n\n<p style=\"margin-left:28%;\"><i>aux_size</i></p>\n\n<p style=\"margin-left:38%;\">size of the data made\navailable.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>flags</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"39%\">\n\n\n<p>describes the AUX update.</p></td>\n<td width=\"23%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:38%;\"><b>PERF_AUX_FLAG_TRUNCATED</b></p>\n\n<p style=\"margin-left:49%;\">if set, then the data returned\nwas truncated to fit the available buffer size.</p>\n\n\n<p style=\"margin-left:38%;\"><b>PERF_AUX_FLAG_OVERWRITE</b></p>\n\n<p style=\"margin-left:49%;\">if set, then the data returned\nhas overwritten previous data.</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_ITRACE_START</b>\n(since Linux 4.1)</p>\n\n<p style=\"margin-left:28%;\">This record indicates which\nprocess has initiated an instruction trace event, allowing\ntools to properly correlate the instruction addresses in the\nAUX buffer with the proper executable.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid; <br>\nu32 tid; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"4%\">\n\n\n<p><i>pid</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"62%\">\n\n\n<p>process ID of the thread starting an instruction\ntrace.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"4%\">\n\n\n<p><i>tid</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"62%\">\n\n\n<p>thread ID of the thread starting an instruction\ntrace.</p> </td></tr>\n</table>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_LOST_SAMPLES</b>\n(since Linux 4.2)</p>\n\n<p style=\"margin-left:28%;\">When using hardware sampling\n(such as Intel PEBS) this record indicates some number of\nsamples that may have been lost.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 lost; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>lost</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"60%\">\n\n\n<p>the number of potentially lost samples.</p></td>\n<td width=\"2%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_SWITCH</b>\n(since Linux 4.3)</p>\n\n<p style=\"margin-left:28%;\">This record indicates a context\nswitch has happened. The <b>PERF_RECORD_MISC_SWITCH_OUT</b>\nbit in the <i>misc</i> field indicates whether it was a\ncontext switch into or away from the current process.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_SWITCH_CPU_WIDE</b>\n(since Linux 4.3)</p>\n\n<p style=\"margin-left:28%;\">As with\n<b>PERF_RECORD_SWITCH</b> this record indicates a context\nswitch has happened, but it only occurs when sampling in\nCPU-wide mode and provides additional information on the\nprocess being switched to/from. The\n<b>PERF_RECORD_MISC_SWITCH_OUT</b> bit in the <i>misc</i>\nfield indicates whether it was a context switch into or away\nfrom the current process.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 next_prev_pid; <br>\nu32 next_prev_tid; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<p style=\"margin-left:28%;\"><i>next_prev_pid</i></p>\n\n<p style=\"margin-left:38%;\">The process ID of the previous\n(if switching in) or next (if switching out) process on the\nCPU.</p>\n\n<p style=\"margin-left:28%;\"><i>next_prev_tid</i></p>\n\n<p style=\"margin-left:38%;\">The thread ID of the previous\n(if switching in) or next (if switching out) thread on the\nCPU.</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_NAMESPACES</b>\n(since Linux 4.11)</p>\n\n<p style=\"margin-left:28%;\">This record includes various\nnamespace information of a process.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu32 pid; <br>\nu32 tid; <br>\nu64 nr_namespaces; <br>\nstruct { u64 dev, inode } [nr_namespaces]; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"4%\">\n\n\n<p><i>pid</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"27%\">\n\n\n<p>is the process ID</p></td>\n<td width=\"35%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"4%\">\n\n\n<p><i>tid</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"27%\">\n\n\n<p>is the thread ID</p></td>\n<td width=\"35%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>nr_namespace</i></p>\n\n<p style=\"margin-left:38%;\">is the number of namespaces in\nthis record</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">Each namespace\nhas <i>dev</i> and <i>inode</i> fields and is recorded in\nthe fixed position like below: <b><br>\nNET_NS_INDEX</b>=<b>0</b></p>\n\n<p style=\"margin-left:38%;\">Network namespace</p>\n\n\n<p style=\"margin-left:28%;\"><b>UTS_NS_INDEX</b>=<b>1</b></p>\n\n<p style=\"margin-left:38%;\">UTS namespace</p>\n\n\n<p style=\"margin-left:28%;\"><b>IPC_NS_INDEX</b>=<b>2</b></p>\n\n<p style=\"margin-left:38%;\">IPC namespace</p>\n\n\n<p style=\"margin-left:28%;\"><b>PID_NS_INDEX</b>=<b>3</b></p>\n\n<p style=\"margin-left:38%;\">PID namespace</p>\n\n\n<p style=\"margin-left:28%;\"><b>USER_NS_INDEX</b>=<b>4</b></p>\n\n<p style=\"margin-left:38%;\">User namespace</p>\n\n\n<p style=\"margin-left:28%;\"><b>MNT_NS_INDEX</b>=<b>5</b></p>\n\n<p style=\"margin-left:38%;\">Mount namespace</p>\n\n\n<p style=\"margin-left:28%;\"><b>CGROUP_NS_INDEX</b>=<b>6</b></p>\n\n<p style=\"margin-left:38%;\">Cgroup namespace</p>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_KSYMBOL</b>\n(since Linux 5.0)</p>\n\n<p style=\"margin-left:28%;\">This record indicates kernel\nsymbol register/unregister events.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 addr; <br>\nu32 len; <br>\nu16 ksym_type; <br>\nu16 flags; <br>\nchar name[]; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>addr</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"56%\">\n\n\n<p>is the address of the kernel symbol.</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>len</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"56%\">\n\n\n<p>is the length of the kernel symbol.</p></td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>ksym_type</i></p>\n\n<p style=\"margin-left:38%;\">is the type of the kernel\nsymbol. Currently the following types are available: <b><br>\nPERF_RECORD_KSYMBOL_TYPE_BPF</b></p>\n\n<p style=\"margin-left:49%;\">The kernel symbol is a BPF\nfunction.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>flags</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>If the <b>PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER</b> is\nset, then this event is for unregistering the kernel\nsymbol.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_BPF_EVENT</b>\n(since Linux 5.0)</p>\n\n<p style=\"margin-left:28%;\">This record indicates BPF\nprogram is loaded or unloaded.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu16 type; <br>\nu16 flags; <br>\nu32 id; <br>\nu8 tag[BPF_TAG_SIZE]; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>type</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"48%\">\n\n\n<p>is one of the following values:</p></td>\n<td width=\"14%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:38%;\"><b>PERF_BPF_EVENT_PROG_LOAD</b></p>\n\n<p style=\"margin-left:49%;\">A BPF program is loaded</p>\n\n\n<p style=\"margin-left:38%;\"><b>PERF_BPF_EVENT_PROG_UNLOAD</b></p>\n\n<p style=\"margin-left:49%;\">A BPF program is unloaded</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"4%\">\n\n\n<p><i>id</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"62%\">\n\n\n<p>is the ID of the BPF program.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"4%\">\n\n\n<p><i>tag</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"62%\">\n\n\n<p>is the tag of the BPF program. Currently,\n<b>BPF_TAG_SIZE</b> is defined as 8.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_CGROUP</b>\n(since Linux 5.7)</p>\n\n<p style=\"margin-left:28%;\">This record indicates a new\ncgroup is created and activated.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 id; <br>\nchar path[]; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>id</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the cgroup identifier. This can be also retrieved by\n<a href=\"https://man.page/2/name_to_handle_at\">name_to_handle_at(2)</a> on the cgroup path (as a file\nhandle).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>path</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"62%\">\n\n\n<p>is the path of the cgroup from the root.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>PERF_RECORD_TEXT_POKE</b>\n(since Linux 5.8)</p>\n\n<p style=\"margin-left:28%;\">This record indicates a change\nin the kernel text. This includes addition and removal of\nthe text and the corresponding length is zero in this\ncase.</p>\n\n<p style=\"margin-left:34%; margin-top: 1em\">struct { <br>\nstruct perf_event_header header; <br>\nu64 addr; <br>\nu16 old_len; <br>\nu16 new_len; <br>\nu8 bytes[]; <br>\nstruct sample_id sample_id; <br>\n};</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"6%\">\n\n\n<p><i>addr</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"44%\">\n\n\n<p>is the address of the change</p></td>\n<td width=\"18%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:28%;\"><i>old_len</i></p>\n\n<p style=\"margin-left:38%;\">is the old length</p>\n\n<p style=\"margin-left:28%;\"><i>new_len</i></p>\n\n<p style=\"margin-left:38%;\">is the new length</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"7%\">\n\n\n<p><i>bytes</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"62%\">\n\n\n<p>contains old bytes immediately followed by new\nbytes.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Overflow\nhandling</b> <br>\nEvents can be set to notify when a threshold is crossed,\nindicating an overflow. Overflow conditions can be captured\nby monitoring the event file descriptor with <a href=\"https://man.page/2/poll\">poll(2)</a>,\n<a href=\"https://man.page/2/select\">select(2)</a>, or <a href=\"https://man.page/7/epoll\">epoll(7)</a>. Alternatively, the\noverflow events can be captured via sa signal handler, by\nenabling I/O signaling on the file descriptor; see the\ndiscussion of the <b>F_SETOWN</b> and <b>F_SETSIG</b>\noperations in <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Overflows are\ngenerated only by sampling events (<i>sample_period</i> must\nhave a nonzero value).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\nways to generate overflow notifications.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first is to\nset a <i>wakeup_events</i> or <i>wakeup_watermark</i> value\nthat will trigger if a certain number of samples or bytes\nhave been written to the mmap ring buffer. In this case,\n<b>POLL_IN</b> is indicated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The other way\nis by use of the <b>PERF_EVENT_IOC_REFRESH</b> ioctl. This\nioctl adds to a counter that decrements each time the event\noverflows. When nonzero, <b>POLL_IN</b> is indicated, but\nonce the counter reaches 0 <b>POLL_HUP</b> is indicated and\nthe underlying event is disabled.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Refreshing an\nevent group leader refreshes all siblings and refreshing\nwith a parameter of 0 currently enables infinite refreshes;\nthese behaviors are unsupported and should not be relied\non.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting with\nLinux 3.18, <b>POLL_HUP</b> is indicated if the event being\nmonitored is attached to a different process and that\nprocess exits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>rdpmc\ninstruction</b> <br>\nStarting with Linux 3.4 on x86, you can use the <i>rdpmc</i>\ninstruction to get low-latency reads without having to enter\nthe kernel. Note that using <i>rdpmc</i> is not necessarily\nfaster than other methods for reading event values.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Support for\nthis can be detected with the <i>cap_usr_rdpmc</i> field in\nthe mmap page; documentation on how to calculate event\nvalues can be found in that section.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Originally,\nwhen rdpmc support was enabled, any process (not just ones\nwith an active perf event) could use the rdpmc instruction\nto access the counters. Starting with Linux 4.0, rdpmc\nsupport is only allowed if an event is currently enabled in\na process&rsquo;s context. To restore the old behavior,\nwrite the value 2 to <i>/sys/devices/cpu/rdpmc</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>perf_event\nioctl calls</b> <br>\nVarious ioctls act on <b>perf_event_open</b>() file\ndescriptors: <b><br>\nPERF_EVENT_IOC_ENABLE</b></p>\n\n<p style=\"margin-left:22%;\">This enables the individual\nevent or event group specified by the file descriptor\nargument.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the\n<b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument,\nthen all events in a group are enabled, even if the event\nspecified is not the group leader (but see BUGS).</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_DISABLE</b></p>\n\n<p style=\"margin-left:22%;\">This disables the individual\ncounter or event group specified by the file descriptor\nargument.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Enabling or\ndisabling the leader of a group enables or disables the\nentire group; that is, while the group leader is disabled,\nnone of the counters in the group will count. Enabling or\ndisabling a member of a group other than the leader affects\nonly that counter; disabling a non-leader stops that counter\nfrom counting but doesn&rsquo;t affect any other\ncounter.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the\n<b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument,\nthen all events in a group are disabled, even if the event\nspecified is not the group leader (but see BUGS).</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_REFRESH</b></p>\n\n<p style=\"margin-left:22%;\">Non-inherited overflow counters\ncan use this to enable a counter for a number of overflows\nspecified by the argument, after which it is disabled.\nSubsequent calls of this ioctl add the argument value to the\ncurrent count. An overflow notification with <b>POLL_IN</b>\nset will happen on each overflow until the count reaches 0;\nwhen that happens a notification with <b>POLL_HUP</b> set is\nsent and the event is disabled. Using an argument of 0 is\nconsidered undefined behavior.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_RESET</b></p>\n\n<p style=\"margin-left:22%;\">Reset the event count specified\nby the file descriptor argument to zero. This resets only\nthe counts; there is no way to reset the multiplexing\n<i>time_enabled</i> or <i>time_running</i> values.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the\n<b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument,\nthen all events in a group are reset, even if the event\nspecified is not the group leader (but see BUGS).</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_PERIOD</b></p>\n\n<p style=\"margin-left:22%;\">This updates the overflow\nperiod for the event.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux 3.7\n(on ARM) and Linux 3.14 (all other architectures), the new\nperiod takes effect immediately. On older kernels, the new\nperiod did not take effect until after the next\noverflow.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument is\na pointer to a 64-bit value containing the desired new\nperiod.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Prior to Linux\n2.6.36, this ioctl always failed due to a bug in the\nkernel.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_SET_OUTPUT</b></p>\n\n<p style=\"margin-left:22%;\">This tells the kernel to report\nevent notifications to the specified file descriptor rather\nthan the default one. The file descriptors must all be on\nthe same CPU.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument\nspecifies the desired file descriptor, or -1 if output\nshould be ignored.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_SET_FILTER</b>\n(since Linux 2.6.33)</p>\n\n<p style=\"margin-left:22%;\">This adds an ftrace filter to\nthis event.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument is\na pointer to the desired ftrace filter.</p>\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_ID</b> (since\nLinux 3.12)</p>\n\n<p style=\"margin-left:22%;\">This returns the event ID value\nfor the given event file descriptor.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument is\na pointer to a 64-bit unsigned integer to hold the\nresult.</p>\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_SET_BPF</b>\n(since Linux 4.1)</p>\n\n<p style=\"margin-left:22%;\">This allows attaching a\nBerkeley Packet Filter (BPF) program to an existing kprobe\ntracepoint event. You need <b>CAP_PERFMON</b> (since Linux\n5.8) or <b>CAP_SYS_ADMIN</b> privileges to use this\nioctl.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument is\na BPF program file descriptor that was created by a previous\n<a href=\"https://man.page/2/bpf\">bpf(2)</a> system call.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_PAUSE_OUTPUT</b>\n(since Linux 4.7)</p>\n\n<p style=\"margin-left:22%;\">This allows pausing and\nresuming the event&rsquo;s ring-buffer. A paused ring-buffer\ndoes not prevent generation of samples, but simply discards\nthem. The discarded samples are considered lost, and cause a\n<b>PERF_RECORD_LOST</b> sample to be generated when\npossible. An overflow signal may still be triggered by the\ndiscarded sample even though the ring-buffer remains\nempty.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument is\nan unsigned 32-bit integer. A nonzero value pauses the\nring-buffer, while a zero value resumes the ring-buffer.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_MODIFY_ATTRIBUTES</b>\n(since Linux 4.17)</p>\n\n<p style=\"margin-left:22%;\">This allows modifying an\nexisting event without the overhead of closing and reopening\na new event. Currently this is supported only for breakpoint\nevents.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument is\na pointer to a <i>perf_event_attr</i> structure containing\nthe updated event settings.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PERF_EVENT_IOC_QUERY_BPF</b>\n(since Linux 4.16)</p>\n\n<p style=\"margin-left:22%;\">This allows querying which\nBerkeley Packet Filter (BPF) programs are attached to an\nexisting kprobe tracepoint. You can only attach one BPF\nprogram per event, but you can have multiple events attached\nto a tracepoint. Querying this value on one tracepoint event\nreturns the ID of all BPF programs in all events attached to\nthe tracepoint. You need <b>CAP_PERFMON</b> (since Linux\n5.8) or <b>CAP_SYS_ADMIN</b> privileges to use this\nioctl.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument is\na pointer to a structure</p>\n\n<p style=\"margin-left:28%;\">struct perf_event_query_bpf {\n<br>\n__u32 ids_len; <br>\n__u32 prog_cnt; <br>\n__u32 ids[0]; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>ids_len</i> field indicates the number of ids that can\nfit in the provided <i>ids</i> array. The <i>prog_cnt</i>\nvalue is filled in by the kernel with the number of attached\nBPF programs. The <i>ids</i> array is filled with the ID of\neach attached BPF program. If there are more programs than\nwill fit in the array, then the kernel will return\n<b>ENOSPC</b> and <i>ids_len</i> will indicate the number of\nprogram IDs that were successfully copied.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Using\nprctl(2)</b> <br>\nA process can enable or disable all currently open event\ngroups using the <a href=\"https://man.page/2/prctl\">prctl(2)</a>\n<b>PR_TASK_PERF_EVENTS_ENABLE</b> and\n<b>PR_TASK_PERF_EVENTS_DISABLE</b> operations. This applies\nonly to events created locally by the calling process. This\ndoes not apply to events created by other processes attached\nto the calling process or inherited events from a parent\nprocess. Only group leaders are enabled and disabled, not\nany other members of the groups.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>perf_event\nrelated configuration files</b> <br>\nFiles in <i>/proc/sys/kernel/</i></p>\n\n\n<p style=\"margin-left:17%;\"><i>/proc/sys/kernel/perf_event_paranoid</i></p>\n\n<p style=\"margin-left:28%;\">The <i>perf_event_paranoid</i>\nfile can be set to restrict access to the performance\ncounters.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"3%\">\n\n\n<p>2</p></td>\n<td width=\"3%\"></td>\n<td width=\"66%\">\n\n\n<p>allow only user-space measurements (default since Linux\n4.6).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"3%\">\n\n\n<p>1</p></td>\n<td width=\"3%\"></td>\n<td width=\"66%\">\n\n\n<p>allow both kernel and user measurements (default before\nLinux 4.6).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"3%\">\n\n\n<p>0</p></td>\n<td width=\"3%\"></td>\n<td width=\"66%\">\n\n\n<p>allow access to CPU-specific data but not raw tracepoint\nsamples.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"28%\"></td>\n<td width=\"3%\">\n\n\n<p>-1</p></td>\n<td width=\"3%\"></td>\n<td width=\"66%\">\n\n\n<p>no restrictions.</p></td></tr>\n</table>\n\n<p style=\"margin-left:28%; margin-top: 1em\">The existence\nof the <i>perf_event_paranoid</i> file is the official\nmethod for determining if a kernel supports\n<b>perf_event_open</b>().</p>\n\n\n<p style=\"margin-left:17%;\"><i>/proc/sys/kernel/perf_event_max_sample_rate</i></p>\n\n<p style=\"margin-left:28%;\">This sets the maximum sample\nrate. Setting this too high can allow users to sample at a\nrate that impacts overall machine performance and\npotentially lock up the machine. The default value is 100000\n(samples per second).</p>\n\n\n<p style=\"margin-left:17%;\"><i>/proc/sys/kernel/perf_event_max_stack</i></p>\n\n<p style=\"margin-left:28%;\">This file sets the maximum\ndepth of stack frame entries reported when generating a call\ntrace.</p>\n\n\n<p style=\"margin-left:17%;\"><i>/proc/sys/kernel/perf_event_mlock_kb</i></p>\n\n<p style=\"margin-left:28%;\">Maximum number of pages an\nunprivileged user can <a href=\"https://man.page/2/mlock\">mlock(2)</a>. The default is 516\n(kB).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Files in\n<i>/sys/bus/event_source/devices/</i></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Since Linux\n2.6.34, the kernel supports having multiple PMUs available\nfor monitoring. Information on how to program these PMUs can\nbe found under <i>/sys/bus/event_source/devices/</i>. Each\nsubdirectory corresponds to a different PMU. <i><br>\n/sys/bus/event_source/devices/*/type</i> (since Linux\n2.6.38)</p>\n\n<p style=\"margin-left:28%;\">This contains an integer that\ncan be used in the <i>type</i> field of\n<i>perf_event_attr</i> to indicate that you wish to use this\nPMU.</p>\n\n\n<p style=\"margin-left:17%;\"><i>/sys/bus/event_source/devices/cpu/rdpmc</i>\n(since Linux 3.4)</p>\n\n<p style=\"margin-left:28%;\">If this file is 1, then direct\nuser-space access to the performance counter registers is\nallowed via the rdpmc instruction. This can be disabled by\nechoing 0 to the file.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">As of Linux 4.0\nthe behavior has changed, so that 1 now means only allow\naccess to processes with active perf events, with 2\nindicating the old allow-anyone-access behavior.</p>\n\n\n<p style=\"margin-left:17%;\"><i>/sys/bus/event_source/devices/*/format/</i>\n(since Linux 3.4)</p>\n\n<p style=\"margin-left:28%;\">This subdirectory contains\ninformation on the architecture-specific subfields available\nfor programming the various <i>config</i> fields in the\n<i>perf_event_attr</i> struct.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">The content of\neach file is the name of the config field, followed by a\ncolon, followed by a series of integer bit ranges separated\nby commas. For example, the file <i>event</i> may contain\nthe value <i>config1:1,6-10,44</i> which indicates that\nevent is an attribute that occupies bits 1,6&ndash;10, and\n44 of <i>perf_event_attr::config1</i>.</p>\n\n\n<p style=\"margin-left:17%;\"><i>/sys/bus/event_source/devices/*/events/</i>\n(since Linux 3.4)</p>\n\n<p style=\"margin-left:28%;\">This subdirectory contains\nfiles with predefined events. The contents are strings\ndescribing the event settings expressed in terms of the\nfields found in the previously mentioned <i>./format/</i>\ndirectory. These are not necessarily complete lists of all\nevents supported by a PMU, but usually a subset of events\ndeemed useful or interesting.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">The content of\neach file is a list of attribute names separated by commas.\nEach entry has an optional value (either hex or decimal). If\nno value is specified, then it is assumed to be a single-bit\nfield with a value of 1. An example entry may look like\nthis: <i>event=0x2,inv,ldlat=3</i>.</p>\n\n\n<p style=\"margin-left:17%;\"><i>/sys/bus/event_source/devices/*/uevent</i></p>\n\n<p style=\"margin-left:28%;\">This file is the standard\nkernel device interface for injecting hotplug events.</p>\n\n\n<p style=\"margin-left:17%;\"><i>/sys/bus/event_source/devices/*/cpumask</i>\n(since Linux 3.7)</p>\n\n<p style=\"margin-left:28%;\">The <i>cpumask</i> file\ncontains a comma-separated list of integers that indicate a\nrepresentative CPU number for each socket (package) on the\nmotherboard. This is needed when setting up uncore or\nnorthbridge events, as those PMUs present socket-wide\nevents.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>perf_event_open</b>()\nreturns the new file descriptor, or -1 if an error occurred\n(in which case, <i>errno</i> is set appropriately).</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The errors\nreturned by <b>perf_event_open</b>() can be inconsistent,\nand may vary across processor architectures and performance\nmonitoring units.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>E2BIG</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned if the <i>perf_event_attr size</i> value is too\nsmall (smaller than <b>PERF_ATTR_SIZE_VER0</b>), too big\n(larger than the page size), or larger than the kernel\nsupports and the extra bytes are not zero. When <b>E2BIG</b>\nis returned, the <i>perf_event_attr size</i> field is\noverwritten by the kernel to be the size of the structure it\nwas expecting.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned when the requested event requires\n<b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b>\npermissions (or a more permissive perf_event paranoid\nsetting). Some common cases where an unprivileged process\nmay encounter this error: attaching to a process owned by a\ndifferent user; monitoring all processes on a given CPU\n(i.e., specifying the <i>pid</i> argument as -1); and not\nsetting <i>exclude_kernel</i> when the paranoid setting\nrequires it.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned if the <i>group_fd</i> file descriptor is not\nvalid, or, if <b>PERF_FLAG_PID_CGROUP</b> is set, the cgroup\nfile descriptor in <i>pid</i> is not valid.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EBUSY</b> (since Linux\n4.1)</p>\n\n<p style=\"margin-left:22%;\">Returned if another event\nalready has exclusive access to the PMU.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned if the <i>attr</i> pointer points at an invalid\nmemory address.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned if the specified event is invalid. There are\nmany possible reasons for this. A not-exhaustive list:\n<i>sample_freq</i> is higher than the maximum setting; the\n<i>cpu</i> to monitor does not exist; <i>read_format</i> is\nout of range; <i>sample_type</i> is out of range; the\n<i>flags</i> value is out of range; <i>exclusive</i> or\n<i>pinned</i> set and the event is not a group leader; the\nevent <i>config</i> values are out of range or set reserved\nbits; the generic event selected is not supported; or there\nis not enough room to add the selected event.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned when trying to mix perf and ftrace handling for\na uprobe.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Each opened event uses one file descriptor. If a large\nnumber of events are opened, the per-process limit on the\nnumber of open file descriptors will be reached, and no more\nevents can be created.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENODEV</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned when the event involves a feature not supported\nby the current CPU.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned if the <i>type</i> setting is not valid. This\nerror is also returned for some unsupported generic\nevents.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSPC</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Prior to Linux 3.3, if there was not enough room for the\nevent, <b>ENOSPC</b> was returned. In Linux 3.3, this was\nchanged to <b>EINVAL</b>. <b>ENOSPC</b> is still returned if\nyou try to add more breakpoint events than supported by the\nhardware.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned if <b>PERF_SAMPLE_STACK_USER</b> is set in\n<i>sample_type</i> and it is not supported by hardware.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EOPNOTSUPP</b></p>\n\n<p style=\"margin-left:22%;\">Returned if an event requiring\na specific hardware feature is requested but there is no\nhardware support. This includes requesting low-skid events\nif not supported, branch tracing if it is not available,\nsampling if no PMU interrupt is available, and branch stacks\nfor software events.</p>\n\n<p style=\"margin-left:11%;\"><b>EOVERFLOW</b> (since Linux\n4.8)</p>\n\n<p style=\"margin-left:22%;\">Returned if\n<b>PERF_SAMPLE_CALLCHAIN</b> is requested and\n<i>sample_max_stack</i> is larger than the maximum specified\nin <i>/proc/sys/kernel/perf_event_max_stack</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned on many (but not all) architectures when an\nunsupported <i>exclude_hv</i>, <i>exclude_idle</i>,\n<i>exclude_user</i>, or <i>exclude_kernel</i> setting is\nspecified.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">It can also\nhappen, as with <b>EACCES</b>, when the requested event\nrequires <b>CAP_PERFMON</b> (since Linux 5.8) or\n<b>CAP_SYS_ADMIN</b> permissions (or a more permissive\nperf_event paranoid setting). This includes setting a\nbreakpoint on a kernel address, and (since Linux 3.13)\nsetting a kernel function-trace tracepoint.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>ESRCH</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Returned if attempting to attach\nto a process that does not exist.</p></td></tr>\n</table>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>perf_event_open</b>()\nwas introduced in Linux 2.6.31 but was called\n<b>perf_counter_open</b>(). It was renamed in Linux\n2.6.32.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This\n<b>perf_event_open</b>() system call Linux-specific and\nshould not be used in programs intended to be portable.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glibc does not\nprovide a wrapper for this system call; call it using\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>. See the example below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The official\nway of knowing if <b>perf_event_open</b>() support is\nenabled is checking for the existence of the file\n<i>/proc/sys/kernel/perf_event_paranoid</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CAP_PERFMON</b>\ncapability (since Linux 5.8) provides secure approach to\nperformance monitoring and observability operations in a\nsystem according to the principal of least privilege (POSIX\nIEEE 1003.1e). Accessing system performance monitoring and\nobservability operations using <b>CAP_PERFMON</b> rather\nthan the much more powerful <b>CAP_SYS_ADMIN</b> excludes\nchances to misuse credentials and makes operations more\nsecure. <b>CAP_SYS_ADMIN</b> usage for secure system\nperformance monitoring and observability is discouraged in\nfavor of the <b>CAP_PERFMON</b> capability.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>F_SETOWN_EX</b> option to <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> is needed to\nproperly get overflow signals in threads. This was\nintroduced in Linux 2.6.32.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prior to Linux\n2.6.33 (at least for x86), the kernel did not check if\nevents could be scheduled together until read time. The same\nhappens on all known kernels if the NMI watchdog is enabled.\nThis means to see if a given set of events works you have to\n<b>perf_event_open</b>(), start, then read before you know\nfor sure you can get valid measurements.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prior to Linux\n2.6.34, event constraints were not enforced by the kernel.\nIn that case, some events would silently return\n&quot;0&quot; if the kernel scheduled them in an improper\ncounter slot.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prior to Linux\n2.6.34, there was a bug when multiplexing where the wrong\nresults could be returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Kernels from\nLinux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if\n&quot;inherit&quot; is enabled and many threads are\nstarted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prior to Linux\n2.6.35, <b>PERF_FORMAT_GROUP</b> did not work with attached\nprocesses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is a bug\nin the kernel code between Linux 2.6.36 and Linux 3.0 that\nignores the &quot;watermark&quot; field and acts as if a\nwakeup_event was chosen if the union has a nonzero value in\nit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From Linux\n2.6.31 to Linux 3.4, the <b>PERF_IOC_FLAG_GROUP</b> ioctl\nargument was broken and would repeatedly operate on the\nevent specified rather than iterating across all sibling\nevents in a group.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From Linux 3.4\nto Linux 3.11, the mmap <i>cap_usr_rdpmc</i> and\n<i>cap_usr_time</i> bits mapped to the same location. Code\nshould migrate to the new <i>cap_user_rdpmc</i> and\n<i>cap_user_time</i> fields instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Always\ndouble-check your results! Various generalized events have\nhad wrong values. For example, retired branches measured the\nwrong thing on AMD machines until Linux 2.6.35.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nis a short example that measures the total instruction count\nof a call to <a href=\"https://man.page/3/printf\">printf(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stdlib.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;sys/ioctl.h&gt; <br>\n#include &lt;linux/perf_event.h&gt; <br>\n#include &lt;asm/unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static long\n<br>\nperf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n<br>\nint cpu, int group_fd, unsigned long flags) <br>\n{ <br>\nint ret;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\nsyscall(__NR_perf_event_open, hw_event, pid, cpu, <br>\ngroup_fd, flags); <br>\nreturn ret; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char **argv) <br>\n{ <br>\nstruct perf_event_attr pe; <br>\nlong long count; <br>\nint fd;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(&amp;pe,\n0, sizeof(pe)); <br>\npe.type = PERF_TYPE_HARDWARE; <br>\npe.size = sizeof(pe); <br>\npe.config = PERF_COUNT_HW_INSTRUCTIONS; <br>\npe.disabled = 1; <br>\npe.exclude_kernel = 1; <br>\npe.exclude_hv = 1;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nperf_event_open(&amp;pe, 0, -1, -1, 0); <br>\nif (fd == -1) { <br>\nfprintf(stderr, &quot;Error opening leader %llx\\n&quot;,\npe.config); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioctl(fd,\nPERF_EVENT_IOC_RESET, 0); <br>\nioctl(fd, PERF_EVENT_IOC_ENABLE, 0);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Measuring\ninstruction count for this printf\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioctl(fd,\nPERF_EVENT_IOC_DISABLE, 0); <br>\nread(fd, &amp;count, sizeof(count));</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Used\n%lld instructions\\n&quot;, count);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(fd); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/perf\">perf(1)</a>,\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/open\">open(2)</a>,\n<a href=\"https://man.page/2/prctl\">prctl(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Documentation/admin-guide/perf-security.rst</i>\nin the kernel source tree</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}