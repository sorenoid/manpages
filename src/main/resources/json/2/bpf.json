{"name":"bpf","body":"\n\n<h1 align=\"center\">BPF</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">bpf - perform a\ncommand on an extended BPF map or program</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;linux/bpf.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nbpf(int</b> <i>cmd</i><b>, union bpf_attr\n*</b><i>attr</i><b>, unsigned int</b>\n<i>size</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>bpf</b>() system call performs a range of operations\nrelated to extended Berkeley Packet Filters. Extended BPF\n(or eBPF) is similar to the original (&quot;classic&quot;)\nBPF (cBPF) used to filter network packets. For both cBPF and\neBPF programs, the kernel statically analyzes the programs\nbefore loading them, in order to ensure that they cannot\nharm the running system.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">eBPF extends\ncBPF in multiple ways, including the ability to call a fixed\nset of in-kernel helper functions (via the <b>BPF_CALL</b>\nopcode extension provided by eBPF) and access shared data\nstructures such as eBPF maps.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Extended BPF\nDesign/Architecture</b> <br>\neBPF maps are a generic data structure for storage of\ndifferent data types. Data types are generally treated as\nbinary blobs, so a user just specifies the size of the key\nand the size of the value at map-creation time. In other\nwords, a key/value for a given map can have an arbitrary\nstructure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A user process\ncan create multiple maps (with key/value-pairs being opaque\nbytes of data) and access them via file descriptors.\nDifferent eBPF programs can access the same maps in\nparallel. It&rsquo;s up to the user process and eBPF program\nto decide what they store inside maps.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There&rsquo;s\none special map type, called a program array. This type of\nmap stores file descriptors referring to other eBPF\nprograms. When a lookup in the map is performed, the program\nflow is redirected in-place to the beginning of another eBPF\nprogram and does not return back to the calling program. The\nlevel of nesting has a fixed limit of 32, so that infinite\nloops cannot be crafted. At run time, the program file\ndescriptors stored in the map can be modified, so program\nfunctionality can be altered based on specific requirements.\nAll programs referred to in a program-array map must have\nbeen previously loaded into the kernel via <b>bpf</b>(). If\na map lookup fails, the current program continues its\nexecution. See <b>BPF_MAP_TYPE_PROG_ARRAY</b> below for\nfurther details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Generally, eBPF\nprograms are loaded by the user process and automatically\nunloaded when the process exits. In some cases, for example,\n<b>tc-bpf</b>(8), the program will continue to stay alive\ninside the kernel even after the process that loaded the\nprogram exits. In that case, the tc subsystem holds a\nreference to the eBPF program after the file descriptor has\nbeen closed by the user-space program. Thus, whether a\nspecific program continues to live inside the kernel depends\non how it is further attached to a given kernel subsystem\nafter it was loaded via <b>bpf</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each eBPF\nprogram is a set of instructions that is safe to run until\nits completion. An in-kernel verifier statically determines\nthat the eBPF program terminates and is safe to execute.\nDuring verification, the kernel increments reference counts\nfor each of the maps that the eBPF program uses, so that the\nattached maps can&rsquo;t be removed until the program is\nunloaded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">eBPF programs\ncan be attached to different events. These events can be the\narrival of network packets, tracing events, classification\nevents by network queueing disciplines (for eBPF programs\nattached to a <b>tc</b>(8) classifier), and other types that\nmay be added in the future. A new event triggers execution\nof the eBPF program, which may store information about the\nevent in eBPF maps. Beyond storing data, eBPF programs may\ncall a fixed set of in-kernel helper functions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The same eBPF\nprogram can be attached to multiple events and different\neBPF programs can access the same map:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">tracing tracing\ntracing packet packet packet <br>\nevent A event B event C on eth0 on eth1 on eth2 <br>\n| | | | | ^ <br>\n| | | | v | <br>\n--&gt; tracing &lt;-- tracing socket tc ingress tc egress\n<br>\nprog_1 prog_2 prog_3 classifier action <br>\n| | | | prog_4 prog_5 <br>\n|--- -----| |------| map_3 | | <br>\nmap_1 map_2 --| map_4 |--</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Arguments</b>\n<br>\nThe operation to be performed by the <b>bpf</b>() system\ncall is determined by the <i>cmd</i> argument. Each\noperation takes an accompanying argument, provided via\n<i>attr</i>, which is a pointer to a union of type\n<i>bpf_attr</i> (see below). The <i>size</i> argument is the\nsize of the union pointed to by <i>attr</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The value\nprovided in <i>cmd</i> is one of the following: <b><br>\nBPF_MAP_CREATE</b></p>\n\n<p style=\"margin-left:22%;\">Create a map and return a file\ndescriptor that refers to the map. The close-on-exec file\ndescriptor flag (see <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>) is automatically\nenabled for the new file descriptor.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_LOOKUP_ELEM</b></p>\n\n<p style=\"margin-left:22%;\">Look up an element by key in a\nspecified map and return its value.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_UPDATE_ELEM</b></p>\n\n<p style=\"margin-left:22%;\">Create or update an element\n(key/value pair) in a specified map.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_DELETE_ELEM</b></p>\n\n<p style=\"margin-left:22%;\">Look up and delete an element\nby key in a specified map.</p>\n\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_GET_NEXT_KEY</b></p>\n\n<p style=\"margin-left:22%;\">Look up an element by key in a\nspecified map and return the key of the next element.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_PROG_LOAD</b></p>\n\n<p style=\"margin-left:22%;\">Verify and load an eBPF\nprogram, returning a new file descriptor associated with the\nprogram. The close-on-exec file descriptor flag (see\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a>) is automatically enabled for the new file\ndescriptor.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>bpf_attr</i> union consists of various anonymous\nstructures that are used by different <b>bpf</b>()\ncommands:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">union bpf_attr\n{ <br>\nstruct { /* Used by BPF_MAP_CREATE */ <br>\n__u32 map_type; <br>\n__u32 key_size; /* size of key in bytes */ <br>\n__u32 value_size; /* size of value in bytes */ <br>\n__u32 max_entries; /* maximum number of entries <br>\nin a map */ <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct { /*\nUsed by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY <br>\ncommands */ <br>\n__u32 map_fd; <br>\n__aligned_u64 key; <br>\nunion { <br>\n__aligned_u64 value; <br>\n__aligned_u64 next_key; <br>\n}; <br>\n__u64 flags; <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct { /*\nUsed by BPF_PROG_LOAD */ <br>\n__u32 prog_type; <br>\n__u32 insn_cnt; <br>\n__aligned_u64 insns; /* 'const struct bpf_insn *' */ <br>\n__aligned_u64 license; /* 'const char *' */ <br>\n__u32 log_level; /* verbosity level of verifier */ <br>\n__u32 log_size; /* size of user buffer */ <br>\n__aligned_u64 log_buf; /* user supplied 'char *' <br>\nbuffer */ <br>\n__u32 kern_version; <br>\n/* checked when prog_type=kprobe <br>\n(since Linux 4.1) */ <br>\n}; <br>\n} __attribute__((aligned(8)));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>eBPF\nmaps</b> <br>\nMaps are a generic data structure for storage of different\ntypes of data. They allow sharing of data between eBPF\nkernel programs, and also between kernel and user-space\napplications.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each map type\nhas the following attributes:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"40%\">\n\n\n<p>type</p></td>\n<td width=\"45%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"40%\">\n\n\n<p>maximum number of elements</p></td>\n<td width=\"45%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"40%\">\n\n\n<p>key size in bytes</p></td>\n<td width=\"45%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"40%\">\n\n\n<p>value size in bytes</p></td>\n<td width=\"45%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nwrapper functions demonstrate how various <b>bpf</b>()\ncommands can be used to access the maps. The functions use\nthe <i>cmd</i> argument to invoke different operations.\n<b><br>\nBPF_MAP_CREATE</b></p>\n\n<p style=\"margin-left:22%;\">The <b>BPF_MAP_CREATE</b>\ncommand creates a new map, returning a new file descriptor\nthat refers to the map.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">int <br>\nbpf_create_map(enum bpf_map_type map_type, <br>\nunsigned int key_size, <br>\nunsigned int value_size, <br>\nunsigned int max_entries) <br>\n{ <br>\nunion bpf_attr attr = { <br>\n.map_type = map_type, <br>\n.key_size = key_size, <br>\n.value_size = value_size, <br>\n.max_entries = max_entries <br>\n};</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">return\nbpf(BPF_MAP_CREATE, &amp;attr, sizeof(attr)); <br>\n}</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The new map has\nthe type specified by <i>map_type</i>, and attributes as\nspecified in <i>key_size</i>, <i>value_size</i>, and\n<i>max_entries</i>. On success, this operation returns a\nfile descriptor. On error, -1 is returned and <i>errno</i>\nis set to <b>EINVAL</b>, <b>EPERM</b>, or <b>ENOMEM</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>key_size</i> and <i>value_size</i> attributes will be\nused by the verifier during program loading to check that\nthe program is calling <b>bpf_map_*_elem</b>() helper\nfunctions with a correctly initialized <i>key</i> and to\ncheck that the program doesn&rsquo;t access the map element\n<i>value</i> beyond the specified <i>value_size</i>. For\nexample, when a map is created with a <i>key_size</i> of 8\nand the eBPF program calls</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">bpf_map_lookup_elem(map_fd,\nfp - 4)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">the program\nwill be rejected, since the in-kernel helper function</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">bpf_map_lookup_elem(map_fd,\nvoid *key)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">expects to read\n8 bytes from the location pointed to by <i>key</i>, but the\n<i>fp&nbsp;-&nbsp;4</i> (where <i>fp</i> is the top of the\nstack) starting address will cause out-of-bounds stack\naccess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Similarly, when\na map is created with a <i>value_size</i> of 1 and the eBPF\nprogram contains</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">value =\nbpf_map_lookup_elem(...); <br>\n*(u32 *) value = 1;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">the program\nwill be rejected, since it accesses the <i>value</i> pointer\nbeyond the specified 1 byte <i>value_size</i> limit.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Currently, the\nfollowing values are supported for <i>map_type</i>:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">enum\nbpf_map_type { <br>\nBPF_MAP_TYPE_UNSPEC, /* Reserve 0 as invalid map type */\n<br>\nBPF_MAP_TYPE_HASH, <br>\nBPF_MAP_TYPE_ARRAY, <br>\nBPF_MAP_TYPE_PROG_ARRAY, <br>\nBPF_MAP_TYPE_PERF_EVENT_ARRAY, <br>\nBPF_MAP_TYPE_PERCPU_HASH, <br>\nBPF_MAP_TYPE_PERCPU_ARRAY, <br>\nBPF_MAP_TYPE_STACK_TRACE, <br>\nBPF_MAP_TYPE_CGROUP_ARRAY, <br>\nBPF_MAP_TYPE_LRU_HASH, <br>\nBPF_MAP_TYPE_LRU_PERCPU_HASH, <br>\nBPF_MAP_TYPE_LPM_TRIE, <br>\nBPF_MAP_TYPE_ARRAY_OF_MAPS, <br>\nBPF_MAP_TYPE_HASH_OF_MAPS, <br>\nBPF_MAP_TYPE_DEVMAP, <br>\nBPF_MAP_TYPE_SOCKMAP, <br>\nBPF_MAP_TYPE_CPUMAP, <br>\nBPF_MAP_TYPE_XSKMAP, <br>\nBPF_MAP_TYPE_SOCKHASH, <br>\nBPF_MAP_TYPE_CGROUP_STORAGE, <br>\nBPF_MAP_TYPE_REUSEPORT_SOCKARRAY, <br>\nBPF_MAP_TYPE_PERCPU_CGROUP_STORAGE, <br>\nBPF_MAP_TYPE_QUEUE, <br>\nBPF_MAP_TYPE_STACK, <br>\n/* See /usr/include/linux/bpf.h for the full list. */ <br>\n};</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>map_type</i>\nselects one of the available map implementations in the\nkernel. For all map types, eBPF programs access maps with\nthe same <b>bpf_map_lookup_elem</b>() and\n<b>bpf_map_update_elem</b>() helper functions. Further\ndetails of the various map types are given below.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_LOOKUP_ELEM</b></p>\n\n<p style=\"margin-left:22%;\">The <b>BPF_MAP_LOOKUP_ELEM</b>\ncommand looks up an element with a given <i>key</i> in the\nmap referred to by the file descriptor <i>fd</i>.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">int <br>\nbpf_lookup_elem(int fd, const void *key, void *value) <br>\n{ <br>\nunion bpf_attr attr = { <br>\n.map_fd = fd, <br>\n.key = ptr_to_u64(key), <br>\n.value = ptr_to_u64(value), <br>\n};</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">return\nbpf(BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr)); <br>\n}</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If an element\nis found, the operation returns zero and stores the\nelement&rsquo;s value into <i>value</i>, which must point to\na buffer of <i>value_size</i> bytes.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If no element\nis found, the operation returns -1 and sets <i>errno</i> to\n<b>ENOENT</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_UPDATE_ELEM</b></p>\n\n<p style=\"margin-left:22%;\">The <b>BPF_MAP_UPDATE_ELEM</b>\ncommand creates or updates an element with a given\n<i>key/value</i> in the map referred to by the file\ndescriptor <i>fd</i>.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">int <br>\nbpf_update_elem(int fd, const void *key, const void *value,\n<br>\nuint64_t flags) <br>\n{ <br>\nunion bpf_attr attr = { <br>\n.map_fd = fd, <br>\n.key = ptr_to_u64(key), <br>\n.value = ptr_to_u64(value), <br>\n.flags = flags, <br>\n};</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">return\nbpf(BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr)); <br>\n}</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>flags</i> argument should be specified as one of the\nfollowing: <b><br>\nBPF_ANY</b></p>\n\n<p style=\"margin-left:32%;\">Create a new element or update\nan existing element.</p>\n\n<p style=\"margin-left:22%;\"><b>BPF_NOEXIST</b></p>\n\n<p style=\"margin-left:32%;\">Create a new element only if it\ndid not exist.</p>\n\n<p style=\"margin-left:22%;\"><b>BPF_EXIST</b></p>\n\n<p style=\"margin-left:32%;\">Update an existing element.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">On success, the\noperation returns zero. On error, -1 is returned and\n<i>errno</i> is set to <b>EINVAL</b>, <b>EPERM</b>,\n<b>ENOMEM</b>, or <b>E2BIG</b>. <b>E2BIG</b> indicates that\nthe number of elements in the map reached the\n<i>max_entries</i> limit specified at map creation time.\n<b>EEXIST</b> will be returned if <i>flags</i> specifies\n<b>BPF_NOEXIST</b> and the element with <i>key</i> already\nexists in the map. <b>ENOENT</b> will be returned if\n<i>flags</i> specifies <b>BPF_EXIST</b> and the element with\n<i>key</i> doesn&rsquo;t exist in the map.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_DELETE_ELEM</b></p>\n\n<p style=\"margin-left:22%;\">The <b>BPF_MAP_DELETE_ELEM</b>\ncommand deletes the element whose key is <i>key</i> from the\nmap referred to by the file descriptor <i>fd</i>.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">int <br>\nbpf_delete_elem(int fd, const void *key) <br>\n{ <br>\nunion bpf_attr attr = { <br>\n.map_fd = fd, <br>\n.key = ptr_to_u64(key), <br>\n};</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">return\nbpf(BPF_MAP_DELETE_ELEM, &amp;attr, sizeof(attr)); <br>\n}</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">On success,\nzero is returned. If the element is not found, -1 is\nreturned and <i>errno</i> is set to <b>ENOENT</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_GET_NEXT_KEY</b></p>\n\n<p style=\"margin-left:22%;\">The <b>BPF_MAP_GET_NEXT_KEY</b>\ncommand looks up an element by <i>key</i> in the map\nreferred to by the file descriptor <i>fd</i> and sets the\n<i>next_key</i> pointer to the key of the next element.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">int <br>\nbpf_get_next_key(int fd, const void *key, void *next_key)\n<br>\n{ <br>\nunion bpf_attr attr = { <br>\n.map_fd = fd, <br>\n.key = ptr_to_u64(key), <br>\n.next_key = ptr_to_u64(next_key), <br>\n};</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">return\nbpf(BPF_MAP_GET_NEXT_KEY, &amp;attr, sizeof(attr)); <br>\n}</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>key</i>\nis found, the operation returns zero and sets the\n<i>next_key</i> pointer to the key of the next element. If\n<i>key</i> is not found, the operation returns zero and sets\nthe <i>next_key</i> pointer to the key of the first element.\nIf <i>key</i> is the last element, -1 is returned and\n<i>errno</i> is set to <b>ENOENT</b>. Other possible\n<i>errno</i> values are <b>ENOMEM</b>, <b>EFAULT</b>,\n<b>EPERM</b>, and <b>EINVAL</b>. This method can be used to\niterate over all elements in the map.</p>\n\n<p style=\"margin-left:11%;\"><b>close(map_fd)</b></p>\n\n<p style=\"margin-left:22%;\">Delete the map referred to by\nthe file descriptor <i>map_fd</i>. When the user-space\nprogram that created a map exits, all maps will be deleted\nautomatically (but see NOTES).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>eBPF map\ntypes</b> <br>\nThe following map types are supported: <b><br>\nBPF_MAP_TYPE_HASH</b></p>\n\n<p style=\"margin-left:22%;\">Hash-table maps have the\nfollowing characteristics:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>Maps are created and destroyed by user-space programs.\nBoth user-space and eBPF programs can perform lookup,\nupdate, and delete operations.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The kernel takes care of allocating and freeing\nkey/value pairs.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The <b>map_update_elem</b>() helper will fail to insert\nnew element when the <i>max_entries</i> limit is reached.\n(This ensures that eBPF programs cannot exhaust memory.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>map_update_elem</b>() replaces existing elements\natomically.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Hash-table maps\nare optimized for speed of lookup.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_TYPE_ARRAY</b></p>\n\n<p style=\"margin-left:22%;\">Array maps have the following\ncharacteristics:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>Optimized for fastest possible lookup. In the future the\nverifier/JIT compiler may recognize lookup() operations that\nemploy a constant key and optimize it into constant pointer.\nIt is possible to optimize a non-constant key into direct\npointer arithmetic as well, since pointers and\n<i>value_size</i> are constant for the life of the eBPF\nprogram. In other words, <b>array_map_lookup_elem</b>() may\nbe &rsquo;inlined&rsquo; by the verifier/JIT compiler while\npreserving concurrent access to this map from user\nspace.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>All array elements pre-allocated and zero initialized at\ninit time</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The key is an array index, and must be exactly four\nbytes.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>map_delete_elem</b>() fails with the error\n<b>EINVAL</b>, since elements cannot be deleted.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>map_update_elem</b>() replaces elements in a\n<b>nonatomic</b> fashion; for atomic updates, a hash-table\nmap should be used instead. There is however one special\ncase that can also be used with arrays: the atomic built-in\n<b>__sync_fetch_and_add()</b> can be used on 32 and 64 bit\natomic counters. For example, it can be applied on the whole\nvalue itself if it represents a single counter, or in case\nof a structure containing multiple counters, it could be\nused on individual counters. This is quite often useful for\naggregation and accounting of events.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Among the uses\nfor array maps are the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\">As &quot;global&quot; eBPF\nvariables: an array of 1 element whose key is (index) 0 and\nwhere the value is a collection of &rsquo;global&rsquo;\nvariables which eBPF programs can use to keep state between\nevents.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>Aggregation of tracing events into a fixed set of\nbuckets.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>Accounting of networking events, for example, number of\npackets and packet sizes.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>BPF_MAP_TYPE_PROG_ARRAY</b>\n(since Linux 4.2)</p>\n\n<p style=\"margin-left:22%;\">A program array map is a\nspecial kind of array map whose map values contain only file\ndescriptors referring to other eBPF programs. Thus, both the\n<i>key_size</i> and <i>value_size</i> must be exactly four\nbytes. This map is used in conjunction with the\n<b>bpf_tail_call</b>() helper.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This means that\nan eBPF program with a program array map attached to it can\ncall from kernel side into</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">void\nbpf_tail_call(void *context, void *prog_map, <br>\nunsigned int index);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">and therefore\nreplace its own program flow with the one from the program\nat the given program array slot, if present. This can be\nregarded as kind of a jump table to a different eBPF\nprogram. The invoked program will then reuse the same stack.\nWhen a jump into the new program has been performed, it\nwon&rsquo;t return to the old program anymore.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If no eBPF\nprogram is found at the given index of the program array\n(because the map slot doesn&rsquo;t contain a valid program\nfile descriptor, the specified lookup index/key is out of\nbounds, or the limit of 32 nested calls has been exceed),\nexecution continues with the current eBPF program. This can\nbe used as a fall-through for default cases.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A program array\nmap is useful, for example, in tracing or networking, to\nhandle individual system calls or protocols in their own\nsubprograms and use their identifiers as an individual map\nindex. This approach may result in performance benefits, and\nalso makes it possible to overcome the maximum instruction\nlimit of a single eBPF program. In dynamic environments, a\nuser-space daemon might atomically replace individual\nsubprograms at run-time with newer versions to alter overall\nprogram behavior, for instance, if global policies\nchange.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>eBPF\nprograms</b> <br>\nThe <b>BPF_PROG_LOAD</b> command is used to load an eBPF\nprogram into the kernel. The return value for this command\nis a new file descriptor associated with this eBPF\nprogram.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">char\nbpf_log_buf[LOG_BUF_SIZE];</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nbpf_prog_load(enum bpf_prog_type type, <br>\nconst struct bpf_insn *insns, int insn_cnt, <br>\nconst char *license) <br>\n{ <br>\nunion bpf_attr attr = { <br>\n.prog_type = type, <br>\n.insns = ptr_to_u64(insns), <br>\n.insn_cnt = insn_cnt, <br>\n.license = ptr_to_u64(license), <br>\n.log_buf = ptr_to_u64(bpf_log_buf), <br>\n.log_size = LOG_BUF_SIZE, <br>\n.log_level = 1, <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">return\nbpf(BPF_PROG_LOAD, &amp;attr, sizeof(attr)); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>prog_type</i>\nis one of the available program types:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">enum\nbpf_prog_type { <br>\nBPF_PROG_TYPE_UNSPEC, /* Reserve 0 as invalid <br>\nprogram type */ <br>\nBPF_PROG_TYPE_SOCKET_FILTER, <br>\nBPF_PROG_TYPE_KPROBE, <br>\nBPF_PROG_TYPE_SCHED_CLS, <br>\nBPF_PROG_TYPE_SCHED_ACT, <br>\nBPF_PROG_TYPE_TRACEPOINT, <br>\nBPF_PROG_TYPE_XDP, <br>\nBPF_PROG_TYPE_PERF_EVENT, <br>\nBPF_PROG_TYPE_CGROUP_SKB, <br>\nBPF_PROG_TYPE_CGROUP_SOCK, <br>\nBPF_PROG_TYPE_LWT_IN, <br>\nBPF_PROG_TYPE_LWT_OUT, <br>\nBPF_PROG_TYPE_LWT_XMIT, <br>\nBPF_PROG_TYPE_SOCK_OPS, <br>\nBPF_PROG_TYPE_SK_SKB, <br>\nBPF_PROG_TYPE_CGROUP_DEVICE, <br>\nBPF_PROG_TYPE_SK_MSG, <br>\nBPF_PROG_TYPE_RAW_TRACEPOINT, <br>\nBPF_PROG_TYPE_CGROUP_SOCK_ADDR, <br>\nBPF_PROG_TYPE_LWT_SEG6LOCAL, <br>\nBPF_PROG_TYPE_LIRC_MODE2, <br>\nBPF_PROG_TYPE_SK_REUSEPORT, <br>\nBPF_PROG_TYPE_FLOW_DISSECTOR, <br>\n/* See /usr/include/linux/bpf.h for the full list. */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For further\ndetails of eBPF program types, see below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The remaining\nfields of <i>bpf_attr</i> are set as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>insns</i> is an array of <i>struct bpf_insn</i>\ninstructions.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>insn_cnt</i> is the number of instructions in the\nprogram referred to by <i>insns</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>license</i> is a license string, which must be GPL\ncompatible to call helper functions marked <i>gpl_only</i>.\n(The licensing rules are the same as for kernel modules, so\nthat also dual licenses, such as &quot;Dual BSD/GPL&quot;,\nmay be used.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>log_buf</i> is a pointer to a caller-allocated buffer\nin which the in-kernel verifier can store the verification\nlog. This log is a multi-line string that can be checked by\nthe program author in order to understand how the verifier\ncame to the conclusion that the eBPF program is unsafe. The\nformat of the output can change at any time as the verifier\nevolves.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>log_size</i> size of the buffer pointed to by\n<i>log_buf</i>. If the size of the buffer is not large\nenough to store all verifier messages, -1 is returned and\n<i>errno</i> is set to <b>ENOSPC</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>log_level</i> verbosity level of the verifier. A\nvalue of zero means that the verifier will not provide a\nlog; in this case, <i>log_buf</i> must be a NULL pointer,\nand <i>log_size</i> must be zero.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Applying\n<a href=\"https://man.page/2/close\">close(2)</a> to the file descriptor returned by\n<b>BPF_PROG_LOAD</b> will unload the eBPF program (but see\nNOTES).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Maps are\naccessible from eBPF programs and are used to exchange data\nbetween eBPF programs and between eBPF programs and\nuser-space programs. For example, eBPF programs can process\nvarious events (like kprobe, packets) and store their data\ninto a map, and user-space programs can then fetch data from\nthe map. Conversely, user-space programs can use a map as a\nconfiguration mechanism, populating the map with values\nchecked by the eBPF program, which then modifies its\nbehavior on the fly according to those values.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>eBPF program\ntypes</b> <br>\nThe eBPF program type (<i>prog_type</i>) determines the\nsubset of kernel helper functions that the program may call.\nThe program type also determines the program input\n(context)&mdash;the format of <i>struct bpf_context</i>\n(which is the data blob passed into the eBPF program as the\nfirst argument).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example, a\ntracing program does not have the exact same subset of\nhelper functions as a socket filter program (though they may\nhave some helpers in common). Similarly, the input (context)\nfor a tracing program is a set of register values, while for\na socket filter it is a network packet.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The set of\nfunctions available to eBPF programs of a given type may\nincrease in the future.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram types are supported: <b><br>\nBPF_PROG_TYPE_SOCKET_FILTER</b> (since Linux 3.19)</p>\n\n<p style=\"margin-left:22%;\">Currently, the set of functions\nfor <b>BPF_PROG_TYPE_SOCKET_FILTER</b> is:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">bpf_map_lookup_elem(map_fd,\nvoid *key) <br>\n/* look up key in a map_fd */ <br>\nbpf_map_update_elem(map_fd, void *key, void *value) <br>\n/* update key/value */ <br>\nbpf_map_delete_elem(map_fd, void *key) <br>\n/* delete key in a map_fd */</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>bpf_context</i> argument is a pointer to a <i>struct\n__sk_buff</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_PROG_TYPE_KPROBE</b>\n(since Linux 4.1)</p>\n\n<p style=\"margin-left:22%;\">[To be documented]</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_PROG_TYPE_SCHED_CLS</b>\n(since Linux 4.1)</p>\n\n<p style=\"margin-left:22%;\">[To be documented]</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_PROG_TYPE_SCHED_ACT</b>\n(since Linux 4.1)</p>\n\n<p style=\"margin-left:22%;\">[To be documented]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Events</b>\n<br>\nOnce a program is loaded, it can be attached to an event.\nVarious kernel subsystems have different ways to do so.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n3.19, the following call will attach the program\n<i>prog_fd</i> to the socket <i>sockfd</i>, which was\ncreated by an earlier call to <a href=\"https://man.page/2/socket\">socket(2)</a>:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">setsockopt(sockfd,\nSOL_SOCKET, SO_ATTACH_BPF, <br>\n&amp;prog_fd, sizeof(prog_fd));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n4.1, the following call may be used to attach the eBPF\nprogram referred to by the file descriptor <i>prog_fd</i> to\na perf event file descriptor, <i>event_fd</i>, that was\ncreated by a previous call to <a href=\"https://man.page/2/perf_event_open\">perf_event_open(2)</a>:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">ioctl(event_fd,\nPERF_EVENT_IOC_SET_BPF, prog_fd);</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a\nsuccessful call, the return value depends on the operation:\n<b><br>\nBPF_MAP_CREATE</b></p>\n\n<p style=\"margin-left:22%;\">The new file descriptor\nassociated with the eBPF map.</p>\n\n<p style=\"margin-left:11%;\"><b>BPF_PROG_LOAD</b></p>\n\n<p style=\"margin-left:22%;\">The new file descriptor\nassociated with the eBPF program.</p>\n\n<p style=\"margin-left:11%;\">All other commands</p>\n\n<p style=\"margin-left:22%;\">Zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>E2BIG</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The eBPF program is too large or\na map reached the <i>max_entries</i> limit (maximum number\nof elements).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>For <b>BPF_PROG_LOAD</b>, even though all program\ninstructions are valid, the program has been rejected\nbecause it was deemed unsafe. This may be because it may\nhave accessed a disallowed memory region or an uninitialized\nstack/register or because the function constraints\ndon&rsquo;t match the actual types or because there was a\nmisaligned memory access. In this case, it is recommended to\ncall <b>bpf</b>() again with <i>log_level = 1</i> and\nexamine <i>log_buf</i> for the specific reason provided by\nthe verifier.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>fd</i> is not an open file descriptor.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>One of the pointers (<i>key</i> or <i>value</i> or\n<i>log_buf</i> or <i>insns</i>) is outside the accessible\naddress space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The value specified in <i>cmd</i> is not recognized by\nthis kernel.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>For <b>BPF_MAP_CREATE</b>, either <i>map_type</i> or\nattributes are invalid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>For <b>BPF_MAP_*_ELEM</b> commands, some of the fields\nof <i>union bpf_attr</i> that are not used by this command\nare not set to zero.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>For <b>BPF_PROG_LOAD</b>, indicates an attempt to load\nan invalid program. eBPF programs can be deemed invalid due\nto unrecognized instructions, the use of reserved fields,\njumps out of range, infinite loops or calls of unknown\nfunctions.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>For <b>BPF_MAP_LOOKUP_ELEM</b> or\n<b>BPF_MAP_DELETE_ELEM</b>, indicates that the element with\nthe given <i>key</i> was not found.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Cannot allocate sufficient memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The call was made without sufficient privilege (without\nthe <b>CAP_SYS_ADMIN</b> capability).</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>bpf</b>() system call first appeared in Linux 3.18.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>bpf</b>() system call is Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prior to Linux\n4.4, all <b>bpf</b>() commands require the caller to have\nthe <b>CAP_SYS_ADMIN</b> capability. From Linux 4.4 onwards,\nan unprivileged user may create limited programs of type\n<b>BPF_PROG_TYPE_SOCKET_FILTER</b> and associated maps.\nHowever they may not store kernel pointers within the maps\nand are presently limited to the following helper\nfunctions:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"31%\">\n\n\n<p style=\"margin-top: 1em\">get_random</p></td>\n<td width=\"54%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"31%\">\n\n\n<p>get_smp_processor_id</p></td>\n<td width=\"54%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"31%\">\n\n\n<p>tail_call</p></td>\n<td width=\"54%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"31%\">\n\n\n<p>ktime_get_ns</p></td>\n<td width=\"54%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Unprivileged\naccess may be blocked by writing the value 1 to the file\n<i>/proc/sys/kernel/unprivileged_bpf_disabled</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">eBPF objects\n(maps and programs) can be shared between processes. For\nexample, after <a href=\"https://man.page/2/fork\">fork(2)</a>, the child inherits file\ndescriptors referring to the same eBPF objects. In addition,\nfile descriptors referring to eBPF objects can be\ntransferred over UNIX domain sockets. File descriptors\nreferring to eBPF objects can be duplicated in the usual\nway, using <a href=\"https://man.page/2/dup\">dup(2)</a> and similar calls. An eBPF object\nis deallocated only after all file descriptors referring to\nthe object have been closed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">eBPF programs\ncan be written in a restricted C that is compiled (using the\n<b>clang</b> compiler) into eBPF bytecode. Various features\nare omitted from this restricted C, such as loops, global\nvariables, variadic functions, floating-point numbers, and\npassing structures as function arguments. Some examples can\nbe found in the <i>samples/bpf/*_kern.c</i> files in the\nkernel source tree.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\ncontains a just-in-time (JIT) compiler that translates eBPF\nbytecode into native machine code for better performance. In\nkernels before Linux 4.15, the JIT compiler is disabled by\ndefault, but its operation can be controlled by writing one\nof the following integer strings to the file\n<i>/proc/sys/net/core/bpf_jit_enable</i>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">0</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Disable JIT compilation\n(default).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>1</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Normal compilation.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>2</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Debugging mode. The generated opcodes are dumped in\nhexadecimal into the kernel log. These opcodes can then be\ndisassembled using the program\n<i>tools/net/bpf_jit_disasm.c</i> provided in the kernel\nsource tree.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n4.15, the kernel may configured with the\n<b>CONFIG_BPF_JIT_ALWAYS_ON</b> option. In this case, the\nJIT compiler is always enabled, and the\n<i>bpf_jit_enable</i> is initialized to 1 and is immutable.\n(This kernel configuration option was provided as a\nmitigation for one of the Spectre attacks against the BPF\ninterpreter.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The JIT\ncompiler for eBPF is currently available for the following\narchitectures:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p style=\"margin-top: 1em\">x86-64 (since Linux 3.18; cBPF\nsince Linux 3.0);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>ARM32 (since Linux 3.18; cBPF since Linux 3.4);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>SPARC 32 (since Linux 3.18; cBPF since Linux 3.5);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>ARM-64 (since Linux 3.18);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>s390 (since Linux 4.1; cBPF since Linux 3.7);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>PowerPC 64 (since Linux 4.8; cBPF since Linux 3.1);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>SPARC 64 (since Linux 4.12);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>x86-32 (since Linux 4.18);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>MIPS 64 (since Linux 4.18; cBPF since Linux 3.16);</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"79%\">\n\n\n<p>riscv (since Linux 5.1).</p></td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* bpf+sockets\nexample: <br>\n* 1. create array map of 256 elements <br>\n* 2. load program that counts number of packets received\n<br>\n* r0 = skb-&gt;data[ETH_HLEN + offsetof(struct iphdr,\nprotocol)] <br>\n* map[r0]++ <br>\n* 3. attach prog_fd to raw socket via setsockopt() <br>\n* 4. print number of received TCP/UDP packets every second\n<br>\n*/ <br>\nint <br>\nmain(int argc, char **argv) <br>\n{ <br>\nint sock, map_fd, prog_fd, key; <br>\nlong long value = 0, tcp_cnt, udp_cnt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">map_fd =\nbpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key), <br>\nsizeof(value), 256); <br>\nif (map_fd &lt; 0) { <br>\nprintf(&quot;failed to create map '%s'\\n&quot;,\nstrerror(errno)); <br>\n/* likely not run as root */ <br>\nreturn 1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct bpf_insn\nprog[] = { <br>\nBPF_MOV64_REG(BPF_REG_6, BPF_REG_1), /* r6 = r1 */ <br>\nBPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr,\nprotocol)), <br>\n/* r0 = ip-&gt;proto */ <br>\nBPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), <br>\n/* *(u32 *)(fp - 4) = r0 */ <br>\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_10), /* r2 = fp */ <br>\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), /* r2 = r2 - 4 */\n<br>\nBPF_LD_MAP_FD(BPF_REG_1, map_fd), /* r1 = map_fd */ <br>\nBPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), <br>\n/* r0 = map_lookup(r1, r2) */ <br>\nBPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2), <br>\n/* if (r0 == 0) goto pc+2 */ <br>\nBPF_MOV64_IMM(BPF_REG_1, 1), /* r1 = 1 */ <br>\nBPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0), <br>\n/* lock *(u64 *) r0 += r1 */ <br>\nBPF_MOV64_IMM(BPF_REG_0, 0), /* r0 = 0 */ <br>\nBPF_EXIT_INSN(), /* return r0 */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">prog_fd =\nbpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <br>\nsizeof(prog) / sizeof(prog[0]), &quot;GPL&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sock =\nopen_raw_sock(&quot;lo&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">assert(setsockopt(sock,\nSOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <br>\nsizeof(prog_fd)) == 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { <br>\nkey = IPPROTO_TCP; <br>\nassert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) ==\n0); <br>\nkey = IPPROTO_UDP; <br>\nassert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) ==\n0); <br>\nprintf(&quot;TCP %lld UDP %lld packets\\n&quot;, tcp_cnt,\nudp_cnt); <br>\nsleep(1); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return 0; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some complete\nworking code can be found in the <i>samples/bpf</i>\ndirectory in the kernel source tree.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/seccomp\">seccomp(2)</a>,\n<a href=\"https://man.page/7/bpf-helpers\">bpf-helpers(7)</a>, <a href=\"https://man.page/7/socket\">socket(7)</a>, <b>tc</b>(8),\n<b>tc-bpf</b>(8)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both classic\nand extended BPF are explained in the kernel source file\n<i>Documentation/networking/filter.txt</i>.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}