{"name":"select","description":"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing","body":"\n\n<h1 align=\"center\">SELECT</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">select,\npselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O\nmultiplexing</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/select.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nselect(int</b> <i>nfds</i><b>, fd_set\n*</b><i>readfds</i><b>, fd_set *</b><i>writefds</i><b>, <br>\nfd_set *</b><i>exceptfds</i><b>, struct timeval\n*</b><i>timeout</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nFD_CLR(int</b> <i>fd</i><b>, fd_set *</b><i>set</i><b>);\n<br>\nint FD_ISSET(int</b> <i>fd</i><b>, fd_set\n*</b><i>set</i><b>); <br>\nvoid FD_SET(int</b> <i>fd</i><b>, fd_set\n*</b><i>set</i><b>); <br>\nvoid FD_ZERO(fd_set *</b><i>set</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\npselect(int</b> <i>nfds</i><b>, fd_set\n*</b><i>readfds</i><b>, fd_set *</b><i>writefds</i><b>, <br>\nfd_set *</b><i>exceptfds</i><b>, const struct timespec\n*</b><i>timeout</i><b>, <br>\nconst sigset_t *</b><i>sigmask</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pselect</b>():\n_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200112L</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>select</b>()\nallows a program to monitor multiple file descriptors,\nwaiting until one or more of the file descriptors become\n&quot;ready&quot; for some class of I/O operation (e.g.,\ninput possible). A file descriptor is considered ready if it\nis possible to perform a corresponding I/O operation (e.g.,\n<a href=\"https://man.page/2/read\">read(2)</a>, or a sufficiently small <a href=\"https://man.page/2/write\">write(2)</a>)\nwithout blocking.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>select</b>()\ncan monitor only file descriptors numbers that are less than\n<b>FD_SETSIZE</b>; <a href=\"https://man.page/2/poll\">poll(2)</a> and <a href=\"https://man.page/7/epoll\">epoll(7)</a> do not\nhave this limitation. See BUGS.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>File\ndescriptor sets</b> <br>\nThe principal arguments of <b>select</b>() are three\n&quot;sets&quot; of file descriptors (declared with the type\n<i>fd_set</i>), which allow the caller to wait for three\nclasses of events on the specified set of file descriptors.\nEach of the <i>fd_set</i> arguments may be specified as NULL\nif no file descriptors are to be watched for the\ncorresponding class of events.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Note\nwell</b>: Upon return, each of the file descriptor sets is\nmodified in place to indicate which file descriptors are\ncurrently &quot;ready&quot;. Thus, if using <b>select</b>()\nwithin a loop, the sets <i>must be reinitialized</i> before\neach call. The implementation of the <i>fd_set</i> arguments\nas value-result arguments is a design error that is avoided\nin <a href=\"https://man.page/2/poll\">poll(2)</a> and <a href=\"https://man.page/7/epoll\">epoll(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The contents of\na file descriptor set can be manipulated using the following\nmacros: <b><br>\nFD_ZERO</b>()</p>\n\n<p style=\"margin-left:22%;\">This macro clears (removes all\nfile descriptors from) <i>set</i>. It should be employed as\nthe first step in initializing a file descriptor set.</p>\n\n<p style=\"margin-left:11%;\"><b>FD_SET</b>()</p>\n\n<p style=\"margin-left:22%;\">This macro adds the file\ndescriptor <i>fd</i> to <i>set</i>. Adding a file descriptor\nthat is already present in the set is a no-op, and does not\nproduce an error.</p>\n\n<p style=\"margin-left:11%;\"><b>FD_CLR</b>()</p>\n\n<p style=\"margin-left:22%;\">This macro removes the file\ndescriptor <i>fd</i> from <i>set</i>. Removing a file\ndescriptor that is not present in the set is a no-op, and\ndoes not produce an error.</p>\n\n<p style=\"margin-left:11%;\"><b>FD_ISSET</b>()</p>\n\n<p style=\"margin-left:22%;\"><b>select</b>() modifies the\ncontents of the sets according to the rules described below.\nAfter calling <b>select</b>(), the <b>FD_ISSET</b>() macro\ncan be used to test if a file descriptor is still present in\na set. <b>FD_ISSET</b>() returns nonzero if the file\ndescriptor <i>fd</i> is present in <i>set</i>, and zero if\nit is not.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Arguments</b>\n<br>\nThe arguments of <b>select</b>() are as follows: <i><br>\nreadfds</i></p>\n\n<p style=\"margin-left:22%;\">The file descriptors in this\nset are watched to see if they are ready for reading. A file\ndescriptor is ready for reading if a read operation will not\nblock; in particular, a file descriptor is also ready on\nend-of-file.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">After\n<b>select</b>() has returned, <i>readfds</i> will be cleared\nof all file descriptors except for those that are ready for\nreading.</p>\n\n<p style=\"margin-left:11%;\"><i>writefds</i></p>\n\n<p style=\"margin-left:22%;\">The file descriptors in this\nset are watched to see if they are ready for writing. A file\ndescriptor is ready for writing if a write operation will\nnot block. However, even if a file descriptor indicates as\nwritable, a large write may still block.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">After\n<b>select</b>() has returned, <i>writefds</i> will be\ncleared of all file descriptors except for those that are\nready for writing.</p>\n\n<p style=\"margin-left:11%;\"><i>exceptfds</i></p>\n\n<p style=\"margin-left:22%;\">The file descriptors in this\nset are watched for &quot;exceptional conditions&quot;. For\nexamples of some exceptional conditions, see the discussion\nof <b>POLLPRI</b> in <a href=\"https://man.page/2/poll\">poll(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">After\n<b>select</b>() has returned, <i>exceptfds</i> will be\ncleared of all file descriptors except for those for which\nan exceptional condition has occurred.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>nfds</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This argument should be set to the highest-numbered file\ndescriptor in any of the three sets, plus 1. The indicated\nfile descriptors in each set are checked, up to this limit\n(but see BUGS).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>timeout</i></p>\n\n<p style=\"margin-left:22%;\">The <i>timeout</i> argument is\na <i>timeval</i> structure (shown below) that specifies the\ninterval that <b>select</b>() should block waiting for a\nfile descriptor to become ready. The call will block until\neither:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"72%\">\n\n\n<p>a file descriptor becomes ready;</p></td>\n<td width=\"3%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"72%\">\n\n\n<p>the call is interrupted by a signal handler; or</p></td>\n<td width=\"3%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"72%\">\n\n\n<p>the timeout expires.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note that the\n<i>timeout</i> interval will be rounded up to the system\nclock granularity, and kernel scheduling delays mean that\nthe blocking interval may overrun by a small amount.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If both fields\nof the <i>timeval</i> structure are zero, then\n<b>select</b>() returns immediately. (This is useful for\npolling.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>timeout</i> is specified as NULL, <b>select</b>() blocks\nindefinitely waiting for a file descriptor to become\nready.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pselect()</b>\n<br>\nThe <b>pselect</b>() system call allows an application to\nsafely wait until either a file descriptor becomes ready or\nuntil a signal is caught.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The operation\nof <b>select</b>() and <b>pselect</b>() is identical, other\nthan these three differences:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\"><b>select</b>() uses a timeout\nthat is a <i>struct timeval</i> (with seconds and\nmicroseconds), while <b>pselect</b>() uses a <i>struct\ntimespec</i> (with seconds and nanoseconds).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><b>select</b>() may update the <i>timeout</i> argument\nto indicate how much time was left. <b>pselect</b>() does\nnot change this argument.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><b>select</b>() has no <i>sigmask</i> argument, and\nbehaves as <b>pselect</b>() called with NULL\n<i>sigmask</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>sigmask</i>\nis a pointer to a signal mask (see <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>);\nif it is not NULL, then <b>pselect</b>() first replaces the\ncurrent signal mask by the one pointed to by <i>sigmask</i>,\nthen does the &quot;select&quot; function, and then restores\nthe original signal mask. (If <i>sigmask</i> is NULL, the\nsignal mask is not modified during the <b>pselect</b>()\ncall.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other than the\ndifference in the precision of the <i>timeout</i> argument,\nthe following <b>pselect</b>() call:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">ready =\npselect(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds,\n<br>\ntimeout, &amp;sigmask);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is equivalent\nto <i>atomically</i> executing the following calls:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sigset_t\norigmask;</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">pthread_sigmask(SIG_SETMASK,\n&amp;sigmask, &amp;origmask); <br>\nready = select(nfds, &amp;readfds, &amp;writefds,\n&amp;exceptfds, timeout); <br>\npthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The reason that\n<b>pselect</b>() is needed is that if one wants to wait for\neither a signal or for a file descriptor to become ready,\nthen an atomic test is needed to prevent race conditions.\n(Suppose the signal handler sets a global flag and returns.\nThen a test of this global flag followed by a call of\n<b>select</b>() could hang indefinitely if the signal\narrived just after the test but just before the call. By\ncontrast, <b>pselect</b>() allows one to first block\nsignals, handle the signals that have come in, then call\n<b>pselect</b>() with the desired <i>sigmask</i>, avoiding\nthe race.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\ntimeout</b> <br>\nThe <i>timeout</i> argument for <b>select</b>() is a\nstructure of the following type:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct timeval\n{ <br>\ntime_t tv_sec; /* seconds */ <br>\nsuseconds_t tv_usec; /* microseconds */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\ncorresponding argument for <b>pselect</b>() has the\nfollowing type:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct timespec\n{ <br>\ntime_t tv_sec; /* seconds */ <br>\nlong tv_nsec; /* nanoseconds */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux,\n<b>select</b>() modifies <i>timeout</i> to reflect the\namount of time not slept; most other implementations do not\ndo this. (POSIX.1 permits either behavior.) This causes\nproblems both when Linux code which reads <i>timeout</i> is\nported to other operating systems, and when code is ported\nto Linux that reuses a <i>struct timeval</i> for multiple\n<b>select</b>()s in a loop without reinitializing it.\nConsider <i>timeout</i> to be undefined after\n<b>select</b>() returns.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>select</b>() and <b>pselect</b>() return the number of\nfile descriptors contained in the three returned descriptor\nsets (that is, the total number of bits that are set in\n<i>readfds</i>, <i>writefds</i>, <i>exceptfds</i>). The\nreturn value may be zero if the timeout expired before any\nfile descriptors became ready.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On error, -1 is\nreturned, and <i>errno</i> is set to indicate the error; the\nfile descriptor sets are unmodified, and <i>timeout</i>\nbecomes undefined.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">An invalid file descriptor was\ngiven in one of the sets. (Perhaps a file descriptor that\nwas already closed, or one on which an error has occurred.)\nHowever, see BUGS.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A signal was caught; see <a href=\"https://man.page/7/signal\">signal(7)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>nfds</i> is negative or exceeds the\n<b>RLIMIT_NOFILE</b> resource limit (see\n<a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The value contained within <i>timeout</i> is\ninvalid.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Unable to allocate memory for internal tables.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pselect</b>()\nwas added to Linux in kernel 2.6.16. Prior to this,\n<b>pselect</b>() was emulated in glibc (but see BUGS).</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>select</b>()\nconforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD\n(<b>select</b>() first appeared in 4.2BSD). Generally\nportable to/from non-BSD systems supporting clones of the\nBSD socket layer (including System&nbsp;V variants).\nHowever, note that the System&nbsp;V variant typically sets\nthe timeout variable before returning, but the BSD variant\ndoes not.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pselect</b>()\nis defined in POSIX.1g, and in POSIX.1-2001 and\nPOSIX.1-2008.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">An\n<i>fd_set</i> is a fixed size buffer. Executing\n<b>FD_CLR</b>() or <b>FD_SET</b>() with a value of <i>fd</i>\nthat is negative or is equal to or larger than\n<b>FD_SETSIZE</b> will result in undefined behavior.\nMoreover, POSIX requires <i>fd</i> to be a valid file\ndescriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The operation\nof <b>select</b>() and <b>pselect</b>() is not affected by\nthe <b>O_NONBLOCK</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On some other\nUNIX systems, <b>select</b>() can fail with the error\n<b>EAGAIN</b> if the system fails to allocate\nkernel-internal resources, rather than <b>ENOMEM</b> as\nLinux does. POSIX specifies this error for <a href=\"https://man.page/2/poll\">poll(2)</a>,\nbut not for <b>select</b>(). Portable programs may wish to\ncheck for <b>EAGAIN</b> and loop, just as with\n<b>EINTR</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\nself-pipe trick</b> <br>\nOn systems that lack <b>pselect</b>(), reliable (and more\nportable) signal trapping can be achieved using the\nself-pipe trick. In this technique, a signal handler writes\na byte to a pipe whose other end is monitored by\n<b>select</b>() in the main program. (To avoid possibly\nblocking when writing to a pipe that may be full or reading\nfrom a pipe that may be empty, nonblocking I/O is used when\nreading from and writing to the pipe.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Emulating\nusleep(3)</b> <br>\nBefore the advent of <a href=\"https://man.page/3/usleep\">usleep(3)</a>, some code employed a\ncall to <b>select</b>() with all three sets empty,\n<i>nfds</i> zero, and a non-NULL <i>timeout</i> as a fairly\nportable way to sleep with subsecond precision.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Correspondence\nbetween select() and poll() notifications</b> <br>\nWithin the Linux kernel source, we find the following\ndefinitions which show the correspondence between the\nreadable, writable, and exceptional condition notifications\nof <b>select</b>() and the event notifications provided by\n<a href=\"https://man.page/2/poll\">poll(2)</a> and <a href=\"https://man.page/7/epoll\">epoll(7)</a>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define\nPOLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | <br>\nEPOLLHUP | EPOLLERR) <br>\n/* Ready for reading */ <br>\n#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT |\n<br>\nEPOLLERR) <br>\n/* Ready for writing */ <br>\n#define POLLEX_SET (EPOLLPRI) <br>\n/* Exceptional condition */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Multithreaded\napplications</b> <br>\nIf a file descriptor being monitored by <b>select</b>() is\nclosed in another thread, the result is unspecified. On some\nUNIX systems, <b>select</b>() unblocks and returns, with an\nindication that the file descriptor is ready (a subsequent\nI/O operation will likely fail with an error, unless another\nprocess reopens file descriptor between the time\n<b>select</b>() returned and the I/O operation is\nperformed). On Linux (and some other systems), closing the\nfile descriptor in another thread has no effect on\n<b>select</b>(). In summary, any application that relies on\na particular behavior in this scenario must be considered\nbuggy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nThe Linux kernel allows file descriptor sets of arbitrary\nsize, determining the length of the sets to be checked from\nthe value of <i>nfds</i>. However, in the glibc\nimplementation, the <i>fd_set</i> type is fixed in size. See\nalso BUGS.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>pselect</b>() interface described in this page is\nimplemented by glibc. The underlying Linux system call is\nnamed <b>pselect6</b>(). This system call has somewhat\ndifferent behavior from the glibc wrapper function.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux\n<b>pselect6</b>() system call modifies its <i>timeout</i>\nargument. However, the glibc wrapper function hides this\nbehavior by using a local variable for the timeout argument\nthat is passed to the system call. Thus, the glibc\n<b>pselect</b>() function does not modify its <i>timeout</i>\nargument; this is the behavior required by POSIX.1-2001.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The final\nargument of the <b>pselect6</b>() system call is not a\n<i>sigset_t&nbsp;*</i> pointer, but is instead a structure\nof the form:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct { <br>\nconst kernel_sigset_t *ss; /* Pointer to signal set */ <br>\nsize_t ss_len; /* Size (in bytes) of object <br>\npointed to by 'ss' */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This allows the\nsystem call to obtain both a pointer to the signal set and\nits size, while allowing for the fact that most\narchitectures support a maximum of 6 arguments to a system\ncall. See <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a> for a discussion of the\ndifference between the kernel and libc notion of the signal\nset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Historical\nglibc details</b> <br>\nGlibc 2.0 provided an incorrect version of <b>pselect</b>()\nthat did not take a <i>sigmask</i> argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In glibc\nversions 2.1 to 2.2.1, one must define <b>_GNU_SOURCE</b> in\norder to obtain the declaration of <b>pselect</b>() from\n<i>&lt;sys/select.h&gt;</i>.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX allows an\nimplementation to define an upper limit, advertised via the\nconstant <b>FD_SETSIZE</b>, on the range of file descriptors\nthat can be specified in a file descriptor set. The Linux\nkernel imposes no fixed limit, but the glibc implementation\nmakes <i>fd_set</i> a fixed-size type, with\n<b>FD_SETSIZE</b> defined as 1024, and the <b>FD_*</b>()\nmacros operating according to that limit. To monitor file\ndescriptors greater than 1023, use <a href=\"https://man.page/2/poll\">poll(2)</a> or\n<a href=\"https://man.page/7/epoll\">epoll(7)</a> instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX, <b>select</b>() should check all specified file\ndescriptors in the three file descriptor sets, up to the\nlimit <i>nfds-1</i>. However, the current implementation\nignores any file descriptor in these sets that is greater\nthan the maximum file descriptor number that the process\ncurrently has open. According to POSIX, any such file\ndescriptor that is specified in one of the sets should\nresult in the error <b>EBADF</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting with\nversion 2.1, glibc provided an emulation of <b>pselect</b>()\nthat was implemented using <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a> and\n<b>select</b>(). This implementation remained vulnerable to\nthe very race condition that <b>pselect</b>() was designed\nto prevent. Modern versions of glibc use the (race-free)\n<b>pselect</b>() system call on kernels where it is\nprovided.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux,\n<b>select</b>() may report a socket file descriptor as\n&quot;ready for reading&quot;, while nevertheless a\nsubsequent read blocks. This could for example happen when\ndata has arrived but upon examination has the wrong checksum\nand is discarded. There may be other circumstances in which\na file descriptor is spuriously reported as ready. Thus it\nmay be safer to use <b>O_NONBLOCK</b> on sockets that should\nnot block.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux,\n<b>select</b>() also modifies <i>timeout</i> if the call is\ninterrupted by a signal handler (i.e., the <b>EINTR</b>\nerror return). This is not permitted by POSIX.1. The Linux\n<b>pselect</b>() system call has the same behavior, but the\nglibc wrapper hides this behavior by internally copying the\n<i>timeout</i> to a local variable and passing that variable\nto the system call.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/select.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(void) <br>\n{ <br>\nfd_set rfds; <br>\nstruct timeval tv; <br>\nint retval;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Watch stdin\n(fd 0) to see when it has input. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">FD_ZERO(&amp;rfds);\n<br>\nFD_SET(0, &amp;rfds);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Wait up to\nfive seconds. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">tv.tv_sec = 5;\n<br>\ntv.tv_usec = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">retval =\nselect(1, &amp;rfds, NULL, NULL, &amp;tv); <br>\n/* Don't rely on the value of tv now! */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (retval ==\n-1) <br>\nperror(&quot;select()&quot;); <br>\nelse if (retval) <br>\nprintf(&quot;Data is available now.\\n&quot;); <br>\n/* FD_ISSET(0, &amp;rfds) will be true. */ <br>\nelse <br>\nprintf(&quot;No data within five seconds.\\n&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/accept\">accept(2)</a>,\n<a href=\"https://man.page/2/connect\">connect(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>,\n<a href=\"https://man.page/2/recv\">recv(2)</a>, <a href=\"https://man.page/2/restart_syscall\">restart_syscall(2)</a>, <a href=\"https://man.page/2/send\">send(2)</a>,\n<a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>, <a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/7/epoll\">epoll(7)</a>,\n<a href=\"https://man.page/7/time\">time(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a tutorial\nwith discussion and examples, see <a href=\"https://man.page/2/select_tut\">select_tut(2)</a>.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}