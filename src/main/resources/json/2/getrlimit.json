{"name":"getrlimit","description":"getrlimit, setrlimit, prlimit - get/set resource limits","body":"\n\n<h1 align=\"center\">GETRLIMIT</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">getrlimit,\nsetrlimit, prlimit - get/set resource limits</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/time.h&gt; <br>\n#include &lt;sys/resource.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ngetrlimit(int</b> <i>resource</i><b>, struct rlimit\n*</b><i>rlim</i><b>); <br>\nint setrlimit(int</b> <i>resource</i><b>, const struct\nrlimit *</b><i>rlim</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nprlimit(pid_t</b> <i>pid</i><b>, int</b> <i>resource</i><b>,\nconst struct rlimit *</b><i>new_limit</i><b>, <br>\nstruct rlimit *</b><i>old_limit</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>prlimit</b>():\n_GNU_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>getrlimit</b>() and <b>setrlimit</b>() system calls get\nand set resource limits. Each resource has an associated\nsoft and hard limit, as defined by the <i>rlimit</i>\nstructure:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct rlimit {\n<br>\nrlim_t rlim_cur; /* Soft limit */ <br>\nrlim_t rlim_max; /* Hard limit (ceiling for rlim_cur) */\n<br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The soft limit\nis the value that the kernel enforces for the corresponding\nresource. The hard limit acts as a ceiling for the soft\nlimit: an unprivileged process may set only its soft limit\nto a value in the range from 0 up to the hard limit, and\n(irreversibly) lower its hard limit. A privileged process\n(under Linux: one with the <b>CAP_SYS_RESOURCE</b>\ncapability in the initial user namespace) may make arbitrary\nchanges to either limit value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The value\n<b>RLIM_INFINITY</b> denotes no limit on a resource (both in\nthe structure returned by <b>getrlimit</b>() and in the\nstructure passed to <b>setrlimit</b>()).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>resource</i> argument must be one of: <b><br>\nRLIMIT_AS</b></p>\n\n<p style=\"margin-left:22%;\">This is the maximum size of the\nprocess&rsquo;s virtual memory (address space). The limit is\nspecified in bytes, and is rounded down to the system page\nsize. This limit affects calls to <a href=\"https://man.page/2/brk\">brk(2)</a>,\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>, and <a href=\"https://man.page/2/mremap\">mremap(2)</a>, which fail with the\nerror <b>ENOMEM</b> upon exceeding this limit. In addition,\nautomatic stack expansion fails (and generates a\n<b>SIGSEGV</b> that kills the process if no alternate stack\nhas been made available via <a href=\"https://man.page/2/sigaltstack\">sigaltstack(2)</a>). Since\nthe value is a <i>long</i>, on machines with a 32-bit\n<i>long</i> either this limit is at most 2&nbsp;GiB, or this\nresource is unlimited.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_CORE</b></p>\n\n<p style=\"margin-left:22%;\">This is the maximum size of a\n<i>core</i> file (see <a href=\"https://man.page/5/core\">core(5)</a>) in bytes that the\nprocess may dump. When 0 no core dump files are created.\nWhen nonzero, larger dumps are truncated to this size.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_CPU</b></p>\n\n<p style=\"margin-left:22%;\">This is a limit, in seconds, on\nthe amount of CPU time that the process can consume. When\nthe process reaches the soft limit, it is sent a\n<b>SIGXCPU</b> signal. The default action for this signal is\nto terminate the process. However, the signal can be caught,\nand the handler can return control to the main program. If\nthe process continues to consume CPU time, it will be sent\n<b>SIGXCPU</b> once per second until the hard limit is\nreached, at which time it is sent <b>SIGKILL</b>. (This\nlatter point describes Linux behavior. Implementations vary\nin how they treat processes which continue to consume CPU\ntime after reaching the soft limit. Portable applications\nthat need to catch this signal should perform an orderly\ntermination upon first receipt of <b>SIGXCPU</b>.)</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_DATA</b></p>\n\n<p style=\"margin-left:22%;\">This is the maximum size of the\nprocess&rsquo;s data segment (initialized data,\nuninitialized data, and heap). The limit is specified in\nbytes, and is rounded down to the system page size. This\nlimit affects calls to <a href=\"https://man.page/2/brk\">brk(2)</a>, <a href=\"https://man.page/2/sbrk\">sbrk(2)</a>, and\n(since Linux 4.7) <a href=\"https://man.page/2/mmap\">mmap(2)</a>, which fail with the error\n<b>ENOMEM</b> upon encountering the soft limit of this\nresource.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_FSIZE</b></p>\n\n<p style=\"margin-left:22%;\">This is the maximum size in\nbytes of files that the process may create. Attempts to\nextend a file beyond this limit result in delivery of a\n<b>SIGXFSZ</b> signal. By default, this signal terminates a\nprocess, but a process can catch this signal instead, in\nwhich case the relevant system call (e.g., <a href=\"https://man.page/2/write\">write(2)</a>,\n<a href=\"https://man.page/2/truncate\">truncate(2)</a>) fails with the error <b>EFBIG</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_LOCKS</b> (Linux\n2.4.0 to 2.4.24)</p>\n\n<p style=\"margin-left:22%;\">This is a limit on the combined\nnumber of <a href=\"https://man.page/2/flock\">flock(2)</a> locks and <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> leases\nthat this process may establish.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_MEMLOCK</b></p>\n\n<p style=\"margin-left:22%;\">This is the maximum number of\nbytes of memory that may be locked into RAM. This limit is\nin effect rounded down to the nearest multiple of the system\npage size. This limit affects <a href=\"https://man.page/2/mlock\">mlock(2)</a>,\n<a href=\"https://man.page/2/mlockall\">mlockall(2)</a>, and the <a href=\"https://man.page/2/mmap\">mmap(2)</a> <b>MAP_LOCKED</b>\noperation. Since Linux 2.6.9, it also affects the\n<a href=\"https://man.page/2/shmctl\">shmctl(2)</a> <b>SHM_LOCK</b> operation, where it sets a\nmaximum on the total bytes in shared memory segments (see\n<a href=\"https://man.page/2/shmget\">shmget(2)</a>) that may be locked by the real user ID of\nthe calling process. The <a href=\"https://man.page/2/shmctl\">shmctl(2)</a> <b>SHM_LOCK</b>\nlocks are accounted for separately from the per-process\nmemory locks established by <a href=\"https://man.page/2/mlock\">mlock(2)</a>,\n<a href=\"https://man.page/2/mlockall\">mlockall(2)</a>, and <a href=\"https://man.page/2/mmap\">mmap(2)</a> <b>MAP_LOCKED</b>; a\nprocess can lock bytes up to this limit in each of these two\ncategories.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In Linux\nkernels before 2.6.9, this limit controlled the amount of\nmemory that could be locked by a privileged process. Since\nLinux 2.6.9, no limits are placed on the amount of memory\nthat a privileged process may lock, and this limit instead\ngoverns the amount of memory that an unprivileged process\nmay lock.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_MSGQUEUE</b> (since\nLinux 2.6.8)</p>\n\n<p style=\"margin-left:22%;\">This is a limit on the number\nof bytes that can be allocated for POSIX message queues for\nthe real user ID of the calling process. This limit is\nenforced for <a href=\"https://man.page/3/mq_open\">mq_open(3)</a>. Each message queue that the\nuser creates counts (until it is removed) against this limit\naccording to the formula:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux\n3.5:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">bytes =\nattr.mq_maxmsg * sizeof(struct msg_msg) + <br>\nmin(attr.mq_maxmsg, MQ_PRIO_MAX) * <br>\nsizeof(struct posix_msg_tree_node)+ <br>\n/* For overhead */ <br>\nattr.mq_maxmsg * attr.mq_msgsize; <br>\n/* For message data */</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Linux 3.4 and\nearlier:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">bytes =\nattr.mq_maxmsg * sizeof(struct msg_msg *) + <br>\n/* For overhead */ <br>\nattr.mq_maxmsg * attr.mq_msgsize; <br>\n/* For message data */</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">where\n<i>attr</i> is the <i>mq_attr</i> structure specified as the\nfourth argument to <a href=\"https://man.page/3/mq_open\">mq_open(3)</a>, and the <i>msg_msg</i>\nand <i>posix_msg_tree_node</i> structures are\nkernel-internal structures.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n&quot;overhead&quot; addend in the formula accounts for\noverhead bytes required by the implementation and ensures\nthat the user cannot create an unlimited number of\nzero-length messages (such messages nevertheless each\nconsume some system memory for bookkeeping overhead).</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_NICE</b> (since Linux\n2.6.12, but see BUGS below)</p>\n\n<p style=\"margin-left:22%;\">This specifies a ceiling to\nwhich the process&rsquo;s nice value can be raised using\n<a href=\"https://man.page/2/setpriority\">setpriority(2)</a> or <a href=\"https://man.page/2/nice\">nice(2)</a>. The actual ceiling\nfor the nice value is calculated as\n<i>20&nbsp;-&nbsp;rlim_cur</i>. The useful range for this\nlimit is thus from 1 (corresponding to a nice value of 19)\nto 40 (corresponding to a nice value of -20). This unusual\nchoice of range was necessary because negative numbers\ncannot be specified as resource limit values, since they\ntypically have special meanings. For example,\n<b>RLIM_INFINITY</b> typically is the same as -1. For more\ndetail on the nice value, see <a href=\"https://man.page/7/sched\">sched(7)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_NOFILE</b></p>\n\n<p style=\"margin-left:22%;\">This specifies a value one\ngreater than the maximum file descriptor number that can be\nopened by this process. Attempts (<a href=\"https://man.page/2/open\">open(2)</a>,\n<a href=\"https://man.page/2/pipe\">pipe(2)</a>, <a href=\"https://man.page/2/dup\">dup(2)</a>, etc.) to exceed this limit\nyield the error <b>EMFILE</b>. (Historically, this limit was\nnamed <b>RLIMIT_OFILE</b> on BSD.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux\n4.5, this limit also defines the maximum number of file\ndescriptors that an unprivileged process (one without the\n<b>CAP_SYS_RESOURCE</b> capability) may have &quot;in\nflight&quot; to other processes, by being passed across UNIX\ndomain sockets. This limit applies to the <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>\nsystem call. For further details, see <a href=\"https://man.page/7/unix\">unix(7)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_NPROC</b></p>\n\n<p style=\"margin-left:22%;\">This is a limit on the number\nof extant process (or, more precisely on Linux, threads) for\nthe real user ID of the calling process. So long as the\ncurrent number of processes belonging to this\nprocess&rsquo;s real user ID is greater than or equal to\nthis limit, <a href=\"https://man.page/2/fork\">fork(2)</a> fails with the error\n<b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>RLIMIT_NPROC</b> limit is not enforced for processes that\nhave either the <b>CAP_SYS_ADMIN</b> or the\n<b>CAP_SYS_RESOURCE</b> capability.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_RSS</b></p>\n\n<p style=\"margin-left:22%;\">This is a limit (in bytes) on\nthe process&rsquo;s resident set (the number of virtual\npages resident in RAM). This limit has effect only in Linux\n2.4.x, x &lt; 30, and there affects only calls to\n<a href=\"https://man.page/2/madvise\">madvise(2)</a> specifying <b>MADV_WILLNEED</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_RTPRIO</b> (since\nLinux 2.6.12, but see BUGS)</p>\n\n<p style=\"margin-left:22%;\">This specifies a ceiling on the\nreal-time priority that may be set for this process using\n<a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a> and\n<a href=\"https://man.page/2/sched_setparam\">sched_setparam(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ndetails on real-time scheduling policies, see\n<a href=\"https://man.page/7/sched\">sched(7)</a></p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_RTTIME</b> (since\nLinux 2.6.25)</p>\n\n<p style=\"margin-left:22%;\">This is a limit (in\nmicroseconds) on the amount of CPU time that a process\nscheduled under a real-time scheduling policy may consume\nwithout making a blocking system call. For the purpose of\nthis limit, each time a process makes a blocking system\ncall, the count of its consumed CPU time is reset to zero.\nThe CPU time count is not reset if the process continues\ntrying to use the CPU but is preempted, its time slice\nexpires, or it calls <a href=\"https://man.page/2/sched_yield\">sched_yield(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Upon reaching\nthe soft limit, the process is sent a <b>SIGXCPU</b> signal.\nIf the process catches or ignores this signal and continues\nconsuming CPU time, then <b>SIGXCPU</b> will be generated\nonce each second until the hard limit is reached, at which\npoint the process is sent a <b>SIGKILL</b> signal.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The intended\nuse of this limit is to stop a runaway real-time process\nfrom locking up the system.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For further\ndetails on real-time scheduling policies, see\n<a href=\"https://man.page/7/sched\">sched(7)</a></p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_SIGPENDING</b> (since\nLinux 2.6.8)</p>\n\n<p style=\"margin-left:22%;\">This is a limit on the number\nof signals that may be queued for the real user ID of the\ncalling process. Both standard and real-time signals are\ncounted for the purpose of checking this limit. However, the\nlimit is enforced only for <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>; it is always\npossible to use <a href=\"https://man.page/2/kill\">kill(2)</a> to queue one instance of any\nof the signals that are not already queued to the\nprocess.</p>\n\n<p style=\"margin-left:11%;\"><b>RLIMIT_STACK</b></p>\n\n<p style=\"margin-left:22%;\">This is the maximum size of the\nprocess stack, in bytes. Upon reaching this limit, a\n<b>SIGSEGV</b> signal is generated. To handle this signal, a\nprocess must employ an alternate signal stack\n(<a href=\"https://man.page/2/sigaltstack\">sigaltstack(2)</a>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux\n2.6.23, this limit also determines the amount of space used\nfor the process&rsquo;s command-line arguments and\nenvironment variables; for details, see\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>prlimit()</b>\n<br>\nThe Linux-specific <b>prlimit</b>() system call combines and\nextends the functionality of <b>setrlimit</b>() and\n<b>getrlimit</b>(). It can be used to both set and get the\nresource limits of an arbitrary process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>resource</i> argument has the same meaning as for\n<b>setrlimit</b>() and <b>getrlimit</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<i>new_limit</i> argument is a not NULL, then the\n<i>rlimit</i> structure to which it points is used to set\nnew values for the soft and hard limits for <i>resource</i>.\nIf the <i>old_limit</i> argument is a not NULL, then a\nsuccessful call to <b>prlimit</b>() places the previous soft\nand hard limits for <i>resource</i> in the <i>rlimit</i>\nstructure pointed to by <i>old_limit</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>pid</i>\nargument specifies the ID of the process on which the call\nis to operate. If <i>pid</i> is 0, then the call applies to\nthe calling process. To set or get the resources of a\nprocess other than itself, the caller must have the\n<b>CAP_SYS_RESOURCE</b> capability in the user namespace of\nthe process whose resource limits are being changed, or the\nreal, effective, and saved set user IDs of the target\nprocess must match the real user ID of the caller <i>and</i>\nthe real, effective, and saved set group IDs of the target\nprocess must match the real group ID of the caller.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\nthese system calls return 0. On error, -1 is returned, and\n<i>errno</i> is set appropriately.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">A pointer argument points to a\nlocation outside the accessible address space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The value specified in <i>resource</i> is not valid; or,\nfor <b>setrlimit</b>() or <b>prlimit</b>():\n<i>rlim-&gt;rlim_cur</i> was greater than\n<i>rlim-&gt;rlim_max</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An unprivileged process tried to raise the hard limit;\nthe <b>CAP_SYS_RESOURCE</b> capability is required to do\nthis.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The caller tried to increase the hard\n<b>RLIMIT_NOFILE</b> limit above the maximum defined by\n<i>/proc/sys/fs/nr_open</i> (see <a href=\"https://man.page/5/proc\">proc(5)</a>)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>prlimit</b>()) The calling process did not have\npermission to set limits for the process specified by\n<i>pid</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESRCH</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Could not find a process with the ID specified in\n<i>pid</i>.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>prlimit</b>() system call is available since Linux\n2.6.36. Library support is available since glibc 2.13.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3273101.png\" alt=\"Image grohtml-3273101.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>getrlimit</b>(),\n<b>setrlimit</b>(): POSIX.1-2001, POSIX.1-2008, SVr4,\n4.3BSD.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>prlimit</b>():\nLinux-specific.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>RLIMIT_MEMLOCK</b>\nand <b>RLIMIT_NPROC</b> derive from BSD and are not\nspecified in POSIX.1; they are present on the BSDs and\nLinux, but on few other implementations. <b>RLIMIT_RSS</b>\nderives from BSD and is not specified in POSIX.1; it is\nnevertheless present on most implementations.\n<b>RLIMIT_MSGQUEUE</b>, <b>RLIMIT_NICE</b>,\n<b>RLIMIT_RTPRIO</b>, <b>RLIMIT_RTTIME</b>, and\n<b>RLIMIT_SIGPENDING</b> are Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child process\ncreated via <a href=\"https://man.page/2/fork\">fork(2)</a> inherits its parent&rsquo;s\nresource limits. Resource limits are preserved across\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Resource limits\nare per-process attributes that are shared by all of the\nthreads in a process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Lowering the\nsoft limit for a resource below the process&rsquo;s current\nconsumption of that resource will succeed (but will prevent\nthe process from further increasing its consumption of the\nresource).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One can set the\nresource limits of the shell using the built-in\n<i>ulimit</i> command (<i>limit</i> in <a href=\"https://man.page/1/csh\">csh(1)</a>). The\nshell&rsquo;s resource limits are inherited by the processes\nthat it creates to execute commands.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6.24, the resource limits of any process can be inspected\nvia <i>/proc/[pid]/limits</i>; see <a href=\"https://man.page/5/proc\">proc(5)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Ancient systems\nprovided a <b>vlimit</b>() function with a similar purpose\nto <b>setrlimit</b>(). For backward compatibility, glibc\nalso provides <b>vlimit</b>(). All new applications should\nbe written using <b>setrlimit</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel ABI differences</b> <br>\nSince version 2.13, the glibc <b>getrlimit</b>() and\n<b>setrlimit</b>() wrapper functions no longer invoke the\ncorresponding system calls, but instead employ\n<b>prlimit</b>(), for the reasons described in BUGS.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The name of the\nglibc wrapper function is <b>prlimit</b>(); the underlying\nsystem call is <b>prlimit64</b>().</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In older Linux\nkernels, the <b>SIGXCPU</b> and <b>SIGKILL</b> signals\ndelivered when a process encountered the soft and hard\n<b>RLIMIT_CPU</b> limits were delivered one (CPU) second\nlater than they should have been. This was fixed in kernel\n2.6.8.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In 2.6.x\nkernels before 2.6.17, a <b>RLIMIT_CPU</b> limit of 0 is\nwrongly treated as &quot;no limit&quot; (like\n<b>RLIM_INFINITY</b>). Since Linux 2.6.17, setting a limit\nof 0 does have an effect, but is actually treated as a limit\nof 1 second.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A kernel bug\nmeans that <b>RLIMIT_RTPRIO</b> does not work in kernel\n2.6.12; the problem is fixed in kernel 2.6.13.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In kernel\n2.6.12, there was an off-by-one mismatch between the\npriority ranges returned by <a href=\"https://man.page/2/getpriority\">getpriority(2)</a> and\n<b>RLIMIT_NICE</b>. This had the effect that the actual\nceiling for the nice value was calculated as\n<i>19&nbsp;-&nbsp;rlim_cur</i>. This was fixed in kernel\n2.6.13.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6.12, if a process reaches its soft <b>RLIMIT_CPU</b>\nlimit and has a handler installed for <b>SIGXCPU</b>, then,\nin addition to invoking the signal handler, the kernel\nincreases the soft limit by one second. This behavior\nrepeats if the process continues to consume CPU time, until\nthe hard limit is reached, at which point the process is\nkilled. Other implementations do not change the\n<b>RLIMIT_CPU</b> soft limit in this manner, and the Linux\nbehavior is probably not standards conformant; portable\napplications should avoid relying on this Linux-specific\nbehavior. The Linux-specific <b>RLIMIT_RTTIME</b> limit\nexhibits the same behavior when the soft limit is\nencountered.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Kernels before\n2.4.22 did not diagnose the error <b>EINVAL</b> for\n<b>setrlimit</b>() when <i>rlim-&gt;rlim_cur</i> was greater\nthan <i>rlim-&gt;rlim_max</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux\ndoesn&rsquo;t return an error when an attempt to set\n<b>RLIMIT_CPU</b> has failed, for compatibility reasons.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Representation\nof &quot;large&quot; resource limit values on 32-bit\nplatforms</b> <br>\nThe glibc <b>getrlimit</b>() and <b>setrlimit</b>() wrapper\nfunctions use a 64-bit <i>rlim_t</i> data type, even on\n32-bit platforms. However, the <i>rlim_t</i> data type used\nin the <b>getrlimit</b>() and <b>setrlimit</b>() system\ncalls is a (32-bit) <i>unsigned long</i>. Furthermore, in\nLinux, the kernel represents resource limits on 32-bit\nplatforms as <i>unsigned long</i>. However, a 32-bit data\ntype is not wide enough. The most pertinent limit here is\n<b>RLIMIT_FSIZE</b>, which specifies the maximum size to\nwhich a file can grow: to be useful, this limit must be\nrepresented using a type that is as wide as the type used to\nrepresent file offsets&mdash;that is, as wide as a 64-bit\n<b>off_t</b> (assuming a program compiled with\n<i>_FILE_OFFSET_BITS=64</i>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To work around\nthis kernel limitation, if a program tried to set a resource\nlimit to a value larger than can be represented in a 32-bit\n<i>unsigned long</i>, then the glibc <b>setrlimit</b>()\nwrapper function silently converted the limit value to\n<b>RLIM_INFINITY</b>. In other words, the requested resource\nlimit setting was silently ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since version\n2.13, glibc works around the limitations of the\n<b>getrlimit</b>() and <b>setrlimit</b>() system calls by\nimplementing <b>setrlimit</b>() and <b>getrlimit</b>() as\nwrapper functions that call <b>prlimit</b>().</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow demonstrates the use of <b>prlimit</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\n_GNU_SOURCE <br>\n#define _FILE_OFFSET_BITS 64 <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;time.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/resource.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct rlimit old, new; <br>\nstruct rlimit *newp; <br>\npid_t pid;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (!(argc == 2\n|| argc == 4)) { <br>\nfprintf(stderr, &quot;Usage: %s &lt;pid&gt;\n[&lt;new-soft-limit&gt; &quot; <br>\n&quot;&lt;new-hard-limit&gt;]\\n&quot;, argv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pid =\natoi(argv[1]); /* PID of target process */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">newp = NULL;\n<br>\nif (argc == 4) { <br>\nnew.rlim_cur = atoi(argv[2]); <br>\nnew.rlim_max = atoi(argv[3]); <br>\nnewp = &amp;new; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Set CPU time\nlimit of target process; retrieve and display <br>\nprevious limit */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(prlimit(pid, RLIMIT_CPU, newp, &amp;old) == -1) <br>\nerrExit(&quot;prlimit-1&quot;); <br>\nprintf(&quot;Previous limits: soft=%jd; hard=%jd\\n&quot;,\n<br>\n(intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Retrieve and\ndisplay new CPU time limit */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(prlimit(pid, RLIMIT_CPU, NULL, &amp;old) == -1) <br>\nerrExit(&quot;prlimit-2&quot;); <br>\nprintf(&quot;New limits: soft=%jd; hard=%jd\\n&quot;, <br>\n(intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/prlimit\">prlimit(1)</a>,\n<a href=\"https://man.page/2/dup\">dup(2)</a>, <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, <a href=\"https://man.page/2/fork\">fork(2)</a>,\n<a href=\"https://man.page/2/getrusage\">getrusage(2)</a>, <a href=\"https://man.page/2/mlock\">mlock(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>,\n<a href=\"https://man.page/2/open\">open(2)</a>, <a href=\"https://man.page/2/quotactl\">quotactl(2)</a>, <a href=\"https://man.page/2/sbrk\">sbrk(2)</a>,\n<a href=\"https://man.page/2/shmctl\">shmctl(2)</a>, <a href=\"https://man.page/3/malloc\">malloc(3)</a>, <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>,\n<a href=\"https://man.page/3/ulimit\">ulimit(3)</a>, <a href=\"https://man.page/5/core\">core(5)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/cgroups\">cgroups(7)</a>, <a href=\"https://man.page/7/credentials\">credentials(7)</a>,\n<a href=\"https://man.page/7/signal\">signal(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}