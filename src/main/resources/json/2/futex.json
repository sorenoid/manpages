{"name":"futex","body":"\n\n<h1 align=\"center\">FUTEX</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">futex - fast\nuser-space locking</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;linux/futex.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;sys/time.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>long\nfutex(uint32_t *</b><i>uaddr</i><b>, int</b>\n<i>futex_op</i><b>, uint32_t</b> <i>val</i><b>, <br>\nconst struct timespec *</b><i>timeout</i><b>,</b> /* or:\n<b>uint32_t</b> <i>val2</i> <b>*/ <br>\nuint32_t *</b><i>uaddr2</i><b>, uint32_t</b>\n<i>val3</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nThere is no glibc wrapper for this system call; see\nNOTES.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>futex</b>() system call provides a method for waiting\nuntil a certain condition becomes true. It is typically used\nas a blocking construct in the context of shared-memory\nsynchronization. When using futexes, the majority of the\nsynchronization operations are performed in user space. A\nuser-space program employs the <b>futex</b>() system call\nonly when it is likely that the program has to block for a\nlonger time until the condition becomes true. Other\n<b>futex</b>() operations can be used to wake any processes\nor threads waiting for a particular condition.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A futex is a\n32-bit value&mdash;referred to below as a <i>futex\nword</i>&mdash;whose address is supplied to the\n<b>futex</b>() system call. (Futexes are 32 bits in size on\nall platforms, including 64-bit systems.) All futex\noperations are governed by this value. In order to share a\nfutex between processes, the futex is placed in a region of\nshared memory, created using (for example) <a href=\"https://man.page/2/mmap\">mmap(2)</a> or\n<a href=\"https://man.page/2/shmat\">shmat(2)</a>. (Thus, the futex word may have different\nvirtual addresses in different processes, but these\naddresses all refer to the same location in physical\nmemory.) In a multithreaded program, it is sufficient to\nplace the futex word in a global variable shared by all\nthreads.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When executing\na futex operation that requests to block a thread, the\nkernel will block only if the futex word has the value that\nthe calling thread supplied (as one of the arguments of the\n<b>futex</b>() call) as the expected value of the futex\nword. The loading of the futex word&rsquo;s value, the\ncomparison of that value with the expected value, and the\nactual blocking will happen atomically and will be totally\nordered with respect to concurrent operations performed by\nother threads on the same futex word. Thus, the futex word\nis used to connect the synchronization in user space with\nthe implementation of blocking by the kernel. Analogously to\nan atomic compare-and-exchange operation that potentially\nchanges shared memory, blocking via a futex is an atomic\ncompare-and-block operation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One use of\nfutexes is for implementing locks. The state of the lock\n(i.e., acquired or not acquired) can be represented as an\natomically accessed flag in shared memory. In the\nuncontended case, a thread can access or modify the lock\nstate with atomic instructions, for example atomically\nchanging it from not acquired to acquired using an atomic\ncompare-and-exchange instruction. (Such instructions are\nperformed entirely in user mode, and the kernel maintains no\ninformation about the lock state.) On the other hand, a\nthread may be unable to acquire a lock because it is already\nacquired by another thread. It then may pass the\nlock&rsquo;s flag as a futex word and the value representing\nthe acquired state as the expected value to a <b>futex</b>()\nwait operation. This <b>futex</b>() operation will block if\nand only if the lock is still acquired (i.e., the value in\nthe futex word still matches the &quot;acquired\nstate&quot;). When releasing the lock, a thread has to first\nreset the lock state to not acquired and then execute a\nfutex operation that wakes threads blocked on the lock flag\nused as a futex word (this can be further optimized to avoid\nunnecessary wake-ups). See <a href=\"https://man.page/7/futex\">futex(7)</a> for more detail\non how to use futexes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Besides the\nbasic wait and wake-up futex functionality, there are\nfurther futex operations aimed at supporting more complex\nuse cases.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that no\nexplicit initialization or destruction is necessary to use\nfutexes; the kernel maintains a futex (i.e., the\nkernel-internal implementation artifact) only while\noperations such as <b>FUTEX_WAIT</b>, described below, are\nbeing performed on a particular futex word.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Arguments</b>\n<br>\nThe <i>uaddr</i> argument points to the futex word. On all\nplatforms, futexes are four-byte integers that must be\naligned on a four-byte boundary. The operation to perform on\nthe futex is specified in the <i>futex_op</i> argument;\n<i>val</i> is a value whose meaning and purpose depends on\n<i>futex_op</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The remaining\narguments (<i>timeout</i>, <i>uaddr2</i>, and <i>val3</i>)\nare required only for certain of the futex operations\ndescribed below. Where one of these arguments is not\nrequired, it is ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For several\nblocking operations, the <i>timeout</i> argument is a\npointer to a <i>timespec</i> structure that specifies a\ntimeout for the operation. However, notwithstanding the\nprototype shown above, for some operations, the least\nsignificant four bytes of this argument are instead used as\nan integer whose meaning is determined by the operation. For\nthese operations, the kernel casts the <i>timeout</i> value\nfirst to <i>unsigned long</i>, then to <i>uint32_t</i>, and\nin the remainder of this page, this argument is referred to\nas <i>val2</i> when interpreted in this fashion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Where it is\nrequired, the <i>uaddr2</i> argument is a pointer to a\nsecond futex word that is employed by the operation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\ninterpretation of the final integer argument, <i>val3</i>,\ndepends on the operation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Futex\noperations</b> <br>\nThe <i>futex_op</i> argument consists of two parts: a\ncommand that specifies the operation to be performed,\nbitwise ORed with zero or more options that modify the\nbehaviour of the operation. The options that may be included\nin <i>futex_op</i> are as follows: <b><br>\nFUTEX_PRIVATE_FLAG</b> (since Linux 2.6.22)</p>\n\n<p style=\"margin-left:22%;\">This option bit can be employed\nwith all futex operations. It tells the kernel that the\nfutex is process-private and not shared with another process\n(i.e., it is being used for synchronization only between\nthreads of the same process). This allows the kernel to make\nsome additional performance optimizations.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">As a\nconvenience, <i>&lt;linux/futex.h&gt;</i> defines a set of\nconstants with the suffix <b>_PRIVATE</b> that are\nequivalents of all of the operations listed below, but with\nthe <b>FUTEX_PRIVATE_FLAG</b> ORed into the constant value.\nThus, there are <b>FUTEX_WAIT_PRIVATE</b>,\n<b>FUTEX_WAKE_PRIVATE</b>, and so on.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_CLOCK_REALTIME</b>\n(since Linux 2.6.28)</p>\n\n<p style=\"margin-left:22%;\">This option bit can be employed\nonly with the <b>FUTEX_WAIT_BITSET</b>,\n<b>FUTEX_WAIT_REQUEUE_PI</b>, and (since Linux 4.5)\n<b>FUTEX_WAIT</b> operations.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If this option\nis set, the kernel measures the <i>timeout</i> against the\n<b>CLOCK_REALTIME</b> clock.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If this option\nis not set, the kernel measures the <i>timeout</i> against\nthe <b>CLOCK_MONOTONIC</b> clock.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The operation\nspecified in <i>futex_op</i> is one of the following:\n<b><br>\nFUTEX_WAIT</b> (since Linux 2.6.0)</p>\n\n<p style=\"margin-left:22%;\">This operation tests that the\nvalue at the futex word pointed to by the address\n<i>uaddr</i> still contains the expected value <i>val</i>,\nand if so, then sleeps waiting for a <b>FUTEX_WAKE</b>\noperation on the futex word. The load of the value of the\nfutex word is an atomic memory access (i.e., using atomic\nmachine instructions of the respective architecture). This\nload, the comparison with the expected value, and starting\nto sleep are performed atomically and totally ordered with\nrespect to other futex operations on the same futex word. If\nthe thread starts to sleep, it is considered a waiter on\nthis futex word. If the futex value does not match\n<i>val</i>, then the call fails immediately with the error\n<b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The purpose of\nthe comparison with the expected value is to prevent lost\nwake-ups. If another thread changed the value of the futex\nword after the calling thread decided to block based on the\nprior value, and if the other thread executed a\n<b>FUTEX_WAKE</b> operation (or similar wake-up) after the\nvalue change and before this <b>FUTEX_WAIT</b> operation,\nthen the calling thread will observe the value change and\nwill not start to sleep.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the\n<i>timeout</i> is not NULL, the structure it points to\nspecifies a timeout for the wait. (This interval will be\nrounded up to the system clock granularity, and is\nguaranteed not to expire early.) The timeout is by default\nmeasured according to the <b>CLOCK_MONOTONIC</b> clock, but,\nsince Linux 4.5, the <b>CLOCK_REALTIME</b> clock can be\nselected by specifying <b>FUTEX_CLOCK_REALTIME</b> in\n<i>futex_op</i>. If <i>timeout</i> is NULL, the call blocks\nindefinitely.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>Note</i>:\nfor <b>FUTEX_WAIT</b>, <i>timeout</i> is interpreted as a\n<i>relative</i> value. This differs from other futex\noperations, where <i>timeout</i> is interpreted as an\nabsolute value. To obtain the equivalent of\n<b>FUTEX_WAIT</b> with an absolute timeout, employ\n<b>FUTEX_WAIT_BITSET</b> with <i>val3</i> specified as\n<b>FUTEX_BITSET_MATCH_ANY</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The arguments\n<i>uaddr2</i> and <i>val3</i> are ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAKE</b> (since Linux\n2.6.0)</p>\n\n<p style=\"margin-left:22%;\">This operation wakes at most\n<i>val</i> of the waiters that are waiting (e.g., inside\n<b>FUTEX_WAIT</b>) on the futex word at the address\n<i>uaddr</i>. Most commonly, <i>val</i> is specified as\neither 1 (wake up a single waiter) or <b>INT_MAX</b> (wake\nup all waiters). No guarantee is provided about which\nwaiters are awoken (e.g., a waiter with a higher scheduling\npriority is not guaranteed to be awoken in preference to a\nwaiter with a lower priority).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The arguments\n<i>timeout</i>, <i>uaddr2</i>, and <i>val3</i> are\nignored.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_FD</b> (from Linux\n2.6.0 up to and including Linux 2.6.25)</p>\n\n<p style=\"margin-left:22%;\">This operation creates a file\ndescriptor that is associated with the futex at\n<i>uaddr</i>. The caller must close the returned file\ndescriptor after use. When another process or thread\nperforms a <b>FUTEX_WAKE</b> on the futex word, the file\ndescriptor indicates as being readable with\n<a href=\"https://man.page/2/select\">select(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, and <a href=\"https://man.page/7/epoll\">epoll(7)</a></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The file\ndescriptor can be used to obtain asynchronous notifications:\nif <i>val</i> is nonzero, then, when another process or\nthread executes a <b>FUTEX_WAKE</b>, the caller will receive\nthe signal number that was passed in <i>val</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The arguments\n<i>timeout</i>, <i>uaddr2</i>, and <i>val3</i> are\nignored.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Because it was\ninherently racy, <b>FUTEX_FD</b> has been removed from Linux\n2.6.26 onward.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_REQUEUE</b> (since\nLinux 2.6.0)</p>\n\n<p style=\"margin-left:22%;\">This operation performs the\nsame task as <b>FUTEX_CMP_REQUEUE</b> (see below), except\nthat no check is made using the value in <i>val3</i>. (The\nargument <i>val3</i> is ignored.)</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_CMP_REQUEUE</b> (since\nLinux 2.6.7)</p>\n\n<p style=\"margin-left:22%;\">This operation first checks\nwhether the location <i>uaddr</i> still contains the value\n<i>val3</i>. If not, the operation fails with the error\n<b>EAGAIN</b>. Otherwise, the operation wakes up a maximum\nof <i>val</i> waiters that are waiting on the futex at\n<i>uaddr</i>. If there are more than <i>val</i> waiters,\nthen the remaining waiters are removed from the wait queue\nof the source futex at <i>uaddr</i> and added to the wait\nqueue of the target futex at <i>uaddr2</i>. The <i>val2</i>\nargument specifies an upper limit on the number of waiters\nthat are requeued to the futex at <i>uaddr2</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The load from\n<i>uaddr</i> is an atomic memory access (i.e., using atomic\nmachine instructions of the respective architecture). This\nload, the comparison with <i>val3</i>, and the requeueing of\nany waiters are performed atomically and totally ordered\nwith respect to other operations on the same futex word.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Typical values\nto specify for <i>val</i> are 0 or 1. (Specifying\n<b>INT_MAX</b> is not useful, because it would make the\n<b>FUTEX_CMP_REQUEUE</b> operation equivalent to\n<b>FUTEX_WAKE</b>.) The limit value specified via\n<i>val2</i> is typically either 1 or <b>INT_MAX</b>.\n(Specifying the argument as 0 is not useful, because it\nwould make the <b>FUTEX_CMP_REQUEUE</b> operation equivalent\nto <b>FUTEX_WAIT</b>.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>FUTEX_CMP_REQUEUE</b> operation was added as a\nreplacement for the earlier <b>FUTEX_REQUEUE</b>. The\ndifference is that the check of the value at <i>uaddr</i>\ncan be used to ensure that requeueing happens only under\ncertain conditions, which allows race conditions to be\navoided in certain use cases.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Both\n<b>FUTEX_REQUEUE</b> and <b>FUTEX_CMP_REQUEUE</b> can be\nused to avoid &quot;thundering herd&quot; wake-ups that\ncould occur when using <b>FUTEX_WAKE</b> in cases where all\nof the waiters that are woken need to acquire another futex.\nConsider the following scenario, where multiple waiter\nthreads are waiting on B, a wait queue implemented using a\nfutex:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">lock(A) <br>\nwhile (!check_value(V)) { <br>\nunlock(A); <br>\nblock_on(B); <br>\nlock(A); <br>\n}; <br>\nunlock(A);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If a waker\nthread used <b>FUTEX_WAKE</b>, then all waiters waiting on B\nwould be woken up, and they would all try to acquire lock A.\nHowever, waking all of the threads in this manner would be\npointless because all except one of the threads would\nimmediately block on lock A again. By contrast, a requeue\noperation wakes just one waiter and moves the other waiters\nto lock A, and when the woken waiter unlocks A then the next\nwaiter can proceed.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAKE_OP</b> (since\nLinux 2.6.14)</p>\n\n<p style=\"margin-left:22%;\">This operation was added to\nsupport some user-space use cases where more than one futex\nmust be handled at the same time. The most notable example\nis the implementation of <a href=\"https://man.page/3/pthread_cond_signal\">pthread_cond_signal(3)</a>,\nwhich requires operations on two futexes, the one used to\nimplement the mutex and the one used in the implementation\nof the wait queue associated with the condition variable.\n<b>FUTEX_WAKE_OP</b> allows such cases to be implemented\nwithout leading to high rates of contention and context\nswitching.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>FUTEX_WAKE_OP</b> operation is equivalent to executing\nthe following code atomically and totally ordered with\nrespect to other futex operations on any of the two supplied\nfutex words:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">uint32_t oldval\n= *(uint32_t *) uaddr2; <br>\n*(uint32_t *) uaddr2 = oldval <i>op oparg</i>; <br>\nfutex(uaddr, FUTEX_WAKE, val, 0, 0, 0); <br>\nif (oldval <i>cmp cmparg</i>) <br>\nfutex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In other words,\n<b>FUTEX_WAKE_OP</b> does the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>saves the original value of the futex word at\n<i>uaddr2</i> and performs an operation to modify the value\nof the futex at <i>uaddr2</i>; this is an atomic\nread-modify-write memory access (i.e., using atomic machine\ninstructions of the respective architecture)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>wakes up a maximum of <i>val</i> waiters on the futex\nfor the futex word at <i>uaddr</i>; and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>dependent on the results of a test of the original value\nof the futex word at <i>uaddr2</i>, wakes up a maximum of\n<i>val2</i> waiters on the futex for the futex word at\n<i>uaddr2</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The operation\nand comparison that are to be performed are encoded in the\nbits of the argument <i>val3</i>. Pictorially, the encoding\nis:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">+---+---+-----------+-----------+\n<br>\n|op |cmp| oparg | cmparg | <br>\n+---+---+-----------+-----------+ <br>\n4 4 12 12 &lt;== # of bits</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Expressed in\ncode, the encoding is:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">#define\nFUTEX_OP(op, oparg, cmp, cmparg) \\ <br>\n(((op &amp; 0xf) &lt;&lt; 28) | \\ <br>\n((cmp &amp; 0xf) &lt;&lt; 24) | \\ <br>\n((oparg &amp; 0xfff) &lt;&lt; 12) | \\ <br>\n(cmparg &amp; 0xfff))</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In the above,\n<i>op</i> and <i>cmp</i> are each one of the codes listed\nbelow. The <i>oparg</i> and <i>cmparg</i> components are\nliteral numeric values, except as noted below.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>op</i>\ncomponent has one of the following values:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">FUTEX_OP_SET 0\n/* uaddr2 = oparg; */ <br>\nFUTEX_OP_ADD 1 /* uaddr2 += oparg; */ <br>\nFUTEX_OP_OR 2 /* uaddr2 |= oparg; */ <br>\nFUTEX_OP_ANDN 3 /* uaddr2 &amp;= ~oparg; */ <br>\nFUTEX_OP_XOR 4 /* uaddr2 ^= oparg; */</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In addition,\nbitwise ORing the following value into <i>op</i> causes\n<i>(1&nbsp;&lt;&lt;&nbsp;oparg)</i> to be used as the\noperand:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">FUTEX_OP_ARG_SHIFT\n8 /* Use (1 &lt;&lt; oparg) as operand */</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>cmp</i>\nfield is one of the following:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">FUTEX_OP_CMP_EQ\n0 /* if (oldval == cmparg) wake */ <br>\nFUTEX_OP_CMP_NE 1 /* if (oldval != cmparg) wake */ <br>\nFUTEX_OP_CMP_LT 2 /* if (oldval &lt; cmparg) wake */ <br>\nFUTEX_OP_CMP_LE 3 /* if (oldval &lt;= cmparg) wake */ <br>\nFUTEX_OP_CMP_GT 4 /* if (oldval &gt; cmparg) wake */ <br>\nFUTEX_OP_CMP_GE 5 /* if (oldval &gt;= cmparg) wake */</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The return\nvalue of <b>FUTEX_WAKE_OP</b> is the sum of the number of\nwaiters woken on the futex <i>uaddr</i> plus the number of\nwaiters woken on the futex <i>uaddr2</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAIT_BITSET</b> (since\nLinux 2.6.25)</p>\n\n<p style=\"margin-left:22%;\">This operation is like\n<b>FUTEX_WAIT</b> except that <i>val3</i> is used to provide\na 32-bit bit mask to the kernel. This bit mask, in which at\nleast one bit must be set, is stored in the kernel-internal\nstate of the waiter. See the description of\n<b>FUTEX_WAKE_BITSET</b> for further details.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>timeout</i> is not NULL, the structure it points to\nspecifies an absolute timeout for the wait operation. If\n<i>timeout</i> is NULL, the operation can block\nindefinitely.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>uaddr2</i> argument is ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAKE_BITSET</b> (since\nLinux 2.6.25)</p>\n\n<p style=\"margin-left:22%;\">This operation is the same as\n<b>FUTEX_WAKE</b> except that the <i>val3</i> argument is\nused to provide a 32-bit bit mask to the kernel. This bit\nmask, in which at least one bit must be set, is used to\nselect which waiters should be woken up. The selection is\ndone by a bitwise AND of the &quot;wake&quot; bit mask\n(i.e., the value in <i>val3</i>) and the bit mask which is\nstored in the kernel-internal state of the waiter (the\n&quot;wait&quot; bit mask that is set using\n<b>FUTEX_WAIT_BITSET</b>). All of the waiters for which the\nresult of the AND is nonzero are woken up; the remaining\nwaiters are left sleeping.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The effect of\n<b>FUTEX_WAIT_BITSET</b> and <b>FUTEX_WAKE_BITSET</b> is to\nallow selective wake-ups among multiple waiters that are\nblocked on the same futex. However, note that, depending on\nthe use case, employing this bit-mask multiplexing feature\non a futex can be less efficient than simply using multiple\nfutexes, because employing bit-mask multiplexing requires\nthe kernel to check all waiters on a futex, including those\nthat are not interested in being woken up (i.e., they do not\nhave the relevant bit set in their &quot;wait&quot; bit\nmask).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The constant\n<b>FUTEX_BITSET_MATCH_ANY</b>, which corresponds to all 32\nbits set in the bit mask, can be used as the <i>val3</i>\nargument for <b>FUTEX_WAIT_BITSET</b> and\n<b>FUTEX_WAKE_BITSET</b>. Other than differences in the\nhandling of the <i>timeout</i> argument, the\n<b>FUTEX_WAIT</b> operation is equivalent to\n<b>FUTEX_WAIT_BITSET</b> with <i>val3</i> specified as\n<b>FUTEX_BITSET_MATCH_ANY</b>; that is, allow a wake-up by\nany waker. The <b>FUTEX_WAKE</b> operation is equivalent to\n<b>FUTEX_WAKE_BITSET</b> with <i>val3</i> specified as\n<b>FUTEX_BITSET_MATCH_ANY</b>; that is, wake up any\nwaiter(s).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>uaddr2</i> and <i>timeout</i> arguments are ignored.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Priority-inheritance\nfutexes</b> <br>\nLinux supports priority-inheritance (PI) futexes in order to\nhandle priority-inversion problems that can be encountered\nwith normal futex locks. Priority inversion is the problem\nthat occurs when a high-priority task is blocked waiting to\nacquire a lock held by a low-priority task, while tasks at\nan intermediate priority continuously preempt the\nlow-priority task from the CPU. Consequently, the\nlow-priority task makes no progress toward releasing the\nlock, and the high-priority task remains blocked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Priority\ninheritance is a mechanism for dealing with the\npriority-inversion problem. With this mechanism, when a\nhigh-priority task becomes blocked by a lock held by a\nlow-priority task, the priority of the low-priority task is\ntemporarily raised to that of the high-priority task, so\nthat it is not preempted by any intermediate level tasks,\nand can thus make progress toward releasing the lock. To be\neffective, priority inheritance must be transitive, meaning\nthat if a high-priority task blocks on a lock held by a\nlower-priority task that is itself blocked by a lock held by\nanother intermediate-priority task (and so on, for chains of\narbitrary length), then both of those tasks (or more\ngenerally, all of the tasks in a lock chain) have their\npriorities raised to be the same as the high-priority\ntask.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From a\nuser-space perspective, what makes a futex PI-aware is a\npolicy agreement (described below) between user space and\nthe kernel about the value of the futex word, coupled with\nthe use of the PI-futex operations described below. (Unlike\nthe other futex operations described above, the PI-futex\noperations are designed for the implementation of very\nspecific IPC mechanisms.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The PI-futex\noperations described below differ from the other futex\noperations in that they impose policy on the use of the\nvalue of the futex word:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If the lock is not acquired, the futex word&rsquo;s\nvalue shall be 0.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If the lock is acquired, the futex word&rsquo;s value\nshall be the thread ID (TID; see <a href=\"https://man.page/2/gettid\">gettid(2)</a>) of the\nowning thread.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If the lock is owned and there are threads contending\nfor the lock, then the <b>FUTEX_WAITERS</b> bit shall be set\nin the futex word&rsquo;s value; in other words, this value\nis:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">FUTEX_WAITERS |\nTID</p>\n\n<p style=\"margin-left:15%; margin-top: 1em\">(Note that is\ninvalid for a PI futex word to have no owner and\n<b>FUTEX_WAITERS</b> set.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With this\npolicy in place, a user-space application can acquire an\nunacquired lock or release a lock using atomic instructions\nexecuted in user mode (e.g., a compare-and-swap operation\nsuch as <i>cmpxchg</i> on the x86 architecture). Acquiring a\nlock simply consists of using compare-and-swap to atomically\nset the futex word&rsquo;s value to the caller&rsquo;s TID\nif its previous value was 0. Releasing a lock requires using\ncompare-and-swap to set the futex word&rsquo;s value to 0 if\nthe previous value was the expected TID.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a futex is\nalready acquired (i.e., has a nonzero value), waiters must\nemploy the <b>FUTEX_LOCK_PI</b> operation to acquire the\nlock. If other threads are waiting for the lock, then the\n<b>FUTEX_WAITERS</b> bit is set in the futex value; in this\ncase, the lock owner must employ the <b>FUTEX_UNLOCK_PI</b>\noperation to release the lock.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the cases\nwhere callers are forced into the kernel (i.e., required to\nperform a <b>futex</b>() call), they then deal directly with\na so-called RT-mutex, a kernel locking mechanism which\nimplements the required priority-inheritance semantics.\nAfter the RT-mutex is acquired, the futex value is updated\naccordingly, before the calling thread returns to user\nspace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is important\nto note that the kernel will update the futex word&rsquo;s\nvalue prior to returning to user space. (This prevents the\npossibility of the futex word&rsquo;s value ending up in an\ninvalid state, such as having an owner but the value being\n0, or having waiters but not having the <b>FUTEX_WAITERS</b>\nbit set.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a futex has\nan associated RT-mutex in the kernel (i.e., there are\nblocked waiters) and the owner of the futex/RT-mutex dies\nunexpectedly, then the kernel cleans up the RT-mutex and\nhands it over to the next waiter. This in turn requires that\nthe user-space value is updated accordingly. To indicate\nthat this is required, the kernel sets the\n<b>FUTEX_OWNER_DIED</b> bit in the futex word along with the\nthread ID of the new owner. User space can detect this\nsituation via the presence of the <b>FUTEX_OWNER_DIED</b>\nbit and is then responsible for cleaning up the stale state\nleft over by the dead owner.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PI futexes are\noperated on by specifying one of the values listed below in\n<i>futex_op</i>. Note that the PI futex operations must be\nused as paired operations and are subject to some additional\nrequirements:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\"><b>FUTEX_LOCK_PI</b> and\n<b>FUTEX_TRYLOCK_PI</b> pair with <b>FUTEX_UNLOCK_PI</b>.\n<b>FUTEX_UNLOCK_PI</b> must be called only on a futex owned\nby the calling thread, as defined by the value policy,\notherwise the error <b>EPERM</b> results.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><b>FUTEX_WAIT_REQUEUE_PI</b> pairs with\n<b>FUTEX_CMP_REQUEUE_PI</b>. This must be performed from a\nnon-PI futex to a distinct PI futex (or the error\n<b>EINVAL</b> results). Additionally, <i>val</i> (the number\nof waiters to be woken) must be 1 (or the error\n<b>EINVAL</b> results).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The PI futex\noperations are as follows: <b><br>\nFUTEX_LOCK_PI</b> (since Linux 2.6.18)</p>\n\n<p style=\"margin-left:22%;\">This operation is used after an\nattempt to acquire the lock via an atomic user-mode\ninstruction failed because the futex word has a nonzero\nvalue&mdash;specifically, because it contained the\n(PID-namespace-specific) TID of the lock owner.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The operation\nchecks the value of the futex word at the address\n<i>uaddr</i>. If the value is 0, then the kernel tries to\natomically set the futex value to the caller&rsquo;s TID. If\nthe futex word&rsquo;s value is nonzero, the kernel\natomically sets the <b>FUTEX_WAITERS</b> bit, which signals\nthe futex owner that it cannot unlock the futex in user\nspace atomically by setting the futex value to 0. After\nthat, the kernel:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>Tries to find the thread which is associated with the\nowner TID.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>Creates or reuses kernel state on behalf of the owner.\n(If this is the first waiter, there is no kernel state for\nthis futex, so kernel state is created by locking the\nRT-mutex and the futex owner is made the owner of the\nRT-mutex. If there are existing waiters, then the existing\nstate is reused.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>Attaches the waiter to the futex (i.e., the waiter is\nenqueued on the RT-mutex waiter list).</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If more than\none waiter exists, the enqueueing of the waiter is in\ndescending priority order. (For information on priority\nordering, see the discussion of the <b>SCHED_DEADLINE</b>,\n<b>SCHED_FIFO</b>, and <b>SCHED_RR</b> scheduling policies\nin <a href=\"https://man.page/7/sched\">sched(7)</a>.) The owner inherits either the\nwaiter&rsquo;s CPU bandwidth (if the waiter is scheduled\nunder the <b>SCHED_DEADLINE</b> policy) or the\nwaiter&rsquo;s priority (if the waiter is scheduled under\nthe <b>SCHED_RR</b> or <b>SCHED_FIFO</b> policy). This\ninheritance follows the lock chain in the case of nested\nlocking and performs deadlock detection.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>timeout</i> argument provides a timeout for the lock\nattempt. If <i>timeout</i> is not NULL, the structure it\npoints to specifies an absolute timeout, measured against\nthe <b>CLOCK_REALTIME</b> clock. If <i>timeout</i> is NULL,\nthe operation will block indefinitely.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>uaddr2</i>, <i>val</i>, and <i>val3</i> arguments are\nignored.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_TRYLOCK_PI</b> (since\nLinux 2.6.18)</p>\n\n<p style=\"margin-left:22%;\">This operation tries to acquire\nthe lock at <i>uaddr</i>. It is invoked when a user-space\natomic acquire did not succeed because the futex word was\nnot 0.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Because the\nkernel has access to more state information than user space,\nacquisition of the lock might succeed if performed by the\nkernel in cases where the futex word (i.e., the state\ninformation accessible to use-space) contains stale state\n(<b>FUTEX_WAITERS</b> and/or <b>FUTEX_OWNER_DIED</b>). This\ncan happen when the owner of the futex died. User space\ncannot handle this condition in a race-free manner, but the\nkernel can fix this up and acquire the futex.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>uaddr2</i>, <i>val</i>, <i>timeout</i>, and <i>val3</i>\narguments are ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_UNLOCK_PI</b> (since\nLinux 2.6.18)</p>\n\n<p style=\"margin-left:22%;\">This operation wakes the top\npriority waiter that is waiting in <b>FUTEX_LOCK_PI</b> on\nthe futex address provided by the <i>uaddr</i> argument.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This is called\nwhen the user-space value at <i>uaddr</i> cannot be changed\natomically from a TID (of the owner) to 0.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>uaddr2</i>, <i>val</i>, <i>timeout</i>, and <i>val3</i>\narguments are ignored.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_CMP_REQUEUE_PI</b>\n(since Linux 2.6.31)</p>\n\n<p style=\"margin-left:22%;\">This operation is a PI-aware\nvariant of <b>FUTEX_CMP_REQUEUE</b>. It requeues waiters\nthat are blocked via <b>FUTEX_WAIT_REQUEUE_PI</b> on\n<i>uaddr</i> from a non-PI source futex (<i>uaddr</i>) to a\nPI target futex (<i>uaddr2</i>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">As with\n<b>FUTEX_CMP_REQUEUE</b>, this operation wakes up a maximum\nof <i>val</i> waiters that are waiting on the futex at\n<i>uaddr</i>. However, for <b>FUTEX_CMP_REQUEUE_PI</b>,\n<i>val</i> is required to be 1 (since the main point is to\navoid a thundering herd). The remaining waiters are removed\nfrom the wait queue of the source futex at <i>uaddr</i> and\nadded to the wait queue of the target futex at\n<i>uaddr2</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>val2</i>\nand <i>val3</i> arguments serve the same purposes as for\n<b>FUTEX_CMP_REQUEUE</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAIT_REQUEUE_PI</b>\n(since Linux 2.6.31)</p>\n\n<p style=\"margin-left:22%;\">Wait on a non-PI futex at\n<i>uaddr</i> and potentially be requeued (via a\n<b>FUTEX_CMP_REQUEUE_PI</b> operation in another task) onto\na PI futex at <i>uaddr2</i>. The wait operation on\n<i>uaddr</i> is the same as for <b>FUTEX_WAIT</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The waiter can\nbe removed from the wait on <i>uaddr</i> without requeueing\non <i>uaddr2</i> via a <b>FUTEX_WAKE</b> operation in\nanother task. In this case, the <b>FUTEX_WAIT_REQUEUE_PI</b>\noperation fails with the error <b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>timeout</i> is not NULL, the structure it points to\nspecifies an absolute timeout for the wait operation. If\n<i>timeout</i> is NULL, the operation can block\nindefinitely.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>val3</i>\nargument is ignored.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>FUTEX_WAIT_REQUEUE_PI</b> and <b>FUTEX_CMP_REQUEUE_PI</b>\nwere added to support a fairly specific use case: support\nfor priority-inheritance-aware POSIX threads condition\nvariables. The idea is that these operations should always\nbe paired, in order to ensure that user space and the kernel\nremain in sync. Thus, in the <b>FUTEX_WAIT_REQUEUE_PI</b>\noperation, the user-space application pre-specifies the\ntarget of the requeue that takes place in the\n<b>FUTEX_CMP_REQUEUE_PI</b> operation.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the event of\nan error (and assuming that <b>futex</b>() was invoked via\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>), all operations return -1 and set\n<i>errno</i> to indicate the cause of the error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The return\nvalue on success depends on the operation, as described in\nthe following list: <b><br>\nFUTEX_WAIT</b></p>\n\n<p style=\"margin-left:22%;\">Returns 0 if the caller was\nwoken up. Note that a wake-up can also be caused by common\nfutex usage patterns in unrelated code that happened to have\npreviously used the futex word&rsquo;s memory location\n(e.g., typical futex-based implementations of Pthreads\nmutexes can cause this under some conditions). Therefore,\ncallers should always conservatively assume that a return\nvalue of 0 can mean a spurious wake-up, and use the futex\nword&rsquo;s value (i.e., the user-space synchronization\nscheme) to decide whether to continue to block or not.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAKE</b></p>\n\n<p style=\"margin-left:22%;\">Returns the number of waiters\nthat were woken up.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_FD</b></p>\n\n<p style=\"margin-left:22%;\">Returns the new file descriptor\nassociated with the futex.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_REQUEUE</b></p>\n\n<p style=\"margin-left:22%;\">Returns the number of waiters\nthat were woken up.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_CMP_REQUEUE</b></p>\n\n<p style=\"margin-left:22%;\">Returns the total number of\nwaiters that were woken up or requeued to the futex for the\nfutex word at <i>uaddr2</i>. If this value is greater than\n<i>val</i>, then the difference is the number of waiters\nrequeued to the futex for the futex word at\n<i>uaddr2</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAKE_OP</b></p>\n\n<p style=\"margin-left:22%;\">Returns the total number of\nwaiters that were woken up. This is the sum of the woken\nwaiters on the two futexes for the futex words at\n<i>uaddr</i> and <i>uaddr2</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAIT_BITSET</b></p>\n\n<p style=\"margin-left:22%;\">Returns 0 if the caller was\nwoken up. See <b>FUTEX_WAIT</b> for how to interpret this\ncorrectly in practice.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAKE_BITSET</b></p>\n\n<p style=\"margin-left:22%;\">Returns the number of waiters\nthat were woken up.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_LOCK_PI</b></p>\n\n<p style=\"margin-left:22%;\">Returns 0 if the futex was\nsuccessfully locked.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_TRYLOCK_PI</b></p>\n\n<p style=\"margin-left:22%;\">Returns 0 if the futex was\nsuccessfully locked.</p>\n\n<p style=\"margin-left:11%;\"><b>FUTEX_UNLOCK_PI</b></p>\n\n<p style=\"margin-left:22%;\">Returns 0 if the futex was\nsuccessfully unlocked.</p>\n\n\n<p style=\"margin-left:11%;\"><b>FUTEX_CMP_REQUEUE_PI</b></p>\n\n<p style=\"margin-left:22%;\">Returns the total number of\nwaiters that were woken up or requeued to the futex for the\nfutex word at <i>uaddr2</i>. If this value is greater than\n<i>val</i>, then difference is the number of waiters\nrequeued to the futex for the futex word at\n<i>uaddr2</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>FUTEX_WAIT_REQUEUE_PI</b></p>\n\n<p style=\"margin-left:22%;\">Returns 0 if the caller was\nsuccessfully requeued to the futex for the futex word at\n<i>uaddr2</i>.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">No read access to the memory of\na futex word.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_WAIT</b>, <b>FUTEX_WAIT_BITSET</b>,\n<b>FUTEX_WAIT_REQUEUE_PI</b>) The value pointed to by\n<i>uaddr</i> was not equal to the expected value <i>val</i>\nat the time of the call.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>Note</b>: on\nLinux, the symbolic names <b>EAGAIN</b> and\n<b>EWOULDBLOCK</b> (both of which appear in different parts\nof the kernel futex code) have the same value.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">(<b>FUTEX_CMP_REQUEUE</b>,\n<b>FUTEX_CMP_REQUEUE_PI</b>) The value pointed to by\n<i>uaddr</i> is not equal to the expected value\n<i>val3</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,\n<b>FUTEX_CMP_REQUEUE_PI</b>) The futex owner thread ID of\n<i>uaddr</i> (for <b>FUTEX_CMP_REQUEUE_PI</b>:\n<i>uaddr2</i>) is about to exit, but has not yet handled the\ninternal state cleanup. Try again.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EDEADLK</b></p>\n\n<p style=\"margin-left:22%;\">(<b>FUTEX_LOCK_PI</b>,\n<b>FUTEX_TRYLOCK_PI</b>, <b>FUTEX_CMP_REQUEUE_PI</b>) The\nfutex word at <i>uaddr</i> is already locked by the\ncaller.</p>\n\n<p style=\"margin-left:11%;\"><b>EDEADLK</b></p>\n\n<p style=\"margin-left:22%;\">(<b>FUTEX_CMP_REQUEUE_PI</b>)\nWhile requeueing a waiter to the PI futex for the futex word\nat <i>uaddr2</i>, the kernel detected a deadlock.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A required pointer argument (i.e., <i>uaddr</i>,\n<i>uaddr2</i>, or <i>timeout</i>) did not point to a valid\nuser-space address.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A <b>FUTEX_WAIT</b> or <b>FUTEX_WAIT_BITSET</b>\noperation was interrupted by a signal (see\n<a href=\"https://man.page/7/signal\">signal(7)</a>). In kernels before Linux 2.6.22, this\nerror could also be returned for a spurious wakeup; since\nLinux 2.6.22, this no longer happens.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The operation in <i>futex_op</i> is one of those that\nemploys a timeout, but the supplied <i>timeout</i> argument\nwas invalid (<i>tv_sec</i> was less than zero, or\n<i>tv_nsec</i> was not less than 1,000,000,000).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The operation specified in <i>futex_op</i> employs one\nor both of the pointers <i>uaddr</i> and <i>uaddr2</i>, but\none of these does not point to a valid object&mdash;that is,\nthe address is not four-byte-aligned.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_WAIT_BITSET</b>, <b>FUTEX_WAKE_BITSET</b>) The\nbit mask supplied in <i>val3</i> is zero.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) <i>uaddr</i> equals\n<i>uaddr2</i> (i.e., an attempt was made to requeue to the\nsame futex).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_FD</b>) The signal number supplied in\n<i>val</i> is invalid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_WAKE</b>, <b>FUTEX_WAKE_OP</b>,\n<b>FUTEX_WAKE_BITSET</b>, <b>FUTEX_REQUEUE</b>,\n<b>FUTEX_CMP_REQUEUE</b>) The kernel detected an\ninconsistency between the user-space state at <i>uaddr</i>\nand the kernel state&mdash;that is, it detected a waiter\nwhich waits in <b>FUTEX_LOCK_PI</b> on <i>uaddr</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,\n<b>FUTEX_UNLOCK_PI</b>) The kernel detected an inconsistency\nbetween the user-space state at <i>uaddr</i> and the kernel\nstate. This indicates either state corruption or that the\nkernel found a waiter on <i>uaddr</i> which is waiting via\n<b>FUTEX_WAIT</b> or <b>FUTEX_WAIT_BITSET</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an\ninconsistency between the user-space state at <i>uaddr2</i>\nand the kernel state; that is, the kernel detected a waiter\nwhich waits via <b>FUTEX_WAIT</b> or\n<b>FUTEX_WAIT_BITSET</b> on <i>uaddr2</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an\ninconsistency between the user-space state at <i>uaddr</i>\nand the kernel state; that is, the kernel detected a waiter\nwhich waits via <b>FUTEX_WAIT</b> or\n<b>FUTEX_WAIT_BITESET</b> on <i>uaddr</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an\ninconsistency between the user-space state at <i>uaddr</i>\nand the kernel state; that is, the kernel detected a waiter\nwhich waits on <i>uaddr</i> via <b>FUTEX_LOCK_PI</b>\n(instead of <b>FUTEX_WAIT_REQUEUE_PI</b>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) An attempt was made to\nrequeue a waiter to a futex other than that specified by the\nmatching <b>FUTEX_WAIT_REQUEUE_PI</b> call for that\nwaiter.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The <i>val</i> argument is\nnot 1.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Invalid argument.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_FD</b>) The system-wide limit on the total\nnumber of open files has been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,\n<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel could not allocate\nmemory to hold state information.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Invalid operation specified in <i>futex_op</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <b>FUTEX_CLOCK_REALTIME</b> option was specified in\n<i>futex_op</i>, but the accompanying operation was neither\n<b>FUTEX_WAIT</b>, <b>FUTEX_WAIT_BITSET</b>, nor\n<b>FUTEX_WAIT_REQUEUE_PI</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,\n<b>FUTEX_UNLOCK_PI</b>, <b>FUTEX_CMP_REQUEUE_PI</b>,\n<b>FUTEX_WAIT_REQUEUE_PI</b>) A run-time check determined\nthat the operation is not available. The PI-futex operations\nare not implemented on all architectures and are not\nsupported on some CPU variants.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,\n<b>FUTEX_CMP_REQUEUE_PI</b>) The caller is not allowed to\nattach itself to the futex at <i>uaddr</i> (for\n<b>FUTEX_CMP_REQUEUE_PI</b>: the futex at <i>uaddr2</i>).\n(This may be caused by a state corruption in user\nspace.)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_UNLOCK_PI</b>) The caller does not own the\nlock represented by the futex word.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESRCH</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,\n<b>FUTEX_CMP_REQUEUE_PI</b>) The thread ID in the futex word\nat <i>uaddr</i> does not exist.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESRCH</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The thread ID in the futex\nword at <i>uaddr2</i> does not exist.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ETIMEDOUT</b></p>\n\n<p style=\"margin-left:22%;\">The operation in\n<i>futex_op</i> employed the timeout specified in\n<i>timeout</i>, and the timeout expired before the operation\ncompleted.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Futexes were\nfirst made available in a stable kernel release with Linux\n2.6.0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Initial futex\nsupport was merged in Linux 2.5.7 but with different\nsemantics from what was described above. A four-argument\nsystem call with the semantics described in this page was\nintroduced in Linux 2.5.40. A fifth argument was added in\nLinux 2.5.70, and a sixth argument was added in Linux\n2.6.7.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This system\ncall is Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glibc does not\nprovide a wrapper for this system call; call it using\n<a href=\"https://man.page/2/syscall\">syscall(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Several\nhigher-level programming abstractions are implemented via\nfutexes, including POSIX semaphores and various POSIX\nthreads synchronization mechanisms (mutexes, condition\nvariables, read-write locks, and barriers).</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow demonstrates use of futexes in a program where a\nparent process and a child process use a pair of futexes\nlocated inside a shared anonymous mapping to synchronize\naccess to a shared resource: the terminal. The two processes\neach write <i>nloops</i> (a command-line argument that\ndefaults to 5 if omitted) messages to the terminal and\nemploy a synchronization protocol that ensures that they\nalternate in writing messages. Upon running this program we\nsee output such as the following:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./futex_demo</b> <br>\nParent (18534) 0 <br>\nChild (18535) 0 <br>\nParent (18534) 1 <br>\nChild (18535) 1 <br>\nParent (18534) 2 <br>\nChild (18535) 2 <br>\nParent (18534) 3 <br>\nChild (18535) 3 <br>\nParent (18534) 4 <br>\nChild (18535) 4</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n/* futex_demo.c</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Usage:\nfutex_demo [nloops] <br>\n(Default: 5)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Demonstrate the\nuse of futexes in a program where parent and child <br>\nuse a pair of futexes located inside a shared anonymous\nmapping to <br>\nsynchronize access to a shared resource: the terminal. The\ntwo <br>\nprocesses each write 'num-loops' messages to the terminal\nand employ <br>\na synchronization protocol that ensures that they alternate\nin <br>\nwriting messages. <br>\n*/ <br>\n#define _GNU_SOURCE <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;stdatomic.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/wait.h&gt; <br>\n#include &lt;sys/mman.h&gt; <br>\n#include &lt;sys/syscall.h&gt; <br>\n#include &lt;linux/futex.h&gt; <br>\n#include &lt;sys/time.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static uint32_t\n*futex1, *futex2, *iaddr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\nfutex(uint32_t *uaddr, int futex_op, uint32_t val, <br>\nconst struct timespec *timeout, uint32_t *uaddr2, uint32_t\nval3) <br>\n{ <br>\nreturn syscall(SYS_futex, uaddr, futex_op, val, <br>\ntimeout, uaddr2, val3); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Acquire the\nfutex pointed to by 'futexp': wait for its value to <br>\nbecome 1, and then set the value to 0. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nfwait(uint32_t *futexp) <br>\n{ <br>\nlong s;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/*\natomic_compare_exchange_strong(ptr, oldval, newval) <br>\natomically performs the equivalent of:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (*ptr ==\n*oldval) <br>\n*ptr = newval;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It returns true\nif the test yielded true and *ptr was updated. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while (1) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Is the futex\navailable? */ <br>\nconst uint32_t one = 1; <br>\nif (atomic_compare_exchange_strong(futexp, &amp;one, 0))\n<br>\nbreak; /* Yes */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Futex is not\navailable; wait */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\nfutex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0); <br>\nif (s == -1 &amp;&amp; errno != EAGAIN) <br>\nerrExit(&quot;futex-FUTEX_WAIT&quot;); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Release the\nfutex pointed to by 'futexp': if the futex currently <br>\nhas the value 0, set its value to 1 and the wake any futex\nwaiters, <br>\nso that if the peer is blocked in fwait(), it can proceed.\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nfpost(uint32_t *futexp) <br>\n{ <br>\nlong s;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/*\natomic_compare_exchange_strong() was described <br>\nin comments above */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">const uint32_t\nzero = 0; <br>\nif (atomic_compare_exchange_strong(futexp, &amp;zero, 1)) {\n<br>\ns = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0); <br>\nif (s == -1) <br>\nerrExit(&quot;futex-FUTEX_WAKE&quot;); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\npid_t childPid; <br>\nint nloops;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">setbuf(stdout,\nNULL);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nloops = (argc\n&gt; 1) ? atoi(argv[1]) : 5;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create a\nshared anonymous mapping that will hold the futexes. <br>\nSince the futexes are being shared between processes, we\n<br>\nsubsequently use the &quot;shared&quot; futex operations\n(i.e., not the <br>\nones suffixed &quot;_PRIVATE&quot;) */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">iaddr =\nmmap(NULL, sizeof(*iaddr) * 2, PROT_READ | PROT_WRITE, <br>\nMAP_ANONYMOUS | MAP_SHARED, -1, 0); <br>\nif (iaddr == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">futex1 =\n&amp;iaddr[0]; <br>\nfutex2 = &amp;iaddr[1];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">*futex1 = 0; /*\nState: unavailable */ <br>\n*futex2 = 1; /* State: available */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create a\nchild process that inherits the shared anonymous <br>\nmapping */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">childPid =\nfork(); <br>\nif (childPid == -1) <br>\nerrExit(&quot;fork&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (childPid ==\n0) { /* Child */ <br>\nfor (int j = 0; j &lt; nloops; j++) { <br>\nfwait(futex1); <br>\nprintf(&quot;Child (%jd) %d\\n&quot;, (intmax_t) getpid(),\nj); <br>\nfpost(futex2); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Parent falls\nthrough to here */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; nloops; j++) { <br>\nfwait(futex2); <br>\nprintf(&quot;Parent (%jd) %d\\n&quot;, (intmax_t) getpid(),\nj); <br>\nfpost(futex1); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">wait(NULL);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/get_robust_list\">get_robust_list(2)</a>,\n<a href=\"https://man.page/2/restart_syscall\">restart_syscall(2)</a>,\n<a href=\"https://man.page/3/pthread_mutexattr_getprotocol\">pthread_mutexattr_getprotocol(3)</a>, <a href=\"https://man.page/7/futex\">futex(7)</a>,\n<a href=\"https://man.page/7/sched\">sched(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nkernel source files:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p><i>Documentation/pi-futex.txt</i></p></td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p><i>Documentation/futex-requeue-pi.txt</i></p></td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p><i>Documentation/locking/rt-mutex.txt</i></p></td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p><i>Documentation/locking/rt-mutex-design.txt</i></p></td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p><i>Documentation/robust-futex-ABI.txt</i></p></td>\n<td width=\"23%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Franke, H.,\nRussell, R., and Kirwood, M., 2002. <i>Fuss, Futexes and\nFurwocks: Fast Userlevel Locking in Linux</i> (from\nproceedings of the Ottawa Linux Symposium 2002), <br>\n\n<a href=\"http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf\">http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Hart, D., 2009.\n<i>A futex overview and update</i>,\n<a href=\"http://lwn.net/Articles/360699/\">http://lwn.net/Articles/360699/</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Hart, D. and\nGuniguntala, D., 2009. <i>Requeue-PI: Making Glibc Condvars\nPI-Aware</i> (from proceedings of the 2009 Real-Time Linux\nWorkshop),\n<a href=\"http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf\">http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Drepper, U.,\n2011. <i>Futexes Are Tricky</i>,\n<a href=\"http://www.akkadia.org/drepper/futex.pdf\">http://www.akkadia.org/drepper/futex.pdf</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Futex example\nlibrary, futex-*.tar.bz2 at <br>\n\n<a href=\"ftp://ftp.kernel.org/pub/linux/kernel/people/rusty/\">ftp://ftp.kernel.org/pub/linux/kernel/people/rusty/</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":2}