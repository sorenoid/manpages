{"name":"netdevice","body":"\n\n<h1 align=\"center\">NETDEVICE</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">netdevice -\nlow-level access to Linux network devices</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/ioctl.h&gt; <br>\n#include &lt;net/if.h&gt;</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This man page\ndescribes the sockets interface which is used to configure\nnetwork devices.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux supports\nsome standard ioctls to configure network devices. They can\nbe used on any socket&rsquo;s file descriptor regardless of\nthe family or type. Most of them pass an <i>ifreq</i>\nstructure:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct ifreq {\n<br>\nchar ifr_name[IFNAMSIZ]; /* Interface name */ <br>\nunion { <br>\nstruct sockaddr ifr_addr; <br>\nstruct sockaddr ifr_dstaddr; <br>\nstruct sockaddr ifr_broadaddr; <br>\nstruct sockaddr ifr_netmask; <br>\nstruct sockaddr ifr_hwaddr; <br>\nshort ifr_flags; <br>\nint ifr_ifindex; <br>\nint ifr_metric; <br>\nint ifr_mtu; <br>\nstruct ifmap ifr_map; <br>\nchar ifr_slave[IFNAMSIZ]; <br>\nchar ifr_newname[IFNAMSIZ]; <br>\nchar *ifr_data; <br>\n}; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Normally, the\nuser specifies which device to affect by setting\n<i>ifr_name</i> to the name of the interface. All other\nmembers of the structure may share memory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Ioctls</b>\n<br>\nIf an ioctl is marked as privileged, then using it requires\nan effective user ID of 0 or the <b>CAP_NET_ADMIN</b>\ncapability. If this is not the case, <b>EPERM</b> will be\nreturned. <b><br>\nSIOCGIFNAME</b></p>\n\n<p style=\"margin-left:22%;\">Given the <i>ifr_ifindex</i>,\nreturn the name of the interface in <i>ifr_name</i>. This is\nthe only ioctl which returns its result in\n<i>ifr_name</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFINDEX</b></p>\n\n<p style=\"margin-left:22%;\">Retrieve the interface index of\nthe interface into <i>ifr_ifindex</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFFLAGS</b>,\n<b>SIOCSIFFLAGS</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the active flag word\nof the device. <i>ifr_flags</i> contains a bit mask of the\nfollowing values:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3536621.png\" alt=\"Image grohtml-3536621.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Setting the\nactive flag word is a privileged operation, but any process\nmay read it. <b><br>\nSIOCGIFPFLAGS</b>, <b>SIOCSIFPFLAGS</b></p>\n\n<p style=\"margin-left:22%;\">Get or set extended (private)\nflags for the device. <i>ifr_flags</i> contains a bit mask\nof the following values:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3536622.png\" alt=\"Image grohtml-3536622.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Setting the\nextended (private) interface flags is a privileged\noperation. <b><br>\nSIOCGIFADDR</b>, <b>SIOCSIFADDR</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the address of the\ndevice using <i>ifr_addr</i>. Setting the interface address\nis a privileged operation. For compatibility, only\n<b>AF_INET</b> addresses are accepted or returned.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFDSTADDR</b>,\n<b>SIOCSIFDSTADDR</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the destination\naddress of a point-to-point device using <i>ifr_dstaddr</i>.\nFor compatibility, only <b>AF_INET</b> addresses are\naccepted or returned. Setting the destination address is a\nprivileged operation.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFBRDADDR</b>,\n<b>SIOCSIFBRDADDR</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the broadcast\naddress for a device using <i>ifr_brdaddr</i>. For\ncompatibility, only <b>AF_INET</b> addresses are accepted or\nreturned. Setting the broadcast address is a privileged\noperation.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFNETMASK</b>,\n<b>SIOCSIFNETMASK</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the network mask for\na device using <i>ifr_netmask</i>. For compatibility, only\n<b>AF_INET</b> addresses are accepted or returned. Setting\nthe network mask is a privileged operation.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFMETRIC</b>,\n<b>SIOCSIFMETRIC</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the metric of the\ndevice using <i>ifr_metric</i>. This is currently not\nimplemented; it sets <i>ifr_metric</i> to 0 if you attempt\nto read it and returns <b>EOPNOTSUPP</b> if you attempt to\nset it.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFMTU</b>,\n<b>SIOCSIFMTU</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the MTU (Maximum\nTransfer Unit) of a device using <i>ifr_mtu</i>. Setting the\nMTU is a privileged operation. Setting the MTU to too small\nvalues may cause kernel crashes.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFHWADDR</b>,\n<b>SIOCSIFHWADDR</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the hardware address\nof a device using <i>ifr_hwaddr</i>. The hardware address is\nspecified in a struct <i>sockaddr</i>. <i>sa_family</i>\ncontains the ARPHRD_* device type, <i>sa_data</i> the L2\nhardware address starting from byte 0. Setting the hardware\naddress is a privileged operation.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCSIFHWBROADCAST</b></p>\n\n<p style=\"margin-left:22%;\">Set the hardware broadcast\naddress of a device from <i>ifr_hwaddr</i>. This is a\nprivileged operation.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFMAP</b>,\n<b>SIOCSIFMAP</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the\ninterface&rsquo;s hardware parameters using <i>ifr_map</i>.\nSetting the parameters is a privileged operation.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct ifmap {\n<br>\nunsigned long mem_start; <br>\nunsigned long mem_end; <br>\nunsigned short base_addr; <br>\nunsigned char irq; <br>\nunsigned char dma; <br>\nunsigned char port; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\ninterpretation of the ifmap structure depends on the device\ndriver and the architecture.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCADDMULTI</b>,\n<b>SIOCDELMULTI</b></p>\n\n<p style=\"margin-left:22%;\">Add an address to or delete an\naddress from the device&rsquo;s link layer multicast filters\nusing <i>ifr_hwaddr</i>. These are privileged operations.\nSee also <a href=\"https://man.page/7/packet\">packet(7)</a> for an alternative.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFTXQLEN</b>,\n<b>SIOCSIFTXQLEN</b></p>\n\n<p style=\"margin-left:22%;\">Get or set the transmit queue\nlength of a device using <i>ifr_qlen</i>. Setting the\ntransmit queue length is a privileged operation.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCSIFNAME</b></p>\n\n<p style=\"margin-left:22%;\">Changes the name of the\ninterface specified in <i>ifr_name</i> to\n<i>ifr_newname</i>. This is a privileged operation. It is\nallowed only when the interface is not up.</p>\n\n<p style=\"margin-left:11%;\"><b>SIOCGIFCONF</b></p>\n\n<p style=\"margin-left:22%;\">Return a list of interface\n(network layer) addresses. This currently means only\naddresses of the <b>AF_INET</b> (IPv4) family for\ncompatibility. Unlike the others, this ioctl passes an\n<i>ifconf</i> structure:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct ifconf {\n<br>\nint ifc_len; /* size of buffer */ <br>\nunion { <br>\nchar *ifc_buf; /* buffer address */ <br>\nstruct ifreq *ifc_req; /* array of structures */ <br>\n}; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>ifc_req</i> is NULL, <b>SIOCGIFCONF</b> returns the\nnecessary buffer size in bytes for receiving all available\naddresses in <i>ifc_len</i>. Otherwise, <i>ifc_req</i>\ncontains a pointer to an array of <i>ifreq</i> structures to\nbe filled with all currently active L3 interface addresses.\n<i>ifc_len</i> contains the size of the array in bytes.\nWithin each <i>ifreq</i> structure, <i>ifr_name</i> will\nreceive the interface name, and <i>ifr_addr</i> the address.\nThe actual number of bytes transferred is returned in\n<i>ifc_len</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the size\nspecified by <i>ifc_len</i> is insufficient to store all the\naddresses, the kernel will skip the exceeding ones and\nreturn success. There is no reliable way of detecting this\ncondition once it has occurred. It is therefore recommended\nto either determine the necessary buffer size beforehand by\ncalling <b>SIOCGIFCONF</b> with <i>ifc_req</i> set to NULL,\nor to retry the call with a bigger buffer whenever\n<i>ifc_len</i> upon return differs by less than\n<i>sizeof(struct ifreq)</i> from its original value.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If an error\noccurs accessing the <i>ifconf</i> or <i>ifreq</i>\nstructures, <b>EFAULT</b> will be returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Most protocols\nsupport their own ioctls to configure protocol-specific\ninterface options. See the protocol man pages for a\ndescription. For configuring IP addresses, see\n<a href=\"https://man.page/7/ip\">ip(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nsome devices support private ioctls. These are not described\nhere.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SIOCGIFCONF</b>\nand the other ioctls that accept or return only\n<b>AF_INET</b> socket addresses are IP-specific and perhaps\nshould rather be documented in <a href=\"https://man.page/7/ip\">ip(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The names of\ninterfaces with no addresses or that don&rsquo;t have the\n<b>IFF_RUNNING</b> flag set can be found via\n<i>/proc/net/dev</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Local IPv6 IP\naddresses can be found via <i>/proc/net</i> or via\n<a href=\"https://man.page/7/rtnetlink\">rtnetlink(7)</a>.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">glibc 2.1 is\nmissing the <i>ifr_newname</i> macro in\n<i>&lt;net/if.h&gt;</i>. Add the following to your program\nas a workaround:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#ifndef\nifr_newname <br>\n#define ifr_newname ifr_ifru.ifru_slave <br>\n#endif</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/5/proc\">proc(5)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/ip\">ip(7)</a>,\n<a href=\"https://man.page/7/rtnetlink\">rtnetlink(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}