{"name":"spufs","body":"\n\n<h1 align=\"center\">SPUFS</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">spufs - SPU\nfilesystem</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The SPU\nfilesystem is used on PowerPC machines that implement the\nCell Broadband Engine Architecture in order to access\nSynergistic Processor Units (SPUs).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The filesystem\nprovides a name space similar to POSIX shared memory or\nmessage queues. Users that have write permissions on the\nfilesystem can use <a href=\"https://man.page/2/spu_create\">spu_create(2)</a> to establish SPU\ncontexts under the <b>spufs</b> root directory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Every SPU\ncontext is represented by a directory containing a\npredefined set of files. These files can be used for\nmanipulating the state of the logical SPU. Users can change\npermissions on the files, but can&rsquo;t add or remove\nfiles.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Mount\noptions <br>\nuid=&lt;uid&gt;</b></p>\n\n<p style=\"margin-left:22%;\">Set the user owning the mount\npoint; the default is 0 (root).</p>\n\n<p style=\"margin-left:11%;\"><b>gid=&lt;gid&gt;</b></p>\n\n<p style=\"margin-left:22%;\">Set the group owning the mount\npoint; the default is 0 (root).</p>\n\n<p style=\"margin-left:11%;\"><b>mode=&lt;mode&gt;</b></p>\n\n<p style=\"margin-left:22%;\">Set the mode of the top-level\ndirectory in <b>spufs</b>, as an octal mode string. The\ndefault is 0775.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Files</b>\n<br>\nThe files in <b>spufs</b> mostly follow the standard\nbehavior for regular system calls like <a href=\"https://man.page/2/read\">read(2)</a> or\n<a href=\"https://man.page/2/write\">write(2)</a>, but often support only a subset of the\noperations supported on regular filesystems. This list\ndetails the supported operations and the deviations from the\nstandard behavior described in the respective man pages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All files that\nsupport the <a href=\"https://man.page/2/read\">read(2)</a> operation also support\n<a href=\"https://man.page/2/readv\">readv(2)</a> and all files that support the\n<a href=\"https://man.page/2/write\">write(2)</a> operation also support <a href=\"https://man.page/2/writev\">writev(2)</a>. All\nfiles support the <a href=\"https://man.page/2/access\">access(2)</a> and <a href=\"https://man.page/2/stat\">stat(2)</a> family\nof operations, but for the latter call, the only fields of\nthe returned <i>stat</i> structure that contain reliable\ninformation are <i>st_mode</i>, <i>st_nlink</i>,\n<i>st_uid</i>, and <i>st_gid</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All files\nsupport the <a href=\"https://man.page/2/chmod\">chmod(2)</a>/<a href=\"https://man.page/2/fchmod\">fchmod(2)</a> and\n<a href=\"https://man.page/2/chown\">chown(2)</a>/<a href=\"https://man.page/2/fchown\">fchown(2)</a> operations, but will not be\nable to grant permissions that contradict the possible\noperations (e.g., read access on the <i>wbox</i> file).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The current set\nof files is: <i><br>\n/capabilities</i></p>\n\n<p style=\"margin-left:22%;\">Contains a comma-delimited\nstring representing the capabilities of this SPU context.\nPossible capabilities are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"7%\">\n\n\n<p><b>sched</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"68%\">\n\n\n<p>This context may be scheduled.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"7%\">\n\n\n<p><b>step</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"68%\">\n\n\n<p>This context can be run in single-step mode, for\ndebugging.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">New\ncapabilities flags may be added in the future.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p style=\"margin-top: 1em\"><i>/mem</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">the contents of the local\nstorage memory of the SPU. This can be accessed like a\nregular shared memory file and contains both code and data\nin the address space of the SPU. The possible operations on\nan open <i>mem</i> file are:</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/read\">read(2)</a>,\n<a href=\"https://man.page/2/pread\">pread(2)</a>, <a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/2/pwrite\">pwrite(2)</a>,\n<a href=\"https://man.page/2/lseek\">lseek(2)</a></p>\n\n<p style=\"margin-left:32%;\">These operate as usual, with\nthe exception that <a href=\"https://man.page/2/lseek\">lseek(2)</a>, <a href=\"https://man.page/2/write\">write(2)</a>, and\n<a href=\"https://man.page/2/pwrite\">pwrite(2)</a> are not supported beyond the end of the\nfile. The file size is the size of the local storage of the\nSPU, which is normally 256 kilobytes.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/mmap\">mmap(2)</a></p>\n\n<p style=\"margin-left:32%;\">Mapping <i>mem</i> into the\nprocess address space provides access to the SPU local\nstorage within the process address space. Only\n<b>MAP_SHARED</b> mappings are allowed.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>/regs</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Contains the saved general-purpose registers of the SPU\ncontext. This file contains the 128-bit values of each\nregister, from register 0 to register 127, in order. This\nallows the general-purpose registers to be inspected for\ndebugging.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Reading to or\nwriting from this file requires that the context is\nscheduled out, so use of this file is not recommended in\nnormal program operation.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>regs</i>\nfile is not present on contexts that have been created with\nthe <b>SPU_CREATE_NOSCHED</b> flag.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><i>/mbox</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The first SPU-to-CPU\ncommunication mailbox. This file is read-only and can be\nread in units of 4 bytes. The file can be used only in\nnonblocking mode - even <a href=\"https://man.page/2/poll\">poll(2)</a> cannot be used to\nblock on this file. The only possible operation on an open\n<i>mbox</i> file is:</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/read\">read(2)</a></p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/read\">read(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. If there is no data available in the mailbox\n(i.e., the SPU has not sent a mailbox message), the return\nvalue is set to -1 and <i>errno</i> is set to <b>EAGAIN</b>.\nWhen data has been read successfully, four bytes are placed\nin the data buffer and the value four is returned.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>/ibox</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>The second SPU-to-CPU communication mailbox. This file\nis similar to the first mailbox file, but can be read in\nblocking I/O mode, thus calling <a href=\"https://man.page/2/read\">read(2)</a> on an open\n<i>ibox</i> file will block until the SPU has written data\nto its interrupt mailbox channel (unless the file has been\nopened with <b>O_NONBLOCK</b>, see below). Also,\n<a href=\"https://man.page/2/poll\">poll(2)</a> and similar system calls can be used to\nmonitor for the presence of mailbox data.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The possible\noperations on an open <i>ibox</i> file are: <b><br>\nread</b>(2)</p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/read\">read(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. If there is no data available in the mailbox\nand the file descriptor has been opened with\n<b>O_NONBLOCK</b>, the return value is set to -1 and\n<i>errno</i> is set to <b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If there is no\ndata available in the mailbox and the file descriptor has\nbeen opened without <b>O_NONBLOCK</b>, the call will block\nuntil the SPU writes to its interrupt mailbox channel. When\ndata has been read successfully, four bytes are placed in\nthe data buffer and the value four is returned.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/poll\">poll(2)</a></p>\n\n<p style=\"margin-left:32%;\">Poll on the <i>ibox</i> file\nreturns <i>(POLLIN | POLLRDNORM)</i> whenever data is\navailable for reading.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>/wbox</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>The CPU-to-SPU communication mailbox. It is write-only\nand can be written in units of four bytes. If the mailbox is\nfull, <a href=\"https://man.page/2/write\">write(2)</a> will block, and <a href=\"https://man.page/2/poll\">poll(2)</a> can be\nused to block until the mailbox is available for writing\nagain. The possible operations on an open <i>wbox</i> file\nare:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/write\">write(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. If there is no space available in the mailbox\nand the file descriptor has been opened with\n<b>O_NONBLOCK</b>, the return value is set to -1 and\n<i>errno</i> is set to <b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If there is no\nspace available in the mailbox and the file descriptor has\nbeen opened without <b>O_NONBLOCK</b>, the call will block\nuntil the SPU reads from its PPE (PowerPC Processing\nElement) mailbox channel. When data has been written\nsuccessfully, the system call returns four as its function\nresult.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/poll\">poll(2)</a></p>\n\n<p style=\"margin-left:32%;\">A poll on the <i>wbox</i> file\nreturns <i>(POLLOUT | POLLWRNORM)</i> whenever space is\navailable for writing.</p>\n\n<p style=\"margin-left:11%;\"><i>/mbox_stat</i>,\n<i>/ibox_stat</i>, <i>/wbox_stat</i></p>\n\n<p style=\"margin-left:22%;\">These are read-only files that\ncontain the length of the current queue of each\nmailbox&mdash;that is, how many words can be read from\n<i>mbox</i> or <i>ibox</i> or how many words can be written\nto <i>wbox</i> without blocking. The files can be read only\nin four-byte units and return a big-endian binary integer\nnumber. The only possible operation on an open\n<i>*box_stat</i> file is: <b><br>\nread</b>(2)</p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/read\">read(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. Otherwise, a four-byte value is placed in the\ndata buffer. This value is the number of elements that can\nbe read from (for <i>mbox_stat</i> and <i>ibox_stat</i>) or\nwritten to (for <i>wbox_stat</i>) the respective mailbox\nwithout blocking or returning an <b>EAGAIN</b> error.</p>\n\n<p style=\"margin-left:11%;\"><i>/npc</i>, <i>/decr</i>,\n<i>/decr_status</i>, <i>/spu_tag_mask</i>,\n<i>/event_mask</i>, <i>/event_status</i>, <i><br>\n/srr0</i>, <i>/lslr</i></p>\n\n<p style=\"margin-left:22%;\">Internal registers of the SPU.\nThese files contain an ASCII string representing the hex\nvalue of the specified register. Reads and writes on these\nfiles (except for <i>npc</i>, see below) require that the\nSPU context be scheduled out, so frequent access to these\nfiles is not recommended for normal program operation.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The contents of\nthese files are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>npc</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>Next Program Counter - valid only when the SPU is in a\nstopped state.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>decr</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>SPU Decrementer</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>decr_status</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>Decrementer Status</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>spu_tag_mask</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>MFC tag mask for SPU DMA</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>event_mask</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>Event mask for SPU interrupts</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>event_status</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>Number of SPU events pending (read-only)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>srr0</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>Interrupt Return address register</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"18%\">\n\n\n<p><i>lslr</i></p></td>\n<td width=\"6%\"></td>\n<td width=\"54%\">\n\n\n<p>Local Store Limit Register</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The possible\noperations on these files are: <b><br>\nread</b>(2)</p>\n\n<p style=\"margin-left:32%;\">Reads the current register\nvalue. If the register value is larger than the buffer\npassed to the <a href=\"https://man.page/2/read\">read(2)</a> system call, subsequent reads\nwill continue reading from the same buffer, until the end of\nthe buffer is reached.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">When a complete\nstring has been read, all subsequent read operations will\nreturn zero bytes and a new file descriptor needs to be\nopened to read a new value.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:32%;\">A <a href=\"https://man.page/2/write\">write(2)</a> operation on\nthe file sets the register to the value given in the string.\nThe string is parsed from the beginning until the first\nnonnumeric character or the end of the buffer. Subsequent\nwrites to the same file descriptor overwrite the previous\nsetting.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Except for the\n<i>npc</i> file, these files are not present on contexts\nthat have been created with the <b>SPU_CREATE_NOSCHED</b>\nflag.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>/fpcr</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>This file provides access to the Floating Point Status\nand Control Register (fcpr) as a binary, four-byte file. The\noperations on the <i>fpcr</i> file are:</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/read\">read(2)</a></p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/read\">read(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. Otherwise, a four-byte value is placed in the\ndata buffer; this is the current value of the <i>fpcr</i>\nregister.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/write\">write(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. Otherwise, a four-byte value is copied from\nthe data buffer, updating the value of the <i>fpcr</i>\nregister.</p>\n\n<p style=\"margin-left:11%;\"><i>/signal1</i>,\n<i>/signal2</i></p>\n\n<p style=\"margin-left:22%;\">The files provide access to the\ntwo signal notification channels of an SPU. These are\nread-write files that operate on four-byte words. Writing to\none of these files triggers an interrupt on the SPU. The\nvalue written to the signal files can be read from the SPU\nthrough a channel read or from host user space through the\nfile. After the value has been read by the SPU, it is reset\nto zero. The possible operations on an open <i>signal1</i>\nor <i>signal2</i> file are: <b><br>\nread</b>(2)</p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/read\">read(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. Otherwise, a four-byte value is placed in the\ndata buffer; this is the current value of the specified\nsignal notification register.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:32%;\">If <i>count</i> is smaller than\nfour, <a href=\"https://man.page/2/write\">write(2)</a> returns -1 and sets <i>errno</i> to\n<b>EINVAL</b>. Otherwise, a four-byte value is copied from\nthe data buffer, updating the value of the specified signal\nnotification register. The signal notification register will\neither be replaced with the input data or will be updated to\nthe bitwise OR operation of the old value and the input\ndata, depending on the contents of the <i>signal1_type</i>\nor <i>signal2_type</i> files respectively.</p>\n\n<p style=\"margin-left:11%;\"><i>/signal1_type</i>,\n<i>/signal2_type</i></p>\n\n<p style=\"margin-left:22%;\">These two files change the\nbehavior of the <i>signal1</i> and <i>signal2</i>\nnotification files. They contain a numeric ASCII string\nwhich is read as either &quot;1&quot; or &quot;0&quot;. In\nmode 0 (overwrite), the hardware replaces the contents of\nthe signal channel with the data that is written to it. In\nmode 1 (logical OR), the hardware accumulates the bits that\nare subsequently written to it. The possible operations on\nan open <i>signal1_type</i> or <i>signal2_type</i> file are:\n<b><br>\nread</b>(2)</p>\n\n<p style=\"margin-left:32%;\">When the count supplied to the\n<a href=\"https://man.page/2/read\">read(2)</a> call is shorter than the required length for\nthe digit (plus a newline character), subsequent reads from\nthe same file descriptor will complete the string. When a\ncomplete string has been read, all subsequent read\noperations will return zero bytes and a new file descriptor\nneeds to be opened to read the value again.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:32%;\">A <a href=\"https://man.page/2/write\">write(2)</a> operation on\nthe file sets the register to the value given in the string.\nThe string is parsed from the beginning until the first\nnonnumeric character or the end of the buffer. Subsequent\nwrites to the same file descriptor overwrite the previous\nsetting.</p>\n\n<p style=\"margin-left:11%;\"><i>/mbox_info</i>,\n<i>/ibox_info</i>, <i>/wbox_info</i>, <i>/dma_into</i>,\n<i>/proxydma_info</i></p>\n\n<p style=\"margin-left:22%;\">Read-only files that contain\nthe saved state of the SPU mailboxes and DMA queues. This\nallows the SPU status to be inspected, mainly for debugging.\nThe <i>mbox_info</i> and <i>ibox_info</i> files each contain\nthe four-byte mailbox message that has been written by the\nSPU. If no message has been written to these mailboxes, then\ncontents of these files is undefined. The <i>mbox_stat</i>,\n<i>ibox_stat</i>, and <i>wbox_stat</i> files contain the\navailable message count.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>wbox_info</i> file contains an array of four-byte mailbox\nmessages, which have been sent to the SPU. With current CBEA\nmachines, the array is four items in length, so up to 4 * 4\n= 16 bytes can be read from this file. If any mailbox queue\nentry is empty, then the bytes read at the corresponding\nlocation are undefined.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>dma_info</i> file contains the contents of the SPU MFC\nDMA queue, represented as the following structure:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nspu_dma_info { <br>\nuint64_t dma_info_type; <br>\nuint64_t dma_info_mask; <br>\nuint64_t dma_info_status; <br>\nuint64_t dma_info_stall_and_notify; <br>\nuint64_t dma_info_atomic_command_status; <br>\nstruct mfc_cq_sr dma_info_command_data[16]; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The last member\nof this data structure is the actual DMA queue, containing\n16 entries. The <i>mfc_cq_sr</i> structure is defined\nas:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nmfc_cq_sr { <br>\nuint64_t mfc_cq_data0_RW; <br>\nuint64_t mfc_cq_data1_RW; <br>\nuint64_t mfc_cq_data2_RW; <br>\nuint64_t mfc_cq_data3_RW; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>proxydma_info</i> file contains similar information, but\ndescribes the proxy DMA queue (i.e., DMAs initiated by\nentities outside the SPU) instead. The file is in the\nfollowing format:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nspu_proxydma_info { <br>\nuint64_t proxydma_info_type; <br>\nuint64_t proxydma_info_mask; <br>\nuint64_t proxydma_info_status; <br>\nstruct mfc_cq_sr proxydma_info_command_data[8]; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Accessing these\nfiles requires that the SPU context is scheduled out -\nfrequent use can be inefficient. These files should not be\nused for normal program operation.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">These files are\nnot present on contexts that have been created with the\n<b>SPU_CREATE_NOSCHED</b> flag.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>/cntl</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>This file provides access to the SPU Run Control and SPU\nstatus registers, as an ASCII string. The following\noperations are supported:</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/read\">read(2)</a></p>\n\n<p style=\"margin-left:32%;\">Reads from the <i>cntl</i> file\nwill return an ASCII string with the hex value of the SPU\nStatus register.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:32%;\">Writes to the <i>cntl</i> file\nwill set the context&rsquo;s SPU Run Control register.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>/mfc</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>Provides access to the Memory Flow Controller of the\nSPU. Reading from the file returns the contents of the\nSPU&rsquo;s MFC Tag Status register, and writing to the file\ninitiates a DMA from the MFC. The following operations are\nsupported:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/write\">write(2)</a></p>\n\n<p style=\"margin-left:32%;\">Writes to this file need to be\nin the format of a MFC DMA command, defined as follows:</p>\n\n<p style=\"margin-left:38%; margin-top: 1em\">struct\nmfc_dma_command { <br>\nint32_t pad; /* reserved */ <br>\nuint32_t lsa; /* local storage address */ <br>\nuint64_t ea; /* effective address */ <br>\nuint16_t size; /* transfer size */ <br>\nuint16_t tag; /* command tag */ <br>\nuint16_t class; /* class ID */ <br>\nuint16_t cmd; /* command opcode */ <br>\n};</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Writes are\nrequired to be exactly <i>sizeof(struct mfc_dma_command)</i>\nbytes in size. The command will be sent to the SPU&rsquo;s\nMFC proxy queue, and the tag stored in the kernel (see\nbelow).</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/read\">read(2)</a></p>\n\n<p style=\"margin-left:32%;\">Reads the contents of the tag\nstatus register. If the file is opened in blocking mode\n(i.e., without <b>O_NONBLOCK</b>), then the read will block\nuntil a DMA tag (as performed by a previous write) is\ncomplete. In nonblocking mode, the MFC tag status register\nwill be returned without waiting.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/poll\">poll(2)</a></p>\n\n<p style=\"margin-left:32%;\">Calling <a href=\"https://man.page/2/poll\">poll(2)</a> on the\n<i>mfc</i> file will block until a new DMA can be started\n(by checking for <b>POLLOUT</b>) or until a previously\nstarted DMA (by checking for <b>POLLIN</b>) has been\ncompleted.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>/mss</i>\nProvides access to the MFC MultiSource Synchronization (MSS)\nfacility. By <a href=\"https://man.page/2/mmap\">mmap(2)</a>-ing this file, processes can\naccess the MSS area of the SPU.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The following\noperations are supported:</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/mmap\">mmap(2)</a></p>\n\n<p style=\"margin-left:32%;\">Mapping <b>mss</b> into the\nprocess address space gives access to the SPU MSS area\nwithin the process address space. Only <b>MAP_SHARED</b>\nmappings are allowed.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><i>/psmap</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Provides access to the whole problem-state mapping of\nthe SPU. Applications can use this area to interface to the\nSPU, rather than writing to individual register files in\n<b>spufs</b>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The following\noperations are supported: <b><br>\nmmap</b>(2)</p>\n\n<p style=\"margin-left:32%;\">Mapping <b>psmap</b> gives a\nprocess a direct map of the SPU problem state area. Only\n<b>MAP_SHARED</b> mappings are supported.</p>\n\n<p style=\"margin-left:11%;\"><i>/phys-id</i></p>\n\n<p style=\"margin-left:22%;\">Read-only file containing the\nphysical SPU number that the SPU context is running on. When\nthe context is not running, this file contains the string\n&quot;-1&quot;.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The physical\nSPU number is given by an ASCII hex string.</p>\n\n<p style=\"margin-left:11%;\"><i>/object-id</i></p>\n\n<p style=\"margin-left:22%;\">Allows applications to store\n(or retrieve) a single 64-bit ID into the context. This ID\nis later used by profiling tools to uniquely identify the\ncontext. <b><br>\nwrite</b>(2)</p>\n\n<p style=\"margin-left:32%;\">By writing an ASCII hex value\ninto this file, applications can set the object ID of the\nSPU context. Any previous value of the object ID is\noverwritten.</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/read\">read(2)</a></p>\n\n<p style=\"margin-left:32%;\">Reading this file gives an\nASCII hex string representing the object ID for this SPU\ncontext.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>/etc/fstab</i>\nentry</p>\n\n<p style=\"margin-left:22%;\">none /spu spufs gid=spu 0 0</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/close\">close(2)</a>,\n<a href=\"https://man.page/2/spu_create\">spu_create(2)</a>, <a href=\"https://man.page/2/spu_run\">spu_run(2)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>The Cell\nBroadband Engine Architecture (CBEA) specification</i></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}