{"name":"pkeys","description":"pkeys -\noverview of Memory Protection Keys\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nMemory\nProtection Keys (pkeys) are an extension to existing\npage-based memory permissions. Normal page permissions using\npage tables require expensive system calls and TLB\ninvalidations when changing permissions. Memory Protection\nKeys provide a mechanism for changing protections without\nrequiring modification of the page tables on every\npermission change.\n\nTo use pkeys,\nsoftware must first &quot;tag&quot; a page in the page\ntables with a pkey. After this tag is in place, an\napplication only has to change the contents of a register in\norder to remove write access, or all access to a tagged\npage.\n\nProtection keys\nwork in conjunction with the existing <b>PROT_READ</b>/\n<b>PROT_WRITE</b>/ <b>PROT_EXEC</b> permissions passed to\nsystem calls such as <a href=\"https://man.page/2/mprotect\">mprotect(2)</a> and <a href=\"https://man.page/2/mmap\">mmap(2)</a>,\nbut always act to further restrict these traditional\npermission mechanisms.\n\nIf a process\nperforms an access that violates pkey restrictions, it\nreceives a <b>SIGSEGV</b> signal. See <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>\nfor details of the information available with that\nsignal.\n\nTo use the\npkeys feature, the processor must support it, and the kernel\nmust contain support for the feature on a given processor.\nAs of early 2016 only future Intel x86 processors are\nsupported, and this hardware supports 16 protection keys in\neach process. However, pkey 0 is used as the default key, so\na maximum of 15 are available for actual application use.\nThe default key is assigned to any memory region for which a\npkey has not been explicitly assigned via\n<a href=\"https://man.page/2/pkey_mprotect\">pkey_mprotect(2)</a>.\n\nProtection keys\nhave the potential to add a layer of security and\nreliability to applications. But they have not been\nprimarily designed as a security feature. For instance,\nWRPKRU is a completely unprivileged instruction, so pkeys\nare useless in any case that an attacker controls the PKRU\nregister or can execute arbitrary instructions.\n\nApplications\nshould be very careful to ensure that they do not\n&quot;leak&quot; protection keys. For instance, before\ncalling <a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a>, the application should be sure\nthat no memory has that pkey assigned. If the application\nleft the freed pkey assigned, a future user of that pkey\nmight inadvertently change the permissions of an unrelated\ndata structure, which could impact security or stability.\nThe kernel currently allows in-use pkeys to have\n<a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a> called on them because it would have\nprocessor or memory performance implications to perform the\nadditional checks needed to disallow it. Implementation of\nthe necessary checks is left up to applications.\nApplications may implement these checks by searching the\n<i>/proc/[pid]/smaps</i> file for memory regions with the\npkey assigned. Further details can be found in\n<a href=\"https://man.page/5/proc\">proc(5)</a>.\n\nAny application\nwanting to use protection keys needs to be able to function\nwithout them. They might be unavailable because the hardware\nthat the application runs on does not support them, the\nkernel code does not contain support, the kernel support has\nbeen disabled, or because the keys have all been allocated,\nperhaps by a library the application is using. It is\nrecommended that applications wanting to use protection keys\nshould simply call <a href=\"https://man.page/2/pkey_alloc\">pkey_alloc(2)</a> and test whether the\ncall succeeds, instead of attempting to detect support for\nthe feature in any other way.\n\nAlthough\nunnecessary, hardware support for protection keys may be\nenumerated with the <i>cpuid</i> instruction. Details of how\nto do this can be found in the Intel Software Developers\nManual. The kernel performs this enumeration and exposes the\ninformation in <i>/proc/cpuinfo</i> under the\n&quot;flags&quot; field. The string &quot;pku&quot; in this\nfield indicates hardware support for protection keys and the\nstring &quot;ospke&quot; indicates that the kernel contains\nand has enabled protection keys support.\n\nApplications\nusing threads and protection keys should be especially\ncareful. Threads inherit the protection key rights of the\nparent at the time of the <a href=\"https://man.page/2/clone\">clone(2)</a>, system call.\nApplications should either ensure that their own permissions\nare appropriate for child threads at the time when\n<a href=\"https://man.page/2/clone\">clone(2)</a> is called, or ensure that each child thread\ncan perform its own initialization of protection key\nrights.\n\n<b>Signal\nHandler Behavior</b> <br>\nEach time a signal handler is invoked (including nested\nsignals), the thread is temporarily given a new, default set\nof protection key rights that override the rights from the\ninterrupted context. This means that applications must\nre-establish their desired protection key rights upon\nentering a signal handler if the desired rights differ from\nthe defaults. The rights of any interrupted context are\nrestored when the signal handler returns.\n\nThis signal\nbehavior is unusual and is due to the fact that the x86 PKRU\nregister (which stores protection key access rights) is\nmanaged with the same hardware mechanism (XSAVE) that\nmanages floating-point registers. The signal behavior is the\nsame as that of floating-point registers.\n\n<b>Protection\nKeys system calls</b> <br>\nThe Linux kernel implements the following pkey-related\nsystem calls: <a href=\"https://man.page/2/pkey_mprotect\">pkey_mprotect(2)</a>, <a href=\"https://man.page/2/pkey_alloc\">pkey_alloc(2)</a>,\nand <a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a>.\n\nThe Linux pkey\nsystem calls are available only if the kernel was configured\nand built with the\n<b>CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS</b> option.\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\nThe program\nbelow allocates a page of memory with read and write\npermissions. It then writes some data to the memory and\nsuccessfully reads it back. After that, it attempts to\nallocate a protection key and disallows access to the page\nby using the WRPKRU instruction. It then tries to access the\npage, which we now expect to cause a fatal signal to the\napplication.\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./a.out</b> <br>\nbuffer contains: 73 <br>\nabout to read buffer again... <br>\nSegmentation fault (core dumped)\n\n<b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/syscall.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;sys/mman.h&gt;\n\nstatic inline\nvoid <br>\nwrpkru(unsigned int pkru) <br>\n{ <br>\nunsigned int eax = pkru; <br>\nunsigned int ecx = 0; <br>\nunsigned int edx = 0;\n\nasm\nvolatile(&quot;.byte 0x0f,0x01,0xef\\n\\t&quot; <br>\n: : &quot;a&quot; (eax), &quot;c&quot; (ecx), &quot;d&quot;\n(edx)); <br>\n}\n\nint <br>\npkey_set(int pkey, unsigned long rights, unsigned long\nflags) <br>\n{ <br>\nunsigned int pkru = (rights &lt;&lt; (2 * pkey)); <br>\nreturn wrpkru(pkru); <br>\n}\n\nint <br>\npkey_mprotect(void *ptr, size_t size, unsigned long\norig_prot, <br>\nunsigned long pkey) <br>\n{ <br>\nreturn syscall(SYS_pkey_mprotect, ptr, size, orig_prot,\npkey); <br>\n}\n\nint <br>\npkey_alloc(void) <br>\n{ <br>\nreturn syscall(SYS_pkey_alloc, 0, 0); <br>\n}\n\nint <br>\npkey_free(unsigned long pkey) <br>\n{ <br>\nreturn syscall(SYS_pkey_free, pkey); <br>\n}\n\n#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)\n\nint <br>\nmain(void) <br>\n{ <br>\nint status; <br>\nint pkey; <br>\nint *buffer;\n\n/* <br>\n*Allocate one page of memory <br>\n*/ <br>\nbuffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,\n<br>\nMAP_ANONYMOUS | MAP_PRIVATE, -1, 0); <br>\nif (buffer == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;);\n\n/* <br>\n* Put some random data into the page (still OK to touch)\n<br>\n*/ <br>\n*buffer = __LINE__; <br>\nprintf(&quot;buffer contains: %d\\n&quot;, *buffer);\n\n/* <br>\n* Allocate a protection key: <br>\n*/ <br>\npkey = pkey_alloc(); <br>\nif (pkey == -1) <br>\nerrExit(&quot;pkey_alloc&quot;);\n\n/* <br>\n* Disable access to any memory with &quot;pkey&quot; set,\n<br>\n* even though there is none right now <br>\n*/ <br>\nstatus = pkey_set(pkey, PKEY_DISABLE_ACCESS, 0); <br>\nif (status) <br>\nerrExit(&quot;pkey_set&quot;);\n\n/* <br>\n* Set the protection key on &quot;buffer&quot;. <br>\n* Note that it is still read/write as far as mprotect() is\n<br>\n* concerned and the previous pkey_set() overrides it. <br>\n*/ <br>\nstatus = pkey_mprotect(buffer, getpagesize(), <br>\nPROT_READ | PROT_WRITE, pkey); <br>\nif (status == -1) <br>\nerrExit(&quot;pkey_mprotect&quot;);\n\n\nprintf(&quot;about\nto read buffer again...\\n&quot;);\n\n/* <br>\n* This will crash, because we have disallowed access <br>\n*/ <br>\nprintf(&quot;buffer contains: %d\\n&quot;, *buffer);\n\nstatus =\npkey_free(pkey); <br>\nif (status == -1) <br>\nerrExit(&quot;pkey_free&quot;);\n\n\nexit(EXIT_SUCCESS);\n<br>\n}\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/2/pkey_alloc\">pkey_alloc(2)</a>,\n<a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a>, <a href=\"https://man.page/2/pkey_mprotect\">pkey_mprotect(2)</a>,\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\nThis page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.","body":"\n\n<h1 align=\"center\">PKEYS</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pkeys -\noverview of Memory Protection Keys</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Memory\nProtection Keys (pkeys) are an extension to existing\npage-based memory permissions. Normal page permissions using\npage tables require expensive system calls and TLB\ninvalidations when changing permissions. Memory Protection\nKeys provide a mechanism for changing protections without\nrequiring modification of the page tables on every\npermission change.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To use pkeys,\nsoftware must first &quot;tag&quot; a page in the page\ntables with a pkey. After this tag is in place, an\napplication only has to change the contents of a register in\norder to remove write access, or all access to a tagged\npage.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Protection keys\nwork in conjunction with the existing <b>PROT_READ</b>/\n<b>PROT_WRITE</b>/ <b>PROT_EXEC</b> permissions passed to\nsystem calls such as <a href=\"https://man.page/2/mprotect\">mprotect(2)</a> and <a href=\"https://man.page/2/mmap\">mmap(2)</a>,\nbut always act to further restrict these traditional\npermission mechanisms.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a process\nperforms an access that violates pkey restrictions, it\nreceives a <b>SIGSEGV</b> signal. See <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>\nfor details of the information available with that\nsignal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To use the\npkeys feature, the processor must support it, and the kernel\nmust contain support for the feature on a given processor.\nAs of early 2016 only future Intel x86 processors are\nsupported, and this hardware supports 16 protection keys in\neach process. However, pkey 0 is used as the default key, so\na maximum of 15 are available for actual application use.\nThe default key is assigned to any memory region for which a\npkey has not been explicitly assigned via\n<a href=\"https://man.page/2/pkey_mprotect\">pkey_mprotect(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Protection keys\nhave the potential to add a layer of security and\nreliability to applications. But they have not been\nprimarily designed as a security feature. For instance,\nWRPKRU is a completely unprivileged instruction, so pkeys\nare useless in any case that an attacker controls the PKRU\nregister or can execute arbitrary instructions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Applications\nshould be very careful to ensure that they do not\n&quot;leak&quot; protection keys. For instance, before\ncalling <a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a>, the application should be sure\nthat no memory has that pkey assigned. If the application\nleft the freed pkey assigned, a future user of that pkey\nmight inadvertently change the permissions of an unrelated\ndata structure, which could impact security or stability.\nThe kernel currently allows in-use pkeys to have\n<a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a> called on them because it would have\nprocessor or memory performance implications to perform the\nadditional checks needed to disallow it. Implementation of\nthe necessary checks is left up to applications.\nApplications may implement these checks by searching the\n<i>/proc/[pid]/smaps</i> file for memory regions with the\npkey assigned. Further details can be found in\n<a href=\"https://man.page/5/proc\">proc(5)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Any application\nwanting to use protection keys needs to be able to function\nwithout them. They might be unavailable because the hardware\nthat the application runs on does not support them, the\nkernel code does not contain support, the kernel support has\nbeen disabled, or because the keys have all been allocated,\nperhaps by a library the application is using. It is\nrecommended that applications wanting to use protection keys\nshould simply call <a href=\"https://man.page/2/pkey_alloc\">pkey_alloc(2)</a> and test whether the\ncall succeeds, instead of attempting to detect support for\nthe feature in any other way.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Although\nunnecessary, hardware support for protection keys may be\nenumerated with the <i>cpuid</i> instruction. Details of how\nto do this can be found in the Intel Software Developers\nManual. The kernel performs this enumeration and exposes the\ninformation in <i>/proc/cpuinfo</i> under the\n&quot;flags&quot; field. The string &quot;pku&quot; in this\nfield indicates hardware support for protection keys and the\nstring &quot;ospke&quot; indicates that the kernel contains\nand has enabled protection keys support.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Applications\nusing threads and protection keys should be especially\ncareful. Threads inherit the protection key rights of the\nparent at the time of the <a href=\"https://man.page/2/clone\">clone(2)</a>, system call.\nApplications should either ensure that their own permissions\nare appropriate for child threads at the time when\n<a href=\"https://man.page/2/clone\">clone(2)</a> is called, or ensure that each child thread\ncan perform its own initialization of protection key\nrights.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Signal\nHandler Behavior</b> <br>\nEach time a signal handler is invoked (including nested\nsignals), the thread is temporarily given a new, default set\nof protection key rights that override the rights from the\ninterrupted context. This means that applications must\nre-establish their desired protection key rights upon\nentering a signal handler if the desired rights differ from\nthe defaults. The rights of any interrupted context are\nrestored when the signal handler returns.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This signal\nbehavior is unusual and is due to the fact that the x86 PKRU\nregister (which stores protection key access rights) is\nmanaged with the same hardware mechanism (XSAVE) that\nmanages floating-point registers. The signal behavior is the\nsame as that of floating-point registers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Protection\nKeys system calls</b> <br>\nThe Linux kernel implements the following pkey-related\nsystem calls: <a href=\"https://man.page/2/pkey_mprotect\">pkey_mprotect(2)</a>, <a href=\"https://man.page/2/pkey_alloc\">pkey_alloc(2)</a>,\nand <a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux pkey\nsystem calls are available only if the kernel was configured\nand built with the\n<b>CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS</b> option.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow allocates a page of memory with read and write\npermissions. It then writes some data to the memory and\nsuccessfully reads it back. After that, it attempts to\nallocate a protection key and disallows access to the page\nby using the WRPKRU instruction. It then tries to access the\npage, which we now expect to cause a fatal signal to the\napplication.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./a.out</b> <br>\nbuffer contains: 73 <br>\nabout to read buffer again... <br>\nSegmentation fault (core dumped)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/syscall.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;sys/mman.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static inline\nvoid <br>\nwrpkru(unsigned int pkru) <br>\n{ <br>\nunsigned int eax = pkru; <br>\nunsigned int ecx = 0; <br>\nunsigned int edx = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">asm\nvolatile(&quot;.byte 0x0f,0x01,0xef\\n\\t&quot; <br>\n: : &quot;a&quot; (eax), &quot;c&quot; (ecx), &quot;d&quot;\n(edx)); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\npkey_set(int pkey, unsigned long rights, unsigned long\nflags) <br>\n{ <br>\nunsigned int pkru = (rights &lt;&lt; (2 * pkey)); <br>\nreturn wrpkru(pkru); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\npkey_mprotect(void *ptr, size_t size, unsigned long\norig_prot, <br>\nunsigned long pkey) <br>\n{ <br>\nreturn syscall(SYS_pkey_mprotect, ptr, size, orig_prot,\npkey); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\npkey_alloc(void) <br>\n{ <br>\nreturn syscall(SYS_pkey_alloc, 0, 0); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\npkey_free(unsigned long pkey) <br>\n{ <br>\nreturn syscall(SYS_pkey_free, pkey); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(void) <br>\n{ <br>\nint status; <br>\nint pkey; <br>\nint *buffer;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n*Allocate one page of memory <br>\n*/ <br>\nbuffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,\n<br>\nMAP_ANONYMOUS | MAP_PRIVATE, -1, 0); <br>\nif (buffer == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Put some random data into the page (still OK to touch)\n<br>\n*/ <br>\n*buffer = __LINE__; <br>\nprintf(&quot;buffer contains: %d\\n&quot;, *buffer);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Allocate a protection key: <br>\n*/ <br>\npkey = pkey_alloc(); <br>\nif (pkey == -1) <br>\nerrExit(&quot;pkey_alloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Disable access to any memory with &quot;pkey&quot; set,\n<br>\n* even though there is none right now <br>\n*/ <br>\nstatus = pkey_set(pkey, PKEY_DISABLE_ACCESS, 0); <br>\nif (status) <br>\nerrExit(&quot;pkey_set&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Set the protection key on &quot;buffer&quot;. <br>\n* Note that it is still read/write as far as mprotect() is\n<br>\n* concerned and the previous pkey_set() overrides it. <br>\n*/ <br>\nstatus = pkey_mprotect(buffer, getpagesize(), <br>\nPROT_READ | PROT_WRITE, pkey); <br>\nif (status == -1) <br>\nerrExit(&quot;pkey_mprotect&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;about\nto read buffer again...\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* This will crash, because we have disallowed access <br>\n*/ <br>\nprintf(&quot;buffer contains: %d\\n&quot;, *buffer);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">status =\npkey_free(pkey); <br>\nif (status == -1) <br>\nerrExit(&quot;pkey_free&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/pkey_alloc\">pkey_alloc(2)</a>,\n<a href=\"https://man.page/2/pkey_free\">pkey_free(2)</a>, <a href=\"https://man.page/2/pkey_mprotect\">pkey_mprotect(2)</a>,\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}