{"name":"glob","body":"\n\n<h1 align=\"center\">GLOB</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">glob - globbing\npathnames</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Long ago, in\nUNIX&nbsp;V6, there was a program <i>/etc/glob</i> that\nwould expand wildcard patterns. Soon afterward this became a\nshell built-in.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These days\nthere is also a library routine <a href=\"https://man.page/3/glob\">glob(3)</a> that will\nperform this function for a user program.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The rules are\nas follows (POSIX.2, 3.13).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Wildcard\nmatching</b> <br>\nA string is a wildcard pattern if it contains one of the\ncharacters '?', '*' or '['. Globbing is the operation that\nexpands a wildcard pattern into the list of pathnames\nmatching the pattern. Matching is defined by:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A '?' (not\nbetween brackets) matches any single character.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A '*' (not\nbetween brackets) matches any string, including the empty\nstring.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Character\nclasses</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An expression\n&quot;<i>[...]</i>&quot; where the first character after the\nleading '[' is not an '!' matches a single character, namely\nany of the characters enclosed by the brackets. The string\nenclosed by the brackets cannot be empty; therefore ']' can\nbe allowed between the brackets, provided that it is the\nfirst character. (Thus, &quot;<i>[][!]</i>&quot; matches the\nthree characters '[', ']' and '!'.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Ranges</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is one\nspecial convention: two characters separated by '-' denote a\nrange. (Thus, &quot;<i>[A-Fa-f0-9]</i>&quot; is equivalent\nto &quot;<i>[ABCDEFabcdef0123456789]</i>&quot;.) One may\ninclude '-' in its literal meaning by making it the first or\nlast character between the brackets. (Thus,\n&quot;<i>[]-]</i>&quot; matches just the two characters ']'\nand '-', and &quot;<i>[--0]</i>&quot; matches the three\ncharacters '-', '.', '0', since '/' cannot be matched.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Complementation</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An expression\n&quot;<i>[!...]</i>&quot; matches a single character, namely\nany character that is not matched by the expression obtained\nby removing the first '!' from it. (Thus,\n&quot;<i>[!]a-]</i>&quot; matches any single character\nexcept ']', 'a' and '-'.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One can remove\nthe special meaning of '?', '*' and '[' by preceding them by\na backslash, or, in case this is part of a shell command\nline, enclosing them in quotes. Between brackets these\ncharacters stand for themselves. Thus,\n&quot;<i>[[?*\\]</i>&quot; matches the four characters '[',\n'?', '*' and '\\'.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Pathnames</b>\n<br>\nGlobbing is applied on each of the components of a pathname\nseparately. A '/' in a pathname cannot be matched by a '?'\nor '*' wildcard, or by a range like\n&quot;<i>[.-0]</i>&quot;. A range containing an explicit '/'\ncharacter is syntactically incorrect. (POSIX requires that\nsyntactically incorrect patterns are left unchanged.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a filename\nstarts with a '.', this character must be matched\nexplicitly. (Thus, <i>rm&nbsp;*</i> will not remove\n.profile, and <i>tar&nbsp;c&nbsp;*</i> will not archive all\nyour files; <i>tar&nbsp;c&nbsp;.</i> is better.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Empty\nlists</b> <br>\nThe nice and simple rule given above: &quot;expand a\nwildcard pattern into the list of matching pathnames&quot;\nwas the original UNIX definition. It allowed one to have\npatterns that expand into an empty list, as in</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xv -wait 0\n*.gif *.jpg</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where perhaps\nno *.gif files are present (and this is not an error).\nHowever, POSIX requires that a wildcard pattern is left\nunchanged when it is syntactically incorrect, or the list of\nmatching pathnames is empty. With <i>bash</i> one can force\nthe classical behavior using this command:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">shopt -s\nnullglob</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(Similar\nproblems occur elsewhere. For example, where old scripts\nhave</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">rm `find .\n-name &quot;*~&quot;`</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">new scripts\nrequire</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">rm -f\nnosuchfile `find . -name &quot;*~&quot;`</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">to avoid error\nmessages from <i>rm</i> called with an empty argument\nlist.)</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Regular\nexpressions</b> <br>\nNote that wildcard patterns are not regular expressions,\nalthough they are a bit similar. First of all, they match\nfilenames, rather than text, and secondly, the conventions\nare not the same: for example, in a regular expression '*'\nmeans zero or more copies of the preceding thing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now that\nregular expressions have bracket expressions where the\nnegation is indicated by a '^', POSIX has declared the\neffect of a wildcard pattern &quot;<i>[^...]</i>&quot; to be\nundefined.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Character\nclasses and internationalization</b> <br>\nOf course ranges were originally meant to be ASCII ranges,\nso that &quot;<i>[&nbsp;-%]</i>&quot; stands for\n&quot;<i>[&nbsp;!&quot;#$%]</i>&quot; and\n&quot;<i>[a-z]</i>&quot; stands for &quot;any lowercase\nletter&quot;. Some UNIX implementations generalized this so\nthat a range X-Y stands for the set of characters with code\nbetween the codes for X and for Y. However, this requires\nthe user to know the character coding in use on the local\nsystem, and moreover, is not convenient if the collating\nsequence for the local alphabet differs from the ordering of\nthe character codes. Therefore, POSIX extended the bracket\nnotation greatly, both for wildcard patterns and for regular\nexpressions. In the above we saw three types of items that\ncan occur in a bracket expression: namely (i) the negation,\n(ii) explicit single characters, and (iii) ranges. POSIX\nspecifies ranges in an internationally more useful way and\nadds three more types:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(iii) Ranges\nX-Y comprise all characters that fall between X and Y\n(inclusive) in the current collating sequence as defined by\nthe <b>LC_COLLATE</b> category in the current locale.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(iv) Named\ncharacter classes, like</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[:alnum:]\n[:alpha:] [:blank:] [:cntrl:] <br>\n[:digit:] [:graph:] [:lower:] [:print:] <br>\n[:punct:] [:space:] [:upper:] [:xdigit:]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">so that one can\nsay &quot;<i>[[:lower:]]</i>&quot; instead of\n&quot;<i>[a-z]</i>&quot;, and have things work in Denmark,\ntoo, where there are three letters past 'z' in the alphabet.\nThese character classes are defined by the <b>LC_CTYPE</b>\ncategory in the current locale.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(v) Collating\nsymbols, like &quot;<i>[.ch.]</i>&quot; or\n&quot;<i>[.a-acute.]</i>&quot;, where the string between\n&quot;<i>[.</i>&quot; and &quot;<i>.]</i>&quot; is a\ncollating element defined for the current locale. Note that\nthis may be a multicharacter element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(vi)\nEquivalence class expressions, like\n&quot;<i>[=a=]</i>&quot;, where the string between\n&quot;<i>[=</i>&quot; and &quot;<i>=]</i>&quot; is any\ncollating element from its equivalence class, as defined for\nthe current locale. For example, &quot;<i>[[=a=]]</i>&quot;\nmight be equivalent to\n&quot;<i>[a&aacute;a&auml;&acirc;]</i>&quot;, that is, to\n&quot;<i>[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]</i>&quot;.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/sh\">sh(1)</a>,\n<a href=\"https://man.page/3/fnmatch\">fnmatch(3)</a>, <a href=\"https://man.page/3/glob\">glob(3)</a>, <a href=\"https://man.page/7/locale\">locale(7)</a>,\n<a href=\"https://man.page/7/regex\">regex(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}