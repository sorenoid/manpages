{"name":"bpf-helpers","description":"BPF-HELPERS -\nlist of eBPF helper functions\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nThe extended\nBerkeley Packet Filter (eBPF) subsystem consists in programs\nwritten in a pseudo-assembly language, then attached to one\nof the several kernel hooks and run in reaction of specific\nevents. This framework differs from the older,\n&quot;classic&quot; BPF (or &quot;cBPF&quot;) in several\naspects, one of them being the ability to call special\nfunctions (or &quot;helpers&quot;) from within a program.\nThese functions are restricted to a white-list of helpers\ndefined in the kernel.\n\nThese helpers\nare used by eBPF programs to interact with the system, or\nwith the context in which they work. For instance, they can\nbe used to print debugging messages, to get the time since\nthe system was booted, to interact with eBPF maps, or to\nmanipulate network packets. Since there are several eBPF\nprogram types, and that they do not run in the same context,\neach program type can only call a subset of those\nhelpers.\n\nDue to eBPF\nconventions, a helper can not have more than five\narguments.\n\nInternally,\neBPF programs call directly into the compiled helper\nfunctions without requiring any foreign-function interface.\nAs a result, calling helpers introduces no overhead, thus\noffering excellent performance.\n\nThis document\nis an attempt to list and document the helpers available to\neBPF developers. They are sorted by chronological order (the\noldest helpers in the kernel at the top).\n\n<h2>HELPERS\n<a name=\"HELPERS\"></a>\n</h2>\n\n\n<b>void\n*bpf_map_lookup_elem(struct bpf_map *</b><i>map</i><b>,\nconst void *</b><i>key</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Perform a lookup in <i>map</i>\nfor an entry associated to <i>key</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Map value associated to <i>key</i>, or <b>NULL</b> if no\nentry was found.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_update_elem(struct bpf_map *</b><i>map</i><b>, const\nvoid *</b><i>key</i><b>, const <br>\nvoid *</b><i>value</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Add or update the value of the\nentry associated to <i>key</i> in <i>map</i> with\n<i>value</i>. <i>flags</i> is one of: <b><br>\nBPF_NOEXIST</b>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nnot exist in the map.\n\n<p style=\"margin-left:32%;\"><b>BPF_EXIST</b>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nalready exist in the map.\n\n<p style=\"margin-left:32%;\"><b>BPF_ANY</b>\n\n<p style=\"margin-left:43%;\">No condition on the existence\nof the entry for <i>key</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Flag value\n<b>BPF_NOEXIST</b> cannot be used for maps of types\n<b>BPF_MAP_TYPE_ARRAY</b> or\n<b>BPF_MAP_TYPE_PERCPU_ARRAY</b> (all elements always\nexist), the helper would return an error.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_delete_elem(struct bpf_map *</b><i>map</i><b>, const\nvoid *</b><i>key</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Delete entry with <i>key</i>\nfrom <i>map</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_probe_read(void\n*</b><i>dst</i><b>, u32</b> <i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">For tracing programs, safely\nattempt to read <i>size</i> bytes from kernel space address\n<i>unsafe_ptr</i> and store the data in <i>dst</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Generally, use\n<b>bpf_probe_read_user</b>() or\n<b>bpf_probe_read_kernel</b>() instead.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_ktime_get_ns(void)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return the time elapsed since\nsystem boot, in nanoseconds. Does not include time the\nsystem was suspended. See:\n<b>clock_gettime</b>(<b>CLOCK_MONOTONIC</b>)\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"22%\">\n\n\n<p>Current <i>ktime</i>.</td>\n<td width=\"46%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_trace_printk(const\nchar *</b><i>fmt</i><b>, u32</b> <i>fmt_size</i><b>,\n...)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is a\n&quot;printk()-like&quot; facility for debugging. It prints\na message defined by format <i>fmt</i> (of size\n<i>fmt_size</i>) to file\n<i>/sys/kernel/debug/tracing/trace</i> from DebugFS, if\navailable. It can take up to three additional <b>u64</b>\narguments (as an eBPF helpers, the total number of arguments\nis limited to five).\n\n<p style=\"margin-left:32%; margin-top: 1em\">Each time the\nhelper is called, it appends a line to the trace. Lines are\ndiscarded while <i>/sys/kernel/debug/tracing/trace</i> is\nopen, use <i>/sys/kernel/debug/tracing/trace_pipe</i> to\navoid this. The format of the trace is customizable, and the\nexact output one will get depends on the options set in\n<i>/sys/kernel/debug/tracing/trace_options</i> (see also the\n<i>README</i> file under the same directory). However, it\nusually defaults to something like:\n\n<pre style=\"margin-left:37%; margin-top: 1em\">telnet-470   [001] .N.. 419421.045894: 0x00000001: &lt;formatted msg&gt;</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">In the\nabove:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>telnet</b> is the name of the current task.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>470</b> is the PID of the current task.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>001</b> is the CPU number on which the task is\nrunning. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p>In <b>.N..</b>, each character refers to a set of\noptions (whether irqs are enabled, scheduling options,\nwhether hard/softirqs are running, level of preempt_disabled\nrespectively). <b>N</b> means that <b>TIF_NEED_RESCHED</b>\nand <b>PREEMPT_NEED_RESCHED</b> are set.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>419421.045894</b> is a timestamp.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>0x00000001</b> is a fake value used by BPF for the\ninstruction pointer register.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>&lt;formatted msg&gt;</b> is the message formatted\nwith <i>fmt</i>.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The conversion\nspecifiers supported by <i>fmt</i> are similar, but more\nlimited than for printk(). They are <b>%d</b>, <b>%i</b>,\n<b>%u</b>, <b>%x</b>, <b>%ld</b>, <b>%li</b>, <b>%lu</b>,\n<b>%lx</b>, <b>%lld</b>, <b>%lli</b>, <b>%llu</b>,\n<b>%llx</b>, <b>%p</b>, <b>%s</b>. No modifier (size of\nfield, padding with zeroes, etc.) is available, and the\nhelper will return <b>-EINVAL</b> (but print nothing) if it\nencounters an unknown specifier.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Also, note that\n<b>bpf_trace_printk</b>() is slow, and should only be used\nfor debugging purposes. For this reason, a notice block\n(spanning several lines) is printed to kernel logs and\nstates that the helper should not be used &quot;for\nproduction use&quot; the first time this helper is used (or\nmore precisely, when <b>trace_printk</b>() buffers are\nallocated). For passing values to user space, perf events\nshould be preferred.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">The number of bytes written to\nthe buffer, or a negative error in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_prandom_u32(void)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get a pseudo-random number.\n\n<p style=\"margin-left:32%; margin-top: 1em\">From a security\npoint of view, this helper uses its own pseudo-random\ninternal state, and cannot be used to infer the seed of\nother random functions in the kernel. However, it is\nessential to note that the generator used by the helper is\nnot cryptographically secure.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>A random 32-bit unsigned value.</td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_smp_processor_id(void)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get the SMP (symmetric\nmultiprocessing) processor id. Note that all programs run\nwith preemption disabled, which means that the SMP processor\nid is stable during all the execution of the program.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The SMP id of the processor running the program.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_store_bytes(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, const void <br>\n*</b><i>from</i><b>, u32</b> <i>len</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Store <i>len</i> bytes from\naddress <i>from</i> into the packet associated to\n<i>skb</i>, at <i>offset</i>. <i>flags</i> are a combination\nof <b>BPF_F_RECOMPUTE_CSUM</b> (automatically recompute the\nchecksum for the packet after storing the bytes) and\n<b>BPF_F_INVALIDATE_HASH</b> (set\n<i>skb</i><b>-&gt;hash</b>, <i>skb</i><b>-&gt;swhash</b> and\n<i>skb</i><b>-&gt;l4hash</b> to 0).\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_l3_csum_replace(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b>\n<i><br>\nto</i><b>, u64</b> <i>size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Recompute the layer 3 (e.g. IP)\nchecksum for the packet associated to <i>skb</i>.\nComputation is incremental, so the helper must know the\nformer value of the header field that was modified\n(<i>from</i>), the new value of this field (<i>to</i>), and\nthe number of bytes (2 or 4) for this field, stored in\n<i>size</i>. Alternatively, it is possible to store the\ndifference between the previous and the new values of the\nheader field in <i>to</i>, by setting <i>from</i> and\n<i>size</i> to 0. For both methods, <i>offset</i> indicates\nthe location of the IP checksum within the packet.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks in combination with <b>bpf_csum_diff</b>(), which does\nnot update the checksum in-place, but offers more\nflexibility and can handle sizes larger than 2 or 4 for the\nchecksum to update.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_l4_csum_replace(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b>\n<i><br>\nto</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Recompute the layer 4 (e.g.\nTCP, UDP or ICMP) checksum for the packet associated to\n<i>skb</i>. Computation is incremental, so the helper must\nknow the former value of the header field that was modified\n(<i>from</i>), the new value of this field (<i>to</i>), and\nthe number of bytes (2 or 4) for this field, stored on the\nlowest four bits of <i>flags</i>. Alternatively, it is\npossible to store the difference between the previous and\nthe new values of the header field in <i>to</i>, by setting\n<i>from</i> and the four lowest bits of <i>flags</i> to 0.\nFor both methods, <i>offset</i> indicates the location of\nthe IP checksum within the packet. In addition to the size\nof the field, <i>flags</i> can be added (bitwise OR) actual\nflags. With <b>BPF_F_MARK_MANGLED_0</b>, a null checksum is\nleft untouched (unless <b>BPF_F_MARK_ENFORCE</b> is added as\nwell), and for updates resulting in a null checksum the\nvalue is set to <b>CSUM_MANGLED_0</b> instead. Flag\n<b>BPF_F_PSEUDO_HDR</b> indicates the checksum is to be\ncomputed against a pseudo-header.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks in combination with <b>bpf_csum_diff</b>(), which does\nnot update the checksum in-place, but offers more\nflexibility and can handle sizes larger than 2 or 4 for the\nchecksum to update.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_tail_call(void\n*</b><i>ctx</i><b>, struct bpf_map\n*</b><i>prog_array_map</i><b>, u32</b> <i><br>\nindex</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This special helper is used to\ntrigger a &quot;tail call&quot;, or in other words, to jump\ninto another eBPF program. The same stack frame is used (but\nvalues on stack and in registers for the caller are not\naccessible to the callee). This mechanism allows for program\nchaining, either for raising the maximum number of available\neBPF instructions, or to execute given programs in\nconditional blocks. For security reasons, there is an upper\nlimit to the number of successive tail calls that can be\nperformed.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Upon call of\nthis helper, the program attempts to jump into a program\nreferenced at index <i>index</i> in <i>prog_array_map</i>, a\nspecial map of type <b>BPF_MAP_TYPE_PROG_ARRAY</b>, and\npasses <i>ctx</i>, a pointer to the context.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the call\nsucceeds, the kernel immediately runs the first instruction\nof the new program. This is not a function call, and it\nnever returns to the previous program. If the call fails,\nthen the helper has no effect, and the caller continues to\nrun its subsequent instructions. A call can fail if the\ndestination program for the jump does not exist (i.e.\n<i>index</i> is superior to the number of entries in\n<i>prog_array_map</i>), or if the maximum number of tail\ncalls has been reached for this chain of programs. This\nlimit is defined in the kernel by the macro\n<b>MAX_TAIL_CALL_CNT</b> (not accessible to user space),\nwhich is currently set to 32.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_clone_redirect(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>ifindex</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Clone and redirect the packet\nassociated to <i>skb</i> to another net device of index\n<i>ifindex</i>. Both ingress and egress interfaces can be\nused for redirection. The <b>BPF_F_INGRESS</b> value in\n<i>flags</i> is used to make the distinction (ingress path\nis selected if the flag is present, egress path otherwise).\nThis is the only flag supported for now.\n\n<p style=\"margin-left:32%; margin-top: 1em\">In comparison\nwith <b>bpf_redirect</b>() helper,\n<b>bpf_clone_redirect</b>() has the associated cost of\nduplicating the packet buffer, but this can be executed out\nof the eBPF program. Conversely, <b>bpf_redirect</b>() is\nmore efficient, but it is handled through an action code\nwhere the redirection happens only after the eBPF program\nhas returned.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_pid_tgid(void)</b>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 64-bit integer containing the current tgid and pid,\nand created as such: <i>current_task</i><b>-&gt;tgid\n&lt;&lt; 32 |</b> <i>current_task</i><b>-&gt;pid</b>.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_uid_gid(void)</b>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 64-bit integer containing the current GID and UID, and\ncreated as such: <i>current_gid</i> <b>&lt;&lt; 32 |</b>\n<i>current_uid</i>. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_current_comm(void *</b><i>buf</i><b>, u32</b>\n<i>size_of_buf</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Copy the <b>comm</b> attribute\nof the current task into <i>buf</i> of <i>size_of_buf</i>.\nThe <b>comm</b> attribute contains the name of the\nexecutable (excluding the path) for the current task. The\n<i>size_of_buf</i> must be strictly positive. On success,\nthe helper makes sure that the <i>buf</i> is NUL-terminated.\nOn failure, it is filled with zeroes.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_cgroup_classid(struct sk_buff\n*</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Retrieve the classid for the\ncurrent task, i.e. for the net_cls cgroup to which\n<i>skb</i> belongs.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used on TC egress path, but not on ingress.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The net_cls\ncgroup provides an interface to tag network packets based on\na user-provided identifier for all traffic coming from the\ntasks belonging to the related cgroup. See also the related\nkernel documentation, available from the Linux sources in\nfile\n<i>Documentation/admin-guide/cgroup-v1/net_cls.rst</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The Linux\nkernel has two versions for cgroups: there are cgroups v1\nand cgroups v2. Both are available to users, who can use a\nmixture of them, but note that the net_cls cgroup is for\ncgroup v1 only. This makes it incompatible with BPF programs\nrun on cgroups, which is a cgroup-v2-only feature (a socket\ncan only hold data for one version of cgroups at a\ntime).\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_CGROUP_NET_CLASSID</b> configuration option set to\n&quot;<b>y</b>&quot; or to &quot;<b>m</b>&quot;.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The classid, or 0 for the default unconfigured\nclassid. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_vlan_push(struct sk_buff *</b><i>skb</i><b>,\n__be16</b> <i>vlan_proto</i><b>, u16</b> <i><br>\nvlan_tci</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Push a <i>vlan_tci</i> (VLAN\ntag control information) of protocol <i>vlan_proto</i> to\nthe packet associated to <i>skb</i>, then update the\nchecksum. Note that if <i>vlan_proto</i> is different from\n<b>ETH_P_8021Q</b> and <b>ETH_P_8021AD</b>, it is considered\nto be <b>ETH_P_8021Q</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_skb_vlan_pop(struct\nsk_buff *</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Pop a VLAN header from the\npacket associated to <i>skb</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_get_tunnel_key(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_tunnel_key <br>\n*</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get tunnel metadata. This\nhelper takes a pointer <i>key</i> to an empty <b>struct\nbpf_tunnel_key</b> of <b>size</b>, that will be filled with\ntunnel metadata for the packet associated to <i>skb</i>. The\n<i>flags</i> can be set to <b>BPF_F_TUNINFO_IPV6</b>, which\nindicates that the tunnel is based on IPv6 protocol instead\nof IPv4.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <b>struct\nbpf_tunnel_key</b> is an object that generalizes the\nprincipal parameters used by various tunneling protocols\ninto a single struct. This way, it can be used to easily\nmake a decision based on the contents of the encapsulation\nheader, &quot;summarized&quot; in this struct. In\nparticular, it holds the IP address of the remote end (IPv4\nor IPv6, depending on the case) in\n<i>key</i><b>-&gt;remote_ipv4</b> or\n<i>key</i><b>-&gt;remote_ipv6</b>. Also, this struct exposes\nthe <i>key</i><b>-&gt;tunnel_id</b>, which is generally\nmapped to a VNI (Virtual Network Identifier), making it\nprogrammable together with the\n<b>bpf_skb_set_tunnel_key</b>() helper.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Let's imagine\nthat the following code is part of a program attached to the\nTC ingress interface, on one end of a GRE tunnel, and is\nsupposed to filter out all messages coming from remote ends\nwith IPv4 address other than 10.0.0.1:\n<pre style=\"margin-left:37%; margin-top: 1em\">int ret;\nstruct bpf_tunnel_key key = {};\n\nret = bpf_skb_get_tunnel_key(skb, &amp;key, sizeof(key), 0);\nif (ret &lt; 0)\n        return TC_ACT_SHOT;     // drop packet\n\nif (key.remote_ipv4 != 0x0a000001)\n        return TC_ACT_SHOT;     // drop packet\n\nreturn TC_ACT_OK;               // accept packet</pre>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This interface\ncan also be used with all encapsulation devices that can\noperate in &quot;collect metadata&quot; mode: instead of\nhaving one network device per specific configuration, the\n&quot;collect metadata&quot; mode only requires a single\ndevice where the configuration can be extracted from this\nhelper.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This can be\nused together with various tunnels such as VXLan, Geneve,\nGRE or IP in IP (IPIP).\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_set_tunnel_key(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_tunnel_key <br>\n*</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Populate tunnel metadata for\npacket associated to <i>skb.</i> The tunnel metadata is set\nto the contents of <i>key</i>, of <i>size</i>. The\n<i>flags</i> can be set to a combination of the following\nvalues: <b><br>\nBPF_F_TUNINFO_IPV6</b>\n\n<p style=\"margin-left:43%;\">Indicate that the tunnel is\nbased on IPv6 protocol instead of IPv4.\n\n<p style=\"margin-left:32%;\"><b>BPF_F_ZERO_CSUM_TX</b>\n\n<p style=\"margin-left:43%;\">For IPv4 packets, add a flag to\ntunnel metadata indicating that checksum computation should\nbe skipped and checksum set to zeroes.\n\n<p style=\"margin-left:32%;\"><b>BPF_F_DONT_FRAGMENT</b>\n\n<p style=\"margin-left:43%;\">Add a flag to tunnel metadata\nindicating that the packet should not be fragmented.\n\n<p style=\"margin-left:32%;\"><b>BPF_F_SEQ_NUMBER</b>\n\n<p style=\"margin-left:43%;\">Add a flag to tunnel metadata\nindicating that a sequence number should be added to tunnel\nheader before sending the packet. This flag was added for\nGRE encapsulation, but might be used with other protocols as\nwell in the future.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Here is a\ntypical usage on the transmit path:\n\n<pre style=\"margin-left:37%; margin-top: 1em\">struct bpf_tunnel_key key;\n     populate key ...\nbpf_skb_set_tunnel_key(skb, &amp;key, sizeof(key), 0);\nbpf_clone_redirect(skb, vxlan_dev_ifindex, 0);</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">See also the\ndescription of the <b>bpf_skb_get_tunnel_key</b>() helper\nfor additional information.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_perf_event_read(struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Read the value of a perf event\ncounter. This helper relies on a <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf\nevent counter is selected when <i>map</i> is updated with\nperf event file descriptors. The <i>map</i> is an array\nwhose size is the number of available CPUs, and each cell\ncontains a value relative to one CPU. The value to retrieve\nis indicated by <i>flags</i>, that contains the index of the\nCPU to look up, masked with <b>BPF_F_INDEX_MASK</b>.\nAlternatively, <i>flags</i> can be set to\n<b>BPF_F_CURRENT_CPU</b> to indicate that the value for the\ncurrent CPU should be retrieved.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that\nbefore Linux 4.13, only hardware perf event can be\nretrieved.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Also, be aware\nthat the newer helper <b>bpf_perf_event_read_value</b>() is\nrecommended over <b>bpf_perf_event_read</b>() in general.\nThe latter has some ABI quirks where error and counter value\nare used as a return code (which is wrong to do since ranges\nmay overlap). This issue is fixed with\n<b>bpf_perf_event_read_value</b>(), which at the same time\nprovides more features over the <b>bpf_perf_event_read</b>()\ninterface. Please refer to the description of\n<b>bpf_perf_event_read_value</b>() for details.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The value of the perf event counter read from the map,\nor a negative error code in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_redirect(u32</b>\n<i>ifindex</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Redirect the packet to another\nnet device of index <i>ifindex</i>. This helper is somewhat\nsimilar to <b>bpf_clone_redirect</b>(), except that the\npacket is not cloned, which provides increased\nperformance.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Except for XDP,\nboth ingress and egress interfaces can be used for\nredirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i>\nis used to make the distinction (ingress path is selected if\nthe flag is present, egress path otherwise). Currently, XDP\nonly supports redirection to the egress interface, and\naccepts no flag at all.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The same effect\ncan also be attained with the more generic\n<b>bpf_redirect_map</b>(), which uses a BPF map to store the\nredirect target instead of providing it directly to the\nhelper.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>For XDP, the helper returns <b>XDP_REDIRECT</b> on\nsuccess or <b>XDP_ABORTED</b> on error. For other program\ntypes, the values are <b>TC_ACT_REDIRECT</b> on success or\n<b>TC_ACT_SHOT</b> on error.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_route_realm(struct sk_buff\n*</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Retrieve the realm or the\nroute, that is to say the <b>tclassid</b> field of the\ndestination for the <i>skb</i>. The identifier retrieved is\na user-provided tag, similar to the one used with the\nnet_cls cgroup (see description for\n<b>bpf_get_cgroup_classid</b>() helper), but here this tag\nis held by a route (a destination entry), not by a task.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Retrieving this\nidentifier works with the clsact TC egress hook (see also\n<b>tc-bpf(8)</b>), or alternatively on conventional classful\negress qdiscs, but not on TC ingress path. In case of clsact\nTC egress hook, this has the advantage that, internally, the\ndestination entry has not been dropped yet in the transmit\npath. Therefore, the destination entry does not need to be\nartificially held via <b>netif_keep_dst</b>() for a classful\nqdisc until the <i>skb</i> is freed.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_IP_ROUTE_CLASSID</b> configuration option.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The realm of the route for the packet associated to\n<i>skb</i>, or 0 if none was found.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_perf_event_output(void *</b><i>ctx</i><b>, struct\nbpf_map *</b><i>map</i><b>, u64</b> <i>flags</i><b>, <br>\nvoid *</b><i>data</i><b>, u64</b> <i>size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Write raw <i>data</i> blob into\na special BPF perf event held by <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event must\nhave the following attributes: <b>PERF_SAMPLE_RAW</b> as\n<b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as\n<b>type</b>, and <b>PERF_COUNT_SW_BPF_OUTPUT</b> as\n<b>config</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> are used to indicate the index in <i>map</i>\nfor which the value must be put, masked with\n<b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be\nset to <b>BPF_F_CURRENT_CPU</b> to indicate that the index\nof the current CPU core should be used.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The value to\nwrite, of <i>size</i>, is passed through eBPF stack and\npointed by <i>data</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The context of\nthe program <i>ctx</i> needs also be passed to the\nhelper.\n\n<p style=\"margin-left:32%; margin-top: 1em\">On user space,\na program willing to read the values needs to call\n<b>perf_event_open</b>() on the perf event (either for one\nor for all CPUs) and to store the file descriptor into the\n<i>map</i>. This must be done before the eBPF program can\nsend data into it. An example is available in file\n<i>samples/bpf/trace_output_user.c</i> in the Linux kernel\nsource tree (the eBPF program counterpart is in\n<i>samples/bpf/trace_output_kern.c</i>).\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>bpf_perf_event_output</b>()\nachieves better performance than <b>bpf_trace_printk</b>()\nfor sharing data with user space, and is much better\nsuitable for streaming data from eBPF programs.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that this\nhelper is not restricted to tracing use cases and can be\nused with programs attached to TC or XDP as well, where it\nallows for passing data to user space listeners. Data can\nbe:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"42%\">\n\n\n<p>Only custom structs,</td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"42%\">\n\n\n<p>Only the packet payload, or</td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"42%\">\n\n\n<p>A combination of both.</td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"42%\"></td>\n<td width=\"23%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_load_bytes(const void *</b><i>skb</i><b>, u32</b>\n<i>offset</i><b>, void *</b><i>to</i><b>, u32</b>\n<i>len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper was provided as an\neasy way to load data from a packet. It can be used to load\n<i>len</i> bytes from <i>offset</i> from the packet\nassociated to <i>skb</i>, into the buffer pointed by\n<i>to</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Since Linux\n4.7, usage of this helper has mostly been replaced by\n&quot;direct packet access&quot;, enabling packet data to be\nmanipulated with <i>skb</i><b>-&gt;data</b> and\n<i>skb</i><b>-&gt;data_end</b> pointing respectively to the\nfirst byte of packet data and to the byte after the last\nbyte of packet data. However, it remains useful if one\nwishes to read large quantities of data at once from a\npacket into the eBPF stack.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_get_stackid(void\n*</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Walk a user or a kernel stack\nand return its id. To achieve this, the helper needs\n<i>ctx</i>, which is a pointer to the context on which the\ntracing program is executed, and a pointer to a <i>map</i>\nof type <b>BPF_MAP_TYPE_STACK_TRACE</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The last\nargument, <i>flags</i>, holds the number of stack frames to\nskip (from 0 to 255), masked with\n<b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to\nset a combination of the following flags: <b><br>\nBPF_F_USER_STACK</b>\n\n<p style=\"margin-left:43%;\">Collect a user space stack\ninstead of a kernel stack.\n\n\n<p style=\"margin-left:32%;\"><b>BPF_F_FAST_STACK_CMP</b>\n\n<p style=\"margin-left:43%;\">Compare stacks by hash\nonly.\n\n<p style=\"margin-left:32%;\"><b>BPF_F_REUSE_STACKID</b>\n\n<p style=\"margin-left:43%;\">If two different stacks hash\ninto the same <i>stackid</i>, discard the old one.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The stack id\nretrieved is a 32 bit long integer handle which can be\nfurther combined with other data (including other stack ids)\nand used as a key into maps. This can be useful for\ngenerating a variety of graphs (such as flame graphs or\noff-cpu graphs).\n\n<p style=\"margin-left:32%; margin-top: 1em\">For walking a\nstack, this helper is an improvement over\n<b>bpf_probe_read</b>(), which can be used with unrolled\nloops but is not efficient and consumes a lot of eBPF\ninstructions. Instead, <b>bpf_get_stackid</b>() can collect\nup to <b>PERF_MAX_STACK_DEPTH</b> both kernel and user\nframes. Note that this limit can be controlled with the\n<b>sysctl</b> program, and that it should be manually\nincreased in order to profile long user stacks (such as\nstacks for Java programs). To do so, use:\n\n<pre style=\"margin-left:37%; margin-top: 1em\"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</pre>\n\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The positive or null stack id on success, or a negative\nerror in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>s64 bpf_csum_diff(__be32\n*</b><i>from</i><b>, u32</b> <i>from_size</i><b>, __be32\n*</b><i>to</i><b>, u32</b> <i>to_size</i><b>, <br>\n__wsum</b> <i>seed</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Compute a checksum difference,\nfrom the raw buffer pointed by <i>from</i>, of length\n<i>from_size</i> (that must be a multiple of 4), towards the\nraw buffer pointed by <i>to</i>, of size <i>to_size</i>\n(same remark). An optional <i>seed</i> can be added to the\nvalue (this can be cascaded, the seed may come from a\nprevious call to the helper).\n\n<p style=\"margin-left:32%; margin-top: 1em\">This is\nflexible enough to be used in several ways:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>With <i>from_size</i> == 0, <i>to_size</i> &gt; 0 and\n<i>seed</i> set to checksum, it can be used when pushing new\ndata. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>With <i>from_size</i> &gt; 0, <i>to_size</i> == 0 and\n<i>seed</i> set to checksum, it can be used when removing\ndata from a packet.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>With <i>from_size</i> &gt; 0, <i>to_size</i> &gt; 0 and\n<i>seed</i> set to 0, it can be used to compute a diff. Note\nthat <i>from_size</i> and <i>to_size</i> do not need to be\nequal. </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used in combination with <b>bpf_l3_csum_replace</b>() and\n<b>bpf_l4_csum_replace</b>(), to which one can feed in the\ndifference computed with <b>bpf_csum_diff</b>().\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">The checksum result, or a\nnegative error code in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_get_tunnel_opt(struct sk_buff *</b><i>skb</i><b>,\nvoid *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Retrieve tunnel options\nmetadata for the packet associated to <i>skb</i>, and store\nthe raw tunnel option data to the buffer <i>opt</i> of\n<i>size</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used with encapsulation devices that can operate in\n&quot;collect metadata&quot; mode (please refer to the\nrelated note in the description of\n<b>bpf_skb_get_tunnel_key</b>() for more details). A\nparticular example where this can be used is in combination\nwith the Geneve encapsulation protocol, where it allows for\npushing (with <b>bpf_skb_get_tunnel_opt</b>() helper) and\nretrieving arbitrary TLVs (Type-Length-Value headers) from\nthe eBPF program. This allows for full customization of\nthese headers.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"59%\">\n\n\n<p>The size of the option data retrieved.</td>\n<td width=\"9%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_set_tunnel_opt(struct sk_buff *</b><i>skb</i><b>,\nvoid *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Set tunnel options metadata for\nthe packet associated to <i>skb</i> to the option data\ncontained in the raw buffer <i>opt</i> of <i>size</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">See also the\ndescription of the <b>bpf_skb_get_tunnel_opt</b>() helper\nfor additional information.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_proto(struct sk_buff *</b><i>skb</i><b>,\n__be16</b> <i>proto</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Change the protocol of the\n<i>skb</i> to <i>proto</i>. Currently supported are\ntransition from IPv4 to IPv6, and from IPv6 to IPv4. The\nhelper takes care of the groundwork for the transition,\nincluding resizing the socket buffer. The eBPF program is\nexpected to fill the new headers, if any, via\n<b>skb_store_bytes</b>() and to recompute the checksums with\n<b>bpf_l3_csum_replace</b>() and\n<b>bpf_l4_csum_replace</b>(). The main case for this helper\nis to perform NAT64 operations out of an eBPF program.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Internally, the\nGSO type is marked as dodgy so that headers are checked and\nsegments are recalculated by the GSO/GRO engine. The size\nfor GSO target is adapted as well.\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_type(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>type</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Change the packet type for the\npacket associated to <i>skb</i>. This comes down to setting\n<i>skb</i><b>-&gt;pkt_type</b> to <i>type</i>, except the\neBPF program does not have a write access to\n<i>skb</i><b>-&gt;pkt_type</b> beside this helper. Using a\nhelper here allows for graceful handling of errors.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The major use\ncase is to change incoming <i>skb*s to **PACKET_HOST*</i> in\na programmatic way instead of having to recirculate via\n<b>redirect</b>(..., <b>BPF_F_INGRESS</b>), for example.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that\n<i>type</i> only allows certain values. At this time, they\nare: <b><br>\nPACKET_HOST</b>\n\n<p style=\"margin-left:43%;\">Packet is for us.\n\n<p style=\"margin-left:32%;\"><b>PACKET_BROADCAST</b>\n\n<p style=\"margin-left:43%;\">Send packet to all.\n\n<p style=\"margin-left:32%;\"><b>PACKET_MULTICAST</b>\n\n<p style=\"margin-left:43%;\">Send packet to group.\n\n<p style=\"margin-left:32%;\"><b>PACKET_OTHERHOST</b>\n\n<p style=\"margin-left:43%;\">Send packet to someone\nelse.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_under_cgroup(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_map *</b><i>map</i><b>, u32</b> <i><br>\nindex</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Check whether <i>skb</i> is a\ndescendant of the cgroup2 held by <i>map</i> of type\n<b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The return value depends on the result of the test, and\ncan be:</td></tr>\n</table>\n\n<p style=\"margin-left:32%;\">&bull;\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\">0, if the <i>skb</i> failed the\ncgroup2 descendant test.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>1, if the <i>skb</i> succeeded the cgroup2 descendant\ntest. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>A negative error code, if an error occurred.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_hash_recalc(struct sk_buff\n*</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Retrieve the hash of the\npacket, <i>skb</i><b>-&gt;hash</b>. If it is not set, in\nparticular if the hash was cleared due to mangling,\nrecompute this hash. Later accesses to the hash can be done\ndirectly with <i>skb</i><b>-&gt;hash</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Calling\n<b>bpf_set_hash_invalid</b>(), changing a packet prototype\nwith <b>bpf_skb_change_proto</b>(), or calling\n<b>bpf_skb_store_bytes</b>() with the\n<b>BPF_F_INVALIDATE_HASH</b> are actions susceptible to\nclear the hash and to trigger a new computation for the next\ncall to <b>bpf_get_hash_recalc</b>().\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"25%\">\n\n\n<p>The 32-bit hash.</td>\n<td width=\"43%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_task(void)</b>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"57%\">\n\n\n<p>A pointer to the current task struct.</td>\n<td width=\"11%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_write_user(void *</b><i>dst</i><b>, const void\n*</b><i>src</i><b>, u32</b> <i>len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Attempt in a safe way to write\n<i>len</i> bytes from the buffer <i>src</i> to <i>dst</i> in\nmemory. It only works for threads that are in user context,\nand <i>dst</i> must be a valid user space address.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nshould not be used to implement any kind of security\nmechanism because of TOC-TOU attacks, but rather to debug,\ndivert, and manipulate execution of semi-cooperative\nprocesses.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Keep in mind\nthat this feature is meant for experiments, and it has a\nrisk of crashing the system and running programs. Therefore,\nwhen an eBPF program using this helper is attached, a\nwarning including PID and process name is printed to kernel\nlogs.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_current_task_under_cgroup(struct bpf_map\n*</b><i>map</i><b>, u32</b> <i>index</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Check whether the probe is\nbeing run is the context of a given subset of the cgroup2\nhierarchy. The cgroup2 to test is held by <i>map</i> of type\n<b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The return value depends on the result of the test, and\ncan be:</td></tr>\n</table>\n\n<p style=\"margin-left:32%;\">&bull;\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\">0, if the <i>skb</i> task\nbelongs to the cgroup2.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>1, if the <i>skb</i> task does not belong to the\ncgroup2. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>A negative error code, if an error occurred.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_tail(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>len</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Resize (trim or grow) the\npacket associated to <i>skb</i> to the new <i>len</i>. The\n<i>flags</i> are reserved for future usage, and must be left\nat zero.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The basic idea\nis that the helper performs the needed work to change the\nsize of the packet, then the eBPF program rewrites the rest\nvia helpers like <b>bpf_skb_store_bytes</b>(),\n<b>bpf_l3_csum_replace</b>(), <b>bpf_l3_csum_replace</b>()\nand others. This helper is a slow path utility intended for\nreplies with control messages. And because it is targeted\nfor slow path, the helper itself can afford to be slow: it\nimplicitly linearizes, unclones and drops offloads from the\n<i>skb</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_pull_data(struct sk_buff *</b><i>skb</i><b>, u32</b>\n<i>len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Pull in non-linear data in case\nthe <i>skb</i> is non-linear and not all of <i>len</i> are\npart of the linear section. Make <i>len</i> bytes from\n<i>skb</i> readable and writable. If a zero value is passed\nfor <i>len</i>, then the whole length of the <i>skb</i> is\npulled.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly needed for reading and writing with direct packet\naccess.\n\n<p style=\"margin-left:32%; margin-top: 1em\">For direct\npacket access, testing that offsets to access are within\npacket boundaries (test on <i>skb</i><b>-&gt;data_end</b>)\nis susceptible to fail if offsets are invalid, or if the\nrequested data is in non-linear parts of the <i>skb</i>. On\nfailure the program can just bail out, or in the case of a\nnon-linear buffer, use a helper to make the data available.\nThe <b>bpf_skb_load_bytes</b>() helper is a first solution\nto access the data. Another one consists in using\n<b>bpf_skb_pull_data</b> to pull in once the non-linear\nparts, then retesting and eventually access the data.\n\n<p style=\"margin-left:32%; margin-top: 1em\">At the same\ntime, this also makes sure the <i>skb</i> is uncloned, which\nis a necessary condition for direct write. As this needs to\nbe an invariant for the write part only, the verifier\ndetects writes and adds a prologue that is calling\n<b>bpf_skb_pull_data()</b> to effectively unclone the\n<i>skb</i> from the very beginning in case it is indeed\ncloned.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>s64 bpf_csum_update(struct\nsk_buff *</b><i>skb</i><b>, __wsum</b>\n<i>csum</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Add the checksum <i>csum</i>\ninto <i>skb</i><b>-&gt;csum</b> in case the driver has\nsupplied a checksum for the entire packet into that field.\nReturn an error otherwise. This helper is intended to be\nused in combination with <b>bpf_csum_diff</b>(), in\nparticular when the checksum needs to be updated after data\nhas been written into the packet through direct packet\naccess.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The checksum on success, or a negative error code in\ncase of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\nbpf_set_hash_invalid(struct sk_buff\n*</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Invalidate the current\n<i>skb</i><b>-&gt;hash</b>. It can be used after mangling on\nheaders through direct packet access, in order to indicate\nthat the hash is outdated and to trigger a recalculation the\nnext time the kernel tries to access this hash or when the\n<b>bpf_get_hash_recalc</b>() helper is called.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_numa_node_id(void)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return the id of the current\nNUMA node. The primary use case for this helper is the\nselection of sockets for the local NUMA node, when the\nprogram is attached to sockets using the\n<b>SO_ATTACH_REUSEPORT_EBPF</b> option (see also\n<b>socket(7)</b>), but the helper is also available to other\neBPF program types, similarly to\n<b>bpf_get_smp_processor_id</b>().\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"43%\">\n\n\n<p>The id of current NUMA node.</td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_head(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>len</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Grows headroom of packet\nassociated to <i>skb</i> and adjusts the offset of the MAC\nheader accordingly, adding <i>len</i> bytes of space. It\nautomatically extends and reallocates memory as\nrequired.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used on a layer 3 <i>skb</i> to push a MAC header for\nredirection into a layer 2 device.\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_xdp_adjust_head(struct xdp_buff *</b><i>xdp_md</i><b>,\nint</b> <i>delta</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Adjust (move)\n<i>xdp_md</i><b>-&gt;data</b> by <i>delta</i> bytes. Note\nthat it is possible to use a negative value for\n<i>delta</i>. This helper can be used to prepare the packet\nfor pushing or popping headers.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_probe_read_str(void\n*</b><i>dst</i><b>, u32</b> <i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Copy a NUL terminated string\nfrom an unsafe kernel address <i>unsafe_ptr</i> to\n<i>dst</i>. See <b>bpf_probe_read_kernel_str</b>() for more\ndetails.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Generally, use\n<b>bpf_probe_read_user_str</b>() or\n<b>bpf_probe_read_kernel_str</b>() instead.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, the strictly positive length of the string,\nincluding the trailing NUL character. On error, a negative\nvalue. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_socket_cookie(struct sk_buff\n*</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">If the <b>struct sk_buff</b>\npointed by <i>skb</i> has a known socket, retrieve the\ncookie (generated by the kernel) of this socket. If no\ncookie has been set yet, generate a new cookie. Once\ngenerated, the socket cookie remains stable for the life of\nthe socket. This helper can be useful for monitoring per\nsocket networking traffic statistics as it provides a global\nsocket identifier that can be assumed unique.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 8-byte long non-decreasing number on success, or 0 if\nthe socket field is missing inside <i>skb</i>.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_socket_cookie(struct bpf_sock_addr\n*</b><i>ctx</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Equivalent to\nbpf_get_socket_cookie() helper that accepts <i>skb</i>, but\ngets socket from <b>struct bpf_sock_addr</b> context.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>A 8-byte long non-decreasing number.</td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_socket_cookie(struct bpf_sock_ops\n*</b><i>ctx</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Equivalent to\n<b>bpf_get_socket_cookie</b>() helper that accepts\n<i>skb</i>, but gets socket from <b>struct bpf_sock_ops</b>\ncontext.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>A 8-byte long non-decreasing number.</td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_socket_uid(struct sk_buff\n*</b><i>skb</i><b>)</b>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The owner UID of the socket associated to <i>skb</i>. If\nthe socket is <b>NULL</b>, or if it is not a full socket\n(i.e. if it is a time-wait or a request socket instead),\n<b>overflowuid</b> value is returned (note that\n<b>overflowuid</b> might also be the actual UID value for\nthe socket).</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_set_hash(struct\nsk_buff *</b><i>skb</i><b>, u32</b> <i>hash</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Set the full hash for\n<i>skb</i> (set the field <i>skb</i><b>-&gt;hash</b>) to\nvalue <i>hash</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_setsockopt(void\n*</b><i>bpf_socket</i><b>, int</b> <i>level</i><b>, int</b>\n<i>optname</i><b>, void <br>\n*</b><i>optval</i><b>, int</b> <i>optlen</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Emulate a call to\n<b>setsockopt()</b> on the socket associated to\n<i>bpf_socket</i>, which must be a full socket. The\n<i>level</i> at which the option resides and the name\n<i>optname</i> of the option must be specified, see\n<b>setsockopt(2)</b> for more information. The option value\nof length <i>optlen</i> is pointed by <i>optval</i>.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>bpf_socket</i>\nshould be one of the following:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_ops</b> for\n<b>BPF_PROG_TYPE_SOCK_OPS</b>. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_addr</b> for\n<b>BPF_CGROUP_INET4_CONNECT</b> and\n<b>BPF_CGROUP_INET6_CONNECT</b>. </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nactually implements a subset of <b>setsockopt()</b>. It\nsupports the following <i>level</i>s:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>SOL_SOCKET</b>, which\nsupports the following <i>optname</i>s: <b>SO_RCVBUF</b>,\n<b>SO_SNDBUF</b>, <b>SO_MAX_PACING_RATE</b>,\n<b>SO_PRIORITY</b>, <b>SO_RCVLOWAT</b>, <b>SO_MARK</b>,\n<b>SO_BINDTODEVICE</b>, <b>SO_KEEPALIVE</b>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_TCP</b>, which supports the following\n<i>optname</i>s: <b>TCP_CONGESTION</b>, <b>TCP_BPF_IW</b>,\n<b>TCP_BPF_SNDCWND_CLAMP</b>, <b>TCP_SAVE_SYN</b>,\n<b>TCP_KEEPIDLE</b>, <b>TCP_KEEPINTVL</b>,\n<b>TCP_KEEPCNT</b>, <b>TCP_SYNCNT</b>,\n<b>TCP_USER_TIMEOUT</b>. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IP</b>, which supports <i>optname</i>\n<b>IP_TOS</b>. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IPV6</b>, which supports <i>optname</i>\n<b>IPV6_TCLASS</b>. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_adjust_room(struct sk_buff *</b><i>skb</i><b>,\ns32</b> <i>len_diff</i><b>, u32</b> <i>mode</i><b>, <br>\nu64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Grow or shrink the room for\ndata in the packet associated to <i>skb</i> by\n<i>len_diff</i>, and according to the selected\n<i>mode</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">By default, the\nhelper will reset any offloaded checksum indicator of the\nskb to CHECKSUM_NONE. This can be avoided by the following\nflag:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_NO_CSUM_RESET</b>: Do not reset\noffloaded checksum data of the skb to CHECKSUM_NONE.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">There are two\nsupported modes at this time:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>BPF_ADJ_ROOM_MAC</b>: Adjust\nroom at the mac layer (room space is added or removed below\nthe layer 2 header).</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_ADJ_ROOM_NET</b>: Adjust room at the network\nlayer (room space is added or removed below the layer 3\nheader). </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The following\nflags are supported at this time:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n\n<p style=\"margin-top: 1em\"><b>BPF_F_ADJ_ROOM_FIXED_GSO</b>:\nDo not adjust gso_size. Adjusting mss in this way is not\nallowed for datagrams.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV4</b>,\n<b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV6</b>: Any new space is\nreserved to hold a tunnel header. Configure skb offsets and\nother fields accordingly.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_ENCAP_L4_GRE</b>,\n<b>BPF_F_ADJ_ROOM_ENCAP_L4_UDP</b>: Use with ENCAP_L3 flags\nto further specify the tunnel type.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_ENCAP_L2</b>(<i>len</i>): Use with\nENCAP_L3/L4 flags to further specify the tunnel type;\n<i>len</i> is the length of the inner MAC header.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">0 on success, or a negative\nerror in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_redirect_map(struct\nbpf_map *</b><i>map</i><b>, u32</b> <i>key</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Redirect the packet to the\nendpoint referenced by <i>map</i> at index <i>key</i>.\nDepending on its type, this <i>map</i> can contain\nreferences to net devices (for forwarding packets through\nother ports), or to CPUs (for redirecting XDP frames to\nanother CPU; but this is only implemented for native XDP\n(with driver support) as of this writing).\n\n<p style=\"margin-left:32%; margin-top: 1em\">The lower two\nbits of <i>flags</i> are used as the return code if the map\nlookup fails. This is so that the return value can be one of\nthe XDP program return codes up to <b>XDP_TX</b>, as chosen\nby the caller. Any higher bits in the <i>flags</i> argument\nmust be unset.\n\n<p style=\"margin-left:32%; margin-top: 1em\">See also\n<b>bpf_redirect</b>(), which only supports redirecting to an\nifindex, but doesn't require a map to do so.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p><b>XDP_REDIRECT</b> on success, or the value of the two\nlower bits of the <i>flags</i> argument on error.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_redirect_map(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_map *</b><i>map</i><b>, u32</b> <i><br>\nkey</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Redirect the packet to the\nsocket referenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress path otherwise). This is the only flag\nsupported for now.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror. </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sock_map_update(struct bpf_sock_ops\n*</b><i>skops</i><b>, struct bpf_map <br>\n*</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Add an entry to, or update a\n<i>map</i> referencing sockets. The <i>skops</i> is used as\na new value for the entry associated to <i>key</i>.\n<i>flags</i> is one of: <b><br>\nBPF_NOEXIST</b>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nnot exist in the map.\n\n<p style=\"margin-left:32%;\"><b>BPF_EXIST</b>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nalready exist in the map.\n\n<p style=\"margin-left:32%;\"><b>BPF_ANY</b>\n\n<p style=\"margin-left:43%;\">No condition on the existence\nof the entry for <i>key</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>map</i> has eBPF programs (parser and verdict), those\nwill be inherited by the socket being added. If the socket\nis already attached to eBPF programs, this results in an\nerror.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_xdp_adjust_meta(struct xdp_buff *</b><i>xdp_md</i><b>,\nint</b> <i>delta</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Adjust the address pointed by\n<i>xdp_md</i><b>-&gt;data_meta</b> by <i>delta</i> (which\ncan be positive or negative). Note that this operation\nmodifies the address stored in\n<i>xdp_md</i><b>-&gt;data</b>, so the latter must be loaded\nonly after the helper has been called.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The use of\n<i>xdp_md</i><b>-&gt;data_meta</b> is optional and programs\nare not required to use it. The rationale is that when the\npacket is processed with XDP (e.g. as DoS filter), it is\npossible to push further meta data along with it before\npassing to the stack, and to give the guarantee that an\ningress eBPF program attached as a TC classifier on the same\ndevice can pick this up for further post-processing. Since\nTC works with socket buffers, it remains possible to set\nfrom XDP the <b>mark</b> or <b>priority</b> pointers, or\nother pointers for the socket buffer. Having this scratch\nspace generic and programmable allows for more flexibility\nas the user is free to store whatever meta data they\nneed.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_perf_event_read_value(struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>, struct <br>\nbpf_perf_event_value *</b><i>buf</i><b>, u32</b>\n<i>buf_size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Read the value of a perf event\ncounter, and store it into <i>buf</i> of size\n<i>buf_size</i>. This helper relies on a <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf\nevent counter is selected when <i>map</i> is updated with\nperf event file descriptors. The <i>map</i> is an array\nwhose size is the number of available CPUs, and each cell\ncontains a value relative to one CPU. The value to retrieve\nis indicated by <i>flags</i>, that contains the index of the\nCPU to look up, masked with <b>BPF_F_INDEX_MASK</b>.\nAlternatively, <i>flags</i> can be set to\n<b>BPF_F_CURRENT_CPU</b> to indicate that the value for the\ncurrent CPU should be retrieved.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nbehaves in a way close to <b>bpf_perf_event_read</b>()\nhelper, save that instead of just returning the value\nobserved, it fills the <i>buf</i> structure. This allows for\nadditional data to be retrieved: in particular, the enabled\nand running times (in <i>buf</i><b>-&gt;enabled</b> and\n<i>buf</i><b>-&gt;running</b>, respectively) are copied. In\ngeneral, <b>bpf_perf_event_read_value</b>() is recommended\nover <b>bpf_perf_event_read</b>(), which has some ABI issues\nand provides fewer functionalities.\n\n<p style=\"margin-left:32%; margin-top: 1em\">These values\nare interesting, because hardware PMU (Performance\nMonitoring Unit) counters are limited resources. When there\nare more PMU based perf events opened than available\ncounters, kernel will multiplex these events so each event\ngets certain percentage (but not all) of the PMU time. In\ncase that multiplexing happens, the number of samples or\ncounter value will not reflect the case compared to when no\nmultiplexing occurs. This makes comparison between different\nruns difficult. Typically, the counter value should be\nnormalized before comparing to other experiments. The usual\nnormalization is done as follows.\n\n<pre style=\"margin-left:37%; margin-top: 1em\">normalized_counter = counter * t_enabled / t_running</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">Where t_enabled\nis the time enabled for event and t_running is the time\nrunning for event since last normalization. The enabled and\nrunning times are accumulated since the perf event open. To\nachieve scaling factor between two invocations of an eBPF\nprogram, users can use CPU id as the key (which is typical\nfor perf array usage model) to remember the previous value\nand do the calculation inside the eBPF program.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_perf_prog_read_value(struct bpf_perf_event_data\n*</b><i>ctx</i><b>, struct <br>\nbpf_perf_event_value *</b><i>buf</i><b>, u32</b>\n<i>buf_size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">For en eBPF program attached to\na perf event, retrieve the value of the event counter\nassociated to <i>ctx</i> and store it in the structure\npointed by <i>buf</i> and of size <i>buf_size</i>. Enabled\nand running times are also stored in the structure (see\ndescription of helper <b>bpf_perf_event_read_value</b>() for\nmore details).\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_getsockopt(void\n*</b><i>bpf_socket</i><b>, int</b> <i>level</i><b>, int</b>\n<i>optname</i><b>, void <br>\n*</b><i>optval</i><b>, int</b> <i>optlen</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Emulate a call to\n<b>getsockopt()</b> on the socket associated to\n<i>bpf_socket</i>, which must be a full socket. The\n<i>level</i> at which the option resides and the name\n<i>optname</i> of the option must be specified, see\n<b>getsockopt(2)</b> for more information. The retrieved\nvalue is stored in the structure pointed by <i>opval</i> and\nof length <i>optlen</i>.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>bpf_socket</i>\nshould be one of the following:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_ops</b> for\n<b>BPF_PROG_TYPE_SOCK_OPS</b>. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_addr</b> for\n<b>BPF_CGROUP_INET4_CONNECT</b> and\n<b>BPF_CGROUP_INET6_CONNECT</b>. </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nactually implements a subset of <b>getsockopt()</b>. It\nsupports the following <i>level</i>s:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>IPPROTO_TCP</b>, which\nsupports <i>optname</i> <b>TCP_CONGESTION</b>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IP</b>, which supports <i>optname</i>\n<b>IP_TOS</b>. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IPV6</b>, which supports <i>optname</i>\n<b>IPV6_TCLASS</b>. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_override_return(struct pt_regs *</b><i>regs</i><b>,\nu64</b> <i>rc</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Used for error injection, this\nhelper uses kprobes to override the return value of the\nprobed function, and to set it to <i>rc</i>. The first\nargument is the context <i>regs</i> on which the kprobe\nworks.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks by setting the PC (program counter) to an override\nfunction which is run in place of the original probed\nfunction. This means the probed function is not run at all.\nThe replacement function just returns with the required\nvalue.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper has\nsecurity implications, and thus is subject to restrictions.\nIt is only available if the kernel was compiled with the\n<b>CONFIG_BPF_KPROBE_OVERRIDE</b> configuration option, and\nin this case it only works on functions tagged with\n<b>ALLOW_ERROR_INJECTION</b> in the kernel code.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Also, the\nhelper is only available for the architectures having the\nCONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,\nx86 architecture is the only one to support this\nfeature.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sock_ops_cb_flags_set(struct bpf_sock_ops\n*</b><i>bpf_sock</i><b>, int</b> <i><br>\nargval</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Attempt to set the value of the\n<b>bpf_sock_ops_cb_flags</b> field for the full TCP socket\nassociated to <i>bpf_sock_ops</i> to <i>argval</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The primary use\nof this field is to determine if there should be calls to\neBPF programs of type <b>BPF_PROG_TYPE_SOCK_OPS</b> at\nvarious points in the TCP code. A program of the same type\ncan change its value, per connection and as necessary, when\nthe connection is established. This field is directly\naccessible for reading, but this helper must be used for\nupdates in order to return an error if an eBPF program tries\nto set a callback that is not supported in the current\nkernel.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>argval</i>\nis a flag array which can combine these flags:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_RTO_CB_FLAG</b> (retransmission time\nout) </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_RETRANS_CB_FLAG</b> (retransmission)</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_STATE_CB_FLAG</b> (TCP state change)</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_RTT_CB_FLAG</b> (every RTT)</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Therefore, this\nfunction can be used to clear a callback flag by setting the\nappropriate bit to zero. e.g. to disable the RTO callback:\n<b><br>\nbpf_sock_ops_cb_flags_set(bpf_sock,</b>\n\n\n<p style=\"margin-left:43%;\"><b>bpf_sock-&gt;bpf_sock_ops_cb_flags\n&amp; ~BPF_SOCK_OPS_RTO_CB_FLAG)</b>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Here are some\nexamples of where one could call such eBPF program:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When RTO fires.</td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When a packet is retransmitted.</td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When the connection terminates.</td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When a packet is sent.</td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When a packet is received.</td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"48%\"></td>\n<td width=\"17%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Code\n<b>-EINVAL</b> if the socket is not a full TCP socket;\notherwise, a positive number containing the bits that could\nnot be set is returned (which comes down to 0 if all bits\nwere set as required).\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_redirect_map(struct sk_msg_buff *</b><i>msg</i><b>,\nstruct bpf_map *</b><i>map</i><b>, <br>\nu32</b> <i>key</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing policies at the socket level. If the message\n<i>msg</i> is allowed to pass (i.e. if the verdict eBPF\nprogram returns <b>SK_PASS</b>), redirect it to the socket\nreferenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress path otherwise). This is the only flag\nsupported for now.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror. </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_apply_bytes(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>bytes</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">For socket policies, apply the\nverdict of the eBPF program to the next <i>bytes</i> (number\nof bytes) of message <i>msg</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">For example,\nthis helper can be used in the following cases:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>A single <b>sendmsg</b>() or <b>sendfile</b>() system\ncall contains multiple logical messages that the eBPF\nprogram is supposed to read and for which it should apply a\nverdict. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>An eBPF program only cares to read the first\n<i>bytes</i> of a <i>msg</i>. If the message has a large\npayload, then setting up and calling the eBPF program\nrepeatedly for all bytes, even though the verdict is already\nknown, would create unnecessary overhead.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">When called\nfrom within an eBPF program, the helper sets a counter\ninternal to the BPF infrastructure, that is used to apply\nthe last verdict to the next <i>bytes</i>. If <i>bytes</i>\nis smaller than the current data being processed from a\n<b>sendmsg</b>() or <b>sendfile</b>() system call, the first\n<i>bytes</i> will be sent and the eBPF program will be\nre-run with the pointer for start of data pointing to byte\nnumber <i>bytes</i> <b>+ 1</b>. If <i>bytes</i> is larger\nthan the current data being processed, then the eBPF verdict\nwill be applied to multiple <b>sendmsg</b>() or\n<b>sendfile</b>() calls until <i>bytes</i> are consumed.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that if a\nsocket closes with the internal counter holding a non-zero\nvalue, this is not a problem because data is not being\nbuffered for <i>bytes</i> and is sent as it is received.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p style=\"margin-top: 1em\">0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_cork_bytes(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>bytes</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">For socket policies, prevent\nthe execution of the verdict eBPF program for message\n<i>msg</i> until <i>bytes</i> (byte number) have been\naccumulated.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This can be\nused when one needs a specific number of bytes before a\nverdict can be assigned, even if the data spans multiple\n<b>sendmsg</b>() or <b>sendfile</b>() calls. The extreme\ncase would be a user calling <b>sendmsg</b>() repeatedly\nwith 1-byte long message segments. Obviously, this is bad\nfor performance, but it is still valid. If the eBPF program\nneeds <i>bytes</i> bytes to validate a header, this helper\ncan be used to prevent the eBPF program to be called again\nuntil <i>bytes</i> have been accumulated.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_pull_data(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>start</i><b>, u32</b> <i>end</i><b>, u64</b>\n<i><br>\nflags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">For socket policies, pull in\nnon-linear data from user space for <i>msg</i> and set\npointers <i>msg</i><b>-&gt;data</b> and\n<i>msg</i><b>-&gt;data_end</b> to <i>start</i> and\n<i>end</i> bytes offsets into <i>msg</i>, respectively.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If a program of\ntype <b>BPF_PROG_TYPE_SK_MSG</b> is run on a <i>msg</i> it\ncan only parse data that the (<b>data</b>, <b>data_end</b>)\npointers have already consumed. For <b>sendmsg</b>() hooks\nthis is likely the first scatterlist element. But for calls\nrelying on the <b>sendpage</b> handler (e.g.\n<b>sendfile</b>()) this will be the range (<b>0</b>,\n<b>0</b>) because the data is shared with user space and by\ndefault the objective is to avoid allowing user space to\nmodify data while (or after) eBPF verdict is being decided.\nThis helper can be used to pull in data and to set the start\nand end pointer to given values. Data will be copied if\nnecessary (i.e. if data was not linear and if start and end\npointers do not point to the same chunk).\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_bind(struct\nbpf_sock_addr *</b><i>ctx</i><b>, struct sockaddr\n*</b><i>addr</i><b>, int</b> <i><br>\naddr_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Bind the socket associated to\n<i>ctx</i> to the address pointed by <i>addr</i>, of length\n<i>addr_len</i>. This allows for making outgoing connection\nfrom the desired IP address, which can be useful for example\nwhen all processes inside a cgroup should use one single IP\naddress on a host that has multiple IP configured.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks for IPv4 and IPv6, TCP and UDP sockets. The domain\n(<i>addr</i><b>-&gt;sa_family</b>) must be <b>AF_INET</b>\n(or <b>AF_INET6</b>). It's advised to pass zero port\n(<b>sin_port</b> or <b>sin6_port</b>) which triggers\nIP_BIND_ADDRESS_NO_PORT-like behavior and lets the kernel\nefficiently pick up an unused port as long as 4-tuple is\nunique. Passing non-zero port might lead to degraded\nperformance.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_xdp_adjust_tail(struct xdp_buff *</b><i>xdp_md</i><b>,\nint</b> <i>delta</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Adjust (move)\n<i>xdp_md</i><b>-&gt;data_end</b> by <i>delta</i> bytes. It\nis possible to both shrink and grow the packet tail. Shrink\ndone via <i>delta</i> being a negative integer.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_get_xfrm_state(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>index</i><b>, struct <br>\nbpf_xfrm_state *</b><i>xfrm_state</i><b>, u32</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Retrieve the XFRM state (IP\ntransform framework, see also <b>ip-xfrm(8)</b>) at\n<i>index</i> in XFRM &quot;security path&quot; for\n<i>skb</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The retrieved\nvalue is stored in the <b>struct bpf_xfrm_state</b> pointed\nby <i>xfrm_state</i> and of length <i>size</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_XFRM</b> configuration option.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_get_stack(void\n*</b><i>ctx</i><b>, void *</b><i>buf</i><b>, u32</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return a user or a kernel stack\nin bpf program provided buffer. To achieve this, the helper\nneeds <i>ctx</i>, which is a pointer to the context on which\nthe tracing program is executed. To store the stacktrace,\nthe bpf program provides <i>buf</i> with a nonnegative\n<i>size</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The last\nargument, <i>flags</i>, holds the number of stack frames to\nskip (from 0 to 255), masked with\n<b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to\nset the following flags: <b><br>\nBPF_F_USER_STACK</b>\n\n<p style=\"margin-left:43%;\">Collect a user space stack\ninstead of a kernel stack.\n\n<p style=\"margin-left:32%;\"><b>BPF_F_USER_BUILD_ID</b>\n\n<p style=\"margin-left:43%;\">Collect buildid+offset instead\nof ips for user stack, only valid if <b>BPF_F_USER_STACK</b>\nis also specified.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>bpf_get_stack</b>()\ncan collect up to <b>PERF_MAX_STACK_DEPTH</b> both kernel\nand user frames, subject to sufficient large buffer size.\nNote that this limit can be controlled with the\n<b>sysctl</b> program, and that it should be manually\nincreased in order to profile long user stacks (such as\nstacks for Java programs). To do so, use:\n\n<pre style=\"margin-left:37%; margin-top: 1em\"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</pre>\n\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A non-negative value equal to or less than <i>size</i>\non success, or a negative error in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_load_bytes_relative(const void *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, void *</b><i>to</i><b>, <br>\nu32</b> <i>len</i><b>, u32</b>\n<i>start_header</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is similar to\n<b>bpf_skb_load_bytes</b>() in that it provides an easy way\nto load <i>len</i> bytes from <i>offset</i> from the packet\nassociated to <i>skb</i>, into the buffer pointed by\n<i>to</i>. The difference to <b>bpf_skb_load_bytes</b>() is\nthat a fifth argument <i>start_header</i> exists in order to\nselect a base offset to start from. <i>start_header</i> can\nbe one of: <b><br>\nBPF_HDR_START_MAC</b>\n\n<p style=\"margin-left:43%;\">Base offset to load data from\nis <i>skb</i>'s mac header.\n\n<p style=\"margin-left:32%;\"><b>BPF_HDR_START_NET</b>\n\n<p style=\"margin-left:43%;\">Base offset to load data from\nis <i>skb</i>'s network header.\n\n<p style=\"margin-left:32%; margin-top: 1em\">In general,\n&quot;direct packet access&quot; is the preferred method to\naccess packet data, however, this helper is in particular\nuseful in socket filters where <i>skb</i><b>-&gt;data</b>\ndoes not always point to the start of the mac header and\nwhere &quot;direct packet access&quot; is not available.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_fib_lookup(void\n*</b><i>ctx</i><b>, struct bpf_fib_lookup\n*</b><i>params</i><b>, int</b> <i>plen</i><b>, <br>\nu32</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Do FIB lookup in kernel tables\nusing parameters in <i>params</i>. If lookup is successful\nand result shows packet is to be forwarded, the neighbor\ntables are searched for the nexthop. If successful (ie., FIB\nlookup shows forwarding and nexthop is resolved), the\nnexthop address is returned in ipv4_dst or ipv6_dst based on\nfamily, smac is set to mac address of egress device, dmac is\nset to nexthop mac address, rt_metric is set to metric from\nroute (IPv4/IPv6 only), and ifindex is set to the device\nindex of the nexthop from the FIB lookup.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>plen</i>\nargument is the size of the passed in struct. <i>flags</i>\nargument can be a combination of one or more of the\nfollowing values: <b><br>\nBPF_FIB_LOOKUP_DIRECT</b>\n\n<p style=\"margin-left:43%;\">Do a direct table lookup vs\nfull lookup using FIB rules.\n\n\n<p style=\"margin-left:32%;\"><b>BPF_FIB_LOOKUP_OUTPUT</b>\n\n<p style=\"margin-left:43%;\">Perform lookup from an egress\nperspective (default is ingress).\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>ctx</i> is\neither <b>struct xdp_md</b> for XDP programs or <b>struct\nsk_buff</b> tc cls_act programs.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>&lt; 0 if any input argument is invalid</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>0 on success (packet is forwarded, nexthop neighbor\nexists) </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>&gt; 0 one of <b>BPF_FIB_LKUP_RET_</b> codes explaining\nwhy the packet is not forwarded or needs assist from full\nstack </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sock_hash_update(struct bpf_sock_ops\n*</b><i>skops</i><b>, struct bpf_map <br>\n*</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Add an entry to, or update a\nsockhash <i>map</i> referencing sockets. The <i>skops</i> is\nused as a new value for the entry associated to <i>key</i>.\n<i>flags</i> is one of: <b><br>\nBPF_NOEXIST</b>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nnot exist in the map.\n\n<p style=\"margin-left:32%;\"><b>BPF_EXIST</b>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nalready exist in the map.\n\n<p style=\"margin-left:32%;\"><b>BPF_ANY</b>\n\n<p style=\"margin-left:43%;\">No condition on the existence\nof the entry for <i>key</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>map</i> has eBPF programs (parser and verdict), those\nwill be inherited by the socket being added. If the socket\nis already attached to eBPF programs, this results in an\nerror.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_redirect_hash(struct sk_msg_buff *</b><i>msg</i><b>,\nstruct bpf_map <br>\n*</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing policies at the socket level. If the message\n<i>msg</i> is allowed to pass (i.e. if the verdict eBPF\nprogram returns <b>SK_PASS</b>), redirect it to the socket\nreferenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKHASH</b>) using hash <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress path otherwise). This is the only flag\nsupported for now.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror. </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_redirect_hash(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_map *</b><i>map</i><b>, <br>\nvoid *</b><i>key</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing policies at the skb socket level. If the\nsk_buff <i>skb</i> is allowed to pass (i.e. if the verdict\neBPF program returns <b>SK_PASS</b>), redirect it to the\nsocket referenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKHASH</b>) using hash <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress otherwise). This is the only flag\nsupported for now.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror. </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_push_encap(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>type</i><b>, void *</b><i>hdr</i><b>, u32</b>\n<i><br>\nlen</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Encapsulate the packet\nassociated to <i>skb</i> within a Layer 3 protocol header.\nThis header is provided in the buffer at address <i>hdr</i>,\nwith <i>len</i> its size in bytes. <i>type</i> indicates the\nprotocol of the header and can be one of: <b><br>\nBPF_LWT_ENCAP_SEG6</b>\n\n<p style=\"margin-left:43%;\">IPv6 encapsulation with Segment\nRouting Header (<b>struct ipv6_sr_hdr</b>). <i>hdr</i> only\ncontains the SRH, the IPv6 header is computed by the\nkernel.\n\n\n<p style=\"margin-left:32%;\"><b>BPF_LWT_ENCAP_SEG6_INLINE</b>\n\n<p style=\"margin-left:43%;\">Only works if <i>skb</i>\ncontains an IPv6 packet. Insert a Segment Routing Header\n(<b>struct ipv6_sr_hdr</b>) inside the IPv6 header.\n\n<p style=\"margin-left:32%;\"><b>BPF_LWT_ENCAP_IP</b>\n\n<p style=\"margin-left:43%;\">IP encapsulation\n(GRE/GUE/IPIP/etc). The outer header must be IPv4 or IPv6,\nfollowed by zero or more additional headers, up to\n<b>LWT_BPF_MAX_HEADROOM</b> total bytes in all prepended\nheaders. Please note that if <b>skb_is_gso</b>(<i>skb</i>)\nis true, no more than two headers can be prepended, and the\ninner header, if present, should be either GRE or\nUDP/GUE.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>BPF_LWT_ENCAP_SEG6</b>*\ntypes can be called by BPF programs of type\n<b>BPF_PROG_TYPE_LWT_IN</b>; <b>BPF_LWT_ENCAP_IP</b> type\ncan be called by bpf programs of types\n<b>BPF_PROG_TYPE_LWT_IN</b> and\n<b>BPF_PROG_TYPE_LWT_XMIT</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_seg6_store_bytes(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, const <br>\nvoid *</b><i>from</i><b>, u32</b> <i>len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Store <i>len</i> bytes from\naddress <i>from</i> into the packet associated to\n<i>skb</i>, at <i>offset</i>. Only the flags, tag and TLVs\ninside the outermost IPv6 Segment Routing Header can be\nmodified through this helper.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_seg6_adjust_srh(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, s32</b> <i><br>\ndelta</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Adjust the size allocated to\nTLVs in the outermost IPv6 Segment Routing Header contained\nin the packet associated to <i>skb</i>, at position\n<i>offset</i> by <i>delta</i> bytes. Only offsets after the\nsegments are accepted. <i>delta</i> can be as well positive\n(growing) as negative (shrinking).\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_seg6_action(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>action</i><b>, void *</b><i>param</i><b>, <br>\nu32</b> <i>param_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Apply an IPv6 Segment Routing\naction of type <i>action</i> to the packet associated to\n<i>skb</i>. Each action takes a parameter contained at\naddress <i>param</i>, and of length <i>param_len</i> bytes.\n<i>action</i> can be one of: <b><br>\nSEG6_LOCAL_ACTION_END_X</b>\n\n<p style=\"margin-left:43%;\">End.X action: Endpoint with\nLayer-3 cross-connect. Type of <i>param</i>: <b>struct\nin6_addr</b>.\n\n\n<p style=\"margin-left:32%;\"><b>SEG6_LOCAL_ACTION_END_T</b>\n\n<p style=\"margin-left:43%;\">End.T action: Endpoint with\nspecific IPv6 table lookup. Type of <i>param</i>:\n<b>int</b>.\n\n\n<p style=\"margin-left:32%;\"><b>SEG6_LOCAL_ACTION_END_B6</b>\n\n<p style=\"margin-left:43%;\">End.B6 action: Endpoint bound\nto an SRv6 policy. Type of <i>param</i>: <b>struct\nipv6_sr_hdr</b>.\n\n\n<p style=\"margin-left:32%;\"><b>SEG6_LOCAL_ACTION_END_B6_ENCAP</b>\n\n<p style=\"margin-left:43%;\">End.B6.Encap action: Endpoint\nbound to an SRv6 encapsulation policy. Type of <i>param</i>:\n<b>struct ipv6_sr_hdr</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_rc_repeat(void\n*</b><i>ctx</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing IR decoding, to report a successfully decoded\nrepeat key message. This delays the generation of a key up\nevent for previously generated key down event.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Some IR\nprotocols like NEC have a special IR message for repeating\nlast button, for when a button is held down.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the lirc sample as passed into the\nprogram.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to\n&quot;<b>y</b>&quot;.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_rc_keydown(void\n*</b><i>ctx</i><b>, u32</b> <i>protocol</i><b>, u64</b>\n<i>scancode</i><b>, u32</b> <i>toggle</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing IR decoding, to report a successfully decoded\nkey press with <i>scancode</i>, <i>toggle</i> value in the\ngiven <i>protocol</i>. The scancode will be translated to a\nkeycode using the rc keymap, and reported as an input key\ndown event. After a period a key up event is generated. This\nperiod can be extended by calling either\n<b>bpf_rc_keydown</b>() again with the same values, or\ncalling <b>bpf_rc_repeat</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">Some protocols\ninclude a toggle bit, in case the button was released and\npressed again between consecutive scancodes.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the lirc sample as passed into the\nprogram.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>protocol</i> is the decoded protocol number (see <b>enum\nrc_proto</b> for some predefined values).\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to\n&quot;<b>y</b>&quot;.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64 bpf_skb_cgroup_id(struct\nsk_buff *</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return the cgroup v2 id of the\nsocket associated with the <i>skb</i>. This is roughly\nsimilar to the <b>bpf_get_cgroup_classid</b>() helper for\ncgroup v1 by providing a tag resp. identifier that can be\nmatched on or used for map lookups e.g. to implement policy.\nThe cgroup v2 id of a given path in the hierarchy is exposed\nin user space through the f_handle API in order to get to\nthe same 64-bit id.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used on TC egress path, but not on ingress, and is\navailable only if the kernel was compiled with the\n<b>CONFIG_SOCK_CGROUP_DATA</b> configuration option.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_cgroup_id(void)</b>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 64-bit integer containing the current cgroup id based\non the cgroup within which the current task is running.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\n*bpf_get_local_storage(void *</b><i>map</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get the pointer to the local\nstorage area. The type and the size of the local storage is\ndefined by the <i>map</i> argument. The <i>flags</i> meaning\nis specific for each map type, and has to be 0 for cgroup\nlocal storage.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Depending on\nthe BPF program type, a local storage area can be shared\nbetween multiple instances of the BPF program, running\nsimultaneously.\n\n<p style=\"margin-left:32%; margin-top: 1em\">A user should\ncare about the synchronization by himself. For example, by\nusing the <b>BPF_STX_XADD</b> instruction to alter the\nshared data.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>A pointer to the local storage area.</td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_select_reuseport(struct sk_reuseport_md\n*</b><i>reuse</i><b>, struct <br>\nbpf_map *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Select a <b>SO_REUSEPORT</b>\nsocket from a <b>BPF_MAP_TYPE_REUSEPORT_ARRAY</b>\n<i>map</i>. It checks the selected socket is matching the\nincoming request in the socket buffer.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_skb_ancestor_cgroup_id(struct sk_buff\n*</b><i>skb</i><b>, int</b>\n<i>ancestor_level</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return id of cgroup v2 that is\nancestor of cgroup associated with the <i>skb</i> at the\n<i>ancestor_level</i>. The root cgroup is at\n<i>ancestor_level</i> zero and each step down the hierarchy\nincrements the level. If <i>ancestor_level</i> == level of\ncgroup associated with <i>skb</i>, then return value will be\nsame as that of <b>bpf_skb_cgroup_id</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">The helper is\nuseful to implement policies based on cgroups that are upper\nin hierarchy than immediate cgroup associated with\n<i>skb</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The format of\nreturned id and helper limitations are same as in\n<b>bpf_skb_cgroup_id</b>().\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_sk_lookup_tcp(void *</b><i>ctx</i><b>, struct\nbpf_sock_tuple <br>\n*</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>\n<i>netns</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Look for TCP socket matching\n<i>tuple</i>, optionally in a child network namespace\n<i>netns</i>. The return value must be checked, and if\nnon-<b>NULL</b>, released via <b>bpf_sk_release</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the context of the program, such as the skb\nor socket (depending on the hook in use). This is used to\ndetermine the base network namespace for the lookup.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>tuple_size</i>\nmust be one of: <b><br>\nsizeof(</b><i>tuple</i><b>-&gt;ipv4)</b>\n\n<p style=\"margin-left:43%;\">Look for an IPv4 socket.\n\n\n<p style=\"margin-left:32%;\"><b>sizeof(</b><i>tuple</i><b>-&gt;ipv6)</b>\n\n<p style=\"margin-left:43%;\">Look for an IPv6 socket.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>netns</i> is a negative signed 32-bit integer, then the\nsocket lookup table in the netns associated with the\n<i>ctx</i> will be used. For the TC hooks, this is the netns\nof the device in the skb. For socket hooks, this is the\nnetns of the socket. If <i>netns</i> is any other signed\n32-bit value greater than or equal to zero then it specifies\nthe ID of the netns relative to the netns associated with\nthe <i>ctx</i>. <i>netns</i> values beyond the range of\n32-bit integers are reserved for future use.\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_NET</b> configuration option.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in\ncase of failure. For sockets with reuseport option, the\n<b>struct bpf_sock</b> result is from\n<i>reuse</i><b>-&gt;socks</b>[] using the hash of the\ntuple. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_sk_lookup_udp(void *</b><i>ctx</i><b>, struct\nbpf_sock_tuple <br>\n*</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>\n<i>netns</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Look for UDP socket matching\n<i>tuple</i>, optionally in a child network namespace\n<i>netns</i>. The return value must be checked, and if\nnon-<b>NULL</b>, released via <b>bpf_sk_release</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the context of the program, such as the skb\nor socket (depending on the hook in use). This is used to\ndetermine the base network namespace for the lookup.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>tuple_size</i>\nmust be one of: <b><br>\nsizeof(</b><i>tuple</i><b>-&gt;ipv4)</b>\n\n<p style=\"margin-left:43%;\">Look for an IPv4 socket.\n\n\n<p style=\"margin-left:32%;\"><b>sizeof(</b><i>tuple</i><b>-&gt;ipv6)</b>\n\n<p style=\"margin-left:43%;\">Look for an IPv6 socket.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>netns</i> is a negative signed 32-bit integer, then the\nsocket lookup table in the netns associated with the\n<i>ctx</i> will be used. For the TC hooks, this is the netns\nof the device in the skb. For socket hooks, this is the\nnetns of the socket. If <i>netns</i> is any other signed\n32-bit value greater than or equal to zero then it specifies\nthe ID of the netns relative to the netns associated with\nthe <i>ctx</i>. <i>netns</i> values beyond the range of\n32-bit integers are reserved for future use.\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_NET</b> configuration option.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in\ncase of failure. For sockets with reuseport option, the\n<b>struct bpf_sock</b> result is from\n<i>reuse</i><b>-&gt;socks</b>[] using the hash of the\ntuple. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_sk_release(struct\nbpf_sock *</b><i>sock</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Release the reference held by\n<i>sock</i>. <i>sock</i> must be a non-<b>NULL</b> pointer\nthat was returned from <b>bpf_sk_lookup_xxx</b>().\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_push_elem(struct bpf_map *</b><i>map</i><b>, const\nvoid *</b><i>value</i><b>, u64</b> <i><br>\nflags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Push an element <i>value</i> in\n<i>map</i>. <i>flags</i> is one of: <b><br>\nBPF_EXIST</b>\n\n<p style=\"margin-left:43%;\">If the queue/stack is full, the\noldest element is removed to make room for this.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_map_pop_elem(struct\nbpf_map *</b><i>map</i><b>, void\n*</b><i>value</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Pop an element from\n<i>map</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_peek_elem(struct bpf_map *</b><i>map</i><b>, void\n*</b><i>value</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get an element from <i>map</i>\nwithout removing it.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_push_data(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>start</i><b>, u32</b> <i>len</i><b>, u64</b>\n<i><br>\nflags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">For socket policies, insert\n<i>len</i> bytes into <i>msg</i> at offset <i>start</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If a program of\ntype <b>BPF_PROG_TYPE_SK_MSG</b> is run on a <i>msg</i> it\nmay want to insert metadata or options into the <i>msg</i>.\nThis can later be read and used by any of the lower layer\nBPF hooks.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper may\nfail if under memory pressure (a malloc fails) in these\ncases BPF programs will get an appropriate error and BPF\nprograms will need to handle them.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_msg_pop_data(struct\nsk_msg_buff *</b><i>msg</i><b>, u32</b> <i>start</i><b>,\nu32</b> <i>len</i><b>, u64</b> <i><br>\nflags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Will remove <i>len</i> bytes\nfrom a <i>msg</i> starting at byte <i>start</i>. This may\nresult in <b>ENOMEM</b> errors under certain situations if\nan allocation and copy are required due to a full ring\nbuffer. However, the helper will try to avoid doing the\nallocation if possible. Other errors can occur if input\nparameters are invalid either due to <i>start</i> byte not\nbeing valid part of <i>msg</i> payload and/or <i>pop</i>\nvalue being to large.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_rc_pointer_rel(void\n*</b><i>ctx</i><b>, s32</b> <i>rel_x</i><b>, s32</b>\n<i>rel_y</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing IR decoding, to report a successfully decoded\npointer movement.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the lirc sample as passed into the\nprogram.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to\n&quot;<b>y</b>&quot;.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_spin_lock(struct\nbpf_spin_lock *</b><i>lock</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Acquire a spinlock represented\nby the pointer <i>lock</i>, which is stored as part of a\nvalue of a map. Taking the lock allows to safely update the\nrest of the fields in that value. The spinlock can (and\nmust) later be released with a call to\n<b>bpf_spin_unlock</b>(<i>lock</i>).\n\n<p style=\"margin-left:32%; margin-top: 1em\">Spinlocks in\nBPF programs come with a number of restrictions and\nconstraints:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> objects are only allowed inside\nmaps of types <b>BPF_MAP_TYPE_HASH</b> and\n<b>BPF_MAP_TYPE_ARRAY</b> (this list could be extended in\nthe future).</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>BTF description of the map is mandatory.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The BPF program can take ONE lock at a time, since\ntaking two or more could cause dead locks.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Only one <b>struct bpf_spin_lock</b> is allowed per map\nelement. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>When the lock is taken, calls (either BPF to BPF or\nhelpers) are not allowed.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The <b>BPF_LD_ABS</b> and <b>BPF_LD_IND</b> instructions\nare not allowed inside a spinlock-ed region.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The BPF program MUST call <b>bpf_spin_unlock</b>() to\nrelease the lock, on all execution paths, before it\nreturns. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The BPF program can access <b>struct bpf_spin_lock</b>\nonly via the <b>bpf_spin_lock</b>() and\n<b>bpf_spin_unlock</b>() helpers. Loading or storing data\ninto the <b>struct bpf_spin_lock</b> <i>lock</i><b>;</b>\nfield of a map is not allowed.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>To use the <b>bpf_spin_lock</b>() helper, the BTF\ndescription of the map value must be a struct and have\n<b>struct bpf_spin_lock</b> <i>anyname</i><b>;</b> field at\nthe top level. Nested lock inside another struct is not\nallowed. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The <b>struct bpf_spin_lock</b> <i>lock</i> field in a\nmap value must be aligned on a multiple of 4 bytes in that\nvalue. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Syscall with command <b>BPF_MAP_LOOKUP_ELEM</b> does not\ncopy the <b>bpf_spin_lock</b> field to user space.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Syscall with command <b>BPF_MAP_UPDATE_ELEM</b>, or\nupdate from a BPF program, do not update the\n<b>bpf_spin_lock</b> field.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> cannot be on the stack or inside a\nnetworking packet (it can only be inside of a map\nvalues). </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> is available to root only.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Tracing programs and socket filter programs cannot use\n<b>bpf_spin_lock</b>() due to insufficient preemption checks\n(but this may change in the future).</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> is not allowed in inner maps of\nmap-in-map. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0\n\n<p style=\"margin-left:11%;\"><b>long bpf_spin_unlock(struct\nbpf_spin_lock *</b><i>lock</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Release the <i>lock</i>\npreviously locked by a call to\n<b>bpf_spin_lock</b>(<i>lock</i>).\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_sk_fullsock(struct bpf_sock *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper gets a <b>struct\nbpf_sock</b> pointer such that all the fields in this\n<b>bpf_sock</b> can be accessed.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A <b>struct bpf_sock</b> pointer on success, or\n<b>NULL</b> in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_tcp_sock\n*bpf_tcp_sock(struct bpf_sock *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">This helper gets a <b>struct\nbpf_tcp_sock</b> pointer from a <b>struct bpf_sock</b>\npointer.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A <b>struct bpf_tcp_sock</b> pointer on success, or\n<b>NULL</b> in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_ecn_set_ce(struct sk_buff\n*</b><i>skb</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Set ECN (Explicit Congestion\nNotification) field of IP header to <b>CE</b> (Congestion\nEncountered) if current value is <b>ECT</b> (ECN Capable\nTransport). Otherwise, do nothing. Works with IPv6 and\nIPv4.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>1 if the <b>CE</b> flag is set (either by the current\nhelper call or because it was already present), 0 if it is\nnot set.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_get_listener_sock(struct bpf_sock\n*</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return a <b>struct bpf_sock</b>\npointer in <b>TCP_LISTEN</b> state. <b>bpf_sk_release</b>()\nis unnecessary and not allowed.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A <b>struct bpf_sock</b> pointer on success, or\n<b>NULL</b> in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_skc_lookup_tcp(void *</b><i>ctx</i><b>, struct\nbpf_sock_tuple <br>\n*</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>\n<i>netns</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Look for TCP socket matching\n<i>tuple</i>, optionally in a child network namespace\n<i>netns</i>. The return value must be checked, and if\nnon-<b>NULL</b>, released via <b>bpf_sk_release</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">This function\nis identical to <b>bpf_sk_lookup_tcp</b>(), except that it\nalso returns timewait or request sockets. Use\n<b>bpf_sk_fullsock</b>() or <b>bpf_tcp_sock</b>() to access\nthe full structure.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_NET</b> configuration option.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in\ncase of failure. For sockets with reuseport option, the\n<b>struct bpf_sock</b> result is from\n<i>reuse</i><b>-&gt;socks</b>[] using the hash of the\ntuple. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_tcp_check_syncookie(struct bpf_sock *</b><i>sk</i><b>,\nvoid *</b><i>iph</i><b>, u32</b> <i><br>\niph_len</i><b>, struct tcphdr *</b><i>th</i><b>, u32</b>\n<i>th_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Check whether <i>iph</i> and\n<i>th</i> contain a valid SYN cookie ACK for the listening\nsocket in <i>sk</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>iph</i>\npoints to the start of the IPv4 or IPv6 header, while\n<i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>)\nor <b>sizeof</b>(<b>struct ip6hdr</b>).\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>th</i>\npoints to the start of the TCP header, while <i>th_len</i>\ncontains <b>sizeof</b>(<b>struct tcphdr</b>).\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 if <i>iph</i> and <i>th</i> are a valid SYN cookie\nACK, or a negative error otherwise.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_get_name(struct bpf_sysctl *</b><i>ctx</i><b>,\nchar *</b><i>buf</i><b>, size_t</b> <i><br>\nbuf_len</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get name of sysctl in\n/proc/sys/ and copy it into provided by program buffer\n<i>buf</i> of size <i>buf_len</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The buffer is\nalways NUL terminated, unless it's zero-sized.\n\n<p style=\"margin-left:32%; margin-top: 1em\">If <i>flags</i>\nis zero, full name (e.g. &quot;net/ipv4/tcp_mem&quot;) is\ncopied. Use <b>BPF_F_SYSCTL_BASE_NAME</b> flag to copy base\nname only (e.g. &quot;tcp_mem&quot;).\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of character copied (not including the trailing\nNUL). </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the buffer wasn't big enough (<i>buf</i> will contain\ntruncated name in this case).\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_get_current_value(struct bpf_sysctl\n*</b><i>ctx</i><b>, char *</b><i>buf</i><b>, <br>\nsize_t</b> <i>buf_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get current value of sysctl as\nit is presented in /proc/sys (incl. newline, etc), and copy\nit as a string into provided by program buffer <i>buf</i> of\nsize <i>buf_len</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The whole value\nis copied, no matter what file position user space issued\ne.g. sys_read at.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The buffer is\nalways NUL terminated, unless it's zero-sized.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of character copied (not including the trailing\nNUL). </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the buffer wasn't big enough (<i>buf</i> will contain\ntruncated name in this case).\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif current value was unavailable, e.g. because sysctl is\nuninitialized and read returns -EIO for it.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_get_new_value(struct bpf_sysctl\n*</b><i>ctx</i><b>, char *</b><i>buf</i><b>, size_t</b>\n<i><br>\nbuf_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get new value being written by\nuser space to sysctl (before the actual write happens) and\ncopy it as a string into provided by program buffer\n<i>buf</i> of size <i>buf_len</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">User space may\nwrite new value at file position &gt; 0.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The buffer is\nalways NUL terminated, unless it's zero-sized.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of character copied (not including the trailing\nNUL). </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the buffer wasn't big enough (<i>buf</i> will contain\ntruncated name in this case).\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif sysctl is being read.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_set_new_value(struct bpf_sysctl\n*</b><i>ctx</i><b>, const char *</b><i>buf</i><b>, <br>\nsize_t</b> <i>buf_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Override new value being\nwritten by user space to sysctl with value provided by\nprogram in buffer <i>buf</i> of size <i>buf_len</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>buf</i>\nshould contain a string in same form as provided by user\nspace on sysctl write.\n\n<p style=\"margin-left:32%; margin-top: 1em\">User space may\nwrite new value at file position &gt; 0. To override the\nwhole sysctl value file position should be set to zero.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"20%\">\n\n\n<p>0 on success.</td>\n<td width=\"48%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the <i>buf_len</i> is too big.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif sysctl is being read.\n\n<p style=\"margin-left:11%;\"><b>long bpf_strtol(const char\n*</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>, u64</b>\n<i>flags</i><b>, long *</b><i>res</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Convert the initial part of the\nstring from buffer <i>buf</i> of size <i>buf_len</i> to a\nlong integer according to the given base and save the result\nin <i>res</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The string may\nbegin with an arbitrary amount of white space (as determined\nby <a href=\"https://man.page/3/isspace\">isspace(3)</a>) followed by a single optional\n'<b>-</b>' sign.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Five least\nsignificant bits of <i>flags</i> encode base, other bits are\ncurrently unused.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Base must be\neither 8, 10, 16 or 0 to detect it automatically similar to\nuser space <a href=\"https://man.page/3/strtol\">strtol(3)</a>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of characters consumed on success. Must be\npositive but no more than <i>buf_len</i>.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif no valid digits were found or unsupported base was\nprovided.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ERANGE</b>\nif resulting value was out of range.\n\n<p style=\"margin-left:11%;\"><b>long bpf_strtoul(const char\n*</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>, u64</b>\n<i>flags</i><b>, unsigned <br>\nlong *</b><i>res</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Convert the initial part of the\nstring from buffer <i>buf</i> of size <i>buf_len</i> to an\nunsigned long integer according to the given base and save\nthe result in <i>res</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The string may\nbegin with an arbitrary amount of white space (as determined\nby <a href=\"https://man.page/3/isspace\">isspace(3)</a>).\n\n<p style=\"margin-left:32%; margin-top: 1em\">Five least\nsignificant bits of <i>flags</i> encode base, other bits are\ncurrently unused.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Base must be\neither 8, 10, 16 or 0 to detect it automatically similar to\nuser space <a href=\"https://man.page/3/strtoul\">strtoul(3)</a>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of characters consumed on success. Must be\npositive but no more than <i>buf_len</i>.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif no valid digits were found or unsupported base was\nprovided.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ERANGE</b>\nif resulting value was out of range.\n\n<p style=\"margin-left:11%;\"><b>void\n*bpf_sk_storage_get(struct bpf_map *</b><i>map</i><b>,\nstruct bpf_sock *</b><i>sk</i><b>, void <br>\n*</b><i>value</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Get a bpf-local-storage from a\n<i>sk</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Logically, it\ncould be thought of getting the value from a <i>map</i> with\n<i>sk</i> as the <b>key</b>. From this perspective, the\nusage is not much different from\n<b>bpf_map_lookup_elem</b>(<i>map</i>,\n<b>&amp;</b><i>sk</i>) except this helper enforces the key\nmust be a full socket and the map must be a\n<b>BPF_MAP_TYPE_SK_STORAGE</b> also.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Underneath, the\nvalue is stored locally at <i>sk</i> instead of the\n<i>map</i>. The <i>map</i> is used as the bpf-local-storage\n&quot;type&quot;. The bpf-local-storage &quot;type&quot;\n(i.e. the <i>map</i>) is searched against all\nbpf-local-storages residing at <i>sk</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">An optional\n<i>flags</i> (<b>BPF_SK_STORAGE_GET_F_CREATE</b>) can be\nused such that a new bpf-local-storage will be created if\none does not exist. <i>value</i> can be used together with\n<b>BPF_SK_STORAGE_GET_F_CREATE</b> to specify the initial\nvalue of a bpf-local-storage. If <i>value</i> is\n<b>NULL</b>, the new bpf-local-storage will be zero\ninitialized.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A bpf-local-storage pointer is returned on success.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>NULL</b> if\nnot found or there was an error in adding a new\nbpf-local-storage.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_storage_delete(struct bpf_map *</b><i>map</i><b>,\nstruct bpf_sock *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Delete a bpf-local-storage from\na <i>sk</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"20%\">\n\n\n<p>0 on success.</td>\n<td width=\"48%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif the bpf-local-storage cannot be found.\n\n<p style=\"margin-left:11%;\"><b>long bpf_send_signal(u32</b>\n<i>sig</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Send signal <i>sig</i> to the\nprocess of the current task. The signal may be delivered to\nany of this process's threads.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>0 on success or successfully queued.</td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EBUSY</b>\nif work queue under nmi is full.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif <i>sig</i> is invalid.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EPERM</b>\nif no permission to send the <i>sig</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EAGAIN</b>\nif bpf program can try again.\n\n<p style=\"margin-left:11%;\"><b>s64\nbpf_tcp_gen_syncookie(struct bpf_sock *</b><i>sk</i><b>,\nvoid *</b><i>iph</i><b>, u32</b> <i>iph_len</i><b>, <br>\nstruct tcphdr *</b><i>th</i><b>, u32</b>\n<i>th_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Try to issue a SYN cookie for\nthe packet with corresponding IP/TCP headers, <i>iph</i> and\n<i>th</i>, on the listening socket in <i>sk</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>iph</i>\npoints to the start of the IPv4 or IPv6 header, while\n<i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>)\nor <b>sizeof</b>(<b>struct ip6hdr</b>).\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>th</i>\npoints to the start of the TCP header, while <i>th_len</i>\ncontains the length of the TCP header.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, lower 32 bits hold the generated SYN cookie\nin followed by 16 bits which hold the MSS value for that\ncookie, and the top 16 bits are unused.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">On failure, the\nreturned value is one of the following:\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nSYN cookie cannot be issued due to error\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nSYN cookie should not be issued (no SYN flood)\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOPNOTSUPP</b>\nkernel configuration does not enable SYN cookies\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EPROTONOSUPPORT</b>\nIP packet version is not 4 or 6\n\n<p style=\"margin-left:11%;\"><b>long bpf_skb_output(void\n*</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>, void <br>\n*</b><i>data</i><b>, u64</b> <i>size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Write raw <i>data</i> blob into\na special BPF perf event held by <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event must\nhave the following attributes: <b>PERF_SAMPLE_RAW</b> as\n<b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as\n<b>type</b>, and <b>PERF_COUNT_SW_BPF_OUTPUT</b> as\n<b>config</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> are used to indicate the index in <i>map</i>\nfor which the value must be put, masked with\n<b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be\nset to <b>BPF_F_CURRENT_CPU</b> to indicate that the index\nof the current CPU core should be used.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The value to\nwrite, of <i>size</i>, is passed through eBPF stack and\npointed by <i>data</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>ctx</i> is a\npointer to in-kernel struct sk_buff.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nsimilar to <b>bpf_perf_event_output</b>() but restricted to\nraw_tracepoint bpf programs.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_user(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Safely attempt to read\n<i>size</i> bytes from user space address <i>unsafe_ptr</i>\nand store the data in <i>dst</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_kernel(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Safely attempt to read\n<i>size</i> bytes from kernel space address\n<i>unsafe_ptr</i> and store the data in <i>dst</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_user_str(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void <br>\n*</b><i>unsafe_ptr</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Copy a NUL terminated string\nfrom an unsafe user address <i>unsafe_ptr</i> to <i>dst</i>.\nThe <i>size</i> should include the terminating NUL byte. In\ncase the string length is smaller than <i>size</i>, the\ntarget is not padded with further NUL bytes. If the string\nlength is larger than <i>size</i>, just <i>size</i>-1 bytes\nare copied and the last byte is set to NUL.\n\n<p style=\"margin-left:32%; margin-top: 1em\">On success, the\nlength of the copied string is returned. This makes this\nhelper useful in tracing programs for reading strings, and\nmore importantly to get its length at runtime. See the\nfollowing snippet:\n<pre style=\"margin-left:37%; margin-top: 1em\">SEC(&quot;kprobe/sys_open&quot;)\nvoid bpf_sys_open(struct pt_regs *ctx)\n{\n        char buf[PATHLEN]; // PATHLEN is defined to 256\n        int res = bpf_probe_read_user_str(buf, sizeof(buf),\n                                          ctx-&gt;di);\n\n\n        // Consume buf, for example push it to\n        // userspace via bpf_perf_event_output(); we\n        // can use res (the string length) as event\n        // size, after checking its boundaries.\n}</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">In comparison,\nusing <b>bpf_probe_read_user</b>() helper here instead to\nread the string would require to estimate the length at\ncompile time, and would often result in copying more memory\nthan necessary.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Another useful\nuse case is when parsing individual process arguments or\nindividual environment variables navigating\n<i>current</i><b>-&gt;mm-&gt;arg_start</b> and\n<i>current</i><b>-&gt;mm-&gt;env_start</b>: using this\nhelper and the return value, one can quickly iterate at the\nright offset of the memory area.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, the strictly positive length of the string,\nincluding the trailing NUL character. On error, a negative\nvalue. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_kernel_str(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void <br>\n*</b><i>unsafe_ptr</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Copy a NUL terminated string\nfrom an unsafe kernel address <i>unsafe_ptr</i> to\n<i>dst</i>. Same semantics as with\n<b>bpf_probe_read_user_str</b>() apply.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, the strictly positive length of the string,\nincluding the trailing NUL character. On error, a negative\nvalue. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_tcp_send_ack(void\n*</b><i>tp</i><b>, u32</b> <i>rcv_nxt</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Send out a tcp-ack. <i>tp</i>\nis the in-kernel struct <b>tcp_sock</b>. <i>rcv_nxt</i> is\nthe ack_seq to be sent out.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_send_signal_thread(u32</b> <i>sig</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Send signal <i>sig</i> to the\nthread corresponding to the current task.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>0 on success or successfully queued.</td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EBUSY</b>\nif work queue under nmi is full.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif <i>sig</i> is invalid.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EPERM</b>\nif no permission to send the <i>sig</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EAGAIN</b>\nif bpf program can try again.\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_jiffies64(void)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Obtain the 64bit jiffies\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"28%\">\n\n\n<p>The 64 bit jiffies</td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_read_branch_records(struct bpf_perf_event_data\n*</b><i>ctx</i><b>, void <br>\n*</b><i>buf</i><b>, u32</b> <i>size</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">For an eBPF program attached to\na perf event, retrieve the branch records (<b>struct\nperf_branch_entry</b>) associated to <i>ctx</i> and store it\nin the buffer pointed by <i>buf</i> up to size <i>size</i>\nbytes.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, number of bytes written to <i>buf</i>. On\nerror, a negative value.</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> can be set to\n<b>BPF_F_GET_BRANCH_RECORDS_SIZE</b> to instead return the\nnumber of bytes required to store all the branch entries. If\nthis flag is set, <i>buf</i> may be NULL.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif arguments invalid or <b>size</b> not a multiple of\n<b>sizeof</b>(<b>struct perf_branch_entry</b>).\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif architecture does not support branch records.\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_ns_current_pid_tgid(u64</b> <i>dev</i><b>, u64</b>\n<i>ino</i><b>, struct <br>\nbpf_pidns_info *</b><i>nsdata</i><b>, u32</b>\n<i>size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Returns 0 on success, values\nfor <i>pid</i> and <i>tgid</i> as seen from the current\n<i>namespace</i> will be returned in <i>nsdata</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or one of the following in case of\nfailure: </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif dev and inum supplied don't match dev_t and inode number\nwith nsfs of current task, or if dev conversion to dev_t\nlost high bits.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif pidns does not exists for the current task.\n\n<p style=\"margin-left:11%;\"><b>long bpf_xdp_output(void\n*</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>, void <br>\n*</b><i>data</i><b>, u64</b> <i>size</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Write raw <i>data</i> blob into\na special BPF perf event held by <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event must\nhave the following attributes: <b>PERF_SAMPLE_RAW</b> as\n<b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as\n<b>type</b>, and <b>PERF_COUNT_SW_BPF_OUTPUT</b> as\n<b>config</b>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> are used to indicate the index in <i>map</i>\nfor which the value must be put, masked with\n<b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be\nset to <b>BPF_F_CURRENT_CPU</b> to indicate that the index\nof the current CPU core should be used.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The value to\nwrite, of <i>size</i>, is passed through eBPF stack and\npointed by <i>data</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>ctx</i> is a\npointer to in-kernel struct xdp_buff.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nsimilar to <b>bpf_perf_eventoutput</b>() but restricted to\nraw_tracepoint bpf programs.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_netns_cookie(void *</b><i>ctx</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Retrieve the cookie (generated\nby the kernel) of the network namespace the input <i>ctx</i>\nis associated with. The network namespace cookie remains\nstable for its lifetime and provides a global identifier\nthat can be assumed unique. If <i>ctx</i> is NULL, then the\nhelper returns the cookie for the initial network namespace.\nThe cookie itself is very similar to that of\n<b>bpf_get_socket_cookie</b>() helper, but for network\nnamespaces instead of sockets.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"43%\">\n\n\n<p>A 8-byte long opaque number.</td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_ancestor_cgroup_id(int</b>\n<i>ancestor_level</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return id of cgroup v2 that is\nancestor of the cgroup associated with the current task at\nthe <i>ancestor_level</i>. The root cgroup is at\n<i>ancestor_level</i> zero and each step down the hierarchy\nincrements the level. If <i>ancestor_level</i> == level of\ncgroup associated with the current task, then return value\nwill be the same as that of\n<b>bpf_get_current_cgroup_id</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">The helper is\nuseful to implement policies based on cgroups that are upper\nin hierarchy than immediate cgroup associated with the\ncurrent task.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The format of\nreturned id and helper limitations are same as in\n<b>bpf_get_current_cgroup_id</b>().\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_sk_assign(struct\nsk_buff *</b><i>skb</i><b>, struct bpf_sock\n*</b><i>sk</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Helper is overloaded depending\non BPF program type. This description applies to\n<b>BPF_PROG_TYPE_SCHED_CLS</b> and\n<b>BPF_PROG_TYPE_SCHED_ACT</b> programs.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Assign the\n<i>sk</i> to the <i>skb</i>. When combined with appropriate\nrouting configuration to receive the packet towards the\nsocket, will cause <i>skb</i> to be delivered to the\nspecified socket. Subsequent redirection of <i>skb</i> via\n<b>bpf_redirect</b>(), <b>bpf_clone_redirect</b>() or other\nmethods outside of BPF may interfere with successful\ndelivery to the socket.\n\n<p style=\"margin-left:32%; margin-top: 1em\">This operation\nis only valid from TC ingress path.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> argument must be zero.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure: </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif specified <i>flags</i> are not supported.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif the socket is unavailable for assignment.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENETUNREACH</b>\nif the socket is unreachable (wrong netns).\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOPNOTSUPP</b>\nif the operation is not supported, for example a call from\noutside of TC ingress.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ESOCKTNOSUPPORT</b>\nif the socket type is not supported (reuseport).\n\n<p style=\"margin-left:11%;\"><b>long bpf_sk_assign(struct\nbpf_sk_lookup *</b><i>ctx</i><b>, struct bpf_sock\n*</b><i>sk</i><b>, u64</b> <i><br>\nflags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Helper is overloaded depending\non BPF program type. This description applies to\n<b>BPF_PROG_TYPE_SK_LOOKUP</b> programs.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Select the\n<i>sk</i> as a result of a socket lookup.\n\n<p style=\"margin-left:32%; margin-top: 1em\">For the\noperation to succeed passed socket must be compatible with\nthe packet description provided by the <i>ctx</i>\nobject.\n\n<p style=\"margin-left:32%; margin-top: 1em\">L4 protocol\n(<b>IPPROTO_TCP</b> or <b>IPPROTO_UDP</b>) must be an exact\nmatch. While IP family (<b>AF_INET</b> or <b>AF_INET6</b>)\nmust be compatible, that is IPv6 sockets that are not\nv6-only can be selected for IPv4 packets.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Only TCP\nlisteners and UDP unconnected sockets can be selected.\n<i>sk</i> can also be NULL to reset any previous\nselection.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>flags</i>\nargument can combination of following values:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SK_LOOKUP_F_REPLACE</b> to override the previous\nsocket selection, potentially done by a BPF program that ran\nbefore us.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SK_LOOKUP_F_NO_REUSEPORT</b> to skip\nload-balancing within reuseport group for the socket being\nselected. </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">On success\n<i>ctx-&gt;sk</i> will point to the selected socket.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">0 on success, or a negative\nerrno in case of failure.</td></tr>\n</table>\n\n<p style=\"margin-left:32%;\">&bull;\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>-EAFNOSUPPORT</b> if socket\nfamily (<i>sk-&gt;family</i>) is not compatible with packet\nfamily (<i>ctx-&gt;family</i>).</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-EEXIST</b> if socket has been already selected,\npotentially by another program, and\n<b>BPF_SK_LOOKUP_F_REPLACE</b> flag was not specified.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-EINVAL</b> if unsupported flags were specified.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-EPROTOTYPE</b> if socket L4 protocol\n(<i>sk-&gt;protocol</i>) doesn't match packet protocol\n(<i>ctx-&gt;protocol</i>). </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-ESOCKTNOSUPPORT</b> if socket is not in allowed\nstate (TCP listening or UDP unconnected).</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_ktime_get_boot_ns(void)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return the time elapsed since\nsystem boot, in nanoseconds. Does include the time the\nsystem was suspended. See:\n<b>clock_gettime</b>(<b>CLOCK_BOOTTIME</b>)\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"22%\">\n\n\n<p>Current <i>ktime</i>.</td>\n<td width=\"46%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_seq_printf(struct\nseq_file *</b><i>m</i><b>, const char *</b><i>fmt</i><b>,\nu32</b> <i>fmt_size</i><b>, <br>\nconst void *</b><i>data</i><b>, u32</b>\n<i>data_len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\"><b>bpf_seq_printf</b>() uses\nseq_file <b>seq_printf</b>() to print out the format string.\nThe <i>m</i> represents the seq_file. The <i>fmt</i> and\n<i>fmt_size</i> are for the format string itself. The\n<i>data</i> and <i>data_len</i> are format string arguments.\nThe <i>data</i> are a <b>u64</b> array and corresponding\nformat string values are stored in the array. For strings\nand pointers where pointees are accessed, only the pointer\nvalues are stored in the <i>data</i> array. The\n<i>data_len</i> is the size of <i>data</i> in bytes.\n\n<p style=\"margin-left:32%; margin-top: 1em\">Formats\n<b>%s</b>, <b>%p{i,I}{4,6}</b> requires to read kernel\nmemory. Reading kernel memory may fail due to either invalid\naddress or valid address but requiring a major memory fault.\nIf reading kernel memory fails, the string for <b>%s</b>\nwill be an empty string, and the ip address for\n<b>%p{i,I}{4,6}</b> will be 0. Not returning error to bpf\nprogram is consistent with what <b>bpf_trace_printk</b>()\ndoes for now.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure: </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EBUSY</b>\nif per-CPU memory copy buffer is busy, can try again by\nreturning 1 from bpf program.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif arguments are invalid, or if <i>fmt</i> is\ninvalid/unsupported.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif <i>fmt</i> contains too many format specifiers.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOVERFLOW</b>\nif an overflow happened: The same object will be tried\nagain.\n\n<p style=\"margin-left:11%;\"><b>long bpf_seq_write(struct\nseq_file *</b><i>m</i><b>, const void *</b><i>data</i><b>,\nu32</b> <i>len</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\"><b>bpf_seq_write</b>() uses\nseq_file <b>seq_write</b>() to write the data. The <i>m</i>\nrepresents the seq_file. The <i>data</i> and <i>len</i>\nrepresent the data to write in bytes.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure: </td></tr>\n</table>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOVERFLOW</b>\nif an overflow happened: The same object will be tried\nagain.\n\n<p style=\"margin-left:11%;\"><b>u64 bpf_sk_cgroup_id(struct\nbpf_sock *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return the cgroup v2 id of the\nsocket <i>sk</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>sk</i> must\nbe a non-<b>NULL</b> pointer to a full socket, e.g. one\nreturned from <b>bpf_sk_lookup_xxx</b>(),\n<b>bpf_sk_fullsock</b>(), etc. The format of returned id is\nsame as in <b>bpf_skb_cgroup_id</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with the\n<b>CONFIG_SOCK_CGROUP_DATA</b> configuration option.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_sk_ancestor_cgroup_id(struct bpf_sock *</b><i>sk</i><b>,\nint</b> <i>ancestor_level</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return id of cgroup v2 that is\nancestor of cgroup associated with the <i>sk</i> at the\n<i>ancestor_level</i>. The root cgroup is at\n<i>ancestor_level</i> zero and each step down the hierarchy\nincrements the level. If <i>ancestor_level</i> == level of\ncgroup associated with <i>sk</i>, then return value will be\nsame as that of <b>bpf_sk_cgroup_id</b>().\n\n<p style=\"margin-left:32%; margin-top: 1em\">The helper is\nuseful to implement policies based on cgroups that are upper\nin hierarchy than immediate cgroup associated with\n<i>sk</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The format of\nreturned id and helper limitations are same as in\n<b>bpf_sk_cgroup_id</b>().\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_ringbuf_output(void\n*</b><i>ringbuf</i><b>, void *</b><i>data</i><b>, u64</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Copy <i>size</i> bytes from\n<i>data</i> into a ring buffer <i>ringbuf</i>. If\n<b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no\nnotification of new data availability is sent. If\n<b>BPF_RB_FORCE_WAKEUP</b> is specified in <i>flags</i>,\nnotification of new data availability is sent\nunconditionally.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\n*bpf_ringbuf_reserve(void *</b><i>ringbuf</i><b>, u64</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Reserve <i>size</i> bytes of\npayload in a ring buffer <i>ringbuf</i>.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Valid pointer with <i>size</i> bytes of memory\navailable; NULL, otherwise.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void bpf_ringbuf_submit(void\n*</b><i>data</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Submit reserved ring buffer\nsample, pointed to by <i>data</i>. If\n<b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no\nnotification of new data availability is sent. If\n<b>BPF_RB_FORCE_WAKEUP</b> is specified in <i>flags</i>,\nnotification of new data availability is sent\nunconditionally.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"39%\">\n\n\n<p>Nothing. Always succeeds.</td>\n<td width=\"29%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\nbpf_ringbuf_discard(void *</b><i>data</i><b>, u64</b>\n<i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Discard reserved ring buffer\nsample, pointed to by <i>data</i>. If\n<b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no\nnotification of new data availability is sent. If\n<b>BPF_RB_FORCE_WAKEUP</b> is specified in <i>flags</i>,\nnotification of new data availability is sent\nunconditionally.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"39%\">\n\n\n<p>Nothing. Always succeeds.</td>\n<td width=\"29%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64 bpf_ringbuf_query(void\n*</b><i>ringbuf</i><b>, u64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Query various characteristics\nof provided ring buffer. What exactly is queries is\ndetermined by <i>flags</i>:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_AVAIL_DATA</b>: Amount of data not yet\nconsumed. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_RING_SIZE</b>: The size of ring buffer.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_CONS_POS</b>: Consumer position (can wrap\naround). </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_PROD_POS</b>: Producer(s) position (can wrap\naround). </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Data returned\nis just a momentary snapshot of actual values and could be\ninaccurate, so this facility should be used to power\nheuristics and for reporting, not to make 100% correct\ncalculation.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">Requested value, or 0, if\n<i>flags</i> are not recognized.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_csum_level(struct\nsk_buff *</b><i>skb</i><b>, u64</b> <i>level</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Change the skbs checksum level\nby one layer up or down, or reset it entirely to none in\norder to have the stack perform checksum validation. The\nlevel is applicable to the following protocols: TCP, UDP,\nGRE, SCTP, FCOE. For example, a decap of | ETH | IP | UDP |\nGUE | IP | TCP | into | ETH | IP | TCP | through\n<b>bpf_skb_adjust_room</b>() helper with passing in\n<b>BPF_F_ADJ_ROOM_NO_CSUM_RESET</b> flag would require one\ncall to <b>bpf_csum_level</b>() with\n<b>BPF_CSUM_LEVEL_DEC</b> since the UDP header is removed.\nSimilarly, an encap of the latter into the former could be\naccompanied by a helper call to <b>bpf_csum_level</b>() with\n<b>BPF_CSUM_LEVEL_INC</b> if the skb is still intended to be\nprocessed in higher layers of the stack instead of just\negressing at tc.\n\n<p style=\"margin-left:32%; margin-top: 1em\">There are three\nsupported level settings at this time:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_INC</b>: Increases skb-&gt;csum_level\nfor skbs with CHECKSUM_UNNECESSARY.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_DEC</b>: Decreases skb-&gt;csum_level\nfor skbs with CHECKSUM_UNNECESSARY.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_RESET</b>: Resets skb-&gt;csum_level\nto 0 and sets CHECKSUM_NONE to force checksum validation by\nthe stack.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_QUERY</b>: No-op, returns the current\nskb-&gt;csum_level. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure. In the case of\n<b>BPF_CSUM_LEVEL_QUERY</b>, the current skb-&gt;csum_level\nis returned or the error code -EACCES in case the skb is not\nsubject to CHECKSUM_UNNECESSARY.\n\n<p style=\"margin-left:11%;\"><b>struct tcp6_sock\n*bpf_skc_to_tcp6_sock(void *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp6_sock</i> pointer.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct tcp_sock\n*bpf_skc_to_tcp_sock(void *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp_sock</i> pointer.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct tcp_timewait_sock\n*bpf_skc_to_tcp_timewait_sock(void\n*</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp_timewait_sock</i> pointer.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct tcp_request_sock\n*bpf_skc_to_tcp_request_sock(void *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp_request_sock</i> pointer.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct udp6_sock\n*bpf_skc_to_udp6_sock(void *</b><i>sk</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>udp6_sock</i> pointer.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_task_stack(struct task_struct *</b><i>task</i><b>,\nvoid *</b><i>buf</i><b>, u32</b> <i>size</i><b>, <br>\nu64</b> <i>flags</i><b>)</b>\n\n<p style=\"margin-left:22%;\"><b>Description</b>\n\n<p style=\"margin-left:32%;\">Return a user or a kernel stack\nin bpf program provided buffer. To achieve this, the helper\nneeds <i>task</i>, which is a valid pointer to struct\ntask_struct. To store the stacktrace, the bpf program\nprovides <i>buf</i> with a nonnegative <i>size</i>.\n\n<p style=\"margin-left:32%; margin-top: 1em\">The last\nargument, <i>flags</i>, holds the number of stack frames to\nskip (from 0 to 255), masked with\n<b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to\nset the following flags: <b><br>\nBPF_F_USER_STACK</b>\n\n<p style=\"margin-left:43%;\">Collect a user space stack\ninstead of a kernel stack.\n\n<p style=\"margin-left:32%;\"><b>BPF_F_USER_BUILD_ID</b>\n\n<p style=\"margin-left:43%;\">Collect buildid+offset instead\nof ips for user stack, only valid if <b>BPF_F_USER_STACK</b>\nis also specified.\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>bpf_get_task_stack</b>()\ncan collect up to <b>PERF_MAX_STACK_DEPTH</b> both kernel\nand user frames, subject to sufficient large buffer size.\nNote that this limit can be controlled with the\n<b>sysctl</b> program, and that it should be manually\nincreased in order to profile long user stacks (such as\nstacks for Java programs). To do so, use:\n\n<pre style=\"margin-left:37%; margin-top: 1em\"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</pre>\n\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A non-negative value equal to or less than <i>size</i>\non success, or a negative error in case of failure.</td></tr>\n</table>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\nExample usage\nfor most of the eBPF helpers listed in this manual page are\navailable within the Linux kernel sources, at the following\nlocations:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"43%\">\n\n\n<p style=\"margin-top: 1em\"><i>samples/bpf/</i></td>\n<td width=\"43%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"43%\">\n\n\n<p><i>tools/testing/selftests/bpf/</i></td>\n<td width=\"43%\">\n</td></tr>\n</table>\n\n<h2>LICENSE\n<a name=\"LICENSE\"></a>\n</h2>\n\n\neBPF programs\ncan have an associated license, passed along with the\nbytecode instructions to the kernel when the programs are\nloaded. The format for that string is identical to the one\nin use for kernel modules (Dual licenses, such as &quot;Dual\nBSD/GPL&quot;, may be used). Some helper functions are only\naccessible to programs that are compatible with the GNU\nPrivacy License (GPL).\n\nIn order to use\nsuch helpers, the eBPF program must be loaded with the\ncorrect license string passed (via <b>attr</b>) to the\n<b>bpf</b>() system call, and this generally translates into\nthe C source code of the program containing a line similar\nto the following:\n\n<pre style=\"margin-left:15%; margin-top: 1em\">char ____license[] __attribute__((section(&quot;license&quot;), used)) = &quot;GPL&quot;;</pre>\n\n\n<h2>IMPLEMENTATION\n<a name=\"IMPLEMENTATION\"></a>\n</h2>\n\n\nThis manual\npage is an effort to document the existing eBPF helper\nfunctions. But as of this writing, the BPF sub-system is\nunder heavy development. New eBPF program or map types are\nadded, along with new helper functions. Some helpers are\noccasionally made available for additional program types. So\nin spite of the efforts of the community, this page might\nnot be up-to-date. If you want to check by yourself what\nhelper functions exist in your kernel, or what types of\nprograms they can support, here are some files among the\nkernel tree that you may be interested in:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\"><i>include/uapi/linux/bpf.h</i>\nis the main BPF header. It contains the full list of all\nhelper functions, as well as many other BPF definitions\nincluding most of the flags, structs or constants used by\nthe helpers.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>net/core/filter.c</i> contains the definition of most\nnetwork-related helper functions, and the list of program\ntypes from which they can be used.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>kernel/trace/bpf_trace.c</i> is the equivalent for\nmost tracing program-related helpers.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>kernel/bpf/verifier.c</i> contains the functions used\nto check that valid types of eBPF maps are used with a given\nhelper function.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>kernel/bpf/</i> directory contains other files in\nwhich additional helpers are defined (for cgroups, sockmaps,\netc.). </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The bpftool utility can be used to probe the\navailability of helper functions on the system (as well as\nsupported program and map types, and a number of other\nparameters). To do so, run <b>bpftool feature probe</b> (see\n<b>bpftool-feature</b>(8) for details). Add the\n<b>unprivileged</b> keyword to list features available to\nunprivileged users.</td></tr>\n</table>\n\nCompatibility\nbetween helper functions and program types can generally be\nfound in the files where helper functions are defined. Look\nfor the <b>struct bpf_func_proto</b> objects and for\nfunctions returning them: these functions contain a list of\nhelpers that a given program type can call. Note that the\n<b>default:</b> label of the <b>switch ... case</b> used to\nfilter helpers can call other functions, themselves allowing\naccess to additional helpers. The requirement for GPL\nlicense is also in those <b>struct bpf_func_proto</b>.\n\nCompatibility\nbetween helper functions and map types can be found in the\n<b>check_map_func_compatibility</b>() function in file\n<i>kernel/bpf/verifier.c</i>.\n\nHelper\nfunctions that invalidate the checks on <b>data</b> and\n<b>data_end</b> pointers for network processing are listed\nin function <b>bpf_helper_changes_pkt_data</b>() in file\n<i>net/core/filter.c</i>.\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<a href=\"https://man.page/2/bpf\">bpf(2)</a>,\n<b>bpftool</b>(8), <a href=\"https://man.page/7/cgroups\">cgroups(7)</a>, <b>ip</b>(8),\n<a href=\"https://man.page/2/perf_event_open\">perf_event_open(2)</a>, <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>,\n<a href=\"https://man.page/7/socket\">socket(7)</a>, <b>tc-bpf</b>(8)\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\nThis page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.","body":"\n\n<h1 align=\"center\">BPF-HELPERS</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">BPF-HELPERS -\nlist of eBPF helper functions</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The extended\nBerkeley Packet Filter (eBPF) subsystem consists in programs\nwritten in a pseudo-assembly language, then attached to one\nof the several kernel hooks and run in reaction of specific\nevents. This framework differs from the older,\n&quot;classic&quot; BPF (or &quot;cBPF&quot;) in several\naspects, one of them being the ability to call special\nfunctions (or &quot;helpers&quot;) from within a program.\nThese functions are restricted to a white-list of helpers\ndefined in the kernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These helpers\nare used by eBPF programs to interact with the system, or\nwith the context in which they work. For instance, they can\nbe used to print debugging messages, to get the time since\nthe system was booted, to interact with eBPF maps, or to\nmanipulate network packets. Since there are several eBPF\nprogram types, and that they do not run in the same context,\neach program type can only call a subset of those\nhelpers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Due to eBPF\nconventions, a helper can not have more than five\narguments.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Internally,\neBPF programs call directly into the compiled helper\nfunctions without requiring any foreign-function interface.\nAs a result, calling helpers introduces no overhead, thus\noffering excellent performance.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This document\nis an attempt to list and document the helpers available to\neBPF developers. They are sorted by chronological order (the\noldest helpers in the kernel at the top).</p>\n\n<h2>HELPERS\n<a name=\"HELPERS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*bpf_map_lookup_elem(struct bpf_map *</b><i>map</i><b>,\nconst void *</b><i>key</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Perform a lookup in <i>map</i>\nfor an entry associated to <i>key</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Map value associated to <i>key</i>, or <b>NULL</b> if no\nentry was found.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_update_elem(struct bpf_map *</b><i>map</i><b>, const\nvoid *</b><i>key</i><b>, const <br>\nvoid *</b><i>value</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Add or update the value of the\nentry associated to <i>key</i> in <i>map</i> with\n<i>value</i>. <i>flags</i> is one of: <b><br>\nBPF_NOEXIST</b></p>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nnot exist in the map.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_EXIST</b></p>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nalready exist in the map.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_ANY</b></p>\n\n<p style=\"margin-left:43%;\">No condition on the existence\nof the entry for <i>key</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Flag value\n<b>BPF_NOEXIST</b> cannot be used for maps of types\n<b>BPF_MAP_TYPE_ARRAY</b> or\n<b>BPF_MAP_TYPE_PERCPU_ARRAY</b> (all elements always\nexist), the helper would return an error.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_delete_elem(struct bpf_map *</b><i>map</i><b>, const\nvoid *</b><i>key</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Delete entry with <i>key</i>\nfrom <i>map</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_probe_read(void\n*</b><i>dst</i><b>, u32</b> <i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">For tracing programs, safely\nattempt to read <i>size</i> bytes from kernel space address\n<i>unsafe_ptr</i> and store the data in <i>dst</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Generally, use\n<b>bpf_probe_read_user</b>() or\n<b>bpf_probe_read_kernel</b>() instead.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_ktime_get_ns(void)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return the time elapsed since\nsystem boot, in nanoseconds. Does not include time the\nsystem was suspended. See:\n<b>clock_gettime</b>(<b>CLOCK_MONOTONIC</b>)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"22%\">\n\n\n<p>Current <i>ktime</i>.</p></td>\n<td width=\"46%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_trace_printk(const\nchar *</b><i>fmt</i><b>, u32</b> <i>fmt_size</i><b>,\n...)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is a\n&quot;printk()-like&quot; facility for debugging. It prints\na message defined by format <i>fmt</i> (of size\n<i>fmt_size</i>) to file\n<i>/sys/kernel/debug/tracing/trace</i> from DebugFS, if\navailable. It can take up to three additional <b>u64</b>\narguments (as an eBPF helpers, the total number of arguments\nis limited to five).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Each time the\nhelper is called, it appends a line to the trace. Lines are\ndiscarded while <i>/sys/kernel/debug/tracing/trace</i> is\nopen, use <i>/sys/kernel/debug/tracing/trace_pipe</i> to\navoid this. The format of the trace is customizable, and the\nexact output one will get depends on the options set in\n<i>/sys/kernel/debug/tracing/trace_options</i> (see also the\n<i>README</i> file under the same directory). However, it\nusually defaults to something like:</p>\n\n<pre style=\"margin-left:37%; margin-top: 1em\">telnet-470   [001] .N.. 419421.045894: 0x00000001: &lt;formatted msg&gt;</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">In the\nabove:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>telnet</b> is the name of the current task.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>470</b> is the PID of the current task.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>001</b> is the CPU number on which the task is\nrunning.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p>In <b>.N..</b>, each character refers to a set of\noptions (whether irqs are enabled, scheduling options,\nwhether hard/softirqs are running, level of preempt_disabled\nrespectively). <b>N</b> means that <b>TIF_NEED_RESCHED</b>\nand <b>PREEMPT_NEED_RESCHED</b> are set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>419421.045894</b> is a timestamp.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>0x00000001</b> is a fake value used by BPF for the\ninstruction pointer register.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"37%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"60%\">\n\n\n<p><b>&lt;formatted msg&gt;</b> is the message formatted\nwith <i>fmt</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The conversion\nspecifiers supported by <i>fmt</i> are similar, but more\nlimited than for printk(). They are <b>%d</b>, <b>%i</b>,\n<b>%u</b>, <b>%x</b>, <b>%ld</b>, <b>%li</b>, <b>%lu</b>,\n<b>%lx</b>, <b>%lld</b>, <b>%lli</b>, <b>%llu</b>,\n<b>%llx</b>, <b>%p</b>, <b>%s</b>. No modifier (size of\nfield, padding with zeroes, etc.) is available, and the\nhelper will return <b>-EINVAL</b> (but print nothing) if it\nencounters an unknown specifier.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Also, note that\n<b>bpf_trace_printk</b>() is slow, and should only be used\nfor debugging purposes. For this reason, a notice block\n(spanning several lines) is printed to kernel logs and\nstates that the helper should not be used &quot;for\nproduction use&quot; the first time this helper is used (or\nmore precisely, when <b>trace_printk</b>() buffers are\nallocated). For passing values to user space, perf events\nshould be preferred.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">The number of bytes written to\nthe buffer, or a negative error in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_prandom_u32(void)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get a pseudo-random number.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">From a security\npoint of view, this helper uses its own pseudo-random\ninternal state, and cannot be used to infer the seed of\nother random functions in the kernel. However, it is\nessential to note that the generator used by the helper is\nnot cryptographically secure.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>A random 32-bit unsigned value.</p></td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_smp_processor_id(void)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get the SMP (symmetric\nmultiprocessing) processor id. Note that all programs run\nwith preemption disabled, which means that the SMP processor\nid is stable during all the execution of the program.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The SMP id of the processor running the program.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_store_bytes(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, const void <br>\n*</b><i>from</i><b>, u32</b> <i>len</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Store <i>len</i> bytes from\naddress <i>from</i> into the packet associated to\n<i>skb</i>, at <i>offset</i>. <i>flags</i> are a combination\nof <b>BPF_F_RECOMPUTE_CSUM</b> (automatically recompute the\nchecksum for the packet after storing the bytes) and\n<b>BPF_F_INVALIDATE_HASH</b> (set\n<i>skb</i><b>-&gt;hash</b>, <i>skb</i><b>-&gt;swhash</b> and\n<i>skb</i><b>-&gt;l4hash</b> to 0).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_l3_csum_replace(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b>\n<i><br>\nto</i><b>, u64</b> <i>size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Recompute the layer 3 (e.g. IP)\nchecksum for the packet associated to <i>skb</i>.\nComputation is incremental, so the helper must know the\nformer value of the header field that was modified\n(<i>from</i>), the new value of this field (<i>to</i>), and\nthe number of bytes (2 or 4) for this field, stored in\n<i>size</i>. Alternatively, it is possible to store the\ndifference between the previous and the new values of the\nheader field in <i>to</i>, by setting <i>from</i> and\n<i>size</i> to 0. For both methods, <i>offset</i> indicates\nthe location of the IP checksum within the packet.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks in combination with <b>bpf_csum_diff</b>(), which does\nnot update the checksum in-place, but offers more\nflexibility and can handle sizes larger than 2 or 4 for the\nchecksum to update.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_l4_csum_replace(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b>\n<i><br>\nto</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Recompute the layer 4 (e.g.\nTCP, UDP or ICMP) checksum for the packet associated to\n<i>skb</i>. Computation is incremental, so the helper must\nknow the former value of the header field that was modified\n(<i>from</i>), the new value of this field (<i>to</i>), and\nthe number of bytes (2 or 4) for this field, stored on the\nlowest four bits of <i>flags</i>. Alternatively, it is\npossible to store the difference between the previous and\nthe new values of the header field in <i>to</i>, by setting\n<i>from</i> and the four lowest bits of <i>flags</i> to 0.\nFor both methods, <i>offset</i> indicates the location of\nthe IP checksum within the packet. In addition to the size\nof the field, <i>flags</i> can be added (bitwise OR) actual\nflags. With <b>BPF_F_MARK_MANGLED_0</b>, a null checksum is\nleft untouched (unless <b>BPF_F_MARK_ENFORCE</b> is added as\nwell), and for updates resulting in a null checksum the\nvalue is set to <b>CSUM_MANGLED_0</b> instead. Flag\n<b>BPF_F_PSEUDO_HDR</b> indicates the checksum is to be\ncomputed against a pseudo-header.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks in combination with <b>bpf_csum_diff</b>(), which does\nnot update the checksum in-place, but offers more\nflexibility and can handle sizes larger than 2 or 4 for the\nchecksum to update.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_tail_call(void\n*</b><i>ctx</i><b>, struct bpf_map\n*</b><i>prog_array_map</i><b>, u32</b> <i><br>\nindex</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This special helper is used to\ntrigger a &quot;tail call&quot;, or in other words, to jump\ninto another eBPF program. The same stack frame is used (but\nvalues on stack and in registers for the caller are not\naccessible to the callee). This mechanism allows for program\nchaining, either for raising the maximum number of available\neBPF instructions, or to execute given programs in\nconditional blocks. For security reasons, there is an upper\nlimit to the number of successive tail calls that can be\nperformed.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Upon call of\nthis helper, the program attempts to jump into a program\nreferenced at index <i>index</i> in <i>prog_array_map</i>, a\nspecial map of type <b>BPF_MAP_TYPE_PROG_ARRAY</b>, and\npasses <i>ctx</i>, a pointer to the context.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the call\nsucceeds, the kernel immediately runs the first instruction\nof the new program. This is not a function call, and it\nnever returns to the previous program. If the call fails,\nthen the helper has no effect, and the caller continues to\nrun its subsequent instructions. A call can fail if the\ndestination program for the jump does not exist (i.e.\n<i>index</i> is superior to the number of entries in\n<i>prog_array_map</i>), or if the maximum number of tail\ncalls has been reached for this chain of programs. This\nlimit is defined in the kernel by the macro\n<b>MAX_TAIL_CALL_CNT</b> (not accessible to user space),\nwhich is currently set to 32.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_clone_redirect(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>ifindex</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Clone and redirect the packet\nassociated to <i>skb</i> to another net device of index\n<i>ifindex</i>. Both ingress and egress interfaces can be\nused for redirection. The <b>BPF_F_INGRESS</b> value in\n<i>flags</i> is used to make the distinction (ingress path\nis selected if the flag is present, egress path otherwise).\nThis is the only flag supported for now.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">In comparison\nwith <b>bpf_redirect</b>() helper,\n<b>bpf_clone_redirect</b>() has the associated cost of\nduplicating the packet buffer, but this can be executed out\nof the eBPF program. Conversely, <b>bpf_redirect</b>() is\nmore efficient, but it is handled through an action code\nwhere the redirection happens only after the eBPF program\nhas returned.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_pid_tgid(void)</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 64-bit integer containing the current tgid and pid,\nand created as such: <i>current_task</i><b>-&gt;tgid\n&lt;&lt; 32 |</b> <i>current_task</i><b>-&gt;pid</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_uid_gid(void)</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 64-bit integer containing the current GID and UID, and\ncreated as such: <i>current_gid</i> <b>&lt;&lt; 32 |</b>\n<i>current_uid</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_current_comm(void *</b><i>buf</i><b>, u32</b>\n<i>size_of_buf</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Copy the <b>comm</b> attribute\nof the current task into <i>buf</i> of <i>size_of_buf</i>.\nThe <b>comm</b> attribute contains the name of the\nexecutable (excluding the path) for the current task. The\n<i>size_of_buf</i> must be strictly positive. On success,\nthe helper makes sure that the <i>buf</i> is NUL-terminated.\nOn failure, it is filled with zeroes.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_cgroup_classid(struct sk_buff\n*</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Retrieve the classid for the\ncurrent task, i.e. for the net_cls cgroup to which\n<i>skb</i> belongs.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used on TC egress path, but not on ingress.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The net_cls\ncgroup provides an interface to tag network packets based on\na user-provided identifier for all traffic coming from the\ntasks belonging to the related cgroup. See also the related\nkernel documentation, available from the Linux sources in\nfile\n<i>Documentation/admin-guide/cgroup-v1/net_cls.rst</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The Linux\nkernel has two versions for cgroups: there are cgroups v1\nand cgroups v2. Both are available to users, who can use a\nmixture of them, but note that the net_cls cgroup is for\ncgroup v1 only. This makes it incompatible with BPF programs\nrun on cgroups, which is a cgroup-v2-only feature (a socket\ncan only hold data for one version of cgroups at a\ntime).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_CGROUP_NET_CLASSID</b> configuration option set to\n&quot;<b>y</b>&quot; or to &quot;<b>m</b>&quot;.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The classid, or 0 for the default unconfigured\nclassid.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_vlan_push(struct sk_buff *</b><i>skb</i><b>,\n__be16</b> <i>vlan_proto</i><b>, u16</b> <i><br>\nvlan_tci</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Push a <i>vlan_tci</i> (VLAN\ntag control information) of protocol <i>vlan_proto</i> to\nthe packet associated to <i>skb</i>, then update the\nchecksum. Note that if <i>vlan_proto</i> is different from\n<b>ETH_P_8021Q</b> and <b>ETH_P_8021AD</b>, it is considered\nto be <b>ETH_P_8021Q</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_skb_vlan_pop(struct\nsk_buff *</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Pop a VLAN header from the\npacket associated to <i>skb</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_get_tunnel_key(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_tunnel_key <br>\n*</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get tunnel metadata. This\nhelper takes a pointer <i>key</i> to an empty <b>struct\nbpf_tunnel_key</b> of <b>size</b>, that will be filled with\ntunnel metadata for the packet associated to <i>skb</i>. The\n<i>flags</i> can be set to <b>BPF_F_TUNINFO_IPV6</b>, which\nindicates that the tunnel is based on IPv6 protocol instead\nof IPv4.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <b>struct\nbpf_tunnel_key</b> is an object that generalizes the\nprincipal parameters used by various tunneling protocols\ninto a single struct. This way, it can be used to easily\nmake a decision based on the contents of the encapsulation\nheader, &quot;summarized&quot; in this struct. In\nparticular, it holds the IP address of the remote end (IPv4\nor IPv6, depending on the case) in\n<i>key</i><b>-&gt;remote_ipv4</b> or\n<i>key</i><b>-&gt;remote_ipv6</b>. Also, this struct exposes\nthe <i>key</i><b>-&gt;tunnel_id</b>, which is generally\nmapped to a VNI (Virtual Network Identifier), making it\nprogrammable together with the\n<b>bpf_skb_set_tunnel_key</b>() helper.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Let's imagine\nthat the following code is part of a program attached to the\nTC ingress interface, on one end of a GRE tunnel, and is\nsupposed to filter out all messages coming from remote ends\nwith IPv4 address other than 10.0.0.1:</p>\n<pre style=\"margin-left:37%; margin-top: 1em\">int ret;\nstruct bpf_tunnel_key key = {};\n\nret = bpf_skb_get_tunnel_key(skb, &amp;key, sizeof(key), 0);\nif (ret &lt; 0)\n        return TC_ACT_SHOT;     // drop packet\n\nif (key.remote_ipv4 != 0x0a000001)\n        return TC_ACT_SHOT;     // drop packet\n\nreturn TC_ACT_OK;               // accept packet</pre>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This interface\ncan also be used with all encapsulation devices that can\noperate in &quot;collect metadata&quot; mode: instead of\nhaving one network device per specific configuration, the\n&quot;collect metadata&quot; mode only requires a single\ndevice where the configuration can be extracted from this\nhelper.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This can be\nused together with various tunnels such as VXLan, Geneve,\nGRE or IP in IP (IPIP).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_set_tunnel_key(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_tunnel_key <br>\n*</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Populate tunnel metadata for\npacket associated to <i>skb.</i> The tunnel metadata is set\nto the contents of <i>key</i>, of <i>size</i>. The\n<i>flags</i> can be set to a combination of the following\nvalues: <b><br>\nBPF_F_TUNINFO_IPV6</b></p>\n\n<p style=\"margin-left:43%;\">Indicate that the tunnel is\nbased on IPv6 protocol instead of IPv4.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_F_ZERO_CSUM_TX</b></p>\n\n<p style=\"margin-left:43%;\">For IPv4 packets, add a flag to\ntunnel metadata indicating that checksum computation should\nbe skipped and checksum set to zeroes.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_F_DONT_FRAGMENT</b></p>\n\n<p style=\"margin-left:43%;\">Add a flag to tunnel metadata\nindicating that the packet should not be fragmented.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_F_SEQ_NUMBER</b></p>\n\n<p style=\"margin-left:43%;\">Add a flag to tunnel metadata\nindicating that a sequence number should be added to tunnel\nheader before sending the packet. This flag was added for\nGRE encapsulation, but might be used with other protocols as\nwell in the future.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Here is a\ntypical usage on the transmit path:</p>\n\n<pre style=\"margin-left:37%; margin-top: 1em\">struct bpf_tunnel_key key;\n     populate key ...\nbpf_skb_set_tunnel_key(skb, &amp;key, sizeof(key), 0);\nbpf_clone_redirect(skb, vxlan_dev_ifindex, 0);</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">See also the\ndescription of the <b>bpf_skb_get_tunnel_key</b>() helper\nfor additional information.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_perf_event_read(struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Read the value of a perf event\ncounter. This helper relies on a <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf\nevent counter is selected when <i>map</i> is updated with\nperf event file descriptors. The <i>map</i> is an array\nwhose size is the number of available CPUs, and each cell\ncontains a value relative to one CPU. The value to retrieve\nis indicated by <i>flags</i>, that contains the index of the\nCPU to look up, masked with <b>BPF_F_INDEX_MASK</b>.\nAlternatively, <i>flags</i> can be set to\n<b>BPF_F_CURRENT_CPU</b> to indicate that the value for the\ncurrent CPU should be retrieved.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that\nbefore Linux 4.13, only hardware perf event can be\nretrieved.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Also, be aware\nthat the newer helper <b>bpf_perf_event_read_value</b>() is\nrecommended over <b>bpf_perf_event_read</b>() in general.\nThe latter has some ABI quirks where error and counter value\nare used as a return code (which is wrong to do since ranges\nmay overlap). This issue is fixed with\n<b>bpf_perf_event_read_value</b>(), which at the same time\nprovides more features over the <b>bpf_perf_event_read</b>()\ninterface. Please refer to the description of\n<b>bpf_perf_event_read_value</b>() for details.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The value of the perf event counter read from the map,\nor a negative error code in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_redirect(u32</b>\n<i>ifindex</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Redirect the packet to another\nnet device of index <i>ifindex</i>. This helper is somewhat\nsimilar to <b>bpf_clone_redirect</b>(), except that the\npacket is not cloned, which provides increased\nperformance.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Except for XDP,\nboth ingress and egress interfaces can be used for\nredirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i>\nis used to make the distinction (ingress path is selected if\nthe flag is present, egress path otherwise). Currently, XDP\nonly supports redirection to the egress interface, and\naccepts no flag at all.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The same effect\ncan also be attained with the more generic\n<b>bpf_redirect_map</b>(), which uses a BPF map to store the\nredirect target instead of providing it directly to the\nhelper.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>For XDP, the helper returns <b>XDP_REDIRECT</b> on\nsuccess or <b>XDP_ABORTED</b> on error. For other program\ntypes, the values are <b>TC_ACT_REDIRECT</b> on success or\n<b>TC_ACT_SHOT</b> on error.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_route_realm(struct sk_buff\n*</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Retrieve the realm or the\nroute, that is to say the <b>tclassid</b> field of the\ndestination for the <i>skb</i>. The identifier retrieved is\na user-provided tag, similar to the one used with the\nnet_cls cgroup (see description for\n<b>bpf_get_cgroup_classid</b>() helper), but here this tag\nis held by a route (a destination entry), not by a task.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Retrieving this\nidentifier works with the clsact TC egress hook (see also\n<b>tc-bpf(8)</b>), or alternatively on conventional classful\negress qdiscs, but not on TC ingress path. In case of clsact\nTC egress hook, this has the advantage that, internally, the\ndestination entry has not been dropped yet in the transmit\npath. Therefore, the destination entry does not need to be\nartificially held via <b>netif_keep_dst</b>() for a classful\nqdisc until the <i>skb</i> is freed.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_IP_ROUTE_CLASSID</b> configuration option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The realm of the route for the packet associated to\n<i>skb</i>, or 0 if none was found.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_perf_event_output(void *</b><i>ctx</i><b>, struct\nbpf_map *</b><i>map</i><b>, u64</b> <i>flags</i><b>, <br>\nvoid *</b><i>data</i><b>, u64</b> <i>size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Write raw <i>data</i> blob into\na special BPF perf event held by <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event must\nhave the following attributes: <b>PERF_SAMPLE_RAW</b> as\n<b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as\n<b>type</b>, and <b>PERF_COUNT_SW_BPF_OUTPUT</b> as\n<b>config</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> are used to indicate the index in <i>map</i>\nfor which the value must be put, masked with\n<b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be\nset to <b>BPF_F_CURRENT_CPU</b> to indicate that the index\nof the current CPU core should be used.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The value to\nwrite, of <i>size</i>, is passed through eBPF stack and\npointed by <i>data</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The context of\nthe program <i>ctx</i> needs also be passed to the\nhelper.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">On user space,\na program willing to read the values needs to call\n<b>perf_event_open</b>() on the perf event (either for one\nor for all CPUs) and to store the file descriptor into the\n<i>map</i>. This must be done before the eBPF program can\nsend data into it. An example is available in file\n<i>samples/bpf/trace_output_user.c</i> in the Linux kernel\nsource tree (the eBPF program counterpart is in\n<i>samples/bpf/trace_output_kern.c</i>).</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>bpf_perf_event_output</b>()\nachieves better performance than <b>bpf_trace_printk</b>()\nfor sharing data with user space, and is much better\nsuitable for streaming data from eBPF programs.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that this\nhelper is not restricted to tracing use cases and can be\nused with programs attached to TC or XDP as well, where it\nallows for passing data to user space listeners. Data can\nbe:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"42%\">\n\n\n<p>Only custom structs,</p></td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"42%\">\n\n\n<p>Only the packet payload, or</p></td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"42%\">\n\n\n<p>A combination of both.</p></td>\n<td width=\"23%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"42%\"></td>\n<td width=\"23%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_load_bytes(const void *</b><i>skb</i><b>, u32</b>\n<i>offset</i><b>, void *</b><i>to</i><b>, u32</b>\n<i>len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper was provided as an\neasy way to load data from a packet. It can be used to load\n<i>len</i> bytes from <i>offset</i> from the packet\nassociated to <i>skb</i>, into the buffer pointed by\n<i>to</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Since Linux\n4.7, usage of this helper has mostly been replaced by\n&quot;direct packet access&quot;, enabling packet data to be\nmanipulated with <i>skb</i><b>-&gt;data</b> and\n<i>skb</i><b>-&gt;data_end</b> pointing respectively to the\nfirst byte of packet data and to the byte after the last\nbyte of packet data. However, it remains useful if one\nwishes to read large quantities of data at once from a\npacket into the eBPF stack.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_get_stackid(void\n*</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Walk a user or a kernel stack\nand return its id. To achieve this, the helper needs\n<i>ctx</i>, which is a pointer to the context on which the\ntracing program is executed, and a pointer to a <i>map</i>\nof type <b>BPF_MAP_TYPE_STACK_TRACE</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The last\nargument, <i>flags</i>, holds the number of stack frames to\nskip (from 0 to 255), masked with\n<b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to\nset a combination of the following flags: <b><br>\nBPF_F_USER_STACK</b></p>\n\n<p style=\"margin-left:43%;\">Collect a user space stack\ninstead of a kernel stack.</p>\n\n\n<p style=\"margin-left:32%;\"><b>BPF_F_FAST_STACK_CMP</b></p>\n\n<p style=\"margin-left:43%;\">Compare stacks by hash\nonly.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_F_REUSE_STACKID</b></p>\n\n<p style=\"margin-left:43%;\">If two different stacks hash\ninto the same <i>stackid</i>, discard the old one.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The stack id\nretrieved is a 32 bit long integer handle which can be\nfurther combined with other data (including other stack ids)\nand used as a key into maps. This can be useful for\ngenerating a variety of graphs (such as flame graphs or\noff-cpu graphs).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">For walking a\nstack, this helper is an improvement over\n<b>bpf_probe_read</b>(), which can be used with unrolled\nloops but is not efficient and consumes a lot of eBPF\ninstructions. Instead, <b>bpf_get_stackid</b>() can collect\nup to <b>PERF_MAX_STACK_DEPTH</b> both kernel and user\nframes. Note that this limit can be controlled with the\n<b>sysctl</b> program, and that it should be manually\nincreased in order to profile long user stacks (such as\nstacks for Java programs). To do so, use:</p>\n\n<pre style=\"margin-left:37%; margin-top: 1em\"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</pre>\n\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The positive or null stack id on success, or a negative\nerror in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>s64 bpf_csum_diff(__be32\n*</b><i>from</i><b>, u32</b> <i>from_size</i><b>, __be32\n*</b><i>to</i><b>, u32</b> <i>to_size</i><b>, <br>\n__wsum</b> <i>seed</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Compute a checksum difference,\nfrom the raw buffer pointed by <i>from</i>, of length\n<i>from_size</i> (that must be a multiple of 4), towards the\nraw buffer pointed by <i>to</i>, of size <i>to_size</i>\n(same remark). An optional <i>seed</i> can be added to the\nvalue (this can be cascaded, the seed may come from a\nprevious call to the helper).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This is\nflexible enough to be used in several ways:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>With <i>from_size</i> == 0, <i>to_size</i> &gt; 0 and\n<i>seed</i> set to checksum, it can be used when pushing new\ndata.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>With <i>from_size</i> &gt; 0, <i>to_size</i> == 0 and\n<i>seed</i> set to checksum, it can be used when removing\ndata from a packet.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>With <i>from_size</i> &gt; 0, <i>to_size</i> &gt; 0 and\n<i>seed</i> set to 0, it can be used to compute a diff. Note\nthat <i>from_size</i> and <i>to_size</i> do not need to be\nequal.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used in combination with <b>bpf_l3_csum_replace</b>() and\n<b>bpf_l4_csum_replace</b>(), to which one can feed in the\ndifference computed with <b>bpf_csum_diff</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">The checksum result, or a\nnegative error code in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_get_tunnel_opt(struct sk_buff *</b><i>skb</i><b>,\nvoid *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Retrieve tunnel options\nmetadata for the packet associated to <i>skb</i>, and store\nthe raw tunnel option data to the buffer <i>opt</i> of\n<i>size</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used with encapsulation devices that can operate in\n&quot;collect metadata&quot; mode (please refer to the\nrelated note in the description of\n<b>bpf_skb_get_tunnel_key</b>() for more details). A\nparticular example where this can be used is in combination\nwith the Geneve encapsulation protocol, where it allows for\npushing (with <b>bpf_skb_get_tunnel_opt</b>() helper) and\nretrieving arbitrary TLVs (Type-Length-Value headers) from\nthe eBPF program. This allows for full customization of\nthese headers.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"59%\">\n\n\n<p>The size of the option data retrieved.</p></td>\n<td width=\"9%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_set_tunnel_opt(struct sk_buff *</b><i>skb</i><b>,\nvoid *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Set tunnel options metadata for\nthe packet associated to <i>skb</i> to the option data\ncontained in the raw buffer <i>opt</i> of <i>size</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">See also the\ndescription of the <b>bpf_skb_get_tunnel_opt</b>() helper\nfor additional information.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_proto(struct sk_buff *</b><i>skb</i><b>,\n__be16</b> <i>proto</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Change the protocol of the\n<i>skb</i> to <i>proto</i>. Currently supported are\ntransition from IPv4 to IPv6, and from IPv6 to IPv4. The\nhelper takes care of the groundwork for the transition,\nincluding resizing the socket buffer. The eBPF program is\nexpected to fill the new headers, if any, via\n<b>skb_store_bytes</b>() and to recompute the checksums with\n<b>bpf_l3_csum_replace</b>() and\n<b>bpf_l4_csum_replace</b>(). The main case for this helper\nis to perform NAT64 operations out of an eBPF program.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Internally, the\nGSO type is marked as dodgy so that headers are checked and\nsegments are recalculated by the GSO/GRO engine. The size\nfor GSO target is adapted as well.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_type(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>type</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Change the packet type for the\npacket associated to <i>skb</i>. This comes down to setting\n<i>skb</i><b>-&gt;pkt_type</b> to <i>type</i>, except the\neBPF program does not have a write access to\n<i>skb</i><b>-&gt;pkt_type</b> beside this helper. Using a\nhelper here allows for graceful handling of errors.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The major use\ncase is to change incoming <i>skb*s to **PACKET_HOST*</i> in\na programmatic way instead of having to recirculate via\n<b>redirect</b>(..., <b>BPF_F_INGRESS</b>), for example.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that\n<i>type</i> only allows certain values. At this time, they\nare: <b><br>\nPACKET_HOST</b></p>\n\n<p style=\"margin-left:43%;\">Packet is for us.</p>\n\n<p style=\"margin-left:32%;\"><b>PACKET_BROADCAST</b></p>\n\n<p style=\"margin-left:43%;\">Send packet to all.</p>\n\n<p style=\"margin-left:32%;\"><b>PACKET_MULTICAST</b></p>\n\n<p style=\"margin-left:43%;\">Send packet to group.</p>\n\n<p style=\"margin-left:32%;\"><b>PACKET_OTHERHOST</b></p>\n\n<p style=\"margin-left:43%;\">Send packet to someone\nelse.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_under_cgroup(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_map *</b><i>map</i><b>, u32</b> <i><br>\nindex</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Check whether <i>skb</i> is a\ndescendant of the cgroup2 held by <i>map</i> of type\n<b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The return value depends on the result of the test, and\ncan be:</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\">0, if the <i>skb</i> failed the\ncgroup2 descendant test.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>1, if the <i>skb</i> succeeded the cgroup2 descendant\ntest.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>A negative error code, if an error occurred.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_hash_recalc(struct sk_buff\n*</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Retrieve the hash of the\npacket, <i>skb</i><b>-&gt;hash</b>. If it is not set, in\nparticular if the hash was cleared due to mangling,\nrecompute this hash. Later accesses to the hash can be done\ndirectly with <i>skb</i><b>-&gt;hash</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Calling\n<b>bpf_set_hash_invalid</b>(), changing a packet prototype\nwith <b>bpf_skb_change_proto</b>(), or calling\n<b>bpf_skb_store_bytes</b>() with the\n<b>BPF_F_INVALIDATE_HASH</b> are actions susceptible to\nclear the hash and to trigger a new computation for the next\ncall to <b>bpf_get_hash_recalc</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"25%\">\n\n\n<p>The 32-bit hash.</p></td>\n<td width=\"43%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_task(void)</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"57%\">\n\n\n<p>A pointer to the current task struct.</p></td>\n<td width=\"11%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_write_user(void *</b><i>dst</i><b>, const void\n*</b><i>src</i><b>, u32</b> <i>len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Attempt in a safe way to write\n<i>len</i> bytes from the buffer <i>src</i> to <i>dst</i> in\nmemory. It only works for threads that are in user context,\nand <i>dst</i> must be a valid user space address.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nshould not be used to implement any kind of security\nmechanism because of TOC-TOU attacks, but rather to debug,\ndivert, and manipulate execution of semi-cooperative\nprocesses.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Keep in mind\nthat this feature is meant for experiments, and it has a\nrisk of crashing the system and running programs. Therefore,\nwhen an eBPF program using this helper is attached, a\nwarning including PID and process name is printed to kernel\nlogs.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_current_task_under_cgroup(struct bpf_map\n*</b><i>map</i><b>, u32</b> <i>index</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Check whether the probe is\nbeing run is the context of a given subset of the cgroup2\nhierarchy. The cgroup2 to test is held by <i>map</i> of type\n<b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The return value depends on the result of the test, and\ncan be:</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\">0, if the <i>skb</i> task\nbelongs to the cgroup2.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>1, if the <i>skb</i> task does not belong to the\ncgroup2.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>A negative error code, if an error occurred.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_tail(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>len</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Resize (trim or grow) the\npacket associated to <i>skb</i> to the new <i>len</i>. The\n<i>flags</i> are reserved for future usage, and must be left\nat zero.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The basic idea\nis that the helper performs the needed work to change the\nsize of the packet, then the eBPF program rewrites the rest\nvia helpers like <b>bpf_skb_store_bytes</b>(),\n<b>bpf_l3_csum_replace</b>(), <b>bpf_l3_csum_replace</b>()\nand others. This helper is a slow path utility intended for\nreplies with control messages. And because it is targeted\nfor slow path, the helper itself can afford to be slow: it\nimplicitly linearizes, unclones and drops offloads from the\n<i>skb</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_pull_data(struct sk_buff *</b><i>skb</i><b>, u32</b>\n<i>len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Pull in non-linear data in case\nthe <i>skb</i> is non-linear and not all of <i>len</i> are\npart of the linear section. Make <i>len</i> bytes from\n<i>skb</i> readable and writable. If a zero value is passed\nfor <i>len</i>, then the whole length of the <i>skb</i> is\npulled.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly needed for reading and writing with direct packet\naccess.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">For direct\npacket access, testing that offsets to access are within\npacket boundaries (test on <i>skb</i><b>-&gt;data_end</b>)\nis susceptible to fail if offsets are invalid, or if the\nrequested data is in non-linear parts of the <i>skb</i>. On\nfailure the program can just bail out, or in the case of a\nnon-linear buffer, use a helper to make the data available.\nThe <b>bpf_skb_load_bytes</b>() helper is a first solution\nto access the data. Another one consists in using\n<b>bpf_skb_pull_data</b> to pull in once the non-linear\nparts, then retesting and eventually access the data.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">At the same\ntime, this also makes sure the <i>skb</i> is uncloned, which\nis a necessary condition for direct write. As this needs to\nbe an invariant for the write part only, the verifier\ndetects writes and adds a prologue that is calling\n<b>bpf_skb_pull_data()</b> to effectively unclone the\n<i>skb</i> from the very beginning in case it is indeed\ncloned.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>s64 bpf_csum_update(struct\nsk_buff *</b><i>skb</i><b>, __wsum</b>\n<i>csum</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Add the checksum <i>csum</i>\ninto <i>skb</i><b>-&gt;csum</b> in case the driver has\nsupplied a checksum for the entire packet into that field.\nReturn an error otherwise. This helper is intended to be\nused in combination with <b>bpf_csum_diff</b>(), in\nparticular when the checksum needs to be updated after data\nhas been written into the packet through direct packet\naccess.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The checksum on success, or a negative error code in\ncase of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\nbpf_set_hash_invalid(struct sk_buff\n*</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Invalidate the current\n<i>skb</i><b>-&gt;hash</b>. It can be used after mangling on\nheaders through direct packet access, in order to indicate\nthat the hash is outdated and to trigger a recalculation the\nnext time the kernel tries to access this hash or when the\n<b>bpf_get_hash_recalc</b>() helper is called.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_numa_node_id(void)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return the id of the current\nNUMA node. The primary use case for this helper is the\nselection of sockets for the local NUMA node, when the\nprogram is attached to sockets using the\n<b>SO_ATTACH_REUSEPORT_EBPF</b> option (see also\n<b>socket(7)</b>), but the helper is also available to other\neBPF program types, similarly to\n<b>bpf_get_smp_processor_id</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"43%\">\n\n\n<p>The id of current NUMA node.</p></td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_change_head(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>len</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Grows headroom of packet\nassociated to <i>skb</i> and adjusts the offset of the MAC\nheader accordingly, adding <i>len</i> bytes of space. It\nautomatically extends and reallocates memory as\nrequired.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used on a layer 3 <i>skb</i> to push a MAC header for\nredirection into a layer 2 device.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_xdp_adjust_head(struct xdp_buff *</b><i>xdp_md</i><b>,\nint</b> <i>delta</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Adjust (move)\n<i>xdp_md</i><b>-&gt;data</b> by <i>delta</i> bytes. Note\nthat it is possible to use a negative value for\n<i>delta</i>. This helper can be used to prepare the packet\nfor pushing or popping headers.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_probe_read_str(void\n*</b><i>dst</i><b>, u32</b> <i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Copy a NUL terminated string\nfrom an unsafe kernel address <i>unsafe_ptr</i> to\n<i>dst</i>. See <b>bpf_probe_read_kernel_str</b>() for more\ndetails.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Generally, use\n<b>bpf_probe_read_user_str</b>() or\n<b>bpf_probe_read_kernel_str</b>() instead.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, the strictly positive length of the string,\nincluding the trailing NUL character. On error, a negative\nvalue.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_socket_cookie(struct sk_buff\n*</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">If the <b>struct sk_buff</b>\npointed by <i>skb</i> has a known socket, retrieve the\ncookie (generated by the kernel) of this socket. If no\ncookie has been set yet, generate a new cookie. Once\ngenerated, the socket cookie remains stable for the life of\nthe socket. This helper can be useful for monitoring per\nsocket networking traffic statistics as it provides a global\nsocket identifier that can be assumed unique.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 8-byte long non-decreasing number on success, or 0 if\nthe socket field is missing inside <i>skb</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_socket_cookie(struct bpf_sock_addr\n*</b><i>ctx</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Equivalent to\nbpf_get_socket_cookie() helper that accepts <i>skb</i>, but\ngets socket from <b>struct bpf_sock_addr</b> context.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>A 8-byte long non-decreasing number.</p></td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_socket_cookie(struct bpf_sock_ops\n*</b><i>ctx</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Equivalent to\n<b>bpf_get_socket_cookie</b>() helper that accepts\n<i>skb</i>, but gets socket from <b>struct bpf_sock_ops</b>\ncontext.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>A 8-byte long non-decreasing number.</p></td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u32\nbpf_get_socket_uid(struct sk_buff\n*</b><i>skb</i><b>)</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The owner UID of the socket associated to <i>skb</i>. If\nthe socket is <b>NULL</b>, or if it is not a full socket\n(i.e. if it is a time-wait or a request socket instead),\n<b>overflowuid</b> value is returned (note that\n<b>overflowuid</b> might also be the actual UID value for\nthe socket).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_set_hash(struct\nsk_buff *</b><i>skb</i><b>, u32</b> <i>hash</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Set the full hash for\n<i>skb</i> (set the field <i>skb</i><b>-&gt;hash</b>) to\nvalue <i>hash</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_setsockopt(void\n*</b><i>bpf_socket</i><b>, int</b> <i>level</i><b>, int</b>\n<i>optname</i><b>, void <br>\n*</b><i>optval</i><b>, int</b> <i>optlen</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Emulate a call to\n<b>setsockopt()</b> on the socket associated to\n<i>bpf_socket</i>, which must be a full socket. The\n<i>level</i> at which the option resides and the name\n<i>optname</i> of the option must be specified, see\n<b>setsockopt(2)</b> for more information. The option value\nof length <i>optlen</i> is pointed by <i>optval</i>.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>bpf_socket</i>\nshould be one of the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_ops</b> for\n<b>BPF_PROG_TYPE_SOCK_OPS</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_addr</b> for\n<b>BPF_CGROUP_INET4_CONNECT</b> and\n<b>BPF_CGROUP_INET6_CONNECT</b>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nactually implements a subset of <b>setsockopt()</b>. It\nsupports the following <i>level</i>s:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>SOL_SOCKET</b>, which\nsupports the following <i>optname</i>s: <b>SO_RCVBUF</b>,\n<b>SO_SNDBUF</b>, <b>SO_MAX_PACING_RATE</b>,\n<b>SO_PRIORITY</b>, <b>SO_RCVLOWAT</b>, <b>SO_MARK</b>,\n<b>SO_BINDTODEVICE</b>, <b>SO_KEEPALIVE</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_TCP</b>, which supports the following\n<i>optname</i>s: <b>TCP_CONGESTION</b>, <b>TCP_BPF_IW</b>,\n<b>TCP_BPF_SNDCWND_CLAMP</b>, <b>TCP_SAVE_SYN</b>,\n<b>TCP_KEEPIDLE</b>, <b>TCP_KEEPINTVL</b>,\n<b>TCP_KEEPCNT</b>, <b>TCP_SYNCNT</b>,\n<b>TCP_USER_TIMEOUT</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IP</b>, which supports <i>optname</i>\n<b>IP_TOS</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IPV6</b>, which supports <i>optname</i>\n<b>IPV6_TCLASS</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_adjust_room(struct sk_buff *</b><i>skb</i><b>,\ns32</b> <i>len_diff</i><b>, u32</b> <i>mode</i><b>, <br>\nu64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Grow or shrink the room for\ndata in the packet associated to <i>skb</i> by\n<i>len_diff</i>, and according to the selected\n<i>mode</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">By default, the\nhelper will reset any offloaded checksum indicator of the\nskb to CHECKSUM_NONE. This can be avoided by the following\nflag:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_NO_CSUM_RESET</b>: Do not reset\noffloaded checksum data of the skb to CHECKSUM_NONE.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">There are two\nsupported modes at this time:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>BPF_ADJ_ROOM_MAC</b>: Adjust\nroom at the mac layer (room space is added or removed below\nthe layer 2 header).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_ADJ_ROOM_NET</b>: Adjust room at the network\nlayer (room space is added or removed below the layer 3\nheader).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The following\nflags are supported at this time:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n\n<p style=\"margin-top: 1em\"><b>BPF_F_ADJ_ROOM_FIXED_GSO</b>:\nDo not adjust gso_size. Adjusting mss in this way is not\nallowed for datagrams.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV4</b>,\n<b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV6</b>: Any new space is\nreserved to hold a tunnel header. Configure skb offsets and\nother fields accordingly.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_ENCAP_L4_GRE</b>,\n<b>BPF_F_ADJ_ROOM_ENCAP_L4_UDP</b>: Use with ENCAP_L3 flags\nto further specify the tunnel type.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_F_ADJ_ROOM_ENCAP_L2</b>(<i>len</i>): Use with\nENCAP_L3/L4 flags to further specify the tunnel type;\n<i>len</i> is the length of the inner MAC header.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">0 on success, or a negative\nerror in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_redirect_map(struct\nbpf_map *</b><i>map</i><b>, u32</b> <i>key</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Redirect the packet to the\nendpoint referenced by <i>map</i> at index <i>key</i>.\nDepending on its type, this <i>map</i> can contain\nreferences to net devices (for forwarding packets through\nother ports), or to CPUs (for redirecting XDP frames to\nanother CPU; but this is only implemented for native XDP\n(with driver support) as of this writing).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The lower two\nbits of <i>flags</i> are used as the return code if the map\nlookup fails. This is so that the return value can be one of\nthe XDP program return codes up to <b>XDP_TX</b>, as chosen\nby the caller. Any higher bits in the <i>flags</i> argument\nmust be unset.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">See also\n<b>bpf_redirect</b>(), which only supports redirecting to an\nifindex, but doesn't require a map to do so.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p><b>XDP_REDIRECT</b> on success, or the value of the two\nlower bits of the <i>flags</i> argument on error.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_redirect_map(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_map *</b><i>map</i><b>, u32</b> <i><br>\nkey</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Redirect the packet to the\nsocket referenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress path otherwise). This is the only flag\nsupported for now.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror.</p> </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sock_map_update(struct bpf_sock_ops\n*</b><i>skops</i><b>, struct bpf_map <br>\n*</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Add an entry to, or update a\n<i>map</i> referencing sockets. The <i>skops</i> is used as\na new value for the entry associated to <i>key</i>.\n<i>flags</i> is one of: <b><br>\nBPF_NOEXIST</b></p>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nnot exist in the map.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_EXIST</b></p>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nalready exist in the map.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_ANY</b></p>\n\n<p style=\"margin-left:43%;\">No condition on the existence\nof the entry for <i>key</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>map</i> has eBPF programs (parser and verdict), those\nwill be inherited by the socket being added. If the socket\nis already attached to eBPF programs, this results in an\nerror.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_xdp_adjust_meta(struct xdp_buff *</b><i>xdp_md</i><b>,\nint</b> <i>delta</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Adjust the address pointed by\n<i>xdp_md</i><b>-&gt;data_meta</b> by <i>delta</i> (which\ncan be positive or negative). Note that this operation\nmodifies the address stored in\n<i>xdp_md</i><b>-&gt;data</b>, so the latter must be loaded\nonly after the helper has been called.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The use of\n<i>xdp_md</i><b>-&gt;data_meta</b> is optional and programs\nare not required to use it. The rationale is that when the\npacket is processed with XDP (e.g. as DoS filter), it is\npossible to push further meta data along with it before\npassing to the stack, and to give the guarantee that an\ningress eBPF program attached as a TC classifier on the same\ndevice can pick this up for further post-processing. Since\nTC works with socket buffers, it remains possible to set\nfrom XDP the <b>mark</b> or <b>priority</b> pointers, or\nother pointers for the socket buffer. Having this scratch\nspace generic and programmable allows for more flexibility\nas the user is free to store whatever meta data they\nneed.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_perf_event_read_value(struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>, struct <br>\nbpf_perf_event_value *</b><i>buf</i><b>, u32</b>\n<i>buf_size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Read the value of a perf event\ncounter, and store it into <i>buf</i> of size\n<i>buf_size</i>. This helper relies on a <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf\nevent counter is selected when <i>map</i> is updated with\nperf event file descriptors. The <i>map</i> is an array\nwhose size is the number of available CPUs, and each cell\ncontains a value relative to one CPU. The value to retrieve\nis indicated by <i>flags</i>, that contains the index of the\nCPU to look up, masked with <b>BPF_F_INDEX_MASK</b>.\nAlternatively, <i>flags</i> can be set to\n<b>BPF_F_CURRENT_CPU</b> to indicate that the value for the\ncurrent CPU should be retrieved.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nbehaves in a way close to <b>bpf_perf_event_read</b>()\nhelper, save that instead of just returning the value\nobserved, it fills the <i>buf</i> structure. This allows for\nadditional data to be retrieved: in particular, the enabled\nand running times (in <i>buf</i><b>-&gt;enabled</b> and\n<i>buf</i><b>-&gt;running</b>, respectively) are copied. In\ngeneral, <b>bpf_perf_event_read_value</b>() is recommended\nover <b>bpf_perf_event_read</b>(), which has some ABI issues\nand provides fewer functionalities.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">These values\nare interesting, because hardware PMU (Performance\nMonitoring Unit) counters are limited resources. When there\nare more PMU based perf events opened than available\ncounters, kernel will multiplex these events so each event\ngets certain percentage (but not all) of the PMU time. In\ncase that multiplexing happens, the number of samples or\ncounter value will not reflect the case compared to when no\nmultiplexing occurs. This makes comparison between different\nruns difficult. Typically, the counter value should be\nnormalized before comparing to other experiments. The usual\nnormalization is done as follows.</p>\n\n<pre style=\"margin-left:37%; margin-top: 1em\">normalized_counter = counter * t_enabled / t_running</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">Where t_enabled\nis the time enabled for event and t_running is the time\nrunning for event since last normalization. The enabled and\nrunning times are accumulated since the perf event open. To\nachieve scaling factor between two invocations of an eBPF\nprogram, users can use CPU id as the key (which is typical\nfor perf array usage model) to remember the previous value\nand do the calculation inside the eBPF program.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_perf_prog_read_value(struct bpf_perf_event_data\n*</b><i>ctx</i><b>, struct <br>\nbpf_perf_event_value *</b><i>buf</i><b>, u32</b>\n<i>buf_size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">For en eBPF program attached to\na perf event, retrieve the value of the event counter\nassociated to <i>ctx</i> and store it in the structure\npointed by <i>buf</i> and of size <i>buf_size</i>. Enabled\nand running times are also stored in the structure (see\ndescription of helper <b>bpf_perf_event_read_value</b>() for\nmore details).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_getsockopt(void\n*</b><i>bpf_socket</i><b>, int</b> <i>level</i><b>, int</b>\n<i>optname</i><b>, void <br>\n*</b><i>optval</i><b>, int</b> <i>optlen</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Emulate a call to\n<b>getsockopt()</b> on the socket associated to\n<i>bpf_socket</i>, which must be a full socket. The\n<i>level</i> at which the option resides and the name\n<i>optname</i> of the option must be specified, see\n<b>getsockopt(2)</b> for more information. The retrieved\nvalue is stored in the structure pointed by <i>opval</i> and\nof length <i>optlen</i>.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>bpf_socket</i>\nshould be one of the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_ops</b> for\n<b>BPF_PROG_TYPE_SOCK_OPS</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>struct bpf_sock_addr</b> for\n<b>BPF_CGROUP_INET4_CONNECT</b> and\n<b>BPF_CGROUP_INET6_CONNECT</b>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nactually implements a subset of <b>getsockopt()</b>. It\nsupports the following <i>level</i>s:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>IPPROTO_TCP</b>, which\nsupports <i>optname</i> <b>TCP_CONGESTION</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IP</b>, which supports <i>optname</i>\n<b>IP_TOS</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>IPPROTO_IPV6</b>, which supports <i>optname</i>\n<b>IPV6_TCLASS</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_override_return(struct pt_regs *</b><i>regs</i><b>,\nu64</b> <i>rc</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Used for error injection, this\nhelper uses kprobes to override the return value of the\nprobed function, and to set it to <i>rc</i>. The first\nargument is the context <i>regs</i> on which the kprobe\nworks.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks by setting the PC (program counter) to an override\nfunction which is run in place of the original probed\nfunction. This means the probed function is not run at all.\nThe replacement function just returns with the required\nvalue.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper has\nsecurity implications, and thus is subject to restrictions.\nIt is only available if the kernel was compiled with the\n<b>CONFIG_BPF_KPROBE_OVERRIDE</b> configuration option, and\nin this case it only works on functions tagged with\n<b>ALLOW_ERROR_INJECTION</b> in the kernel code.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Also, the\nhelper is only available for the architectures having the\nCONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,\nx86 architecture is the only one to support this\nfeature.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sock_ops_cb_flags_set(struct bpf_sock_ops\n*</b><i>bpf_sock</i><b>, int</b> <i><br>\nargval</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Attempt to set the value of the\n<b>bpf_sock_ops_cb_flags</b> field for the full TCP socket\nassociated to <i>bpf_sock_ops</i> to <i>argval</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The primary use\nof this field is to determine if there should be calls to\neBPF programs of type <b>BPF_PROG_TYPE_SOCK_OPS</b> at\nvarious points in the TCP code. A program of the same type\ncan change its value, per connection and as necessary, when\nthe connection is established. This field is directly\naccessible for reading, but this helper must be used for\nupdates in order to return an error if an eBPF program tries\nto set a callback that is not supported in the current\nkernel.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>argval</i>\nis a flag array which can combine these flags:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_RTO_CB_FLAG</b> (retransmission time\nout)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_RETRANS_CB_FLAG</b> (retransmission)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_STATE_CB_FLAG</b> (TCP state change)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SOCK_OPS_RTT_CB_FLAG</b> (every RTT)</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Therefore, this\nfunction can be used to clear a callback flag by setting the\nappropriate bit to zero. e.g. to disable the RTO callback:\n<b><br>\nbpf_sock_ops_cb_flags_set(bpf_sock,</b></p>\n\n\n<p style=\"margin-left:43%;\"><b>bpf_sock-&gt;bpf_sock_ops_cb_flags\n&amp; ~BPF_SOCK_OPS_RTO_CB_FLAG)</b></p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Here are some\nexamples of where one could call such eBPF program:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When RTO fires.</p></td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When a packet is retransmitted.</p></td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When the connection terminates.</p></td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When a packet is sent.</p></td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"48%\">\n\n\n<p>When a packet is received.</p></td>\n<td width=\"17%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"48%\"></td>\n<td width=\"17%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Code\n<b>-EINVAL</b> if the socket is not a full TCP socket;\notherwise, a positive number containing the bits that could\nnot be set is returned (which comes down to 0 if all bits\nwere set as required).</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_redirect_map(struct sk_msg_buff *</b><i>msg</i><b>,\nstruct bpf_map *</b><i>map</i><b>, <br>\nu32</b> <i>key</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing policies at the socket level. If the message\n<i>msg</i> is allowed to pass (i.e. if the verdict eBPF\nprogram returns <b>SK_PASS</b>), redirect it to the socket\nreferenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress path otherwise). This is the only flag\nsupported for now.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror.</p> </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_apply_bytes(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>bytes</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">For socket policies, apply the\nverdict of the eBPF program to the next <i>bytes</i> (number\nof bytes) of message <i>msg</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">For example,\nthis helper can be used in the following cases:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>A single <b>sendmsg</b>() or <b>sendfile</b>() system\ncall contains multiple logical messages that the eBPF\nprogram is supposed to read and for which it should apply a\nverdict.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>An eBPF program only cares to read the first\n<i>bytes</i> of a <i>msg</i>. If the message has a large\npayload, then setting up and calling the eBPF program\nrepeatedly for all bytes, even though the verdict is already\nknown, would create unnecessary overhead.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">When called\nfrom within an eBPF program, the helper sets a counter\ninternal to the BPF infrastructure, that is used to apply\nthe last verdict to the next <i>bytes</i>. If <i>bytes</i>\nis smaller than the current data being processed from a\n<b>sendmsg</b>() or <b>sendfile</b>() system call, the first\n<i>bytes</i> will be sent and the eBPF program will be\nre-run with the pointer for start of data pointing to byte\nnumber <i>bytes</i> <b>+ 1</b>. If <i>bytes</i> is larger\nthan the current data being processed, then the eBPF verdict\nwill be applied to multiple <b>sendmsg</b>() or\n<b>sendfile</b>() calls until <i>bytes</i> are consumed.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note that if a\nsocket closes with the internal counter holding a non-zero\nvalue, this is not a problem because data is not being\nbuffered for <i>bytes</i> and is sent as it is received.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p style=\"margin-top: 1em\">0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_cork_bytes(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>bytes</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">For socket policies, prevent\nthe execution of the verdict eBPF program for message\n<i>msg</i> until <i>bytes</i> (byte number) have been\naccumulated.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This can be\nused when one needs a specific number of bytes before a\nverdict can be assigned, even if the data spans multiple\n<b>sendmsg</b>() or <b>sendfile</b>() calls. The extreme\ncase would be a user calling <b>sendmsg</b>() repeatedly\nwith 1-byte long message segments. Obviously, this is bad\nfor performance, but it is still valid. If the eBPF program\nneeds <i>bytes</i> bytes to validate a header, this helper\ncan be used to prevent the eBPF program to be called again\nuntil <i>bytes</i> have been accumulated.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_pull_data(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>start</i><b>, u32</b> <i>end</i><b>, u64</b>\n<i><br>\nflags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">For socket policies, pull in\nnon-linear data from user space for <i>msg</i> and set\npointers <i>msg</i><b>-&gt;data</b> and\n<i>msg</i><b>-&gt;data_end</b> to <i>start</i> and\n<i>end</i> bytes offsets into <i>msg</i>, respectively.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If a program of\ntype <b>BPF_PROG_TYPE_SK_MSG</b> is run on a <i>msg</i> it\ncan only parse data that the (<b>data</b>, <b>data_end</b>)\npointers have already consumed. For <b>sendmsg</b>() hooks\nthis is likely the first scatterlist element. But for calls\nrelying on the <b>sendpage</b> handler (e.g.\n<b>sendfile</b>()) this will be the range (<b>0</b>,\n<b>0</b>) because the data is shared with user space and by\ndefault the objective is to avoid allowing user space to\nmodify data while (or after) eBPF verdict is being decided.\nThis helper can be used to pull in data and to set the start\nand end pointer to given values. Data will be copied if\nnecessary (i.e. if data was not linear and if start and end\npointers do not point to the same chunk).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_bind(struct\nbpf_sock_addr *</b><i>ctx</i><b>, struct sockaddr\n*</b><i>addr</i><b>, int</b> <i><br>\naddr_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Bind the socket associated to\n<i>ctx</i> to the address pointed by <i>addr</i>, of length\n<i>addr_len</i>. This allows for making outgoing connection\nfrom the desired IP address, which can be useful for example\nwhen all processes inside a cgroup should use one single IP\naddress on a host that has multiple IP configured.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper\nworks for IPv4 and IPv6, TCP and UDP sockets. The domain\n(<i>addr</i><b>-&gt;sa_family</b>) must be <b>AF_INET</b>\n(or <b>AF_INET6</b>). It's advised to pass zero port\n(<b>sin_port</b> or <b>sin6_port</b>) which triggers\nIP_BIND_ADDRESS_NO_PORT-like behavior and lets the kernel\nefficiently pick up an unused port as long as 4-tuple is\nunique. Passing non-zero port might lead to degraded\nperformance.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_xdp_adjust_tail(struct xdp_buff *</b><i>xdp_md</i><b>,\nint</b> <i>delta</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Adjust (move)\n<i>xdp_md</i><b>-&gt;data_end</b> by <i>delta</i> bytes. It\nis possible to both shrink and grow the packet tail. Shrink\ndone via <i>delta</i> being a negative integer.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_get_xfrm_state(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>index</i><b>, struct <br>\nbpf_xfrm_state *</b><i>xfrm_state</i><b>, u32</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Retrieve the XFRM state (IP\ntransform framework, see also <b>ip-xfrm(8)</b>) at\n<i>index</i> in XFRM &quot;security path&quot; for\n<i>skb</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The retrieved\nvalue is stored in the <b>struct bpf_xfrm_state</b> pointed\nby <i>xfrm_state</i> and of length <i>size</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_XFRM</b> configuration option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_get_stack(void\n*</b><i>ctx</i><b>, void *</b><i>buf</i><b>, u32</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return a user or a kernel stack\nin bpf program provided buffer. To achieve this, the helper\nneeds <i>ctx</i>, which is a pointer to the context on which\nthe tracing program is executed. To store the stacktrace,\nthe bpf program provides <i>buf</i> with a nonnegative\n<i>size</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The last\nargument, <i>flags</i>, holds the number of stack frames to\nskip (from 0 to 255), masked with\n<b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to\nset the following flags: <b><br>\nBPF_F_USER_STACK</b></p>\n\n<p style=\"margin-left:43%;\">Collect a user space stack\ninstead of a kernel stack.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_F_USER_BUILD_ID</b></p>\n\n<p style=\"margin-left:43%;\">Collect buildid+offset instead\nof ips for user stack, only valid if <b>BPF_F_USER_STACK</b>\nis also specified.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>bpf_get_stack</b>()\ncan collect up to <b>PERF_MAX_STACK_DEPTH</b> both kernel\nand user frames, subject to sufficient large buffer size.\nNote that this limit can be controlled with the\n<b>sysctl</b> program, and that it should be manually\nincreased in order to profile long user stacks (such as\nstacks for Java programs). To do so, use:</p>\n\n<pre style=\"margin-left:37%; margin-top: 1em\"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</pre>\n\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A non-negative value equal to or less than <i>size</i>\non success, or a negative error in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_load_bytes_relative(const void *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, void *</b><i>to</i><b>, <br>\nu32</b> <i>len</i><b>, u32</b>\n<i>start_header</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is similar to\n<b>bpf_skb_load_bytes</b>() in that it provides an easy way\nto load <i>len</i> bytes from <i>offset</i> from the packet\nassociated to <i>skb</i>, into the buffer pointed by\n<i>to</i>. The difference to <b>bpf_skb_load_bytes</b>() is\nthat a fifth argument <i>start_header</i> exists in order to\nselect a base offset to start from. <i>start_header</i> can\nbe one of: <b><br>\nBPF_HDR_START_MAC</b></p>\n\n<p style=\"margin-left:43%;\">Base offset to load data from\nis <i>skb</i>'s mac header.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_HDR_START_NET</b></p>\n\n<p style=\"margin-left:43%;\">Base offset to load data from\nis <i>skb</i>'s network header.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">In general,\n&quot;direct packet access&quot; is the preferred method to\naccess packet data, however, this helper is in particular\nuseful in socket filters where <i>skb</i><b>-&gt;data</b>\ndoes not always point to the start of the mac header and\nwhere &quot;direct packet access&quot; is not available.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_fib_lookup(void\n*</b><i>ctx</i><b>, struct bpf_fib_lookup\n*</b><i>params</i><b>, int</b> <i>plen</i><b>, <br>\nu32</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Do FIB lookup in kernel tables\nusing parameters in <i>params</i>. If lookup is successful\nand result shows packet is to be forwarded, the neighbor\ntables are searched for the nexthop. If successful (ie., FIB\nlookup shows forwarding and nexthop is resolved), the\nnexthop address is returned in ipv4_dst or ipv6_dst based on\nfamily, smac is set to mac address of egress device, dmac is\nset to nexthop mac address, rt_metric is set to metric from\nroute (IPv4/IPv6 only), and ifindex is set to the device\nindex of the nexthop from the FIB lookup.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>plen</i>\nargument is the size of the passed in struct. <i>flags</i>\nargument can be a combination of one or more of the\nfollowing values: <b><br>\nBPF_FIB_LOOKUP_DIRECT</b></p>\n\n<p style=\"margin-left:43%;\">Do a direct table lookup vs\nfull lookup using FIB rules.</p>\n\n\n<p style=\"margin-left:32%;\"><b>BPF_FIB_LOOKUP_OUTPUT</b></p>\n\n<p style=\"margin-left:43%;\">Perform lookup from an egress\nperspective (default is ingress).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>ctx</i> is\neither <b>struct xdp_md</b> for XDP programs or <b>struct\nsk_buff</b> tc cls_act programs.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>&lt; 0 if any input argument is invalid</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>0 on success (packet is forwarded, nexthop neighbor\nexists)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>&gt; 0 one of <b>BPF_FIB_LKUP_RET_</b> codes explaining\nwhy the packet is not forwarded or needs assist from full\nstack</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sock_hash_update(struct bpf_sock_ops\n*</b><i>skops</i><b>, struct bpf_map <br>\n*</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Add an entry to, or update a\nsockhash <i>map</i> referencing sockets. The <i>skops</i> is\nused as a new value for the entry associated to <i>key</i>.\n<i>flags</i> is one of: <b><br>\nBPF_NOEXIST</b></p>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nnot exist in the map.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_EXIST</b></p>\n\n<p style=\"margin-left:43%;\">The entry for <i>key</i> must\nalready exist in the map.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_ANY</b></p>\n\n<p style=\"margin-left:43%;\">No condition on the existence\nof the entry for <i>key</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>map</i> has eBPF programs (parser and verdict), those\nwill be inherited by the socket being added. If the socket\nis already attached to eBPF programs, this results in an\nerror.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_redirect_hash(struct sk_msg_buff *</b><i>msg</i><b>,\nstruct bpf_map <br>\n*</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing policies at the socket level. If the message\n<i>msg</i> is allowed to pass (i.e. if the verdict eBPF\nprogram returns <b>SK_PASS</b>), redirect it to the socket\nreferenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKHASH</b>) using hash <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress path otherwise). This is the only flag\nsupported for now.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror.</p> </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_redirect_hash(struct sk_buff *</b><i>skb</i><b>,\nstruct bpf_map *</b><i>map</i><b>, <br>\nvoid *</b><i>key</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing policies at the skb socket level. If the\nsk_buff <i>skb</i> is allowed to pass (i.e. if the verdict\neBPF program returns <b>SK_PASS</b>), redirect it to the\nsocket referenced by <i>map</i> (of type\n<b>BPF_MAP_TYPE_SOCKHASH</b>) using hash <i>key</i>. Both\ningress and egress interfaces can be used for redirection.\nThe <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to\nmake the distinction (ingress path is selected if the flag\nis present, egress otherwise). This is the only flag\nsupported for now.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"62%\">\n\n\n<p><b>SK_PASS</b> on success, or <b>SK_DROP</b> on\nerror.</p> </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_push_encap(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>type</i><b>, void *</b><i>hdr</i><b>, u32</b>\n<i><br>\nlen</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Encapsulate the packet\nassociated to <i>skb</i> within a Layer 3 protocol header.\nThis header is provided in the buffer at address <i>hdr</i>,\nwith <i>len</i> its size in bytes. <i>type</i> indicates the\nprotocol of the header and can be one of: <b><br>\nBPF_LWT_ENCAP_SEG6</b></p>\n\n<p style=\"margin-left:43%;\">IPv6 encapsulation with Segment\nRouting Header (<b>struct ipv6_sr_hdr</b>). <i>hdr</i> only\ncontains the SRH, the IPv6 header is computed by the\nkernel.</p>\n\n\n<p style=\"margin-left:32%;\"><b>BPF_LWT_ENCAP_SEG6_INLINE</b></p>\n\n<p style=\"margin-left:43%;\">Only works if <i>skb</i>\ncontains an IPv6 packet. Insert a Segment Routing Header\n(<b>struct ipv6_sr_hdr</b>) inside the IPv6 header.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_LWT_ENCAP_IP</b></p>\n\n<p style=\"margin-left:43%;\">IP encapsulation\n(GRE/GUE/IPIP/etc). The outer header must be IPv4 or IPv6,\nfollowed by zero or more additional headers, up to\n<b>LWT_BPF_MAX_HEADROOM</b> total bytes in all prepended\nheaders. Please note that if <b>skb_is_gso</b>(<i>skb</i>)\nis true, no more than two headers can be prepended, and the\ninner header, if present, should be either GRE or\nUDP/GUE.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>BPF_LWT_ENCAP_SEG6</b>*\ntypes can be called by BPF programs of type\n<b>BPF_PROG_TYPE_LWT_IN</b>; <b>BPF_LWT_ENCAP_IP</b> type\ncan be called by bpf programs of types\n<b>BPF_PROG_TYPE_LWT_IN</b> and\n<b>BPF_PROG_TYPE_LWT_XMIT</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_seg6_store_bytes(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, const <br>\nvoid *</b><i>from</i><b>, u32</b> <i>len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Store <i>len</i> bytes from\naddress <i>from</i> into the packet associated to\n<i>skb</i>, at <i>offset</i>. Only the flags, tag and TLVs\ninside the outermost IPv6 Segment Routing Header can be\nmodified through this helper.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_seg6_adjust_srh(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>offset</i><b>, s32</b> <i><br>\ndelta</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Adjust the size allocated to\nTLVs in the outermost IPv6 Segment Routing Header contained\nin the packet associated to <i>skb</i>, at position\n<i>offset</i> by <i>delta</i> bytes. Only offsets after the\nsegments are accepted. <i>delta</i> can be as well positive\n(growing) as negative (shrinking).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_lwt_seg6_action(struct sk_buff *</b><i>skb</i><b>,\nu32</b> <i>action</i><b>, void *</b><i>param</i><b>, <br>\nu32</b> <i>param_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Apply an IPv6 Segment Routing\naction of type <i>action</i> to the packet associated to\n<i>skb</i>. Each action takes a parameter contained at\naddress <i>param</i>, and of length <i>param_len</i> bytes.\n<i>action</i> can be one of: <b><br>\nSEG6_LOCAL_ACTION_END_X</b></p>\n\n<p style=\"margin-left:43%;\">End.X action: Endpoint with\nLayer-3 cross-connect. Type of <i>param</i>: <b>struct\nin6_addr</b>.</p>\n\n\n<p style=\"margin-left:32%;\"><b>SEG6_LOCAL_ACTION_END_T</b></p>\n\n<p style=\"margin-left:43%;\">End.T action: Endpoint with\nspecific IPv6 table lookup. Type of <i>param</i>:\n<b>int</b>.</p>\n\n\n<p style=\"margin-left:32%;\"><b>SEG6_LOCAL_ACTION_END_B6</b></p>\n\n<p style=\"margin-left:43%;\">End.B6 action: Endpoint bound\nto an SRv6 policy. Type of <i>param</i>: <b>struct\nipv6_sr_hdr</b>.</p>\n\n\n<p style=\"margin-left:32%;\"><b>SEG6_LOCAL_ACTION_END_B6_ENCAP</b></p>\n\n<p style=\"margin-left:43%;\">End.B6.Encap action: Endpoint\nbound to an SRv6 encapsulation policy. Type of <i>param</i>:\n<b>struct ipv6_sr_hdr</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A call to this\nhelper is susceptible to change the underlying packet\nbuffer. Therefore, at load time, all checks on pointers\npreviously done by the verifier are invalidated and must be\nperformed again, if the helper is used in combination with\ndirect packet access.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_rc_repeat(void\n*</b><i>ctx</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing IR decoding, to report a successfully decoded\nrepeat key message. This delays the generation of a key up\nevent for previously generated key down event.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Some IR\nprotocols like NEC have a special IR message for repeating\nlast button, for when a button is held down.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the lirc sample as passed into the\nprogram.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to\n&quot;<b>y</b>&quot;.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_rc_keydown(void\n*</b><i>ctx</i><b>, u32</b> <i>protocol</i><b>, u64</b>\n<i>scancode</i><b>, u32</b> <i>toggle</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing IR decoding, to report a successfully decoded\nkey press with <i>scancode</i>, <i>toggle</i> value in the\ngiven <i>protocol</i>. The scancode will be translated to a\nkeycode using the rc keymap, and reported as an input key\ndown event. After a period a key up event is generated. This\nperiod can be extended by calling either\n<b>bpf_rc_keydown</b>() again with the same values, or\ncalling <b>bpf_rc_repeat</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Some protocols\ninclude a toggle bit, in case the button was released and\npressed again between consecutive scancodes.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the lirc sample as passed into the\nprogram.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>protocol</i> is the decoded protocol number (see <b>enum\nrc_proto</b> for some predefined values).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to\n&quot;<b>y</b>&quot;.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64 bpf_skb_cgroup_id(struct\nsk_buff *</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return the cgroup v2 id of the\nsocket associated with the <i>skb</i>. This is roughly\nsimilar to the <b>bpf_get_cgroup_classid</b>() helper for\ncgroup v1 by providing a tag resp. identifier that can be\nmatched on or used for map lookups e.g. to implement policy.\nThe cgroup v2 id of a given path in the hierarchy is exposed\nin user space through the f_handle API in order to get to\nthe same 64-bit id.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper can\nbe used on TC egress path, but not on ingress, and is\navailable only if the kernel was compiled with the\n<b>CONFIG_SOCK_CGROUP_DATA</b> configuration option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_cgroup_id(void)</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A 64-bit integer containing the current cgroup id based\non the cgroup within which the current task is running.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\n*bpf_get_local_storage(void *</b><i>map</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get the pointer to the local\nstorage area. The type and the size of the local storage is\ndefined by the <i>map</i> argument. The <i>flags</i> meaning\nis specific for each map type, and has to be 0 for cgroup\nlocal storage.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Depending on\nthe BPF program type, a local storage area can be shared\nbetween multiple instances of the BPF program, running\nsimultaneously.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">A user should\ncare about the synchronization by himself. For example, by\nusing the <b>BPF_STX_XADD</b> instruction to alter the\nshared data.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>A pointer to the local storage area.</p></td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_select_reuseport(struct sk_reuseport_md\n*</b><i>reuse</i><b>, struct <br>\nbpf_map *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Select a <b>SO_REUSEPORT</b>\nsocket from a <b>BPF_MAP_TYPE_REUSEPORT_ARRAY</b>\n<i>map</i>. It checks the selected socket is matching the\nincoming request in the socket buffer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_skb_ancestor_cgroup_id(struct sk_buff\n*</b><i>skb</i><b>, int</b>\n<i>ancestor_level</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return id of cgroup v2 that is\nancestor of cgroup associated with the <i>skb</i> at the\n<i>ancestor_level</i>. The root cgroup is at\n<i>ancestor_level</i> zero and each step down the hierarchy\nincrements the level. If <i>ancestor_level</i> == level of\ncgroup associated with <i>skb</i>, then return value will be\nsame as that of <b>bpf_skb_cgroup_id</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The helper is\nuseful to implement policies based on cgroups that are upper\nin hierarchy than immediate cgroup associated with\n<i>skb</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The format of\nreturned id and helper limitations are same as in\n<b>bpf_skb_cgroup_id</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_sk_lookup_tcp(void *</b><i>ctx</i><b>, struct\nbpf_sock_tuple <br>\n*</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>\n<i>netns</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Look for TCP socket matching\n<i>tuple</i>, optionally in a child network namespace\n<i>netns</i>. The return value must be checked, and if\nnon-<b>NULL</b>, released via <b>bpf_sk_release</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the context of the program, such as the skb\nor socket (depending on the hook in use). This is used to\ndetermine the base network namespace for the lookup.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>tuple_size</i>\nmust be one of: <b><br>\nsizeof(</b><i>tuple</i><b>-&gt;ipv4)</b></p>\n\n<p style=\"margin-left:43%;\">Look for an IPv4 socket.</p>\n\n\n<p style=\"margin-left:32%;\"><b>sizeof(</b><i>tuple</i><b>-&gt;ipv6)</b></p>\n\n<p style=\"margin-left:43%;\">Look for an IPv6 socket.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>netns</i> is a negative signed 32-bit integer, then the\nsocket lookup table in the netns associated with the\n<i>ctx</i> will be used. For the TC hooks, this is the netns\nof the device in the skb. For socket hooks, this is the\nnetns of the socket. If <i>netns</i> is any other signed\n32-bit value greater than or equal to zero then it specifies\nthe ID of the netns relative to the netns associated with\nthe <i>ctx</i>. <i>netns</i> values beyond the range of\n32-bit integers are reserved for future use.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_NET</b> configuration option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in\ncase of failure. For sockets with reuseport option, the\n<b>struct bpf_sock</b> result is from\n<i>reuse</i><b>-&gt;socks</b>[] using the hash of the\ntuple.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_sk_lookup_udp(void *</b><i>ctx</i><b>, struct\nbpf_sock_tuple <br>\n*</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>\n<i>netns</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Look for UDP socket matching\n<i>tuple</i>, optionally in a child network namespace\n<i>netns</i>. The return value must be checked, and if\nnon-<b>NULL</b>, released via <b>bpf_sk_release</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the context of the program, such as the skb\nor socket (depending on the hook in use). This is used to\ndetermine the base network namespace for the lookup.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>tuple_size</i>\nmust be one of: <b><br>\nsizeof(</b><i>tuple</i><b>-&gt;ipv4)</b></p>\n\n<p style=\"margin-left:43%;\">Look for an IPv4 socket.</p>\n\n\n<p style=\"margin-left:32%;\"><b>sizeof(</b><i>tuple</i><b>-&gt;ipv6)</b></p>\n\n<p style=\"margin-left:43%;\">Look for an IPv6 socket.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If the\n<i>netns</i> is a negative signed 32-bit integer, then the\nsocket lookup table in the netns associated with the\n<i>ctx</i> will be used. For the TC hooks, this is the netns\nof the device in the skb. For socket hooks, this is the\nnetns of the socket. If <i>netns</i> is any other signed\n32-bit value greater than or equal to zero then it specifies\nthe ID of the netns relative to the netns associated with\nthe <i>ctx</i>. <i>netns</i> values beyond the range of\n32-bit integers are reserved for future use.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">All values for\n<i>flags</i> are reserved for future usage, and must be left\nat zero.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_NET</b> configuration option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in\ncase of failure. For sockets with reuseport option, the\n<b>struct bpf_sock</b> result is from\n<i>reuse</i><b>-&gt;socks</b>[] using the hash of the\ntuple.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_sk_release(struct\nbpf_sock *</b><i>sock</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Release the reference held by\n<i>sock</i>. <i>sock</i> must be a non-<b>NULL</b> pointer\nthat was returned from <b>bpf_sk_lookup_xxx</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_push_elem(struct bpf_map *</b><i>map</i><b>, const\nvoid *</b><i>value</i><b>, u64</b> <i><br>\nflags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Push an element <i>value</i> in\n<i>map</i>. <i>flags</i> is one of: <b><br>\nBPF_EXIST</b></p>\n\n<p style=\"margin-left:43%;\">If the queue/stack is full, the\noldest element is removed to make room for this.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_map_pop_elem(struct\nbpf_map *</b><i>map</i><b>, void\n*</b><i>value</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Pop an element from\n<i>map</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_map_peek_elem(struct bpf_map *</b><i>map</i><b>, void\n*</b><i>value</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get an element from <i>map</i>\nwithout removing it.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_msg_push_data(struct sk_msg_buff *</b><i>msg</i><b>,\nu32</b> <i>start</i><b>, u32</b> <i>len</i><b>, u64</b>\n<i><br>\nflags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">For socket policies, insert\n<i>len</i> bytes into <i>msg</i> at offset <i>start</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If a program of\ntype <b>BPF_PROG_TYPE_SK_MSG</b> is run on a <i>msg</i> it\nmay want to insert metadata or options into the <i>msg</i>.\nThis can later be read and used by any of the lower layer\nBPF hooks.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper may\nfail if under memory pressure (a malloc fails) in these\ncases BPF programs will get an appropriate error and BPF\nprograms will need to handle them.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_msg_pop_data(struct\nsk_msg_buff *</b><i>msg</i><b>, u32</b> <i>start</i><b>,\nu32</b> <i>len</i><b>, u64</b> <i><br>\nflags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Will remove <i>len</i> bytes\nfrom a <i>msg</i> starting at byte <i>start</i>. This may\nresult in <b>ENOMEM</b> errors under certain situations if\nan allocation and copy are required due to a full ring\nbuffer. However, the helper will try to avoid doing the\nallocation if possible. Other errors can occur if input\nparameters are invalid either due to <i>start</i> byte not\nbeing valid part of <i>msg</i> payload and/or <i>pop</i>\nvalue being to large.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_rc_pointer_rel(void\n*</b><i>ctx</i><b>, s32</b> <i>rel_x</i><b>, s32</b>\n<i>rel_y</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper is used in programs\nimplementing IR decoding, to report a successfully decoded\npointer movement.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The <i>ctx</i>\nshould point to the lirc sample as passed into the\nprogram.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nonly available is the kernel was compiled with the\n<b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to\n&quot;<b>y</b>&quot;.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_spin_lock(struct\nbpf_spin_lock *</b><i>lock</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Acquire a spinlock represented\nby the pointer <i>lock</i>, which is stored as part of a\nvalue of a map. Taking the lock allows to safely update the\nrest of the fields in that value. The spinlock can (and\nmust) later be released with a call to\n<b>bpf_spin_unlock</b>(<i>lock</i>).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Spinlocks in\nBPF programs come with a number of restrictions and\nconstraints:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> objects are only allowed inside\nmaps of types <b>BPF_MAP_TYPE_HASH</b> and\n<b>BPF_MAP_TYPE_ARRAY</b> (this list could be extended in\nthe future).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>BTF description of the map is mandatory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The BPF program can take ONE lock at a time, since\ntaking two or more could cause dead locks.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Only one <b>struct bpf_spin_lock</b> is allowed per map\nelement.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>When the lock is taken, calls (either BPF to BPF or\nhelpers) are not allowed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The <b>BPF_LD_ABS</b> and <b>BPF_LD_IND</b> instructions\nare not allowed inside a spinlock-ed region.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The BPF program MUST call <b>bpf_spin_unlock</b>() to\nrelease the lock, on all execution paths, before it\nreturns.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The BPF program can access <b>struct bpf_spin_lock</b>\nonly via the <b>bpf_spin_lock</b>() and\n<b>bpf_spin_unlock</b>() helpers. Loading or storing data\ninto the <b>struct bpf_spin_lock</b> <i>lock</i><b>;</b>\nfield of a map is not allowed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>To use the <b>bpf_spin_lock</b>() helper, the BTF\ndescription of the map value must be a struct and have\n<b>struct bpf_spin_lock</b> <i>anyname</i><b>;</b> field at\nthe top level. Nested lock inside another struct is not\nallowed.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>The <b>struct bpf_spin_lock</b> <i>lock</i> field in a\nmap value must be aligned on a multiple of 4 bytes in that\nvalue.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Syscall with command <b>BPF_MAP_LOOKUP_ELEM</b> does not\ncopy the <b>bpf_spin_lock</b> field to user space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Syscall with command <b>BPF_MAP_UPDATE_ELEM</b>, or\nupdate from a BPF program, do not update the\n<b>bpf_spin_lock</b> field.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> cannot be on the stack or inside a\nnetworking packet (it can only be inside of a map\nvalues).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> is available to root only.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p>Tracing programs and socket filter programs cannot use\n<b>bpf_spin_lock</b>() due to insufficient preemption checks\n(but this may change in the future).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>bpf_spin_lock</b> is not allowed in inner maps of\nmap-in-map.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_spin_unlock(struct\nbpf_spin_lock *</b><i>lock</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Release the <i>lock</i>\npreviously locked by a call to\n<b>bpf_spin_lock</b>(<i>lock</i>).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_sk_fullsock(struct bpf_sock *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper gets a <b>struct\nbpf_sock</b> pointer such that all the fields in this\n<b>bpf_sock</b> can be accessed.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A <b>struct bpf_sock</b> pointer on success, or\n<b>NULL</b> in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_tcp_sock\n*bpf_tcp_sock(struct bpf_sock *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">This helper gets a <b>struct\nbpf_tcp_sock</b> pointer from a <b>struct bpf_sock</b>\npointer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A <b>struct bpf_tcp_sock</b> pointer on success, or\n<b>NULL</b> in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_skb_ecn_set_ce(struct sk_buff\n*</b><i>skb</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Set ECN (Explicit Congestion\nNotification) field of IP header to <b>CE</b> (Congestion\nEncountered) if current value is <b>ECT</b> (ECN Capable\nTransport). Otherwise, do nothing. Works with IPv6 and\nIPv4.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>1 if the <b>CE</b> flag is set (either by the current\nhelper call or because it was already present), 0 if it is\nnot set.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_get_listener_sock(struct bpf_sock\n*</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return a <b>struct bpf_sock</b>\npointer in <b>TCP_LISTEN</b> state. <b>bpf_sk_release</b>()\nis unnecessary and not allowed.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A <b>struct bpf_sock</b> pointer on success, or\n<b>NULL</b> in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct bpf_sock\n*bpf_skc_lookup_tcp(void *</b><i>ctx</i><b>, struct\nbpf_sock_tuple <br>\n*</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>\n<i>netns</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Look for TCP socket matching\n<i>tuple</i>, optionally in a child network namespace\n<i>netns</i>. The return value must be checked, and if\nnon-<b>NULL</b>, released via <b>bpf_sk_release</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This function\nis identical to <b>bpf_sk_lookup_tcp</b>(), except that it\nalso returns timewait or request sockets. Use\n<b>bpf_sk_fullsock</b>() or <b>bpf_tcp_sock</b>() to access\nthe full structure.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with\n<b>CONFIG_NET</b> configuration option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in\ncase of failure. For sockets with reuseport option, the\n<b>struct bpf_sock</b> result is from\n<i>reuse</i><b>-&gt;socks</b>[] using the hash of the\ntuple.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_tcp_check_syncookie(struct bpf_sock *</b><i>sk</i><b>,\nvoid *</b><i>iph</i><b>, u32</b> <i><br>\niph_len</i><b>, struct tcphdr *</b><i>th</i><b>, u32</b>\n<i>th_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Check whether <i>iph</i> and\n<i>th</i> contain a valid SYN cookie ACK for the listening\nsocket in <i>sk</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>iph</i>\npoints to the start of the IPv4 or IPv6 header, while\n<i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>)\nor <b>sizeof</b>(<b>struct ip6hdr</b>).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>th</i>\npoints to the start of the TCP header, while <i>th_len</i>\ncontains <b>sizeof</b>(<b>struct tcphdr</b>).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 if <i>iph</i> and <i>th</i> are a valid SYN cookie\nACK, or a negative error otherwise.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_get_name(struct bpf_sysctl *</b><i>ctx</i><b>,\nchar *</b><i>buf</i><b>, size_t</b> <i><br>\nbuf_len</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get name of sysctl in\n/proc/sys/ and copy it into provided by program buffer\n<i>buf</i> of size <i>buf_len</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The buffer is\nalways NUL terminated, unless it's zero-sized.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If <i>flags</i>\nis zero, full name (e.g. &quot;net/ipv4/tcp_mem&quot;) is\ncopied. Use <b>BPF_F_SYSCTL_BASE_NAME</b> flag to copy base\nname only (e.g. &quot;tcp_mem&quot;).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of character copied (not including the trailing\nNUL).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the buffer wasn't big enough (<i>buf</i> will contain\ntruncated name in this case).</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_get_current_value(struct bpf_sysctl\n*</b><i>ctx</i><b>, char *</b><i>buf</i><b>, <br>\nsize_t</b> <i>buf_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get current value of sysctl as\nit is presented in /proc/sys (incl. newline, etc), and copy\nit as a string into provided by program buffer <i>buf</i> of\nsize <i>buf_len</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The whole value\nis copied, no matter what file position user space issued\ne.g. sys_read at.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The buffer is\nalways NUL terminated, unless it's zero-sized.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of character copied (not including the trailing\nNUL).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the buffer wasn't big enough (<i>buf</i> will contain\ntruncated name in this case).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif current value was unavailable, e.g. because sysctl is\nuninitialized and read returns -EIO for it.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_get_new_value(struct bpf_sysctl\n*</b><i>ctx</i><b>, char *</b><i>buf</i><b>, size_t</b>\n<i><br>\nbuf_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get new value being written by\nuser space to sysctl (before the actual write happens) and\ncopy it as a string into provided by program buffer\n<i>buf</i> of size <i>buf_len</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">User space may\nwrite new value at file position &gt; 0.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The buffer is\nalways NUL terminated, unless it's zero-sized.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of character copied (not including the trailing\nNUL).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the buffer wasn't big enough (<i>buf</i> will contain\ntruncated name in this case).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif sysctl is being read.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sysctl_set_new_value(struct bpf_sysctl\n*</b><i>ctx</i><b>, const char *</b><i>buf</i><b>, <br>\nsize_t</b> <i>buf_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Override new value being\nwritten by user space to sysctl with value provided by\nprogram in buffer <i>buf</i> of size <i>buf_len</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>buf</i>\nshould contain a string in same form as provided by user\nspace on sysctl write.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">User space may\nwrite new value at file position &gt; 0. To override the\nwhole sysctl value file position should be set to zero.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"20%\">\n\n\n<p>0 on success.</p></td>\n<td width=\"48%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif the <i>buf_len</i> is too big.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif sysctl is being read.</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_strtol(const char\n*</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>, u64</b>\n<i>flags</i><b>, long *</b><i>res</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Convert the initial part of the\nstring from buffer <i>buf</i> of size <i>buf_len</i> to a\nlong integer according to the given base and save the result\nin <i>res</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The string may\nbegin with an arbitrary amount of white space (as determined\nby <a href=\"https://man.page/3/isspace\">isspace(3)</a>) followed by a single optional\n'<b>-</b>' sign.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Five least\nsignificant bits of <i>flags</i> encode base, other bits are\ncurrently unused.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Base must be\neither 8, 10, 16 or 0 to detect it automatically similar to\nuser space <a href=\"https://man.page/3/strtol\">strtol(3)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of characters consumed on success. Must be\npositive but no more than <i>buf_len</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif no valid digits were found or unsupported base was\nprovided.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ERANGE</b>\nif resulting value was out of range.</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_strtoul(const char\n*</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>, u64</b>\n<i>flags</i><b>, unsigned <br>\nlong *</b><i>res</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Convert the initial part of the\nstring from buffer <i>buf</i> of size <i>buf_len</i> to an\nunsigned long integer according to the given base and save\nthe result in <i>res</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The string may\nbegin with an arbitrary amount of white space (as determined\nby <a href=\"https://man.page/3/isspace\">isspace(3)</a>).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Five least\nsignificant bits of <i>flags</i> encode base, other bits are\ncurrently unused.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Base must be\neither 8, 10, 16 or 0 to detect it automatically similar to\nuser space <a href=\"https://man.page/3/strtoul\">strtoul(3)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Number of characters consumed on success. Must be\npositive but no more than <i>buf_len</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif no valid digits were found or unsupported base was\nprovided.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ERANGE</b>\nif resulting value was out of range.</p>\n\n<p style=\"margin-left:11%;\"><b>void\n*bpf_sk_storage_get(struct bpf_map *</b><i>map</i><b>,\nstruct bpf_sock *</b><i>sk</i><b>, void <br>\n*</b><i>value</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Get a bpf-local-storage from a\n<i>sk</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Logically, it\ncould be thought of getting the value from a <i>map</i> with\n<i>sk</i> as the <b>key</b>. From this perspective, the\nusage is not much different from\n<b>bpf_map_lookup_elem</b>(<i>map</i>,\n<b>&amp;</b><i>sk</i>) except this helper enforces the key\nmust be a full socket and the map must be a\n<b>BPF_MAP_TYPE_SK_STORAGE</b> also.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Underneath, the\nvalue is stored locally at <i>sk</i> instead of the\n<i>map</i>. The <i>map</i> is used as the bpf-local-storage\n&quot;type&quot;. The bpf-local-storage &quot;type&quot;\n(i.e. the <i>map</i>) is searched against all\nbpf-local-storages residing at <i>sk</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">An optional\n<i>flags</i> (<b>BPF_SK_STORAGE_GET_F_CREATE</b>) can be\nused such that a new bpf-local-storage will be created if\none does not exist. <i>value</i> can be used together with\n<b>BPF_SK_STORAGE_GET_F_CREATE</b> to specify the initial\nvalue of a bpf-local-storage. If <i>value</i> is\n<b>NULL</b>, the new bpf-local-storage will be zero\ninitialized.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A bpf-local-storage pointer is returned on success.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>NULL</b> if\nnot found or there was an error in adding a new\nbpf-local-storage.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_sk_storage_delete(struct bpf_map *</b><i>map</i><b>,\nstruct bpf_sock *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Delete a bpf-local-storage from\na <i>sk</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"20%\">\n\n\n<p>0 on success.</p></td>\n<td width=\"48%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif the bpf-local-storage cannot be found.</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_send_signal(u32</b>\n<i>sig</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Send signal <i>sig</i> to the\nprocess of the current task. The signal may be delivered to\nany of this process's threads.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>0 on success or successfully queued.</p></td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EBUSY</b>\nif work queue under nmi is full.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif <i>sig</i> is invalid.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EPERM</b>\nif no permission to send the <i>sig</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EAGAIN</b>\nif bpf program can try again.</p>\n\n<p style=\"margin-left:11%;\"><b>s64\nbpf_tcp_gen_syncookie(struct bpf_sock *</b><i>sk</i><b>,\nvoid *</b><i>iph</i><b>, u32</b> <i>iph_len</i><b>, <br>\nstruct tcphdr *</b><i>th</i><b>, u32</b>\n<i>th_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Try to issue a SYN cookie for\nthe packet with corresponding IP/TCP headers, <i>iph</i> and\n<i>th</i>, on the listening socket in <i>sk</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>iph</i>\npoints to the start of the IPv4 or IPv6 header, while\n<i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>)\nor <b>sizeof</b>(<b>struct ip6hdr</b>).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>th</i>\npoints to the start of the TCP header, while <i>th_len</i>\ncontains the length of the TCP header.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, lower 32 bits hold the generated SYN cookie\nin followed by 16 bits which hold the MSS value for that\ncookie, and the top 16 bits are unused.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">On failure, the\nreturned value is one of the following:</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nSYN cookie cannot be issued due to error</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nSYN cookie should not be issued (no SYN flood)</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOPNOTSUPP</b>\nkernel configuration does not enable SYN cookies</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EPROTONOSUPPORT</b>\nIP packet version is not 4 or 6</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_skb_output(void\n*</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>, void <br>\n*</b><i>data</i><b>, u64</b> <i>size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Write raw <i>data</i> blob into\na special BPF perf event held by <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event must\nhave the following attributes: <b>PERF_SAMPLE_RAW</b> as\n<b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as\n<b>type</b>, and <b>PERF_COUNT_SW_BPF_OUTPUT</b> as\n<b>config</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> are used to indicate the index in <i>map</i>\nfor which the value must be put, masked with\n<b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be\nset to <b>BPF_F_CURRENT_CPU</b> to indicate that the index\nof the current CPU core should be used.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The value to\nwrite, of <i>size</i>, is passed through eBPF stack and\npointed by <i>data</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>ctx</i> is a\npointer to in-kernel struct sk_buff.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nsimilar to <b>bpf_perf_event_output</b>() but restricted to\nraw_tracepoint bpf programs.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_user(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Safely attempt to read\n<i>size</i> bytes from user space address <i>unsafe_ptr</i>\nand store the data in <i>dst</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_kernel(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void\n*</b><i>unsafe_ptr</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Safely attempt to read\n<i>size</i> bytes from kernel space address\n<i>unsafe_ptr</i> and store the data in <i>dst</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_user_str(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void <br>\n*</b><i>unsafe_ptr</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Copy a NUL terminated string\nfrom an unsafe user address <i>unsafe_ptr</i> to <i>dst</i>.\nThe <i>size</i> should include the terminating NUL byte. In\ncase the string length is smaller than <i>size</i>, the\ntarget is not padded with further NUL bytes. If the string\nlength is larger than <i>size</i>, just <i>size</i>-1 bytes\nare copied and the last byte is set to NUL.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">On success, the\nlength of the copied string is returned. This makes this\nhelper useful in tracing programs for reading strings, and\nmore importantly to get its length at runtime. See the\nfollowing snippet:</p>\n<pre style=\"margin-left:37%; margin-top: 1em\">SEC(&quot;kprobe/sys_open&quot;)\nvoid bpf_sys_open(struct pt_regs *ctx)\n{\n        char buf[PATHLEN]; // PATHLEN is defined to 256\n        int res = bpf_probe_read_user_str(buf, sizeof(buf),\n                                          ctx-&gt;di);\n\n\n        // Consume buf, for example push it to\n        // userspace via bpf_perf_event_output(); we\n        // can use res (the string length) as event\n        // size, after checking its boundaries.\n}</pre>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\">In comparison,\nusing <b>bpf_probe_read_user</b>() helper here instead to\nread the string would require to estimate the length at\ncompile time, and would often result in copying more memory\nthan necessary.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Another useful\nuse case is when parsing individual process arguments or\nindividual environment variables navigating\n<i>current</i><b>-&gt;mm-&gt;arg_start</b> and\n<i>current</i><b>-&gt;mm-&gt;env_start</b>: using this\nhelper and the return value, one can quickly iterate at the\nright offset of the memory area.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, the strictly positive length of the string,\nincluding the trailing NUL character. On error, a negative\nvalue.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_probe_read_kernel_str(void *</b><i>dst</i><b>, u32</b>\n<i>size</i><b>, const void <br>\n*</b><i>unsafe_ptr</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Copy a NUL terminated string\nfrom an unsafe kernel address <i>unsafe_ptr</i> to\n<i>dst</i>. Same semantics as with\n<b>bpf_probe_read_user_str</b>() apply.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, the strictly positive length of the string,\nincluding the trailing NUL character. On error, a negative\nvalue.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_tcp_send_ack(void\n*</b><i>tp</i><b>, u32</b> <i>rcv_nxt</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Send out a tcp-ack. <i>tp</i>\nis the in-kernel struct <b>tcp_sock</b>. <i>rcv_nxt</i> is\nthe ack_seq to be sent out.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_send_signal_thread(u32</b> <i>sig</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Send signal <i>sig</i> to the\nthread corresponding to the current task.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"56%\">\n\n\n<p>0 on success or successfully queued.</p></td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EBUSY</b>\nif work queue under nmi is full.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif <i>sig</i> is invalid.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EPERM</b>\nif no permission to send the <i>sig</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EAGAIN</b>\nif bpf program can try again.</p>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_jiffies64(void)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Obtain the 64bit jiffies</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"28%\">\n\n\n<p>The 64 bit jiffies</p></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_read_branch_records(struct bpf_perf_event_data\n*</b><i>ctx</i><b>, void <br>\n*</b><i>buf</i><b>, u32</b> <i>size</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">For an eBPF program attached to\na perf event, retrieve the branch records (<b>struct\nperf_branch_entry</b>) associated to <i>ctx</i> and store it\nin the buffer pointed by <i>buf</i> up to size <i>size</i>\nbytes.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>On success, number of bytes written to <i>buf</i>. On\nerror, a negative value.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> can be set to\n<b>BPF_F_GET_BRANCH_RECORDS_SIZE</b> to instead return the\nnumber of bytes required to store all the branch entries. If\nthis flag is set, <i>buf</i> may be NULL.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif arguments invalid or <b>size</b> not a multiple of\n<b>sizeof</b>(<b>struct perf_branch_entry</b>).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif architecture does not support branch records.</p>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_ns_current_pid_tgid(u64</b> <i>dev</i><b>, u64</b>\n<i>ino</i><b>, struct <br>\nbpf_pidns_info *</b><i>nsdata</i><b>, u32</b>\n<i>size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Returns 0 on success, values\nfor <i>pid</i> and <i>tgid</i> as seen from the current\n<i>namespace</i> will be returned in <i>nsdata</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or one of the following in case of\nfailure:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif dev and inum supplied don't match dev_t and inode number\nwith nsfs of current task, or if dev conversion to dev_t\nlost high bits.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif pidns does not exists for the current task.</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_xdp_output(void\n*</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,\nu64</b> <i>flags</i><b>, void <br>\n*</b><i>data</i><b>, u64</b> <i>size</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Write raw <i>data</i> blob into\na special BPF perf event held by <i>map</i> of type\n<b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event must\nhave the following attributes: <b>PERF_SAMPLE_RAW</b> as\n<b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as\n<b>type</b>, and <b>PERF_COUNT_SW_BPF_OUTPUT</b> as\n<b>config</b>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> are used to indicate the index in <i>map</i>\nfor which the value must be put, masked with\n<b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be\nset to <b>BPF_F_CURRENT_CPU</b> to indicate that the index\nof the current CPU core should be used.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The value to\nwrite, of <i>size</i>, is passed through eBPF stack and\npointed by <i>data</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>ctx</i> is a\npointer to in-kernel struct xdp_buff.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\nsimilar to <b>bpf_perf_eventoutput</b>() but restricted to\nraw_tracepoint bpf programs.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_netns_cookie(void *</b><i>ctx</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Retrieve the cookie (generated\nby the kernel) of the network namespace the input <i>ctx</i>\nis associated with. The network namespace cookie remains\nstable for its lifetime and provides a global identifier\nthat can be assumed unique. If <i>ctx</i> is NULL, then the\nhelper returns the cookie for the initial network namespace.\nThe cookie itself is very similar to that of\n<b>bpf_get_socket_cookie</b>() helper, but for network\nnamespaces instead of sockets.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"43%\">\n\n\n<p>A 8-byte long opaque number.</p></td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_get_current_ancestor_cgroup_id(int</b>\n<i>ancestor_level</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return id of cgroup v2 that is\nancestor of the cgroup associated with the current task at\nthe <i>ancestor_level</i>. The root cgroup is at\n<i>ancestor_level</i> zero and each step down the hierarchy\nincrements the level. If <i>ancestor_level</i> == level of\ncgroup associated with the current task, then return value\nwill be the same as that of\n<b>bpf_get_current_cgroup_id</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The helper is\nuseful to implement policies based on cgroups that are upper\nin hierarchy than immediate cgroup associated with the\ncurrent task.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The format of\nreturned id and helper limitations are same as in\n<b>bpf_get_current_cgroup_id</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_sk_assign(struct\nsk_buff *</b><i>skb</i><b>, struct bpf_sock\n*</b><i>sk</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Helper is overloaded depending\non BPF program type. This description applies to\n<b>BPF_PROG_TYPE_SCHED_CLS</b> and\n<b>BPF_PROG_TYPE_SCHED_ACT</b> programs.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Assign the\n<i>sk</i> to the <i>skb</i>. When combined with appropriate\nrouting configuration to receive the packet towards the\nsocket, will cause <i>skb</i> to be delivered to the\nspecified socket. Subsequent redirection of <i>skb</i> via\n<b>bpf_redirect</b>(), <b>bpf_clone_redirect</b>() or other\nmethods outside of BPF may interfere with successful\ndelivery to the socket.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This operation\nis only valid from TC ingress path.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The\n<i>flags</i> argument must be zero.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif specified <i>flags</i> are not supported.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENOENT</b>\nif the socket is unavailable for assignment.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ENETUNREACH</b>\nif the socket is unreachable (wrong netns).</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOPNOTSUPP</b>\nif the operation is not supported, for example a call from\noutside of TC ingress.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-ESOCKTNOSUPPORT</b>\nif the socket type is not supported (reuseport).</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_sk_assign(struct\nbpf_sk_lookup *</b><i>ctx</i><b>, struct bpf_sock\n*</b><i>sk</i><b>, u64</b> <i><br>\nflags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Helper is overloaded depending\non BPF program type. This description applies to\n<b>BPF_PROG_TYPE_SK_LOOKUP</b> programs.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Select the\n<i>sk</i> as a result of a socket lookup.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">For the\noperation to succeed passed socket must be compatible with\nthe packet description provided by the <i>ctx</i>\nobject.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">L4 protocol\n(<b>IPPROTO_TCP</b> or <b>IPPROTO_UDP</b>) must be an exact\nmatch. While IP family (<b>AF_INET</b> or <b>AF_INET6</b>)\nmust be compatible, that is IPv6 sockets that are not\nv6-only can be selected for IPv4 packets.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Only TCP\nlisteners and UDP unconnected sockets can be selected.\n<i>sk</i> can also be NULL to reset any previous\nselection.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>flags</i>\nargument can combination of following values:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SK_LOOKUP_F_REPLACE</b> to override the previous\nsocket selection, potentially done by a BPF program that ran\nbefore us.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_SK_LOOKUP_F_NO_REUSEPORT</b> to skip\nload-balancing within reuseport group for the socket being\nselected.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">On success\n<i>ctx-&gt;sk</i> will point to the selected socket.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">0 on success, or a negative\nerrno in case of failure.</p></td></tr>\n</table>\n\n<p style=\"margin-left:32%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p style=\"margin-top: 1em\"><b>-EAFNOSUPPORT</b> if socket\nfamily (<i>sk-&gt;family</i>) is not compatible with packet\nfamily (<i>ctx-&gt;family</i>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-EEXIST</b> if socket has been already selected,\npotentially by another program, and\n<b>BPF_SK_LOOKUP_F_REPLACE</b> flag was not specified.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-EINVAL</b> if unsupported flags were specified.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-EPROTOTYPE</b> if socket L4 protocol\n(<i>sk-&gt;protocol</i>) doesn't match packet protocol\n(<i>ctx-&gt;protocol</i>).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>-ESOCKTNOSUPPORT</b> if socket is not in allowed\nstate (TCP listening or UDP unconnected).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_ktime_get_boot_ns(void)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return the time elapsed since\nsystem boot, in nanoseconds. Does include the time the\nsystem was suspended. See:\n<b>clock_gettime</b>(<b>CLOCK_BOOTTIME</b>)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"22%\">\n\n\n<p>Current <i>ktime</i>.</p></td>\n<td width=\"46%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_seq_printf(struct\nseq_file *</b><i>m</i><b>, const char *</b><i>fmt</i><b>,\nu32</b> <i>fmt_size</i><b>, <br>\nconst void *</b><i>data</i><b>, u32</b>\n<i>data_len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\"><b>bpf_seq_printf</b>() uses\nseq_file <b>seq_printf</b>() to print out the format string.\nThe <i>m</i> represents the seq_file. The <i>fmt</i> and\n<i>fmt_size</i> are for the format string itself. The\n<i>data</i> and <i>data_len</i> are format string arguments.\nThe <i>data</i> are a <b>u64</b> array and corresponding\nformat string values are stored in the array. For strings\nand pointers where pointees are accessed, only the pointer\nvalues are stored in the <i>data</i> array. The\n<i>data_len</i> is the size of <i>data</i> in bytes.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Formats\n<b>%s</b>, <b>%p{i,I}{4,6}</b> requires to read kernel\nmemory. Reading kernel memory may fail due to either invalid\naddress or valid address but requiring a major memory fault.\nIf reading kernel memory fails, the string for <b>%s</b>\nwill be an empty string, and the ip address for\n<b>%p{i,I}{4,6}</b> will be 0. Not returning error to bpf\nprogram is consistent with what <b>bpf_trace_printk</b>()\ndoes for now.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EBUSY</b>\nif per-CPU memory copy buffer is busy, can try again by\nreturning 1 from bpf program.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EINVAL</b>\nif arguments are invalid, or if <i>fmt</i> is\ninvalid/unsupported.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-E2BIG</b>\nif <i>fmt</i> contains too many format specifiers.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOVERFLOW</b>\nif an overflow happened: The same object will be tried\nagain.</p>\n\n<p style=\"margin-left:11%;\"><b>long bpf_seq_write(struct\nseq_file *</b><i>m</i><b>, const void *</b><i>data</i><b>,\nu32</b> <i>len</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\"><b>bpf_seq_write</b>() uses\nseq_file <b>seq_write</b>() to write the data. The <i>m</i>\nrepresents the seq_file. The <i>data</i> and <i>len</i>\nrepresent the data to write in bytes.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure:</p> </td></tr>\n</table>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>-EOVERFLOW</b>\nif an overflow happened: The same object will be tried\nagain.</p>\n\n<p style=\"margin-left:11%;\"><b>u64 bpf_sk_cgroup_id(struct\nbpf_sock *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return the cgroup v2 id of the\nsocket <i>sk</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\"><i>sk</i> must\nbe a non-<b>NULL</b> pointer to a full socket, e.g. one\nreturned from <b>bpf_sk_lookup_xxx</b>(),\n<b>bpf_sk_fullsock</b>(), etc. The format of returned id is\nsame as in <b>bpf_skb_cgroup_id</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This helper is\navailable only if the kernel was compiled with the\n<b>CONFIG_SOCK_CGROUP_DATA</b> configuration option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64\nbpf_sk_ancestor_cgroup_id(struct bpf_sock *</b><i>sk</i><b>,\nint</b> <i>ancestor_level</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return id of cgroup v2 that is\nancestor of cgroup associated with the <i>sk</i> at the\n<i>ancestor_level</i>. The root cgroup is at\n<i>ancestor_level</i> zero and each step down the hierarchy\nincrements the level. If <i>ancestor_level</i> == level of\ncgroup associated with <i>sk</i>, then return value will be\nsame as that of <b>bpf_sk_cgroup_id</b>().</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The helper is\nuseful to implement policies based on cgroups that are upper\nin hierarchy than immediate cgroup associated with\n<i>sk</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The format of\nreturned id and helper limitations are same as in\n<b>bpf_sk_cgroup_id</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>The id is returned or 0 in case the id could not be\nretrieved.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_ringbuf_output(void\n*</b><i>ringbuf</i><b>, void *</b><i>data</i><b>, u64</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Copy <i>size</i> bytes from\n<i>data</i> into a ring buffer <i>ringbuf</i>. If\n<b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no\nnotification of new data availability is sent. If\n<b>BPF_RB_FORCE_WAKEUP</b> is specified in <i>flags</i>,\nnotification of new data availability is sent\nunconditionally.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>0 on success, or a negative error in case of\nfailure.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\n*bpf_ringbuf_reserve(void *</b><i>ringbuf</i><b>, u64</b>\n<i>size</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Reserve <i>size</i> bytes of\npayload in a ring buffer <i>ringbuf</i>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>Valid pointer with <i>size</i> bytes of memory\navailable; NULL, otherwise.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void bpf_ringbuf_submit(void\n*</b><i>data</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Submit reserved ring buffer\nsample, pointed to by <i>data</i>. If\n<b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no\nnotification of new data availability is sent. If\n<b>BPF_RB_FORCE_WAKEUP</b> is specified in <i>flags</i>,\nnotification of new data availability is sent\nunconditionally.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"39%\">\n\n\n<p>Nothing. Always succeeds.</p></td>\n<td width=\"29%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>void\nbpf_ringbuf_discard(void *</b><i>data</i><b>, u64</b>\n<i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Discard reserved ring buffer\nsample, pointed to by <i>data</i>. If\n<b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no\nnotification of new data availability is sent. If\n<b>BPF_RB_FORCE_WAKEUP</b> is specified in <i>flags</i>,\nnotification of new data availability is sent\nunconditionally.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"39%\">\n\n\n<p>Nothing. Always succeeds.</p></td>\n<td width=\"29%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>u64 bpf_ringbuf_query(void\n*</b><i>ringbuf</i><b>, u64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Query various characteristics\nof provided ring buffer. What exactly is queries is\ndetermined by <i>flags</i>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_AVAIL_DATA</b>: Amount of data not yet\nconsumed.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_RING_SIZE</b>: The size of ring buffer.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_CONS_POS</b>: Consumer position (can wrap\naround).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_RB_PROD_POS</b>: Producer(s) position (can wrap\naround).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Data returned\nis just a momentary snapshot of actual values and could be\ninaccurate, so this facility should be used to power\nheuristics and for reporting, not to make 100% correct\ncalculation.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">Requested value, or 0, if\n<i>flags</i> are not recognized.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long bpf_csum_level(struct\nsk_buff *</b><i>skb</i><b>, u64</b> <i>level</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Change the skbs checksum level\nby one layer up or down, or reset it entirely to none in\norder to have the stack perform checksum validation. The\nlevel is applicable to the following protocols: TCP, UDP,\nGRE, SCTP, FCOE. For example, a decap of | ETH | IP | UDP |\nGUE | IP | TCP | into | ETH | IP | TCP | through\n<b>bpf_skb_adjust_room</b>() helper with passing in\n<b>BPF_F_ADJ_ROOM_NO_CSUM_RESET</b> flag would require one\ncall to <b>bpf_csum_level</b>() with\n<b>BPF_CSUM_LEVEL_DEC</b> since the UDP header is removed.\nSimilarly, an encap of the latter into the former could be\naccompanied by a helper call to <b>bpf_csum_level</b>() with\n<b>BPF_CSUM_LEVEL_INC</b> if the skb is still intended to be\nprocessed in higher layers of the stack instead of just\negressing at tc.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">There are three\nsupported level settings at this time:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_INC</b>: Increases skb-&gt;csum_level\nfor skbs with CHECKSUM_UNNECESSARY.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_DEC</b>: Decreases skb-&gt;csum_level\nfor skbs with CHECKSUM_UNNECESSARY.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_RESET</b>: Resets skb-&gt;csum_level\nto 0 and sets CHECKSUM_NONE to force checksum validation by\nthe stack.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p>&bull;</p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><b>BPF_CSUM_LEVEL_QUERY</b>: No-op, returns the current\nskb-&gt;csum_level.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"12%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:32%; margin-top: 1em\">0 on success,\nor a negative error in case of failure. In the case of\n<b>BPF_CSUM_LEVEL_QUERY</b>, the current skb-&gt;csum_level\nis returned or the error code -EACCES in case the skb is not\nsubject to CHECKSUM_UNNECESSARY.</p>\n\n<p style=\"margin-left:11%;\"><b>struct tcp6_sock\n*bpf_skc_to_tcp6_sock(void *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp6_sock</i> pointer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct tcp_sock\n*bpf_skc_to_tcp_sock(void *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp_sock</i> pointer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct tcp_timewait_sock\n*bpf_skc_to_tcp_timewait_sock(void\n*</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp_timewait_sock</i> pointer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct tcp_request_sock\n*bpf_skc_to_tcp_request_sock(void *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>tcp_request_sock</i> pointer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>struct udp6_sock\n*bpf_skc_to_udp6_sock(void *</b><i>sk</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Dynamically cast a <i>sk</i>\npointer to a <i>udp6_sock</i> pointer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"65%\">\n\n\n<p><i>sk</i> if casting is valid, or NULL otherwise.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>long\nbpf_get_task_stack(struct task_struct *</b><i>task</i><b>,\nvoid *</b><i>buf</i><b>, u32</b> <i>size</i><b>, <br>\nu64</b> <i>flags</i><b>)</b></p>\n\n<p style=\"margin-left:22%;\"><b>Description</b></p>\n\n<p style=\"margin-left:32%;\">Return a user or a kernel stack\nin bpf program provided buffer. To achieve this, the helper\nneeds <i>task</i>, which is a valid pointer to struct\ntask_struct. To store the stacktrace, the bpf program\nprovides <i>buf</i> with a nonnegative <i>size</i>.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The last\nargument, <i>flags</i>, holds the number of stack frames to\nskip (from 0 to 255), masked with\n<b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to\nset the following flags: <b><br>\nBPF_F_USER_STACK</b></p>\n\n<p style=\"margin-left:43%;\">Collect a user space stack\ninstead of a kernel stack.</p>\n\n<p style=\"margin-left:32%;\"><b>BPF_F_USER_BUILD_ID</b></p>\n\n<p style=\"margin-left:43%;\">Collect buildid+offset instead\nof ips for user stack, only valid if <b>BPF_F_USER_STACK</b>\nis also specified.</p>\n\n\n<p style=\"margin-left:32%; margin-top: 1em\"><b>bpf_get_task_stack</b>()\ncan collect up to <b>PERF_MAX_STACK_DEPTH</b> both kernel\nand user frames, subject to sufficient large buffer size.\nNote that this limit can be controlled with the\n<b>sysctl</b> program, and that it should be manually\nincreased in order to profile long user stacks (such as\nstacks for Java programs). To do so, use:</p>\n\n<pre style=\"margin-left:37%; margin-top: 1em\"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</pre>\n\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"9%\">\n\n\n<p><b>Return</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"68%\">\n\n\n<p>A non-negative value equal to or less than <i>size</i>\non success, or a negative error in case of failure.</p></td></tr>\n</table>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Example usage\nfor most of the eBPF helpers listed in this manual page are\navailable within the Linux kernel sources, at the following\nlocations:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"43%\">\n\n\n<p style=\"margin-top: 1em\"><i>samples/bpf/</i></p></td>\n<td width=\"43%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"43%\">\n\n\n<p><i>tools/testing/selftests/bpf/</i></p></td>\n<td width=\"43%\">\n</td></tr>\n</table>\n\n<h2>LICENSE\n<a name=\"LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">eBPF programs\ncan have an associated license, passed along with the\nbytecode instructions to the kernel when the programs are\nloaded. The format for that string is identical to the one\nin use for kernel modules (Dual licenses, such as &quot;Dual\nBSD/GPL&quot;, may be used). Some helper functions are only\naccessible to programs that are compatible with the GNU\nPrivacy License (GPL).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to use\nsuch helpers, the eBPF program must be loaded with the\ncorrect license string passed (via <b>attr</b>) to the\n<b>bpf</b>() system call, and this generally translates into\nthe C source code of the program containing a line similar\nto the following:</p>\n\n<pre style=\"margin-left:15%; margin-top: 1em\">char ____license[] __attribute__((section(&quot;license&quot;), used)) = &quot;GPL&quot;;</pre>\n\n\n<h2>IMPLEMENTATION\n<a name=\"IMPLEMENTATION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This manual\npage is an effort to document the existing eBPF helper\nfunctions. But as of this writing, the BPF sub-system is\nunder heavy development. New eBPF program or map types are\nadded, along with new helper functions. Some helpers are\noccasionally made available for additional program types. So\nin spite of the efforts of the community, this page might\nnot be up-to-date. If you want to check by yourself what\nhelper functions exist in your kernel, or what types of\nprograms they can support, here are some files among the\nkernel tree that you may be interested in:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\"><i>include/uapi/linux/bpf.h</i>\nis the main BPF header. It contains the full list of all\nhelper functions, as well as many other BPF definitions\nincluding most of the flags, structs or constants used by\nthe helpers.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>net/core/filter.c</i> contains the definition of most\nnetwork-related helper functions, and the list of program\ntypes from which they can be used.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>kernel/trace/bpf_trace.c</i> is the equivalent for\nmost tracing program-related helpers.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>kernel/bpf/verifier.c</i> contains the functions used\nto check that valid types of eBPF maps are used with a given\nhelper function.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><i>kernel/bpf/</i> directory contains other files in\nwhich additional helpers are defined (for cgroups, sockmaps,\netc.).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The bpftool utility can be used to probe the\navailability of helper functions on the system (as well as\nsupported program and map types, and a number of other\nparameters). To do so, run <b>bpftool feature probe</b> (see\n<b>bpftool-feature</b>(8) for details). Add the\n<b>unprivileged</b> keyword to list features available to\nunprivileged users.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Compatibility\nbetween helper functions and program types can generally be\nfound in the files where helper functions are defined. Look\nfor the <b>struct bpf_func_proto</b> objects and for\nfunctions returning them: these functions contain a list of\nhelpers that a given program type can call. Note that the\n<b>default:</b> label of the <b>switch ... case</b> used to\nfilter helpers can call other functions, themselves allowing\naccess to additional helpers. The requirement for GPL\nlicense is also in those <b>struct bpf_func_proto</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Compatibility\nbetween helper functions and map types can be found in the\n<b>check_map_func_compatibility</b>() function in file\n<i>kernel/bpf/verifier.c</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Helper\nfunctions that invalidate the checks on <b>data</b> and\n<b>data_end</b> pointers for network processing are listed\nin function <b>bpf_helper_changes_pkt_data</b>() in file\n<i>net/core/filter.c</i>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/bpf\">bpf(2)</a>,\n<b>bpftool</b>(8), <a href=\"https://man.page/7/cgroups\">cgroups(7)</a>, <b>ip</b>(8),\n<a href=\"https://man.page/2/perf_event_open\">perf_event_open(2)</a>, <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>,\n<a href=\"https://man.page/7/socket\">socket(7)</a>, <b>tc-bpf</b>(8)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#HELPERS\">HELPERS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#LICENSE\">LICENSE</a>","<a href=\"#IMPLEMENTATION\">IMPLEMENTATION</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}