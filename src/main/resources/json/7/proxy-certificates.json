{"name":"proxy-certificates","description":"proxy-certificates\n- Proxy certificates in OpenSSL\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nProxy\ncertificates are defined in <small>RFC 3820.</small> They\nare used to extend rights to some other entity (a computer\nprocess, typically, or sometimes to the user itself). This\nallows the entity to perform operations on behalf of the\nowner of the <small>EE</small> (End Entity) certificate.\n\nThe\nrequirements for a valid proxy certificate are:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They are issued by an End Entity, either a normal\n<small>EE</small> certificate, or another proxy\ncertificate. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They must not have the <b>subjectAltName</b> or\n<b>issuerAltName</b> extensions.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They must have the <b>proxyCertInfo</b> extension.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They must have the subject of their issuer, with one\n<b>commonName</b> added.</td></tr>\n</table>\n\n<b>Enabling\nproxy certificate verification</b> <br>\nOpenSSL expects applications that want to use proxy\ncertificates to be specially aware of them, and make that\nexplicit. This is done by setting an X509 verification\nflag:\n\n\nX509_STORE_CTX_set_flags(ctx,\nX509_V_FLAG_ALLOW_PROXY_CERTS);\n\nor\n\n\nX509_VERIFY_PARAM_set_flags(param,\nX509_V_FLAG_ALLOW_PROXY_CERTS);\n\nSee &quot;\n<small>NOTES&quot;</small> for a discussion on this\nrequirement.\n\n<b>Creating\nproxy certificates</b> <br>\nCreating proxy certificates can be done using the\n<a href=\"https://man.page/1/openssl-x509\">openssl-x509(1)</a> command, with some extra\nextensions:\n\n[ proxy ] <br>\n# A proxy certificate MUST NEVER be a CA certificate. <br>\nbasicConstraints = CA:FALSE <br>\n# Usual authority key ID <br>\nauthorityKeyIdentifier = keyid,issuer:always <br>\n# The extension which marks this certificate as a proxy <br>\nproxyCertInfo =\ncritical,language:id-ppl-anyLanguage,pathlen:1,policy:text:AB\n\nIt&rsquo;s also\npossible to specify the proxy extension in a separate\nsection:\n\nproxyCertInfo =\ncritical,@proxy_ext <br>\n[ proxy_ext ] <br>\nlanguage = id-ppl-anyLanguage <br>\npathlen = 0 <br>\npolicy = text:BC\n\nThe policy\nvalue has a specific syntax, <i>syntag</i>:<i>string</i>,\nwhere the <i>syntag</i> determines what will be done with\nthe string. The following <i>syntag</i>s are recognised:\n<b><br>\ntext</b>\n\n<p style=\"margin-left:17%;\">indicates that the string is a\nbyte sequence, without any encoding:\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">policy=text:raeksmoergaas\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>hex</b></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>indicates the string is encoded hexadecimal encoded\nbinary data, with colons between each byte (every second hex\ndigit): </td></tr>\n</table>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">policy=hex:72:E4:6B:73:6D:F6:72:67:E5:73\n\n<p style=\"margin-left:11%;\"><b>file</b>\n\n<p style=\"margin-left:17%;\">indicates that the text of the\npolicy should be taken from a file. The string is then a\nfilename. This is useful for policies that are more than a\nfew lines, such as <small>XML</small> or other markup.\n\nNote that the\nproxy policy value is what determines the rights granted to\nthe process during the proxy certificate, and it is up to\nthe application to interpret and combine these\npolicies.&gt;\n\nWith a proxy\nextension, creating a proxy certificate is a matter of two\ncommands:\n\nopenssl req\n-new -config proxy.cnf \\ <br>\n-out proxy.req -keyout proxy.key \\ <br>\n-subj &quot;/DC=org/DC=openssl/DC=users/CN=proxy&quot; <br>\nopenssl x509 -req -CAcreateserial -in proxy.req -out\nproxy.crt \\ <br>\n-CA user.crt -CAkey user.key -days 7 \\ <br>\n-extfile proxy.cnf -extensions proxy\n\nYou can also\ncreate a proxy certificate using another proxy certificate\nas issuer. Note that this example uses a different\nconfiguration section for the proxy extensions:\n\nopenssl req\n-new -config proxy.cnf \\ <br>\n-out proxy2.req -keyout proxy2.key \\ <br>\n-subj &quot;/DC=org/DC=openssl/DC=users/CN=proxy/CN=proxy\n2&quot; <br>\nopenssl x509 -req -CAcreateserial -in proxy2.req -out\nproxy2.crt \\ <br>\n-CA proxy.crt -CAkey proxy.key -days 7 \\ <br>\n-extfile proxy.cnf -extensions proxy_2\n\n<b>Using proxy\ncerts in applications</b> <br>\nTo interpret proxy policies, the application would normally\nstart with some default rights (perhaps none at all), then\ncompute the resulting rights by checking the rights against\nthe chain of proxy certificates, user certificate and\n<small>CA</small> certificates.\n\nThe complicated\npart is figuring out how to pass data between your\napplication and the certificate validation procedure.\n\nThe following\ningredients are needed for such processing:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>a callback function that will be called for every\ncertificate being validated. The callback is called several\ntimes for each certificate, so you must be careful to do the\nproxy policy interpretation at the right time. You also need\nto fill in the defaults when the <small>EE</small>\ncertificate is checked.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>a data structure that is shared between your application\ncode and the callback.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>a wrapper function that sets it all up.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>an ex_data index function that creates an index into the\ngeneric ex_data store that is attached to an X509 validation\ncontext. </td></tr>\n</table>\n\nThe following\nskeleton code can be used as a starting point:\n\n#include\n&lt;string.h&gt; <br>\n#include &lt;netdb.h&gt; <br>\n#include &lt;openssl/x509.h&gt; <br>\n#include &lt;openssl/x509v3.h&gt; <br>\n#define total_rights 25 <br>\n/* <br>\n* In this example, I will use a view of granted rights as a\nbit <br>\n* array, one bit for each possible right. <br>\n*/ <br>\ntypedef struct your_rights { <br>\nunsigned char rights[(total_rights + 7) / 8]; <br>\n} YOUR_RIGHTS; <br>\n/* <br>\n* The following procedure will create an index for the\nex_data <br>\n* store in the X509 validation context the first time it's\n<br>\n* called. Subsequent calls will return the same index. <br>\n*/ <br>\nstatic int get_proxy_auth_ex_data_idx(X509_STORE_CTX *ctx)\n<br>\n{ <br>\nstatic volatile int idx = -1; <br>\nif (idx &lt; 0) { <br>\nX509_STORE_lock(X509_STORE_CTX_get0_store(ctx)); <br>\nif (idx &lt; 0) { <br>\nidx = X509_STORE_CTX_get_ex_new_index(0, <br>\n&quot;for verify callback&quot;, <br>\nNULL,NULL,NULL); <br>\n} <br>\nX509_STORE_unlock(X509_STORE_CTX_get0_store(ctx)); <br>\n} <br>\nreturn idx; <br>\n} <br>\n/* Callback to be given to the X509 validation procedure. */\n<br>\nstatic int verify_callback(int ok, X509_STORE_CTX *ctx) <br>\n{ <br>\nif (ok == 1) { <br>\n/* <br>\n* It's REALLY important you keep the proxy policy check <br>\n* within this section. It's important to know that when <br>\n* ok is 1, the certificates are checked from top to <br>\n* bottom. You get the CA root first, followed by the <br>\n* possible chain of intermediate CAs, followed by the EE\n<br>\n* certificate, followed by the possible proxy <br>\n* certificates. <br>\n*/ <br>\nX509 *xs = X509_STORE_CTX_get_current_cert(ctx); <br>\nif (X509_get_extension_flags(xs) &amp; EXFLAG_PROXY) { <br>\nYOUR_RIGHTS *rights = <br>\n(YOUR_RIGHTS *)X509_STORE_CTX_get_ex_data(ctx, <br>\nget_proxy_auth_ex_data_idx(ctx)); <br>\nPROXY_CERT_INFO_EXTENSION *pci = <br>\nX509_get_ext_d2i(xs, NID_proxyCertInfo, NULL, NULL); <br>\nswitch (OBJ_obj2nid(pci-&gt;proxyPolicy-&gt;policyLanguage))\n{ <br>\ncase NID_Independent: <br>\n/* <br>\n* Do whatever you need to grant explicit rights <br>\n* to this particular proxy certificate, usually <br>\n* by pulling them from some database. If there <br>\n* are none to be found, clear all rights (making <br>\n* this and any subsequent proxy certificate void <br>\n* of any rights). <br>\n*/ <br>\nmemset(rights-&gt;rights, 0, sizeof(rights-&gt;rights));\n<br>\nbreak; <br>\ncase NID_id_ppl_inheritAll: <br>\n/* <br>\n* This is basically a NOP, we simply let the <br>\n* current rights stand as they are. <br>\n*/ <br>\nbreak; <br>\ndefault: <br>\n/* <br>\n* This is usually the most complex section of <br>\n* code. You really do whatever you want as long <br>\n* as you follow RFC 3820. In the example we use <br>\n* here, the simplest thing to do is to build <br>\n* another, temporary bit array and fill it with <br>\n* the rights granted by the current proxy <br>\n* certificate, then use it as a mask on the <br>\n* accumulated rights bit array, and voila, you <br>\n* now have a new accumulated rights bit array. <br>\n*/ <br>\n{ <br>\nint i; <br>\nYOUR_RIGHTS tmp_rights; <br>\nmemset(tmp_rights.rights, 0, <br>\nsizeof(tmp_rights.rights)); <br>\n/* <br>\n* process_rights() is supposed to be a <br>\n* procedure that takes a string and its <br>\n* length, interprets it and sets the bits <br>\n* in the YOUR_RIGHTS pointed at by the <br>\n* third argument. <br>\n*/ <br>\nprocess_rights((char *)\npci-&gt;proxyPolicy-&gt;policy-&gt;data, <br>\npci-&gt;proxyPolicy-&gt;policy-&gt;length, <br>\n&amp;tmp_rights); <br>\nfor(i = 0; i &lt; total_rights / 8; i++) <br>\nrights-&gt;rights[i] &amp;= tmp_rights.rights[i]; <br>\n} <br>\nbreak; <br>\n} <br>\nPROXY_CERT_INFO_EXTENSION_free(pci); <br>\n} else if (!(X509_get_extension_flags(xs) &amp; EXFLAG_CA))\n{ <br>\n/* We have an EE certificate, let's use it to set default!\n*/ <br>\nYOUR_RIGHTS *rights = <br>\n(YOUR_RIGHTS *)X509_STORE_CTX_get_ex_data(ctx, <br>\nget_proxy_auth_ex_data_idx(ctx)); <br>\n/* <br>\n* The following procedure finds out what rights the <br>\n* owner of the current certificate has, and sets them <br>\n* in the YOUR_RIGHTS structure pointed at by the <br>\n* second argument. <br>\n*/ <br>\nset_default_rights(xs, rights); <br>\n} <br>\n} <br>\nreturn ok; <br>\n} <br>\nstatic int my_X509_verify_cert(X509_STORE_CTX *ctx, <br>\nYOUR_RIGHTS *needed_rights) <br>\n{ <br>\nint ok; <br>\nint (*save_verify_cb)(int ok,X509_STORE_CTX *ctx) = <br>\nX509_STORE_CTX_get_verify_cb(ctx); <br>\nYOUR_RIGHTS rights; <br>\nX509_STORE_CTX_set_verify_cb(ctx, verify_callback); <br>\nX509_STORE_CTX_set_ex_data(ctx,\nget_proxy_auth_ex_data_idx(ctx), <br>\n&amp;rights); <br>\nX509_STORE_CTX_set_flags(ctx,\nX509_V_FLAG_ALLOW_PROXY_CERTS); <br>\nok = X509_verify_cert(ctx); <br>\nif (ok == 1) { <br>\nok = check_needed_rights(rights, needed_rights); <br>\n} <br>\nX509_STORE_CTX_set_verify_cb(ctx, save_verify_cb); <br>\nreturn ok; <br>\n}\n\nIf you use\n<small>SSL</small> or <small>TLS,</small> you can easily set\nup a callback to have the certificates checked properly,\nusing the code above:\n\n\nSSL_CTX_set_cert_verify_callback(s_ctx,\nmy_X509_verify_cert, <br>\n&amp;needed_rights);\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\nTo this date,\nit seems that proxy certificates have only been used in\nenvironments that are aware of them, and no one seems to\nhave investigated how they can be used or misused outside of\nsuch an environment.\n\nFor that\nreason, OpenSSL requires that applications aware of proxy\ncertificates must also make that explicit.\n\n\n<b>subjectAltName</b>\nand <b>issuerAltName</b> are forbidden in proxy\ncertificates, and this is enforced in OpenSSL. The subject\nmust be the same as the issuer, with one commonName added\non.\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/3/X509_STORE_CTX_set_flags\">X509_STORE_CTX_set_flags(3)</a>,\n<a href=\"https://man.page/3/X509_STORE_CTX_set_verify_cb\">X509_STORE_CTX_set_verify_cb(3)</a>,\n<a href=\"https://man.page/3/X509_VERIFY_PARAM_set_flags\">X509_VERIFY_PARAM_set_flags(3)</a>,\n<a href=\"https://man.page/3/SSL_CTX_set_cert_verify_callback\">SSL_CTX_set_cert_verify_callback(3)</a>,\n<a href=\"https://man.page/1/openssl-req\">openssl-req(1)</a>, <a href=\"https://man.page/1/openssl-x509\">openssl-x509(1)</a>, <small>RFC\n3820</small> &lt;https://tools.ietf.org/html/rfc3820&gt;\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\nCopyright\n2019-2021 The OpenSSL Project Authors. All Rights\nReserved.\n\nLicensed under\nthe Apache License 2.0 (the &quot;License&quot;). You may\nnot use this file except in compliance with the License. You\ncan obtain a copy in the file <small>LICENSE</small> in the\nsource distribution or at\n&lt;https://www.openssl.org/source/license.html&gt;.","body":"\n\n<h1 align=\"center\">PROXY-CERTIFICATES</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">proxy-certificates\n- Proxy certificates in OpenSSL</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Proxy\ncertificates are defined in <small>RFC 3820.</small> They\nare used to extend rights to some other entity (a computer\nprocess, typically, or sometimes to the user itself). This\nallows the entity to perform operations on behalf of the\nowner of the <small>EE</small> (End Entity) certificate.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nrequirements for a valid proxy certificate are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They are issued by an End Entity, either a normal\n<small>EE</small> certificate, or another proxy\ncertificate.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They must not have the <b>subjectAltName</b> or\n<b>issuerAltName</b> extensions.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They must have the <b>proxyCertInfo</b> extension.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>They must have the subject of their issuer, with one\n<b>commonName</b> added.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Enabling\nproxy certificate verification</b> <br>\nOpenSSL expects applications that want to use proxy\ncertificates to be specially aware of them, and make that\nexplicit. This is done by setting an X509 verification\nflag:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">X509_STORE_CTX_set_flags(ctx,\nX509_V_FLAG_ALLOW_PROXY_CERTS);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">X509_VERIFY_PARAM_set_flags(param,\nX509_V_FLAG_ALLOW_PROXY_CERTS);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See &quot;\n<small>NOTES&quot;</small> for a discussion on this\nrequirement.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Creating\nproxy certificates</b> <br>\nCreating proxy certificates can be done using the\n<a href=\"https://man.page/1/openssl-x509\">openssl-x509(1)</a> command, with some extra\nextensions:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[ proxy ] <br>\n# A proxy certificate MUST NEVER be a CA certificate. <br>\nbasicConstraints = CA:FALSE <br>\n# Usual authority key ID <br>\nauthorityKeyIdentifier = keyid,issuer:always <br>\n# The extension which marks this certificate as a proxy <br>\nproxyCertInfo =\ncritical,language:id-ppl-anyLanguage,pathlen:1,policy:text:AB</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It&rsquo;s also\npossible to specify the proxy extension in a separate\nsection:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">proxyCertInfo =\ncritical,@proxy_ext <br>\n[ proxy_ext ] <br>\nlanguage = id-ppl-anyLanguage <br>\npathlen = 0 <br>\npolicy = text:BC</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The policy\nvalue has a specific syntax, <i>syntag</i>:<i>string</i>,\nwhere the <i>syntag</i> determines what will be done with\nthe string. The following <i>syntag</i>s are recognised:\n<b><br>\ntext</b></p>\n\n<p style=\"margin-left:17%;\">indicates that the string is a\nbyte sequence, without any encoding:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">policy=text:raeksmoergaas</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>hex</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>indicates the string is encoded hexadecimal encoded\nbinary data, with colons between each byte (every second hex\ndigit):</p> </td></tr>\n</table>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">policy=hex:72:E4:6B:73:6D:F6:72:67:E5:73</p>\n\n<p style=\"margin-left:11%;\"><b>file</b></p>\n\n<p style=\"margin-left:17%;\">indicates that the text of the\npolicy should be taken from a file. The string is then a\nfilename. This is useful for policies that are more than a\nfew lines, such as <small>XML</small> or other markup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nproxy policy value is what determines the rights granted to\nthe process during the proxy certificate, and it is up to\nthe application to interpret and combine these\npolicies.&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With a proxy\nextension, creating a proxy certificate is a matter of two\ncommands:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">openssl req\n-new -config proxy.cnf \\ <br>\n-out proxy.req -keyout proxy.key \\ <br>\n-subj &quot;/DC=org/DC=openssl/DC=users/CN=proxy&quot; <br>\nopenssl x509 -req -CAcreateserial -in proxy.req -out\nproxy.crt \\ <br>\n-CA user.crt -CAkey user.key -days 7 \\ <br>\n-extfile proxy.cnf -extensions proxy</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can also\ncreate a proxy certificate using another proxy certificate\nas issuer. Note that this example uses a different\nconfiguration section for the proxy extensions:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">openssl req\n-new -config proxy.cnf \\ <br>\n-out proxy2.req -keyout proxy2.key \\ <br>\n-subj &quot;/DC=org/DC=openssl/DC=users/CN=proxy/CN=proxy\n2&quot; <br>\nopenssl x509 -req -CAcreateserial -in proxy2.req -out\nproxy2.crt \\ <br>\n-CA proxy.crt -CAkey proxy.key -days 7 \\ <br>\n-extfile proxy.cnf -extensions proxy_2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Using proxy\ncerts in applications</b> <br>\nTo interpret proxy policies, the application would normally\nstart with some default rights (perhaps none at all), then\ncompute the resulting rights by checking the rights against\nthe chain of proxy certificates, user certificate and\n<small>CA</small> certificates.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The complicated\npart is figuring out how to pass data between your\napplication and the certificate validation procedure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\ningredients are needed for such processing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>a callback function that will be called for every\ncertificate being validated. The callback is called several\ntimes for each certificate, so you must be careful to do the\nproxy policy interpretation at the right time. You also need\nto fill in the defaults when the <small>EE</small>\ncertificate is checked.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>a data structure that is shared between your application\ncode and the callback.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>a wrapper function that sets it all up.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>an ex_data index function that creates an index into the\ngeneric ex_data store that is attached to an X509 validation\ncontext.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nskeleton code can be used as a starting point:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;string.h&gt; <br>\n#include &lt;netdb.h&gt; <br>\n#include &lt;openssl/x509.h&gt; <br>\n#include &lt;openssl/x509v3.h&gt; <br>\n#define total_rights 25 <br>\n/* <br>\n* In this example, I will use a view of granted rights as a\nbit <br>\n* array, one bit for each possible right. <br>\n*/ <br>\ntypedef struct your_rights { <br>\nunsigned char rights[(total_rights + 7) / 8]; <br>\n} YOUR_RIGHTS; <br>\n/* <br>\n* The following procedure will create an index for the\nex_data <br>\n* store in the X509 validation context the first time it's\n<br>\n* called. Subsequent calls will return the same index. <br>\n*/ <br>\nstatic int get_proxy_auth_ex_data_idx(X509_STORE_CTX *ctx)\n<br>\n{ <br>\nstatic volatile int idx = -1; <br>\nif (idx &lt; 0) { <br>\nX509_STORE_lock(X509_STORE_CTX_get0_store(ctx)); <br>\nif (idx &lt; 0) { <br>\nidx = X509_STORE_CTX_get_ex_new_index(0, <br>\n&quot;for verify callback&quot;, <br>\nNULL,NULL,NULL); <br>\n} <br>\nX509_STORE_unlock(X509_STORE_CTX_get0_store(ctx)); <br>\n} <br>\nreturn idx; <br>\n} <br>\n/* Callback to be given to the X509 validation procedure. */\n<br>\nstatic int verify_callback(int ok, X509_STORE_CTX *ctx) <br>\n{ <br>\nif (ok == 1) { <br>\n/* <br>\n* It's REALLY important you keep the proxy policy check <br>\n* within this section. It's important to know that when <br>\n* ok is 1, the certificates are checked from top to <br>\n* bottom. You get the CA root first, followed by the <br>\n* possible chain of intermediate CAs, followed by the EE\n<br>\n* certificate, followed by the possible proxy <br>\n* certificates. <br>\n*/ <br>\nX509 *xs = X509_STORE_CTX_get_current_cert(ctx); <br>\nif (X509_get_extension_flags(xs) &amp; EXFLAG_PROXY) { <br>\nYOUR_RIGHTS *rights = <br>\n(YOUR_RIGHTS *)X509_STORE_CTX_get_ex_data(ctx, <br>\nget_proxy_auth_ex_data_idx(ctx)); <br>\nPROXY_CERT_INFO_EXTENSION *pci = <br>\nX509_get_ext_d2i(xs, NID_proxyCertInfo, NULL, NULL); <br>\nswitch (OBJ_obj2nid(pci-&gt;proxyPolicy-&gt;policyLanguage))\n{ <br>\ncase NID_Independent: <br>\n/* <br>\n* Do whatever you need to grant explicit rights <br>\n* to this particular proxy certificate, usually <br>\n* by pulling them from some database. If there <br>\n* are none to be found, clear all rights (making <br>\n* this and any subsequent proxy certificate void <br>\n* of any rights). <br>\n*/ <br>\nmemset(rights-&gt;rights, 0, sizeof(rights-&gt;rights));\n<br>\nbreak; <br>\ncase NID_id_ppl_inheritAll: <br>\n/* <br>\n* This is basically a NOP, we simply let the <br>\n* current rights stand as they are. <br>\n*/ <br>\nbreak; <br>\ndefault: <br>\n/* <br>\n* This is usually the most complex section of <br>\n* code. You really do whatever you want as long <br>\n* as you follow RFC 3820. In the example we use <br>\n* here, the simplest thing to do is to build <br>\n* another, temporary bit array and fill it with <br>\n* the rights granted by the current proxy <br>\n* certificate, then use it as a mask on the <br>\n* accumulated rights bit array, and voila, you <br>\n* now have a new accumulated rights bit array. <br>\n*/ <br>\n{ <br>\nint i; <br>\nYOUR_RIGHTS tmp_rights; <br>\nmemset(tmp_rights.rights, 0, <br>\nsizeof(tmp_rights.rights)); <br>\n/* <br>\n* process_rights() is supposed to be a <br>\n* procedure that takes a string and its <br>\n* length, interprets it and sets the bits <br>\n* in the YOUR_RIGHTS pointed at by the <br>\n* third argument. <br>\n*/ <br>\nprocess_rights((char *)\npci-&gt;proxyPolicy-&gt;policy-&gt;data, <br>\npci-&gt;proxyPolicy-&gt;policy-&gt;length, <br>\n&amp;tmp_rights); <br>\nfor(i = 0; i &lt; total_rights / 8; i++) <br>\nrights-&gt;rights[i] &amp;= tmp_rights.rights[i]; <br>\n} <br>\nbreak; <br>\n} <br>\nPROXY_CERT_INFO_EXTENSION_free(pci); <br>\n} else if (!(X509_get_extension_flags(xs) &amp; EXFLAG_CA))\n{ <br>\n/* We have an EE certificate, let's use it to set default!\n*/ <br>\nYOUR_RIGHTS *rights = <br>\n(YOUR_RIGHTS *)X509_STORE_CTX_get_ex_data(ctx, <br>\nget_proxy_auth_ex_data_idx(ctx)); <br>\n/* <br>\n* The following procedure finds out what rights the <br>\n* owner of the current certificate has, and sets them <br>\n* in the YOUR_RIGHTS structure pointed at by the <br>\n* second argument. <br>\n*/ <br>\nset_default_rights(xs, rights); <br>\n} <br>\n} <br>\nreturn ok; <br>\n} <br>\nstatic int my_X509_verify_cert(X509_STORE_CTX *ctx, <br>\nYOUR_RIGHTS *needed_rights) <br>\n{ <br>\nint ok; <br>\nint (*save_verify_cb)(int ok,X509_STORE_CTX *ctx) = <br>\nX509_STORE_CTX_get_verify_cb(ctx); <br>\nYOUR_RIGHTS rights; <br>\nX509_STORE_CTX_set_verify_cb(ctx, verify_callback); <br>\nX509_STORE_CTX_set_ex_data(ctx,\nget_proxy_auth_ex_data_idx(ctx), <br>\n&amp;rights); <br>\nX509_STORE_CTX_set_flags(ctx,\nX509_V_FLAG_ALLOW_PROXY_CERTS); <br>\nok = X509_verify_cert(ctx); <br>\nif (ok == 1) { <br>\nok = check_needed_rights(rights, needed_rights); <br>\n} <br>\nX509_STORE_CTX_set_verify_cb(ctx, save_verify_cb); <br>\nreturn ok; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you use\n<small>SSL</small> or <small>TLS,</small> you can easily set\nup a callback to have the certificates checked properly,\nusing the code above:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SSL_CTX_set_cert_verify_callback(s_ctx,\nmy_X509_verify_cert, <br>\n&amp;needed_rights);</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">To this date,\nit seems that proxy certificates have only been used in\nenvironments that are aware of them, and no one seems to\nhave investigated how they can be used or misused outside of\nsuch an environment.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For that\nreason, OpenSSL requires that applications aware of proxy\ncertificates must also make that explicit.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>subjectAltName</b>\nand <b>issuerAltName</b> are forbidden in proxy\ncertificates, and this is enforced in OpenSSL. The subject\nmust be the same as the issuer, with one commonName added\non.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/X509_STORE_CTX_set_flags\">X509_STORE_CTX_set_flags(3)</a>,\n<a href=\"https://man.page/3/X509_STORE_CTX_set_verify_cb\">X509_STORE_CTX_set_verify_cb(3)</a>,\n<a href=\"https://man.page/3/X509_VERIFY_PARAM_set_flags\">X509_VERIFY_PARAM_set_flags(3)</a>,\n<a href=\"https://man.page/3/SSL_CTX_set_cert_verify_callback\">SSL_CTX_set_cert_verify_callback(3)</a>,\n<a href=\"https://man.page/1/openssl-req\">openssl-req(1)</a>, <a href=\"https://man.page/1/openssl-x509\">openssl-x509(1)</a>, <small>RFC\n3820</small> &lt;https://tools.ietf.org/html/rfc3820&gt;</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n2019-2021 The OpenSSL Project Authors. All Rights\nReserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nthe Apache License 2.0 (the &quot;License&quot;). You may\nnot use this file except in compliance with the License. You\ncan obtain a copy in the file <small>LICENSE</small> in the\nsource distribution or at\n&lt;https://www.openssl.org/source/license.html&gt;.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":7}