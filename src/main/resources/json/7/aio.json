{"name":"aio","description":"aio - POSIX\nasynchronous I/O overview\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nThe POSIX\nasynchronous I/O (AIO) interface allows applications to\ninitiate one or more I/O operations that are performed\nasynchronously (i.e., in the background). The application\ncan elect to be notified of completion of the I/O operation\nin a variety of ways: by delivery of a signal, by\ninstantiation of a thread, or no notification at all.\n\nThe POSIX AIO\ninterface consists of the following functions: <b><br>\naio_read</b>(3)\n\n<p style=\"margin-left:22%;\">Enqueue a read request. This is\nthe asynchronous analog of <a href=\"https://man.page/2/read\">read(2)</a>.\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_write\">aio_write(3)</a>\n\n<p style=\"margin-left:22%;\">Enqueue a write request. This\nis the asynchronous analog of <a href=\"https://man.page/2/write\">write(2)</a>.\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_fsync\">aio_fsync(3)</a>\n\n<p style=\"margin-left:22%;\">Enqueue a sync request for the\nI/O operations on a file descriptor. This is the\nasynchronous analog of <a href=\"https://man.page/2/fsync\">fsync(2)</a> and\n<a href=\"https://man.page/2/fdatasync\">fdatasync(2)</a>.\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_error\">aio_error(3)</a>\n\n<p style=\"margin-left:22%;\">Obtain the error status of an\nenqueued I/O request.\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_return\">aio_return(3)</a>\n\n<p style=\"margin-left:22%;\">Obtain the return status of a\ncompleted I/O request.\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_suspend\">aio_suspend(3)</a>\n\n<p style=\"margin-left:22%;\">Suspend the caller until one or\nmore of a specified set of I/O requests completes.\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_cancel\">aio_cancel(3)</a>\n\n<p style=\"margin-left:22%;\">Attempt to cancel outstanding\nI/O requests on a specified file descriptor.\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a>\n\n<p style=\"margin-left:22%;\">Enqueue multiple I/O requests\nusing a single function call.\n\nThe\n<i>aiocb</i> (&quot;asynchronous I/O control block&quot;)\nstructure defines parameters that control an I/O operation.\nAn argument of this type is employed with all of the\nfunctions listed above. This structure has the following\nform:\n\n<p style=\"margin-left:17%; margin-top: 1em\">#include\n&lt;aiocb.h&gt;\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct aiocb {\n<br>\n/* The order of these fields is implementation-dependent\n*/\n\n<p style=\"margin-left:17%; margin-top: 1em\">int aio_fildes;\n/* File descriptor */ <br>\noff_t aio_offset; /* File offset */ <br>\nvolatile void *aio_buf; /* Location of buffer */ <br>\nsize_t aio_nbytes; /* Length of transfer */ <br>\nint aio_reqprio; /* Request priority */ <br>\nstruct sigevent aio_sigevent; /* Notification method */ <br>\nint aio_lio_opcode; /* Operation to be performed; <br>\nlio_listio() only */\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Various\nimplementation-internal fields not shown */ <br>\n};\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Operation\ncodes for 'aio_lio_opcode': */\n\n<p style=\"margin-left:17%; margin-top: 1em\">enum {\nLIO_READ, LIO_WRITE, LIO_NOP };\n\nThe fields of\nthis structure are as follows: <i><br>\naio_fildes</i>\n\n<p style=\"margin-left:22%;\">The file descriptor on which\nthe I/O operation is to be performed.\n\n<p style=\"margin-left:11%;\"><i>aio_offset</i>\n\n<p style=\"margin-left:22%;\">This is the file offset at\nwhich the I/O operation is to be performed.\n\n<p style=\"margin-left:11%;\"><i>aio_buf</i>\n\n<p style=\"margin-left:22%;\">This is the buffer used to\ntransfer data for a read or write operation.\n\n<p style=\"margin-left:11%;\"><i>aio_nbytes</i>\n\n<p style=\"margin-left:22%;\">This is the size of the buffer\npointed to by <i>aio_buf</i>.\n\n<p style=\"margin-left:11%;\"><i>aio_reqprio</i>\n\n<p style=\"margin-left:22%;\">This field specifies a value\nthat is subtracted from the calling thread&rsquo;s real-time\npriority in order to determine the priority for execution of\nthis I/O request (see <a href=\"https://man.page/3/pthread_setschedparam\">pthread_setschedparam(3)</a>). The\nspecified value must be between 0 and the value returned by\n<i>sysconf(_SC_AIO_PRIO_DELTA_MAX)</i>. This field is\nignored for file synchronization operations.\n\n<p style=\"margin-left:11%;\"><i>aio_sigevent</i>\n\n<p style=\"margin-left:22%;\">This field is a structure that\nspecifies how the caller is to be notified when the\nasynchronous I/O operation completes. Possible values for\n<i>aio_sigevent.sigev_notify</i> are <b>SIGEV_NONE</b>,\n<b>SIGEV_SIGNAL</b>, and <b>SIGEV_THREAD</b>. See\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for further details.\n\n<p style=\"margin-left:11%;\"><i>aio_lio_opcode</i>\n\n<p style=\"margin-left:22%;\">The type of operation to be\nperformed; used only for <a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a>.\n\nIn addition to\nthe standard functions listed above, the GNU C library\nprovides the following extension to the POSIX AIO API:\n<b><br>\naio_init</b>(3)\n\n<p style=\"margin-left:22%;\">Set parameters for tuning the\nbehavior of the glibc POSIX AIO implementation.\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The <i>aio_reqprio</i> field of\nthe <i>aiocb</i> structure was less than 0, or was greater\nthan the limit returned by the call\n<i>sysconf(_SC_AIO_PRIO_DELTA_MAX)</i>. </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\nThe POSIX AIO\ninterfaces are provided by glibc since version 2.1.\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\nPOSIX.1-2001,\nPOSIX.1-2008.\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\nIt is a good\nidea to zero out the control block buffer before use (see\n<a href=\"https://man.page/3/memset\">memset(3)</a>). The control block buffer and the buffer\npointed to by <i>aio_buf</i> must not be changed while the\nI/O operation is in progress. These buffers must remain\nvalid until the I/O operation completes.\n\nSimultaneous\nasynchronous read or write operations using the same\n<i>aiocb</i> structure yield undefined results.\n\nThe current\nLinux POSIX AIO implementation is provided in user space by\nglibc. This has a number of limitations, most notably that\nmaintaining multiple threads to perform I/O operations is\nexpensive and scales poorly. Work has been in progress for\nsome time on a kernel state-machine-based implementation of\nasynchronous I/O (see <a href=\"https://man.page/2/io_submit\">io_submit(2)</a>,\n<a href=\"https://man.page/2/io_setup\">io_setup(2)</a>, <a href=\"https://man.page/2/io_cancel\">io_cancel(2)</a>,\n<a href=\"https://man.page/2/io_destroy\">io_destroy(2)</a>, <a href=\"https://man.page/2/io_getevents\">io_getevents(2)</a>), but this\nimplementation hasn&rsquo;t yet matured to the point where\nthe POSIX AIO implementation can be completely reimplemented\nusing the kernel system calls.\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\nThe program\nbelow opens each of the files named in its command-line\narguments and queues a request on the resulting file\ndescriptor using <a href=\"https://man.page/3/aio_read\">aio_read(3)</a>. The program then loops,\nperiodically monitoring each of the I/O operations that is\nstill in progress using <a href=\"https://man.page/3/aio_error\">aio_error(3)</a>. Each of the I/O\nrequests is set up to provide notification by delivery of a\nsignal. After all I/O requests have completed, the program\nretrieves their status using <a href=\"https://man.page/3/aio_return\">aio_return(3)</a>.\n\nThe\n<b>SIGQUIT</b> signal (generated by typing control-\\) causes\nthe program to request cancellation of each of the\noutstanding requests using <a href=\"https://man.page/3/aio_cancel\">aio_cancel(3)</a>.\n\nHere is an\nexample of what we might see when running this program. In\nthis example, the program queues two requests to standard\ninput, and these are satisfied by two lines of input\ncontaining &quot;abc&quot; and &quot;x&quot;.\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out\n/dev/stdin /dev/stdin</b> <br>\nopened /dev/stdin on descriptor 3 <br>\nopened /dev/stdin on descriptor 4 <br>\naio_error(): <br>\nfor request 0 (descriptor 3): In progress <br>\nfor request 1 (descriptor 4): In progress <b><br>\nabc</b> <br>\nI/O completion signal received <br>\naio_error(): <br>\nfor request 0 (descriptor 3): I/O succeeded <br>\nfor request 1 (descriptor 4): In progress <br>\naio_error(): <br>\nfor request 1 (descriptor 4): In progress <b><br>\nx</b> <br>\nI/O completion signal received <br>\naio_error(): <br>\nfor request 1 (descriptor 4): I/O succeeded <br>\nAll I/O requests completed <br>\naio_return(): <br>\nfor request 0 (descriptor 3): 4 <br>\nfor request 1 (descriptor 4): 2\n\n<b>Program\nsource</b> <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;aio.h&gt; <br>\n#include &lt;signal.h&gt;\n\n#define\nBUF_SIZE 20 /* Size of buffers for read operations */\n\n#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while\n(0)\n\nstruct\nioRequest { /* Application-defined structure for tracking\n<br>\nI/O requests */ <br>\nint reqNum; <br>\nint status; <br>\nstruct aiocb *aiocbp; <br>\n};\n\nstatic volatile\nsig_atomic_t gotSIGQUIT = 0; <br>\n/* On delivery of SIGQUIT, we attempt to <br>\ncancel all outstanding I/O requests */\n\nstatic void /*\nHandler for SIGQUIT */ <br>\nquitHandler(int sig) <br>\n{ <br>\ngotSIGQUIT = 1; <br>\n}\n\n#define\nIO_SIGNAL SIGUSR1 /* Signal used to notify I/O completion\n*/\n\nstatic void /*\nHandler for I/O completion signal */ <br>\naioSigHandler(int sig, siginfo_t *si, void *ucontext) <br>\n{ <br>\nif (si-&gt;si_code == SI_ASYNCIO) { <br>\nwrite(STDOUT_FILENO, &quot;I/O completion signal\nreceived\\n&quot;, 31);\n\n/* The\ncorresponding ioRequest structure would be available as <br>\nstruct ioRequest *ioReq = si-&gt;si_value.sival_ptr; <br>\nand the file descriptor would then be available via <br>\nioReq-&gt;aiocbp-&gt;aio_fildes */ <br>\n} <br>\n}\n\nint <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct sigaction sa; <br>\nint s; <br>\nint numReqs; /* Total number of queued I/O requests */ <br>\nint openReqs; /* Number of I/O requests still in progress\n*/\n\nif (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s &lt;pathname&gt;\n&lt;pathname&gt;...\\n&quot;, <br>\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}\n\nnumReqs = argc\n- 1;\n\n/* Allocate our\narrays */\n\nstruct\nioRequest *ioList = calloc(numReqs, sizeof(*ioList)); <br>\nif (ioList == NULL) <br>\nerrExit(&quot;calloc&quot;);\n\nstruct aiocb\n*aiocbList = calloc(numReqs, sizeof(*aiocbList)); <br>\nif (aiocbList == NULL) <br>\nerrExit(&quot;calloc&quot;);\n\n/* Establish\nhandlers for SIGQUIT and the I/O completion signal */\n\nsa.sa_flags =\nSA_RESTART; <br>\nsigemptyset(&amp;sa.sa_mask);\n\nsa.sa_handler =\nquitHandler; <br>\nif (sigaction(SIGQUIT, &amp;sa, NULL) == -1) <br>\nerrExit(&quot;sigaction&quot;);\n\nsa.sa_flags =\nSA_RESTART | SA_SIGINFO; <br>\nsa.sa_sigaction = aioSigHandler; <br>\nif (sigaction(IO_SIGNAL, &amp;sa, NULL) == -1) <br>\nerrExit(&quot;sigaction&quot;);\n\n/* Open each\nfile specified on the command line, and queue <br>\na read request on the resulting file descriptor */\n\nfor (int j = 0;\nj &lt; numReqs; j++) { <br>\nioList[j].reqNum = j; <br>\nioList[j].status = EINPROGRESS; <br>\nioList[j].aiocbp = &amp;aiocbList[j];\n\n\nioList[j].aiocbp-&gt;aio_fildes\n= open(argv[j + 1], O_RDONLY); <br>\nif (ioList[j].aiocbp-&gt;aio_fildes == -1) <br>\nerrExit(&quot;open&quot;); <br>\nprintf(&quot;opened %s on descriptor %d\\n&quot;, argv[j +\n1], <br>\nioList[j].aiocbp-&gt;aio_fildes);\n\n\nioList[j].aiocbp-&gt;aio_buf\n= malloc(BUF_SIZE); <br>\nif (ioList[j].aiocbp-&gt;aio_buf == NULL) <br>\nerrExit(&quot;malloc&quot;);\n\n\nioList[j].aiocbp-&gt;aio_nbytes\n= BUF_SIZE; <br>\nioList[j].aiocbp-&gt;aio_reqprio = 0; <br>\nioList[j].aiocbp-&gt;aio_offset = 0; <br>\nioList[j].aiocbp-&gt;aio_sigevent.sigev_notify =\nSIGEV_SIGNAL; <br>\nioList[j].aiocbp-&gt;aio_sigevent.sigev_signo = IO_SIGNAL;\n<br>\nioList[j].aiocbp-&gt;aio_sigevent.sigev_value.sival_ptr =\n<br>\n&amp;ioList[j];\n\ns =\naio_read(ioList[j].aiocbp); <br>\nif (s == -1) <br>\nerrExit(&quot;aio_read&quot;); <br>\n}\n\nopenReqs =\nnumReqs;\n\n/* Loop,\nmonitoring status of I/O requests */\n\nwhile (openReqs\n&gt; 0) { <br>\nsleep(3); /* Delay between each monitoring step */\n\nif (gotSIGQUIT)\n{\n\n/* On receipt\nof SIGQUIT, attempt to cancel each of the <br>\noutstanding I/O requests, and display status returned <br>\nfrom the cancellation requests */\n\n\nprintf(&quot;got\nSIGQUIT; canceling I/O requests: \\n&quot;);\n\nfor (int j = 0;\nj &lt; numReqs; j++) { <br>\nif (ioList[j].status == EINPROGRESS) { <br>\nprintf(&quot; Request %d on descriptor %d:&quot;, j, <br>\nioList[j].aiocbp-&gt;aio_fildes); <br>\ns = aio_cancel(ioList[j].aiocbp-&gt;aio_fildes, <br>\nioList[j].aiocbp); <br>\nif (s == AIO_CANCELED) <br>\nprintf(&quot;I/O canceled\\n&quot;); <br>\nelse if (s == AIO_NOTCANCELED) <br>\nprintf(&quot;I/O not canceled\\n&quot;); <br>\nelse if (s == AIO_ALLDONE) <br>\nprintf(&quot;I/O all done\\n&quot;); <br>\nelse <br>\nperror(&quot;aio_cancel&quot;); <br>\n} <br>\n}\n\ngotSIGQUIT = 0;\n<br>\n}\n\n/* Check the\nstatus of each I/O request that is still <br>\nin progress */\n\n\nprintf(&quot;aio_error():\\n&quot;);\n<br>\nfor (int j = 0; j &lt; numReqs; j++) { <br>\nif (ioList[j].status == EINPROGRESS) { <br>\nprintf(&quot; for request %d (descriptor %d): &quot;, <br>\nj, ioList[j].aiocbp-&gt;aio_fildes); <br>\nioList[j].status = aio_error(ioList[j].aiocbp);\n\nswitch\n(ioList[j].status) { <br>\ncase 0: <br>\nprintf(&quot;I/O succeeded\\n&quot;); <br>\nbreak; <br>\ncase EINPROGRESS: <br>\nprintf(&quot;In progress\\n&quot;); <br>\nbreak; <br>\ncase ECANCELED: <br>\nprintf(&quot;Canceled\\n&quot;); <br>\nbreak; <br>\ndefault: <br>\nperror(&quot;aio_error&quot;); <br>\nbreak; <br>\n}\n\nif\n(ioList[j].status != EINPROGRESS) <br>\nopenReqs--; <br>\n} <br>\n} <br>\n}\n\n\nprintf(&quot;All\nI/O requests completed\\n&quot;);\n\n/* Check status\nreturn of all I/O requests */\n\n\nprintf(&quot;aio_return():\\n&quot;);\n<br>\nfor (int j = 0; j &lt; numReqs; j++) { <br>\nssize_t s;\n\ns =\naio_return(ioList[j].aiocbp); <br>\nprintf(&quot; for request %d (descriptor %d): %zd\\n&quot;,\n<br>\nj, ioList[j].aiocbp-&gt;aio_fildes, s); <br>\n}\n\n\nexit(EXIT_SUCCESS);\n<br>\n}\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/2/io_cancel\">io_cancel(2)</a>,\n<a href=\"https://man.page/2/io_destroy\">io_destroy(2)</a>, <a href=\"https://man.page/2/io_getevents\">io_getevents(2)</a>,\n<a href=\"https://man.page/2/io_setup\">io_setup(2)</a>, <a href=\"https://man.page/2/io_submit\">io_submit(2)</a>,\n<a href=\"https://man.page/3/aio_cancel\">aio_cancel(3)</a>, <a href=\"https://man.page/3/aio_error\">aio_error(3)</a>,\n<a href=\"https://man.page/3/aio_init\">aio_init(3)</a>, <a href=\"https://man.page/3/aio_read\">aio_read(3)</a>,\n<a href=\"https://man.page/3/aio_return\">aio_return(3)</a>, <a href=\"https://man.page/3/aio_write\">aio_write(3)</a>,\n<a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a>\n\n\n&quot;Asynchronous\nI/O Support in Linux 2.5&quot;, Bhattacharya, Pratt,\nPulavarty, and Morgan, Proceedings of the Linux Symposium,\n2003,\n<a href=\"https://www.kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf\">https://www.kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf</a>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\nThis page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.","body":"\n\n<h1 align=\"center\">AIO</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">aio - POSIX\nasynchronous I/O overview</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The POSIX\nasynchronous I/O (AIO) interface allows applications to\ninitiate one or more I/O operations that are performed\nasynchronously (i.e., in the background). The application\ncan elect to be notified of completion of the I/O operation\nin a variety of ways: by delivery of a signal, by\ninstantiation of a thread, or no notification at all.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The POSIX AIO\ninterface consists of the following functions: <b><br>\naio_read</b>(3)</p>\n\n<p style=\"margin-left:22%;\">Enqueue a read request. This is\nthe asynchronous analog of <a href=\"https://man.page/2/read\">read(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_write\">aio_write(3)</a></p>\n\n<p style=\"margin-left:22%;\">Enqueue a write request. This\nis the asynchronous analog of <a href=\"https://man.page/2/write\">write(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_fsync\">aio_fsync(3)</a></p>\n\n<p style=\"margin-left:22%;\">Enqueue a sync request for the\nI/O operations on a file descriptor. This is the\nasynchronous analog of <a href=\"https://man.page/2/fsync\">fsync(2)</a> and\n<a href=\"https://man.page/2/fdatasync\">fdatasync(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_error\">aio_error(3)</a></p>\n\n<p style=\"margin-left:22%;\">Obtain the error status of an\nenqueued I/O request.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_return\">aio_return(3)</a></p>\n\n<p style=\"margin-left:22%;\">Obtain the return status of a\ncompleted I/O request.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_suspend\">aio_suspend(3)</a></p>\n\n<p style=\"margin-left:22%;\">Suspend the caller until one or\nmore of a specified set of I/O requests completes.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/aio_cancel\">aio_cancel(3)</a></p>\n\n<p style=\"margin-left:22%;\">Attempt to cancel outstanding\nI/O requests on a specified file descriptor.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a></p>\n\n<p style=\"margin-left:22%;\">Enqueue multiple I/O requests\nusing a single function call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>aiocb</i> (&quot;asynchronous I/O control block&quot;)\nstructure defines parameters that control an I/O operation.\nAn argument of this type is employed with all of the\nfunctions listed above. This structure has the following\nform:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#include\n&lt;aiocb.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct aiocb {\n<br>\n/* The order of these fields is implementation-dependent\n*/</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int aio_fildes;\n/* File descriptor */ <br>\noff_t aio_offset; /* File offset */ <br>\nvolatile void *aio_buf; /* Location of buffer */ <br>\nsize_t aio_nbytes; /* Length of transfer */ <br>\nint aio_reqprio; /* Request priority */ <br>\nstruct sigevent aio_sigevent; /* Notification method */ <br>\nint aio_lio_opcode; /* Operation to be performed; <br>\nlio_listio() only */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Various\nimplementation-internal fields not shown */ <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Operation\ncodes for 'aio_lio_opcode': */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">enum {\nLIO_READ, LIO_WRITE, LIO_NOP };</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthis structure are as follows: <i><br>\naio_fildes</i></p>\n\n<p style=\"margin-left:22%;\">The file descriptor on which\nthe I/O operation is to be performed.</p>\n\n<p style=\"margin-left:11%;\"><i>aio_offset</i></p>\n\n<p style=\"margin-left:22%;\">This is the file offset at\nwhich the I/O operation is to be performed.</p>\n\n<p style=\"margin-left:11%;\"><i>aio_buf</i></p>\n\n<p style=\"margin-left:22%;\">This is the buffer used to\ntransfer data for a read or write operation.</p>\n\n<p style=\"margin-left:11%;\"><i>aio_nbytes</i></p>\n\n<p style=\"margin-left:22%;\">This is the size of the buffer\npointed to by <i>aio_buf</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>aio_reqprio</i></p>\n\n<p style=\"margin-left:22%;\">This field specifies a value\nthat is subtracted from the calling thread&rsquo;s real-time\npriority in order to determine the priority for execution of\nthis I/O request (see <a href=\"https://man.page/3/pthread_setschedparam\">pthread_setschedparam(3)</a>). The\nspecified value must be between 0 and the value returned by\n<i>sysconf(_SC_AIO_PRIO_DELTA_MAX)</i>. This field is\nignored for file synchronization operations.</p>\n\n<p style=\"margin-left:11%;\"><i>aio_sigevent</i></p>\n\n<p style=\"margin-left:22%;\">This field is a structure that\nspecifies how the caller is to be notified when the\nasynchronous I/O operation completes. Possible values for\n<i>aio_sigevent.sigev_notify</i> are <b>SIGEV_NONE</b>,\n<b>SIGEV_SIGNAL</b>, and <b>SIGEV_THREAD</b>. See\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for further details.</p>\n\n<p style=\"margin-left:11%;\"><i>aio_lio_opcode</i></p>\n\n<p style=\"margin-left:22%;\">The type of operation to be\nperformed; used only for <a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition to\nthe standard functions listed above, the GNU C library\nprovides the following extension to the POSIX AIO API:\n<b><br>\naio_init</b>(3)</p>\n\n<p style=\"margin-left:22%;\">Set parameters for tuning the\nbehavior of the glibc POSIX AIO implementation.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The <i>aio_reqprio</i> field of\nthe <i>aiocb</i> structure was less than 0, or was greater\nthan the limit returned by the call\n<i>sysconf(_SC_AIO_PRIO_DELTA_MAX)</i>.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The POSIX AIO\ninterfaces are provided by glibc since version 2.1.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is a good\nidea to zero out the control block buffer before use (see\n<a href=\"https://man.page/3/memset\">memset(3)</a>). The control block buffer and the buffer\npointed to by <i>aio_buf</i> must not be changed while the\nI/O operation is in progress. These buffers must remain\nvalid until the I/O operation completes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Simultaneous\nasynchronous read or write operations using the same\n<i>aiocb</i> structure yield undefined results.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The current\nLinux POSIX AIO implementation is provided in user space by\nglibc. This has a number of limitations, most notably that\nmaintaining multiple threads to perform I/O operations is\nexpensive and scales poorly. Work has been in progress for\nsome time on a kernel state-machine-based implementation of\nasynchronous I/O (see <a href=\"https://man.page/2/io_submit\">io_submit(2)</a>,\n<a href=\"https://man.page/2/io_setup\">io_setup(2)</a>, <a href=\"https://man.page/2/io_cancel\">io_cancel(2)</a>,\n<a href=\"https://man.page/2/io_destroy\">io_destroy(2)</a>, <a href=\"https://man.page/2/io_getevents\">io_getevents(2)</a>), but this\nimplementation hasn&rsquo;t yet matured to the point where\nthe POSIX AIO implementation can be completely reimplemented\nusing the kernel system calls.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow opens each of the files named in its command-line\narguments and queues a request on the resulting file\ndescriptor using <a href=\"https://man.page/3/aio_read\">aio_read(3)</a>. The program then loops,\nperiodically monitoring each of the I/O operations that is\nstill in progress using <a href=\"https://man.page/3/aio_error\">aio_error(3)</a>. Each of the I/O\nrequests is set up to provide notification by delivery of a\nsignal. After all I/O requests have completed, the program\nretrieves their status using <a href=\"https://man.page/3/aio_return\">aio_return(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>SIGQUIT</b> signal (generated by typing control-\\) causes\nthe program to request cancellation of each of the\noutstanding requests using <a href=\"https://man.page/3/aio_cancel\">aio_cancel(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is an\nexample of what we might see when running this program. In\nthis example, the program queues two requests to standard\ninput, and these are satisfied by two lines of input\ncontaining &quot;abc&quot; and &quot;x&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out\n/dev/stdin /dev/stdin</b> <br>\nopened /dev/stdin on descriptor 3 <br>\nopened /dev/stdin on descriptor 4 <br>\naio_error(): <br>\nfor request 0 (descriptor 3): In progress <br>\nfor request 1 (descriptor 4): In progress <b><br>\nabc</b> <br>\nI/O completion signal received <br>\naio_error(): <br>\nfor request 0 (descriptor 3): I/O succeeded <br>\nfor request 1 (descriptor 4): In progress <br>\naio_error(): <br>\nfor request 1 (descriptor 4): In progress <b><br>\nx</b> <br>\nI/O completion signal received <br>\naio_error(): <br>\nfor request 1 (descriptor 4): I/O succeeded <br>\nAll I/O requests completed <br>\naio_return(): <br>\nfor request 0 (descriptor 3): 4 <br>\nfor request 1 (descriptor 4): 2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;aio.h&gt; <br>\n#include &lt;signal.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nBUF_SIZE 20 /* Size of buffers for read operations */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while\n(0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct\nioRequest { /* Application-defined structure for tracking\n<br>\nI/O requests */ <br>\nint reqNum; <br>\nint status; <br>\nstruct aiocb *aiocbp; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static volatile\nsig_atomic_t gotSIGQUIT = 0; <br>\n/* On delivery of SIGQUIT, we attempt to <br>\ncancel all outstanding I/O requests */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void /*\nHandler for SIGQUIT */ <br>\nquitHandler(int sig) <br>\n{ <br>\ngotSIGQUIT = 1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nIO_SIGNAL SIGUSR1 /* Signal used to notify I/O completion\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void /*\nHandler for I/O completion signal */ <br>\naioSigHandler(int sig, siginfo_t *si, void *ucontext) <br>\n{ <br>\nif (si-&gt;si_code == SI_ASYNCIO) { <br>\nwrite(STDOUT_FILENO, &quot;I/O completion signal\nreceived\\n&quot;, 31);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* The\ncorresponding ioRequest structure would be available as <br>\nstruct ioRequest *ioReq = si-&gt;si_value.sival_ptr; <br>\nand the file descriptor would then be available via <br>\nioReq-&gt;aiocbp-&gt;aio_fildes */ <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct sigaction sa; <br>\nint s; <br>\nint numReqs; /* Total number of queued I/O requests */ <br>\nint openReqs; /* Number of I/O requests still in progress\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s &lt;pathname&gt;\n&lt;pathname&gt;...\\n&quot;, <br>\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">numReqs = argc\n- 1;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Allocate our\narrays */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct\nioRequest *ioList = calloc(numReqs, sizeof(*ioList)); <br>\nif (ioList == NULL) <br>\nerrExit(&quot;calloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct aiocb\n*aiocbList = calloc(numReqs, sizeof(*aiocbList)); <br>\nif (aiocbList == NULL) <br>\nerrExit(&quot;calloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Establish\nhandlers for SIGQUIT and the I/O completion signal */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sa.sa_flags =\nSA_RESTART; <br>\nsigemptyset(&amp;sa.sa_mask);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sa.sa_handler =\nquitHandler; <br>\nif (sigaction(SIGQUIT, &amp;sa, NULL) == -1) <br>\nerrExit(&quot;sigaction&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sa.sa_flags =\nSA_RESTART | SA_SIGINFO; <br>\nsa.sa_sigaction = aioSigHandler; <br>\nif (sigaction(IO_SIGNAL, &amp;sa, NULL) == -1) <br>\nerrExit(&quot;sigaction&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Open each\nfile specified on the command line, and queue <br>\na read request on the resulting file descriptor */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; numReqs; j++) { <br>\nioList[j].reqNum = j; <br>\nioList[j].status = EINPROGRESS; <br>\nioList[j].aiocbp = &amp;aiocbList[j];</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioList[j].aiocbp-&gt;aio_fildes\n= open(argv[j + 1], O_RDONLY); <br>\nif (ioList[j].aiocbp-&gt;aio_fildes == -1) <br>\nerrExit(&quot;open&quot;); <br>\nprintf(&quot;opened %s on descriptor %d\\n&quot;, argv[j +\n1], <br>\nioList[j].aiocbp-&gt;aio_fildes);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioList[j].aiocbp-&gt;aio_buf\n= malloc(BUF_SIZE); <br>\nif (ioList[j].aiocbp-&gt;aio_buf == NULL) <br>\nerrExit(&quot;malloc&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioList[j].aiocbp-&gt;aio_nbytes\n= BUF_SIZE; <br>\nioList[j].aiocbp-&gt;aio_reqprio = 0; <br>\nioList[j].aiocbp-&gt;aio_offset = 0; <br>\nioList[j].aiocbp-&gt;aio_sigevent.sigev_notify =\nSIGEV_SIGNAL; <br>\nioList[j].aiocbp-&gt;aio_sigevent.sigev_signo = IO_SIGNAL;\n<br>\nioList[j].aiocbp-&gt;aio_sigevent.sigev_value.sival_ptr =\n<br>\n&amp;ioList[j];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\naio_read(ioList[j].aiocbp); <br>\nif (s == -1) <br>\nerrExit(&quot;aio_read&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">openReqs =\nnumReqs;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Loop,\nmonitoring status of I/O requests */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while (openReqs\n&gt; 0) { <br>\nsleep(3); /* Delay between each monitoring step */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (gotSIGQUIT)\n{</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* On receipt\nof SIGQUIT, attempt to cancel each of the <br>\noutstanding I/O requests, and display status returned <br>\nfrom the cancellation requests */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;got\nSIGQUIT; canceling I/O requests: \\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; numReqs; j++) { <br>\nif (ioList[j].status == EINPROGRESS) { <br>\nprintf(&quot; Request %d on descriptor %d:&quot;, j, <br>\nioList[j].aiocbp-&gt;aio_fildes); <br>\ns = aio_cancel(ioList[j].aiocbp-&gt;aio_fildes, <br>\nioList[j].aiocbp); <br>\nif (s == AIO_CANCELED) <br>\nprintf(&quot;I/O canceled\\n&quot;); <br>\nelse if (s == AIO_NOTCANCELED) <br>\nprintf(&quot;I/O not canceled\\n&quot;); <br>\nelse if (s == AIO_ALLDONE) <br>\nprintf(&quot;I/O all done\\n&quot;); <br>\nelse <br>\nperror(&quot;aio_cancel&quot;); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">gotSIGQUIT = 0;\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Check the\nstatus of each I/O request that is still <br>\nin progress */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;aio_error():\\n&quot;);\n<br>\nfor (int j = 0; j &lt; numReqs; j++) { <br>\nif (ioList[j].status == EINPROGRESS) { <br>\nprintf(&quot; for request %d (descriptor %d): &quot;, <br>\nj, ioList[j].aiocbp-&gt;aio_fildes); <br>\nioList[j].status = aio_error(ioList[j].aiocbp);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">switch\n(ioList[j].status) { <br>\ncase 0: <br>\nprintf(&quot;I/O succeeded\\n&quot;); <br>\nbreak; <br>\ncase EINPROGRESS: <br>\nprintf(&quot;In progress\\n&quot;); <br>\nbreak; <br>\ncase ECANCELED: <br>\nprintf(&quot;Canceled\\n&quot;); <br>\nbreak; <br>\ndefault: <br>\nperror(&quot;aio_error&quot;); <br>\nbreak; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(ioList[j].status != EINPROGRESS) <br>\nopenReqs--; <br>\n} <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;All\nI/O requests completed\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Check status\nreturn of all I/O requests */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;aio_return():\\n&quot;);\n<br>\nfor (int j = 0; j &lt; numReqs; j++) { <br>\nssize_t s;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\naio_return(ioList[j].aiocbp); <br>\nprintf(&quot; for request %d (descriptor %d): %zd\\n&quot;,\n<br>\nj, ioList[j].aiocbp-&gt;aio_fildes, s); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/io_cancel\">io_cancel(2)</a>,\n<a href=\"https://man.page/2/io_destroy\">io_destroy(2)</a>, <a href=\"https://man.page/2/io_getevents\">io_getevents(2)</a>,\n<a href=\"https://man.page/2/io_setup\">io_setup(2)</a>, <a href=\"https://man.page/2/io_submit\">io_submit(2)</a>,\n<a href=\"https://man.page/3/aio_cancel\">aio_cancel(3)</a>, <a href=\"https://man.page/3/aio_error\">aio_error(3)</a>,\n<a href=\"https://man.page/3/aio_init\">aio_init(3)</a>, <a href=\"https://man.page/3/aio_read\">aio_read(3)</a>,\n<a href=\"https://man.page/3/aio_return\">aio_return(3)</a>, <a href=\"https://man.page/3/aio_write\">aio_write(3)</a>,\n<a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;Asynchronous\nI/O Support in Linux 2.5&quot;, Bhattacharya, Pratt,\nPulavarty, and Morgan, Proceedings of the Linux Symposium,\n2003,\n<a href=\"https://www.kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf\">https://www.kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}