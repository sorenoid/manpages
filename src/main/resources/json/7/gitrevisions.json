{"name":"gitrevisions","description":"gitrevisions - Specifying revisions and ranges for Git","body":"\n\n<h1 align=\"center\">GITREVISIONS</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">gitrevisions -\nSpecifying revisions and ranges for Git</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">gitrevisions</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many Git\ncommands take revision parameters as arguments. Depending on\nthe command, they denote a specific commit or, for commands\nwhich walk the revision graph (such as <a href=\"https://man.page/1/git-log\">git-log(1)</a>),\nall commits which are reachable from that commit. For\ncommands that walk the revision graph one can also specify a\nrange of revisions explicitly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nsome Git commands (such as <a href=\"https://man.page/1/git-show\">git-show(1)</a> and\n<a href=\"https://man.page/1/git-push\">git-push(1)</a>) can also take revision parameters which\ndenote other objects than commits, e.g. blobs\n(&quot;files&quot;) or trees (&quot;directories of\nfiles&quot;).</p>\n\n<h2>SPECIFYING REVISIONS\n<a name=\"SPECIFYING REVISIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A revision\nparameter <i>&lt;rev&gt;</i> typically, but not necessarily,\nnames a commit object. It uses what is called an <i>extended\nSHA-1</i> syntax. Here are various ways to spell object\nnames. The ones listed near the end of this list name trees\nand blobs contained in a commit.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b><big>Note</big></b>\n<br>\nThis document shows the &quot;raw&quot; syntax as seen by\ngit. The shell and other UIs might require additional\nquoting to protect special characters and to avoid word\nsplitting.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i><big>&lt;sha1&gt;</big></i><big>,\ne.g. <i>dae86e1950b1277e545cee180551750029cfe735</i>,\n<i>dae86e</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>The full SHA-1 object name\n(40-byte hexadecimal string), or a leading substring that is\nunique within the repository. E.g.\ndae86e1950b1277e545cee180551750029cfe735 and dae86e both\nname the same commit object if there is no other object in\nyour repository whose object name starts with\ndae86e.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;describeOutput&gt;</i>,\ne.g. <i>v1.7.4.2-679-g3bee7fb</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>Output from <b>git\ndescribe</b>; i.e. a closest tag, optionally followed by a\ndash and a number of commits, followed by a dash, a\n<i>g</i>, and an abbreviated object name.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;refname&gt;</i>,\ne.g. <i>master</i>, <i>heads/master</i>,\n<i>refs/heads/master</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A symbolic ref name. E.g.\n<i>master</i> typically means the commit object referenced\nby <i>refs/heads/master</i>. If you happen to have both\n<i>heads/master</i> and <i>tags/master</i>, you can\nexplicitly say <i>heads/master</i> to tell Git which one you\nmean. When ambiguous, a <i>&lt;refname&gt;</i> is\ndisambiguated by taking the first match in the following\nrules:</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>1. If\n<i>$GIT_DIR/&lt;refname&gt;</i> exists, that is what you\nmean (this is usually useful only for <b>HEAD</b>,\n<b>FETCH_HEAD</b>, <b>ORIG_HEAD</b>, <b>MERGE_HEAD</b> and\n<b>CHERRY_PICK_HEAD</b>);</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>2.\notherwise, <i>refs/&lt;refname&gt;</i> if it\nexists;</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>3.\notherwise, <i>refs/tags/&lt;refname&gt;</i> if it\nexists;</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>4.\notherwise, <i>refs/heads/&lt;refname&gt;</i> if it\nexists;</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>5.\notherwise, <i>refs/remotes/&lt;refname&gt;</i> if it\nexists;</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>6.\notherwise, <i>refs/remotes/&lt;refname&gt;/HEAD</i> if it\nexists.</big></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big><b>HEAD</b>\nnames the commit on which you based the changes in the\nworking tree. <b>FETCH_HEAD</b> records the branch which you\nfetched from a remote repository with your last <b>git\nfetch</b> invocation. <b>ORIG_HEAD</b> is created by\ncommands that move your <b>HEAD</b> in a drastic way, to\nrecord the position of the <b>HEAD</b> before their\noperation, so that you can easily change the tip of the\nbranch back to the state before you ran them.\n<b>MERGE_HEAD</b> records the commit(s) which you are\nmerging into your branch when you run <b>git merge</b>.\n<b>CHERRY_PICK_HEAD</b> records the commit which you are\ncherry-picking when you run <b>git\ncherry-pick</b>.</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>Note that\nany of the <i>refs/*</i> cases above may come either from\nthe <b>$GIT_DIR/refs</b> directory or from the\n<b>$GIT_DIR/packed-refs</b> file. While the ref name\nencoding is unspecified, UTF-8 is preferred as some output\nprocessing may assume ref names in UTF-8.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>@</i></big></p>\n\n<p style=\"margin-left:17%;\"><big><i>@</i> alone is a\nshortcut for <b>HEAD</b>.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>[&lt;refname&gt;]@{&lt;date&gt;}</i>,\ne.g. <i>master@{yesterday}</i>, <i>HEAD@{5 minutes\nago}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A ref followed by the\nsuffix <i>@</i> with a date specification enclosed in a\nbrace pair (e.g. <i>{yesterday}</i>, <i>{1 month 2 weeks 3\ndays 1 hour 1 second ago}</i> or <i>{1979-02-26\n18:30:00}</i>) specifies the value of the ref at a prior\npoint in time. This suffix may only be used immediately\nfollowing a ref name and the ref must have an existing log\n(<i>$GIT_DIR/logs/&lt;ref&gt;</i>). Note that this looks up\nthe state of your <b>local</b> ref at a given time; e.g.,\nwhat was in your local <i>master</i> branch last week. If\nyou want to look at commits made during certain times, see\n<b>--since</b> and <b>--until</b>.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;refname&gt;@{&lt;n&gt;}</i>,\ne.g. <i>master@{1}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A ref followed by the\nsuffix <i>@</i> with an ordinal specification enclosed in a\nbrace pair (e.g. <i>{1}</i>, <i>{15}</i>) specifies the n-th\nprior value of that ref. For example <i>master@{1}</i> is\nthe immediate prior value of <i>master</i> while\n<i>master@{5}</i> is the 5th prior value of <i>master</i>.\nThis suffix may only be used immediately following a ref\nname and the ref must have an existing log\n(<i>$GIT_DIR/logs/&lt;refname&gt;</i>).</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>@{&lt;n&gt;}</i>,\ne.g. <i>@{1}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>You can use the <i>@</i>\nconstruct with an empty ref part to get at a reflog entry of\nthe current branch. For example, if you are on branch\n<i>blabla</i> then <i>@{1}</i> means the same as\n<i>blabla@{1}</i>.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>@{-&lt;n&gt;}</i>,\ne.g. <i>@{-1}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>The construct\n<i>@{-&lt;n&gt;}</i> means the &lt;n&gt;th branch/commit\nchecked out before the current one.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>[&lt;branchname&gt;]@{upstream}</i>,\ne.g. <i>master@{upstream}</i>, <i>@{u}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>The suffix\n<i>@{upstream}</i> to a branchname (short form\n<i>&lt;branchname&gt;@{u}</i>) refers to the branch that the\nbranch specified by branchname is set to build on top of\n(configured with <b>branch.&lt;name&gt;.remote</b> and\n<b>branch.&lt;name&gt;.merge</b>). A missing branchname\ndefaults to the current one. These suffixes are also\naccepted when spelled in uppercase, and they mean the same\nthing no matter the case.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>[&lt;branchname&gt;]@{push}</i>,\ne.g. <i>master@{push}</i>, <i>@{push}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>The suffix <i>@{push}</i>\nreports the branch &quot;where we would push to&quot; if\n<b>git push</b> were run while <b>branchname</b> was checked\nout (or the current <b>HEAD</b> if no branchname is\nspecified). Since our push destination is in a remote\nrepository, of course, we report the local tracking branch\nthat corresponds to that branch (i.e., something in\n<b>refs/remotes/</b>).</big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Here&rsquo;s\nan example to make it more clear:</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>$ git\nconfig push.default current <br>\n$ git config remote.pushdefault myfork <br>\n$ git switch -c mybranch origin/master</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>$ git\nrev-parse --symbolic-full-name @{upstream} <br>\nrefs/remotes/origin/master</big></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><big>$ git\nrev-parse --symbolic-full-name @{push} <br>\nrefs/remotes/myfork/mybranch</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Note in\nthe example that we set up a triangular workflow, where we\npull from one location and push to another. In a\nnon-triangular workflow, <i>@{push}</i> is the same as\n<i>@{upstream}</i>, and there is no need for it.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>This\nsuffix is also accepted when spelled in uppercase, and means\nthe same thing no matter the case.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;^[&lt;n&gt;]</i>,\ne.g. <i>HEAD^, v1.5.1^0</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>^</i> to a\nrevision parameter means the first parent of that commit\nobject. <i>^&lt;n&gt;</i> means the &lt;n&gt;th parent (i.e.\n<i>&lt;rev&gt;^</i> is equivalent to <i>&lt;rev&gt;^1</i>).\nAs a special rule, <i>&lt;rev&gt;^0</i> means the commit\nitself and is used when <i>&lt;rev&gt;</i> is the object\nname of a tag object that refers to a commit\nobject.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;~[&lt;n&gt;]</i>,\ne.g. <i>HEAD~, master~3</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>~</i> to a\nrevision parameter means the first parent of that commit\nobject. A suffix <i>~&lt;n&gt;</i> to a revision parameter\nmeans the commit object that is the &lt;n&gt;th generation\nancestor of the named commit object, following only the\nfirst parents. I.e. <i>&lt;rev&gt;~3</i> is equivalent to\n<i>&lt;rev&gt;^^^</i> which is equivalent to\n<i>&lt;rev&gt;^1^1^1</i>. See below for an illustration of\nthe usage of this form.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;^{&lt;type&gt;}</i>,\ne.g. <i>v0.99.8^{commit}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>^</i> followed\nby an object type name enclosed in brace pair means\ndereference the object at <i>&lt;rev&gt;</i> recursively\nuntil an object of type <i>&lt;type&gt;</i> is found or the\nobject cannot be dereferenced anymore (in which case, barf).\nFor example, if <i>&lt;rev&gt;</i> is a commit-ish,\n<i>&lt;rev&gt;^{commit}</i> describes the corresponding\ncommit object. Similarly, if <i>&lt;rev&gt;</i> is a\ntree-ish, <i>&lt;rev&gt;^{tree}</i> describes the\ncorresponding tree object. <i>&lt;rev&gt;^0</i> is a\nshort-hand for <i>&lt;rev&gt;^{commit}</i>.</big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><i>&lt;rev&gt;^{object}</i>\ncan be used to make sure <i>&lt;rev&gt;</i> names an object\nthat exists, without requiring <i>&lt;rev&gt;</i> to be a\ntag, and without dereferencing <i>&lt;rev&gt;</i>; because a\ntag is already an object, it does not have to be\ndereferenced even once to get to an object.</big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><i>&lt;rev&gt;^{tag}</i>\ncan be used to ensure that <i>&lt;rev&gt;</i> identifies an\nexisting tag object.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;^{}</i>,\ne.g. <i>v0.99.8^{}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>^</i> followed\nby an empty brace pair means the object could be a tag, and\ndereference the tag recursively until a non-tag object is\nfound.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;^{/&lt;text&gt;}</i>,\ne.g. <i>HEAD^{/fix nasty bug}</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>^</i> to a\nrevision parameter, followed by a brace pair that contains a\ntext led by a slash, is the same as the <i>:/fix nasty\nbug</i> syntax below except that it returns the youngest\nmatching commit which is reachable from the\n<i>&lt;rev&gt;</i> before <i>^</i>.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>:/&lt;text&gt;</i>,\ne.g. <i>:/fix nasty bug</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A colon, followed by a\nslash, followed by a text, names a commit whose commit\nmessage matches the specified regular expression. This name\nreturns the youngest matching commit which is reachable from\nany ref, including HEAD. The regular expression can match\nany part of the commit message. To match messages starting\nwith a string, one can use e.g. <i>:/^foo</i>. The special\nsequence <i>:/!</i> is reserved for modifiers to what is\nmatched. <i>:/!-foo</i> performs a negative match, while\n<i>:/!!foo</i> matches a literal <i>!</i> character,\nfollowed by <i>foo</i>. Any other sequence beginning with\n<i>:/!</i> is reserved for now. Depending on the given text,\nthe shell&rsquo;s word splitting rules might require\nadditional quoting.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;:&lt;path&gt;</i>,\ne.g. <i>HEAD:README</i>, <i>master:./README</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>:</i> followed\nby a path names the blob or tree at the given path in the\ntree-ish object named by the part before the colon. A path\nstarting with <i>./</i> or <i>../</i> is relative to the\ncurrent working directory. The given path will be converted\nto be relative to the working tree&rsquo;s root directory.\nThis is most useful to address a blob or tree from a commit\nor tree that has the same tree structure as the working\ntree.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>:[&lt;n&gt;:]&lt;path&gt;</i>,\ne.g. <i>:0:README</i>, <i>:README</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A colon, optionally\nfollowed by a stage number (0 to 3) and a colon, followed by\na path, names a blob object in the index at the given path.\nA missing stage number (and the colon that follows it) names\na stage 0 entry. During a merge, stage 1 is the common\nancestor, stage 2 is the target branch&rsquo;s version\n(typically the current branch), and stage 3 is the version\nfrom the branch which is being merged.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Here is an\nillustration, by Jon Loeliger. Both commit nodes B and C are\nparents of commit node A. Parent commits are ordered\nleft-to-right.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>G H I J\n<br>\n\\ / \\ / <br>\nD E F <br>\n\\ | / \\ <br>\n\\ | / | <br>\n\\|/ | <br>\nB C <br>\n\\ / <br>\n\\ / <br>\nA</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>A = = A^0\n<br>\nB = A^ = A^1 = A~1 <br>\nC = = A^2 <br>\nD = A^^ = A^1^1 = A~2 <br>\nE = B^2 = A^^2 <br>\nF = B^3 = A^^3 <br>\nG = A^^^ = A^1^1^1 = A~3 <br>\nH = D^2 = B^^2 = A^^^2 = A~2^2 <br>\nI = F^ = B^3^ = A^^3^ <br>\nJ = F^2 = B^3^2 = A^^3^2</big></p>\n\n<h2>SPECIFYING RANGES\n<a name=\"SPECIFYING RANGES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>History\ntraversing commands such as <b>git log</b> operate on a set\nof commits, not just a single commit.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>For these\ncommands, specifying a single revision, using the notation\ndescribed in the previous section, means the set of commits\n<b>reachable</b> from the given commit.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Specifying\nseveral revisions means the set of commits reachable from\nany of the given commits.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>A\ncommit&rsquo;s reachable set is the commit itself and the\ncommits in its ancestry chain.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>There are\nseveral notations to specify a set of connected commits\n(called a &quot;revision range&quot;), illustrated\nbelow.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><b>Commit\nExclusions</b> <i><br>\n^&lt;rev&gt;</i> (caret) Notation</big></p>\n\n<p style=\"margin-left:17%;\"><big>To exclude commits\nreachable from a commit, a prefix <i>^</i> notation is used.\nE.g. <i>^r1 r2</i> means commits reachable from <i>r2</i>\nbut exclude the ones reachable from <i>r1</i> (i.e.\n<i>r1</i> and its ancestors).</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><b>Dotted\nRange Notations</b> <br>\nThe <i>..</i> (two-dot) Range Notation</big></p>\n\n<p style=\"margin-left:17%;\"><big>The <i>^r1 r2</i> set\noperation appears so often that there is a shorthand for it.\nWhen you have two commits <i>r1</i> and <i>r2</i> (named\naccording to the syntax explained in SPECIFYING REVISIONS\nabove), you can ask for commits that are reachable from r2\nexcluding those that are reachable from r1 by <i>^r1 r2</i>\nand it can be written as <i>r1..r2</i>.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>The\n<i>...</i> (three-dot) Symmetric Difference\nNotation</big></p>\n\n<p style=\"margin-left:17%;\"><big>A similar notation\n<i>r1...r2</i> is called symmetric difference of <i>r1</i>\nand <i>r2</i> and is defined as <i>r1 r2 --not $(git\nmerge-base --all r1 r2)</i>. It is the set of commits that\nare reachable from either one of <i>r1</i> (left side) or\n<i>r2</i> (right side) but not from both.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>In these\ntwo shorthand notations, you can omit one end and let it\ndefault to HEAD. For example, <i>origin..</i> is a shorthand\nfor <i>origin..HEAD</i> and asks &quot;What did I do since I\nforked from the origin branch?&quot; Similarly,\n<i>..origin</i> is a shorthand for <i>HEAD..origin</i> and\nasks &quot;What did the origin do since I forked from\nthem?&quot; Note that <i>..</i> would mean <i>HEAD..HEAD</i>\nwhich is an empty range that is both reachable and\nunreachable from HEAD.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Commands\nthat are specifically designed to take two distinct ranges\n(e.g. &quot;git range-diff R1 R2&quot; to compare two\nranges) do exist, but they are exceptions. Unless otherwise\nnoted, all &quot;git&quot; commands that operate on a set of\ncommits work on a single revision range. In other words,\nwriting two &quot;two-dot range notation&quot; next to each\nother, e.g.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git log\nA..B C..D</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>does\n<b>not</b> specify two revision ranges for most commands.\nInstead it will name a single connected set of commits, i.e.\nthose that are reachable from either B or D but are\nreachable from neither A or C. In a linear history like\nthis:</big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>---A---B---o---o---C---D</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>because A\nand B are reachable from C, the revision range specified by\nthese two dotted ranges is a single commit D.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><b>Other\n&lt;rev&gt;^ Parent Shorthand Notations</b> <br>\nThree other shorthands exist, particularly useful for merge\ncommits, for naming a set that is formed by a commit and its\nparent commits.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>The\n<i>r1^@</i> notation means all parents of\n<i>r1</i>.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>The\n<i>r1^!</i> notation includes commit <i>r1</i> but excludes\nall of its parents. By itself, this notation denotes the\nsingle commit <i>r1</i>.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>The\n<i>&lt;rev&gt;^-[&lt;n&gt;]</i> notation includes\n<i>&lt;rev&gt;</i> but excludes the &lt;n&gt;th parent (i.e.\na shorthand for <i>&lt;rev&gt;^&lt;n&gt;..&lt;rev&gt;</i>),\nwith <i>&lt;n&gt;</i> = 1 if not given. This is typically\nuseful for merge commits where you can just pass\n<i>&lt;commit&gt;^-</i> to get all the commits in the branch\nthat was merged in merge commit <i>&lt;commit&gt;</i>\n(including <i>&lt;commit&gt;</i> itself).</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>While\n<i>&lt;rev&gt;^&lt;n&gt;</i> was about specifying a single\ncommit parent, these three notations also consider its\nparents. For example you can say <i>HEAD^2^@</i>, however\nyou cannot say <i>HEAD^@^2</i>.</big></p>\n\n<h2>REVISION RANGE SUMMARY\n<a name=\"REVISION RANGE SUMMARY\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>Include commits that are\nreachable from &lt;rev&gt; (i.e. &lt;rev&gt; and its\nancestors).</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>^&lt;rev&gt;</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>Exclude commits that are\nreachable from &lt;rev&gt; (i.e. &lt;rev&gt; and its\nancestors).</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev1&gt;..&lt;rev2&gt;</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>Include commits that are\nreachable from &lt;rev2&gt; but exclude those that are\nreachable from &lt;rev1&gt;. When either &lt;rev1&gt; or\n&lt;rev2&gt; is omitted, it defaults to\n<b>HEAD</b>.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev1&gt;...&lt;rev2&gt;</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>Include commits that are\nreachable from either &lt;rev1&gt; or &lt;rev2&gt; but\nexclude those that are reachable from both. When either\n&lt;rev1&gt; or &lt;rev2&gt; is omitted, it defaults to\n<b>HEAD</b>.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;^@</i>,\ne.g. <i>HEAD^@</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>^</i> followed\nby an at sign is the same as listing all parents of\n<i>&lt;rev&gt;</i> (meaning, include anything reachable from\nits parents, but not the commit itself).</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;^!</i>,\ne.g. <i>HEAD^!</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>A suffix <i>^</i> followed\nby an exclamation mark is the same as giving commit\n<i>&lt;rev&gt;</i> and then all its parents prefixed with\n<i>^</i> to exclude them (and their ancestors).</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>&lt;rev&gt;^-&lt;n&gt;</i>,\ne.g. <i>HEAD^-, HEAD^-2</i></big></p>\n\n<p style=\"margin-left:17%;\"><big>Equivalent to\n<i>&lt;rev&gt;^&lt;n&gt;..&lt;rev&gt;</i>, with\n<i>&lt;n&gt;</i> = 1 if not given.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Here are a\nhandful of examples using the Loeliger illustration above,\nwith each step in the notation&rsquo;s expansion and\nselection carefully spelt out:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Args\nExpanded arguments Selected commits <br>\nD G H D <br>\nD F G H I J D F <br>\n^G D H D <br>\n^D B E I J F B <br>\n^D B C E I J F B C <br>\nC I J F C <br>\nB..C = ^B C C <br>\nB...C = B ^F C G H D E B C <br>\nB^- = B^..B <br>\n= ^B^1 B E I J F B <br>\nC^@ = C^1 <br>\n= F I J F <br>\nB^@ = B^1 B^2 B^3 <br>\n= D E F D G H E F I J <br>\nC^! = C ^C^@ <br>\n= C ^C^1 <br>\n= C ^F C <br>\nB^! = B ^B^@ <br>\n= B ^B^1 ^B^2 ^B^3 <br>\n= B ^D ^E ^F B <br>\nF^! D = F ^I ^J D G H D F</big></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><a href=\"https://man.page/1/git-rev-parse\">git-rev-parse(1)</a></big></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Part of\nthe <a href=\"https://man.page/1/git\">git(1)</a> suite</big></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SPECIFYING REVISIONS\">SPECIFYING REVISIONS</a>","<a href=\"#SPECIFYING RANGES\">SPECIFYING RANGES</a>","<a href=\"#REVISION RANGE SUMMARY\">REVISION RANGE SUMMARY</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#GIT\">GIT</a>"],"level":7}