{"name":"daemon","description":"daemon -\nWriting and packaging system daemons\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nA daemon is a\nservice process that runs in the background and supervises\nthe system or provides functionality to other processes.\nTraditionally, daemons are implemented following a scheme\noriginating in SysV Unix. Modern daemons should follow a\nsimpler yet more powerful scheme (here called\n&quot;new-style&quot; daemons), as implemented by\n<a href=\"https://man.page/1/systemd\">systemd(1)</a>. This manual page covers both schemes, and\nin particular includes recommendations for daemons that\nshall be included in the systemd init system.\n\n<b>SysV\nDaemons</b> <br>\nWhen a traditional SysV daemon starts, it should execute the\nfollowing steps as part of the initialization. Note that\nthese steps are unnecessary for new-style daemons (see\nbelow), and should only be implemented if compatibility with\nSysV is essential.\n\n<p style=\"margin-left:17%; margin-top: 1em\">1. Close all\nopen file descriptors except standard input, output, and\nerror (i.e. the first three file descriptors 0, 1, 2). This\nensures that no accidentally passed file descriptor stays\naround in the daemon process. On Linux, this is best\nimplemented by iterating through /proc/self/fd, with a\nfallback of iterating from file descriptor 3 to the value\nreturned by <b>getrlimit()</b> for <b>RLIMIT_NOFILE</b>.\n\n<p style=\"margin-left:17%; margin-top: 1em\">2. Reset all\nsignal handlers to their default. This is best done by\niterating through the available signals up to the limit of\n<b>_NSIG</b> and resetting them to <b>SIG_DFL</b>.\n\n<p style=\"margin-left:17%; margin-top: 1em\">3. Reset the\nsignal mask using <b>sigprocmask()</b>.\n\n<p style=\"margin-left:17%; margin-top: 1em\">4. Sanitize the\nenvironment block, removing or resetting environment\nvariables that might negatively impact daemon runtime.\n\n<p style=\"margin-left:17%; margin-top: 1em\">5. Call\n<b>fork()</b>, to create a background process.\n\n<p style=\"margin-left:17%; margin-top: 1em\">6. In the\nchild, call <b>setsid()</b> to detach from any terminal and\ncreate an independent session.\n\n<p style=\"margin-left:17%; margin-top: 1em\">7. In the\nchild, call <b>fork()</b> again, to ensure that the daemon\ncan never re-acquire a terminal again. (This relevant if the\nprogram &mdash; and all its dependencies &mdash; does not\ncarefully specify &rsquo;O_NOCTTY&rsquo; on each and every\nsingle &rsquo;open()&rsquo; call that might potentially open\na TTY device node.)\n\n<p style=\"margin-left:17%; margin-top: 1em\">8. Call\n<b>exit()</b> in the first child, so that only the second\nchild (the actual daemon process) stays around. This ensures\nthat the daemon process is re-parented to init/PID 1, as all\ndaemons should be.\n\n<p style=\"margin-left:17%; margin-top: 1em\">9. In the\ndaemon process, connect /dev/null to standard input, output,\nand error.\n\n<p style=\"margin-left:17%; margin-top: 1em\">10. In the\ndaemon process, reset the umask to 0, so that the file modes\npassed to <b>open()</b>, <b>mkdir()</b> and suchlike\ndirectly control the access mode of the created files and\ndirectories.\n\n<p style=\"margin-left:17%; margin-top: 1em\">11. In the\ndaemon process, change the current directory to the root\ndirectory (/), in order to avoid that the daemon\ninvoluntarily blocks mount points from being unmounted.\n\n<p style=\"margin-left:17%; margin-top: 1em\">12. In the\ndaemon process, write the daemon PID (as returned by\n<b>getpid()</b>) to a PID file, for example /run/foobar.pid\n(for a hypothetical daemon &quot;foobar&quot;) to ensure\nthat the daemon cannot be started more than once. This must\nbe implemented in race-free fashion so that the PID file is\nonly updated when it is verified at the same time that the\nPID previously stored in the PID file no longer exists or\nbelongs to a foreign process.\n\n<p style=\"margin-left:17%; margin-top: 1em\">13. In the\ndaemon process, drop privileges, if possible and\napplicable.\n\n<p style=\"margin-left:17%; margin-top: 1em\">14. From the\ndaemon process, notify the original process started that\ninitialization is complete. This can be implemented via an\nunnamed pipe or similar communication channel that is\ncreated before the first <b>fork()</b> and hence available\nin both the original and the daemon process.\n\n<p style=\"margin-left:17%; margin-top: 1em\">15. Call\n<b>exit()</b> in the original process. The process that\ninvoked the daemon must be able to rely on that this\n<b>exit()</b> happens after initialization is complete and\nall external communication channels are established and\naccessible.\n\nThe BSD\n<b>daemon()</b> function should not be used, as it\nimplements only a subset of these steps.\n\nA daemon that\nneeds to provide compatibility with SysV systems should\nimplement the scheme pointed out above. However, it is\nrecommended to make this behavior optional and configurable\nvia a command line argument to ease debugging as well as to\nsimplify integration into systems using systemd.\n\n<b>New-Style\nDaemons</b> <br>\nModern services for Linux should be implemented as new-style\ndaemons. This makes it easier to supervise and control them\nat runtime and simplifies their implementation.\n\nFor developing\na new-style daemon, none of the initialization steps\nrecommended for SysV daemons need to be implemented.\nNew-style init systems such as systemd make all of them\nredundant. Moreover, since some of these steps interfere\nwith process monitoring, file descriptor passing and other\nfunctionality of the init system, it is recommended not to\nexecute them when run as new-style service.\n\nNote that\nnew-style init systems guarantee execution of daemon\nprocesses in a clean process context: it is guaranteed that\nthe environment block is sanitized, that the signal handlers\nand mask is reset and that no left-over file descriptors are\npassed. Daemons will be executed in their own session, with\nstandard input connected to /dev/null and standard\noutput/error connected to the\n<b>systemd-journald.service</b>(8) logging service, unless\notherwise configured. The umask is reset.\n\nIt is\nrecommended for new-style daemons to implement the\nfollowing:\n\n<p style=\"margin-left:17%; margin-top: 1em\">1. If\n<b>SIGTERM</b> is received, shut down the daemon and exit\ncleanly.\n\n<p style=\"margin-left:17%; margin-top: 1em\">2. If\n<b>SIGHUP</b> is received, reload the configuration files,\nif this applies.\n\n<p style=\"margin-left:17%; margin-top: 1em\">3. Provide a\ncorrect exit code from the main daemon process, as this is\nused by the init system to detect service errors and\nproblems. It is recommended to follow the exit code scheme\nas defined in the <b><font color=\"#0000FF\">LSB\nrecommendations for SysV init scripts</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">4.\nIf possible and applicable, expose the daemon's control\ninterface via the D-Bus IPC system and grab a bus name as\nlast step of initialization.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">5.\nFor integration in systemd, provide a .service unit file\nthat carries information about starting, stopping and\notherwise maintaining the daemon. See\n<b>systemd.service</b>(5) for details.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">6.\nAs much as possible, rely on the init system's functionality\nto limit the access of the daemon to files, services and\nother resources, i.e. in the case of systemd, rely on\nsystemd's resource limit control instead of implementing\nyour own, rely on systemd's privilege dropping code instead\nof implementing it in the daemon, and similar. See\n<b>systemd.exec</b>(5) for the available\ncontrols.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">7.\nIf D-Bus is used, make your daemon bus-activatable by\nsupplying a D-Bus service activation configuration file.\nThis has multiple advantages: your daemon may be started\nlazily on-demand; it may be started in parallel to other\ndaemons requiring it &mdash; which maximizes parallelization\nand boot-up speed; your daemon can be restarted on failure\nwithout losing any bus requests, as the bus queues requests\nfor activatable services. See below for details.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">8.\nIf your daemon provides services to other local processes or\nremote clients via a socket, it should be made\nsocket-activatable following the scheme pointed out below.\nLike D-Bus activation, this enables on-demand starting of\nservices as well as it allows improved parallelization of\nservice start-up. Also, for state-less protocols (such as\nsyslog, DNS), a daemon implementing socket-based activation\ncan be restarted without losing a single request. See below\nfor details.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">9.\nIf applicable, a daemon should notify the init system about\nstartup completion or status updates via the\n<a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a> interface.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">10.\nInstead of using the <b>syslog()</b> call to log directly to\nthe system syslog service, a new-style daemon may choose to\nsimply log to standard error via <b>fprintf()</b>, which is\nthen forwarded to syslog by the init system. If log levels\nare necessary, these can be encoded by prefixing individual\nlog lines with strings like &quot;&lt;4&gt;&quot; (for log\nlevel 4 &quot;WARNING&quot; in the syslog priority scheme),\nfollowing a similar style as the Linux kernel's\n<b>printk()</b> level system. For details, see\n<a href=\"https://man.page/3/sd-daemon\">sd-daemon(3)</a> and <b>systemd.exec</b>(5).</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">11.\nAs new-style daemons are invoked without a controlling TTY\n(but as their own session leaders) care should be taken to\nalways specify &rsquo;O_NOCTTY&rsquo; on\n&rsquo;open()&rsquo; calls that possibly reference a TTY\ndevice node, so that no controlling TTY is accidentally\nacquired.</font>\n\n\n<font color=\"#000000\">These\nrecommendations are similar but not identical to the</font>\n<b><font color=\"#0000FF\">Apple MacOS X Daemon\nRequirements</font></b>\n<small><font color=\"#000000\">[2]</font></small>\n<font color=\"#000000\">.</font>\n\n<h2>ACTIVATION\n<a name=\"ACTIVATION\"></a>\n</h2>\n\n\n\n<font color=\"#000000\">New-style\ninit systems provide multiple additional mechanisms to\nactivate services, as detailed below. It is common that\nservices are configured to be activated via more than one\nmechanism at the same time. An example for systemd:\nbluetoothd.service might get activated either when Bluetooth\nhardware is plugged in, or when an application accesses its\nprogramming interfaces via D-Bus. Or, a print server daemon\nmight get activated when traffic arrives at an IPP port, or\nwhen a printer is plugged in, or when a file is queued in\nthe printer spool directory. Even for services that are\nintended to be started on system bootup unconditionally, it\nis a good idea to implement some of the various activation\nschemes outlined below, in order to maximize\nparallelization. If a daemon implements a D-Bus service or\nlistening socket, implementing the full bus and socket\nactivation scheme allows starting of the daemon with its\nclients in parallel (which speeds up boot-up), since all its\ncommunication channels are established already, and no\nrequest is lost because client requests will be queued by\nthe bus system (in case of D-Bus) or the kernel (in case of\nsockets) until the activation is completed.</font>\n\n\n<font color=\"#000000\"><b>Activation\non Boot</b> <br>\nOld-style daemons are usually activated exclusively on boot\n(and manually by the administrator) via SysV init scripts,\nas detailed in the</font> <b><font color=\"#0000FF\">LSB Linux\nStandard Base Core Specification</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">. This method of activation is\nsupported ubiquitously on Linux init systems, both old-style\nand new-style systems. Among other issues, SysV init scripts\nhave the disadvantage of involving shell scripts in the boot\nprocess. New-style init systems generally employ updated\nversions of activation, both during boot-up and during\nruntime and using more minimal service description\nfiles.</font>\n\n\n<font color=\"#000000\">In\nsystemd, if the developer or administrator wants to make\nsure that a service or other unit is activated automatically\non boot, it is recommended to place a symlink to the unit\nfile in the .wants/ directory of either multi-user.target or\ngraphical.target, which are normally used as boot targets at\nsystem startup. See <b>systemd.unit</b>(5) for details about\nthe .wants/ directories, and <b>systemd.special</b>(7) for\ndetails about the two boot targets.</font>\n\n\n<font color=\"#000000\"><b>Socket-Based\nActivation</b> <br>\nIn order to maximize the possible parallelization and\nrobustness and simplify configuration and development, it is\nrecommended for all new-style daemons that communicate via\nlistening sockets to employ socket-based activation. In a\nsocket-based activation scheme, the creation and binding of\nthe listening socket as primary communication channel of\ndaemons to local (and sometimes remote) clients is moved out\nof the daemon code and into the init system. Based on\nper-daemon configuration, the init system installs the\nsockets and then hands them off to the spawned process as\nsoon as the respective daemon is to be started. Optionally,\nactivation of the service can be delayed until the first\ninbound traffic arrives at the socket to implement on-demand\nactivation of daemons. However, the primary advantage of\nthis scheme is that all providers and all consumers of the\nsockets can be started in parallel as soon as all sockets\nare established. In addition to that, daemons can be\nrestarted with losing only a minimal number of client\ntransactions, or even any client request at all (the latter\nis particularly true for state-less protocols, such as DNS\nor syslog), because the socket stays bound and accessible\nduring the restart, and all requests are queued while the\ndaemon cannot process them.</font>\n\n\n<font color=\"#000000\">New-style\ndaemons which support socket activation must be able to\nreceive their sockets from the init system instead of\ncreating and binding them themselves. For details about the\nprogramming interfaces for this scheme provided by systemd,\nsee <a href=\"https://man.page/3/sd_listen_fds\">sd_listen_fds(3)</a> and <a href=\"https://man.page/3/sd-daemon\">sd-daemon(3)</a>. For\ndetails about porting existing daemons to socket-based\nactivation, see below. With minimal effort, it is possible\nto implement socket-based activation in addition to\ntraditional internal socket creation in the same codebase in\norder to support both new-style and old-style init systems\nfrom the same daemon binary.</font>\n\n\n<font color=\"#000000\">systemd\nimplements socket-based activation via .socket units, which\nare described in <b>systemd.socket</b>(5). When configuring\nsocket units for socket-based activation, it is essential\nthat all listening sockets are pulled in by the special\ntarget unit sockets.target. It is recommended to place a\n<i>WantedBy=sockets.target</i> directive in the [Install]\nsection to automatically add such a dependency on\ninstallation of a socket unit. Unless\n<i>DefaultDependencies=no</i> is set, the necessary ordering\ndependencies are implicitly created for all socket units.\nFor more information about sockets.target, see\n<b>systemd.special</b>(7). It is not necessary or\nrecommended to place any additional dependencies on socket\nunits (for example from multi-user.target or suchlike) when\none is installed in sockets.target.</font>\n\n\n<font color=\"#000000\"><b>Bus-Based\nActivation</b> <br>\nWhen the D-Bus IPC system is used for communication with\nclients, new-style daemons should employ bus activation so\nthat they are automatically activated when a client\napplication accesses their IPC interfaces. This is\nconfigured in D-Bus service files (not to be confused with\nsystemd service unit files!). To ensure that D-Bus uses\nsystemd to start-up and maintain the daemon, use the\n<i>SystemdService=</i> directive in these service files to\nconfigure the matching systemd service for a D-Bus service.\ne.g.: For a D-Bus service whose D-Bus activation file is\nnamed org.freedesktop.RealtimeKit.service, make sure to set\n<i>SystemdService=rtkit-daemon.service</i> in that file to\nbind it to the systemd service rtkit-daemon.service. This is\nneeded to make sure that the daemon is started in a\nrace-free fashion when activated via multiple mechanisms\nsimultaneously.</font>\n\n\n<font color=\"#000000\"><b>Device-Based\nActivation</b> <br>\nOften, daemons that manage a particular type of hardware\nshould be activated only when the hardware of the respective\nkind is plugged in or otherwise becomes available. In a\nnew-style init system, it is possible to bind activation to\nhardware plug/unplug events. In systemd, kernel devices\nappearing in the sysfs/udev device tree can be exposed as\nunits if they are tagged with the string\n&quot;systemd&quot;. Like any other kind of unit, they may\nthen pull in other units when activated (i.e. plugged in)\nand thus implement device-based activation. systemd\ndependencies may be encoded in the udev database via the\n<i>SYSTEMD_WANTS=</i> property. See <b>systemd.device</b>(5)\nfor details. Often, it is nicer to pull in services from\ndevices only indirectly via dedicated targets. Example:\nInstead of pulling in bluetoothd.service from all the\nvarious bluetooth dongles and other hardware available, pull\nin bluetooth.target from them and bluetoothd.service from\nthat target. This provides for nicer abstraction and gives\nadministrators the option to enable bluetoothd.service via\ncontrolling a bluetooth.target.wants/ symlink uniformly with\na command like <b>enable</b> of <a href=\"https://man.page/1/systemctl\">systemctl(1)</a> instead\nof manipulating the udev ruleset.</font>\n\n\n<font color=\"#000000\"><b>Path-Based\nActivation</b> <br>\nOften, runtime of daemons processing spool files or\ndirectories (such as a printing system) can be delayed until\nthese file system objects change state, or become non-empty.\nNew-style init systems provide a way to bind service\nactivation to file system changes. systemd implements this\nscheme via path-based activation configured in .path units,\nas outlined in <b>systemd.path</b>(5).</font>\n\n\n<font color=\"#000000\"><b>Timer-Based\nActivation</b> <br>\nSome daemons that implement clean-up jobs that are intended\nto be executed in regular intervals benefit from timer-based\nactivation. In systemd, this is implemented via .timer\nunits, as described in <b>systemd.timer</b>(5).</font>\n\n\n<font color=\"#000000\"><b>Other\nForms of Activation</b> <br>\nOther forms of activation have been suggested and\nimplemented in some systems. However, there are often\nsimpler or better alternatives, or they can be put together\nof combinations of the schemes above. Example: Sometimes, it\nappears useful to start daemons or .socket units when a\nspecific IP address is configured on a network interface,\nbecause network sockets shall be bound to the address.\nHowever, an alternative to implement this is by utilizing\nthe Linux <b>IP_FREEBIND</b>/<b>IPV6_FREEBIND</b> socket\noption, as accessible via <i>FreeBind=yes</i> in systemd\nsocket files (see <b>systemd.socket</b>(5) for details).\nThis option, when enabled, allows sockets to be bound to a\nnon-local, not configured IP address, and hence allows\nbindings to a particular IP address before it actually\nbecomes available, making such an explicit dependency to the\nconfigured address redundant. Another often suggested\ntrigger for service activation is low system load. However,\nhere too, a more convincing approach might be to make proper\nuse of features of the operating system, in particular, the\nCPU or I/O scheduler of Linux. Instead of scheduling jobs\nfrom userspace based on monitoring the OS scheduler, it is\nadvisable to leave the scheduling of processes to the OS\nscheduler itself. systemd provides fine-grained access to\nthe CPU and I/O schedulers. If a process executed by the\ninit system shall not negatively impact the amount of CPU or\nI/O bandwidth available to other processes, it should be\nconfigured with <i>CPUSchedulingPolicy=idle</i> and/or\n<i>IOSchedulingClass=idle</i>. Optionally, this may be\ncombined with timer-based activation to schedule background\njobs during runtime and with minimal impact on the system,\nand remove it from the boot phase itself.</font>\n\n<h2>INTEGRATION WITH SYSTEMD\n<a name=\"INTEGRATION WITH SYSTEMD\"></a>\n</h2>\n\n\n\n<font color=\"#000000\"><b>Writing\nsystemd Unit Files</b> <br>\nWhen writing systemd unit files, it is recommended to\nconsider the following suggestions:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">1.\nIf possible, do not use the <i>Type=forking</i> setting in\nservice files. But if you do, make sure to set the PID file\npath using <i>PIDFile=</i>. See <b>systemd.service</b>(5)\nfor details.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">2.\nIf your daemon registers a D-Bus name on the bus, make sure\nto use <i>Type=dbus</i> in the service file if\npossible.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">3.\nMake sure to set a good human-readable description string\nwith <i>Description=</i>.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">4.\nDo not disable <i>DefaultDependencies=</i>, unless you\nreally know what you do and your unit is involved in early\nboot or late system shutdown.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">5.\nNormally, little if any dependencies should need to be\ndefined explicitly. However, if you do configure explicit\ndependencies, only refer to unit names listed on\n<b>systemd.special</b>(7) or names introduced by your own\npackage to keep the unit file operating\nsystem-independent.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">6.\nMake sure to include an [Install] section including\ninstallation information for the unit file. See\n<b>systemd.unit</b>(5) for details. To activate your service\non boot, make sure to add a\n<i>WantedBy=multi-user.target</i> or\n<i>WantedBy=graphical.target</i> directive. To activate your\nsocket on boot, make sure to add\n<i>WantedBy=sockets.target</i>. Usually, you also want to\nmake sure that when your service is installed, your socket\nis installed too, hence add <i>Also=foo.socket</i> in your\nservice file foo.service, for a hypothetical program\nfoo.</font>\n\n\n<font color=\"#000000\"><b>Installing\nsystemd Service Files</b> <br>\nAt the build installation time (e.g. <b>make install</b>\nduring package build), packages are recommended to install\ntheir systemd unit files in the directory returned by\n<b>pkg-config systemd --variable=systemdsystemunitdir</b>\n(for system services) or <b>pkg-config systemd\n--variable=systemduserunitdir</b> (for user services). This\nwill make the services available in the system on explicit\nrequest but not activate them automatically during boot.\nOptionally, during package installation (e.g. <b>rpm -i</b>\nby the administrator), symlinks should be created in the\nsystemd configuration directories via the <b>enable</b>\ncommand of the <a href=\"https://man.page/1/systemctl\">systemctl(1)</a> tool to activate them\nautomatically on boot.</font>\n\n\n<font color=\"#000000\">Packages\nusing <a href=\"https://man.page/1/autoconf\">autoconf(1)</a> are recommended to use a configure\nscript excerpt like the following to determine the unit\ninstallation path during source configuration:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">PKG_PROG_PKG_CONFIG\n<br>\nAC_ARG_WITH([systemdsystemunitdir], <br>\n[AS_HELP_STRING([--with-systemdsystemunitdir=DIR],\n[Directory for systemd service files])],, <br>\n[with_systemdsystemunitdir=auto]) <br>\nAS_IF([test &quot;x$with_systemdsystemunitdir&quot; =\n&quot;xyes&quot; -o &quot;x$with_systemdsystemunitdir&quot;\n= &quot;xauto&quot;], [ <br>\ndef_systemdsystemunitdir=$($PKG_CONFIG\n--variable=systemdsystemunitdir systemd)</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">AS_IF([test\n&quot;x$def_systemdsystemunitdir&quot; = &quot;x&quot;],\n<br>\n[AS_IF([test &quot;x$with_systemdsystemunitdir&quot; =\n&quot;xyes&quot;], <br>\n[AC_MSG_ERROR([systemd support requested but pkg-config\nunable to query systemd package])]) <br>\nwith_systemdsystemunitdir=no], <br>\n\n[with_systemdsystemunitdir=&quot;$def_systemdsystemunitdir&quot;])])\n<br>\nAS_IF([test &quot;x$with_systemdsystemunitdir&quot; !=\n&quot;xno&quot;], <br>\n[AC_SUBST([systemdsystemunitdir],\n[$with_systemdsystemunitdir])]) <br>\nAM_CONDITIONAL([HAVE_SYSTEMD], [test\n&quot;x$with_systemdsystemunitdir&quot; !=\n&quot;xno&quot;])</font>\n\n\n<font color=\"#000000\">This\nsnippet allows automatic installation of the unit files on\nsystemd machines, and optionally allows their installation\neven on machines lacking systemd. (Modification of this\nsnippet for the user unit directory is left as an exercise\nfor the reader.)</font>\n\n\n<font color=\"#000000\">Additionally,\nto ensure that <b>make distcheck</b> continues to work, it\nis recommended to add the following to the top-level\nMakefile.am file in <a href=\"https://man.page/1/automake\">automake(1)</a>-based\nprojects:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">AM_DISTCHECK_CONFIGURE_FLAGS\n= \\ <br>\n\n--with-systemdsystemunitdir=$$dc_install_base/$(systemdsystemunitdir)</font>\n\n\n<font color=\"#000000\">Finally,\nunit files should be installed in the system with an\nautomake excerpt like the following:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">if\nHAVE_SYSTEMD <br>\nsystemdsystemunit_DATA = \\ <br>\nfoobar.socket \\ <br>\nfoobar.service <br>\nendif</font>\n\n\n<font color=\"#000000\">In\nthe <b>rpm</b>(8) .spec file, use snippets like the\nfollowing to enable/disable the service during\ninstallation/deinstallation. This makes use of the RPM\nmacros shipped along systemd. Consult the packaging\nguidelines of your distribution for details and the\nequivalent for other package managers.</font>\n\n\n<font color=\"#000000\">At\nthe top of the file:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">BuildRequires:\nsystemd <br>\n%{?systemd_requires}</font>\n\n\n<font color=\"#000000\">And\nas scriptlets, further down:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%post\n<br>\n%systemd_post foobar.service foobar.socket</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%preun\n<br>\n%systemd_preun foobar.service foobar.socket</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%postun\n<br>\n%systemd_postun</font>\n\n\n<font color=\"#000000\">If\nthe service shall be restarted during upgrades, replace the\n&quot;%postun&quot; scriptlet above with the\nfollowing:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%postun\n<br>\n%systemd_postun_with_restart foobar.service</font>\n\n\n<font color=\"#000000\">Note\nthat &quot;%systemd_post&quot; and\n&quot;%systemd_preun&quot; expect the names of all units\nthat are installed/removed as arguments, separated by\nspaces. &quot;%systemd_postun&quot; expects no arguments.\n&quot;%systemd_postun_with_restart&quot; expects the units\nto restart as arguments.</font>\n\n\n<font color=\"#000000\">To\nfacilitate upgrades from a package version that shipped only\nSysV init scripts to a package version that ships both a\nSysV init script and a native systemd service file, use a\nfragment like the following:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%triggerun\n-- foobar &lt; 0.47.11-1 <br>\nif /sbin/chkconfig --level 5 foobar ; then <br>\n/bin/systemctl --no-reload enable foobar.service\nfoobar.socket &gt;/dev/null 2&gt;&amp;1 || : <br>\nfi</font>\n\n\n<font color=\"#000000\">Where\n0.47.11-1 is the first package version that includes the\nnative unit file. This fragment will ensure that the first\ntime the unit file is installed, it will be enabled if and\nonly if the SysV init script is enabled, thus making sure\nthat the enable status is not changed. Note that\n<b>chkconfig</b> is a command specific to Fedora which can\nbe used to check whether a SysV init script is enabled.\nOther operating systems will have to use different commands\nhere.</font>\n\n<h2>PORTING EXISTING DAEMONS\n<a name=\"PORTING EXISTING DAEMONS\"></a>\n</h2>\n\n\n\n<font color=\"#000000\">Since\nnew-style init systems such as systemd are compatible with\ntraditional SysV init systems, it is not strictly necessary\nto port existing daemons to the new style. However, doing so\noffers additional functionality to the daemons as well as\nsimplifying integration into new-style init\nsystems.</font>\n\n\n<font color=\"#000000\">To\nport an existing SysV compatible daemon, the following steps\nare recommended:</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">1.\nIf not already implemented, add an optional command line\nswitch to the daemon to disable daemonization. This is\nuseful not only for using the daemon in new-style init\nsystems, but also to ease debugging.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">2.\nIf the daemon offers interfaces to other software running on\nthe local system via local <b>AF_UNIX</b> sockets, consider\nimplementing socket-based activation (see above). Usually, a\nminimal patch is sufficient to implement this: Extend the\nsocket creation in the daemon code so that\n<a href=\"https://man.page/3/sd_listen_fds\">sd_listen_fds(3)</a> is checked for already passed\nsockets first. If sockets are passed (i.e. when\n<b>sd_listen_fds()</b> returns a positive value), skip the\nsocket creation step and use the passed sockets. Secondly,\nensure that the file system socket nodes for local\n<b>AF_UNIX</b> sockets used in the socket-based activation\nare not removed when the daemon shuts down, if sockets have\nbeen passed. Third, if the daemon normally closes all\nremaining open file descriptors as part of its\ninitialization, the sockets passed from the init system must\nbe spared. Since new-style init systems guarantee that no\nleft-over file descriptors are passed to executed processes,\nit might be a good choice to simply skip the closing of all\nremaining open file descriptors if sockets are\npassed.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">3.\nWrite and install a systemd unit file for the service (and\nthe sockets if socket-based activation is used, as well as a\npath unit file, if the daemon processes a spool directory),\nsee above for details.</font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">4.\nIf the daemon exposes interfaces via D-Bus, write and\ninstall a D-Bus activation file for the service, see above\nfor details.</font>\n\n<h2>PLACING DAEMON DATA\n<a name=\"PLACING DAEMON DATA\"></a>\n</h2>\n\n\n\n<font color=\"#000000\">It\nis recommended to follow the general guidelines for placing\npackage files, as discussed in\n<a href=\"https://man.page/7/file-hierarchy\">file-hierarchy(7)</a>.</font>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<font color=\"#000000\"><a href=\"https://man.page/1/systemd\">systemd(1)</a>,\n<a href=\"https://man.page/3/sd-daemon\">sd-daemon(3)</a>, <a href=\"https://man.page/3/sd_listen_fds\">sd_listen_fds(3)</a>,\n<a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a>, <a href=\"https://man.page/3/daemon\">daemon(3)</a>,\n<b>systemd.service</b>(5),\n<a href=\"https://man.page/7/file-hierarchy\">file-hierarchy(7)</a></font>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">1.</font> </td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">LSB\nrecommendations for SysV init scripts</font></td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/iniscrptact.html</font>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">2.</font> </td>\n<td width=\"2%\"></td>\n<td width=\"51%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">Apple\nMacOS X Daemon Requirements</font></td>\n<td width=\"32%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html</font>","body":"\n\n<h1 align=\"center\">DAEMON</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">daemon -\nWriting and packaging system daemons</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A daemon is a\nservice process that runs in the background and supervises\nthe system or provides functionality to other processes.\nTraditionally, daemons are implemented following a scheme\noriginating in SysV Unix. Modern daemons should follow a\nsimpler yet more powerful scheme (here called\n&quot;new-style&quot; daemons), as implemented by\n<a href=\"https://man.page/1/systemd\">systemd(1)</a>. This manual page covers both schemes, and\nin particular includes recommendations for daemons that\nshall be included in the systemd init system.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SysV\nDaemons</b> <br>\nWhen a traditional SysV daemon starts, it should execute the\nfollowing steps as part of the initialization. Note that\nthese steps are unnecessary for new-style daemons (see\nbelow), and should only be implemented if compatibility with\nSysV is essential.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">1. Close all\nopen file descriptors except standard input, output, and\nerror (i.e. the first three file descriptors 0, 1, 2). This\nensures that no accidentally passed file descriptor stays\naround in the daemon process. On Linux, this is best\nimplemented by iterating through /proc/self/fd, with a\nfallback of iterating from file descriptor 3 to the value\nreturned by <b>getrlimit()</b> for <b>RLIMIT_NOFILE</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">2. Reset all\nsignal handlers to their default. This is best done by\niterating through the available signals up to the limit of\n<b>_NSIG</b> and resetting them to <b>SIG_DFL</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">3. Reset the\nsignal mask using <b>sigprocmask()</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">4. Sanitize the\nenvironment block, removing or resetting environment\nvariables that might negatively impact daemon runtime.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">5. Call\n<b>fork()</b>, to create a background process.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">6. In the\nchild, call <b>setsid()</b> to detach from any terminal and\ncreate an independent session.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">7. In the\nchild, call <b>fork()</b> again, to ensure that the daemon\ncan never re-acquire a terminal again. (This relevant if the\nprogram &mdash; and all its dependencies &mdash; does not\ncarefully specify &rsquo;O_NOCTTY&rsquo; on each and every\nsingle &rsquo;open()&rsquo; call that might potentially open\na TTY device node.)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">8. Call\n<b>exit()</b> in the first child, so that only the second\nchild (the actual daemon process) stays around. This ensures\nthat the daemon process is re-parented to init/PID 1, as all\ndaemons should be.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">9. In the\ndaemon process, connect /dev/null to standard input, output,\nand error.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">10. In the\ndaemon process, reset the umask to 0, so that the file modes\npassed to <b>open()</b>, <b>mkdir()</b> and suchlike\ndirectly control the access mode of the created files and\ndirectories.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">11. In the\ndaemon process, change the current directory to the root\ndirectory (/), in order to avoid that the daemon\ninvoluntarily blocks mount points from being unmounted.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">12. In the\ndaemon process, write the daemon PID (as returned by\n<b>getpid()</b>) to a PID file, for example /run/foobar.pid\n(for a hypothetical daemon &quot;foobar&quot;) to ensure\nthat the daemon cannot be started more than once. This must\nbe implemented in race-free fashion so that the PID file is\nonly updated when it is verified at the same time that the\nPID previously stored in the PID file no longer exists or\nbelongs to a foreign process.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">13. In the\ndaemon process, drop privileges, if possible and\napplicable.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">14. From the\ndaemon process, notify the original process started that\ninitialization is complete. This can be implemented via an\nunnamed pipe or similar communication channel that is\ncreated before the first <b>fork()</b> and hence available\nin both the original and the daemon process.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">15. Call\n<b>exit()</b> in the original process. The process that\ninvoked the daemon must be able to rely on that this\n<b>exit()</b> happens after initialization is complete and\nall external communication channels are established and\naccessible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The BSD\n<b>daemon()</b> function should not be used, as it\nimplements only a subset of these steps.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A daemon that\nneeds to provide compatibility with SysV systems should\nimplement the scheme pointed out above. However, it is\nrecommended to make this behavior optional and configurable\nvia a command line argument to ease debugging as well as to\nsimplify integration into systems using systemd.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>New-Style\nDaemons</b> <br>\nModern services for Linux should be implemented as new-style\ndaemons. This makes it easier to supervise and control them\nat runtime and simplifies their implementation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For developing\na new-style daemon, none of the initialization steps\nrecommended for SysV daemons need to be implemented.\nNew-style init systems such as systemd make all of them\nredundant. Moreover, since some of these steps interfere\nwith process monitoring, file descriptor passing and other\nfunctionality of the init system, it is recommended not to\nexecute them when run as new-style service.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\nnew-style init systems guarantee execution of daemon\nprocesses in a clean process context: it is guaranteed that\nthe environment block is sanitized, that the signal handlers\nand mask is reset and that no left-over file descriptors are\npassed. Daemons will be executed in their own session, with\nstandard input connected to /dev/null and standard\noutput/error connected to the\n<b>systemd-journald.service</b>(8) logging service, unless\notherwise configured. The umask is reset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is\nrecommended for new-style daemons to implement the\nfollowing:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">1. If\n<b>SIGTERM</b> is received, shut down the daemon and exit\ncleanly.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">2. If\n<b>SIGHUP</b> is received, reload the configuration files,\nif this applies.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">3. Provide a\ncorrect exit code from the main daemon process, as this is\nused by the init system to detect service errors and\nproblems. It is recommended to follow the exit code scheme\nas defined in the <b><font color=\"#0000FF\">LSB\nrecommendations for SysV init scripts</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">4.\nIf possible and applicable, expose the daemon's control\ninterface via the D-Bus IPC system and grab a bus name as\nlast step of initialization.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">5.\nFor integration in systemd, provide a .service unit file\nthat carries information about starting, stopping and\notherwise maintaining the daemon. See\n<b>systemd.service</b>(5) for details.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">6.\nAs much as possible, rely on the init system's functionality\nto limit the access of the daemon to files, services and\nother resources, i.e. in the case of systemd, rely on\nsystemd's resource limit control instead of implementing\nyour own, rely on systemd's privilege dropping code instead\nof implementing it in the daemon, and similar. See\n<b>systemd.exec</b>(5) for the available\ncontrols.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">7.\nIf D-Bus is used, make your daemon bus-activatable by\nsupplying a D-Bus service activation configuration file.\nThis has multiple advantages: your daemon may be started\nlazily on-demand; it may be started in parallel to other\ndaemons requiring it &mdash; which maximizes parallelization\nand boot-up speed; your daemon can be restarted on failure\nwithout losing any bus requests, as the bus queues requests\nfor activatable services. See below for details.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">8.\nIf your daemon provides services to other local processes or\nremote clients via a socket, it should be made\nsocket-activatable following the scheme pointed out below.\nLike D-Bus activation, this enables on-demand starting of\nservices as well as it allows improved parallelization of\nservice start-up. Also, for state-less protocols (such as\nsyslog, DNS), a daemon implementing socket-based activation\ncan be restarted without losing a single request. See below\nfor details.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">9.\nIf applicable, a daemon should notify the init system about\nstartup completion or status updates via the\n<a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a> interface.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">10.\nInstead of using the <b>syslog()</b> call to log directly to\nthe system syslog service, a new-style daemon may choose to\nsimply log to standard error via <b>fprintf()</b>, which is\nthen forwarded to syslog by the init system. If log levels\nare necessary, these can be encoded by prefixing individual\nlog lines with strings like &quot;&lt;4&gt;&quot; (for log\nlevel 4 &quot;WARNING&quot; in the syslog priority scheme),\nfollowing a similar style as the Linux kernel's\n<b>printk()</b> level system. For details, see\n<a href=\"https://man.page/3/sd-daemon\">sd-daemon(3)</a> and <b>systemd.exec</b>(5).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">11.\nAs new-style daemons are invoked without a controlling TTY\n(but as their own session leaders) care should be taken to\nalways specify &rsquo;O_NOCTTY&rsquo; on\n&rsquo;open()&rsquo; calls that possibly reference a TTY\ndevice node, so that no controlling TTY is accidentally\nacquired.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">These\nrecommendations are similar but not identical to the</font>\n<b><font color=\"#0000FF\">Apple MacOS X Daemon\nRequirements</font></b>\n<small><font color=\"#000000\">[2]</font></small>\n<font color=\"#000000\">.</font></p>\n\n<h2>ACTIVATION\n<a name=\"ACTIVATION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">New-style\ninit systems provide multiple additional mechanisms to\nactivate services, as detailed below. It is common that\nservices are configured to be activated via more than one\nmechanism at the same time. An example for systemd:\nbluetoothd.service might get activated either when Bluetooth\nhardware is plugged in, or when an application accesses its\nprogramming interfaces via D-Bus. Or, a print server daemon\nmight get activated when traffic arrives at an IPP port, or\nwhen a printer is plugged in, or when a file is queued in\nthe printer spool directory. Even for services that are\nintended to be started on system bootup unconditionally, it\nis a good idea to implement some of the various activation\nschemes outlined below, in order to maximize\nparallelization. If a daemon implements a D-Bus service or\nlistening socket, implementing the full bus and socket\nactivation scheme allows starting of the daemon with its\nclients in parallel (which speeds up boot-up), since all its\ncommunication channels are established already, and no\nrequest is lost because client requests will be queued by\nthe bus system (in case of D-Bus) or the kernel (in case of\nsockets) until the activation is completed.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Activation\non Boot</b> <br>\nOld-style daemons are usually activated exclusively on boot\n(and manually by the administrator) via SysV init scripts,\nas detailed in the</font> <b><font color=\"#0000FF\">LSB Linux\nStandard Base Core Specification</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">. This method of activation is\nsupported ubiquitously on Linux init systems, both old-style\nand new-style systems. Among other issues, SysV init scripts\nhave the disadvantage of involving shell scripts in the boot\nprocess. New-style init systems generally employ updated\nversions of activation, both during boot-up and during\nruntime and using more minimal service description\nfiles.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">In\nsystemd, if the developer or administrator wants to make\nsure that a service or other unit is activated automatically\non boot, it is recommended to place a symlink to the unit\nfile in the .wants/ directory of either multi-user.target or\ngraphical.target, which are normally used as boot targets at\nsystem startup. See <b>systemd.unit</b>(5) for details about\nthe .wants/ directories, and <b>systemd.special</b>(7) for\ndetails about the two boot targets.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Socket-Based\nActivation</b> <br>\nIn order to maximize the possible parallelization and\nrobustness and simplify configuration and development, it is\nrecommended for all new-style daemons that communicate via\nlistening sockets to employ socket-based activation. In a\nsocket-based activation scheme, the creation and binding of\nthe listening socket as primary communication channel of\ndaemons to local (and sometimes remote) clients is moved out\nof the daemon code and into the init system. Based on\nper-daemon configuration, the init system installs the\nsockets and then hands them off to the spawned process as\nsoon as the respective daemon is to be started. Optionally,\nactivation of the service can be delayed until the first\ninbound traffic arrives at the socket to implement on-demand\nactivation of daemons. However, the primary advantage of\nthis scheme is that all providers and all consumers of the\nsockets can be started in parallel as soon as all sockets\nare established. In addition to that, daemons can be\nrestarted with losing only a minimal number of client\ntransactions, or even any client request at all (the latter\nis particularly true for state-less protocols, such as DNS\nor syslog), because the socket stays bound and accessible\nduring the restart, and all requests are queued while the\ndaemon cannot process them.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">New-style\ndaemons which support socket activation must be able to\nreceive their sockets from the init system instead of\ncreating and binding them themselves. For details about the\nprogramming interfaces for this scheme provided by systemd,\nsee <a href=\"https://man.page/3/sd_listen_fds\">sd_listen_fds(3)</a> and <a href=\"https://man.page/3/sd-daemon\">sd-daemon(3)</a>. For\ndetails about porting existing daemons to socket-based\nactivation, see below. With minimal effort, it is possible\nto implement socket-based activation in addition to\ntraditional internal socket creation in the same codebase in\norder to support both new-style and old-style init systems\nfrom the same daemon binary.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">systemd\nimplements socket-based activation via .socket units, which\nare described in <b>systemd.socket</b>(5). When configuring\nsocket units for socket-based activation, it is essential\nthat all listening sockets are pulled in by the special\ntarget unit sockets.target. It is recommended to place a\n<i>WantedBy=sockets.target</i> directive in the [Install]\nsection to automatically add such a dependency on\ninstallation of a socket unit. Unless\n<i>DefaultDependencies=no</i> is set, the necessary ordering\ndependencies are implicitly created for all socket units.\nFor more information about sockets.target, see\n<b>systemd.special</b>(7). It is not necessary or\nrecommended to place any additional dependencies on socket\nunits (for example from multi-user.target or suchlike) when\none is installed in sockets.target.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Bus-Based\nActivation</b> <br>\nWhen the D-Bus IPC system is used for communication with\nclients, new-style daemons should employ bus activation so\nthat they are automatically activated when a client\napplication accesses their IPC interfaces. This is\nconfigured in D-Bus service files (not to be confused with\nsystemd service unit files!). To ensure that D-Bus uses\nsystemd to start-up and maintain the daemon, use the\n<i>SystemdService=</i> directive in these service files to\nconfigure the matching systemd service for a D-Bus service.\ne.g.: For a D-Bus service whose D-Bus activation file is\nnamed org.freedesktop.RealtimeKit.service, make sure to set\n<i>SystemdService=rtkit-daemon.service</i> in that file to\nbind it to the systemd service rtkit-daemon.service. This is\nneeded to make sure that the daemon is started in a\nrace-free fashion when activated via multiple mechanisms\nsimultaneously.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Device-Based\nActivation</b> <br>\nOften, daemons that manage a particular type of hardware\nshould be activated only when the hardware of the respective\nkind is plugged in or otherwise becomes available. In a\nnew-style init system, it is possible to bind activation to\nhardware plug/unplug events. In systemd, kernel devices\nappearing in the sysfs/udev device tree can be exposed as\nunits if they are tagged with the string\n&quot;systemd&quot;. Like any other kind of unit, they may\nthen pull in other units when activated (i.e. plugged in)\nand thus implement device-based activation. systemd\ndependencies may be encoded in the udev database via the\n<i>SYSTEMD_WANTS=</i> property. See <b>systemd.device</b>(5)\nfor details. Often, it is nicer to pull in services from\ndevices only indirectly via dedicated targets. Example:\nInstead of pulling in bluetoothd.service from all the\nvarious bluetooth dongles and other hardware available, pull\nin bluetooth.target from them and bluetoothd.service from\nthat target. This provides for nicer abstraction and gives\nadministrators the option to enable bluetoothd.service via\ncontrolling a bluetooth.target.wants/ symlink uniformly with\na command like <b>enable</b> of <a href=\"https://man.page/1/systemctl\">systemctl(1)</a> instead\nof manipulating the udev ruleset.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Path-Based\nActivation</b> <br>\nOften, runtime of daemons processing spool files or\ndirectories (such as a printing system) can be delayed until\nthese file system objects change state, or become non-empty.\nNew-style init systems provide a way to bind service\nactivation to file system changes. systemd implements this\nscheme via path-based activation configured in .path units,\nas outlined in <b>systemd.path</b>(5).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Timer-Based\nActivation</b> <br>\nSome daemons that implement clean-up jobs that are intended\nto be executed in regular intervals benefit from timer-based\nactivation. In systemd, this is implemented via .timer\nunits, as described in <b>systemd.timer</b>(5).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Other\nForms of Activation</b> <br>\nOther forms of activation have been suggested and\nimplemented in some systems. However, there are often\nsimpler or better alternatives, or they can be put together\nof combinations of the schemes above. Example: Sometimes, it\nappears useful to start daemons or .socket units when a\nspecific IP address is configured on a network interface,\nbecause network sockets shall be bound to the address.\nHowever, an alternative to implement this is by utilizing\nthe Linux <b>IP_FREEBIND</b>/<b>IPV6_FREEBIND</b> socket\noption, as accessible via <i>FreeBind=yes</i> in systemd\nsocket files (see <b>systemd.socket</b>(5) for details).\nThis option, when enabled, allows sockets to be bound to a\nnon-local, not configured IP address, and hence allows\nbindings to a particular IP address before it actually\nbecomes available, making such an explicit dependency to the\nconfigured address redundant. Another often suggested\ntrigger for service activation is low system load. However,\nhere too, a more convincing approach might be to make proper\nuse of features of the operating system, in particular, the\nCPU or I/O scheduler of Linux. Instead of scheduling jobs\nfrom userspace based on monitoring the OS scheduler, it is\nadvisable to leave the scheduling of processes to the OS\nscheduler itself. systemd provides fine-grained access to\nthe CPU and I/O schedulers. If a process executed by the\ninit system shall not negatively impact the amount of CPU or\nI/O bandwidth available to other processes, it should be\nconfigured with <i>CPUSchedulingPolicy=idle</i> and/or\n<i>IOSchedulingClass=idle</i>. Optionally, this may be\ncombined with timer-based activation to schedule background\njobs during runtime and with minimal impact on the system,\nand remove it from the boot phase itself.</font></p>\n\n<h2>INTEGRATION WITH SYSTEMD\n<a name=\"INTEGRATION WITH SYSTEMD\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Writing\nsystemd Unit Files</b> <br>\nWhen writing systemd unit files, it is recommended to\nconsider the following suggestions:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">1.\nIf possible, do not use the <i>Type=forking</i> setting in\nservice files. But if you do, make sure to set the PID file\npath using <i>PIDFile=</i>. See <b>systemd.service</b>(5)\nfor details.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">2.\nIf your daemon registers a D-Bus name on the bus, make sure\nto use <i>Type=dbus</i> in the service file if\npossible.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">3.\nMake sure to set a good human-readable description string\nwith <i>Description=</i>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">4.\nDo not disable <i>DefaultDependencies=</i>, unless you\nreally know what you do and your unit is involved in early\nboot or late system shutdown.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">5.\nNormally, little if any dependencies should need to be\ndefined explicitly. However, if you do configure explicit\ndependencies, only refer to unit names listed on\n<b>systemd.special</b>(7) or names introduced by your own\npackage to keep the unit file operating\nsystem-independent.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">6.\nMake sure to include an [Install] section including\ninstallation information for the unit file. See\n<b>systemd.unit</b>(5) for details. To activate your service\non boot, make sure to add a\n<i>WantedBy=multi-user.target</i> or\n<i>WantedBy=graphical.target</i> directive. To activate your\nsocket on boot, make sure to add\n<i>WantedBy=sockets.target</i>. Usually, you also want to\nmake sure that when your service is installed, your socket\nis installed too, hence add <i>Also=foo.socket</i> in your\nservice file foo.service, for a hypothetical program\nfoo.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Installing\nsystemd Service Files</b> <br>\nAt the build installation time (e.g. <b>make install</b>\nduring package build), packages are recommended to install\ntheir systemd unit files in the directory returned by\n<b>pkg-config systemd --variable=systemdsystemunitdir</b>\n(for system services) or <b>pkg-config systemd\n--variable=systemduserunitdir</b> (for user services). This\nwill make the services available in the system on explicit\nrequest but not activate them automatically during boot.\nOptionally, during package installation (e.g. <b>rpm -i</b>\nby the administrator), symlinks should be created in the\nsystemd configuration directories via the <b>enable</b>\ncommand of the <a href=\"https://man.page/1/systemctl\">systemctl(1)</a> tool to activate them\nautomatically on boot.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Packages\nusing <a href=\"https://man.page/1/autoconf\">autoconf(1)</a> are recommended to use a configure\nscript excerpt like the following to determine the unit\ninstallation path during source configuration:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">PKG_PROG_PKG_CONFIG\n<br>\nAC_ARG_WITH([systemdsystemunitdir], <br>\n[AS_HELP_STRING([--with-systemdsystemunitdir=DIR],\n[Directory for systemd service files])],, <br>\n[with_systemdsystemunitdir=auto]) <br>\nAS_IF([test &quot;x$with_systemdsystemunitdir&quot; =\n&quot;xyes&quot; -o &quot;x$with_systemdsystemunitdir&quot;\n= &quot;xauto&quot;], [ <br>\ndef_systemdsystemunitdir=$($PKG_CONFIG\n--variable=systemdsystemunitdir systemd)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">AS_IF([test\n&quot;x$def_systemdsystemunitdir&quot; = &quot;x&quot;],\n<br>\n[AS_IF([test &quot;x$with_systemdsystemunitdir&quot; =\n&quot;xyes&quot;], <br>\n[AC_MSG_ERROR([systemd support requested but pkg-config\nunable to query systemd package])]) <br>\nwith_systemdsystemunitdir=no], <br>\n\n[with_systemdsystemunitdir=&quot;$def_systemdsystemunitdir&quot;])])\n<br>\nAS_IF([test &quot;x$with_systemdsystemunitdir&quot; !=\n&quot;xno&quot;], <br>\n[AC_SUBST([systemdsystemunitdir],\n[$with_systemdsystemunitdir])]) <br>\nAM_CONDITIONAL([HAVE_SYSTEMD], [test\n&quot;x$with_systemdsystemunitdir&quot; !=\n&quot;xno&quot;])</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\nsnippet allows automatic installation of the unit files on\nsystemd machines, and optionally allows their installation\neven on machines lacking systemd. (Modification of this\nsnippet for the user unit directory is left as an exercise\nfor the reader.)</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Additionally,\nto ensure that <b>make distcheck</b> continues to work, it\nis recommended to add the following to the top-level\nMakefile.am file in <a href=\"https://man.page/1/automake\">automake(1)</a>-based\nprojects:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">AM_DISTCHECK_CONFIGURE_FLAGS\n= \\ <br>\n\n--with-systemdsystemunitdir=$$dc_install_base/$(systemdsystemunitdir)</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Finally,\nunit files should be installed in the system with an\nautomake excerpt like the following:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">if\nHAVE_SYSTEMD <br>\nsystemdsystemunit_DATA = \\ <br>\nfoobar.socket \\ <br>\nfoobar.service <br>\nendif</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">In\nthe <b>rpm</b>(8) .spec file, use snippets like the\nfollowing to enable/disable the service during\ninstallation/deinstallation. This makes use of the RPM\nmacros shipped along systemd. Consult the packaging\nguidelines of your distribution for details and the\nequivalent for other package managers.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">At\nthe top of the file:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">BuildRequires:\nsystemd <br>\n%{?systemd_requires}</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">And\nas scriptlets, further down:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%post\n<br>\n%systemd_post foobar.service foobar.socket</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%preun\n<br>\n%systemd_preun foobar.service foobar.socket</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%postun\n<br>\n%systemd_postun</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nthe service shall be restarted during upgrades, replace the\n&quot;%postun&quot; scriptlet above with the\nfollowing:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%postun\n<br>\n%systemd_postun_with_restart foobar.service</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Note\nthat &quot;%systemd_post&quot; and\n&quot;%systemd_preun&quot; expect the names of all units\nthat are installed/removed as arguments, separated by\nspaces. &quot;%systemd_postun&quot; expects no arguments.\n&quot;%systemd_postun_with_restart&quot; expects the units\nto restart as arguments.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nfacilitate upgrades from a package version that shipped only\nSysV init scripts to a package version that ships both a\nSysV init script and a native systemd service file, use a\nfragment like the following:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">%triggerun\n-- foobar &lt; 0.47.11-1 <br>\nif /sbin/chkconfig --level 5 foobar ; then <br>\n/bin/systemctl --no-reload enable foobar.service\nfoobar.socket &gt;/dev/null 2&gt;&amp;1 || : <br>\nfi</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Where\n0.47.11-1 is the first package version that includes the\nnative unit file. This fragment will ensure that the first\ntime the unit file is installed, it will be enabled if and\nonly if the SysV init script is enabled, thus making sure\nthat the enable status is not changed. Note that\n<b>chkconfig</b> is a command specific to Fedora which can\nbe used to check whether a SysV init script is enabled.\nOther operating systems will have to use different commands\nhere.</font></p>\n\n<h2>PORTING EXISTING DAEMONS\n<a name=\"PORTING EXISTING DAEMONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Since\nnew-style init systems such as systemd are compatible with\ntraditional SysV init systems, it is not strictly necessary\nto port existing daemons to the new style. However, doing so\noffers additional functionality to the daemons as well as\nsimplifying integration into new-style init\nsystems.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nport an existing SysV compatible daemon, the following steps\nare recommended:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">1.\nIf not already implemented, add an optional command line\nswitch to the daemon to disable daemonization. This is\nuseful not only for using the daemon in new-style init\nsystems, but also to ease debugging.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">2.\nIf the daemon offers interfaces to other software running on\nthe local system via local <b>AF_UNIX</b> sockets, consider\nimplementing socket-based activation (see above). Usually, a\nminimal patch is sufficient to implement this: Extend the\nsocket creation in the daemon code so that\n<a href=\"https://man.page/3/sd_listen_fds\">sd_listen_fds(3)</a> is checked for already passed\nsockets first. If sockets are passed (i.e. when\n<b>sd_listen_fds()</b> returns a positive value), skip the\nsocket creation step and use the passed sockets. Secondly,\nensure that the file system socket nodes for local\n<b>AF_UNIX</b> sockets used in the socket-based activation\nare not removed when the daemon shuts down, if sockets have\nbeen passed. Third, if the daemon normally closes all\nremaining open file descriptors as part of its\ninitialization, the sockets passed from the init system must\nbe spared. Since new-style init systems guarantee that no\nleft-over file descriptors are passed to executed processes,\nit might be a good choice to simply skip the closing of all\nremaining open file descriptors if sockets are\npassed.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">3.\nWrite and install a systemd unit file for the service (and\nthe sockets if socket-based activation is used, as well as a\npath unit file, if the daemon processes a spool directory),\nsee above for details.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">4.\nIf the daemon exposes interfaces via D-Bus, write and\ninstall a D-Bus activation file for the service, see above\nfor details.</font></p>\n\n<h2>PLACING DAEMON DATA\n<a name=\"PLACING DAEMON DATA\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">It\nis recommended to follow the general guidelines for placing\npackage files, as discussed in\n<a href=\"https://man.page/7/file-hierarchy\">file-hierarchy(7)</a>.</font></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><a href=\"https://man.page/1/systemd\">systemd(1)</a>,\n<a href=\"https://man.page/3/sd-daemon\">sd-daemon(3)</a>, <a href=\"https://man.page/3/sd_listen_fds\">sd_listen_fds(3)</a>,\n<a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a>, <a href=\"https://man.page/3/daemon\">daemon(3)</a>,\n<b>systemd.service</b>(5),\n<a href=\"https://man.page/7/file-hierarchy\">file-hierarchy(7)</a></font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">1.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">LSB\nrecommendations for SysV init scripts</font></p></td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/iniscrptact.html</font></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">2.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"51%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">Apple\nMacOS X Daemon Requirements</font></p></td>\n<td width=\"32%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html</font></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ACTIVATION\">ACTIVATION</a>","<a href=\"#INTEGRATION WITH SYSTEMD\">INTEGRATION WITH SYSTEMD</a>","<a href=\"#PORTING EXISTING DAEMONS\">PORTING EXISTING DAEMONS</a>","<a href=\"#PLACING DAEMON DATA\">PLACING DAEMON DATA</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#NOTES\">NOTES</a>"],"level":7}