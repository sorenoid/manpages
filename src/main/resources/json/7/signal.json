{"name":"signal","description":"signal - overview of signals","body":"\n\n<h1 align=\"center\">SIGNAL</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">signal -\noverview of signals</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux supports\nboth POSIX reliable signals (hereinafter &quot;standard\nsignals&quot;) and POSIX real-time signals.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Signal\ndispositions</b> <br>\nEach signal has a current <i>disposition</i>, which\ndetermines how the process behaves when it is delivered the\nsignal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The entries in\nthe &quot;Action&quot; column of the table below specify the\ndefault disposition for each signal, as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>Term</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>Default action is to terminate the process.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>Ign</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>Default action is to ignore the signal.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>Core</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>Default action is to terminate the process and dump core\n(see <a href=\"https://man.page/5/core\">core(5)</a>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>Stop</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>Default action is to stop the process.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>Cont</p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>Default action is to continue the process if it is\ncurrently stopped.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process can\nchange the disposition of a signal using <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>\nor <a href=\"https://man.page/2/signal\">signal(2)</a>. (The latter is less portable when\nestablishing a signal handler; see <a href=\"https://man.page/2/signal\">signal(2)</a> for\ndetails.) Using these system calls, a process can elect one\nof the following behaviors to occur on delivery of the\nsignal: perform the default action; ignore the signal; or\ncatch the signal with a <i>signal handler</i>, a\nprogrammer-defined function that is automatically invoked\nwhen the signal is delivered.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default, a\nsignal handler is invoked on the normal process stack. It is\npossible to arrange that the signal handler uses an\nalternate stack; see <a href=\"https://man.page/2/sigaltstack\">sigaltstack(2)</a> for a discussion\nof how to do this and when it might be useful.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The signal\ndisposition is a per-process attribute: in a multithreaded\napplication, the disposition of a particular signal is the\nsame for all threads.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child created\nvia <a href=\"https://man.page/2/fork\">fork(2)</a> inherits a copy of its parent&rsquo;s\nsignal dispositions. During an <a href=\"https://man.page/2/execve\">execve(2)</a>, the\ndispositions of handled signals are reset to the default;\nthe dispositions of ignored signals are left unchanged.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Sending a\nsignal</b> <br>\nThe following system calls and library functions allow the\ncaller to send a signal: <b><br>\nraise</b>(3)</p>\n\n<p style=\"margin-left:22%;\">Sends a signal to the calling\nthread.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/kill\">kill(2)</a></p>\n\n<p style=\"margin-left:22%;\">Sends a signal to a specified\nprocess, to all members of a specified process group, or to\nall processes on the system.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/pidfd_send_signal\">pidfd_send_signal(2)</a></p>\n\n<p style=\"margin-left:22%;\">Sends a signal to a process\nidentified by a PID file descriptor.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/killpg\">killpg(3)</a></p>\n\n<p style=\"margin-left:22%;\">Sends a signal to all of the\nmembers of a specified process group.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/pthread_kill\">pthread_kill(3)</a></p>\n\n<p style=\"margin-left:22%;\">Sends a signal to a specified\nPOSIX thread in the same process as the caller.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/tgkill\">tgkill(2)</a></p>\n\n<p style=\"margin-left:22%;\">Sends a signal to a specified\nthread within a specific process. (This is the system call\nused to implement <a href=\"https://man.page/3/pthread_kill\">pthread_kill(3)</a>.)</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a></p>\n\n<p style=\"margin-left:22%;\">Sends a real-time signal with\naccompanying data to a specified process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Waiting for\na signal to be caught</b> <br>\nThe following system calls suspend execution of the calling\nthread until a signal is caught (or an unhandled signal\nterminates the process): <b><br>\npause</b>(2)</p>\n\n<p style=\"margin-left:22%;\">Suspends execution until any\nsignal is caught.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sigsuspend\">sigsuspend(2)</a></p>\n\n<p style=\"margin-left:22%;\">Temporarily changes the signal\nmask (see below) and suspends execution until one of the\nunmasked signals is caught.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Synchronously\naccepting a signal</b> <br>\nRather than asynchronously catching a signal via a signal\nhandler, it is possible to synchronously accept the signal,\nthat is, to block execution until the signal is delivered,\nat which point the kernel returns information about the\nsignal to the caller. There are two general ways to do\nthis:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>, <a href=\"https://man.page/2/sigtimedwait\">sigtimedwait(2)</a>, and\n<a href=\"https://man.page/3/sigwait\">sigwait(3)</a> suspend execution until one of the signals\nin a specified set is delivered. Each of these calls returns\ninformation about the delivered signal.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/signalfd\">signalfd(2)</a> returns a file descriptor that can be\nused to read information about signals that are delivered to\nthe caller. Each <a href=\"https://man.page/2/read\">read(2)</a> from this file descriptor\nblocks until one of the signals in the set specified in the\n<a href=\"https://man.page/2/signalfd\">signalfd(2)</a> call is delivered to the caller. The\nbuffer returned by <a href=\"https://man.page/2/read\">read(2)</a> contains a structure\ndescribing the signal.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Signal mask\nand pending signals</b> <br>\nA signal may be <i>blocked</i>, which means that it will not\nbe delivered until it is later unblocked. Between the time\nwhen it is generated and when it is delivered a signal is\nsaid to be <i>pending</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each thread in\na process has an independent <i>signal mask</i>, which\nindicates the set of signals that the thread is currently\nblocking. A thread can manipulate its signal mask using\n<a href=\"https://man.page/3/pthread_sigmask\">pthread_sigmask(3)</a>. In a traditional single-threaded\napplication, <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a> can be used to manipulate\nthe signal mask.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child created\nvia <a href=\"https://man.page/2/fork\">fork(2)</a> inherits a copy of its parent&rsquo;s\nsignal mask; the signal mask is preserved across\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A signal may be\nprocess-directed or thread-directed. A process-directed\nsignal is one that is targeted at (and thus pending for) the\nprocess as a whole. A signal may be process-directed because\nit was generated by the kernel for reasons other than a\nhardware exception, or because it was sent using\n<a href=\"https://man.page/2/kill\">kill(2)</a> or <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>. A thread-directed\nsignal is one that is targeted at a specific thread. A\nsignal may be thread-directed because it was generated as a\nconsequence of executing a specific machine-language\ninstruction that triggered a hardware exception (e.g.,\n<b>SIGSEGV</b> for an invalid memory access, or\n<b>SIGFPE</b> for a math error), or because it was targeted\nat a specific thread using interfaces such as\n<a href=\"https://man.page/2/tgkill\">tgkill(2)</a> or <a href=\"https://man.page/3/pthread_kill\">pthread_kill(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\nprocess-directed signal may be delivered to any one of the\nthreads that does not currently have the signal blocked. If\nmore than one of the threads has the signal unblocked, then\nthe kernel chooses an arbitrary thread to which to deliver\nthe signal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A thread can\nobtain the set of signals that it currently has pending\nusing <a href=\"https://man.page/2/sigpending\">sigpending(2)</a>. This set will consist of the\nunion of the set of pending process-directed signals and the\nset of signals pending for the calling thread.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child created\nvia <a href=\"https://man.page/2/fork\">fork(2)</a> initially has an empty pending signal\nset; the pending signal set is preserved across an\n<a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Execution of\nsignal handlers</b> <br>\nWhenever there is a transition from kernel-mode to user-mode\nexecution (e.g., on return from a system call or scheduling\nof a thread onto the CPU), the kernel checks whether there\nis a pending unblocked signal for which the process has\nestablished a signal handler. If there is such a pending\nsignal, the following steps occur:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The kernel performs the\nnecessary preparatory steps for execution of the signal\nhandler:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">a)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"3%\"></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">The signal is removed from the\nset of pending signals.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"3%\">\n\n\n<p>b)</p></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p>If the signal handler was installed by a call to\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a> that specified the <b>SA_ONSTACK</b>\nflag and the thread has defined an alternate signal stack\n(using <a href=\"https://man.page/2/sigaltstack\">sigaltstack(2)</a>), then that stack is\ninstalled.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"3%\">\n\n\n<p>c)</p></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p>Various pieces of signal-related context are saved into\na special frame that is created on the stack. The saved\ninformation includes:</p></td></tr>\n</table>\n\n<p style=\"margin-left:20%;\">+</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\"></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">the program counter register\n(i.e., the address of the next instruction in the main\nprogram that should be executed when the signal handler\nreturns);</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\">\n\n\n<p>+</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>architecture-specific register state required for\nresuming the interrupted program;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\">\n\n\n<p>+</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>the thread&rsquo;s current signal mask;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\">\n\n\n<p>+</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>the thread&rsquo;s alternate signal stack settings.</p></td></tr>\n</table>\n\n<p style=\"margin-left:20%; margin-top: 1em\">(If the signal\nhandler was installed using the <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>\n<b>SA_SIGINFO</b> flag, then the above information is\naccessible via the <i>ucontext_t</i> object that is pointed\nto by the third argument of the signal handler.)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\">d)</p></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">Any signals specified in\n<i>act-&gt;sa_mask</i> when registering the handler with\n<a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a> are added to the thread&rsquo;s signal\nmask. The signal being delivered is also added to the signal\nmask, unless <b>SA_NODEFER</b> was specified when\nregistering the handler. These signals are thus blocked\nwhile the handler executes.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p>2.</p></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">The kernel\nconstructs a frame for the signal handler on the stack. The\nkernel sets the program counter for the thread to point to\nthe first instruction of the signal handler function, and\nconfigures the return address for that function to point to\na piece of user-space code known as the signal trampoline\n(described in <a href=\"https://man.page/2/sigreturn\">sigreturn(2)</a>).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The kernel passes control back\nto user-space, where execution commences at the start of the\nsignal handler function.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>When the signal handler returns, control passes to the\nsignal trampoline code.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>The signal trampoline calls <a href=\"https://man.page/2/sigreturn\">sigreturn(2)</a>, a\nsystem call that uses the information in the stack frame\ncreated in step 1 to restore the thread to its state before\nthe signal handler was called. The thread&rsquo;s signal\nmask and alternate signal stack settings are restored as\npart of this procedure. Upon completion of the call to\n<a href=\"https://man.page/2/sigreturn\">sigreturn(2)</a>, the kernel transfers control back to\nuser space, and the thread recommences execution at the\npoint where it was interrupted by the signal handler.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that if\nthe signal handler does not return (e.g., control is\ntransferred out of the handler using <a href=\"https://man.page/3/siglongjmp\">siglongjmp(3)</a>,\nor the handler executes a new program with\n<a href=\"https://man.page/2/execve\">execve(2)</a>), then the final step is not performed. In\nparticular, in such scenarios it is the programmer&rsquo;s\nresponsibility to restore the state of the signal mask\n(using <a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>), if it is desired to unblock\nthe signals that were blocked on entry to the signal\nhandler. (Note that <a href=\"https://man.page/3/siglongjmp\">siglongjmp(3)</a> may or may not\nrestore the signal mask, depending on the <i>savesigs</i>\nvalue that was specified in the corresponding call to\n<a href=\"https://man.page/3/sigsetjmp\">sigsetjmp(3)</a>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From the\nkernel&rsquo;s point of view, execution of the signal\nhandler code is exactly the same as the execution of any\nother user-space code. That is to say, the kernel does not\nrecord any special state information indicating that the\nthread is currently excuting inside a signal handler. All\nnecessary state information is maintained in user-space\nregisters and the user-space stack. The depth to which\nnested signal handlers may be invoked is thus limited only\nby the user-space stack (and sensible software design!).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Standard\nsignals</b> <br>\nLinux supports the standard signals listed below. The second\ncolumn of the table indicates which standard (if any)\nspecified the signal: &quot;P1990&quot; indicates that the\nsignal is described in the original POSIX.1-1990 standard;\n&quot;P2001&quot; indicates that the signal was added in\nSUSv2 and POSIX.1-2001.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3511981.png\" alt=\"Image grohtml-3511981.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The signals\n<b>SIGKILL</b> and <b>SIGSTOP</b> cannot be caught, blocked,\nor ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Up to and\nincluding Linux 2.2, the default behavior for <b>SIGSYS</b>,\n<b>SIGXCPU</b>, <b>SIGXFSZ</b>, and (on architectures other\nthan SPARC and MIPS) <b>SIGBUS</b> was to terminate the\nprocess (without a core dump). (On some other UNIX systems\nthe default action for <b>SIGXCPU</b> and <b>SIGXFSZ</b> is\nto terminate the process without a core dump.) Linux 2.4\nconforms to the POSIX.1-2001 requirements for these signals,\nterminating the process with a core dump.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SIGEMT</b>\nis not specified in POSIX.1-2001, but nevertheless appears\non most other UNIX systems, where its default action is\ntypically to terminate the process with a core dump.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SIGPWR</b>\n(which is not specified in POSIX.1-2001) is typically\nignored by default on those other UNIX systems where it\nappears.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SIGIO</b>\n(which is not specified in POSIX.1-2001) is ignored by\ndefault on several other UNIX systems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Queueing and\ndelivery semantics for standard signals</b> <br>\nIf multiple standard signals are pending for a process, the\norder in which the signals are delivered is unspecified.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Standard\nsignals do not queue. If multiple instances of a standard\nsignal are generated while that signal is blocked, then only\none instance of the signal is marked as pending (and the\nsignal will be delivered just once when it is unblocked). In\nthe case where a standard signal is already pending, the\n<i>siginfo_t</i> structure (see <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>)\nassociated with that signal is not overwritten on arrival of\nsubsequent instances of the same signal. Thus, the process\nwill receive the information associated with the first\ninstance of the signal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Signal\nnumbering for standard signals</b> <br>\nThe numeric value for each signal is given in the table\nbelow. As shown in the table, many signals have different\nnumeric values on different architectures. The first numeric\nvalue in each table row shows the signal number on x86, ARM,\nand most other architectures; the second value is for Alpha\nand SPARC; the third is for MIPS; and the last is for\nPARISC. A dash (-) denotes that a signal is absent on the\ncorresponding architecture.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3511982.png\" alt=\"Image grohtml-3511982.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note the\nfollowing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Where defined, <b>SIGUNUSED</b>\nis synonymous with <b>SIGSYS</b>. Since glibc 2.26,\n<b>SIGUNUSED</b> is no longer defined on any\narchitecture.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Signal 29 is <b>SIGINFO</b>/<b>SIGPWR</b> (synonyms for\nthe same value) on Alpha but <b>SIGLOST</b> on SPARC.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Real-time\nsignals</b> <br>\nStarting with version 2.2, Linux supports real-time signals\nas originally defined in the POSIX.1b real-time extensions\n(and now included in POSIX.1-2001). The range of supported\nreal-time signals is defined by the macros <b>SIGRTMIN</b>\nand <b>SIGRTMAX</b>. POSIX.1-2001 requires that an\nimplementation support at least <b>_POSIX_RTSIG_MAX</b> (8)\nreal-time signals.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux\nkernel supports a range of 33 different real-time signals,\nnumbered 32 to 64. However, the glibc POSIX threads\nimplementation internally uses two (for NPTL) or three (for\nLinuxThreads) real-time signals (see <a href=\"https://man.page/7/pthreads\">pthreads(7)</a>),\nand adjusts the value of <b>SIGRTMIN</b> suitably (to 34 or\n35). Because the range of available real-time signals varies\naccording to the glibc threading implementation (and this\nvariation can occur at run time according to the available\nkernel and glibc), and indeed the range of real-time signals\nvaries across UNIX systems, programs should <i>never refer\nto real-time signals using hard-coded numbers</i>, but\ninstead should always refer to real-time signals using the\nnotation <b>SIGRTMIN</b>+n, and include suitable (run-time)\nchecks that <b>SIGRTMIN</b>+n does not exceed\n<b>SIGRTMAX</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Unlike standard\nsignals, real-time signals have no predefined meanings: the\nentire set of real-time signals can be used for\napplication-defined purposes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\naction for an unhandled real-time signal is to terminate the\nreceiving process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Real-time\nsignals are distinguished by the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Multiple instances of real-time\nsignals can be queued. By contrast, if multiple instances of\na standard signal are delivered while that signal is\ncurrently blocked, then only one instance is queued.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>If the signal is sent using <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>, an\naccompanying value (either an integer or a pointer) can be\nsent with the signal. If the receiving process establishes a\nhandler for this signal using the <b>SA_SIGINFO</b> flag to\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>, then it can obtain this data via the\n<i>si_value</i> field of the <i>siginfo_t</i> structure\npassed as the second argument to the handler. Furthermore,\nthe <i>si_pid</i> and <i>si_uid</i> fields of this structure\ncan be used to obtain the PID and real user ID of the\nprocess sending the signal.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Real-time signals are delivered in a guaranteed order.\nMultiple real-time signals of the same type are delivered in\nthe order they were sent. If different real-time signals are\nsent to a process, they are delivered starting with the\nlowest-numbered signal. (I.e., low-numbered signals have\nhighest priority.) By contrast, if multiple standard signals\nare pending for a process, the order in which they are\ndelivered is unspecified.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If both\nstandard and real-time signals are pending for a process,\nPOSIX leaves it unspecified which is delivered first. Linux,\nlike many other implementations, gives priority to standard\nsignals in this case.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX, an implementation should permit at least\n<b>_POSIX_SIGQUEUE_MAX</b> (32) real-time signals to be\nqueued to a process. However, Linux does things differently.\nIn kernels up to and including 2.6.7, Linux imposes a\nsystem-wide limit on the number of queued real-time signals\nfor all processes. This limit can be viewed and (with\nprivilege) changed via the <i>/proc/sys/kernel/rtsig-max</i>\nfile. A related file, <i>/proc/sys/kernel/rtsig-nr</i>, can\nbe used to find out how many real-time signals are currently\nqueued. In Linux 2.6.8, these <i>/proc</i> interfaces were\nreplaced by the <b>RLIMIT_SIGPENDING</b> resource limit,\nwhich specifies a per-user limit for queued signals; see\n<a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a> for further details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The addition of\nreal-time signals required the widening of the signal set\nstructure (<i>sigset_t</i>) from 32 to 64 bits.\nConsequently, various system calls were superseded by new\nsystem calls that supported the larger signal sets. The old\nand new system calls are as follows:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3511983.png\" alt=\"Image grohtml-3511983.png\"></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Interruption\nof system calls and library functions by signal handlers</b>\n<br>\nIf a signal handler is invoked while a system call or\nlibrary function call is blocked, then either:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">the call is automatically\nrestarted after the signal handler returns; or</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>the call fails with the error <b>EINTR</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Which of these\ntwo behaviors occurs depends on the interface and whether or\nnot the signal handler was established using the\n<b>SA_RESTART</b> flag (see <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>). The\ndetails vary across UNIX systems; below, the details for\nLinux.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a blocked\ncall to one of the following interfaces is interrupted by a\nsignal handler, then the call is automatically restarted\nafter the signal handler returns if the <b>SA_RESTART</b>\nflag was used; otherwise the call fails with the error\n<b>EINTR</b>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\"><a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/readv\">readv(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/2/writev\">writev(2)</a>, and <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> calls\non &quot;slow&quot; devices. A &quot;slow&quot; device is\none where the I/O call may block for an indefinite time, for\nexample, a terminal, pipe, or socket. If an I/O call on a\nslow device has already transferred some data by the time it\nis interrupted by a signal handler, then the call will\nreturn a success status (normally, the number of bytes\ntransferred). Note that a (local) disk is not a slow device\naccording to this definition; I/O operations on disk devices\nare not interrupted by signals.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/open\">open(2)</a>, if it can block (e.g., when opening a\nFIFO; see <a href=\"https://man.page/7/fifo\">fifo(7)</a>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/wait\">wait(2)</a>, <a href=\"https://man.page/2/wait3\">wait3(2)</a>, <a href=\"https://man.page/2/wait4\">wait4(2)</a>,\n<a href=\"https://man.page/2/waitid\">waitid(2)</a>, and <a href=\"https://man.page/2/waitpid\">waitpid(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Socket interfaces: <a href=\"https://man.page/2/accept\">accept(2)</a>, <a href=\"https://man.page/2/connect\">connect(2)</a>,\n<a href=\"https://man.page/2/recv\">recv(2)</a>, <a href=\"https://man.page/2/recvfrom\">recvfrom(2)</a>, <a href=\"https://man.page/2/recvmmsg\">recvmmsg(2)</a>,\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>, <a href=\"https://man.page/2/send\">send(2)</a>, <a href=\"https://man.page/2/sendto\">sendto(2)</a>, and\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>, unless a timeout has been set on the\nsocket (see below).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>File locking interfaces: <a href=\"https://man.page/2/flock\">flock(2)</a> and the\n<b>F_SETLKW</b> and <b>F_OFD_SETLKW</b> operations of\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a></p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>POSIX message queue interfaces: <a href=\"https://man.page/3/mq_receive\">mq_receive(3)</a>,\n<a href=\"https://man.page/3/mq_timedreceive\">mq_timedreceive(3)</a>, <a href=\"https://man.page/3/mq_send\">mq_send(3)</a>, and\n<a href=\"https://man.page/3/mq_timedsend\">mq_timedsend(3)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/futex\">futex(2)</a> <b>FUTEX_WAIT</b> (since Linux 2.6.22;\nbeforehand, always failed with <b>EINTR</b>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/getrandom\">getrandom(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/3/pthread_mutex_lock\">pthread_mutex_lock(3)</a>,\n<a href=\"https://man.page/3/pthread_cond_wait\">pthread_cond_wait(3)</a>, and related APIs.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/futex\">futex(2)</a> <b>FUTEX_WAIT_BITSET</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>POSIX semaphore interfaces: <a href=\"https://man.page/3/sem_wait\">sem_wait(3)</a> and\n<a href=\"https://man.page/3/sem_timedwait\">sem_timedwait(3)</a> (since Linux 2.6.22; beforehand,\nalways failed with <b>EINTR</b>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/read\">read(2)</a> from an <a href=\"https://man.page/7/inotify\">inotify(7)</a> file descriptor\n(since Linux 3.8; beforehand, always failed with\n<b>EINTR</b>).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\ninterfaces are never restarted after being interrupted by a\nsignal handler, regardless of the use of <b>SA_RESTART</b>;\nthey always fail with the error <b>EINTR</b> when\ninterrupted by a signal handler:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">&quot;Input&quot; socket\ninterfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been set\non the socket using <a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a>: <a href=\"https://man.page/2/accept\">accept(2)</a>,\n<a href=\"https://man.page/2/recv\">recv(2)</a>, <a href=\"https://man.page/2/recvfrom\">recvfrom(2)</a>, <a href=\"https://man.page/2/recvmmsg\">recvmmsg(2)</a> (also\nwith a non-NULL <i>timeout</i> argument), and\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>&quot;Output&quot; socket interfaces, when a timeout\n(<b>SO_RCVTIMEO</b>) has been set on the socket using\n<a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a>: <a href=\"https://man.page/2/connect\">connect(2)</a>, <a href=\"https://man.page/2/send\">send(2)</a>,\n<a href=\"https://man.page/2/sendto\">sendto(2)</a>, and <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Interfaces used to wait for signals: <a href=\"https://man.page/2/pause\">pause(2)</a>,\n<a href=\"https://man.page/2/sigsuspend\">sigsuspend(2)</a>, <a href=\"https://man.page/2/sigtimedwait\">sigtimedwait(2)</a>, and\n<a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>File descriptor multiplexing interfaces:\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>, <a href=\"https://man.page/2/epoll_pwait\">epoll_pwait(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>,\n<a href=\"https://man.page/2/ppoll\">ppoll(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>, and\n<a href=\"https://man.page/2/pselect\">pselect(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>System V IPC interfaces: <a href=\"https://man.page/2/msgrcv\">msgrcv(2)</a>,\n<a href=\"https://man.page/2/msgsnd\">msgsnd(2)</a>, <a href=\"https://man.page/2/semop\">semop(2)</a>, and\n<a href=\"https://man.page/2/semtimedop\">semtimedop(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Sleep interfaces: <a href=\"https://man.page/2/clock_nanosleep\">clock_nanosleep(2)</a>,\n<a href=\"https://man.page/2/nanosleep\">nanosleep(2)</a>, and <a href=\"https://man.page/3/usleep\">usleep(3)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/io_getevents\">io_getevents(2)</a>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/3/sleep\">sleep(3)</a> function is also never restarted if\ninterrupted by a handler, but gives a success return: the\nnumber of seconds remaining to sleep.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Interruption\nof system calls and library functions by stop signals</b>\n<br>\nOn Linux, even in the absence of signal handlers, certain\nblocking interfaces can fail with the error <b>EINTR</b>\nafter the process is stopped by one of the stop signals and\nthen resumed via <b>SIGCONT</b>. This behavior is not\nsanctioned by POSIX.1, and doesn&rsquo;t occur on other\nsystems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux\ninterfaces that display this behavior are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">&quot;Input&quot; socket\ninterfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been set\non the socket using <a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a>: <a href=\"https://man.page/2/accept\">accept(2)</a>,\n<a href=\"https://man.page/2/recv\">recv(2)</a>, <a href=\"https://man.page/2/recvfrom\">recvfrom(2)</a>, <a href=\"https://man.page/2/recvmmsg\">recvmmsg(2)</a> (also\nwith a non-NULL <i>timeout</i> argument), and\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>&quot;Output&quot; socket interfaces, when a timeout\n(<b>SO_RCVTIMEO</b>) has been set on the socket using\n<a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a>: <a href=\"https://man.page/2/connect\">connect(2)</a>, <a href=\"https://man.page/2/send\">send(2)</a>,\n<a href=\"https://man.page/2/sendto\">sendto(2)</a>, and <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>, if a send timeout\n(<b>SO_SNDTIMEO</b>) has been set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>, <a href=\"https://man.page/2/epoll_pwait\">epoll_pwait(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/semop\">semop(2)</a>, <a href=\"https://man.page/2/semtimedop\">semtimedop(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/sigtimedwait\">sigtimedwait(2)</a>, <a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Linux 3.7 and earlier: <a href=\"https://man.page/2/read\">read(2)</a> from an\n<a href=\"https://man.page/7/inotify\">inotify(7)</a> file descriptor</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Linux 2.6.21 and earlier: <a href=\"https://man.page/2/futex\">futex(2)</a>\n<b>FUTEX_WAIT</b>, <a href=\"https://man.page/3/sem_timedwait\">sem_timedwait(3)</a>,\n<a href=\"https://man.page/3/sem_wait\">sem_wait(3)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Linux 2.6.8 and earlier: <a href=\"https://man.page/2/msgrcv\">msgrcv(2)</a>,\n<a href=\"https://man.page/2/msgsnd\">msgsnd(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Linux 2.4 and earlier: <a href=\"https://man.page/2/nanosleep\">nanosleep(2)</a>.</p></td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1, except\nas noted.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a\ndiscussion of async-signal-safe functions, see\n<a href=\"https://man.page/7/signal-safety\">signal-safety(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>/proc/[pid]/task/[tid]/status</i> file contains various\nfields that show the signals that a thread is blocking\n(<i>SigBlk</i>), catching (<i>SigCgt</i>), or ignoring\n(<i>SigIgn</i>). (The set of signals that are caught or\nignored will be the same across all threads in a process.)\nOther fields show the set of pending signals that are\ndirected to the thread (<i>SigPnd</i>) as well as the set of\npending signals that are directed to the process as a whole\n(<i>ShdPnd</i>). The corresponding fields in\n<i>/proc/[pid]/status</i> show the information for the main\nthread. See <a href=\"https://man.page/5/proc\">proc(5)</a> for further details.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are six\nsignals that can be delivered as a consequence of a hardware\nexception: <b>SIGBUS</b>, <b>SIGEMT</b>, <b>SIGFPE</b>,\n<b>SIGILL</b>, <b>SIGSEGV</b>, and <b>SIGTRAP</b>. Which of\nthese signals is delivered, for any given hardware\nexception, is not documented and does not always make\nsense.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example, an\ninvalid memory access that causes delivery of <b>SIGSEGV</b>\non one CPU architecture may cause delivery of <b>SIGBUS</b>\non another architecture, or vice versa.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For another\nexample, using the x86 <i>int</i> instruction with a\nforbidden argument (any number other than 3 or 128) causes\ndelivery of <b>SIGSEGV</b>, even though <b>SIGILL</b> would\nmake more sense, because of how the CPU reports the\nforbidden operation to the kernel.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/kill\">kill(1)</a>,\n<a href=\"https://man.page/2/clone\">clone(2)</a>, <a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>, <a href=\"https://man.page/2/kill\">kill(2)</a>,\n<a href=\"https://man.page/2/pidfd_send_signal\">pidfd_send_signal(2)</a>, <a href=\"https://man.page/2/restart_syscall\">restart_syscall(2)</a>,\n<a href=\"https://man.page/2/rt_sigqueueinfo\">rt_sigqueueinfo(2)</a>, <a href=\"https://man.page/2/setitimer\">setitimer(2)</a>,\n<a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>, <a href=\"https://man.page/2/sgetmask\">sgetmask(2)</a>,\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>, <a href=\"https://man.page/2/sigaltstack\">sigaltstack(2)</a>,\n<a href=\"https://man.page/2/signal\">signal(2)</a>, <a href=\"https://man.page/2/signalfd\">signalfd(2)</a>, <a href=\"https://man.page/2/sigpending\">sigpending(2)</a>,\n<a href=\"https://man.page/2/sigprocmask\">sigprocmask(2)</a>, <a href=\"https://man.page/2/sigreturn\">sigreturn(2)</a>,\n<a href=\"https://man.page/2/sigsuspend\">sigsuspend(2)</a>, <a href=\"https://man.page/2/sigwaitinfo\">sigwaitinfo(2)</a>,\n<a href=\"https://man.page/3/abort\">abort(3)</a>, <a href=\"https://man.page/3/bsd_signal\">bsd_signal(3)</a>, <a href=\"https://man.page/3/killpg\">killpg(3)</a>,\n<a href=\"https://man.page/3/longjmp\">longjmp(3)</a>, <a href=\"https://man.page/3/pthread_sigqueue\">pthread_sigqueue(3)</a>,\n<a href=\"https://man.page/3/raise\">raise(3)</a>, <a href=\"https://man.page/3/sigqueue\">sigqueue(3)</a>, <a href=\"https://man.page/3/sigset\">sigset(3)</a>,\n<a href=\"https://man.page/3/sigsetops\">sigsetops(3)</a>, <a href=\"https://man.page/3/sigvec\">sigvec(3)</a>, <a href=\"https://man.page/3/sigwait\">sigwait(3)</a>,\n<a href=\"https://man.page/3/strsignal\">strsignal(3)</a>, <a href=\"https://man.page/3/swapcontext\">swapcontext(3)</a>,\n<a href=\"https://man.page/3/sysv_signal\">sysv_signal(3)</a>, <a href=\"https://man.page/5/core\">core(5)</a>, <a href=\"https://man.page/5/proc\">proc(5)</a>,\n<a href=\"https://man.page/7/nptl\">nptl(7)</a>, <a href=\"https://man.page/7/pthreads\">pthreads(7)</a>, <a href=\"https://man.page/7/sigevent\">sigevent(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}