{"name":"pipe","description":"pipe - overview\nof pipes and FIFOs\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nPipes and FIFOs\n(also known as named pipes) provide a unidirectional\ninterprocess communication channel. A pipe has a <i>read\nend</i> and a <i>write end</i>. Data written to the write\nend of a pipe can be read from the read end of the pipe.\n\nA pipe is\ncreated using <a href=\"https://man.page/2/pipe\">pipe(2)</a>, which creates a new pipe and\nreturns two file descriptors, one referring to the read end\nof the pipe, the other referring to the write end. Pipes can\nbe used to create a communication channel between related\nprocesses; see <a href=\"https://man.page/2/pipe\">pipe(2)</a> for an example.\n\nA FIFO (short\nfor First In First Out) has a name within the filesystem\n(created using <a href=\"https://man.page/3/mkfifo\">mkfifo(3)</a>), and is opened using\n<a href=\"https://man.page/2/open\">open(2)</a>. Any process may open a FIFO, assuming the\nfile permissions allow it. The read end is opened using the\n<b>O_RDONLY</b> flag; the write end is opened using the\n<b>O_WRONLY</b> flag. See <a href=\"https://man.page/7/fifo\">fifo(7)</a> for further\ndetails. <i>Note</i>: although FIFOs have a pathname in the\nfilesystem, I/O on FIFOs does not involve operations on the\nunderlying device (if there is one).\n\n<b>I/O on pipes\nand FIFOs</b> <br>\nThe only difference between pipes and FIFOs is the manner in\nwhich they are created and opened. Once these tasks have\nbeen accomplished, I/O on pipes and FIFOs has exactly the\nsame semantics.\n\nIf a process\nattempts to read from an empty pipe, then <a href=\"https://man.page/2/read\">read(2)</a>\nwill block until data is available. If a process attempts to\nwrite to a full pipe (see below), then <a href=\"https://man.page/2/write\">write(2)</a>\nblocks until sufficient data has been read from the pipe to\nallow the write to complete. Nonblocking I/O is possible by\nusing the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_SETFL</b> operation to enable\nthe <b>O_NONBLOCK</b> open file status flag.\n\nThe\ncommunication channel provided by a pipe is a <i>byte\nstream</i>: there is no concept of message boundaries.\n\nIf all file\ndescriptors referring to the write end of a pipe have been\nclosed, then an attempt to <a href=\"https://man.page/2/read\">read(2)</a> from the pipe will\nsee end-of-file (<a href=\"https://man.page/2/read\">read(2)</a> will return 0). If all file\ndescriptors referring to the read end of a pipe have been\nclosed, then a <a href=\"https://man.page/2/write\">write(2)</a> will cause a <b>SIGPIPE</b>\nsignal to be generated for the calling process. If the\ncalling process is ignoring this signal, then\n<a href=\"https://man.page/2/write\">write(2)</a> fails with the error <b>EPIPE</b>. An\napplication that uses <a href=\"https://man.page/2/pipe\">pipe(2)</a> and <a href=\"https://man.page/2/fork\">fork(2)</a>\nshould use suitable <a href=\"https://man.page/2/close\">close(2)</a> calls to close\nunnecessary duplicate file descriptors; this ensures that\nend-of-file and <b>SIGPIPE</b>/<b>EPIPE</b> are delivered\nwhen appropriate.\n\nIt is not\npossible to apply <a href=\"https://man.page/2/lseek\">lseek(2)</a> to a pipe.\n\n<b>Pipe\ncapacity</b> <br>\nA pipe has a limited capacity. If the pipe is full, then a\n<a href=\"https://man.page/2/write\">write(2)</a> will block or fail, depending on whether the\n<b>O_NONBLOCK</b> flag is set (see below). Different\nimplementations have different limits for the pipe capacity.\nApplications should not rely on a particular capacity: an\napplication should be designed so that a reading process\nconsumes data as soon as it is available, so that a writing\nprocess does not remain blocked.\n\nIn Linux\nversions before 2.6.11, the capacity of a pipe was the same\nas the system page size (e.g., 4096 bytes on i386). Since\nLinux 2.6.11, the pipe capacity is 16 pages (i.e., 65,536\nbytes in a system with a page size of 4096 bytes). Since\nLinux 2.6.35, the default pipe capacity is 16 pages, but the\ncapacity can be queried and set using the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>\n<b>F_GETPIPE_SZ</b> and <b>F_SETPIPE_SZ</b> operations. See\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a> for more information.\n\nThe following\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operation, which can be applied to a file\ndescriptor that refers to either end of a pipe, places a\ncount of the number of unread bytes in the pipe in the\n<i>int</i> buffer pointed to by the final argument of the\ncall:\n\nioctl(fd,\nFIONREAD, &amp;nbytes);\n\nThe\n<b>FIONREAD</b> operation is not specified in any standard,\nbut is provided on many implementations.\n\n<b>/proc\nfiles</b> <br>\nOn Linux, the following files control how much memory can be\nused for pipes: <i><br>\n/proc/sys/fs/pipe-max-pages</i> (only in Linux 2.6.34)\n\n<p style=\"margin-left:22%;\">An upper limit, in pages, on\nthe capacity that an unprivileged user (one without the\n<b>CAP_SYS_RESOURCE</b> capability) can set for a pipe.\n\n<p style=\"margin-left:22%; margin-top: 1em\">The default\nvalue for this limit is 16 times the default pipe capacity\n(see above); the lower limit is two pages.\n\n<p style=\"margin-left:22%; margin-top: 1em\">This interface\nwas removed in Linux 2.6.35, in favor of\n<i>/proc/sys/fs/pipe-max-size</i>.\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/pipe-max-size</i>\n(since Linux 2.6.35)\n\n<p style=\"margin-left:22%;\">The maximum size (in bytes) of\nindividual pipes that can be set by users without the\n<b>CAP_SYS_RESOURCE</b> capability. The value assigned to\nthis file may be rounded upward, to reflect the value\nactually employed for a convenient implementation. To\ndetermine the rounded-up value, display the contents of this\nfile after assigning a value to it.\n\n<p style=\"margin-left:22%; margin-top: 1em\">The default\nvalue for this file is 1048576 (1&nbsp;MiB). The minimum\nvalue that can be assigned to this file is the system page\nsize. Attempts to set a limit less than the page size cause\n<a href=\"https://man.page/2/write\">write(2)</a> to fail with the error <b>EINVAL</b>.\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux\n4.9, the value on this file also acts as a ceiling on the\ndefault capacity of a new pipe or newly opened FIFO.\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/pipe-user-pages-hard</i>\n(since Linux 4.5)\n\n<p style=\"margin-left:22%;\">The hard limit on the total\nsize (in pages) of all pipes created or set by a single\nunprivileged user (i.e., one with neither the\n<b>CAP_SYS_RESOURCE</b> nor the <b>CAP_SYS_ADMIN</b>\ncapability). So long as the total number of pages allocated\nto pipe buffers for this user is at this limit, attempts to\ncreate new pipes will be denied, and attempts to increase a\npipe&rsquo;s capacity will be denied.\n\n<p style=\"margin-left:22%; margin-top: 1em\">When the value\nof this limit is zero (which is the default), no hard limit\nis applied.\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/pipe-user-pages-soft</i>\n(since Linux 4.5)\n\n<p style=\"margin-left:22%;\">The soft limit on the total\nsize (in pages) of all pipes created or set by a single\nunprivileged user (i.e., one with neither the\n<b>CAP_SYS_RESOURCE</b> nor the <b>CAP_SYS_ADMIN</b>\ncapability). So long as the total number of pages allocated\nto pipe buffers for this user is at this limit, individual\npipes created by a user will be limited to one page, and\nattempts to increase a pipe&rsquo;s capacity will be\ndenied.\n\n<p style=\"margin-left:22%; margin-top: 1em\">When the value\nof this limit is zero, no soft limit is applied. The default\nvalue for this file is 16384, which permits creating up to\n1024 pipes with the default capacity.\n\nBefore Linux\n4.9, some bugs affected the handling of the\n<i>pipe-user-pages-soft</i> and <i>pipe-user-pages-hard</i>\nlimits; see BUGS.\n\n\n<b>PIPE_BUF</b>\n<br>\nPOSIX.1 says that <a href=\"https://man.page/2/write\">write(2)</a>s of less than\n<b>PIPE_BUF</b> bytes must be atomic: the output data is\nwritten to the pipe as a contiguous sequence. Writes of more\nthan <b>PIPE_BUF</b> bytes may be nonatomic: the kernel may\ninterleave the data with data written by other processes.\nPOSIX.1 requires <b>PIPE_BUF</b> to be at least 512 bytes.\n(On Linux, <b>PIPE_BUF</b> is 4096 bytes.) The precise\nsemantics depend on whether the file descriptor is\nnonblocking (<b>O_NONBLOCK</b>), whether there are multiple\nwriters to the pipe, and on <i>n</i>, the number of bytes to\nbe written: <b><br>\nO_NONBLOCK</b> disabled, <i>n</i> &lt;= <b>PIPE_BUF</b>\n\n<p style=\"margin-left:22%;\">All <i>n</i> bytes are written\natomically; <a href=\"https://man.page/2/write\">write(2)</a> may block if there is not room\nfor <i>n</i> bytes to be written immediately\n\n<p style=\"margin-left:11%;\"><b>O_NONBLOCK</b> enabled,\n<i>n</i> &lt;= <b>PIPE_BUF</b>\n\n<p style=\"margin-left:22%;\">If there is room to write\n<i>n</i> bytes to the pipe, then <a href=\"https://man.page/2/write\">write(2)</a> succeeds\nimmediately, writing all <i>n</i> bytes; otherwise\n<a href=\"https://man.page/2/write\">write(2)</a> fails, with <i>errno</i> set to\n<b>EAGAIN</b>.\n\n<p style=\"margin-left:11%;\"><b>O_NONBLOCK</b> disabled,\n<i>n</i> &gt; <b>PIPE_BUF</b>\n\n<p style=\"margin-left:22%;\">The write is nonatomic: the\ndata given to <a href=\"https://man.page/2/write\">write(2)</a> may be interleaved with\n<a href=\"https://man.page/2/write\">write(2)</a>s by other process; the <a href=\"https://man.page/2/write\">write(2)</a>\nblocks until <i>n</i> bytes have been written.\n\n<p style=\"margin-left:11%;\"><b>O_NONBLOCK</b> enabled,\n<i>n</i> &gt; <b>PIPE_BUF</b>\n\n<p style=\"margin-left:22%;\">If the pipe is full, then\n<a href=\"https://man.page/2/write\">write(2)</a> fails, with <i>errno</i> set to\n<b>EAGAIN</b>. Otherwise, from 1 to <i>n</i> bytes may be\nwritten (i.e., a &quot;partial write&quot; may occur; the\ncaller should check the return value from <a href=\"https://man.page/2/write\">write(2)</a> to\nsee how many bytes were actually written), and these bytes\nmay be interleaved with writes by other processes.\n\n<b>Open file\nstatus flags</b> <br>\nThe only open file status flags that can be meaningfully\napplied to a pipe or FIFO are <b>O_NONBLOCK</b> and\n<b>O_ASYNC</b>.\n\nSetting the\n<b>O_ASYNC</b> flag for the read end of a pipe causes a\nsignal (<b>SIGIO</b> by default) to be generated when new\ninput becomes available on the pipe. The target for delivery\nof signals must be set using the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>\n<b>F_SETOWN</b> command. On Linux, <b>O_ASYNC</b> is\nsupported for pipes and FIFOs only since kernel 2.6.\n\n<b>Portability\nnotes</b> <br>\nOn some systems (but not Linux), pipes are bidirectional:\ndata can be transmitted in both directions between the pipe\nends. POSIX.1 requires only unidirectional pipes. Portable\napplications should avoid reliance on bidirectional pipe\nsemantics.\n\n<b>BUGS</b>\n<br>\nBefore Linux 4.9, some bugs affected the handling of the\n<i>pipe-user-pages-soft</i> and <i>pipe-user-pages-hard</i>\nlimits when using the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_SETPIPE_SZ</b>\noperation to change a pipe&rsquo;s capacity:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>(1)</td>\n<td width=\"3%\"></td>\n<td width=\"82%\">\n\n\n<p>When increasing the pipe capacity, the checks against\nthe soft and hard limits were made against existing\nconsumption, and excluded the memory required for the\nincreased pipe capacity. The new increase in pipe capacity\ncould then push the total memory used by the user for pipes\n(possibly far) over a limit. (This could also trigger the\nproblem described next.)</td></tr>\n</table>\n\n<p style=\"margin-left:18%; margin-top: 1em\">Starting with\nLinux 4.9, the limit checking includes the memory required\nfor the new pipe capacity.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">(2)</td>\n<td width=\"3%\"></td>\n<td width=\"82%\">\n\n\n<p style=\"margin-top: 1em\">The limit checks were performed\neven when the new pipe capacity was less than the existing\npipe capacity. This could lead to problems if a user set a\nlarge pipe capacity, and then the limits were lowered, with\nthe result that the user could no longer decrease the pipe\ncapacity. </td></tr>\n</table>\n\n<p style=\"margin-left:18%; margin-top: 1em\">Starting with\nLinux 4.9, checks against the limits are performed only when\nincreasing a pipe&rsquo;s capacity; an unprivileged user can\nalways decrease a pipe&rsquo;s capacity.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">(3)</td>\n<td width=\"3%\"></td>\n<td width=\"82%\">\n\n\n<p style=\"margin-top: 1em\">The accounting and checking\nagainst the limits were done as follows:</td></tr>\n</table>\n\n<p style=\"margin-left:18%;\">(a)\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"18%\"></td>\n<td width=\"5%\"></td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p style=\"margin-top: 1em\">Test whether the user has\nexceeded the limit.</td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"18%\"></td>\n<td width=\"5%\">\n\n\n<p>(b)</td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p>Make the new pipe buffer allocation.</td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"18%\"></td>\n<td width=\"5%\">\n\n\n<p>(c)</td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p>Account new allocation against the limits.</td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:18%; margin-top: 1em\">This was racey.\nMultiple processes could pass point (a) simultaneously, and\nthen allocate pipe buffers that were accounted for only in\nstep (c), with the result that the user&rsquo;s pipe buffer\nallocation could be pushed over the limit.\n\n<p style=\"margin-left:18%; margin-top: 1em\">Starting with\nLinux 4.9, the accounting step is performed before doing the\nallocation, and the operation fails if the limit would be\nexceeded.\n\nBefore Linux\n4.9, bugs similar to points (1) and (3) could also occur\nwhen the kernel allocated memory for a new pipe buffer; that\nis, when calling <a href=\"https://man.page/2/pipe\">pipe(2)</a> and when opening a\npreviously unopened FIFO.\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/1/mkfifo\">mkfifo(1)</a>,\n<a href=\"https://man.page/2/dup\">dup(2)</a>, <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, <a href=\"https://man.page/2/open\">open(2)</a>,\n<a href=\"https://man.page/2/pipe\">pipe(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/socketpair\">socketpair(2)</a>, <a href=\"https://man.page/2/splice\">splice(2)</a>, <a href=\"https://man.page/2/stat\">stat(2)</a>,\n<a href=\"https://man.page/2/tee\">tee(2)</a>, <a href=\"https://man.page/2/vmsplice\">vmsplice(2)</a>, <a href=\"https://man.page/3/mkfifo\">mkfifo(3)</a>,\n<a href=\"https://man.page/7/epoll\">epoll(7)</a>, <a href=\"https://man.page/7/fifo\">fifo(7)</a>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\nThis page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.","body":"\n\n<h1 align=\"center\">PIPE</h1>\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pipe - overview\nof pipes and FIFOs</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Pipes and FIFOs\n(also known as named pipes) provide a unidirectional\ninterprocess communication channel. A pipe has a <i>read\nend</i> and a <i>write end</i>. Data written to the write\nend of a pipe can be read from the read end of the pipe.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A pipe is\ncreated using <a href=\"https://man.page/2/pipe\">pipe(2)</a>, which creates a new pipe and\nreturns two file descriptors, one referring to the read end\nof the pipe, the other referring to the write end. Pipes can\nbe used to create a communication channel between related\nprocesses; see <a href=\"https://man.page/2/pipe\">pipe(2)</a> for an example.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A FIFO (short\nfor First In First Out) has a name within the filesystem\n(created using <a href=\"https://man.page/3/mkfifo\">mkfifo(3)</a>), and is opened using\n<a href=\"https://man.page/2/open\">open(2)</a>. Any process may open a FIFO, assuming the\nfile permissions allow it. The read end is opened using the\n<b>O_RDONLY</b> flag; the write end is opened using the\n<b>O_WRONLY</b> flag. See <a href=\"https://man.page/7/fifo\">fifo(7)</a> for further\ndetails. <i>Note</i>: although FIFOs have a pathname in the\nfilesystem, I/O on FIFOs does not involve operations on the\nunderlying device (if there is one).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>I/O on pipes\nand FIFOs</b> <br>\nThe only difference between pipes and FIFOs is the manner in\nwhich they are created and opened. Once these tasks have\nbeen accomplished, I/O on pipes and FIFOs has exactly the\nsame semantics.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a process\nattempts to read from an empty pipe, then <a href=\"https://man.page/2/read\">read(2)</a>\nwill block until data is available. If a process attempts to\nwrite to a full pipe (see below), then <a href=\"https://man.page/2/write\">write(2)</a>\nblocks until sufficient data has been read from the pipe to\nallow the write to complete. Nonblocking I/O is possible by\nusing the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_SETFL</b> operation to enable\nthe <b>O_NONBLOCK</b> open file status flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\ncommunication channel provided by a pipe is a <i>byte\nstream</i>: there is no concept of message boundaries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If all file\ndescriptors referring to the write end of a pipe have been\nclosed, then an attempt to <a href=\"https://man.page/2/read\">read(2)</a> from the pipe will\nsee end-of-file (<a href=\"https://man.page/2/read\">read(2)</a> will return 0). If all file\ndescriptors referring to the read end of a pipe have been\nclosed, then a <a href=\"https://man.page/2/write\">write(2)</a> will cause a <b>SIGPIPE</b>\nsignal to be generated for the calling process. If the\ncalling process is ignoring this signal, then\n<a href=\"https://man.page/2/write\">write(2)</a> fails with the error <b>EPIPE</b>. An\napplication that uses <a href=\"https://man.page/2/pipe\">pipe(2)</a> and <a href=\"https://man.page/2/fork\">fork(2)</a>\nshould use suitable <a href=\"https://man.page/2/close\">close(2)</a> calls to close\nunnecessary duplicate file descriptors; this ensures that\nend-of-file and <b>SIGPIPE</b>/<b>EPIPE</b> are delivered\nwhen appropriate.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is not\npossible to apply <a href=\"https://man.page/2/lseek\">lseek(2)</a> to a pipe.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Pipe\ncapacity</b> <br>\nA pipe has a limited capacity. If the pipe is full, then a\n<a href=\"https://man.page/2/write\">write(2)</a> will block or fail, depending on whether the\n<b>O_NONBLOCK</b> flag is set (see below). Different\nimplementations have different limits for the pipe capacity.\nApplications should not rely on a particular capacity: an\napplication should be designed so that a reading process\nconsumes data as soon as it is available, so that a writing\nprocess does not remain blocked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux\nversions before 2.6.11, the capacity of a pipe was the same\nas the system page size (e.g., 4096 bytes on i386). Since\nLinux 2.6.11, the pipe capacity is 16 pages (i.e., 65,536\nbytes in a system with a page size of 4096 bytes). Since\nLinux 2.6.35, the default pipe capacity is 16 pages, but the\ncapacity can be queried and set using the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>\n<b>F_GETPIPE_SZ</b> and <b>F_SETPIPE_SZ</b> operations. See\n<a href=\"https://man.page/2/fcntl\">fcntl(2)</a> for more information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operation, which can be applied to a file\ndescriptor that refers to either end of a pipe, places a\ncount of the number of unread bytes in the pipe in the\n<i>int</i> buffer pointed to by the final argument of the\ncall:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ioctl(fd,\nFIONREAD, &amp;nbytes);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>FIONREAD</b> operation is not specified in any standard,\nbut is provided on many implementations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc\nfiles</b> <br>\nOn Linux, the following files control how much memory can be\nused for pipes: <i><br>\n/proc/sys/fs/pipe-max-pages</i> (only in Linux 2.6.34)</p>\n\n<p style=\"margin-left:22%;\">An upper limit, in pages, on\nthe capacity that an unprivileged user (one without the\n<b>CAP_SYS_RESOURCE</b> capability) can set for a pipe.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The default\nvalue for this limit is 16 times the default pipe capacity\n(see above); the lower limit is two pages.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This interface\nwas removed in Linux 2.6.35, in favor of\n<i>/proc/sys/fs/pipe-max-size</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/pipe-max-size</i>\n(since Linux 2.6.35)</p>\n\n<p style=\"margin-left:22%;\">The maximum size (in bytes) of\nindividual pipes that can be set by users without the\n<b>CAP_SYS_RESOURCE</b> capability. The value assigned to\nthis file may be rounded upward, to reflect the value\nactually employed for a convenient implementation. To\ndetermine the rounded-up value, display the contents of this\nfile after assigning a value to it.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The default\nvalue for this file is 1048576 (1&nbsp;MiB). The minimum\nvalue that can be assigned to this file is the system page\nsize. Attempts to set a limit less than the page size cause\n<a href=\"https://man.page/2/write\">write(2)</a> to fail with the error <b>EINVAL</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since Linux\n4.9, the value on this file also acts as a ceiling on the\ndefault capacity of a new pipe or newly opened FIFO.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/pipe-user-pages-hard</i>\n(since Linux 4.5)</p>\n\n<p style=\"margin-left:22%;\">The hard limit on the total\nsize (in pages) of all pipes created or set by a single\nunprivileged user (i.e., one with neither the\n<b>CAP_SYS_RESOURCE</b> nor the <b>CAP_SYS_ADMIN</b>\ncapability). So long as the total number of pages allocated\nto pipe buffers for this user is at this limit, attempts to\ncreate new pipes will be denied, and attempts to increase a\npipe&rsquo;s capacity will be denied.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">When the value\nof this limit is zero (which is the default), no hard limit\nis applied.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/pipe-user-pages-soft</i>\n(since Linux 4.5)</p>\n\n<p style=\"margin-left:22%;\">The soft limit on the total\nsize (in pages) of all pipes created or set by a single\nunprivileged user (i.e., one with neither the\n<b>CAP_SYS_RESOURCE</b> nor the <b>CAP_SYS_ADMIN</b>\ncapability). So long as the total number of pages allocated\nto pipe buffers for this user is at this limit, individual\npipes created by a user will be limited to one page, and\nattempts to increase a pipe&rsquo;s capacity will be\ndenied.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">When the value\nof this limit is zero, no soft limit is applied. The default\nvalue for this file is 16384, which permits creating up to\n1024 pipes with the default capacity.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n4.9, some bugs affected the handling of the\n<i>pipe-user-pages-soft</i> and <i>pipe-user-pages-hard</i>\nlimits; see BUGS.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PIPE_BUF</b>\n<br>\nPOSIX.1 says that <a href=\"https://man.page/2/write\">write(2)</a>s of less than\n<b>PIPE_BUF</b> bytes must be atomic: the output data is\nwritten to the pipe as a contiguous sequence. Writes of more\nthan <b>PIPE_BUF</b> bytes may be nonatomic: the kernel may\ninterleave the data with data written by other processes.\nPOSIX.1 requires <b>PIPE_BUF</b> to be at least 512 bytes.\n(On Linux, <b>PIPE_BUF</b> is 4096 bytes.) The precise\nsemantics depend on whether the file descriptor is\nnonblocking (<b>O_NONBLOCK</b>), whether there are multiple\nwriters to the pipe, and on <i>n</i>, the number of bytes to\nbe written: <b><br>\nO_NONBLOCK</b> disabled, <i>n</i> &lt;= <b>PIPE_BUF</b></p>\n\n<p style=\"margin-left:22%;\">All <i>n</i> bytes are written\natomically; <a href=\"https://man.page/2/write\">write(2)</a> may block if there is not room\nfor <i>n</i> bytes to be written immediately</p>\n\n<p style=\"margin-left:11%;\"><b>O_NONBLOCK</b> enabled,\n<i>n</i> &lt;= <b>PIPE_BUF</b></p>\n\n<p style=\"margin-left:22%;\">If there is room to write\n<i>n</i> bytes to the pipe, then <a href=\"https://man.page/2/write\">write(2)</a> succeeds\nimmediately, writing all <i>n</i> bytes; otherwise\n<a href=\"https://man.page/2/write\">write(2)</a> fails, with <i>errno</i> set to\n<b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>O_NONBLOCK</b> disabled,\n<i>n</i> &gt; <b>PIPE_BUF</b></p>\n\n<p style=\"margin-left:22%;\">The write is nonatomic: the\ndata given to <a href=\"https://man.page/2/write\">write(2)</a> may be interleaved with\n<a href=\"https://man.page/2/write\">write(2)</a>s by other process; the <a href=\"https://man.page/2/write\">write(2)</a>\nblocks until <i>n</i> bytes have been written.</p>\n\n<p style=\"margin-left:11%;\"><b>O_NONBLOCK</b> enabled,\n<i>n</i> &gt; <b>PIPE_BUF</b></p>\n\n<p style=\"margin-left:22%;\">If the pipe is full, then\n<a href=\"https://man.page/2/write\">write(2)</a> fails, with <i>errno</i> set to\n<b>EAGAIN</b>. Otherwise, from 1 to <i>n</i> bytes may be\nwritten (i.e., a &quot;partial write&quot; may occur; the\ncaller should check the return value from <a href=\"https://man.page/2/write\">write(2)</a> to\nsee how many bytes were actually written), and these bytes\nmay be interleaved with writes by other processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Open file\nstatus flags</b> <br>\nThe only open file status flags that can be meaningfully\napplied to a pipe or FIFO are <b>O_NONBLOCK</b> and\n<b>O_ASYNC</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Setting the\n<b>O_ASYNC</b> flag for the read end of a pipe causes a\nsignal (<b>SIGIO</b> by default) to be generated when new\ninput becomes available on the pipe. The target for delivery\nof signals must be set using the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>\n<b>F_SETOWN</b> command. On Linux, <b>O_ASYNC</b> is\nsupported for pipes and FIFOs only since kernel 2.6.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Portability\nnotes</b> <br>\nOn some systems (but not Linux), pipes are bidirectional:\ndata can be transmitted in both directions between the pipe\nends. POSIX.1 requires only unidirectional pipes. Portable\napplications should avoid reliance on bidirectional pipe\nsemantics.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>BUGS</b>\n<br>\nBefore Linux 4.9, some bugs affected the handling of the\n<i>pipe-user-pages-soft</i> and <i>pipe-user-pages-hard</i>\nlimits when using the <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_SETPIPE_SZ</b>\noperation to change a pipe&rsquo;s capacity:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>(1)</p></td>\n<td width=\"3%\"></td>\n<td width=\"82%\">\n\n\n<p>When increasing the pipe capacity, the checks against\nthe soft and hard limits were made against existing\nconsumption, and excluded the memory required for the\nincreased pipe capacity. The new increase in pipe capacity\ncould then push the total memory used by the user for pipes\n(possibly far) over a limit. (This could also trigger the\nproblem described next.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:18%; margin-top: 1em\">Starting with\nLinux 4.9, the limit checking includes the memory required\nfor the new pipe capacity.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">(2)</p></td>\n<td width=\"3%\"></td>\n<td width=\"82%\">\n\n\n<p style=\"margin-top: 1em\">The limit checks were performed\neven when the new pipe capacity was less than the existing\npipe capacity. This could lead to problems if a user set a\nlarge pipe capacity, and then the limits were lowered, with\nthe result that the user could no longer decrease the pipe\ncapacity.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:18%; margin-top: 1em\">Starting with\nLinux 4.9, checks against the limits are performed only when\nincreasing a pipe&rsquo;s capacity; an unprivileged user can\nalways decrease a pipe&rsquo;s capacity.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">(3)</p></td>\n<td width=\"3%\"></td>\n<td width=\"82%\">\n\n\n<p style=\"margin-top: 1em\">The accounting and checking\nagainst the limits were done as follows:</p></td></tr>\n</table>\n\n<p style=\"margin-left:18%;\">(a)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"18%\"></td>\n<td width=\"5%\"></td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p style=\"margin-top: 1em\">Test whether the user has\nexceeded the limit.</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"18%\"></td>\n<td width=\"5%\">\n\n\n<p>(b)</p></td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p>Make the new pipe buffer allocation.</p></td>\n<td width=\"6%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"18%\"></td>\n<td width=\"5%\">\n\n\n<p>(c)</p></td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p>Account new allocation against the limits.</p></td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:18%; margin-top: 1em\">This was racey.\nMultiple processes could pass point (a) simultaneously, and\nthen allocate pipe buffers that were accounted for only in\nstep (c), with the result that the user&rsquo;s pipe buffer\nallocation could be pushed over the limit.</p>\n\n<p style=\"margin-left:18%; margin-top: 1em\">Starting with\nLinux 4.9, the accounting step is performed before doing the\nallocation, and the operation fails if the limit would be\nexceeded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n4.9, bugs similar to points (1) and (3) could also occur\nwhen the kernel allocated memory for a new pipe buffer; that\nis, when calling <a href=\"https://man.page/2/pipe\">pipe(2)</a> and when opening a\npreviously unopened FIFO.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/mkfifo\">mkfifo(1)</a>,\n<a href=\"https://man.page/2/dup\">dup(2)</a>, <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>, <a href=\"https://man.page/2/open\">open(2)</a>,\n<a href=\"https://man.page/2/pipe\">pipe(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/socketpair\">socketpair(2)</a>, <a href=\"https://man.page/2/splice\">splice(2)</a>, <a href=\"https://man.page/2/stat\">stat(2)</a>,\n<a href=\"https://man.page/2/tee\">tee(2)</a>, <a href=\"https://man.page/2/vmsplice\">vmsplice(2)</a>, <a href=\"https://man.page/3/mkfifo\">mkfifo(3)</a>,\n<a href=\"https://man.page/7/epoll\">epoll(7)</a>, <a href=\"https://man.page/7/fifo\">fifo(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}