{"name":"des_modes","body":"\n\n<h1 align=\"center\">DES_MODES</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">des_modes - the\nvariants of DES and other crypto algorithms of OpenSSL</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Several crypto\nalgorithms for OpenSSL can be used in a number of modes.\nThose are used for using block ciphers in a way similar to\nstream ciphers, among other things.</p>\n\n<h2>OVERVIEW\n<a name=\"OVERVIEW\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Electronic\nCodebook Mode ( <small>ECB</small> )</b> <br>\nNormally, this is found as the function\n<i>algorithm</i><b>_ecb_encrypt()</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>64 bits are enciphered at a time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The order of the blocks can be rearranged without\ndetection.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The same plaintext block always produces the same\nciphertext block (for the same key) making it vulnerable to\na &rsquo;dictionary attack&rsquo;.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>An error will only affect one ciphertext block.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cipher Block\nChaining Mode ( <small>CBC</small> )</b> <br>\nNormally, this is found as the function\n<i>algorithm</i><b>_cbc_encrypt()</b>. Be aware that\n<b>des_cbc_encrypt()</b> is not really <small>DES\nCBC</small> (it does not update the <small>IV</small> ); use\n<b>des_ncbc_encrypt()</b> instead.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">a multiple of 64 bits are\nenciphered at a time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The <small>CBC</small> mode produces the same ciphertext\nwhenever the same plaintext is encrypted using the same key\nand starting variable.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The chaining operation makes the ciphertext blocks\ndependent on the current and all preceding plaintext blocks\nand therefore blocks can not be rearranged.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The use of different starting variables prevents the\nsame plaintext enciphering to the same ciphertext.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>An error will affect the current and the following\nciphertext blocks.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cipher\nFeedback Mode ( <small>CFB</small> )</b> <br>\nNormally, this is found as the function\n<i>algorithm</i><b>_cfb_encrypt()</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">a number of bits (j) &lt;= 64\nare enciphered at a time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The <small>CFB</small> mode produces the same ciphertext\nwhenever the same plaintext is encrypted using the same key\nand starting variable.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The chaining operation makes the ciphertext variables\ndependent on the current and all preceding variables and\ntherefore j-bit variables are chained together and can not\nbe rearranged.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The use of different starting variables prevents the\nsame plaintext enciphering to the same ciphertext.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The strength of the <small>CFB</small> mode depends on\nthe size of k (maximal if j == k). In my implementation this\nis always the case.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Selection of a small value for j will require more\ncycles through the encipherment algorithm per unit of\nplaintext and thus cause greater processing overheads.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Only multiples of j bits can be enciphered.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>An error will affect the current and the following\nciphertext variables.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Output\nFeedback Mode ( <small>OFB</small> )</b> <br>\nNormally, this is found as the function\n<i>algorithm</i><b>_ofb_encrypt()</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">a number of bits (j) &lt;= 64\nare enciphered at a time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The <small>OFB</small> mode produces the same ciphertext\nwhenever the same plaintext enciphered using the same key\nand starting variable. More over, in the <small>OFB</small>\nmode the same key stream is produced when the same key and\nstart variable are used. Consequently, for security reasons\na specific start variable should be used only once for a\ngiven key.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The absence of chaining makes the <small>OFB</small>\nmore vulnerable to specific attacks.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The use of different start variables values prevents the\nsame plaintext enciphering to the same ciphertext, by\nproducing different key streams.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Selection of a small value for j will require more\ncycles through the encipherment algorithm per unit of\nplaintext and thus cause greater processing overheads.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Only multiples of j bits can be enciphered.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><small>OFB</small> mode of operation does not extend\nciphertext errors in the resultant plaintext output. Every\nbit error in the ciphertext causes only one bit to be in\nerror in the deciphered plaintext.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><small>OFB</small> mode is not self-synchronizing. If\nthe two operation of encipherment and decipherment get out\nof synchronism, the system needs to be re-initialized.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Each re-initialization should use a value of the start\nvariable different from the start variable values used\nbefore with the same key. The reason for this is that an\nidentical bit stream would be produced each time from the\nsame parameters. This would be susceptible to a &rsquo;known\nplaintext&rsquo; attack.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Triple\n<small>ECB</small> Mode</b> <br>\nNormally, this is found as the function\n<i>algorithm</i><b>_ecb3_encrypt()</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">Encrypt with key1, decrypt with\nkey2 and encrypt with key3 again.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>As for <small>ECB</small> encryption but increases the\nkey length to 168 bits. There are theoretic attacks that can\nbe used that make the effective key length 112 bits, but\nthis attack also requires 2^56 blocks of memory, not very\nlikely, even for the <small>NSA.</small></p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>If both keys are the same it is equivalent to encrypting\nonce with just one key.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>If the first and last key are the same, the key length\nis 112 bits. There are attacks that could reduce the\neffective key strength to only slightly more than 56 bits,\nbut these require a lot of memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>If all 3 keys are the same, this is effectively the same\nas normal ecb mode.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Triple\n<small>CBC</small> Mode</b> <br>\nNormally, this is found as the function\n<i>algorithm</i><b>_ede3_cbc_encrypt()</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">Encrypt with key1, decrypt with\nkey2 and then encrypt with key3.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>As for <small>CBC</small> encryption but increases the\nkey length to 168 bits with the same restrictions as for\ntriple ecb mode.</p></td></tr>\n</table>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This text was\nbeen written in large parts by Eric Young in his original\ndocumentation for SSLeay, the predecessor of OpenSSL. In\nturn, he attributed it to:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">AS 2805.5.2\n<br>\nAustralian Standard <br>\nElectronic funds transfer - Requirements for interfaces,\n<br>\nPart 5.2: Modes of operation for an n-bit block cipher\nalgorithm <br>\nAppendix A</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/BF_encrypt\">BF_encrypt(3)</a>,\n<a href=\"https://man.page/3/DES_crypt\">DES_crypt(3)</a></p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n2000-2017 The OpenSSL Project Authors. All Rights\nReserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nthe Apache License 2.0 (the &quot;License&quot;). You may\nnot use this file except in compliance with the License. You\ncan obtain a copy in the file <small>LICENSE</small> in the\nsource distribution or at\n&lt;https://www.openssl.org/source/license.html&gt;.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OVERVIEW\">OVERVIEW</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":7}