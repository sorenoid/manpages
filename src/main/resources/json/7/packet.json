{"name":"packet","description":"packet - packet\ninterface on device level","body":"\n\n<h1 align=\"center\">PACKET</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">packet - packet\ninterface on device level</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/socket.h&gt; <br>\n#include &lt;linux/if_packet.h&gt; <br>\n#include &lt;net/ethernet.h&gt; /* the L2 protocols\n*/</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>packet_socket\n= socket(AF_PACKET, int</b> <i>socket_type</i><b>, int</b>\n<i>protocol</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Packet sockets\nare used to receive or send raw packets at the device driver\n(OSI Layer 2) level. They allow the user to implement\nprotocol modules in user space on top of the physical\nlayer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>socket_type</i> is either <b>SOCK_RAW</b> for raw packets\nincluding the link-level header or <b>SOCK_DGRAM</b> for\ncooked packets with the link-level header removed. The\nlink-level header information is available in a common\nformat in a <i>sockaddr_ll</i> structure. <i>protocol</i> is\nthe IEEE 802.3 protocol number in network byte order. See\nthe <i>&lt;linux/if_ether.h&gt;</i> include file for a list\nof allowed protocols. When protocol is set to\n<b>htons(ETH_P_ALL)</b>, then all protocols are received.\nAll incoming packets of that protocol type will be passed to\nthe packet socket before they are passed to the protocols\nimplemented in the kernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to\ncreate a packet socket, a process must have the\n<b>CAP_NET_RAW</b> capability in the user namespace that\ngoverns its network namespace.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SOCK_RAW</b>\npackets are passed to and from the device driver without any\nchanges in the packet data. When receiving a packet, the\naddress is still parsed and passed in a standard\n<i>sockaddr_ll</i> address structure. When transmitting a\npacket, the user-supplied buffer should contain the\nphysical-layer header. That packet is then queued unmodified\nto the network driver of the interface defined by the\ndestination address. Some device drivers always add other\nheaders. <b>SOCK_RAW</b> is similar to but not compatible\nwith the obsolete <b>AF_INET/SOCK_PACKET</b> of Linux\n2.0.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SOCK_DGRAM</b>\noperates on a slightly higher level. The physical header is\nremoved before the packet is passed to the user. Packets\nsent through a <b>SOCK_DGRAM</b> packet socket get a\nsuitable physical-layer header based on the information in\nthe <i>sockaddr_ll</i> destination address before they are\nqueued.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default, all\npackets of the specified protocol type are passed to a\npacket socket. To get packets only from a specific interface\nuse <a href=\"https://man.page/2/bind\">bind(2)</a> specifying an address in a <i>struct\nsockaddr_ll</i> to bind the packet socket to an interface.\nFields used for binding are <i>sll_family</i> (should be\n<b>AF_PACKET</b>), <i>sll_protocol</i>, and\n<i>sll_ifindex</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/connect\">connect(2)</a> operation is not supported on packet\nsockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\n<b>MSG_TRUNC</b> flag is passed to <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>,\n<a href=\"https://man.page/2/recv\">recv(2)</a>, or <a href=\"https://man.page/2/recvfrom\">recvfrom(2)</a>, the real length of\nthe packet on the wire is always returned, even when it is\nlonger than the buffer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Address\ntypes</b> <br>\nThe <i>sockaddr_ll</i> structure is a device-independent\nphysical-layer address.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nsockaddr_ll { <br>\nunsigned short sll_family; /* Always AF_PACKET */ <br>\nunsigned short sll_protocol; /* Physical-layer protocol */\n<br>\nint sll_ifindex; /* Interface number */ <br>\nunsigned short sll_hatype; /* ARP hardware type */ <br>\nunsigned char sll_pkttype; /* Packet type */ <br>\nunsigned char sll_halen; /* Length of address */ <br>\nunsigned char sll_addr[8]; /* Physical-layer address */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthis structure are as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>sll_protocol</i> is the standard ethernet protocol\ntype in network byte order as defined in the\n<i>&lt;linux/if_ether.h&gt;</i> include file. It defaults to\nthe socket&rsquo;s protocol.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>sll_ifindex</i> is the interface index of the\ninterface (see <a href=\"https://man.page/7/netdevice\">netdevice(7)</a>); 0 matches any interface\n(only permitted for binding). <i>sll_hatype</i> is an ARP\ntype as defined in the <i>&lt;linux/if_arp.h&gt;</i> include\nfile.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>sll_pkttype</i> contains the packet type. Valid types\nare <b>PACKET_HOST</b> for a packet addressed to the local\nhost, <b>PACKET_BROADCAST</b> for a physical-layer broadcast\npacket, <b>PACKET_MULTICAST</b> for a packet sent to a\nphysical-layer multicast address, <b>PACKET_OTHERHOST</b>\nfor a packet to some other host that has been caught by a\ndevice driver in promiscuous mode, and\n<b>PACKET_OUTGOING</b> for a packet originating from the\nlocal host that is looped back to a packet socket. These\ntypes make sense only for receiving.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>sll_addr</i> and <i>sll_halen</i> contain the\nphysical-layer (e.g., IEEE 802.3) address and its length.\nThe exact interpretation depends on the device.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When you send\npackets, it is enough to specify <i>sll_family</i>,\n<i>sll_addr</i>, <i>sll_halen</i>, <i>sll_ifindex</i>, and\n<i>sll_protocol</i>. The other fields should be 0.\n<i>sll_hatype</i> and <i>sll_pkttype</i> are set on received\npackets for your information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Socket\noptions</b> <br>\nPacket socket options are configured by calling\n<a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a> with level <b>SOL_PACKET</b>. <b><br>\nPACKET_ADD_MEMBERSHIP <br>\nPACKET_DROP_MEMBERSHIP</b></p>\n\n<p style=\"margin-left:22%;\">Packet sockets can be used to\nconfigure physical-layer multicasting and promiscuous mode.\n<b>PACKET_ADD_MEMBERSHIP</b> adds a binding and\n<b>PACKET_DROP_MEMBERSHIP</b> drops it. They both expect a\n<i>packet_mreq</i> structure as argument:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\npacket_mreq { <br>\nint mr_ifindex; /* interface index */ <br>\nunsigned short mr_type; /* action */ <br>\nunsigned short mr_alen; /* address length */ <br>\nunsigned char mr_address[8]; /* physical-layer address */\n<br>\n};</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>mr_ifindex</i>\ncontains the interface index for the interface whose status\nshould be changed. The <i>mr_type</i> field specifies which\naction to perform. <b>PACKET_MR_PROMISC</b> enables\nreceiving all packets on a shared medium (often known as\n&quot;promiscuous mode&quot;), <b>PACKET_MR_MULTICAST</b>\nbinds the socket to the physical-layer multicast group\nspecified in <i>mr_address</i> and <i>mr_alen</i>, and\n<b>PACKET_MR_ALLMULTI</b> sets the socket up to receive all\nmulticast packets arriving at the interface.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In addition,\nthe traditional ioctls <b>SIOCSIFFLAGS</b>,\n<b>SIOCADDMULTI</b>, <b>SIOCDELMULTI</b> can be used for the\nsame purpose.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_AUXDATA</b> (since\nLinux 2.6.21)</p>\n\n<p style=\"margin-left:22%;\">If this binary option is\nenabled, the packet socket passes a metadata structure along\nwith each packet in the <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a> control field. The\nstructure can be read with <a href=\"https://man.page/3/cmsg\">cmsg(3)</a>. It is defined\nas</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\ntpacket_auxdata { <br>\n__u32 tp_status; <br>\n__u32 tp_len; /* packet length */ <br>\n__u32 tp_snaplen; /* captured length */ <br>\n__u16 tp_mac; <br>\n__u16 tp_net; <br>\n__u16 tp_vlan_tci; <br>\n__u16 tp_vlan_tpid; /* Since Linux 3.14; earlier, these <br>\nwere unused padding bytes */ <br>\n};</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_FANOUT</b> (since\nLinux 3.1)</p>\n\n<p style=\"margin-left:22%;\">To scale processing across\nthreads, packet sockets can form a fanout group. In this\nmode, each matching packet is enqueued onto only one socket\nin the group. A socket joins a fanout group by calling\n<a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a> with level <b>SOL_PACKET</b> and option\n<b>PACKET_FANOUT</b>. Each network namespace can have up to\n65536 independent groups. A socket selects a group by\nencoding the ID in the first 16 bits of the integer option\nvalue. The first packet socket to join a group implicitly\ncreates it. To successfully join an existing group,\nsubsequent packet sockets must have the same protocol,\ndevice settings, fanout mode and flags (see below). Packet\nsockets can leave a fanout group only by closing the socket.\nThe group is deleted when the last socket is closed.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Fanout supports\nmultiple algorithms to spread traffic between sockets, as\nfollows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The default mode, <b>PACKET_FANOUT_HASH</b>, sends\npackets from the same flow to the same socket to maintain\nper-flow ordering. For each packet, it chooses a socket by\ntaking the packet flow hash modulo the number of sockets in\nthe group, where a flow hash is a hash over network-layer\naddress and optional transport-layer port fields.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>The load-balance mode <b>PACKET_FANOUT_LB</b> implements\na round-robin algorithm.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>PACKET_FANOUT_CPU</b> selects the socket based on the\nCPU that the packet arrived on.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>PACKET_FANOUT_ROLLOVER</b> processes all data on a\nsingle socket, moving to the next when one becomes\nbacklogged.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>PACKET_FANOUT_RND</b> selects the socket using a\npseudo-random number generator.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p><b>PACKET_FANOUT_QM</b> (available since Linux 3.14)\nselects the socket using the recorded queue_mapping of the\nreceived skb.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Fanout modes\ncan take additional options. IP fragmentation causes packets\nfrom the same flow to have different flow hashes. The flag\n<b>PACKET_FANOUT_FLAG_DEFRAG</b>, if set, causes packets to\nbe defragmented before fanout is applied, to preserve order\neven in this case. Fanout mode and options are communicated\nin the second 16 bits of the integer option value. The flag\n<b>PACKET_FANOUT_FLAG_ROLLOVER</b> enables the roll over\nmechanism as a backup strategy: if the original fanout\nalgorithm selects a backlogged socket, the packet rolls over\nto the next available one.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_LOSS</b> (with\n<b>PACKET_TX_RING</b>)</p>\n\n<p style=\"margin-left:22%;\">When a malformed packet is\nencountered on a transmit ring, the default is to reset its\n<i>tp_status</i> to <b>TP_STATUS_WRONG_FORMAT</b> and abort\nthe transmission immediately. The malformed packet blocks\nitself and subsequently enqueued packets from being sent.\nThe format error must be fixed, the associated\n<i>tp_status</i> reset to <b>TP_STATUS_SEND_REQUEST</b>, and\nthe transmission process restarted via <a href=\"https://man.page/2/send\">send(2)</a>.\nHowever, if <b>PACKET_LOSS</b> is set, any malformed packet\nwill be skipped, its <i>tp_status</i> reset to\n<b>TP_STATUS_AVAILABLE</b>, and the transmission process\ncontinued.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_RESERVE</b> (with\n<b>PACKET_RX_RING</b>)</p>\n\n<p style=\"margin-left:22%;\">By default, a packet receive\nring writes packets immediately following the metadata\nstructure and alignment padding. This integer option\nreserves additional headroom.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_RX_RING</b></p>\n\n<p style=\"margin-left:22%;\">Create a memory-mapped ring\nbuffer for asynchronous packet reception. The packet socket\nreserves a contiguous region of application address space,\nlays it out into an array of packet slots and copies packets\n(up to <i>tp_snaplen</i>) into subsequent slots. Each packet\nis preceded by a metadata structure similar to\n<i>tpacket_auxdata</i>. The protocol fields encode the\noffset to the data from the start of the metadata header.\n<i>tp_net</i> stores the offset to the network layer. If the\npacket socket is of type <b>SOCK_DGRAM</b>, then\n<i>tp_mac</i> is the same. If it is of type <b>SOCK_RAW</b>,\nthen that field stores the offset to the link-layer frame.\nPacket socket and application communicate the head and tail\nof the ring through the <i>tp_status</i> field. The packet\nsocket owns all slots with <i>tp_status</i> equal to\n<b>TP_STATUS_KERNEL</b>. After filling a slot, it changes\nthe status of the slot to transfer ownership to the\napplication. During normal operation, the new\n<i>tp_status</i> value has at least the\n<b>TP_STATUS_USER</b> bit set to signal that a received\npacket has been stored. When the application has finished\nprocessing a packet, it transfers ownership of the slot back\nto the socket by setting <i>tp_status</i> equal to\n<b>TP_STATUS_KERNEL</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Packet sockets\nimplement multiple variants of the packet ring. The\nimplementation details are described in\n<i>Documentation/networking/packet_mmap.rst</i> in the Linux\nkernel source tree.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_STATISTICS</b></p>\n\n<p style=\"margin-left:22%;\">Retrieve packet socket\nstatistics in the form of a structure</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\ntpacket_stats { <br>\nunsigned int tp_packets; /* Total packet count */ <br>\nunsigned int tp_drops; /* Dropped packet count */ <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Receiving\nstatistics resets the internal counters. The statistics\nstructure differs when using a ring of variant\n<b>TPACKET_V3</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_TIMESTAMP</b> (with\n<b>PACKET_RX_RING</b>; since Linux 2.6.36)</p>\n\n<p style=\"margin-left:22%;\">The packet receive ring always\nstores a timestamp in the metadata header. By default, this\nis a software generated timestamp generated when the packet\nis copied into the ring. This integer option selects the\ntype of timestamp. Besides the default, it support the two\nhardware formats described in\n<i>Documentation/networking/timestamping.rst</i> in the\nLinux kernel source tree.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_TX_RING</b> (since\nLinux 2.6.31)</p>\n\n<p style=\"margin-left:22%;\">Create a memory-mapped ring\nbuffer for packet transmission. This option is similar to\n<b>PACKET_RX_RING</b> and takes the same arguments. The\napplication writes packets into slots with <i>tp_status</i>\nequal to <b>TP_STATUS_AVAILABLE</b> and schedules them for\ntransmission by changing <i>tp_status</i> to\n<b>TP_STATUS_SEND_REQUEST</b>. When packets are ready to be\ntransmitted, the application calls <a href=\"https://man.page/2/send\">send(2)</a> or a\nvariant thereof. The <i>buf</i> and <i>len</i> fields of\nthis call are ignored. If an address is passed using\n<a href=\"https://man.page/2/sendto\">sendto(2)</a> or <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>, then that overrides\nthe socket default. On successful transmission, the socket\nresets <i>tp_status</i> to <b>TP_STATUS_AVAILABLE</b>. It\nimmediately aborts the transmission on error unless\n<b>PACKET_LOSS</b> is set.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_VERSION</b> (with\n<b>PACKET_RX_RING</b>; since Linux 2.6.27)</p>\n\n<p style=\"margin-left:22%;\">By default,\n<b>PACKET_RX_RING</b> creates a packet receive ring of\nvariant <b>TPACKET_V1</b>. To create another variant,\nconfigure the desired variant by setting this integer option\nbefore creating the ring.</p>\n\n<p style=\"margin-left:11%;\"><b>PACKET_QDISC_BYPASS</b>\n(since Linux 3.14)</p>\n\n<p style=\"margin-left:22%;\">By default, packets sent\nthrough packet sockets pass through the kernel&rsquo;s qdisc\n(traffic control) layer, which is fine for the vast majority\nof use cases. For traffic generator appliances using packet\nsockets that intend to brute-force flood the\nnetwork&mdash;for example, to test devices under load in a\nsimilar fashion to pktgen&mdash;this layer can be bypassed\nby setting this integer option to 1. A side effect is that\npacket buffering in the qdisc layer is avoided, which will\nlead to increased drops when network device transmit queues\nare busy; therefore, use at your own risk.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Ioctls <br>\nSIOCGSTAMP</b> can be used to receive the timestamp of the\nlast received packet. Argument is a <i>struct timeval</i>\nvariable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nall standard ioctls defined in <a href=\"https://man.page/7/netdevice\">netdevice(7)</a> and\n<a href=\"https://man.page/7/socket\">socket(7)</a> are valid on packet sockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Error\nhandling</b> <br>\nPacket sockets do no error handling other than errors\noccurred while passing the packet to the device driver. They\ndon&rsquo;t have the concept of a pending error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>EADDRNOTAVAIL</b></p>\n\n<p style=\"margin-left:22%;\">Unknown multicast group address\npassed.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"53%\">\n\n\n<p>User passed invalid memory address.</p></td>\n<td width=\"25%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"53%\">\n\n\n<p>Invalid argument.</p></td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EMSGSIZE</b></p>\n\n<p style=\"margin-left:22%;\">Packet is bigger than interface\nMTU.</p>\n\n<p style=\"margin-left:11%;\"><b>ENETDOWN</b></p>\n\n<p style=\"margin-left:22%;\">Interface is not up.</p>\n\n<p style=\"margin-left:11%;\"><b>ENOBUFS</b></p>\n\n<p style=\"margin-left:22%;\">Not enough memory to allocate\nthe packet.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENODEV</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Unknown device name or interface index specified in\ninterface address.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>No packet received.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTCONN</b></p>\n\n<p style=\"margin-left:22%;\">No interface address\npassed.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>ENXIO</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Interface address contained an invalid interface\nindex.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>User has insufficient privileges to carry out this\noperation.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nother errors may be generated by the low-level driver.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>AF_PACKET</b>\nis a new feature in Linux 2.2. Earlier Linux versions\nsupported only <b>SOCK_PACKET</b>.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For portable\nprograms it is suggested to use <b>AF_PACKET</b> via\n<a href=\"https://man.page/3/pcap\">pcap(3)</a>; although this covers only a subset of the\n<b>AF_PACKET</b> features.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>SOCK_DGRAM</b> packet sockets make no attempt to create\nor parse the IEEE 802.2 LLC header for a IEEE 802.3 frame.\nWhen <b>ETH_P_802_3</b> is specified as protocol for sending\nthe kernel creates the 802.3 frame and fills out the length\nfield; the user has to supply the LLC header to get a fully\nconforming packet. Incoming 802.3 packets are not\nmultiplexed on the DSAP/SSAP protocol fields; instead they\nare supplied to the user as protocol <b>ETH_P_802_2</b> with\nthe LLC header prefixed. It is thus not possible to bind to\n<b>ETH_P_802_3</b>; bind to <b>ETH_P_802_2</b> instead and\ndo the protocol multiplex yourself. The default for sending\nis the standard Ethernet DIX encapsulation with the protocol\nfilled in.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Packet sockets\nare not subject to the input or output firewall chains.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Compatibility</b>\n<br>\nIn Linux 2.0, the only way to get a packet socket was with\nthe call:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">socket(AF_INET,\nSOCK_PACKET, protocol)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is still\nsupported, but deprecated and strongly discouraged. The main\ndifference between the two methods is that\n<b>SOCK_PACKET</b> uses the old <i>struct sockaddr_pkt</i>\nto specify an interface, which doesn&rsquo;t provide\nphysical-layer independence.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nsockaddr_pkt { <br>\nunsigned short spkt_family; <br>\nunsigned char spkt_device[14]; <br>\nunsigned short spkt_protocol; <br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>spkt_family</i>\ncontains the device type, <i>spkt_protocol</i> is the IEEE\n802.3 protocol type as defined in\n<i>&lt;sys/if_ether.h&gt;</i> and <i>spkt_device</i> is the\ndevice name as a null-terminated string, for example,\neth0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This structure\nis obsolete and should not be used in new code.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The IEEE\n802.2/803.3 LLC handling could be considered as a bug.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Socket filters\nare not documented.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>MSG_TRUNC recvmsg</b>(2) extension is an ugly hack and\nshould be replaced by a control message. There is currently\nno way to get the original destination address of packets\nvia <b>SOCK_DGRAM</b>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/socket\">socket(2)</a>,\n<a href=\"https://man.page/3/pcap\">pcap(3)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/ip\">ip(7)</a>,\n<a href=\"https://man.page/7/raw\">raw(7)</a>, <a href=\"https://man.page/7/socket\">socket(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">RFC&nbsp;894\nfor the standard IP Ethernet encapsulation. RFC&nbsp;1700\nfor the IEEE 802.3 IP encapsulation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>&lt;linux/if_ether.h&gt;</i> include file for\nphysical-layer protocols.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux\nkernel source tree.\n<i>Documentation/networking/filter.rst</i> describes how to\napply Berkeley Packet Filters to packet sockets.\n<i>tools/testing/selftests/net/psock_tpacket.c</i> contains\nexample source code for all available versions of\n<b>PACKET_RX_RING</b> and <b>PACKET_TX_RING</b>.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}