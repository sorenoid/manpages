{"name":"crypto","description":"crypto - OpenSSL cryptographic library","body":"\n\n<h1 align=\"center\">CRYPTO</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">crypto -\nOpenSSL cryptographic library</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\nindividual manual pages for details.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The OpenSSL\ncrypto library (&quot;libcrypto&quot;) implements a wide\nrange of cryptographic algorithms used in various Internet\nstandards. The services provided by this library are used by\nthe OpenSSL implementations of <small>TLS</small> and\n<small>CMS,</small> and they have also been used to\nimplement many other third party products and protocols.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nfunctionality includes symmetric encryption, public key\ncryptography, key agreement, certificate handling,\ncryptographic hash functions, cryptographic pseudo-random\nnumber generators, message authentication codes (MACs), key\nderivation functions (KDFs), and various utilities.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Algorithms</b>\n<br>\nCryptographic primitives such as the <small>SHA256</small>\ndigest, or <small>AES</small> encryption are referred to in\nOpenSSL as &quot;algorithms&quot;. Each algorithm may have\nmultiple implementations available for use. For example the\n<small>RSA</small> algorithm is available as a\n&quot;default&quot; implementation suitable for general use,\nand a &quot;fips&quot; implementation which has been\nvalidated to <small>FIPS</small> standards for situations\nwhere that is important. It is also possible that a third\nparty could add additional implementations such as in a\nhardware security module ( <small>HSM</small> ).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Operations</b>\n<br>\nDifferent algorithms can be grouped together by their\npurpose. For example there are algorithms for encryption,\nand different algorithms for digesting data. These different\ngroups are known as &quot;operations&quot; in OpenSSL. Each\noperation has a different set of functions associated with\nit. For example to perform an encryption operation using\n<small>AES</small> (or any other encryption algorithm) you\nwould use the encryption functions detailed on the\n<a href=\"https://man.page/3/EVP_EncryptInit\">EVP_EncryptInit(3)</a> page. Or to perform a digest\noperation using <small>SHA256</small> then you would use the\ndigesting functions on the <a href=\"https://man.page/3/EVP_DigestInit\">EVP_DigestInit(3)</a>\npage.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Providers</b>\n<br>\nA provider in OpenSSL is a component that collects together\nalgorithm implementations. In order to use an algorithm you\nmust have at least one provider loaded that contains an\nimplementation of it. OpenSSL comes with a number of\nproviders and they may also be obtained from third parties.\nIf you don&rsquo;t load a provider explicitly (either in\nprogram code or via config) then the OpenSSL built-in\n&quot;default&quot; provider will be automatically\nloaded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Library\ncontexts</b> <br>\nA library context can be thought of as a &quot;scope&quot;\nwithin which configuration options take effect. When a\nprovider is loaded, it is only loaded within the scope of a\ngiven library context. In this way it is possible for\ndifferent components of a complex application to each use a\ndifferent library context and have different providers\nloaded with different configuration settings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If an\napplication does not explicitly create a library context\nthen the &quot;default&quot; library context will be\nused.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Library\ncontexts are represented by the\n<b><small>OSSL_LIB_CTX</small></b> type. Many OpenSSL\n<small>API</small> functions take a library context as a\nparameter. Applications can always pass\n<b><small>NULL</small></b> for this parameter to just use\nthe default library context.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\nlibrary context is automatically created the first time it\nis needed. This will automatically load any available\nconfiguration file and will initialise OpenSSL for use.\nUnlike in earlier versions of OpenSSL (prior to 1.1.0) no\nexplicit initialisation steps need to be taken.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Similarly when\nthe application exits the default library context is\nautomatically destroyed. No explicit de-initialisation steps\nneed to be taken.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<b><small>OSSL_LIB_CTX</small></b> (3) for more information\nabout library contexts. See also &quot; <small>ALGORITHM\nFETCHING&quot;</small> .</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Multi-threaded\napplications</b> <br>\nAs long as OpenSSL has been built with support for threads\n(the default case on most platforms) then most OpenSSL\n<i>functions</i> are thread-safe in the sense that it is\nsafe to call the same function from multiple threads at the\nsame time. However most OpenSSL <i>data structures</i> are\nnot thread-safe. For example the <a href=\"https://man.page/3/BIO_write\">BIO_write(3)</a> and\n<a href=\"https://man.page/3/BIO_read\">BIO_read(3)</a> functions are thread safe. However it\nwould not be thread safe to call <b>BIO_write()</b> from one\nthread while calling <b>BIO_read()</b> in another where both\nfunctions are passed the same <b><small>BIO</small></b>\nobject since both of them may attempt to make changes to the\nsame <b><small>BIO</small></b> object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are\nexceptions to these rules. A small number of functions are\nnot thread safe at all. Where this is the case this\nrestriction should be noted in the documentation for the\nfunction. Similarly some data structures may be partially or\nfully thread safe. For example it is safe to use an\n<b><small>OSSL_LIB_CTX</small></b> in multiple threads.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/7/openssl-threads\">openssl-threads(7)</a> for a more detailed discussion on\nOpenSSL threading support.</p>\n\n<h2>ALGORITHM FETCHING\n<a name=\"ALGORITHM FETCHING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to use\nan algorithm an implementation for it must first be\n&quot;fetched&quot;. Fetching is the process of looking\nthrough the available implementations, applying selection\ncriteria (via a property query string), and finally choosing\nthe implementation that will be used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Two types of\nfetching are supported by OpenSSL - explicit fetching and\nimplicit fetching.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Property\nquery strings</b> <br>\nWhen fetching an algorithm it is possible to specify a\nproperty query string to guide the selection process. For\nexample a property query string of\n&quot;provider=default&quot; could be used to force the\nselection to only consider algorithm implementations in the\ndefault provider.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Property query\nstrings can be specified explicitly as an argument to a\nfunction. It is also possible to specify a default property\nquery string for the whole library context using the\n<a href=\"https://man.page/3/EVP_set_default_properties\">EVP_set_default_properties(3)</a> function. Where both\ndefault properties and function specific properties are\nspecified then they are combined. Function specific\nproperties will override default properties where there is a\nconflict.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/7/property\">property(7)</a> for more information about\nproperties.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Explicit\nfetching</b> <br>\nUsers of the OpenSSL libraries never query a provider\ndirectly for an algorithm implementation. Instead, the\ndiverse OpenSSL APIs often have explicit fetching functions\nthat do the work, and they return an appropriate algorithm\nobject back to the user. These functions usually have the\nname &quot;APINAME_fetch&quot;, where &quot;APINAME&quot; is\nthe name of the operation. For example\n<a href=\"https://man.page/3/EVP_MD_fetch\">EVP_MD_fetch(3)</a> can be used to explicitly fetch a\ndigest algorithm implementation. The user is responsible for\nfreeing the object returned from the\n&quot;APINAME_fetch&quot; function using\n&quot;APINAME_free&quot; when it is no longer needed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These fetching\nfunctions follow a fairly common pattern, where three\narguments are passed: <br>\nThe library context</p>\n\n<p style=\"margin-left:17%;\">See\n<b><small>OSSL_LIB_CTX</small></b> (3) for a more detailed\ndescription. This may be <small>NULL</small> to signify the\ndefault (global) library context, or a context created by\nthe user. Only providers loaded in this library context (see\n<a href=\"https://man.page/3/OSSL_PROVIDER_load\">OSSL_PROVIDER_load(3)</a>) will be considered by the\nfetching function. In case no provider has been loaded in\nthis library context then the default provider will be\nloaded as a fallback (see\n<a href=\"https://man.page/7/OSSL_PROVIDER-default\">OSSL_PROVIDER-default(7)</a>).</p>\n\n<p style=\"margin-left:11%;\">An identifier</p>\n\n<p style=\"margin-left:17%;\">For all currently implemented\nfetching functions this is the algorithm name.</p>\n\n<p style=\"margin-left:11%;\">A property query string</p>\n\n<p style=\"margin-left:17%;\">The property query string used\nto guide selection of the algorithm implementation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The algorithm\nimplementation that is fetched can then be used with other\ndiverse functions that use them. For example the\n<a href=\"https://man.page/3/EVP_DigestInit_ex\">EVP_DigestInit_ex(3)</a> function takes as a parameter an\n<b><small>EVP_MD</small></b> object which may have been\nreturned from an earlier call to <a href=\"https://man.page/3/EVP_MD_fetch\">EVP_MD_fetch(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Implicit\nfetch</b> <br>\nOpenSSL has a number of functions that return an algorithm\nobject with no associated implementation, such as\n<a href=\"https://man.page/3/EVP_sha256\">EVP_sha256(3)</a>, <a href=\"https://man.page/3/EVP_aes_128_cbc\">EVP_aes_128_cbc(3)</a>,\n<a href=\"https://man.page/3/EVP_get_cipherbyname\">EVP_get_cipherbyname(3)</a> or\n<a href=\"https://man.page/3/EVP_get_digestbyname\">EVP_get_digestbyname(3)</a>. These are present for\ncompatibility with OpenSSL before version 3.0 where explicit\nfetching was not available.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When they are\nused with functions like <a href=\"https://man.page/3/EVP_DigestInit_ex\">EVP_DigestInit_ex(3)</a> or\n<a href=\"https://man.page/3/EVP_CipherInit_ex\">EVP_CipherInit_ex(3)</a>, the actual implementation to be\nused is fetched implicitly using default search\ncriteria.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In some cases\nimplicit fetching can also occur when a <small>NULL</small>\nalgorithm parameter is supplied. In this case an algorithm\nimplementation is implicitly fetched using default search\ncriteria and an algorithm name that is consistent with the\ncontext in which it is being used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Functions that\nrevolve around <b><small>EVP_PKEY_CTX</small></b> and\n<b><small>EVP_PKEY</small></b> (3), such as\n<a href=\"https://man.page/3/EVP_DigestSignInit\">EVP_DigestSignInit(3)</a> and friends, all fetch the\nimplementations implicitly. Because these functions involve\nboth an operation type (such as\n<b><small>EVP_SIGNATURE</small></b> (3)) and an\n<b><small>EVP_KEYMGMT</small></b> (3) for the\n<b><small>EVP_PKEY</small></b> (3), they try the\nfollowing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Fetch the operation type implementation from any\nprovider given a library context and property string stored\nin the <b><small>EVP_PKEY_CTX</small></b> .</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the provider\nof the operation type implementation is different from the\nprovider of the <b><small>EVP_PKEY</small></b> (3)&rsquo;s\n<b><small>EVP_KEYMGMT</small></b> (3) implementation, try to\nfetch a <b><small>EVP_KEYMGMT</small></b> (3) implementation\nin the same provider as the operation type implementation\nand export the <b><small>EVP_PKEY</small></b> (3) to it\n(effectively making a temporary copy of the original\nkey).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If anything in\nthis step fails, the next step is used as a fallback.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">As a fallback, try to fetch the\noperation type implementation from the same provider as the\noriginal <b><small>EVP_PKEY</small></b> (3)&rsquo;s\n<b><small>EVP_KEYMGMT</small></b> (3), still using the\npropery string from the <b><small>EVP_PKEY_CTX</small></b>\n.</p> </td></tr>\n</table>\n\n<h2>FETCHING EXAMPLES\n<a name=\"FETCHING EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsection provides a series of examples of fetching algorithm\nimplementations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Fetch any\navailable implementation of <small>SHA2-256</small> in the\ndefault context. Note that some algorithms have aliases. So\n&quot; <small>SHA256&quot;</small> and &quot;\n<small>SHA2-256&quot;</small> are synonymous:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_MD *md =\nEVP_MD_fetch(NULL, &quot;SHA2-256&quot;, NULL); <br>\n... <br>\nEVP_MD_free(md);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Fetch any\navailable implementation of <small>AES-128-CBC</small> in\nthe default context:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_CIPHER\n*cipher = EVP_CIPHER_fetch(NULL, &quot;AES-128-CBC&quot;,\nNULL); <br>\n... <br>\nEVP_CIPHER_free(cipher);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Fetch an\nimplementation of <small>SHA2-256</small> from the default\nprovider in the default context:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_MD *md =\nEVP_MD_fetch(NULL, &quot;SHA2-256&quot;,\n&quot;provider=default&quot;); <br>\n... <br>\nEVP_MD_free(md);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Fetch an\nimplementation of <small>SHA2-256</small> that is not from\nthe default provider in the default context:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_MD *md =\nEVP_MD_fetch(NULL, &quot;SHA2-256&quot;,\n&quot;provider!=default&quot;); <br>\n... <br>\nEVP_MD_free(md);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Fetch an\nimplementation of <small>SHA2-256</small> from the default\nprovider in the specified context:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_MD *md =\nEVP_MD_fetch(ctx, &quot;SHA2-256&quot;,\n&quot;provider=default&quot;); <br>\n... <br>\nEVP_MD_free(md);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Load the legacy\nprovider into the default context and then fetch an\nimplementation of <small>WHIRLPOOL</small> from it:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* This only\nneeds to be done once - usually at application start up */\n<br>\nOSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL,\n&quot;legacy&quot;); <br>\nEVP_MD *md = EVP_MD_fetch(NULL, &quot;WHIRLPOOL&quot;,\n&quot;provider=legacy&quot;); <br>\n... <br>\nEVP_MD_free(md);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that in\nthe above example the property string\n&quot;provider=legacy&quot; is optional since, assuming no\nother providers have been loaded, the only implementation of\nthe &quot;whirlpool&quot; algorithm is in the\n&quot;legacy&quot; provider. Also note that the default\nprovider should be explicitly loaded if it is required in\naddition to other providers:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* This only\nneeds to be done once - usually at application start up */\n<br>\nOSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL,\n&quot;legacy&quot;); <br>\nOSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL,\n&quot;default&quot;); <br>\nEVP_MD *md_whirlpool = EVP_MD_fetch(NULL,\n&quot;whirlpool&quot;, NULL); <br>\nEVP_MD *md_sha256 = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;,\nNULL); <br>\n... <br>\nEVP_MD_free(md_whirlpool); <br>\nEVP_MD_free(md_sha256);</p>\n\n<h2>OPENSSL PROVIDERS\n<a name=\"OPENSSL PROVIDERS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">OpenSSL comes\nwith a set of providers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The algorithms\navailable in each of these providers may vary due to build\ntime configuration options. The <a href=\"https://man.page/1/openssl-list\">openssl-list(1)</a>\ncommand can be used to list the currently available\nalgorithms.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The names of\nthe algorithms shown from <a href=\"https://man.page/1/openssl-list\">openssl-list(1)</a> can be used\nas an algorithm identifier to the appropriate fetching\nfunction. Also see the provider specific manual pages linked\nbelow for further details about using the algorithms\navailable in each of the providers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As well as the\nOpenSSL providers third parties can also implement\nproviders. For information on writing a provider see\n<a href=\"https://man.page/7/provider\">provider(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Default\nprovider</b> <br>\nThe default provider is built in as part of the\n<i>libcrypto</i> library and contains all of the most\ncommonly used algorithm implementations. Should it be needed\n(if other providers are loaded and offer implementations of\nthe same algorithms), the property query string\n&quot;provider=default&quot; can be used as a search\ncriterion for these implementations. The default provider\nincludes all of the functionality in the base provider\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you\ndon&rsquo;t load any providers at all then the\n&quot;default&quot; provider will be automatically loaded.\nIf you explicitly load any provider then the\n&quot;default&quot; provider would also need to be\nexplicitly loaded if it is required.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/7/OSSL_PROVIDER-default\">OSSL_PROVIDER-default(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Base\nprovider</b> <br>\nThe base provider is built in as part of the\n<i>libcrypto</i> library and contains algorithm\nimplementations for encoding and decoding for OpenSSL keys.\nShould it be needed (if other providers are loaded and offer\nimplementations of the same algorithms), the property query\nstring &quot;provider=base&quot; can be used as a search\ncriterion for these implementations. Some encoding and\ndecoding algorithm implementations are not\n<small>FIPS</small> algorithm implementations in themselves\nbut support algorithms from the <small>FIPS</small> provider\nand are allowed for use in &quot; <small>FIPS</small>\nmode&quot;. The property query string &quot;fips=yes&quot;\ncan be used to select such algorithms.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/7/OSSL_PROVIDER-base\">OSSL_PROVIDER-base(7)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>FIPS</small>\nprovider</b> <br>\nThe <small>FIPS</small> provider is a dynamically loadable\nmodule, and must therefore be loaded explicitly, either in\ncode or through OpenSSL configuration (see\n<a href=\"https://man.page/5/config\">config(5)</a>). It contains algorithm implementations\nthat have been validated according to the <small>FIPS\n140-2</small> standard. Should it be needed (if other\nproviders are loaded and offer implementations of the same\nalgorithms), the property query string\n&quot;provider=fips&quot; can be used as a search criterion\nfor these implementations. All approved algorithm\nimplementations in the <small>FIPS</small> provider can also\nbe selected with the property &quot;fips=yes&quot;. The\n<small>FIPS</small> provider may also contain non-approved\nalgorithm implementations and these can be selected with the\nproperty &quot;fips=no&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<b><small>OSSL_PROVIDER-FIPS</small></b> (7) and\n<a href=\"https://man.page/7/fips_module\">fips_module(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Legacy\nprovider</b> <br>\nThe legacy provider is a dynamically loadable module, and\nmust therefore be loaded explicitly, either in code or\nthrough OpenSSL configuration (see <a href=\"https://man.page/5/config\">config(5)</a>). It\ncontains algorithm implementations that are considered\ninsecure, or are no longer in common use such as\n<small>MD2</small> or <small>RC4.</small> Should it be\nneeded (if other providers are loaded and offer\nimplementations of the same algorithms), the property\n&quot;provider=legacy&quot; can be used as a search\ncriterion for these implementations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/7/OSSL_PROVIDER-legacy\">OSSL_PROVIDER-legacy(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Null\nprovider</b> <br>\nThe null provider is built in as part of the\n<i>libcrypto</i> library. It contains no algorithms in it at\nall. When fetching algorithms the default provider will be\nautomatically loaded if no other provider has been\nexplicitly loaded. To prevent that from happening you can\nexplicitly load the null provider.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/7/OSSL_PROVIDER-null\">OSSL_PROVIDER-null(7)</a>.</p>\n\n<h2>USING ALGORITHMS IN APPLICATIONS\n<a name=\"USING ALGORITHMS IN APPLICATIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Cryptographic\nalgorithms are made available to applications through use of\nthe &quot; <small>EVP&quot;</small> APIs. Each of the\nvarious operations such as encryption, digesting, message\nauthentication codes, etc., have a set of <small>EVP</small>\nfunction calls that can be invoked to use them. See the\n<a href=\"https://man.page/7/evp\">evp(7)</a> page for further details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Most of these\nfollow a common pattern. A &quot;context&quot; object is\nfirst created. For example for a digest operation you would\nuse an <b><small>EVP_MD_CTX</small></b> , and for an\nencryption/decryption operation you would use an\n<b><small>EVP_CIPHER_CTX</small></b> . The operation is then\ninitialised ready for use via an &quot;init&quot; function -\noptionally passing in a set of parameters (using the\n<b><small>OSSL_PARAM</small></b> type) to configure how the\noperation should behave. Next data is fed into the operation\nin a series of &quot;update&quot; calls. The operation is\nfinalised using a &quot;final&quot; call which will\ntypically provide some kind of output. Finally the context\nis cleaned up and freed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshows a complete example for doing this process for\ndigesting data using <small>SHA256.</small> The process is\nsimilar for other operations such as encryption/decryption,\nsignatures, message authentication codes, etc.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stdio.h&gt; <br>\n#include &lt;openssl/evp.h&gt; <br>\n#include &lt;openssl/bio.h&gt; <br>\n#include &lt;openssl/err.h&gt; <br>\nint main(void) <br>\n{ <br>\nEVP_MD_CTX *ctx = NULL; <br>\nEVP_MD *sha256 = NULL; <br>\nconst unsigned char msg[] = { <br>\n0x00, 0x01, 0x02, 0x03 <br>\n}; <br>\nunsigned int len = 0; <br>\nunsigned char *outdigest = NULL; <br>\nint ret = 1; <br>\n/* Create a context for the digest operation */ <br>\nctx = EVP_MD_CTX_new(); <br>\nif (ctx == NULL) <br>\ngoto err; <br>\n/* <br>\n* Fetch the SHA256 algorithm implementation for doing the\ndigest. We're <br>\n* using the &quot;default&quot; library context here (first\nNULL parameter), and <br>\n* we're not supplying any particular search criteria for our\nSHA256 <br>\n* implementation (second NULL parameter). Any SHA256\nimplementation will <br>\n* do. <br>\n*/ <br>\nsha256 = EVP_MD_fetch(NULL, &quot;SHA256&quot;, NULL); <br>\nif (sha256 == NULL) <br>\ngoto err; <br>\n/* Initialise the digest operation */ <br>\nif (!EVP_DigestInit_ex(ctx, sha256, NULL)) <br>\ngoto err; <br>\n/* <br>\n* Pass the message to be digested. This can be passed in\nover multiple <br>\n* EVP_DigestUpdate calls if necessary <br>\n*/ <br>\nif (!EVP_DigestUpdate(ctx, msg, sizeof(msg))) <br>\ngoto err; <br>\n/* Allocate the output buffer */ <br>\noutdigest = OPENSSL_malloc(EVP_MD_get_size(sha256)); <br>\nif (outdigest == NULL) <br>\ngoto err; <br>\n/* Now calculate the digest itself */ <br>\nif (!EVP_DigestFinal_ex(ctx, outdigest, &amp;len)) <br>\ngoto err; <br>\n/* Print out the digest result */ <br>\nBIO_dump_fp(stdout, outdigest, len); <br>\nret = 0; <br>\nerr: <br>\n/* Clean up all the resources we allocated */ <br>\nOPENSSL_free(outdigest); <br>\nEVP_MD_free(sha256); <br>\nEVP_MD_CTX_free(ctx); <br>\nif (ret != 0) <br>\nERR_print_errors_fp(stderr); <br>\nreturn ret; <br>\n}</p>\n\n<h2>CONFIGURATION\n<a name=\"CONFIGURATION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default\nOpenSSL will load a configuration file when it is first\nused. This will set up various configuration settings within\nthe default library context. Applications that create their\nown library contexts may optionally configure them with a\nconfig file using the <a href=\"https://man.page/3/OSSL_LIB_CTX_load_config\">OSSL_LIB_CTX_load_config(3)</a>\nfunction.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nconfiguration file can be used to automatically load\nproviders and set up default property query strings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For information\non the OpenSSL configuration file format see\n<a href=\"https://man.page/5/config\">config(5)</a>.</p>\n\n<h2>ENCODING AND DECODING KEYS\n<a name=\"ENCODING AND DECODING KEYS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many algorithms\nrequire the use of a key. Keys can be generated dynamically\nusing the <small>EVP</small> APIs (for example see\n<a href=\"https://man.page/3/EVP_PKEY_Q_keygen\">EVP_PKEY_Q_keygen(3)</a>). However it is often necessary\nto save or load keys (or their associated parameters) to or\nfrom some external format such as <small>PEM</small> or\n<small>DER</small> (see <a href=\"https://man.page/7/openssl-glossary\">openssl-glossary(7)</a>). OpenSSL\nuses encoders and decoders to perform this task.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Encoders and\ndecoders are just algorithm implementations in the same way\nas any other algorithm implementation in OpenSSL. They are\nimplemented by providers. The OpenSSL encoders and decoders\nare available in the default provider. They are also\nduplicated in the base provider.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For information\nabout encoders see <a href=\"https://man.page/3/OSSL_ENCODER_CTX_new_for_pkey\">OSSL_ENCODER_CTX_new_for_pkey(3)</a>.\nFor information about decoders see\n<a href=\"https://man.page/3/OSSL_DECODER_CTX_new_for_pkey\">OSSL_DECODER_CTX_new_for_pkey(3)</a>.</p>\n\n<h2>LIBRARY CONVENTIONS\n<a name=\"LIBRARY CONVENTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many OpenSSL\nfunctions that &quot;get&quot; or &quot;set&quot; a value\nfollow a naming convention using the numbers <b>0</b> and\n<b>1</b>, i.e. &quot;get0&quot;, &quot;get1&quot;,\n&quot;set0&quot; and &quot;set1&quot;. This can also apply\nto some functions that &quot;add&quot; a value to an\nexisting set, i.e. &quot;add0&quot; and\n&quot;add1&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example the\nfunctions:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int\nX509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);\n<br>\nint X509_add1_trust_object(X509 *x, const ASN1_OBJECT\n*obj);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the <b>0</b>\nversion the ownership of the object is passed to (for an add\nor set) or retained by (for a get) the parent object. For\nexample after calling the <b>X509_CRL_add0_revoked()</b>\nfunction above, ownership of the <i>rev</i> object is passed\nto the <i>crl</i> object. Therefore, after calling this\nfunction <i>rev</i> should not be freed directly. It will be\nfreed implicitly when <i>crl</i> is freed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the <b>1</b>\nversion the ownership of the object is not passed to or\nretained by the parent object. Instead a copy or &quot;up\nref&quot; of the object is performed. So after calling the\n<b>X509_add1_trust_object()</b> function above the\napplication will still be responsible for freeing the\n<i>obj</i> value where appropriate.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/openssl\">openssl(1)</a>,\n<a href=\"https://man.page/7/ssl\">ssl(7)</a>, <a href=\"https://man.page/7/evp\">evp(7)</a>,\n<b><small>OSSL_LIB_CTX</small></b> (3),\n<a href=\"https://man.page/7/openssl-threads\">openssl-threads(7)</a>, <a href=\"https://man.page/7/property\">property(7)</a>,\n<a href=\"https://man.page/7/OSSL_PROVIDER-default\">OSSL_PROVIDER-default(7)</a>,\n<a href=\"https://man.page/7/OSSL_PROVIDER-base\">OSSL_PROVIDER-base(7)</a>,\n<b><small>OSSL_PROVIDER-FIPS</small></b> (7),\n<a href=\"https://man.page/7/OSSL_PROVIDER-legacy\">OSSL_PROVIDER-legacy(7)</a>,\n<a href=\"https://man.page/7/OSSL_PROVIDER-null\">OSSL_PROVIDER-null(7)</a>, <a href=\"https://man.page/7/openssl-glossary\">openssl-glossary(7)</a>,\n<a href=\"https://man.page/7/provider\">provider(7)</a></p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n2000-2022 The OpenSSL Project Authors. All Rights\nReserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nthe Apache License 2.0 (the &quot;License&quot;). You may\nnot use this file except in compliance with the License. You\ncan obtain a copy in the file <small>LICENSE</small> in the\nsource distribution or at\n&lt;https://www.openssl.org/source/license.html&gt;.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ALGORITHM FETCHING\">ALGORITHM FETCHING</a>","<a href=\"#FETCHING EXAMPLES\">FETCHING EXAMPLES</a>","<a href=\"#OPENSSL PROVIDERS\">OPENSSL PROVIDERS</a>","<a href=\"#USING ALGORITHMS IN APPLICATIONS\">USING ALGORITHMS IN APPLICATIONS</a>","<a href=\"#CONFIGURATION\">CONFIGURATION</a>","<a href=\"#ENCODING AND DECODING KEYS\">ENCODING AND DECODING KEYS</a>","<a href=\"#LIBRARY CONVENTIONS\">LIBRARY CONVENTIONS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":7}