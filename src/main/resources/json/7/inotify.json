{"name":"inotify","description":"inotify -\nmonitoring filesystem events\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nThe\n<i>inotify</i> API provides a mechanism for monitoring\nfilesystem events. Inotify can be used to monitor individual\nfiles, or to monitor directories. When a directory is\nmonitored, inotify will return events for the directory\nitself, and for files inside the directory.\n\nThe following\nsystem calls are used with this API:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a> creates an inotify instance and\nreturns a file descriptor referring to the inotify instance.\nThe more recent <a href=\"https://man.page/2/inotify_init1\">inotify_init1(2)</a> is like\n<a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a>, but has a <i>flags</i> argument that\nprovides access to some extra functionality.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> manipulates the &quot;watch\nlist&quot; associated with an inotify instance. Each item\n(&quot;watch&quot;) in the watch list specifies the pathname\nof a file or directory, along with some set of events that\nthe kernel should monitor for the file referred to by that\npathname. <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> either creates a new\nwatch item, or modifies an existing watch. Each watch has a\nunique &quot;watch descriptor&quot;, an integer returned by\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> when the watch is created.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>When events occur for monitored files and directories,\nthose events are made available to the application as\nstructured data that can be read from the inotify file\ndescriptor using <a href=\"https://man.page/2/read\">read(2)</a> (see below).</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a> removes an item from an\ninotify watch list.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>When all file descriptors referring to an inotify\ninstance have been closed (using <a href=\"https://man.page/2/close\">close(2)</a>), the\nunderlying object and its resources are freed for reuse by\nthe kernel; all associated watches are automatically\nfreed. </td></tr>\n</table>\n\nWith careful\nprogramming, an application can use inotify to efficiently\nmonitor and cache the state of a set of filesystem objects.\nHowever, robust applications should allow for the fact that\nbugs in the monitoring logic or races of the kind described\nbelow may leave the cache inconsistent with the filesystem\nstate. It is probably wise to do some consistency checking,\nand rebuild the cache when inconsistencies are detected.\n\n<b>Reading\nevents from an inotify file descriptor</b> <br>\nTo determine what events have occurred, an application\n<a href=\"https://man.page/2/read\">read(2)</a>s from the inotify file descriptor. If no\nevents have so far occurred, then, assuming a blocking file\ndescriptor, <a href=\"https://man.page/2/read\">read(2)</a> will block until at least one\nevent occurs (unless interrupted by a signal, in which case\nthe call fails with the error <b>EINTR</b>; see\n<a href=\"https://man.page/7/signal\">signal(7)</a>).\n\nEach successful\n<a href=\"https://man.page/2/read\">read(2)</a> returns a buffer containing one or more of\nthe following structures:\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\ninotify_event { <br>\nint wd; /* Watch descriptor */ <br>\nuint32_t mask; /* Mask describing event */ <br>\nuint32_t cookie; /* Unique cookie associating related <br>\nevents (for rename(2)) */ <br>\nuint32_t len; /* Size of <i>name</i> field */ <br>\nchar name[]; /* Optional null-terminated name */ <br>\n};\n\n<i>wd</i>\nidentifies the watch for which this event occurs. It is one\nof the watch descriptors returned by a previous call to\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>.\n\n<i>mask</i>\ncontains bits that describe the event that occurred (see\nbelow).\n\n<i>cookie</i>\nis a unique integer that connects related events. Currently,\nthis is used only for rename events, and allows the\nresulting pair of <b>IN_MOVED_FROM</b> and\n<b>IN_MOVED_TO</b> events to be connected by the\napplication. For all other event types, <i>cookie</i> is set\nto 0.\n\nThe <i>name</i>\nfield is present only when an event is returned for a file\ninside a watched directory; it identifies the filename\nwithin the watched directory. This filename is\nnull-terminated, and may include further null bytes ('\\0')\nto align subsequent reads to a suitable address\nboundary.\n\nThe <i>len</i>\nfield counts all of the bytes in <i>name</i>, including the\nnull bytes; the length of each <i>inotify_event</i>\nstructure is thus <i>sizeof(struct\ninotify_event)+len</i>.\n\nThe behavior\nwhen the buffer given to <a href=\"https://man.page/2/read\">read(2)</a> is too small to\nreturn information about the next event depends on the\nkernel version: in kernels before 2.6.21, <a href=\"https://man.page/2/read\">read(2)</a>\nreturns 0; since kernel 2.6.21, <a href=\"https://man.page/2/read\">read(2)</a> fails with\nthe error <b>EINVAL</b>. Specifying a buffer of size\n\nsizeof(struct\ninotify_event) + NAME_MAX + 1\n\nwill be\nsufficient to read at least one event.\n\n<b>inotify\nevents</b> <br>\nThe <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> <i>mask</i> argument and the\n<i>mask</i> field of the <i>inotify_event</i> structure\nreturned when <a href=\"https://man.page/2/read\">read(2)</a>ing an inotify file descriptor\nare both bit masks identifying inotify events. The following\nbits can be specified in <i>mask</i> when calling\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> and may be returned in the\n<i>mask</i> field returned by <a href=\"https://man.page/2/read\">read(2)</a>:\n\n<p style=\"margin-left:17%;\"><b>IN_ACCESS</b> (+)\n\n<p style=\"margin-left:28%;\">File was accessed (e.g.,\n<a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/execve\">execve(2)</a>).\n\n<p style=\"margin-left:17%;\"><b>IN_ATTRIB</b> (*)\n\n<p style=\"margin-left:28%;\">Metadata changed&mdash;for\nexample, permissions (e.g., <a href=\"https://man.page/2/chmod\">chmod(2)</a>), timestamps\n(e.g., <a href=\"https://man.page/2/utimensat\">utimensat(2)</a>), extended attributes\n(<a href=\"https://man.page/2/setxattr\">setxattr(2)</a>), link count (since Linux 2.6.25; e.g.,\nfor the target of <a href=\"https://man.page/2/link\">link(2)</a> and for <a href=\"https://man.page/2/unlink\">unlink(2)</a>),\nand user/group ID (e.g., <a href=\"https://man.page/2/chown\">chown(2)</a>).\n\n<p style=\"margin-left:17%;\"><b>IN_CLOSE_WRITE</b> (+)\n\n<p style=\"margin-left:28%;\">File opened for writing was\nclosed.\n\n<p style=\"margin-left:17%;\"><b>IN_CLOSE_NOWRITE</b> (*)\n\n<p style=\"margin-left:28%;\">File or directory not opened\nfor writing was closed.\n\n<p style=\"margin-left:17%;\"><b>IN_CREATE</b> (+)\n\n<p style=\"margin-left:28%;\">File/directory created in\nwatched directory (e.g., <a href=\"https://man.page/2/open\">open(2)</a> <b>O_CREAT</b>,\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, <a href=\"https://man.page/2/link\">link(2)</a>, <a href=\"https://man.page/2/symlink\">symlink(2)</a>,\n<a href=\"https://man.page/2/bind\">bind(2)</a> on a UNIX domain socket).\n\n<p style=\"margin-left:17%;\"><b>IN_DELETE</b> (+)\n\n<p style=\"margin-left:28%;\">File/directory deleted from\nwatched directory.\n\n<p style=\"margin-left:17%;\"><b>IN_DELETE_SELF</b>\n\n<p style=\"margin-left:28%;\">Watched file/directory was\nitself deleted. (This event also occurs if an object is\nmoved to another filesystem, since <a href=\"https://man.page/1/mv\">mv(1)</a> in effect\ncopies the file to the other filesystem and then deletes it\nfrom the original filesystem.) In addition, an\n<b>IN_IGNORED</b> event will subsequently be generated for\nthe watch descriptor.\n\n<p style=\"margin-left:17%;\"><b>IN_MODIFY</b> (+)\n\n<p style=\"margin-left:28%;\">File was modified (e.g.,\n<a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/2/truncate\">truncate(2)</a>).\n\n<p style=\"margin-left:17%;\"><b>IN_MOVE_SELF</b>\n\n<p style=\"margin-left:28%;\">Watched file/directory was\nitself moved.\n\n<p style=\"margin-left:17%;\"><b>IN_MOVED_FROM</b> (+)\n\n<p style=\"margin-left:28%;\">Generated for the directory\ncontaining the old filename when a file is renamed.\n\n<p style=\"margin-left:17%;\"><b>IN_MOVED_TO</b> (+)\n\n<p style=\"margin-left:28%;\">Generated for the directory\ncontaining the new filename when a file is renamed.\n\n<p style=\"margin-left:17%;\"><b>IN_OPEN</b> (*)\n\n<p style=\"margin-left:28%;\">File or directory was\nopened.\n\nInotify\nmonitoring is inode-based: when monitoring a file (but not\nwhen monitoring the directory containing a file), an event\ncan be generated for activity on any link to the file (in\nthe same or a different directory).\n\nWhen monitoring\na directory:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>the events marked above with an asterisk (*) can occur\nboth for the directory itself and for objects inside the\ndirectory; and</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>the events marked with a plus sign (+) occur only for\nobjects inside the directory (not for the directory\nitself). </td></tr>\n</table>\n\n<i>Note</i>:\nwhen monitoring a directory, events are not generated for\nthe files inside the directory when the events are performed\nvia a pathname (i.e., a link) that lies outside the\nmonitored directory.\n\nWhen events are\ngenerated for objects inside a watched directory, the\n<i>name</i> field in the returned <i>inotify_event</i>\nstructure identifies the name of the file within the\ndirectory.\n\nThe\n<b>IN_ALL_EVENTS</b> macro is defined as a bit mask of all\nof the above events. This macro can be used as the\n<i>mask</i> argument when calling\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>.\n\nTwo additional\nconvenience macros are defined:\n\n<p style=\"margin-left:17%;\"><b>IN_MOVE</b>\n\n<p style=\"margin-left:28%;\">Equates to <b>IN_MOVED_FROM |\nIN_MOVED_TO</b>.\n\n<p style=\"margin-left:17%;\"><b>IN_CLOSE</b>\n\n<p style=\"margin-left:28%;\">Equates to <b>IN_CLOSE_WRITE |\nIN_CLOSE_NOWRITE</b>.\n\nThe following\nfurther bits can be specified in <i>mask</i> when calling\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>:\n\n<p style=\"margin-left:17%;\"><b>IN_DONT_FOLLOW</b> (since\nLinux 2.6.15)\n\n<p style=\"margin-left:28%;\">Don&rsquo;t dereference\n<i>pathname</i> if it is a symbolic link.\n\n<p style=\"margin-left:17%;\"><b>IN_EXCL_UNLINK</b> (since\nLinux 2.6.36)\n\n<p style=\"margin-left:28%;\">By default, when watching\nevents on the children of a directory, events are generated\nfor children even after they have been unlinked from the\ndirectory. This can result in large numbers of uninteresting\nevents for some applications (e.g., if watching <i>/tmp</i>,\nin which many applications create temporary files whose\nnames are immediately unlinked). Specifying\n<b>IN_EXCL_UNLINK</b> changes the default behavior, so that\nevents are not generated for children after they have been\nunlinked from the watched directory.\n\n<p style=\"margin-left:17%;\"><b>IN_MASK_ADD</b>\n\n<p style=\"margin-left:28%;\">If a watch instance already\nexists for the filesystem object corresponding to\n<i>pathname</i>, add (OR) the events in <i>mask</i> to the\nwatch mask (instead of replacing the mask); the error\n<b>EINVAL</b> results if <b>IN_MASK_CREATE</b> is also\nspecified.\n\n<p style=\"margin-left:17%;\"><b>IN_ONESHOT</b>\n\n<p style=\"margin-left:28%;\">Monitor the filesystem object\ncorresponding to <i>pathname</i> for one event, then remove\nfrom watch list.\n\n<p style=\"margin-left:17%;\"><b>IN_ONLYDIR</b> (since Linux\n2.6.15)\n\n<p style=\"margin-left:28%;\">Watch <i>pathname</i> only if\nit is a directory; the error <b>ENOTDIR</b> results if\n<i>pathname</i> is not a directory. Using this flag provides\nan application with a race-free way of ensuring that the\nmonitored object is a directory.\n\n<p style=\"margin-left:17%;\"><b>IN_MASK_CREATE</b> (since\nLinux 4.18)\n\n<p style=\"margin-left:28%;\">Watch <i>pathname</i> only if\nit does not already have a watch associated with it; the\nerror <b>EEXIST</b> results if <i>pathname</i> is already\nbeing watched.\n\n<p style=\"margin-left:28%; margin-top: 1em\">Using this flag\nprovides an application with a way of ensuring that new\nwatches do not modify existing ones. This is useful because\nmultiple paths may refer to the same inode, and multiple\ncalls to <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> without this flag may\nclobber existing watch masks.\n\nThe following\nbits may be set in the <i>mask</i> field returned by\n<a href=\"https://man.page/2/read\">read(2)</a>:\n\n<p style=\"margin-left:17%;\"><b>IN_IGNORED</b>\n\n<p style=\"margin-left:28%;\">Watch was removed explicitly\n(<a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a>) or automatically (file was\ndeleted, or filesystem was unmounted). See also BUGS.\n\n<p style=\"margin-left:17%;\"><b>IN_ISDIR</b>\n\n<p style=\"margin-left:28%;\">Subject of this event is a\ndirectory.\n\n<p style=\"margin-left:17%;\"><b>IN_Q_OVERFLOW</b>\n\n<p style=\"margin-left:28%;\">Event queue overflowed\n(<i>wd</i> is -1 for this event).\n\n<p style=\"margin-left:17%;\"><b>IN_UNMOUNT</b>\n\n<p style=\"margin-left:28%;\">Filesystem containing watched\nobject was unmounted. In addition, an <b>IN_IGNORED</b>\nevent will subsequently be generated for the watch\ndescriptor.\n\n\n<b>Examples</b>\n<br>\nSuppose an application is watching the directory <i>dir</i>\nand the file <i>dir/myfile</i> for all events. The examples\nbelow show some events that will be generated for these two\nobjects.\n\n<p style=\"margin-left:17%;\">fd =\nopen(&quot;dir/myfile&quot;, O_RDWR);\n\n<p style=\"margin-left:28%;\">Generates <b>IN_OPEN</b> events\nfor both <i>dir</i> and <i>dir/myfile</i>.\n\n<p style=\"margin-left:17%;\">read(fd, buf, count);\n\n<p style=\"margin-left:28%;\">Generates <b>IN_ACCESS</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.\n\n<p style=\"margin-left:17%;\">write(fd, buf, count);\n\n<p style=\"margin-left:28%;\">Generates <b>IN_MODIFY</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.\n\n<p style=\"margin-left:17%;\">fchmod(fd, mode);\n\n<p style=\"margin-left:28%;\">Generates <b>IN_ATTRIB</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.\n\n<p style=\"margin-left:17%;\">close(fd);\n\n<p style=\"margin-left:28%;\">Generates <b>IN_CLOSE_WRITE</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.\n\nSuppose an\napplication is watching the directories <i>dir1</i> and\n<i>dir2</i>, and the file <i>dir1/myfile</i>. The following\nexamples show some events that may be generated.\n\n<p style=\"margin-left:17%;\">link(&quot;dir1/myfile&quot;,\n&quot;dir2/new&quot;);\n\n<p style=\"margin-left:28%;\">Generates an <b>IN_ATTRIB</b>\nevent for <i>myfile</i> and an <b>IN_CREATE</b> event for\n<i>dir2</i>.\n\n\n<p style=\"margin-left:17%;\">rename(&quot;dir1/myfile&quot;,\n&quot;dir2/myfile&quot;);\n\n<p style=\"margin-left:28%;\">Generates an\n<b>IN_MOVED_FROM</b> event for <i>dir1</i>, an\n<b>IN_MOVED_TO</b> event for <i>dir2</i>, and an\n<b>IN_MOVE_SELF</b> event for <i>myfile</i>. The\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> events will have\nthe same <i>cookie</i> value.\n\nSuppose that\n<i>dir1/xx</i> and <i>dir2/yy</i> are (the only) links to\nthe same file, and an application is watching <i>dir1</i>,\n<i>dir2</i>, <i>dir1/xx</i>, and <i>dir2/yy</i>. Executing\nthe following calls in the order given below will generate\nthe following events:\n\n\n<p style=\"margin-left:17%;\">unlink(&quot;dir2/yy&quot;);\n\n<p style=\"margin-left:28%;\">Generates an <b>IN_ATTRIB</b>\nevent for <i>xx</i> (because its link count changes) and an\n<b>IN_DELETE</b> event for <i>dir2</i>.\n\n\n<p style=\"margin-left:17%;\">unlink(&quot;dir1/xx&quot;);\n\n<p style=\"margin-left:28%;\">Generates <b>IN_ATTRIB</b>,\n<b>IN_DELETE_SELF</b>, and <b>IN_IGNORED</b> events for\n<i>xx</i>, and an <b>IN_DELETE</b> event for\n<i>dir1</i>.\n\nSuppose an\napplication is watching the directory <i>dir</i> and (the\nempty) directory <i>dir/subdir</i>. The following examples\nshow some events that may be generated.\n\n<p style=\"margin-left:17%;\">mkdir(&quot;dir/new&quot;,\nmode);\n\n<p style=\"margin-left:28%;\">Generates an <b>IN_CREATE |\nIN_ISDIR</b> event for <i>dir</i>.\n\n\n<p style=\"margin-left:17%;\">rmdir(&quot;dir/subdir&quot;);\n\n<p style=\"margin-left:28%;\">Generates <b>IN_DELETE_SELF</b>\nand <b>IN_IGNORED</b> events for <i>subdir</i>, and an\n<b>IN_DELETE | IN_ISDIR</b> event for <i>dir</i>.\n\n<b>/proc\ninterfaces</b> <br>\nThe following interfaces can be used to limit the amount of\nkernel memory consumed by inotify: <i><br>\n/proc/sys/fs/inotify/max_queued_events</i>\n\n<p style=\"margin-left:22%;\">The value in this file is used\nwhen an application calls <a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a> to set an\nupper limit on the number of events that can be queued to\nthe corresponding inotify instance. Events in excess of this\nlimit are dropped, but an <b>IN_Q_OVERFLOW</b> event is\nalways generated.\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/inotify/max_user_instances</i>\n\n<p style=\"margin-left:22%;\">This specifies an upper limit\non the number of inotify instances that can be created per\nreal user ID.\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/inotify/max_user_watches</i>\n\n<p style=\"margin-left:22%;\">This specifies an upper limit\non the number of watches that can be created per real user\nID.\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\nInotify was\nmerged into the 2.6.13 Linux kernel. The required library\ninterfaces were added to glibc in version 2.4.\n(<b>IN_DONT_FOLLOW</b>, <b>IN_MASK_ADD</b>, and\n<b>IN_ONLYDIR</b> were added in glibc version 2.5.)\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\nThe inotify API\nis Linux-specific.\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\nInotify file\ndescriptors can be monitored using <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/poll\">poll(2)</a>, and <a href=\"https://man.page/7/epoll\">epoll(7)</a>. When an event is\navailable, the file descriptor indicates as readable.\n\nSince Linux\n2.6.25, signal-driven I/O notification is available for\ninotify file descriptors; see the discussion of\n<b>F_SETFL</b> (for setting the <b>O_ASYNC</b> flag),\n<b>F_SETOWN</b>, and <b>F_SETSIG</b> in <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>. The\n<i>siginfo_t</i> structure (described in\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>) that is passed to the signal handler\nhas the following fields set: <i>si_fd</i> is set to the\ninotify file descriptor number; <i>si_signo</i> is set to\nthe signal number; <i>si_code</i> is set to <b>POLL_IN</b>;\nand <b>POLLIN</b> is set in <i>si_band</i>.\n\nIf successive\noutput inotify events produced on the inotify file\ndescriptor are identical (same <i>wd</i>, <i>mask</i>,\n<i>cookie</i>, and <i>name</i>), then they are coalesced\ninto a single event if the older event has not yet been read\n(but see BUGS). This reduces the amount of kernel memory\nrequired for the event queue, but also means that an\napplication can&rsquo;t use inotify to reliably count file\nevents.\n\nThe events\nreturned by reading from an inotify file descriptor form an\nordered queue. Thus, for example, it is guaranteed that when\nrenaming from one directory to another, events will be\nproduced in the correct order on the inotify file\ndescriptor.\n\nThe set of\nwatch descriptors that is being monitored via an inotify\nfile descriptor can be viewed via the entry for the inotify\nfile descriptor in the process&rsquo;s\n<i>/proc/[pid]/fdinfo</i> directory. See <a href=\"https://man.page/5/proc\">proc(5)</a> for\nfurther details. The <b>FIONREAD ioctl</b>(2) returns the\nnumber of bytes available to read from an inotify file\ndescriptor.\n\n<b>Limitations\nand caveats</b> <br>\nThe inotify API provides no information about the user or\nprocess that triggered the inotify event. In particular,\nthere is no easy way for a process that is monitoring events\nvia inotify to distinguish events that it triggers itself\nfrom those that are triggered by other processes.\n\nInotify reports\nonly events that a user-space program triggers through the\nfilesystem API. As a result, it does not catch remote events\nthat occur on network filesystems. (Applications must fall\nback to polling the filesystem to catch such events.)\nFurthermore, various pseudo-filesystems such as\n<i>/proc</i>, <i>/sys</i>, and <i>/dev/pts</i> are not\nmonitorable with inotify.\n\nThe inotify API\ndoes not report file accesses and modifications that may\noccur because of <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/msync\">msync(2)</a>, and\n<a href=\"https://man.page/2/munmap\">munmap(2)</a>.\n\nThe inotify API\nidentifies affected files by filename. However, by the time\nan application processes an inotify event, the filename may\nalready have been deleted or renamed.\n\nThe inotify API\nidentifies events via watch descriptors. It is the\napplication&rsquo;s responsibility to cache a mapping (if\none is needed) between watch descriptors and pathnames. Be\naware that directory renamings may affect multiple cached\npathnames.\n\nInotify\nmonitoring of directories is not recursive: to monitor\nsubdirectories under a directory, additional watches must be\ncreated. This can take a significant amount time for large\ndirectory trees.\n\nIf monitoring\nan entire directory subtree, and a new subdirectory is\ncreated in that tree or an existing directory is renamed\ninto that tree, be aware that by the time you create a watch\nfor the new subdirectory, new files (and subdirectories) may\nalready exist inside the subdirectory. Therefore, you may\nwant to scan the contents of the subdirectory immediately\nafter adding the watch (and, if desired, recursively add\nwatches for any subdirectories that it contains).\n\nNote that the\nevent queue can overflow. In this case, events are lost.\nRobust applications should handle the possibility of lost\nevents gracefully. For example, it may be necessary to\nrebuild part or all of the application cache. (One simple,\nbut possibly expensive, approach is to close the inotify\nfile descriptor, empty the cache, create a new inotify file\ndescriptor, and then re-create watches and cache entries for\nthe objects to be monitored.)\n\nIf a filesystem\nis mounted on top of a monitored directory, no event is\ngenerated, and no events are generated for objects\nimmediately under the new mount point. If the filesystem is\nsubsequently unmounted, events will subsequently be\ngenerated for the directory and the objects it contains.\n\n<b>Dealing with\nrename() events</b> <br>\nAs noted above, the <b>IN_MOVED_FROM</b> and\n<b>IN_MOVED_TO</b> event pair that is generated by\n<a href=\"https://man.page/2/rename\">rename(2)</a> can be matched up via their shared cookie\nvalue. However, the task of matching has some\nchallenges.\n\nThese two\nevents are usually consecutive in the event stream available\nwhen reading from the inotify file descriptor. However, this\nis not guaranteed. If multiple processes are triggering\nevents for monitored objects, then (on rare occasions) an\narbitrary number of other events may appear between the\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> events.\nFurthermore, it is not guaranteed that the event pair is\natomically inserted into the queue: there may be a brief\ninterval where the <b>IN_MOVED_FROM</b> has appeared, but\nthe <b>IN_MOVED_TO</b> has not.\n\nMatching up the\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> event pair\ngenerated by <a href=\"https://man.page/2/rename\">rename(2)</a> is thus inherently racy.\n(Don&rsquo;t forget that if an object is renamed outside of\na monitored directory, there may not even be an\n<b>IN_MOVED_TO</b> event.) Heuristic approaches (e.g.,\nassume the events are always consecutive) can be used to\nensure a match in most cases, but will inevitably miss some\ncases, causing the application to perceive the\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> events as being\nunrelated. If watch descriptors are destroyed and re-created\nas a result, then those watch descriptors will be\ninconsistent with the watch descriptors in any pending\nevents. (Re-creating the inotify file descriptor and\nrebuilding the cache may be useful to deal with this\nscenario.)\n\nApplications\nshould also allow for the possibility that the\n<b>IN_MOVED_FROM</b> event was the last event that could fit\nin the buffer returned by the current call to\n<a href=\"https://man.page/2/read\">read(2)</a>, and the accompanying <b>IN_MOVED_TO</b>\nevent might be fetched only on the next <a href=\"https://man.page/2/read\">read(2)</a>,\nwhich should be done with a (small) timeout to allow for the\nfact that insertion of the\n<b>IN_MOVED_FROM</b>-<b>IN_MOVED_TO</b> event pair is not\natomic, and also the possibility that there may not be any\n<b>IN_MOVED_TO</b> event.\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\nBefore Linux\n3.19, <a href=\"https://man.page/2/fallocate\">fallocate(2)</a> did not create any inotify events.\nSince Linux 3.19, calls to <a href=\"https://man.page/2/fallocate\">fallocate(2)</a> generate\n<b>IN_MODIFY</b> events.\n\nIn kernels\nbefore 2.6.16, the <b>IN_ONESHOT</b> <i>mask</i> flag does\nnot work.\n\nAs originally\ndesigned and implemented, the <b>IN_ONESHOT</b> flag did not\ncause an <b>IN_IGNORED</b> event to be generated when the\nwatch was dropped after one event. However, as an unintended\neffect of other changes, since Linux 2.6.36, an\n<b>IN_IGNORED</b> event is generated in this case.\n\nBefore kernel\n2.6.25, the kernel code that was intended to coalesce\nsuccessive identical events (i.e., the two most recent\nevents could potentially be coalesced if the older had not\nyet been read) instead checked if the most recent event\ncould be coalesced with the <i>oldest</i> unread event.\n\nWhen a watch\ndescriptor is removed by calling <a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a>\n(or because a watch file is deleted or the filesystem that\ncontains it is unmounted), any pending unread events for\nthat watch descriptor remain available to read. As watch\ndescriptors are subsequently allocated with\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>, the kernel cycles through the\nrange of possible watch descriptors (0 to <b>INT_MAX</b>)\nincrementally. When allocating a free watch descriptor, no\ncheck is made to see whether that watch descriptor number\nhas any pending unread events in the inotify queue. Thus, it\ncan happen that a watch descriptor is reallocated even when\npending unread events exist for a previous incarnation of\nthat watch descriptor number, with the result that the\napplication might then read those events and interpret them\nas belonging to the file associated with the newly recycled\nwatch descriptor. In practice, the likelihood of hitting\nthis bug may be extremely low, since it requires that an\napplication cycle through <b>INT_MAX</b> watch descriptors,\nrelease a watch descriptor while leaving unread events for\nthat watch descriptor in the queue, and then recycle that\nwatch descriptor. For this reason, and because there have\nbeen no reports of the bug occurring in real-world\napplications, as of Linux 3.15, no kernel changes have yet\nbeen made to eliminate this possible bug.\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\nThe following\nprogram demonstrates the usage of the inotify API. It marks\nthe directories passed as a command-line arguments and waits\nfor events of type <b>IN_OPEN</b>, <b>IN_CLOSE_NOWRITE</b>,\nand <b>IN_CLOSE_WRITE</b>.\n\nThe following\noutput was recorded while editing the file\n<i>/home/user/temp/foo</i> and listing directory\n<i>/tmp</i>. Before the file and the directory were opened,\n<b>IN_OPEN</b> events occurred. After the file was closed,\nan <b>IN_CLOSE_WRITE</b> event occurred. After the directory\nwas closed, an <b>IN_CLOSE_NOWRITE</b> event occurred.\nExecution of the program ended when the user pressed the\nENTER key.\n\n<b>Example\noutput</b>\n\n<p style=\"margin-left:17%;\">$ <b>./a.out /tmp\n/home/user/temp</b> <br>\nPress enter key to terminate. <br>\nListening for events. <br>\nIN_OPEN: /home/user/temp/foo [file] <br>\nIN_CLOSE_WRITE: /home/user/temp/foo [file] <br>\nIN_OPEN: /tmp/ [directory] <br>\nIN_CLOSE_NOWRITE: /tmp/ [directory]\n\n<p style=\"margin-left:17%; margin-top: 1em\">Listening for\nevents stopped.\n\n<b>Program\nsource</b> <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;poll.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/inotify.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt;\n\n/* Read all\navailable inotify events from the file descriptor 'fd'. <br>\nwd is the table of watch descriptors for the directories in\nargv. <br>\nargc is the length of wd and argv. <br>\nargv is the list of watched directories. <br>\nEntry 0 of wd and argv is unused. */\n\nstatic void\n<br>\nhandle_events(int fd, int *wd, int argc, char* argv[]) <br>\n{ <br>\n/* Some systems cannot read integer variables if they are\nnot <br>\nproperly aligned. On other systems, incorrect alignment may\n<br>\ndecrease performance. Hence, the buffer used for reading\nfrom <br>\nthe inotify file descriptor should have the same alignment\nas <br>\nstruct inotify_event. */\n\nchar buf[4096]\n<br>\n__attribute__ ((aligned(__alignof__(struct\ninotify_event)))); <br>\nconst struct inotify_event *event; <br>\nssize_t len;\n\n/* Loop while\nevents can be read from inotify file descriptor. */\n\nfor (;;) {\n\n/* Read some\nevents. */\n\nlen = read(fd,\nbuf, sizeof(buf)); <br>\nif (len == -1 &amp;&amp; errno != EAGAIN) { <br>\nperror(&quot;read&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}\n\n/* If the\nnonblocking read() found no events to read, then <br>\nit returns -1 with errno set to EAGAIN. In that case, <br>\nwe exit the loop. */\n\nif (len &lt;=\n0) <br>\nbreak;\n\n/* Loop over\nall events in the buffer */\n\nfor (char *ptr\n= buf; ptr &lt; buf + len; <br>\nptr += sizeof(struct inotify_event) + event-&gt;len) {\n\nevent = (const\nstruct inotify_event *) ptr;\n\n/* Print event\ntype */\n\nif\n(event-&gt;mask &amp; IN_OPEN) <br>\nprintf(&quot;IN_OPEN: &quot;); <br>\nif (event-&gt;mask &amp; IN_CLOSE_NOWRITE) <br>\nprintf(&quot;IN_CLOSE_NOWRITE: &quot;); <br>\nif (event-&gt;mask &amp; IN_CLOSE_WRITE) <br>\nprintf(&quot;IN_CLOSE_WRITE: &quot;);\n\n/* Print the\nname of the watched directory */\n\nfor (int i = 1;\ni &lt; argc; ++i) { <br>\nif (wd[i] == event-&gt;wd) { <br>\nprintf(&quot;%s/&quot;, argv[i]); <br>\nbreak; <br>\n} <br>\n}\n\n/* Print the\nname of the file */\n\nif\n(event-&gt;len) <br>\nprintf(&quot;%s&quot;, event-&gt;name);\n\n/* Print type\nof filesystem object */\n\nif\n(event-&gt;mask &amp; IN_ISDIR) <br>\nprintf(&quot; [directory]\\n&quot;); <br>\nelse <br>\nprintf(&quot; [file]\\n&quot;); <br>\n} <br>\n} <br>\n}\n\nint <br>\nmain(int argc, char* argv[]) <br>\n{ <br>\nchar buf; <br>\nint fd, i, poll_num; <br>\nint *wd; <br>\nnfds_t nfds; <br>\nstruct pollfd fds[2];\n\nif (argc &lt;\n2) { <br>\nprintf(&quot;Usage: %s PATH [PATH ...]\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}\n\n\nprintf(&quot;Press\nENTER key to terminate.\\n&quot;);\n\n/* Create the\nfile descriptor for accessing the inotify API */\n\nfd =\ninotify_init1(IN_NONBLOCK); <br>\nif (fd == -1) { <br>\nperror(&quot;inotify_init1&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}\n\n/* Allocate\nmemory for watch descriptors */\n\nwd =\ncalloc(argc, sizeof(int)); <br>\nif (wd == NULL) { <br>\nperror(&quot;calloc&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}\n\n/* Mark\ndirectories for events <br>\n- file was opened <br>\n- file was closed */\n\nfor (i = 1; i\n&lt; argc; i++) { <br>\nwd[i] = inotify_add_watch(fd, argv[i], <br>\nIN_OPEN | IN_CLOSE); <br>\nif (wd[i] == -1) { <br>\nfprintf(stderr, &quot;Cannot watch '%s': %s\\n&quot;, <br>\nargv[i], strerror(errno)); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\n}\n\n/* Prepare for\npolling */\n\nnfds = 2;\n\n/* Console\ninput */\n\nfds[0].fd =\nSTDIN_FILENO; <br>\nfds[0].events = POLLIN;\n\n/* Inotify\ninput */\n\nfds[1].fd = fd;\n<br>\nfds[1].events = POLLIN;\n\n/* Wait for\nevents and/or terminal input */\n\n\nprintf(&quot;Listening\nfor events.\\n&quot;); <br>\nwhile (1) { <br>\npoll_num = poll(fds, nfds, -1); <br>\nif (poll_num == -1) { <br>\nif (errno == EINTR) <br>\ncontinue; <br>\nperror(&quot;poll&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}\n\nif (poll_num\n&gt; 0) {\n\nif\n(fds[0].revents &amp; POLLIN) {\n\n/* Console\ninput is available. Empty stdin and quit */\n\nwhile\n(read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf !=\n'\\n') <br>\ncontinue; <br>\nbreak; <br>\n}\n\nif\n(fds[1].revents &amp; POLLIN) {\n\n/* Inotify\nevents are available */\n\n\nhandle_events(fd,\nwd, argc, argv); <br>\n} <br>\n} <br>\n}\n\n\nprintf(&quot;Listening\nfor events stopped.\\n&quot;);\n\n/* Close\ninotify file descriptor */\n\nclose(fd);\n\nfree(wd); <br>\nexit(EXIT_SUCCESS); <br>\n}\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/1/inotifywait\">inotifywait(1)</a>,\n<a href=\"https://man.page/1/inotifywatch\">inotifywatch(1)</a>, <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>,\n<a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a>, <a href=\"https://man.page/2/inotify_init1\">inotify_init1(2)</a>,\n<a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/stat\">stat(2)</a>,\n<a href=\"https://man.page/7/fanotify\">fanotify(7)</a>\n\n\n<i>Documentation/filesystems/inotify.txt</i>\nin the Linux kernel source tree\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\nThis page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.","body":"\n\n<h1 align=\"center\">INOTIFY</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">inotify -\nmonitoring filesystem events</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>inotify</i> API provides a mechanism for monitoring\nfilesystem events. Inotify can be used to monitor individual\nfiles, or to monitor directories. When a directory is\nmonitored, inotify will return events for the directory\nitself, and for files inside the directory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsystem calls are used with this API:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a> creates an inotify instance and\nreturns a file descriptor referring to the inotify instance.\nThe more recent <a href=\"https://man.page/2/inotify_init1\">inotify_init1(2)</a> is like\n<a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a>, but has a <i>flags</i> argument that\nprovides access to some extra functionality.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> manipulates the &quot;watch\nlist&quot; associated with an inotify instance. Each item\n(&quot;watch&quot;) in the watch list specifies the pathname\nof a file or directory, along with some set of events that\nthe kernel should monitor for the file referred to by that\npathname. <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> either creates a new\nwatch item, or modifies an existing watch. Each watch has a\nunique &quot;watch descriptor&quot;, an integer returned by\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> when the watch is created.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>When events occur for monitored files and directories,\nthose events are made available to the application as\nstructured data that can be read from the inotify file\ndescriptor using <a href=\"https://man.page/2/read\">read(2)</a> (see below).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a> removes an item from an\ninotify watch list.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>When all file descriptors referring to an inotify\ninstance have been closed (using <a href=\"https://man.page/2/close\">close(2)</a>), the\nunderlying object and its resources are freed for reuse by\nthe kernel; all associated watches are automatically\nfreed.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With careful\nprogramming, an application can use inotify to efficiently\nmonitor and cache the state of a set of filesystem objects.\nHowever, robust applications should allow for the fact that\nbugs in the monitoring logic or races of the kind described\nbelow may leave the cache inconsistent with the filesystem\nstate. It is probably wise to do some consistency checking,\nand rebuild the cache when inconsistencies are detected.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading\nevents from an inotify file descriptor</b> <br>\nTo determine what events have occurred, an application\n<a href=\"https://man.page/2/read\">read(2)</a>s from the inotify file descriptor. If no\nevents have so far occurred, then, assuming a blocking file\ndescriptor, <a href=\"https://man.page/2/read\">read(2)</a> will block until at least one\nevent occurs (unless interrupted by a signal, in which case\nthe call fails with the error <b>EINTR</b>; see\n<a href=\"https://man.page/7/signal\">signal(7)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each successful\n<a href=\"https://man.page/2/read\">read(2)</a> returns a buffer containing one or more of\nthe following structures:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\ninotify_event { <br>\nint wd; /* Watch descriptor */ <br>\nuint32_t mask; /* Mask describing event */ <br>\nuint32_t cookie; /* Unique cookie associating related <br>\nevents (for rename(2)) */ <br>\nuint32_t len; /* Size of <i>name</i> field */ <br>\nchar name[]; /* Optional null-terminated name */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>wd</i>\nidentifies the watch for which this event occurs. It is one\nof the watch descriptors returned by a previous call to\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>mask</i>\ncontains bits that describe the event that occurred (see\nbelow).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>cookie</i>\nis a unique integer that connects related events. Currently,\nthis is used only for rename events, and allows the\nresulting pair of <b>IN_MOVED_FROM</b> and\n<b>IN_MOVED_TO</b> events to be connected by the\napplication. For all other event types, <i>cookie</i> is set\nto 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>name</i>\nfield is present only when an event is returned for a file\ninside a watched directory; it identifies the filename\nwithin the watched directory. This filename is\nnull-terminated, and may include further null bytes ('\\0')\nto align subsequent reads to a suitable address\nboundary.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>len</i>\nfield counts all of the bytes in <i>name</i>, including the\nnull bytes; the length of each <i>inotify_event</i>\nstructure is thus <i>sizeof(struct\ninotify_event)+len</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The behavior\nwhen the buffer given to <a href=\"https://man.page/2/read\">read(2)</a> is too small to\nreturn information about the next event depends on the\nkernel version: in kernels before 2.6.21, <a href=\"https://man.page/2/read\">read(2)</a>\nreturns 0; since kernel 2.6.21, <a href=\"https://man.page/2/read\">read(2)</a> fails with\nthe error <b>EINVAL</b>. Specifying a buffer of size</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sizeof(struct\ninotify_event) + NAME_MAX + 1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">will be\nsufficient to read at least one event.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>inotify\nevents</b> <br>\nThe <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> <i>mask</i> argument and the\n<i>mask</i> field of the <i>inotify_event</i> structure\nreturned when <a href=\"https://man.page/2/read\">read(2)</a>ing an inotify file descriptor\nare both bit masks identifying inotify events. The following\nbits can be specified in <i>mask</i> when calling\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> and may be returned in the\n<i>mask</i> field returned by <a href=\"https://man.page/2/read\">read(2)</a>:</p>\n\n<p style=\"margin-left:17%;\"><b>IN_ACCESS</b> (+)</p>\n\n<p style=\"margin-left:28%;\">File was accessed (e.g.,\n<a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/execve\">execve(2)</a>).</p>\n\n<p style=\"margin-left:17%;\"><b>IN_ATTRIB</b> (*)</p>\n\n<p style=\"margin-left:28%;\">Metadata changed&mdash;for\nexample, permissions (e.g., <a href=\"https://man.page/2/chmod\">chmod(2)</a>), timestamps\n(e.g., <a href=\"https://man.page/2/utimensat\">utimensat(2)</a>), extended attributes\n(<a href=\"https://man.page/2/setxattr\">setxattr(2)</a>), link count (since Linux 2.6.25; e.g.,\nfor the target of <a href=\"https://man.page/2/link\">link(2)</a> and for <a href=\"https://man.page/2/unlink\">unlink(2)</a>),\nand user/group ID (e.g., <a href=\"https://man.page/2/chown\">chown(2)</a>).</p>\n\n<p style=\"margin-left:17%;\"><b>IN_CLOSE_WRITE</b> (+)</p>\n\n<p style=\"margin-left:28%;\">File opened for writing was\nclosed.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_CLOSE_NOWRITE</b> (*)</p>\n\n<p style=\"margin-left:28%;\">File or directory not opened\nfor writing was closed.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_CREATE</b> (+)</p>\n\n<p style=\"margin-left:28%;\">File/directory created in\nwatched directory (e.g., <a href=\"https://man.page/2/open\">open(2)</a> <b>O_CREAT</b>,\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, <a href=\"https://man.page/2/link\">link(2)</a>, <a href=\"https://man.page/2/symlink\">symlink(2)</a>,\n<a href=\"https://man.page/2/bind\">bind(2)</a> on a UNIX domain socket).</p>\n\n<p style=\"margin-left:17%;\"><b>IN_DELETE</b> (+)</p>\n\n<p style=\"margin-left:28%;\">File/directory deleted from\nwatched directory.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_DELETE_SELF</b></p>\n\n<p style=\"margin-left:28%;\">Watched file/directory was\nitself deleted. (This event also occurs if an object is\nmoved to another filesystem, since <a href=\"https://man.page/1/mv\">mv(1)</a> in effect\ncopies the file to the other filesystem and then deletes it\nfrom the original filesystem.) In addition, an\n<b>IN_IGNORED</b> event will subsequently be generated for\nthe watch descriptor.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_MODIFY</b> (+)</p>\n\n<p style=\"margin-left:28%;\">File was modified (e.g.,\n<a href=\"https://man.page/2/write\">write(2)</a>, <a href=\"https://man.page/2/truncate\">truncate(2)</a>).</p>\n\n<p style=\"margin-left:17%;\"><b>IN_MOVE_SELF</b></p>\n\n<p style=\"margin-left:28%;\">Watched file/directory was\nitself moved.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_MOVED_FROM</b> (+)</p>\n\n<p style=\"margin-left:28%;\">Generated for the directory\ncontaining the old filename when a file is renamed.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_MOVED_TO</b> (+)</p>\n\n<p style=\"margin-left:28%;\">Generated for the directory\ncontaining the new filename when a file is renamed.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_OPEN</b> (*)</p>\n\n<p style=\"margin-left:28%;\">File or directory was\nopened.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inotify\nmonitoring is inode-based: when monitoring a file (but not\nwhen monitoring the directory containing a file), an event\ncan be generated for activity on any link to the file (in\nthe same or a different directory).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When monitoring\na directory:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>the events marked above with an asterisk (*) can occur\nboth for the directory itself and for objects inside the\ndirectory; and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>the events marked with a plus sign (+) occur only for\nobjects inside the directory (not for the directory\nitself).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\nwhen monitoring a directory, events are not generated for\nthe files inside the directory when the events are performed\nvia a pathname (i.e., a link) that lies outside the\nmonitored directory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When events are\ngenerated for objects inside a watched directory, the\n<i>name</i> field in the returned <i>inotify_event</i>\nstructure identifies the name of the file within the\ndirectory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>IN_ALL_EVENTS</b> macro is defined as a bit mask of all\nof the above events. This macro can be used as the\n<i>mask</i> argument when calling\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Two additional\nconvenience macros are defined:</p>\n\n<p style=\"margin-left:17%;\"><b>IN_MOVE</b></p>\n\n<p style=\"margin-left:28%;\">Equates to <b>IN_MOVED_FROM |\nIN_MOVED_TO</b>.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_CLOSE</b></p>\n\n<p style=\"margin-left:28%;\">Equates to <b>IN_CLOSE_WRITE |\nIN_CLOSE_NOWRITE</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nfurther bits can be specified in <i>mask</i> when calling\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>:</p>\n\n<p style=\"margin-left:17%;\"><b>IN_DONT_FOLLOW</b> (since\nLinux 2.6.15)</p>\n\n<p style=\"margin-left:28%;\">Don&rsquo;t dereference\n<i>pathname</i> if it is a symbolic link.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_EXCL_UNLINK</b> (since\nLinux 2.6.36)</p>\n\n<p style=\"margin-left:28%;\">By default, when watching\nevents on the children of a directory, events are generated\nfor children even after they have been unlinked from the\ndirectory. This can result in large numbers of uninteresting\nevents for some applications (e.g., if watching <i>/tmp</i>,\nin which many applications create temporary files whose\nnames are immediately unlinked). Specifying\n<b>IN_EXCL_UNLINK</b> changes the default behavior, so that\nevents are not generated for children after they have been\nunlinked from the watched directory.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_MASK_ADD</b></p>\n\n<p style=\"margin-left:28%;\">If a watch instance already\nexists for the filesystem object corresponding to\n<i>pathname</i>, add (OR) the events in <i>mask</i> to the\nwatch mask (instead of replacing the mask); the error\n<b>EINVAL</b> results if <b>IN_MASK_CREATE</b> is also\nspecified.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_ONESHOT</b></p>\n\n<p style=\"margin-left:28%;\">Monitor the filesystem object\ncorresponding to <i>pathname</i> for one event, then remove\nfrom watch list.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_ONLYDIR</b> (since Linux\n2.6.15)</p>\n\n<p style=\"margin-left:28%;\">Watch <i>pathname</i> only if\nit is a directory; the error <b>ENOTDIR</b> results if\n<i>pathname</i> is not a directory. Using this flag provides\nan application with a race-free way of ensuring that the\nmonitored object is a directory.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_MASK_CREATE</b> (since\nLinux 4.18)</p>\n\n<p style=\"margin-left:28%;\">Watch <i>pathname</i> only if\nit does not already have a watch associated with it; the\nerror <b>EEXIST</b> results if <i>pathname</i> is already\nbeing watched.</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">Using this flag\nprovides an application with a way of ensuring that new\nwatches do not modify existing ones. This is useful because\nmultiple paths may refer to the same inode, and multiple\ncalls to <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a> without this flag may\nclobber existing watch masks.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nbits may be set in the <i>mask</i> field returned by\n<a href=\"https://man.page/2/read\">read(2)</a>:</p>\n\n<p style=\"margin-left:17%;\"><b>IN_IGNORED</b></p>\n\n<p style=\"margin-left:28%;\">Watch was removed explicitly\n(<a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a>) or automatically (file was\ndeleted, or filesystem was unmounted). See also BUGS.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_ISDIR</b></p>\n\n<p style=\"margin-left:28%;\">Subject of this event is a\ndirectory.</p>\n\n<p style=\"margin-left:17%;\"><b>IN_Q_OVERFLOW</b></p>\n\n<p style=\"margin-left:28%;\">Event queue overflowed\n(<i>wd</i> is -1 for this event).</p>\n\n<p style=\"margin-left:17%;\"><b>IN_UNMOUNT</b></p>\n\n<p style=\"margin-left:28%;\">Filesystem containing watched\nobject was unmounted. In addition, an <b>IN_IGNORED</b>\nevent will subsequently be generated for the watch\ndescriptor.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Examples</b>\n<br>\nSuppose an application is watching the directory <i>dir</i>\nand the file <i>dir/myfile</i> for all events. The examples\nbelow show some events that will be generated for these two\nobjects.</p>\n\n<p style=\"margin-left:17%;\">fd =\nopen(&quot;dir/myfile&quot;, O_RDWR);</p>\n\n<p style=\"margin-left:28%;\">Generates <b>IN_OPEN</b> events\nfor both <i>dir</i> and <i>dir/myfile</i>.</p>\n\n<p style=\"margin-left:17%;\">read(fd, buf, count);</p>\n\n<p style=\"margin-left:28%;\">Generates <b>IN_ACCESS</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.</p>\n\n<p style=\"margin-left:17%;\">write(fd, buf, count);</p>\n\n<p style=\"margin-left:28%;\">Generates <b>IN_MODIFY</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.</p>\n\n<p style=\"margin-left:17%;\">fchmod(fd, mode);</p>\n\n<p style=\"margin-left:28%;\">Generates <b>IN_ATTRIB</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.</p>\n\n<p style=\"margin-left:17%;\">close(fd);</p>\n\n<p style=\"margin-left:28%;\">Generates <b>IN_CLOSE_WRITE</b>\nevents for both <i>dir</i> and <i>dir/myfile</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose an\napplication is watching the directories <i>dir1</i> and\n<i>dir2</i>, and the file <i>dir1/myfile</i>. The following\nexamples show some events that may be generated.</p>\n\n<p style=\"margin-left:17%;\">link(&quot;dir1/myfile&quot;,\n&quot;dir2/new&quot;);</p>\n\n<p style=\"margin-left:28%;\">Generates an <b>IN_ATTRIB</b>\nevent for <i>myfile</i> and an <b>IN_CREATE</b> event for\n<i>dir2</i>.</p>\n\n\n<p style=\"margin-left:17%;\">rename(&quot;dir1/myfile&quot;,\n&quot;dir2/myfile&quot;);</p>\n\n<p style=\"margin-left:28%;\">Generates an\n<b>IN_MOVED_FROM</b> event for <i>dir1</i>, an\n<b>IN_MOVED_TO</b> event for <i>dir2</i>, and an\n<b>IN_MOVE_SELF</b> event for <i>myfile</i>. The\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> events will have\nthe same <i>cookie</i> value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose that\n<i>dir1/xx</i> and <i>dir2/yy</i> are (the only) links to\nthe same file, and an application is watching <i>dir1</i>,\n<i>dir2</i>, <i>dir1/xx</i>, and <i>dir2/yy</i>. Executing\nthe following calls in the order given below will generate\nthe following events:</p>\n\n\n<p style=\"margin-left:17%;\">unlink(&quot;dir2/yy&quot;);</p>\n\n<p style=\"margin-left:28%;\">Generates an <b>IN_ATTRIB</b>\nevent for <i>xx</i> (because its link count changes) and an\n<b>IN_DELETE</b> event for <i>dir2</i>.</p>\n\n\n<p style=\"margin-left:17%;\">unlink(&quot;dir1/xx&quot;);</p>\n\n<p style=\"margin-left:28%;\">Generates <b>IN_ATTRIB</b>,\n<b>IN_DELETE_SELF</b>, and <b>IN_IGNORED</b> events for\n<i>xx</i>, and an <b>IN_DELETE</b> event for\n<i>dir1</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose an\napplication is watching the directory <i>dir</i> and (the\nempty) directory <i>dir/subdir</i>. The following examples\nshow some events that may be generated.</p>\n\n<p style=\"margin-left:17%;\">mkdir(&quot;dir/new&quot;,\nmode);</p>\n\n<p style=\"margin-left:28%;\">Generates an <b>IN_CREATE |\nIN_ISDIR</b> event for <i>dir</i>.</p>\n\n\n<p style=\"margin-left:17%;\">rmdir(&quot;dir/subdir&quot;);</p>\n\n<p style=\"margin-left:28%;\">Generates <b>IN_DELETE_SELF</b>\nand <b>IN_IGNORED</b> events for <i>subdir</i>, and an\n<b>IN_DELETE | IN_ISDIR</b> event for <i>dir</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc\ninterfaces</b> <br>\nThe following interfaces can be used to limit the amount of\nkernel memory consumed by inotify: <i><br>\n/proc/sys/fs/inotify/max_queued_events</i></p>\n\n<p style=\"margin-left:22%;\">The value in this file is used\nwhen an application calls <a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a> to set an\nupper limit on the number of events that can be queued to\nthe corresponding inotify instance. Events in excess of this\nlimit are dropped, but an <b>IN_Q_OVERFLOW</b> event is\nalways generated.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/inotify/max_user_instances</i></p>\n\n<p style=\"margin-left:22%;\">This specifies an upper limit\non the number of inotify instances that can be created per\nreal user ID.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/fs/inotify/max_user_watches</i></p>\n\n<p style=\"margin-left:22%;\">This specifies an upper limit\non the number of watches that can be created per real user\nID.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inotify was\nmerged into the 2.6.13 Linux kernel. The required library\ninterfaces were added to glibc in version 2.4.\n(<b>IN_DONT_FOLLOW</b>, <b>IN_MASK_ADD</b>, and\n<b>IN_ONLYDIR</b> were added in glibc version 2.5.)</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inotify API\nis Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inotify file\ndescriptors can be monitored using <a href=\"https://man.page/2/select\">select(2)</a>,\n<a href=\"https://man.page/2/poll\">poll(2)</a>, and <a href=\"https://man.page/7/epoll\">epoll(7)</a>. When an event is\navailable, the file descriptor indicates as readable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6.25, signal-driven I/O notification is available for\ninotify file descriptors; see the discussion of\n<b>F_SETFL</b> (for setting the <b>O_ASYNC</b> flag),\n<b>F_SETOWN</b>, and <b>F_SETSIG</b> in <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>. The\n<i>siginfo_t</i> structure (described in\n<a href=\"https://man.page/2/sigaction\">sigaction(2)</a>) that is passed to the signal handler\nhas the following fields set: <i>si_fd</i> is set to the\ninotify file descriptor number; <i>si_signo</i> is set to\nthe signal number; <i>si_code</i> is set to <b>POLL_IN</b>;\nand <b>POLLIN</b> is set in <i>si_band</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If successive\noutput inotify events produced on the inotify file\ndescriptor are identical (same <i>wd</i>, <i>mask</i>,\n<i>cookie</i>, and <i>name</i>), then they are coalesced\ninto a single event if the older event has not yet been read\n(but see BUGS). This reduces the amount of kernel memory\nrequired for the event queue, but also means that an\napplication can&rsquo;t use inotify to reliably count file\nevents.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The events\nreturned by reading from an inotify file descriptor form an\nordered queue. Thus, for example, it is guaranteed that when\nrenaming from one directory to another, events will be\nproduced in the correct order on the inotify file\ndescriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The set of\nwatch descriptors that is being monitored via an inotify\nfile descriptor can be viewed via the entry for the inotify\nfile descriptor in the process&rsquo;s\n<i>/proc/[pid]/fdinfo</i> directory. See <a href=\"https://man.page/5/proc\">proc(5)</a> for\nfurther details. The <b>FIONREAD ioctl</b>(2) returns the\nnumber of bytes available to read from an inotify file\ndescriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Limitations\nand caveats</b> <br>\nThe inotify API provides no information about the user or\nprocess that triggered the inotify event. In particular,\nthere is no easy way for a process that is monitoring events\nvia inotify to distinguish events that it triggers itself\nfrom those that are triggered by other processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inotify reports\nonly events that a user-space program triggers through the\nfilesystem API. As a result, it does not catch remote events\nthat occur on network filesystems. (Applications must fall\nback to polling the filesystem to catch such events.)\nFurthermore, various pseudo-filesystems such as\n<i>/proc</i>, <i>/sys</i>, and <i>/dev/pts</i> are not\nmonitorable with inotify.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inotify API\ndoes not report file accesses and modifications that may\noccur because of <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/msync\">msync(2)</a>, and\n<a href=\"https://man.page/2/munmap\">munmap(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inotify API\nidentifies affected files by filename. However, by the time\nan application processes an inotify event, the filename may\nalready have been deleted or renamed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inotify API\nidentifies events via watch descriptors. It is the\napplication&rsquo;s responsibility to cache a mapping (if\none is needed) between watch descriptors and pathnames. Be\naware that directory renamings may affect multiple cached\npathnames.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inotify\nmonitoring of directories is not recursive: to monitor\nsubdirectories under a directory, additional watches must be\ncreated. This can take a significant amount time for large\ndirectory trees.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If monitoring\nan entire directory subtree, and a new subdirectory is\ncreated in that tree or an existing directory is renamed\ninto that tree, be aware that by the time you create a watch\nfor the new subdirectory, new files (and subdirectories) may\nalready exist inside the subdirectory. Therefore, you may\nwant to scan the contents of the subdirectory immediately\nafter adding the watch (and, if desired, recursively add\nwatches for any subdirectories that it contains).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nevent queue can overflow. In this case, events are lost.\nRobust applications should handle the possibility of lost\nevents gracefully. For example, it may be necessary to\nrebuild part or all of the application cache. (One simple,\nbut possibly expensive, approach is to close the inotify\nfile descriptor, empty the cache, create a new inotify file\ndescriptor, and then re-create watches and cache entries for\nthe objects to be monitored.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a filesystem\nis mounted on top of a monitored directory, no event is\ngenerated, and no events are generated for objects\nimmediately under the new mount point. If the filesystem is\nsubsequently unmounted, events will subsequently be\ngenerated for the directory and the objects it contains.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Dealing with\nrename() events</b> <br>\nAs noted above, the <b>IN_MOVED_FROM</b> and\n<b>IN_MOVED_TO</b> event pair that is generated by\n<a href=\"https://man.page/2/rename\">rename(2)</a> can be matched up via their shared cookie\nvalue. However, the task of matching has some\nchallenges.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These two\nevents are usually consecutive in the event stream available\nwhen reading from the inotify file descriptor. However, this\nis not guaranteed. If multiple processes are triggering\nevents for monitored objects, then (on rare occasions) an\narbitrary number of other events may appear between the\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> events.\nFurthermore, it is not guaranteed that the event pair is\natomically inserted into the queue: there may be a brief\ninterval where the <b>IN_MOVED_FROM</b> has appeared, but\nthe <b>IN_MOVED_TO</b> has not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Matching up the\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> event pair\ngenerated by <a href=\"https://man.page/2/rename\">rename(2)</a> is thus inherently racy.\n(Don&rsquo;t forget that if an object is renamed outside of\na monitored directory, there may not even be an\n<b>IN_MOVED_TO</b> event.) Heuristic approaches (e.g.,\nassume the events are always consecutive) can be used to\nensure a match in most cases, but will inevitably miss some\ncases, causing the application to perceive the\n<b>IN_MOVED_FROM</b> and <b>IN_MOVED_TO</b> events as being\nunrelated. If watch descriptors are destroyed and re-created\nas a result, then those watch descriptors will be\ninconsistent with the watch descriptors in any pending\nevents. (Re-creating the inotify file descriptor and\nrebuilding the cache may be useful to deal with this\nscenario.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Applications\nshould also allow for the possibility that the\n<b>IN_MOVED_FROM</b> event was the last event that could fit\nin the buffer returned by the current call to\n<a href=\"https://man.page/2/read\">read(2)</a>, and the accompanying <b>IN_MOVED_TO</b>\nevent might be fetched only on the next <a href=\"https://man.page/2/read\">read(2)</a>,\nwhich should be done with a (small) timeout to allow for the\nfact that insertion of the\n<b>IN_MOVED_FROM</b>-<b>IN_MOVED_TO</b> event pair is not\natomic, and also the possibility that there may not be any\n<b>IN_MOVED_TO</b> event.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n3.19, <a href=\"https://man.page/2/fallocate\">fallocate(2)</a> did not create any inotify events.\nSince Linux 3.19, calls to <a href=\"https://man.page/2/fallocate\">fallocate(2)</a> generate\n<b>IN_MODIFY</b> events.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In kernels\nbefore 2.6.16, the <b>IN_ONESHOT</b> <i>mask</i> flag does\nnot work.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As originally\ndesigned and implemented, the <b>IN_ONESHOT</b> flag did not\ncause an <b>IN_IGNORED</b> event to be generated when the\nwatch was dropped after one event. However, as an unintended\neffect of other changes, since Linux 2.6.36, an\n<b>IN_IGNORED</b> event is generated in this case.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before kernel\n2.6.25, the kernel code that was intended to coalesce\nsuccessive identical events (i.e., the two most recent\nevents could potentially be coalesced if the older had not\nyet been read) instead checked if the most recent event\ncould be coalesced with the <i>oldest</i> unread event.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a watch\ndescriptor is removed by calling <a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a>\n(or because a watch file is deleted or the filesystem that\ncontains it is unmounted), any pending unread events for\nthat watch descriptor remain available to read. As watch\ndescriptors are subsequently allocated with\n<a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>, the kernel cycles through the\nrange of possible watch descriptors (0 to <b>INT_MAX</b>)\nincrementally. When allocating a free watch descriptor, no\ncheck is made to see whether that watch descriptor number\nhas any pending unread events in the inotify queue. Thus, it\ncan happen that a watch descriptor is reallocated even when\npending unread events exist for a previous incarnation of\nthat watch descriptor number, with the result that the\napplication might then read those events and interpret them\nas belonging to the file associated with the newly recycled\nwatch descriptor. In practice, the likelihood of hitting\nthis bug may be extremely low, since it requires that an\napplication cycle through <b>INT_MAX</b> watch descriptors,\nrelease a watch descriptor while leaving unread events for\nthat watch descriptor in the queue, and then recycle that\nwatch descriptor. For this reason, and because there have\nbeen no reports of the bug occurring in real-world\napplications, as of Linux 3.15, no kernel changes have yet\nbeen made to eliminate this possible bug.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram demonstrates the usage of the inotify API. It marks\nthe directories passed as a command-line arguments and waits\nfor events of type <b>IN_OPEN</b>, <b>IN_CLOSE_NOWRITE</b>,\nand <b>IN_CLOSE_WRITE</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\noutput was recorded while editing the file\n<i>/home/user/temp/foo</i> and listing directory\n<i>/tmp</i>. Before the file and the directory were opened,\n<b>IN_OPEN</b> events occurred. After the file was closed,\nan <b>IN_CLOSE_WRITE</b> event occurred. After the directory\nwas closed, an <b>IN_CLOSE_NOWRITE</b> event occurred.\nExecution of the program ended when the user pressed the\nENTER key.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Example\noutput</b></p>\n\n<p style=\"margin-left:17%;\">$ <b>./a.out /tmp\n/home/user/temp</b> <br>\nPress enter key to terminate. <br>\nListening for events. <br>\nIN_OPEN: /home/user/temp/foo [file] <br>\nIN_CLOSE_WRITE: /home/user/temp/foo [file] <br>\nIN_OPEN: /tmp/ [directory] <br>\nIN_CLOSE_NOWRITE: /tmp/ [directory]</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Listening for\nevents stopped.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;poll.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/inotify.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read all\navailable inotify events from the file descriptor 'fd'. <br>\nwd is the table of watch descriptors for the directories in\nargv. <br>\nargc is the length of wd and argv. <br>\nargv is the list of watched directories. <br>\nEntry 0 of wd and argv is unused. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nhandle_events(int fd, int *wd, int argc, char* argv[]) <br>\n{ <br>\n/* Some systems cannot read integer variables if they are\nnot <br>\nproperly aligned. On other systems, incorrect alignment may\n<br>\ndecrease performance. Hence, the buffer used for reading\nfrom <br>\nthe inotify file descriptor should have the same alignment\nas <br>\nstruct inotify_event. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">char buf[4096]\n<br>\n__attribute__ ((aligned(__alignof__(struct\ninotify_event)))); <br>\nconst struct inotify_event *event; <br>\nssize_t len;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Loop while\nevents can be read from inotify file descriptor. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read some\nevents. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">len = read(fd,\nbuf, sizeof(buf)); <br>\nif (len == -1 &amp;&amp; errno != EAGAIN) { <br>\nperror(&quot;read&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* If the\nnonblocking read() found no events to read, then <br>\nit returns -1 with errno set to EAGAIN. In that case, <br>\nwe exit the loop. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (len &lt;=\n0) <br>\nbreak;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Loop over\nall events in the buffer */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (char *ptr\n= buf; ptr &lt; buf + len; <br>\nptr += sizeof(struct inotify_event) + event-&gt;len) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">event = (const\nstruct inotify_event *) ptr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Print event\ntype */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(event-&gt;mask &amp; IN_OPEN) <br>\nprintf(&quot;IN_OPEN: &quot;); <br>\nif (event-&gt;mask &amp; IN_CLOSE_NOWRITE) <br>\nprintf(&quot;IN_CLOSE_NOWRITE: &quot;); <br>\nif (event-&gt;mask &amp; IN_CLOSE_WRITE) <br>\nprintf(&quot;IN_CLOSE_WRITE: &quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Print the\nname of the watched directory */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int i = 1;\ni &lt; argc; ++i) { <br>\nif (wd[i] == event-&gt;wd) { <br>\nprintf(&quot;%s/&quot;, argv[i]); <br>\nbreak; <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Print the\nname of the file */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(event-&gt;len) <br>\nprintf(&quot;%s&quot;, event-&gt;name);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Print type\nof filesystem object */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(event-&gt;mask &amp; IN_ISDIR) <br>\nprintf(&quot; [directory]\\n&quot;); <br>\nelse <br>\nprintf(&quot; [file]\\n&quot;); <br>\n} <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char* argv[]) <br>\n{ <br>\nchar buf; <br>\nint fd, i, poll_num; <br>\nint *wd; <br>\nnfds_t nfds; <br>\nstruct pollfd fds[2];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nprintf(&quot;Usage: %s PATH [PATH ...]\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Press\nENTER key to terminate.\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create the\nfile descriptor for accessing the inotify API */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\ninotify_init1(IN_NONBLOCK); <br>\nif (fd == -1) { <br>\nperror(&quot;inotify_init1&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Allocate\nmemory for watch descriptors */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">wd =\ncalloc(argc, sizeof(int)); <br>\nif (wd == NULL) { <br>\nperror(&quot;calloc&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Mark\ndirectories for events <br>\n- file was opened <br>\n- file was closed */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (i = 1; i\n&lt; argc; i++) { <br>\nwd[i] = inotify_add_watch(fd, argv[i], <br>\nIN_OPEN | IN_CLOSE); <br>\nif (wd[i] == -1) { <br>\nfprintf(stderr, &quot;Cannot watch '%s': %s\\n&quot;, <br>\nargv[i], strerror(errno)); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Prepare for\npolling */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nfds = 2;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Console\ninput */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fds[0].fd =\nSTDIN_FILENO; <br>\nfds[0].events = POLLIN;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Inotify\ninput */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fds[1].fd = fd;\n<br>\nfds[1].events = POLLIN;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Wait for\nevents and/or terminal input */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Listening\nfor events.\\n&quot;); <br>\nwhile (1) { <br>\npoll_num = poll(fds, nfds, -1); <br>\nif (poll_num == -1) { <br>\nif (errno == EINTR) <br>\ncontinue; <br>\nperror(&quot;poll&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (poll_num\n&gt; 0) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fds[0].revents &amp; POLLIN) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Console\ninput is available. Empty stdin and quit */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while\n(read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf !=\n'\\n') <br>\ncontinue; <br>\nbreak; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fds[1].revents &amp; POLLIN) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Inotify\nevents are available */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">handle_events(fd,\nwd, argc, argv); <br>\n} <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Listening\nfor events stopped.\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Close\ninotify file descriptor */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(fd);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">free(wd); <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/inotifywait\">inotifywait(1)</a>,\n<a href=\"https://man.page/1/inotifywatch\">inotifywatch(1)</a>, <a href=\"https://man.page/2/inotify_add_watch\">inotify_add_watch(2)</a>,\n<a href=\"https://man.page/2/inotify_init\">inotify_init(2)</a>, <a href=\"https://man.page/2/inotify_init1\">inotify_init1(2)</a>,\n<a href=\"https://man.page/2/inotify_rm_watch\">inotify_rm_watch(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/stat\">stat(2)</a>,\n<a href=\"https://man.page/7/fanotify\">fanotify(7)</a></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Documentation/filesystems/inotify.txt</i>\nin the Linux kernel source tree</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}