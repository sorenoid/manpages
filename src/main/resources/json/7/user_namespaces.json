{"name":"user_namespaces","description":"user_namespaces - overview of Linux user namespaces","body":"\n\n<h1 align=\"center\">USER_NAMESPACES</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">user_namespaces\n- overview of Linux user namespaces</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an overview\nof namespaces, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">User namespaces\nisolate security-related identifiers and attributes, in\nparticular, user IDs and group IDs (see\n<a href=\"https://man.page/7/credentials\">credentials(7)</a>), the root directory, keys (see\n<a href=\"https://man.page/7/keyrings\">keyrings(7)</a>), and capabilities (see\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>). A process&rsquo;s user and group\nIDs can be different inside and outside a user namespace. In\nparticular, a process can have a normal unprivileged user ID\noutside a user namespace while at the same time having a\nuser ID of 0 inside the namespace; in other words, the\nprocess has full privileges for operations inside the user\nnamespace, but is unprivileged for operations outside the\nnamespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Nested\nnamespaces, namespace membership</b> <br>\nUser namespaces can be nested; that is, each user\nnamespace&mdash;except the initial (&quot;root&quot;)\nnamespace&mdash;has a parent user namespace, and can have\nzero or more child user namespaces. The parent user\nnamespace is the user namespace of the process that creates\nthe user namespace via a call to <a href=\"https://man.page/2/unshare\">unshare(2)</a> or\n<a href=\"https://man.page/2/clone\">clone(2)</a> with the <b>CLONE_NEWUSER</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\nimposes (since version 3.11) a limit of 32 nested levels of\nuser namespaces. Calls to <a href=\"https://man.page/2/unshare\">unshare(2)</a> or\n<a href=\"https://man.page/2/clone\">clone(2)</a> that would cause this limit to be exceeded\nfail with the error <b>EUSERS</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each process is\na member of exactly one user namespace. A process created\nvia <a href=\"https://man.page/2/fork\">fork(2)</a> or <a href=\"https://man.page/2/clone\">clone(2)</a> without the\n<b>CLONE_NEWUSER</b> flag is a member of the same user\nnamespace as its parent. A single-threaded process can join\nanother user namespace with <a href=\"https://man.page/2/setns\">setns(2)</a> if it has the\n<b>CAP_SYS_ADMIN</b> in that namespace; upon doing so, it\ngains a full set of capabilities in that namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A call to\n<a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a> with the\n<b>CLONE_NEWUSER</b> flag makes the new child process (for\n<a href=\"https://man.page/2/clone\">clone(2)</a>) or the caller (for <a href=\"https://man.page/2/unshare\">unshare(2)</a>) a\nmember of the new user namespace created by the call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>NS_GET_PARENT ioctl</b>(2) operation can be used to\ndiscover the parental relationship between user namespaces;\nsee <a href=\"https://man.page/2/ioctl_ns\">ioctl_ns(2)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Capabilities</b>\n<br>\nThe child process created by <a href=\"https://man.page/2/clone\">clone(2)</a> with the\n<b>CLONE_NEWUSER</b> flag starts out with a complete set of\ncapabilities in the new user namespace. Likewise, a process\nthat creates a new user namespace using <a href=\"https://man.page/2/unshare\">unshare(2)</a> or\njoins an existing user namespace using <a href=\"https://man.page/2/setns\">setns(2)</a> gains\na full set of capabilities in that namespace. On the other\nhand, that process has no capabilities in the parent (in the\ncase of <a href=\"https://man.page/2/clone\">clone(2)</a>) or previous (in the case of\n<a href=\"https://man.page/2/unshare\">unshare(2)</a> and <a href=\"https://man.page/2/setns\">setns(2)</a>) user namespace, even\nif the new namespace is created or joined by the root user\n(i.e., a process with user ID 0 in the root namespace).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that a\ncall to <a href=\"https://man.page/2/execve\">execve(2)</a> will cause a process&rsquo;s\ncapabilities to be recalculated in the usual way (see\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>). Consequently, unless the process\nhas a user ID of 0 within the namespace, or the executable\nfile has a nonempty inheritable capabilities mask, the\nprocess will lose all capabilities. See the discussion of\nuser and group ID mappings, below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A call to\n<a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a> using the\n<b>CLONE_NEWUSER</b> flag or a call to <a href=\"https://man.page/2/setns\">setns(2)</a> that\nmoves the caller into another user namespace sets the\n&quot;securebits&quot; flags (see <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>) to\ntheir default values (all flags disabled) in the child (for\n<a href=\"https://man.page/2/clone\">clone(2)</a>) or caller (for <a href=\"https://man.page/2/unshare\">unshare(2)</a> or\n<a href=\"https://man.page/2/setns\">setns(2)</a>). Note that because the caller no longer has\ncapabilities in its original user namespace after a call to\n<a href=\"https://man.page/2/setns\">setns(2)</a>, it is not possible for a process to reset\nits &quot;securebits&quot; flags while retaining its user\nnamespace membership by using a pair of <a href=\"https://man.page/2/setns\">setns(2)</a>\ncalls to move to another user namespace and then return to\nits original user namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The rules for\ndetermining whether or not a process has a capability in a\nparticular user namespace are as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>A process has a capability inside a user namespace if it\nis a member of that namespace and it has the capability in\nits effective capability set. A process can gain\ncapabilities in its effective capability set in various\nways. For example, it may execute a set-user-ID program or\nan executable with associated file capabilities. In\naddition, a process may gain capabilities via the effect of\n<a href=\"https://man.page/2/clone\">clone(2)</a>, <a href=\"https://man.page/2/unshare\">unshare(2)</a>, or <a href=\"https://man.page/2/setns\">setns(2)</a>, as\nalready described.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>If a process has a capability in a user namespace, then\nit has that capability in all child (and further removed\ndescendant) namespaces as well.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>When a user namespace is created, the kernel records the\neffective user ID of the creating process as being the\n&quot;owner&quot; of the namespace. A process that resides\nin the parent of the user namespace and whose effective user\nID matches the owner of the namespace has all capabilities\nin the namespace. By virtue of the previous rule, this means\nthat the process has all capabilities in all further removed\ndescendant user namespaces as well. The <b>NS_GET_OWNER_UID\nioctl</b>(2) operation can be used to discover the user ID\nof the owner of the namespace; see <a href=\"https://man.page/2/ioctl_ns\">ioctl_ns(2)</a>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Effect of\ncapabilities within a user namespace</b> <br>\nHaving a capability inside a user namespace permits a\nprocess to perform operations (that require privilege) only\non resources governed by that namespace. In other words,\nhaving a capability in a user namespace permits a process to\nperform privileged operations on resources that are governed\nby (nonuser) namespaces owned by (associated with) the user\nnamespace (see the next subsection).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On the other\nhand, there are many privileged operations that affect\nresources that are not associated with any namespace type,\nfor example, changing the system (i.e., calendar) time\n(governed by <b>CAP_SYS_TIME</b>), loading a kernel module\n(governed by <b>CAP_SYS_MODULE</b>), and creating a device\n(governed by <b>CAP_MKNOD</b>). Only a process with\nprivileges in the <i>initial</i> user namespace can perform\nsuch operations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Holding\n<b>CAP_SYS_ADMIN</b> within the user namespace that owns a\nprocess&rsquo;s mount namespace allows that process to\ncreate bind mounts and mount the following types of\nfilesystems:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p style=\"margin-top: 1em\"><i>/proc</i> (since Linux\n3.8)</p> </td>\n<td width=\"40%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p><i>/sys</i> (since Linux 3.8)</p></td>\n<td width=\"40%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p><i>devpts</i> (since Linux 3.9)</p></td>\n<td width=\"40%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p><a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a> (since Linux 3.9)</p></td>\n<td width=\"40%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p><i>ramfs</i> (since Linux 3.9)</p></td>\n<td width=\"40%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p><i>mqueue</i> (since Linux 3.9)</p></td>\n<td width=\"40%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"40%\">\n\n\n<p><i>bpf</i> (since Linux 4.4)</p></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Holding\n<b>CAP_SYS_ADMIN</b> within the user namespace that owns a\nprocess&rsquo;s cgroup namespace allows (since Linux 4.6)\nthat process to the mount the cgroup version 2 filesystem\nand cgroup version 1 named hierarchies (i.e., cgroup\nfilesystems mounted with the <i>&quot;none,name=&quot;</i>\noption).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Holding\n<b>CAP_SYS_ADMIN</b> within the user namespace that owns a\nprocess&rsquo;s PID namespace allows (since Linux 3.8) that\nprocess to mount <i>/proc</i> filesystems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note however,\nthat mounting block-based filesystems can be done only by a\nprocess that holds <b>CAP_SYS_ADMIN</b> in the initial user\nnamespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Interaction\nof user namespaces and other types of namespaces</b> <br>\nStarting in Linux 3.8, unprivileged processes can create\nuser namespaces, and the other types of namespaces can be\ncreated with just the <b>CAP_SYS_ADMIN</b> capability in the\ncaller&rsquo;s user namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a nonuser\nnamespace is created, it is owned by the user namespace in\nwhich the creating process was a member at the time of the\ncreation of the namespace. Privileged operations on\nresources governed by the nonuser namespace require that the\nprocess has the necessary capabilities in the user namespace\nthat owns the nonuser namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>CLONE_NEWUSER</b> is specified along with other\n<b>CLONE_NEW*</b> flags in a single <a href=\"https://man.page/2/clone\">clone(2)</a> or\n<a href=\"https://man.page/2/unshare\">unshare(2)</a> call, the user namespace is guaranteed to\nbe created first, giving the child (<a href=\"https://man.page/2/clone\">clone(2)</a>) or\ncaller (<a href=\"https://man.page/2/unshare\">unshare(2)</a>) privileges over the remaining\nnamespaces created by the call. Thus, it is possible for an\nunprivileged caller to specify this combination of\nflags.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a new\nnamespace (other than a user namespace) is created via\n<a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a>, the kernel records the\nuser namespace of the creating process as the owner of the\nnew namespace. (This association can&rsquo;t be changed.)\nWhen a process in the new namespace subsequently performs\nprivileged operations that operate on global resources\nisolated by the namespace, the permission checks are\nperformed according to the process&rsquo;s capabilities in\nthe user namespace that the kernel associated with the new\nnamespace. For example, suppose that a process attempts to\nchange the hostname (<a href=\"https://man.page/2/sethostname\">sethostname(2)</a>), a resource\ngoverned by the UTS namespace. In this case, the kernel will\ndetermine which user namespace owns the process&rsquo;s UTS\nnamespace, and check whether the process has the required\ncapability (<b>CAP_SYS_ADMIN</b>) in that user\nnamespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>NS_GET_USERNS ioctl</b>(2) operation can be used to\ndiscover the user namespace that owns a nonuser namespace;\nsee <a href=\"https://man.page/2/ioctl_ns\">ioctl_ns(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>User and\ngroup ID mappings: uid_map and gid_map</b> <br>\nWhen a user namespace is created, it starts out without a\nmapping of user IDs (group IDs) to the parent user\nnamespace. The <i>/proc/[pid]/uid_map</i> and\n<i>/proc/[pid]/gid_map</i> files (available since Linux 3.5)\nexpose the mappings for user and group IDs inside the user\nnamespace for the process <i>pid</i>. These files can be\nread to view the mappings in a user namespace and written to\n(once) to define the mappings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The description\nin the following paragraphs explains the details for\n<i>uid_map</i>; <i>gid_map</i> is exactly the same, but each\ninstance of &quot;user ID&quot; is replaced by &quot;group\nID&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>uid_map</i> file exposes the mapping of user IDs from the\nuser namespace of the process <i>pid</i> to the user\nnamespace of the process that opened <i>uid_map</i> (but see\na qualification to this point below). In other words,\nprocesses that are in different user namespaces will\npotentially see different values when reading from a\nparticular <i>uid_map</i> file, depending on the user ID\nmappings for the user namespaces of the reading\nprocesses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each line in\nthe <i>uid_map</i> file specifies a 1-to-1 mapping of a\nrange of contiguous user IDs between two user namespaces.\n(When a user namespace is first created, this file is\nempty.) The specification in each line takes the form of\nthree numbers delimited by white space. The first two\nnumbers specify the starting user ID in each of the two user\nnamespaces. The third number specifies the length of the\nmapped range. In detail, the fields are interpreted as\nfollows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">(1)</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">The start of the range of user\nIDs in the user namespace of the process <i>pid</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>(2)</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>The start of the range of user IDs to which the user IDs\nspecified by field one map. How field two is interpreted\ndepends on whether the process that opened <i>uid_map</i>\nand the process <i>pid</i> are in the same user namespace,\nas follows:</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%;\">a)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\"></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">If the two processes are in\ndifferent user namespaces: field two is the start of a range\nof user IDs in the user namespace of the process that opened\n<i>uid_map</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p>b)</p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>If the two processes are in the same user namespace:\nfield two is the start of the range of user IDs in the\nparent user namespace of the process <i>pid</i>. This case\nenables the opener of <i>uid_map</i> (the common case here\nis opening <i>/proc/self/uid_map</i>) to see the mapping of\nuser IDs into the user namespace of the process that created\nthis user namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p>(3)</p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The length of\nthe range of user IDs that is mapped between the two user\nnamespaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">System calls\nthat return user IDs (group IDs)&mdash;for example,\n<a href=\"https://man.page/2/getuid\">getuid(2)</a>, <a href=\"https://man.page/2/getgid\">getgid(2)</a>, and the credential\nfields in the structure returned by\n<a href=\"https://man.page/2/stat\">stat(2)</a>&mdash;return the user ID (group ID) mapped\ninto the caller&rsquo;s user namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a process\naccesses a file, its user and group IDs are mapped into the\ninitial user namespace for the purpose of permission\nchecking and assigning IDs when creating a file. When a\nprocess retrieves file user and group IDs via\n<a href=\"https://man.page/2/stat\">stat(2)</a>, the IDs are mapped in the opposite\ndirection, to produce values relative to the process user\nand group ID mappings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The initial\nuser namespace has no parent namespace, but, for\nconsistency, the kernel provides dummy user and group ID\nmapping files for this namespace. Looking at the\n<i>uid_map</i> file (<i>gid_map</i> is the same) from a\nshell in the initial namespace shows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cat\n/proc/$$/uid_map</b> <br>\n0 0 4294967295</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This mapping\ntells us that the range starting at user ID 0 in this\nnamespace maps to a range starting at 0 in the (nonexistent)\nparent namespace, and the length of the range is the largest\n32-bit unsigned integer. This leaves 4294967295 (the 32-bit\nsigned -1 value) unmapped. This is deliberate:\n<i>(uid_t)&nbsp;-1</i> is used in several interfaces (e.g.,\n<a href=\"https://man.page/2/setreuid\">setreuid(2)</a>) as a way to specify &quot;no user\nID&quot;. Leaving <i>(uid_t)&nbsp;-1</i> unmapped and\nunusable guarantees that there will be no confusion when\nusing these interfaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Defining\nuser and group ID mappings: writing to uid_map and\ngid_map</b> <br>\nAfter the creation of a new user namespace, the\n<i>uid_map</i> file of <i>one</i> of the processes in the\nnamespace may be written to <i>once</i> to define the\nmapping of user IDs in the new user namespace. An attempt to\nwrite more than once to a <i>uid_map</i> file in a user\nnamespace fails with the error <b>EPERM</b>. Similar rules\napply for <i>gid_map</i> files.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The lines\nwritten to <i>uid_map</i> (<i>gid_map</i>) must conform to\nthe following rules:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The three fields must be valid\nnumbers, and the last field must be greater than 0.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Lines are terminated by newline characters.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>There is a limit on the number of lines in the file. In\nLinux 4.14 and earlier, this limit was (arbitrarily) set at\n5 lines. Since Linux 4.15, the limit is 340 lines. In\naddition, the number of bytes written to the file must be\nless than the system page size, and the write must be\nperformed at the start of the file (i.e., <a href=\"https://man.page/2/lseek\">lseek(2)</a>\nand <a href=\"https://man.page/2/pwrite\">pwrite(2)</a> can&rsquo;t be used to write to nonzero\noffsets in the file).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The range of user IDs (group IDs) specified in each line\ncannot overlap with the ranges in any other lines. In the\ninitial implementation (Linux 3.8), this requirement was\nsatisfied by a simplistic implementation that imposed the\nfurther requirement that the values in both field 1 and\nfield 2 of successive lines must be in ascending numerical\norder, which prevented some otherwise valid maps from being\ncreated. Linux 3.9 and later fix this limitation, allowing\nany valid set of nonoverlapping maps.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>At least one line must be written to the file.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Writes that\nviolate the above rules fail with the error\n<b>EINVAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order for a\nprocess to write to the <i>/proc/[pid]/uid_map</i>\n(<i>/proc/[pid]/gid_map</i>) file, all of the following\nrequirements must be met:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The writing process must have\nthe <b>CAP_SETUID</b> (<b>CAP_SETGID</b>) capability in the\nuser namespace of the process <i>pid</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>The writing process must either be in the user namespace\nof the process <i>pid</i> or be in the parent user namespace\nof the process <i>pid</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>The mapped user IDs (group IDs) must in turn have a\nmapping in the parent user namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>One of the following two cases applies:</p></td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">*</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\"><i>Either</i> the writing\nprocess has the <b>CAP_SETUID</b> (<b>CAP_SETGID</b>)\ncapability in the <i>parent</i> user namespace.</p></td></tr>\n</table>\n\n<p style=\"margin-left:20%;\">+</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"2%\"></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">No further restrictions apply:\nthe process can make mappings to arbitrary user IDs (group\nIDs) in the parent user namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"2%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p><i>Or</i> otherwise all of the following restrictions\napply:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:20%;\">+</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\"></td>\n<td width=\"3%\"></td>\n<td width=\"75%\">\n\n\n<p style=\"margin-top: 1em\">The data written to\n<i>uid_map</i> (<i>gid_map</i>) must consist of a single\nline that maps the writing process&rsquo;s effective user ID\n(group ID) in the parent user namespace to a user ID (group\nID) in the user namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\">\n\n\n<p>+</p></td>\n<td width=\"3%\"></td>\n<td width=\"75%\">\n\n\n<p>The writing process must have the same effective user ID\nas the process that created the user namespace.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"20%\"></td>\n<td width=\"2%\">\n\n\n<p>+</p></td>\n<td width=\"3%\"></td>\n<td width=\"75%\">\n\n\n<p>In the case of <i>gid_map</i>, use of the\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a> system call must first be denied by\nwriting &quot;<i>deny</i>&quot; to the\n<i>/proc/[pid]/setgroups</i> file (see below) before writing\nto <i>gid_map</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Writes that\nviolate the above rules fail with the error\n<b>EPERM</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Interaction\nwith system calls that change process UIDs or GIDs</b> <br>\nIn a user namespace where the <i>uid_map</i> file has not\nbeen written, the system calls that change user IDs will\nfail. Similarly, if the <i>gid_map</i> file has not been\nwritten, the system calls that change group IDs will fail.\nAfter the <i>uid_map</i> and <i>gid_map</i> files have been\nwritten, only the mapped values may be used in system calls\nthat change user and group IDs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For user IDs,\nthe relevant system calls include <a href=\"https://man.page/2/setuid\">setuid(2)</a>,\n<a href=\"https://man.page/2/setfsuid\">setfsuid(2)</a>, <a href=\"https://man.page/2/setreuid\">setreuid(2)</a>, and\n<a href=\"https://man.page/2/setresuid\">setresuid(2)</a>. For group IDs, the relevant system\ncalls include <a href=\"https://man.page/2/setgid\">setgid(2)</a>, <a href=\"https://man.page/2/setfsgid\">setfsgid(2)</a>,\n<a href=\"https://man.page/2/setregid\">setregid(2)</a>, <a href=\"https://man.page/2/setresgid\">setresgid(2)</a>, and\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Writing\n&quot;<i>deny</i>&quot; to the <i>/proc/[pid]/setgroups</i>\nfile before writing to <i>/proc/[pid]/gid_map</i> will\npermanently disable <a href=\"https://man.page/2/setgroups\">setgroups(2)</a> in a user namespace\nand allow writing to <i>/proc/[pid]/gid_map</i> without\nhaving the <b>CAP_SETGID</b> capability in the parent user\nnamespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\n/proc/[pid]/setgroups file</b> <br>\nThe <i>/proc/[pid]/setgroups</i> file displays the string\n&quot;<i>allow</i>&quot; if processes in the user namespace\nthat contains the process <i>pid</i> are permitted to employ\nthe <a href=\"https://man.page/2/setgroups\">setgroups(2)</a> system call; it displays\n&quot;<i>deny</i>&quot; if <a href=\"https://man.page/2/setgroups\">setgroups(2)</a> is not\npermitted in that user namespace. Note that regardless of\nthe value in the <i>/proc/[pid]/setgroups</i> file (and\nregardless of the process&rsquo;s capabilities), calls to\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a> are also not permitted if\n<i>/proc/[pid]/gid_map</i> has not yet been set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A privileged\nprocess (one with the <b>CAP_SYS_ADMIN</b> capability in the\nnamespace) may write either of the strings\n&quot;<i>allow</i>&quot; or &quot;<i>deny</i>&quot; to this\nfile <i>before</i> writing a group ID mapping for this user\nnamespace to the file <i>/proc/[pid]/gid_map</i>. Writing\nthe string &quot;<i>deny</i>&quot; prevents any process in\nthe user namespace from employing <a href=\"https://man.page/2/setgroups\">setgroups(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The essence of\nthe restrictions described in the preceding paragraph is\nthat it is permitted to write to\n<i>/proc/[pid]/setgroups</i> only so long as calling\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a> is disallowed because\n<i>/proc/[pid]/gid_map</i> has not been set. This ensures\nthat a process cannot transition from a state where\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a> is allowed to a state where\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a> is denied; a process can transition only\nfrom <a href=\"https://man.page/2/setgroups\">setgroups(2)</a> being disallowed to\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a> being allowed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\nvalue of this file in the initial user namespace is\n&quot;<i>allow</i>&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once\n<i>/proc/[pid]/gid_map</i> has been written to (which has\nthe effect of enabling <a href=\"https://man.page/2/setgroups\">setgroups(2)</a> in the user\nnamespace), it is no longer possible to disallow\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a> by writing &quot;<i>deny</i>&quot; to\n<i>/proc/[pid]/setgroups</i> (the write fails with the error\n<b>EPERM</b>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child user\nnamespace inherits the <i>/proc/[pid]/setgroups</i> setting\nfrom its parent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<i>setgroups</i> file has the value &quot;<i>deny</i>&quot;,\nthen the <a href=\"https://man.page/2/setgroups\">setgroups(2)</a> system call can&rsquo;t\nsubsequently be reenabled (by writing\n&quot;<i>allow</i>&quot; to the file) in this user\nnamespace. (Attempts to do so fail with the error\n<b>EPERM</b>.) This restriction also propagates down to all\nchild user namespaces of this user namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>/proc/[pid]/setgroups</i> file was added in Linux 3.19,\nbut was backported to many earlier stable kernel series,\nbecause it addresses a security issue. The issue concerned\nfiles with permissions such as &quot;rwx---rwx&quot;. Such\nfiles give fewer permissions to &quot;group&quot; than they\ndo to &quot;other&quot;. This means that dropping groups\nusing <a href=\"https://man.page/2/setgroups\">setgroups(2)</a> might allow a process file access\nthat it did not formerly have. Before the existence of user\nnamespaces this was not a concern, since only a privileged\nprocess (one with the <b>CAP_SETGID</b> capability) could\ncall <a href=\"https://man.page/2/setgroups\">setgroups(2)</a>. However, with the introduction of\nuser namespaces, it became possible for an unprivileged\nprocess to create a new namespace in which the user had all\nprivileges. This then allowed formerly unprivileged users to\ndrop groups and thus gain file access that they did not\npreviously have. The <i>/proc/[pid]/setgroups</i> file was\nadded to address this security issue, by denying any pathway\nfor an unprivileged process to drop groups with\n<a href=\"https://man.page/2/setgroups\">setgroups(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Unmapped\nuser and group IDs</b> <br>\nThere are various places where an unmapped user ID (group\nID) may be exposed to user space. For example, the first\nprocess in a new user namespace may call <a href=\"https://man.page/2/getuid\">getuid(2)</a>\nbefore a user ID mapping has been defined for the namespace.\nIn most such cases, an unmapped user ID is converted to the\noverflow user ID (group ID); the default value for the\noverflow user ID (group ID) is 65534. See the descriptions\nof <i>/proc/sys/kernel/overflowuid</i> and\n<i>/proc/sys/kernel/overflowgid</i> in <a href=\"https://man.page/5/proc\">proc(5)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The cases where\nunmapped IDs are mapped in this fashion include system calls\nthat return user IDs (<a href=\"https://man.page/2/getuid\">getuid(2)</a>, <a href=\"https://man.page/2/getgid\">getgid(2)</a>,\nand similar), credentials passed over a UNIX domain socket,\ncredentials returned by <a href=\"https://man.page/2/stat\">stat(2)</a>, <a href=\"https://man.page/2/waitid\">waitid(2)</a>,\nand the System V IPC &quot;ctl&quot; <b>IPC_STAT</b>\noperations, credentials exposed by <i>/proc/[pid]/status</i>\nand the files in <i>/proc/sysvipc/*</i>, credentials\nreturned via the <i>si_uid</i> field in the <i>siginfo_t</i>\nreceived with a signal (see <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>),\ncredentials written to the process accounting file (see\n<a href=\"https://man.page/5/acct\">acct(5)</a>), and credentials returned with POSIX message\nqueue notifications (see <a href=\"https://man.page/3/mq_notify\">mq_notify(3)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is one\nnotable case where unmapped user and group IDs are\n<i>not</i> converted to the corresponding overflow ID value.\nWhen viewing a <i>uid_map</i> or <i>gid_map</i> file in\nwhich there is no mapping for the second field, that field\nis displayed as 4294967295 (-1 as an unsigned integer).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Accessing\nfiles</b> <br>\nIn order to determine permissions when an unprivileged\nprocess accesses a file, the process credentials (UID, GID)\nand the file credentials are in effect mapped back to what\nthey would be in the initial user namespace and then\ncompared to determine the permissions that the process has\non the file. The same is also of other objects that employ\nthe credentials plus permissions mask accessibility model,\nsuch as System V IPC objects</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Operation of\nfile-related capabilities</b> <br>\nCertain capabilities allow a process to bypass various\nkernel-enforced restrictions when performing operations on\nfiles owned by other users or groups. These capabilities\nare: <b>CAP_CHOWN</b>, <b>CAP_DAC_OVERRIDE</b>,\n<b>CAP_DAC_READ_SEARCH</b>, <b>CAP_FOWNER</b>, and\n<b>CAP_FSETID</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Within a user\nnamespace, these capabilities allow a process to bypass the\nrules if the process has the relevant capability over the\nfile, meaning that:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">the process has the relevant\neffective capability in its user namespace; and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>the file&rsquo;s user ID and group ID both have valid\nmappings in the user namespace.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>CAP_FOWNER</b> capability is treated somewhat\nexceptionally: it allows a process to bypass the\ncorresponding rules so long as at least the file&rsquo;s\nuser ID has a mapping in the user namespace (i.e., the\nfile&rsquo;s group ID does not need to have a valid\nmapping).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Set-user-ID\nand set-group-ID programs</b> <br>\nWhen a process inside a user namespace executes a\nset-user-ID (set-group-ID) program, the process&rsquo;s\neffective user (group) ID inside the namespace is changed to\nwhatever value is mapped for the user (group) ID of the\nfile. However, if either the user <i>or</i> the group ID of\nthe file has no mapping inside the namespace, the\nset-user-ID (set-group-ID) bit is silently ignored: the new\nprogram is executed, but the process&rsquo;s effective user\n(group) ID is left unchanged. (This mirrors the semantics of\nexecuting a set-user-ID or set-group-ID program that resides\non a filesystem that was mounted with the <b>MS_NOSUID</b>\nflag, as described in <a href=\"https://man.page/2/mount\">mount(2)</a>.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Miscellaneous</b>\n<br>\nWhen a process&rsquo;s user and group IDs are passed over a\nUNIX domain socket to a process in a different user\nnamespace (see the description of <b>SCM_CREDENTIALS</b> in\n<a href=\"https://man.page/7/unix\">unix(7)</a>), they are translated into the corresponding\nvalues as per the receiving process&rsquo;s user and group\nID mappings.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Namespaces are\na Linux-specific feature.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Over the years,\nthere have been a lot of features that have been added to\nthe Linux kernel that have been made available only to\nprivileged users because of their potential to confuse\nset-user-ID-root applications. In general, it becomes safe\nto allow the root user in a user namespace to use those\nfeatures because it is impossible, while in a user\nnamespace, to gain more privilege than the root user of a\nuser namespace has.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Availability</b>\n<br>\nUse of user namespaces requires a kernel that is configured\nwith the <b>CONFIG_USER_NS</b> option. User namespaces\nrequire support in a range of subsystems across the kernel.\nWhen an unsupported subsystem is configured into the kernel,\nit is not possible to configure user namespaces support.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As at Linux\n3.8, most relevant subsystems supported user namespaces, but\na number of filesystems did not have the infrastructure\nneeded to map user and group IDs between user namespaces.\nLinux 3.9 added the required infrastructure support for many\nof the remaining unsupported filesystems (Plan 9 (9P),\nAndrew File System (AFS), Ceph, CIFS, CODA, NFS, and OCFS2).\nLinux 3.12 added support for the last of the unsupported\nmajor filesystems, XFS.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow is designed to allow experimenting with user\nnamespaces, as well as other types of namespaces. It creates\nnamespaces as specified by command-line options and then\nexecutes a command inside those namespaces. The comments and\n<i>usage()</i> function inside the program provide a full\nexplanation of the program. The following shell session\ndemonstrates its use.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">First, we look\nat the run-time environment:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>uname\n-rs</b> # Need Linux 3.8 or later <br>\nLinux 3.8.0 <br>\n$ <b>id -u</b> # Running as unprivileged user <br>\n1000 <br>\n$ <b>id -g</b> <br>\n1000</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now start a new\nshell in new user (<i>-U</i>), mount (<i>-m</i>), and PID\n(<i>-p</i>) namespaces, with user ID (<i>-M</i>) and group\nID (<i>-G</i>) 1000 mapped to 0 inside the user\nnamespace:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1'\nbash</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The shell has\nPID 1, because it is the first process in the new PID\nnamespace:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">bash$ <b>echo\n$$</b> <br>\n1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Mounting a new\n<i>/proc</i> filesystem and listing all of the processes\nvisible in the new PID namespace shows that the shell\ncan&rsquo;t see any processes outside the PID namespace:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">bash$ <b>mount\n-t proc proc /proc</b> <br>\nbash$ <b>ps ax</b> <br>\nPID TTY STAT TIME COMMAND <br>\n1 pts/3 S 0:00 bash <br>\n22 pts/3 R+ 0:00 ps ax</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inside the user\nnamespace, the shell has user and group ID 0, and a full set\nof permitted and effective capabilities:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">bash$ <b>cat\n/proc/$$/status | egrep '^[UG]id'</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p>Uid:</p></td>\n<td width=\"8%\">\n\n\n<p>0</p></td>\n<td width=\"7%\">\n\n\n<p>0</p></td>\n<td width=\"62%\">\n\n\n<p>0</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\"></td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n\n\n<p>0</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p>Gid:</p></td>\n<td width=\"8%\">\n\n\n<p>0</p></td>\n<td width=\"7%\">\n\n\n<p>0</p></td>\n<td width=\"62%\">\n\n\n<p>0</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\"></td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n\n\n<p>0</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%;\">bash$ <b>cat /proc/$$/status |\negrep '^Cap(Prm|Inh|Eff)'</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p>CapInh:</p></td>\n<td width=\"77%\">\n\n\n<p>0000000000000000</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p>CapPrm:</p></td>\n<td width=\"77%\">\n\n\n<p>0000001fffffffff</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n\n\n<p>CapEff:</p></td>\n<td width=\"77%\">\n\n\n<p>0000001fffffffff</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n/* userns_child_exec.c</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nGNU General Public License v2 or later</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Create a child\nprocess that executes a shell command in new <br>\nnamespace(s); allow UID and GID mappings to be specified\nwhen <br>\ncreating a user namespace. <br>\n*/ <br>\n#define _GNU_SOURCE <br>\n#include &lt;sched.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/wait.h&gt; <br>\n#include &lt;signal.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;limits.h&gt; <br>\n#include &lt;errno.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* A simple\nerror-handling function: print an error message based <br>\non the value in 'errno' and terminate the calling process\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct\nchild_args { <br>\nchar **argv; /* Command to be executed by child, with args\n*/ <br>\nint pipe_fd[2]; /* Pipe used to synchronize parent and child\n*/ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int\nverbose;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nusage(char *pname) <br>\n{ <br>\nfprintf(stderr, &quot;Usage: %s [options] cmd\n[arg...]\\n\\n&quot;, pname); <br>\nfprintf(stderr, &quot;Create a child process that executes a\nshell &quot; <br>\n&quot;command in a new user namespace,\\n&quot; <br>\n&quot;and possibly also other new namespace(s).\\n\\n&quot;);\n<br>\nfprintf(stderr, &quot;Options can be:\\n\\n&quot;); <br>\n#define fpe(str) fprintf(stderr, &quot; %s&quot;, str); <br>\nfpe(&quot;-i New IPC namespace\\n&quot;); <br>\nfpe(&quot;-m New mount namespace\\n&quot;); <br>\nfpe(&quot;-n New network namespace\\n&quot;); <br>\nfpe(&quot;-p New PID namespace\\n&quot;); <br>\nfpe(&quot;-u New UTS namespace\\n&quot;); <br>\nfpe(&quot;-U New user namespace\\n&quot;); <br>\nfpe(&quot;-M uid_map Specify UID map for user\nnamespace\\n&quot;); <br>\nfpe(&quot;-G gid_map Specify GID map for user\nnamespace\\n&quot;); <br>\nfpe(&quot;-z Map user's UID and GID to 0 in user\nnamespace\\n&quot;); <br>\nfpe(&quot; (equivalent to: -M '0 &lt;uid&gt; 1' -G '0\n&lt;gid&gt; 1')\\n&quot;); <br>\nfpe(&quot;-v Display verbose messages\\n&quot;); <br>\nfpe(&quot;\\n&quot;); <br>\nfpe(&quot;If -z, -M, or -G is specified, -U is\nrequired.\\n&quot;); <br>\nfpe(&quot;It is not permitted to specify both -z and either\n-M or -G.\\n&quot;); <br>\nfpe(&quot;\\n&quot;); <br>\nfpe(&quot;Map strings for -M and -G consist of records of\nthe form:\\n&quot;); <br>\nfpe(&quot;\\n&quot;); <br>\nfpe(&quot; ID-inside-ns ID-outside-ns len\\n&quot;); <br>\nfpe(&quot;\\n&quot;); <br>\nfpe(&quot;A map string can contain multiple records,\nseparated&quot; <br>\n&quot; by commas;\\n&quot;); <br>\nfpe(&quot;the commas are replaced by newlines before\nwriting&quot; <br>\n&quot; to map files.\\n&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_FAILURE);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Update the\nmapping file 'map_file', with the value provided in <br>\n'mapping', a string that defines a UID or GID mapping. A UID\nor <br>\nGID mapping consists of one or more newline-delimited\nrecords <br>\nof the form:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ID_inside-ns\nID-outside-ns length</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Requiring the\nuser to supply a string that contains newlines is <br>\nof course inconvenient for command-line use. Thus, we permit\nthe <br>\nuse of commas to delimit records in this string, and replace\nthem <br>\nwith newlines before writing the string to the file. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nupdate_map(char *mapping, char *map_file) <br>\n{ <br>\nint fd; <br>\nsize_t map_len; /* Length of 'mapping' */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Replace\ncommas in mapping string with newlines */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">map_len =\nstrlen(mapping); <br>\nfor (int j = 0; j &lt; map_len; j++) <br>\nif (mapping[j] == ',') <br>\nmapping[j] = '\\n';</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(map_file, O_RDWR); <br>\nif (fd == -1) { <br>\nfprintf(stderr, &quot;ERROR: open %s: %s\\n&quot;, map_file,\n<br>\nstrerror(errno)); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (write(fd,\nmapping, map_len) != map_len) { <br>\nfprintf(stderr, &quot;ERROR: write %s: %s\\n&quot;, map_file,\n<br>\nstrerror(errno)); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(fd); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Linux 3.19\nmade a change in the handling of setgroups(2) and the <br>\n'gid_map' file to address a security issue. The issue\nallowed <br>\n*unprivileged* users to employ user namespaces in order to\ndrop <br>\nThe upshot of the 3.19 changes is that in order to update\nthe <br>\n'gid_maps' file, use of the setgroups() system call in this\n<br>\nuser namespace must first be disabled by writing\n&quot;deny&quot; to one of <br>\nthe /proc/PID/setgroups files for this namespace. That is\nthe <br>\npurpose of the following function. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nproc_setgroups_write(pid_t child_pid, char *str) <br>\n{ <br>\nchar setgroups_path[PATH_MAX]; <br>\nint fd;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">snprintf(setgroups_path,\nPATH_MAX, &quot;/proc/%jd/setgroups&quot;, <br>\n(intmax_t) child_pid);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nopen(setgroups_path, O_RDWR); <br>\nif (fd == -1) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* We may be on\na system that doesn't support <br>\n/proc/PID/setgroups. In that case, the file won't exist,\n<br>\nand the system won't impose the restrictions that Linux 3.19\n<br>\nadded. That's fine: we don't need to do anything in order\n<br>\nto permit 'gid_map' to be updated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if the\nerror from open() was something other than <br>\nthe ENOENT error that is expected for that case, let the\n<br>\nuser know. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (errno !=\nENOENT) <br>\nfprintf(stderr, &quot;ERROR: open %s: %s\\n&quot;,\nsetgroups_path, <br>\nstrerror(errno)); <br>\nreturn; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (write(fd,\nstr, strlen(str)) == -1) <br>\nfprintf(stderr, &quot;ERROR: write %s: %s\\n&quot;,\nsetgroups_path, <br>\nstrerror(errno));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(fd); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int /*\nStart function for cloned child */ <br>\nchildFunc(void *arg) <br>\n{ <br>\nstruct child_args *args = arg; <br>\nchar ch;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Wait until\nthe parent has updated the UID and GID mappings. <br>\nSee the comment in main(). We wait for end of file on a <br>\npipe that will be closed by the parent process once it has\n<br>\nupdated the mappings. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(args-&gt;pipe_fd[1]);\n/* Close our descriptor for the write <br>\nend of the pipe so that we see EOF <br>\nwhen parent closes its descriptor */ <br>\nif (read(args-&gt;pipe_fd[0], &amp;ch, 1) != 0) { <br>\nfprintf(stderr, <br>\n&quot;Failure in child: read from pipe returned !=\n0\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(args-&gt;pipe_fd[0]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Execute a\nshell command */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;About\nto exec %s\\n&quot;, args-&gt;argv[0]); <br>\nexecvp(args-&gt;argv[0], args-&gt;argv); <br>\nerrExit(&quot;execvp&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nSTACK_SIZE (1024 * 1024)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static char\nchild_stack[STACK_SIZE]; /* Space for child's stack */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint flags, opt, map_zero; <br>\npid_t child_pid; <br>\nstruct child_args args; <br>\nchar *uid_map, *gid_map; <br>\nconst int MAP_BUF_SIZE = 100; <br>\nchar map_buf[MAP_BUF_SIZE]; <br>\nchar map_path[PATH_MAX];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Parse\ncommand-line options. The initial '+' character in <br>\nthe final getopt() argument prevents GNU-style permutation\n<br>\nof command-line options. That's useful, since sometimes <br>\nthe 'command' to be executed by this program itself <br>\nhas command-line options. We don't want getopt() to treat\n<br>\nthose as options to this program. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">flags = 0; <br>\nverbose = 0; <br>\ngid_map = NULL; <br>\nuid_map = NULL; <br>\nmap_zero = 0; <br>\nwhile ((opt = getopt(argc, argv, &quot;+imnpuUM:G:zv&quot;))\n!= -1) { <br>\nswitch (opt) { <br>\ncase 'i': flags |= CLONE_NEWIPC; break; <br>\ncase 'm': flags |= CLONE_NEWNS; break; <br>\ncase 'n': flags |= CLONE_NEWNET; break; <br>\ncase 'p': flags |= CLONE_NEWPID; break; <br>\ncase 'u': flags |= CLONE_NEWUTS; break; <br>\ncase 'v': verbose = 1; break; <br>\ncase 'z': map_zero = 1; break; <br>\ncase 'M': uid_map = optarg; break; <br>\ncase 'G': gid_map = optarg; break; <br>\ncase 'U': flags |= CLONE_NEWUSER; break; <br>\ndefault: usage(argv[0]); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* -M or -G\nwithout -U is nonsensical */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (((uid_map\n!= NULL || gid_map != NULL || map_zero) &amp;&amp; <br>\n!(flags &amp; CLONE_NEWUSER)) || <br>\n(map_zero &amp;&amp; (uid_map != NULL || gid_map != NULL)))\n<br>\nusage(argv[0]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">args.argv =\n&amp;argv[optind];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* We use a\npipe to synchronize the parent and child, in order to <br>\nensure that the parent sets the UID and GID maps before the\nchild <br>\ncalls execve(). This ensures that the child maintains its\n<br>\ncapabilities during the execve() in the common case where we\n<br>\nwant to map the child's effective user ID to 0 in the new\nuser <br>\nnamespace. Without this synchronization, the child would\nlose <br>\nits capabilities if it performed an execve() with nonzero\n<br>\nuser IDs (see the capabilities(7) man page for details of\nthe <br>\ntransformation of a process's capabilities during execve()).\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(pipe(args.pipe_fd) == -1) <br>\nerrExit(&quot;pipe&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create the\nchild in new namespace(s) */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">child_pid =\nclone(childFunc, child_stack + STACK_SIZE, <br>\nflags | SIGCHLD, &amp;args); <br>\nif (child_pid == -1) <br>\nerrExit(&quot;clone&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Parent falls\nthrough to here */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (verbose)\n<br>\nprintf(&quot;%s: PID of child created by clone() is\n%jd\\n&quot;, <br>\nargv[0], (intmax_t) child_pid);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Update the\nUID and GID maps in the child */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (uid_map !=\nNULL || map_zero) { <br>\nsnprintf(map_path, PATH_MAX, &quot;/proc/%jd/uid_map&quot;,\n<br>\n(intmax_t) child_pid); <br>\nif (map_zero) { <br>\nsnprintf(map_buf, MAP_BUF_SIZE, &quot;0 %jd 1&quot;, <br>\n(intmax_t) getuid()); <br>\nuid_map = map_buf; <br>\n} <br>\nupdate_map(uid_map, map_path); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (gid_map !=\nNULL || map_zero) { <br>\nproc_setgroups_write(child_pid, &quot;deny&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">snprintf(map_path,\nPATH_MAX, &quot;/proc/%jd/gid_map&quot;, <br>\n(intmax_t) child_pid); <br>\nif (map_zero) { <br>\nsnprintf(map_buf, MAP_BUF_SIZE, &quot;0 %ld 1&quot;, <br>\n(intmax_t) getgid()); <br>\ngid_map = map_buf; <br>\n} <br>\nupdate_map(gid_map, map_path); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Close the\nwrite end of the pipe, to signal to the child that we <br>\nhave updated the UID and GID maps */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(args.pipe_fd[1]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(waitpid(child_pid, NULL, 0) == -1) /* Wait for child */\n<br>\nerrExit(&quot;waitpid&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (verbose)\n<br>\nprintf(&quot;%s: terminating\\n&quot;, argv[0]);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/newgidmap\">newgidmap(1)</a>,\n<a href=\"https://man.page/1/newuidmap\">newuidmap(1)</a>, <a href=\"https://man.page/2/clone\">clone(2)</a>, <a href=\"https://man.page/2/ptrace\">ptrace(2)</a>,\n<a href=\"https://man.page/2/setns\">setns(2)</a>, <a href=\"https://man.page/2/unshare\">unshare(2)</a>, <a href=\"https://man.page/5/proc\">proc(5)</a>,\n<a href=\"https://man.page/5/subgid\">subgid(5)</a>, <a href=\"https://man.page/5/subuid\">subuid(5)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/cgroup_namespaces\">cgroup_namespaces(7)</a>, <a href=\"https://man.page/7/credentials\">credentials(7)</a>,\n<a href=\"https://man.page/7/namespaces\">namespaces(7)</a>, <a href=\"https://man.page/7/pid_namespaces\">pid_namespaces(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\nsource file\n<i>Documentation/namespaces/resource-control.txt</i>.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}