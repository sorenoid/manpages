{"name":"sched","description":"sched - overview of CPU scheduling","body":"\n\n<h1 align=\"center\">SCHED</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sched -\noverview of CPU scheduling</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6.23, the default scheduler is CFS, the &quot;Completely\nFair Scheduler&quot;. The CFS scheduler replaced the earlier\n&quot;O(1)&quot; scheduler.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>API\nsummary</b> <br>\nLinux provides the following system calls for controlling\nthe CPU scheduling behavior, policy, and priority of\nprocesses (or, more precisely, threads). <b><br>\nnice</b>(2)</p>\n\n<p style=\"margin-left:22%;\">Set a new nice value for the\ncalling thread, and return the new nice value.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/getpriority\">getpriority(2)</a></p>\n\n<p style=\"margin-left:22%;\">Return the nice value of a\nthread, a process group, or the set of threads owned by a\nspecified user.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/setpriority\">setpriority(2)</a></p>\n\n<p style=\"margin-left:22%;\">Set the nice value of a thread,\na process group, or the set of threads owned by a specified\nuser.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a></p>\n\n<p style=\"margin-left:22%;\">Set the scheduling policy and\nparameters of a specified thread.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_getscheduler\">sched_getscheduler(2)</a></p>\n\n<p style=\"margin-left:22%;\">Return the scheduling policy of\na specified thread.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_setparam\">sched_setparam(2)</a></p>\n\n<p style=\"margin-left:22%;\">Set the scheduling parameters\nof a specified thread.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_getparam\">sched_getparam(2)</a></p>\n\n<p style=\"margin-left:22%;\">Fetch the scheduling parameters\nof a specified thread.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_get_priority_max\">sched_get_priority_max(2)</a></p>\n\n<p style=\"margin-left:22%;\">Return the maximum priority\navailable in a specified scheduling policy.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_get_priority_min\">sched_get_priority_min(2)</a></p>\n\n<p style=\"margin-left:22%;\">Return the minimum priority\navailable in a specified scheduling policy.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_rr_get_interval\">sched_rr_get_interval(2)</a></p>\n\n<p style=\"margin-left:22%;\">Fetch the quantum used for\nthreads that are scheduled under the &quot;round-robin&quot;\nscheduling policy.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_yield\">sched_yield(2)</a></p>\n\n<p style=\"margin-left:22%;\">Cause the caller to relinquish\nthe CPU, so that some other thread be executed.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a></p>\n\n<p style=\"margin-left:22%;\">(Linux-specific) Set the CPU\naffinity of a specified thread.</p>\n\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_getaffinity\">sched_getaffinity(2)</a></p>\n\n<p style=\"margin-left:22%;\">(Linux-specific) Get the CPU\naffinity of a specified thread.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a></p>\n\n<p style=\"margin-left:22%;\">Set the scheduling policy and\nparameters of a specified thread. This (Linux-specific)\nsystem call provides a superset of the functionality of\n<a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a> and\n<a href=\"https://man.page/2/sched_setparam\">sched_setparam(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><a href=\"https://man.page/2/sched_getattr\">sched_getattr(2)</a></p>\n\n<p style=\"margin-left:22%;\">Fetch the scheduling policy and\nparameters of a specified thread. This (Linux-specific)\nsystem call provides a superset of the functionality of\n<a href=\"https://man.page/2/sched_getscheduler\">sched_getscheduler(2)</a> and\n<a href=\"https://man.page/2/sched_getparam\">sched_getparam(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Scheduling\npolicies</b> <br>\nThe scheduler is the kernel component that decides which\nrunnable thread will be executed by the CPU next. Each\nthread has an associated scheduling policy and a\n<i>static</i> scheduling priority, <i>sched_priority</i>.\nThe scheduler makes its decisions based on knowledge of the\nscheduling policy and static priority of all threads on the\nsystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For threads\nscheduled under one of the normal scheduling policies\n(<b>SCHED_OTHER</b>, <b>SCHED_IDLE</b>, <b>SCHED_BATCH</b>),\n<i>sched_priority</i> is not used in scheduling decisions\n(it must be specified as 0).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Processes\nscheduled under one of the real-time policies\n(<b>SCHED_FIFO</b>, <b>SCHED_RR</b>) have a\n<i>sched_priority</i> value in the range 1 (low) to 99\n(high). (As the numbers imply, real-time threads always have\nhigher priority than normal threads.) Note well: POSIX.1\nrequires an implementation to support only a minimum 32\ndistinct priority levels for the real-time policies, and\nsome systems supply just this minimum. Portable programs\nshould use <a href=\"https://man.page/2/sched_get_priority_min\">sched_get_priority_min(2)</a> and\n<a href=\"https://man.page/2/sched_get_priority_max\">sched_get_priority_max(2)</a> to find the range of\npriorities supported for a particular policy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Conceptually,\nthe scheduler maintains a list of runnable threads for each\npossible <i>sched_priority</i> value. In order to determine\nwhich thread runs next, the scheduler looks for the nonempty\nlist with the highest static priority and selects the thread\nat the head of this list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\nthread&rsquo;s scheduling policy determines where it will be\ninserted into the list of threads with equal static priority\nand how it will move inside this list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All scheduling\nis preemptive: if a thread with a higher static priority\nbecomes ready to run, the currently running thread will be\npreempted and returned to the wait list for its static\npriority level. The scheduling policy determines the\nordering only within the list of runnable threads with equal\nstatic priority.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCHED_FIFO:\nFirst in-first out scheduling <br>\nSCHED_FIFO</b> can be used only with static priorities\nhigher than 0, which means that when a <b>SCHED_FIFO</b>\nthread becomes runnable, it will always immediately preempt\nany currently running <b>SCHED_OTHER</b>,\n<b>SCHED_BATCH</b>, or <b>SCHED_IDLE</b> thread.\n<b>SCHED_FIFO</b> is a simple scheduling algorithm without\ntime slicing. For threads scheduled under the\n<b>SCHED_FIFO</b> policy, the following rules apply:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>1)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>A running <b>SCHED_FIFO</b> thread that has been\npreempted by another thread of higher priority will stay at\nthe head of the list for its priority and will resume\nexecution as soon as all threads of higher priority are\nblocked again.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>When a blocked <b>SCHED_FIFO</b> thread becomes\nrunnable, it will be inserted at the end of the list for its\npriority.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>If a call to <a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a>,\n<a href=\"https://man.page/2/sched_setparam\">sched_setparam(2)</a>, <a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a>,\n<a href=\"https://man.page/3/pthread_setschedparam\">pthread_setschedparam(3)</a>, or\n<a href=\"https://man.page/3/pthread_setschedprio\">pthread_setschedprio(3)</a> changes the priority of the\nrunning or runnable <b>SCHED_FIFO</b> thread identified by\n<i>pid</i> the effect on the thread&rsquo;s position in the\nlist depends on the direction of the change to threads\npriority:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"2%\"></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">If the thread&rsquo;s priority\nis raised, it is placed at the end of the list for its new\npriority. As a consequence, it may preempt a currently\nrunning thread with the same priority.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>If the thread&rsquo;s priority is unchanged, its\nposition in the run list is unchanged.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"15%\"></td>\n<td width=\"2%\">\n\n\n<p>&bull;</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>If the thread&rsquo;s priority is lowered, it is placed\nat the front of the list for its new priority.</p></td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">According to\nPOSIX.1-2008, changes to a thread&rsquo;s priority (or\npolicy) using any mechanism other than\n<a href=\"https://man.page/3/pthread_setschedprio\">pthread_setschedprio(3)</a> should result in the thread\nbeing placed at the end of the list for its priority.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">4)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">A thread calling\n<a href=\"https://man.page/2/sched_yield\">sched_yield(2)</a> will be put at the end of the\nlist.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">No other events\nwill move a thread scheduled under the <b>SCHED_FIFO</b>\npolicy in the wait list of runnable threads with equal\nstatic priority.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<b>SCHED_FIFO</b> thread runs until either it is blocked by\nan I/O request, it is preempted by a higher priority thread,\nor it calls <a href=\"https://man.page/2/sched_yield\">sched_yield(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCHED_RR:\nRound-robin scheduling <br>\nSCHED_RR</b> is a simple enhancement of <b>SCHED_FIFO</b>.\nEverything described above for <b>SCHED_FIFO</b> also\napplies to <b>SCHED_RR</b>, except that each thread is\nallowed to run only for a maximum time quantum. If a\n<b>SCHED_RR</b> thread has been running for a time period\nequal to or longer than the time quantum, it will be put at\nthe end of the list for its priority. A <b>SCHED_RR</b>\nthread that has been preempted by a higher priority thread\nand subsequently resumes execution as a running thread will\ncomplete the unexpired portion of its round-robin time\nquantum. The length of the time quantum can be retrieved\nusing <a href=\"https://man.page/2/sched_rr_get_interval\">sched_rr_get_interval(2)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCHED_DEADLINE:\nSporadic task model deadline scheduling</b> <br>\nSince version 3.14, Linux provides a deadline scheduling\npolicy (<b>SCHED_DEADLINE</b>). This policy is currently\nimplemented using GEDF (Global Earliest Deadline First) in\nconjunction with CBS (Constant Bandwidth Server). To set and\nfetch this policy and associated attributes, one must use\nthe Linux-specific <a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a> and\n<a href=\"https://man.page/2/sched_getattr\">sched_getattr(2)</a> system calls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A sporadic task\nis one that has a sequence of jobs, where each job is\nactivated at most once per period. Each job also has a\n<i>relative deadline</i>, before which it should finish\nexecution, and a <i>computation time</i>, which is the CPU\ntime necessary for executing the job. The moment when a task\nwakes up because a new job has to be executed is called the\n<i>arrival time</i> (also referred to as the request time or\nrelease time). The <i>start time</i> is the time at which a\ntask starts its execution. The <i>absolute deadline</i> is\nthus obtained by adding the relative deadline to the arrival\ntime.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\ndiagram clarifies these terms:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">arrival/wakeup\nabsolute deadline <br>\n| start time | <br>\n| | | <br>\nv v v <br>\n-----x--------xooooooooooooooooo--------x--------x--- <br>\n|&lt;- comp. time -&gt;| <br>\n|&lt;------- relative deadline ------&gt;| <br>\n|&lt;-------------- period -------------------&gt;|</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When setting a\n<b>SCHED_DEADLINE</b> policy for a thread using\n<a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a>, one can specify three parameters:\n<i>Runtime</i>, <i>Deadline</i>, and <i>Period</i>. These\nparameters do not necessarily correspond to the\naforementioned terms: usual practice is to set Runtime to\nsomething bigger than the average computation time (or\nworst-case execution time for hard real-time tasks),\nDeadline to the relative deadline, and Period to the period\nof the task. Thus, for <b>SCHED_DEADLINE</b> scheduling, we\nhave:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">arrival/wakeup\nabsolute deadline <br>\n| start time | <br>\n| | | <br>\nv v v <br>\n-----x--------xooooooooooooooooo--------x--------x--- <br>\n|&lt;-- Runtime -------&gt;| <br>\n|&lt;----------- Deadline -----------&gt;| <br>\n|&lt;-------------- Period -------------------&gt;|</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The three\ndeadline-scheduling parameters correspond to the\n<i>sched_runtime</i>, <i>sched_deadline</i>, and\n<i>sched_period</i> fields of the <i>sched_attr</i>\nstructure; see <a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a>. These fields express\nvalues in nanoseconds. If <i>sched_period</i> is specified\nas 0, then it is made the same as <i>sched_deadline</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\nrequires that:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sched_runtime\n&lt;= sched_deadline &lt;= sched_period</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nunder the current implementation, all of the parameter\nvalues must be at least 1024 (i.e., just over one\nmicrosecond, which is the resolution of the implementation),\nand less than 2^63. If any of these checks fails,\n<a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a> fails with the error\n<b>EINVAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The CBS\nguarantees non-interference between tasks, by throttling\nthreads that attempt to over-run their specified\nRuntime.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To ensure\ndeadline scheduling guarantees, the kernel must prevent\nsituations where the set of <b>SCHED_DEADLINE</b> threads is\nnot feasible (schedulable) within the given constraints. The\nkernel thus performs an admittance test when setting or\nchanging <b>SCHED_DEADLINE</b> policy and attributes. This\nadmission test calculates whether the change is feasible; if\nit is not, <a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a> fails with the error\n<b>EBUSY</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example, it\nis required (but not necessarily sufficient) for the total\nutilization to be less than or equal to the total number of\nCPUs available, where, since each thread can maximally run\nfor Runtime per Period, that thread&rsquo;s utilization is\nits Runtime divided by its Period.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to\nfulfill the guarantees that are made when a thread is\nadmitted to the <b>SCHED_DEADLINE</b> policy,\n<b>SCHED_DEADLINE</b> threads are the highest priority (user\ncontrollable) threads in the system; if any\n<b>SCHED_DEADLINE</b> thread is runnable, it will preempt\nany thread scheduled under one of the other policies.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A call to\n<a href=\"https://man.page/2/fork\">fork(2)</a> by a thread scheduled under the\n<b>SCHED_DEADLINE</b> policy fails with the error\n<b>EAGAIN</b>, unless the thread has its reset-on-fork flag\nset (see below).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<b>SCHED_DEADLINE</b> thread that calls\n<a href=\"https://man.page/2/sched_yield\">sched_yield(2)</a> will yield the current job and wait\nfor a new period to begin.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCHED_OTHER:\nDefault Linux time-sharing scheduling <br>\nSCHED_OTHER</b> can be used at only static priority 0 (i.e.,\nthreads under real-time policies always have priority over\n<b>SCHED_OTHER</b> processes). <b>SCHED_OTHER</b> is the\nstandard Linux time-sharing scheduler that is intended for\nall threads that do not require the special real-time\nmechanisms.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The thread to\nrun is chosen from the static priority 0 list based on a\n<i>dynamic</i> priority that is determined only inside this\nlist. The dynamic priority is based on the nice value (see\nbelow) and is increased for each time quantum the thread is\nready to run, but denied to run by the scheduler. This\nensures fair progress among all <b>SCHED_OTHER</b>\nthreads.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the Linux\nkernel source code, the <b>SCHED_OTHER</b> policy is\nactually named <b>SCHED_NORMAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The nice\nvalue</b> <br>\nThe nice value is an attribute that can be used to influence\nthe CPU scheduler to favor or disfavor a process in\nscheduling decisions. It affects the scheduling of\n<b>SCHED_OTHER</b> and <b>SCHED_BATCH</b> (see below)\nprocesses. The nice value can be modified using\n<a href=\"https://man.page/2/nice\">nice(2)</a>, <a href=\"https://man.page/2/setpriority\">setpriority(2)</a>, or\n<a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1, the nice value is a per-process attribute; that is,\nthe threads in a process should share a nice value. However,\non Linux, the nice value is a per-thread attribute:\ndifferent threads in the same process may have different\nnice values.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The range of\nthe nice value varies across UNIX systems. On modern Linux,\nthe range is -20 (high priority) to +19 (low priority). On\nsome other systems, the range is -20..20. Very early Linux\nkernels (Before Linux 2.0) had the range -infinity..15.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The degree to\nwhich the nice value affects the relative scheduling of\n<b>SCHED_OTHER</b> processes likewise varies across UNIX\nsystems and across Linux kernel versions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With the advent\nof the CFS scheduler in kernel 2.6.23, Linux adopted an\nalgorithm that causes relative differences in nice values to\nhave a much stronger effect. In the current implementation,\neach unit of difference in the nice values of two processes\nresults in a factor of 1.25 in the degree to which the\nscheduler favors the higher priority process. This causes\nvery low nice values (+19) to truly provide little CPU to a\nprocess whenever there is any other higher priority load on\nthe system, and makes high nice values (-20) deliver most of\nthe CPU to applications that require it (e.g., some audio\napplications).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux, the\n<b>RLIMIT_NICE</b> resource limit can be used to define a\nlimit to which an unprivileged process&rsquo;s nice value\ncan be raised; see <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a> for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For further\ndetails on the nice value, see the subsections on the\nautogroup feature and group scheduling, below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCHED_BATCH:\nScheduling batch processes</b> <br>\n(Since Linux 2.6.16.) <b>SCHED_BATCH</b> can be used only at\nstatic priority 0. This policy is similar to\n<b>SCHED_OTHER</b> in that it schedules the thread according\nto its dynamic priority (based on the nice value). The\ndifference is that this policy will cause the scheduler to\nalways assume that the thread is CPU-intensive.\nConsequently, the scheduler will apply a small scheduling\npenalty with respect to wakeup behavior, so that this thread\nis mildly disfavored in scheduling decisions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This policy is\nuseful for workloads that are noninteractive, but do not\nwant to lower their nice value, and for workloads that want\na deterministic scheduling policy without interactivity\ncausing extra preemptions (between the workload&rsquo;s\ntasks).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCHED_IDLE:\nScheduling very low priority jobs</b> <br>\n(Since Linux 2.6.23.) <b>SCHED_IDLE</b> can be used only at\nstatic priority 0; the process nice value has no influence\nfor this policy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This policy is\nintended for running jobs at extremely low priority (lower\neven than a +19 nice value with the <b>SCHED_OTHER</b> or\n<b>SCHED_BATCH</b> policies).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Resetting\nscheduling policy for child processes</b> <br>\nEach thread has a reset-on-fork scheduling flag. When this\nflag is set, children created by <a href=\"https://man.page/2/fork\">fork(2)</a> do not\ninherit privileged scheduling policies. The reset-on-fork\nflag can be set by either:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">ORing the\n<b>SCHED_RESET_ON_FORK</b> flag into the <i>policy</i>\nargument when calling <a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a> (since\nLinux 2.6.32); or</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>specifying the <b>SCHED_FLAG_RESET_ON_FORK</b> flag in\n<i>attr.sched_flags</i> when calling\n<a href=\"https://man.page/2/sched_setattr\">sched_setattr(2)</a>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nconstants used with these two APIs have different names. The\nstate of the reset-on-fork flag can analogously be retrieved\nusing <a href=\"https://man.page/2/sched_getscheduler\">sched_getscheduler(2)</a> and\n<a href=\"https://man.page/2/sched_getattr\">sched_getattr(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nreset-on-fork feature is intended for media-playback\napplications, and can be used to prevent applications\nevading the <b>RLIMIT_RTTIME</b> resource limit (see\n<a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>) by creating multiple child\nprocesses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">More precisely,\nif the reset-on-fork flag is set, the following rules apply\nfor subsequently created children:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">If the calling thread has a\nscheduling policy of <b>SCHED_FIFO</b> or <b>SCHED_RR</b>,\nthe policy is reset to <b>SCHED_OTHER</b> in child\nprocesses.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If the calling process has a negative nice value, the\nnice value is reset to zero in child processes.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After the\nreset-on-fork flag has been enabled, it can be reset only if\nthe thread has the <b>CAP_SYS_NICE</b> capability. This flag\nis disabled in child processes created by\n<a href=\"https://man.page/2/fork\">fork(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Privileges\nand resource limits</b> <br>\nIn Linux kernels before 2.6.12, only privileged\n(<b>CAP_SYS_NICE</b>) threads can set a nonzero static\npriority (i.e., set a real-time scheduling policy). The only\nchange that an unprivileged thread can make is to set the\n<b>SCHED_OTHER</b> policy, and this can be done only if the\neffective user ID of the caller matches the real or\neffective user ID of the target thread (i.e., the thread\nspecified by <i>pid</i>) whose policy is being changed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A thread must\nbe privileged (<b>CAP_SYS_NICE</b>) in order to set or\nmodify a <b>SCHED_DEADLINE</b> policy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6.12, the <b>RLIMIT_RTPRIO</b> resource limit defines a\nceiling on an unprivileged thread&rsquo;s static priority\nfor the <b>SCHED_RR</b> and <b>SCHED_FIFO</b> policies. The\nrules for changing scheduling policy and priority are as\nfollows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">If an unprivileged thread has a\nnonzero <b>RLIMIT_RTPRIO</b> soft limit, then it can change\nits scheduling policy and priority, subject to the\nrestriction that the priority cannot be set to a value\nhigher than the maximum of its current priority and its\n<b>RLIMIT_RTPRIO</b> soft limit.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If the <b>RLIMIT_RTPRIO</b> soft limit is 0, then the\nonly permitted changes are to lower the priority, or to\nswitch to a non-real-time policy.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Subject to the same rules, another unprivileged thread\ncan also make these changes, as long as the effective user\nID of the thread making the change matches the real or\neffective user ID of the target thread.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Special rules apply for the <b>SCHED_IDLE</b> policy. In\nLinux kernels before 2.6.39, an unprivileged thread\noperating under this policy cannot change its policy,\nregardless of the value of its <b>RLIMIT_RTPRIO</b> resource\nlimit. In Linux kernels since 2.6.39, an unprivileged thread\ncan switch to either the <b>SCHED_BATCH</b> or the\n<b>SCHED_OTHER</b> policy so long as its nice value falls\nwithin the range permitted by its <b>RLIMIT_NICE</b>\nresource limit (see <a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Privileged\n(<b>CAP_SYS_NICE</b>) threads ignore the\n<b>RLIMIT_RTPRIO</b> limit; as with older kernels, they can\nmake arbitrary changes to scheduling policy and priority.\nSee <a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a> for further information on\n<b>RLIMIT_RTPRIO</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Limiting the\nCPU usage of real-time and deadline processes</b> <br>\nA nonblocking infinite loop in a thread scheduled under the\n<b>SCHED_FIFO</b>, <b>SCHED_RR</b>, or <b>SCHED_DEADLINE</b>\npolicy can potentially block all other threads from\naccessing the CPU forever. Prior to Linux 2.6.25, the only\nway of preventing a runaway real-time process from freezing\nthe system was to run (at the console) a shell scheduled\nunder a higher static priority than the tested application.\nThis allows an emergency kill of tested real-time\napplications that do not block or terminate as expected.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6.25, there are other techniques for dealing with runaway\nreal-time and deadline processes. One of these is to use the\n<b>RLIMIT_RTTIME</b> resource limit to set a ceiling on the\nCPU time that a real-time process may consume. See\n<a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a> for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since version\n2.6.25, Linux also provides two <i>/proc</i> files that can\nbe used to reserve a certain amount of CPU time to be used\nby non-real-time processes. Reserving CPU time in this\nfashion allows some CPU time to be allocated to (say) a root\nshell that can be used to kill a runaway process. Both of\nthese files specify time values in microseconds: <i><br>\n/proc/sys/kernel/sched_rt_period_us</i></p>\n\n<p style=\"margin-left:22%;\">This file specifies a\nscheduling period that is equivalent to 100% CPU bandwidth.\nThe value in this file can range from 1 to <b>INT_MAX</b>,\ngiving an operating range of 1 microsecond to around 35\nminutes. The default value in this file is 1,000,000 (1\nsecond).</p>\n\n\n<p style=\"margin-left:11%;\"><i>/proc/sys/kernel/sched_rt_runtime_us</i></p>\n\n<p style=\"margin-left:22%;\">The value in this file\nspecifies how much of the &quot;period&quot; time can be\nused by all real-time and deadline scheduled processes on\nthe system. The value in this file can range from -1 to\n<b>INT_MAX</b>-1. Specifying -1 makes the run time the same\nas the period; that is, no CPU time is set aside for\nnon-real-time processes (which was the Linux behavior before\nkernel 2.6.25). The default value in this file is 950,000\n(0.95 seconds), meaning that 5% of the CPU time is reserved\nfor processes that don&rsquo;t run under a real-time or\ndeadline scheduling policy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Response\ntime</b> <br>\nA blocked high priority thread waiting for I/O has a certain\nresponse time before it is scheduled again. The device\ndriver writer can greatly reduce this response time by using\na &quot;slow interrupt&quot; interrupt handler.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Miscellaneous</b>\n<br>\nChild processes inherit the scheduling policy and parameters\nacross a <a href=\"https://man.page/2/fork\">fork(2)</a>. The scheduling policy and\nparameters are preserved across <a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Memory locking\nis usually needed for real-time processes to avoid paging\ndelays; this can be done with <a href=\"https://man.page/2/mlock\">mlock(2)</a> or\n<a href=\"https://man.page/2/mlockall\">mlockall(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\nautogroup feature</b> <br>\nSince Linux 2.6.38, the kernel provides a feature known as\nautogrouping to improve interactive desktop performance in\nthe face of multiprocess, CPU-intensive workloads such as\nbuilding the Linux kernel with large numbers of parallel\nbuild processes (i.e., the <a href=\"https://man.page/1/make\">make(1)</a> <b>-j</b>\nflag).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This feature\noperates in conjunction with the CFS scheduler and requires\na kernel that is configured with\n<b>CONFIG_SCHED_AUTOGROUP</b>. On a running system, this\nfeature is enabled or disabled via the file\n<i>/proc/sys/kernel/sched_autogroup_enabled</i>; a value of\n0 disables the feature, while a value of 1 enables it. The\ndefault value in this file is 1, unless the kernel was\nbooted with the <i>noautogroup</i> parameter.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A new autogroup\nis created when a new session is created via\n<a href=\"https://man.page/2/setsid\">setsid(2)</a>; this happens, for example, when a new\nterminal window is started. A new process created by\n<a href=\"https://man.page/2/fork\">fork(2)</a> inherits its parent&rsquo;s autogroup\nmembership. Thus, all of the processes in a session are\nmembers of the same autogroup. An autogroup is automatically\ndestroyed when the last process in the group terminates.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\nautogrouping is enabled, all of the members of an autogroup\nare placed in the same kernel scheduler &quot;task\ngroup&quot;. The CFS scheduler employs an algorithm that\nequalizes the distribution of CPU cycles across task groups.\nThe benefits of this for interactive desktop performance can\nbe described via the following example.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose that\nthere are two autogroups competing for the same CPU (i.e.,\npresume either a single CPU system or the use of\n<a href=\"https://man.page/1/taskset\">taskset(1)</a> to confine all the processes to the same\nCPU on an SMP system). The first group contains ten\nCPU-bound processes from a kernel build started with\n<i>make&nbsp;-j10</i>. The other contains a single CPU-bound\nprocess: a video player. The effect of autogrouping is that\nthe two groups will each receive half of the CPU cycles.\nThat is, the video player will receive 50% of the CPU\ncycles, rather than just 9% of the cycles, which would\nlikely lead to degraded video playback. The situation on an\nSMP system is more complex, but the general effect is the\nsame: the scheduler distributes CPU cycles across task\ngroups such that an autogroup that contains a large number\nof CPU-bound processes does not end up hogging CPU cycles at\nthe expense of the other jobs on the system.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\nprocess&rsquo;s autogroup (task group) membership can be\nviewed via the file <i>/proc/[pid]/autogroup</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cat\n/proc/1/autogroup</b> <br>\n/autogroup-1 nice 0</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This file can\nalso be used to modify the CPU bandwidth allocated to an\nautogroup. This is done by writing a number in the\n&quot;nice&quot; range to the file to set the\nautogroup&rsquo;s nice value. The allowed range is from +19\n(low priority) to -20 (high priority). (Writing values\noutside of this range causes <a href=\"https://man.page/2/write\">write(2)</a> to fail with\nthe error <b>EINVAL</b>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The autogroup\nnice setting has the same meaning as the process nice value,\nbut applies to distribution of CPU cycles to the autogroup\nas a whole, based on the relative nice values of other\nautogroups. For a process inside an autogroup, the CPU\ncycles that it receives will be a product of the\nautogroup&rsquo;s nice value (compared to other autogroups)\nand the process&rsquo;s nice value (compared to other\nprocesses in the same autogroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The use of the\n<a href=\"https://man.page/7/cgroups\">cgroups(7)</a> CPU controller to place processes in\ncgroups other than the root CPU cgroup overrides the effect\nof autogrouping.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The autogroup\nfeature groups only processes scheduled under non-real-time\npolicies (<b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, and\n<b>SCHED_IDLE</b>). It does not group processes scheduled\nunder real-time and deadline policies. Those processes are\nscheduled according to the rules described earlier.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The nice\nvalue and group scheduling</b> <br>\nWhen scheduling non-real-time processes (i.e., those\nscheduled under the <b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>,\nand <b>SCHED_IDLE</b> policies), the CFS scheduler employs a\ntechnique known as &quot;group scheduling&quot;, if the\nkernel was configured with the\n<b>CONFIG_FAIR_GROUP_SCHED</b> option (which is\ntypical).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Under group\nscheduling, threads are scheduled in &quot;task\ngroups&quot;. Task groups have a hierarchical relationship,\nrooted under the initial task group on the system, known as\nthe &quot;root task group&quot;. Task groups are formed in\nthe following circumstances:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>All of the threads in a CPU cgroup form a task group.\nThe parent of this task group is the task group of the\ncorresponding parent cgroup.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If autogrouping is enabled, then all of the threads that\nare (implicitly) placed in an autogroup (i.e., the same\nsession, as created by <a href=\"https://man.page/2/setsid\">setsid(2)</a>) form a task group.\nEach new autogroup is thus a separate task group. The root\ntask group is the parent of all such autogroups.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If autogrouping is enabled, then the root task group\nconsists of all processes in the root CPU cgroup that were\nnot otherwise implicitly placed into a new autogroup.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If autogrouping is disabled, then the root task group\nconsists of all processes in the root CPU cgroup.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If group scheduling was disabled (i.e., the kernel was\nconfigured without <b>CONFIG_FAIR_GROUP_SCHED</b>), then all\nof the processes on the system are notionally placed in a\nsingle task group.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Under group\nscheduling, a thread&rsquo;s nice value has an effect for\nscheduling decisions <i>only relative to other threads in\nthe same task group</i>. This has some surprising\nconsequences in terms of the traditional semantics of the\nnice value on UNIX systems. In particular, if autogrouping\nis enabled (which is the default in various distributions),\nthen employing <a href=\"https://man.page/2/setpriority\">setpriority(2)</a> or <a href=\"https://man.page/1/nice\">nice(1)</a> on a\nprocess has an effect only for scheduling relative to other\nprocesses executed in the same session (typically: the same\nterminal window).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Conversely, for\ntwo processes that are (for example) the sole CPU-bound\nprocesses in different sessions (e.g., different terminal\nwindows, each of whose jobs are tied to different\nautogroups), <i>modifying the nice value of the process in\none of the sessions has no effect</i> in terms of the\nscheduler&rsquo;s decisions relative to the process in the\nother session. A possibly useful workaround here is to use a\ncommand such as the following to modify the autogroup nice\nvalue for <i>all</i> of the processes in a terminal\nsession:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>echo 10\n&gt; /proc/self/autogroup</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Real-time\nfeatures in the mainline Linux kernel</b> <br>\nSince kernel version 2.6.18, Linux is gradually becoming\nequipped with real-time capabilities, most of which are\nderived from the former <i>realtime-preempt</i> patch set.\nUntil the patches have been completely merged into the\nmainline kernel, they must be installed to achieve the best\nreal-time performance. These patches are named:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">patch-<i>kernelversion</i>-rt<i>patchversion</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and can be\ndownloaded from\n<a href=\"http://www.kernel.org/pub/linux/kernel/projects/rt/\">http://www.kernel.org/pub/linux/kernel/projects/rt/</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Without the\npatches and prior to their full inclusion into the mainline\nkernel, the kernel configuration offers only the three\npreemption classes <b>CONFIG_PREEMPT_NONE</b>,\n<b>CONFIG_PREEMPT_VOLUNTARY</b>, and\n<b>CONFIG_PREEMPT_DESKTOP</b> which respectively provide no,\nsome, and considerable reduction of the worst-case\nscheduling latency.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With the\npatches applied or after their full inclusion into the\nmainline kernel, the additional configuration item\n<b>CONFIG_PREEMPT_RT</b> becomes available. If this is\nselected, Linux is transformed into a regular real-time\noperating system. The FIFO and RR scheduling policies are\nthen used to run a thread with true real-time priority and a\nminimum worst-case scheduling latency.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/7/cgroups\">cgroups(7)</a> CPU controller can be used to limit the\nCPU consumption of groups of processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Originally,\nStandard Linux was intended as a general-purpose operating\nsystem being able to handle background processes,\ninteractive applications, and less demanding real-time\napplications (applications that need to usually meet timing\ndeadlines). Although the Linux kernel 2.6 allowed for kernel\npreemption and the newly introduced O(1) scheduler ensures\nthat the time needed to schedule is fixed and deterministic\nirrespective of the number of active tasks, true real-time\ncomputing was not possible up to kernel version 2.6.17.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/chcpu\">chcpu(1)</a>,\n<a href=\"https://man.page/1/chrt\">chrt(1)</a>, <a href=\"https://man.page/1/lscpu\">lscpu(1)</a>, <a href=\"https://man.page/1/ps\">ps(1)</a>,\n<a href=\"https://man.page/1/taskset\">taskset(1)</a>, <a href=\"https://man.page/1/top\">top(1)</a>, <a href=\"https://man.page/2/getpriority\">getpriority(2)</a>,\n<a href=\"https://man.page/2/mlock\">mlock(2)</a>, <a href=\"https://man.page/2/mlockall\">mlockall(2)</a>, <a href=\"https://man.page/2/munlock\">munlock(2)</a>,\n<a href=\"https://man.page/2/munlockall\">munlockall(2)</a>, <a href=\"https://man.page/2/nice\">nice(2)</a>,\n<a href=\"https://man.page/2/sched_get_priority_max\">sched_get_priority_max(2)</a>,\n<a href=\"https://man.page/2/sched_get_priority_min\">sched_get_priority_min(2)</a>,\n<a href=\"https://man.page/2/sched_getaffinity\">sched_getaffinity(2)</a>, <a href=\"https://man.page/2/sched_getparam\">sched_getparam(2)</a>,\n<a href=\"https://man.page/2/sched_getscheduler\">sched_getscheduler(2)</a>,\n<a href=\"https://man.page/2/sched_rr_get_interval\">sched_rr_get_interval(2)</a>,\n<a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>, <a href=\"https://man.page/2/sched_setparam\">sched_setparam(2)</a>,\n<a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a>, <a href=\"https://man.page/2/sched_yield\">sched_yield(2)</a>,\n<a href=\"https://man.page/2/setpriority\">setpriority(2)</a>, <a href=\"https://man.page/3/pthread_getaffinity_np\">pthread_getaffinity_np(3)</a>,\n<a href=\"https://man.page/3/pthread_getschedparam\">pthread_getschedparam(3)</a>,\n<a href=\"https://man.page/3/pthread_setaffinity_np\">pthread_setaffinity_np(3)</a>, <a href=\"https://man.page/3/sched_getcpu\">sched_getcpu(3)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/cpuset\">cpuset(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Programming\nfor the real world - POSIX.4</i> by Bill O. Gallmeister,\nO&rsquo;Reilly &amp; Associates, Inc., ISBN\n1-56592-074-0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux\nkernel source files\n<i>Documentation/scheduler/sched-deadline.txt</i>,\n<i>Documentation/scheduler/sched-rt-group.txt</i>,\n<i>Documentation/scheduler/sched-design-CFS.txt</i>, and\n<i>Documentation/scheduler/sched-nice-design.txt</i></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}