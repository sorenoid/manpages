{"name":"gitcore-tutorial","description":"gitcore-tutorial\n- A Git core tutorial for developers","body":"\n\n<h1 align=\"center\">GITCORE-TUTORIAL</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">gitcore-tutorial\n- A Git core tutorial for developers</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git *</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This tutorial\nexplains how to use the &quot;core&quot; Git commands to set\nup and work with a Git repository.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you just\nneed to use Git as a revision control system you may prefer\nto start with &quot;A Tutorial Introduction to Git&quot;\n(<a href=\"https://man.page/7/gittutorial\">gittutorial(7)</a>) or <b><font color=\"#0000FF\">the Git\nUser Manual</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">However,\nan understanding of these low-level tools can be helpful if\nyou want to understand Git&rsquo;s internals.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\ncore Git is often called &quot;plumbing&quot;, with the\nprettier user interfaces on top of it called\n&quot;porcelain&quot;. You may not want to use the plumbing\ndirectly very often, but it can be good to know what the\nplumbing does when the porcelain isn&rsquo;t\nflushing.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Back\nwhen this document was originally written, many porcelain\ncommands were shell scripts. For simplicity, it still uses\nthem as examples to illustrate how plumbing is fit together\nto form the porcelain commands. The source tree includes\nsome of these scripts in contrib/examples/ for reference.\nAlthough these are not implemented as shell scripts anymore,\nthe description of what the plumbing layer commands do is\nstill valid.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><b><big>Note</big></b>\n<br>\nDeeper technical details are often marked as Notes, which\nyou can skip on your first reading.</font></p>\n\n<h2>CREATING A GIT REPOSITORY\n<a name=\"CREATING A GIT REPOSITORY\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>Creating\na new Git repository couldn&rsquo;t be easier: all Git\nrepositories start out empty, and the only thing you need to\ndo is find yourself a subdirectory that you want to use as a\nworking tree - either an empty one for a totally new\nproject, or an existing working tree that you want to import\ninto Git.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>For\nour first example, we&rsquo;re going to start a totally new\nrepository from scratch, with no pre-existing files, and\nwe&rsquo;ll call it <i>git-tutorial</i>. To start up, create\na subdirectory for it, change into that subdirectory, and\ninitialize the Git infrastructure with <i>git\ninit</i>:</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>$\nmkdir git-tutorial <br>\n$ cd git-tutorial <br>\n$ git init</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>to\nwhich Git will reply</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>Initialized\nempty Git repository in .git/</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>which\nis just Git&rsquo;s way of saying that you haven&rsquo;t\nbeen doing anything strange, and that it will have created a\nlocal <b>.git</b> directory setup for your new project. You\nwill now have a <b>.git</b> directory, and you can inspect\nthat with <i>ls</i>. For your new empty project, it should\nshow you three entries, among other things:</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>&bull;\na file called <b>HEAD</b>, that has <b>ref:\nrefs/heads/master</b> in it. This is similar to a symbolic\nlink and points at <b>refs/heads/master</b> relative to the\n<b>HEAD</b> file.</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>Don&rsquo;t\nworry about the fact that the file that the <b>HEAD</b> link\npoints to doesn&rsquo;t even exist yet &mdash; you\nhaven&rsquo;t created the commit that will start your\n<b>HEAD</b> development branch yet.</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>&bull;\na subdirectory called <b>objects</b>, which will contain all\nthe objects of your project. You should never have any real\nreason to look at the objects directly, but you might want\nto know that these objects are what contains all the real\n<i>data</i> in your repository.</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>&bull;\na subdirectory called <b>refs</b>, which contains references\nto objects.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>In\nparticular, the <b>refs</b> subdirectory will contain two\nother subdirectories, named <b>heads</b> and <b>tags</b>\nrespectively. They do exactly what their names imply: they\ncontain references to any number of different <i>heads</i>\nof development (aka <i>branches</i>), and to any <i>tags</i>\nthat you have created to name specific versions in your\nrepository.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>One\nnote: the special <b>master</b> head is the default branch,\nwhich is why the <b>.git/HEAD</b> file was created points to\nit even if it doesn&rsquo;t yet exist. Basically, the\n<b>HEAD</b> link is supposed to always point to the branch\nyou are working on right now, and you always start out\nexpecting to work on the <b>master</b>\nbranch.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>However,\nthis is only a convention, and you can name your branches\nanything you want, and don&rsquo;t have to ever even\n<i>have</i> a <b>master</b> branch. A number of the Git\ntools will assume that <b>.git/HEAD</b> is valid,\nthough.</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><b><big>Note</big></b>\n<br>\nAn <i>object</i> is identified by its 160-bit SHA-1 hash,\naka <i>object name</i>, and a reference to an object is\nalways the 40-byte hex representation of that SHA-1 name.\nThe files in the <b>refs</b> subdirectory are expected to\ncontain these hex references (usually with a final <b>\\n</b>\nat the end), and you should thus expect to see a number of\n41-byte files containing these references in these\n<b>refs</b> subdirectories when you actually start\npopulating your tree.</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><b><big>Note</big></b>\n<br>\nAn advanced user may want to take a look at\n<a href=\"https://man.page/5/gitrepository-layout\">gitrepository-layout(5)</a> after finishing this\ntutorial.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>You\nhave now created your first Git repository. Of course, since\nit&rsquo;s empty, that&rsquo;s not very useful, so\nlet&rsquo;s start populating it with data.</big></font></p>\n\n<h2>POPULATING A GIT REPOSITORY\n<a name=\"POPULATING A GIT REPOSITORY\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>We&rsquo;ll\nkeep this simple and stupid, so we&rsquo;ll start off with\npopulating a few trivial files just to get a feel for\nit.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>Start\noff with just creating any random files that you want to\nmaintain in your Git repository. We&rsquo;ll start off with\na few bad examples, just to get a feel for how this\nworks:</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\necho &quot;Hello World&quot; &gt;hello <br>\n$ echo &quot;Silly example&quot;\n&gt;example</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>you\nhave now created two files in your working tree (aka\n<i>working directory</i>), but to actually check in your\nhard work, you will have to go through two\nsteps:</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>&bull;\nfill in the <i>index</i> file (aka <i>cache</i>) with the\ninformation about your working tree\nstate.</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>&bull;\ncommit that index file as an object.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>The\nfirst step is trivial: when you want to tell Git about any\nchanges to your working tree, you use the <i>git\nupdate-index</i> program. That program normally just takes a\nlist of filenames you want to update, but to avoid trivial\nmistakes, it refuses to add new entries to the index (or\nremove existing ones) unless you explicitly tell it that\nyou&rsquo;re adding a new entry with the <b>--add</b> flag\n(or removing an entry with the <b>--remove</b>)\nflag.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>So\nto populate the index with the two files you just created,\nyou can do</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\ngit update-index --add hello example</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>and\nyou have now told Git to track those two\nfiles.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>In\nfact, as you did that, if you now look into your object\ndirectory, you&rsquo;ll notice that Git will have added two\nnew objects to the object database. If you did exactly the\nsteps above, you should now be able to\ndo</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\nls .git/objects/??/*</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>and\nsee two files:</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>.git/objects/55/7db03de997c86a4a028e1ebd3a1ceb225be238\n<br>\n\n.git/objects/f2/4c74a2e500f5ee1332c86b94199f52b1d1d962</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>which\ncorrespond with the objects with names of <b>557db...</b>\nand <b>f24c7...</b> respectively.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>If\nyou want to, you can use <i>git cat-file</i> to look at\nthose objects, but you&rsquo;ll have to use the object name,\nnot the filename of the object:</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\ngit cat-file -t\n557db03de997c86a4a028e1ebd3a1ceb225be238</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>where\nthe <b>-t</b> tells <i>git cat-file</i> to tell you what the\n&quot;type&quot; of the object is. Git will tell you that\nyou have a &quot;blob&quot; object (i.e., just a regular\nfile), and you can see the contents\nwith</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\ngit cat-file blob 557db03</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>which\nwill print out &quot;Hello World&quot;. The object\n<b>557db03</b> is nothing more than the contents of your\nfile <b>hello</b>.</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><b><big>Note</big></b>\n<br>\nDon&rsquo;t confuse that object with the file <b>hello</b>\nitself. The object is literally just those specific\n<b>contents</b> of the file, and however much you later\nchange the contents in file <b>hello</b>, the object we just\nlooked at will never change. Objects are\nimmutable.</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><b><big>Note</big></b>\n<br>\nThe second example demonstrates that you can abbreviate the\nobject name to only the first several hexadecimal digits in\nmost places.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>Anyway,\nas we mentioned previously, you normally never actually take\na look at the objects themselves, and typing long\n40-character hex names is not something you&rsquo;d normally\nwant to do. The above digression was just to show that\n<i>git update-index</i> did something magical, and actually\nsaved away the contents of your files into the Git object\ndatabase.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>Updating\nthe index did something else too: it created a\n<b>.git/index</b> file. This is the index that describes\nyour current working tree, and something you should be very\naware of. Again, you normally never worry about the index\nfile itself, but you should be aware of the fact that you\nhave not actually really &quot;checked in&quot; your files\ninto Git so far, you&rsquo;ve only <b>told</b> Git about\nthem.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>However,\nsince Git knows about them, you can now start using some of\nthe most basic Git commands to manipulate the files or look\nat their status.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>In\nparticular, let&rsquo;s not even check in the two files into\nGit yet, we&rsquo;ll start off by adding another line to\n<b>hello</b> first:</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\necho &quot;It's a new day for git&quot;\n&gt;&gt;hello</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>and\nyou can now, since you told Git about the previous state of\n<b>hello</b>, ask Git what has changed in the tree compared\nto your old index, using the <i>git diff-files</i>\ncommand:</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\ngit diff-files</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>Oops.\nThat wasn&rsquo;t very readable. It just spit out its own\ninternal version of a <i>diff</i>, but that internal version\nreally just tells you that it has noticed that\n&quot;hello&quot; has been modified, and that the old object\ncontents it had have been replaced with something\nelse.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>To\nmake it readable, we can tell <i>git diff-files</i> to\noutput the differences as a patch, using the <b>-p</b>\nflag:</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\ngit diff-files -p <br>\ndiff --git a/hello b/hello <br>\nindex 557db03..263414f 100644 <br>\n--- a/hello <br>\n+++ b/hello <br>\n@@ -1 +1,2 @@ <br>\nHello World <br>\n+It's a new day for git</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>i.e.\nthe diff of the change we caused by adding another line to\n<b>hello</b>.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>In\nother words, <i>git diff-files</i> always shows us the\ndifference between what is recorded in the index, and what\nis currently in the working tree. That&rsquo;s very\nuseful.</big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big>A\ncommon shorthand for <b>git diff-files -p</b> is to just\nwrite <b>git diff</b>, which will do the same\nthing.</big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big>$\ngit diff <br>\ndiff --git a/hello b/hello <br>\nindex 557db03..263414f 100644 <br>\n--- a/hello <br>\n+++ b/hello <br>\n@@ -1 +1,2 @@ <br>\nHello World <br>\n+It's a new day for git</big></big></font></p>\n\n<h2>COMMITTING GIT STATE\n<a name=\"COMMITTING GIT STATE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Now,\nwe want to go to the next stage in Git, which is to take the\nfiles that Git knows about in the index, and commit them as\na real tree. We do that in two phases: creating a\n<i>tree</i> object, and committing that <i>tree</i> object\nas a <i>commit</i> object together with an explanation of\nwhat the tree was all about, along with information of how\nwe came to that state.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Creating\na tree object is trivial, and is done with <i>git\nwrite-tree</i>. There are no options or other input: <b>git\nwrite-tree</b> will take the current index state, and write\nan object that describes that whole index. In other words,\nwe&rsquo;re now tying together all the different filenames\nwith their contents (and their permissions), and we&rsquo;re\ncreating the equivalent of a Git &quot;directory&quot;\nobject:</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>$\ngit write-tree</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>and\nthis will just output the name of the resulting tree, in\nthis case (if you have done exactly as I&rsquo;ve described)\nit should be</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>8988da15d077d4829fc51d8544c097def6644dbb</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>which\nis another incomprehensible object name. Again, if you want\nto, you can use <b>git cat-file -t 8988d...</b> to see that\nthis time the object is not a &quot;blob&quot; object, but a\n&quot;tree&quot; object (you can also use <b>git\ncat-file</b> to actually output the raw object contents, but\nyou&rsquo;ll see mainly a binary mess, so that&rsquo;s less\ninteresting).</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>However\n&mdash; normally you&rsquo;d never use <i>git write-tree</i>\non its own, because normally you always commit a tree into a\ncommit object using the <i>git commit-tree</i> command. In\nfact, it&rsquo;s easier to not actually use <i>git\nwrite-tree</i> on its own at all, but to just pass its\nresult in as an argument to <i>git\ncommit-tree</i>.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><i>git\ncommit-tree</i> normally takes several arguments &mdash; it\nwants to know what the <i>parent</i> of a commit was, but\nsince this is the first commit ever in this new repository,\nand it has no parents, we only need to pass in the object\nname of the tree. However, <i>git commit-tree</i> also wants\nto get a commit message on its standard input, and it will\nwrite out the resulting object name for the commit to its\nstandard output.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>And\nthis is where we create the <b>.git/refs/heads/master</b>\nfile which is pointed at by <b>HEAD</b>. This file is\nsupposed to contain the reference to the top-of-tree of the\nmaster branch, and since that&rsquo;s exactly what <i>git\ncommit-tree</i> spits out, we can do this all with a\nsequence of simple shell\ncommands:</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>$\ntree=$(git write-tree) <br>\n$ commit=$(echo 'Initial commit' | git commit-tree $tree)\n<br>\n$ git update-ref HEAD $commit</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>In\nthis case this creates a totally new commit that is not\nrelated to anything else. Normally you do this only\n<b>once</b> for a project ever, and all later commits will\nbe parented on top of an earlier\ncommit.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Again,\nnormally you&rsquo;d never actually do this by hand. There\nis a helpful script called <b>git commit</b> that will do\nall of this for you. So you could have just written <b>git\ncommit</b> instead, and it would have done the above magic\nscripting for you.</big></big></big></font></p>\n\n<h2>MAKING A CHANGE\n<a name=\"MAKING A CHANGE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Remember\nhow we did the <i>git update-index</i> on file <b>hello</b>\nand then we changed <b>hello</b> afterward, and could\ncompare the new state of <b>hello</b> with the state we\nsaved in the index file?</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Further,\nremember how I said that <i>git write-tree</i> writes the\ncontents of the <b>index</b> file to the tree, and thus what\nwe just committed was in fact the <b>original</b> contents\nof the file <b>hello</b>, not the new ones. We did that on\npurpose, to show the difference between the index state, and\nthe state in the working tree, and how they don&rsquo;t have\nto match, even when we commit\nthings.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>As\nbefore, if we do <b>git diff-files -p</b> in our\ngit-tutorial project, we&rsquo;ll still see the same\ndifference we saw last time: the index file hasn&rsquo;t\nchanged by the act of committing anything. However, now that\nwe have committed something, we can also learn to use a new\ncommand: <i>git diff-index</i>.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Unlike\n<i>git diff-files</i>, which showed the difference between\nthe index file and the working tree, <i>git diff-index</i>\nshows the differences between a committed <b>tree</b> and\neither the index file or the working tree. In other words,\n<i>git diff-index</i> wants a tree to be diffed against, and\nbefore we did the commit, we couldn&rsquo;t do that, because\nwe didn&rsquo;t have anything to diff\nagainst.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>But\nnow we can do</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>$\ngit diff-index -p HEAD</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>(where\n<b>-p</b> has the same meaning as it did in <i>git\ndiff-files</i>), and it will show us the same difference,\nbut for a totally different reason. Now we&rsquo;re\ncomparing the working tree not against the index file, but\nagainst the tree we just wrote. It just so happens that\nthose two are obviously the same, so we get the same\nresult.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Again,\nbecause this is a common operation, you can also just\nshorthand it with</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>$\ngit diff HEAD</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>which\nends up doing the above for\nyou.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>In\nother words, <i>git diff-index</i> normally compares a tree\nagainst the working tree, but when given the <b>--cached</b>\nflag, it is told to instead compare against just the index\ncache contents, and ignore the current working tree state\nentirely. Since we just wrote the index file to HEAD, doing\n<b>git diff-index --cached -p HEAD</b> should thus return an\nempty set of differences, and that&rsquo;s exactly what it\ndoes.</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><b><big>Note</big></b>\n<i><br>\ngit diff-index</i> really always uses the index for its\ncomparisons, and saying that it compares a tree against the\nworking tree is thus not strictly accurate. In particular,\nthe list of files to compare (the &quot;meta-data&quot;)\n<b>always</b> comes from the index file, regardless of\nwhether the <b>--cached</b> flag is used or not. The\n<b>--cached</b> flag really only determines whether the file\n<b>contents</b> to be compared come from the working tree or\nnot.</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>This\nis not hard to understand, as soon as you realize that Git\nsimply never knows (or cares) about files that it is not\ntold about explicitly. Git will never go <b>looking</b> for\nfiles to compare, it expects you to tell it what the files\nare, and that&rsquo;s what the index is there\nfor.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>However,\nour next step is to commit the <b>change</b> we did, and\nagain, to understand what&rsquo;s going on, keep in mind the\ndifference between &quot;working tree contents&quot;,\n&quot;index file&quot; and &quot;committed tree&quot;. We\nhave changes in the working tree that we want to commit, and\nwe always have to work through the index file, so the first\nthing we need to do is to update the index\ncache:</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>$\ngit update-index hello</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>(note\nhow we didn&rsquo;t need the <b>--add</b> flag this time,\nsince Git knew about the file\nalready).</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Note\nwhat happens to the different <i>git diff-*</i> versions\nhere. After we&rsquo;ve updated <b>hello</b> in the index,\n<b>git diff-files -p</b> now shows no differences, but\n<b>git diff-index -p HEAD</b> still <b>does</b> show that\nthe current state is different from the state we committed.\nIn fact, now <i>git diff-index</i> shows the same difference\nwhether we use the <b>--cached</b> flag or not, since now\nthe index is coherent with the working\ntree.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Now,\nsince we&rsquo;ve updated <b>hello</b> in the index, we can\ncommit the new version. We could do it by writing the tree\nby hand again, and committing the tree (this time we&rsquo;d\nhave to use the <b>-p HEAD</b> flag to tell commit that the\nHEAD was the <b>parent</b> of the new commit, and that this\nwasn&rsquo;t an initial commit any more), but you&rsquo;ve\ndone that once already, so let&rsquo;s just use the helpful\nscript this time:</big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>$\ngit commit</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>which\nstarts an editor for you to write the commit message and\ntells you a bit about what you have\ndone.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>Write\nwhatever message you want, and all the lines that start with\n<i>#</i> will be pruned out, and the rest will be used as\nthe commit message for the change. If you decide you\ndon&rsquo;t want to commit anything after all at this point\n(you can continue to edit things and update the index), you\ncan just leave an empty message. Otherwise <b>git commit</b>\nwill commit the change for you.</big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big>You&rsquo;ve\nnow made your first real Git commit. And if you&rsquo;re\ninterested in looking at what <b>git commit</b> really does,\nfeel free to investigate: it&rsquo;s a few very simple shell\nscripts to generate the helpful (?) commit message headers,\nand a few one-liners that actually do the commit itself\n(<i>git commit</i>).</big></big></big></font></p>\n\n<h2>INSPECTING CHANGES\n<a name=\"INSPECTING CHANGES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big>While\ncreating changes is useful, it&rsquo;s even more useful if\nyou can tell later what changed. The most useful command for\nthis is another of the <i>diff</i> family, namely <i>git\ndiff-tree</i>.</big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><i>git\ndiff-tree</i> can be given two arbitrary trees, and it will\ntell you the differences between them. Perhaps even more\ncommonly, though, you can give it just a single commit\nobject, and it will figure out the parent of that commit\nitself, and show the difference directly. Thus, to get the\nsame diff that we&rsquo;ve already seen several times, we\ncan now do</big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big>$\ngit diff-tree -p HEAD</big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big>(again,\n<b>-p</b> means to show the difference as a human-readable\npatch), and it will show what the last commit (in\n<b>HEAD</b>) actually\nchanged.</big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><b><big>Note</big></b>\n<br>\nHere is an ASCII art by Jon Loeliger that illustrates how\nvarious <i>diff-*</i> commands compare\nthings.</big></big></big></big></font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big>diff-tree\n<br>\n+----+ <br>\n| | <br>\n| | <br>\nV V <br>\n+-----------+ <br>\n| Object DB | <br>\n| Backing | <br>\n| Store | <br>\n+-----------+ <br>\n^ ^ <br>\n| | <br>\n| | diff-index --cached <br>\n| | <br>\ndiff-index | V <br>\n| +-----------+ <br>\n| | Index | <br>\n| | &quot;cache&quot; | <br>\n| +-----------+ <br>\n| ^ <br>\n| | <br>\n| | diff-files <br>\n| | <br>\nV V <br>\n+-----------+ <br>\n| Working | <br>\n| Directory | <br>\n+-----------+</big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big>More\ninterestingly, you can also give <i>git diff-tree</i> the\n<b>--pretty</b> flag, which tells it to also show the commit\nmessage and author and date of the commit, and you can tell\nit to show a whole series of diffs. Alternatively, you can\ntell it to be &quot;silent&quot;, and not show the diffs at\nall, but just show the actual commit\nmessage.</big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big>In\nfact, together with the <i>git rev-list</i> program (which\ngenerates a list of revisions), <i>git diff-tree</i> ends up\nbeing a veritable fount of changes. You can emulate <b>git\nlog</b>, <b>git log -p</b>, etc. with a trivial script that\npipes the output of <b>git rev-list</b> to <b>git diff-tree\n--stdin</b>, which was exactly how early versions of <b>git\nlog</b> were implemented.</big></big></big></big></font></p>\n\n<h2>TAGGING A VERSION\n<a name=\"TAGGING A VERSION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>In\nGit, there are two kinds of tags, a &quot;light&quot; one,\nand an &quot;annotated\ntag&quot;.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>A\n&quot;light&quot; tag is technically nothing more than a\nbranch, except we put it in the <b>.git/refs/tags/</b>\nsubdirectory instead of calling it a <b>head</b>. So the\nsimplest form of tag involves nothing more\nthan</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit tag\nmy-first-tag</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>which\njust writes the current <b>HEAD</b> into the\n<b>.git/refs/tags/my-first-tag</b> file, after which point\nyou can then use this symbolic name for that particular\nstate. You can, for example,\ndo</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit diff\nmy-first-tag</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>to\ndiff your current state against that tag which at this point\nwill obviously be an empty diff, but if you continue to\ndevelop and commit stuff, you can use your tag as an\n&quot;anchor-point&quot; to see what has changed since you\ntagged it.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>An\n&quot;annotated tag&quot; is actually a real Git object, and\ncontains not only a pointer to the state you want to tag,\nbut also a small tag name and message, along with optionally\na PGP signature that says that yes, you really did that tag.\nYou create these annotated tags with either the <b>-a</b> or\n<b>-s</b> flag to <i>git\ntag</i>:</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit tag -s\n&lt;tagname&gt;</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>which\nwill sign the current <b>HEAD</b> (but you can also give it\nanother argument that specifies the thing to tag, e.g., you\ncould have tagged the current <b>mybranch</b> point by using\n<b>git tag &lt;tagname&gt;\nmybranch</b>).</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>You\nnormally only do signed tags for major releases or things\nlike that, while the light-weight tags are useful for any\nmarking you want to do &mdash; any time you decide that you\nwant to remember a certain point, just create a private tag\nfor it, and you have a nice symbolic name for the state at\nthat point.</big></big></big></big></big></font></p>\n\n<h2>COPYING REPOSITORIES\n<a name=\"COPYING REPOSITORIES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>Git\nrepositories are normally totally self-sufficient and\nrelocatable. Unlike CVS, for example, there is no separate\nnotion of &quot;repository&quot; and &quot;working\ntree&quot;. A Git repository normally <b>is</b> the working\ntree, with the local Git information hidden in the\n<b>.git</b> subdirectory. There is nothing else. What you\nsee is what you\ngot.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><b><big>Note</big></b>\n<br>\nYou can tell Git to split the Git internal information from\nthe directory that it tracks, but we&rsquo;ll ignore that\nfor now: it&rsquo;s not how normal projects work, and\nit&rsquo;s really only meant for special uses. So the mental\nmodel of &quot;the Git information is always tied directly\nto the working tree that it describes&quot; may not be\ntechnically 100% accurate, but it&rsquo;s a good model for\nall normal use.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>This\nhas two\nimplications:</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>&bull;\nif you grow bored with the tutorial repository you created\n(or you&rsquo;ve made a mistake and want to start all over),\nyou can just do\nsimple</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\nrm -rf git-tutorial</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>and\nit will be gone. There&rsquo;s no external repository, and\nthere&rsquo;s no history outside the project you\ncreated.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>&bull;\nif you want to move or duplicate a Git repository, you can\ndo so. There is <i>git clone</i> command, but if all you\nwant to do is just to create a copy of your repository (with\nall the full history that went along with it), you can do so\nwith a regular <b>cp -a git-tutorial\nnew-git-tutorial</b>.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>Note\nthat when you&rsquo;ve moved or copied a Git repository,\nyour Git index file (which caches various information,\nnotably some of the &quot;stat&quot; information for the\nfiles involved) will likely need to be refreshed. So after\nyou do a <b>cp -a</b> to create a new copy, you&rsquo;ll\nwant to do</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit update-index\n--refresh</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>in\nthe new repository to make sure that the index file is up to\ndate.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>Note\nthat the second point is true even across machines. You can\nduplicate a remote Git repository with <b>any</b> regular\ncopy mechanism, be it <i>scp</i>, <i>rsync</i> or\n<i>wget</i>.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>When\ncopying a remote repository, you&rsquo;ll want to at a\nminimum update the index cache when you do this, and\nespecially with other peoples' repositories you often want\nto make sure that the index cache is in some known state\n(you don&rsquo;t know <b>what</b> they&rsquo;ve done and not\nyet checked in), so usually you&rsquo;ll precede the <i>git\nupdate-index</i> with\na</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit read-tree --reset HEAD <br>\n$ git update-index\n--refresh</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>which\nwill force a total index re-build from the tree pointed to\nby <b>HEAD</b>. It resets the index contents to <b>HEAD</b>,\nand then the <i>git update-index</i> makes sure to match up\nall index entries with the checked-out files. If the\noriginal repository had uncommitted changes in its working\ntree, <b>git update-index --refresh</b> notices them and\ntells you they need to be\nupdated.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>The\nabove can also be written as\nsimply</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit reset</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>and\nin fact a lot of the common Git command combinations can be\nscripted with the <b>git xyz</b> interfaces. You can learn\nthings by just looking at what the various git scripts do.\nFor example, <b>git reset</b> used to be the above two lines\nimplemented in <i>git reset</i>, but some things like <i>git\nstatus</i> and <i>git commit</i> are slightly more complex\nscripts around the basic Git\ncommands.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>Many\n(most?) public remote repositories will not contain any of\nthe checked out files or even an index file, and will\n<b>only</b> contain the actual core Git files. Such a\nrepository usually doesn&rsquo;t even have the <b>.git</b>\nsubdirectory, but has all the Git files directly in the\nrepository.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>To\ncreate your own local live copy of such a &quot;raw&quot;\nGit repository, you&rsquo;d first create your own\nsubdirectory for the project, and then copy the raw\nrepository contents into the <b>.git</b> directory. For\nexample, to create your own copy of the Git repository,\nyou&rsquo;d do the\nfollowing</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\nmkdir my-git <br>\n$ cd my-git <br>\n$ rsync -rL rsync://rsync.kernel.org/pub/scm/git/git.git/\n.git</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>followed\nby</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit read-tree HEAD</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>to\npopulate the index. However, now you have populated the\nindex, and you have all the Git internal files, but you will\nnotice that you don&rsquo;t actually have any of the working\ntree files to work on. To get those, you&rsquo;d check them\nout with</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit checkout-index -u\n-a</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>where\nthe <b>-u</b> flag means that you want the checkout to keep\nthe index up to date (so that you don&rsquo;t have to\nrefresh it afterward), and the <b>-a</b> flag means\n&quot;check out all files&quot; (if you have a stale copy or\nan older version of a checked out tree you may also need to\nadd the <b>-f</b> flag first, to tell <i>git\ncheckout-index</i> to <b>force</b> overwriting of any old\nfiles).</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>Again,\nthis can all be simplified\nwith</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>$\ngit clone git://git.kernel.org/pub/scm/git/git.git/ my-git\n<br>\n$ cd my-git <br>\n$ git checkout</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>which\nwill end up doing all of the above for\nyou.</big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big>You\nhave now successfully copied somebody else&rsquo;s (mine)\nremote repository, and checked it\nout.</big></big></big></big></big></font></p>\n\n<h2>CREATING A NEW BRANCH\n<a name=\"CREATING A NEW BRANCH\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>Branches\nin Git are really nothing more than pointers into the Git\nobject database from within the <b>.git/refs/</b>\nsubdirectory, and as we already discussed, the <b>HEAD</b>\nbranch is nothing but a symlink to one of these object\npointers.</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>You\ncan at any time create a new branch by just picking an\narbitrary point in the project history, and just writing the\nSHA-1 name of that object into a file under\n<b>.git/refs/heads/</b>. You can use any filename you want\n(and indeed, subdirectories), but the convention is that the\n&quot;normal&quot; branch is called <b>master</b>.\nThat&rsquo;s just a convention, though, and nothing enforces\nit.</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>To\nshow that as an example, let&rsquo;s go back to the\ngit-tutorial repository we used earlier, and create a branch\nin it. You do that by simply just saying that you want to\ncheck out a new\nbranch:</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>$\ngit switch -c\nmybranch</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>will\ncreate a new branch based at the current <b>HEAD</b>\nposition, and switch to\nit.</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nIf you make the decision to start your new branch at some\nother point in the history than the current <b>HEAD</b>, you\ncan do so by just telling <i>git switch</i> what the base of\nthe checkout would be. In other words, if you have an\nearlier tag or branch, you&rsquo;d just\ndo</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>$\ngit switch -c mybranch\nearlier-commit</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>and\nit would create the new branch <b>mybranch</b> at the\nearlier commit, and check out the state at that\ntime.</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>You\ncan always just jump back to your original <b>master</b>\nbranch by\ndoing</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>$\ngit switch\nmaster</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>(or\nany other branch-name, for that matter) and if you forget\nwhich branch you happen to be on, a\nsimple</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>$\ncat .git/HEAD</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>will\ntell you where it&rsquo;s pointing. To get the list of\nbranches you have, you can\nsay</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>$\ngit branch</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>which\nused to be nothing more than a simple script around <b>ls\n.git/refs/heads</b>. There will be an asterisk in front of\nthe branch you are currently\non.</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>Sometimes\nyou may wish to create a new branch <i>without</i> actually\nchecking it out and switching to it. If so, just use the\ncommand</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>$\ngit branch &lt;branchname&gt;\n[startingpoint]</big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big>which\nwill simply <i>create</i> the branch, but will not do\nanything further. You can then later &mdash; once you decide\nthat you want to actually develop on that branch &mdash;\nswitch to that branch with a regular <i>git switch</i> with\nthe branchname as the\nargument.</big></big></big></big></big></big></font></p>\n\n<h2>MERGING TWO BRANCHES\n<a name=\"MERGING TWO BRANCHES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>One\nof the ideas of having a branch is that you do some\n(possibly experimental) work in it, and eventually merge it\nback to the main branch. So assuming you created the above\n<b>mybranch</b> that started out being the same as the\noriginal <b>master</b> branch, let&rsquo;s make sure\nwe&rsquo;re in that branch, and do some work\nthere.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngit switch mybranch <br>\n$ echo &quot;Work, work, work&quot; &gt;&gt;hello <br>\n$ git commit -m &quot;Some work.&quot; -i\nhello</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Here,\nwe just added another line to <b>hello</b>, and we used a\nshorthand for doing both <b>git update-index hello</b> and\n<b>git commit</b> by just giving the filename directly to\n<b>git commit</b>, with an <b>-i</b> flag (it tells Git to\n<i>include</i> that file in addition to what you have done\nto the index file so far when making the commit). The\n<b>-m</b> flag is to give the commit log message from the\ncommand\nline.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Now,\nto make it a bit more interesting, let&rsquo;s assume that\nsomebody else does some work in the original branch, and\nsimulate that by going back to the master branch, and\nediting the same file differently\nthere:</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngit switch\nmaster</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Here,\ntake a moment to look at the contents of <b>hello</b>, and\nnotice how they don&rsquo;t contain the work we just did in\n<b>mybranch</b> &mdash; because that work hasn&rsquo;t\nhappened in the <b>master</b> branch at all. Then\ndo</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\necho &quot;Play, play, play&quot; &gt;&gt;hello <br>\n$ echo &quot;Lots of fun&quot; &gt;&gt;example <br>\n$ git commit -m &quot;Some fun.&quot; -i hello\nexample</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>since\nthe master branch is obviously in a much better\nmood.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Now,\nyou&rsquo;ve got two branches, and you decide that you want\nto merge the work done. Before we do that, let&rsquo;s\nintroduce a cool graphical tool that helps you view\nwhat&rsquo;s going\non:</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngitk\n--all</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>will\nshow you graphically both of your branches (that&rsquo;s\nwhat the <b>--all</b> means: normally it will just show you\nyour current <b>HEAD</b>) and their histories. You can also\nsee exactly how they came to be from a common\nsource.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Anyway,\nlet&rsquo;s exit <i>gitk</i> (<b>^Q</b> or the File menu),\nand decide that we want to merge the work we did on the\n<b>mybranch</b> branch into the <b>master</b> branch (which\nis currently our <b>HEAD</b> too). To do that, there&rsquo;s\na nice script called <i>git merge</i>, which wants to know\nwhich branches you want to resolve and what the merge is all\nabout:</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngit merge -m &quot;Merge work in mybranch&quot;\nmybranch</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>where\nthe first argument is going to be used as the commit message\nif the merge can be resolved\nautomatically.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Now,\nin this case we&rsquo;ve intentionally created a situation\nwhere the merge will need to be fixed up by hand, though, so\nGit will do as much of it as it can automatically (which in\nthis case is just merge the <b>example</b> file, which had\nno differences in the <b>mybranch</b> branch), and\nsay:</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Auto-merging\nhello <br>\nCONFLICT (content): Merge conflict in hello <br>\nAutomatic merge failed; fix conflicts and then commit the\nresult.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>It\ntells you that it did an &quot;Automatic merge&quot;, which\nfailed due to conflicts in\n<b>hello</b>.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Not\nto worry. It left the (trivial) conflict in <b>hello</b> in\nthe same form you should already be well used to if\nyou&rsquo;ve ever used CVS, so let&rsquo;s just open\n<b>hello</b> in our editor (whatever that may be), and fix\nit up somehow. I&rsquo;d suggest just making it so that\n<b>hello</b> contains all four\nlines:</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Hello\nWorld <br>\nIt's a new day for git <br>\nPlay, play, play <br>\nWork, work,\nwork</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>and\nonce you&rsquo;re happy with your manual merge, just do\na</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngit commit -i\nhello</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>which\nwill very loudly warn you that you&rsquo;re now committing a\nmerge (which is correct, so never mind), and you can write a\nsmall merge message about your adventures in <i>git\nmerge</i>-land.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>After\nyou&rsquo;re done, start up <b>gitk --all</b> to see\ngraphically what the history looks like. Notice that\n<b>mybranch</b> still exists, and you can switch to it, and\ncontinue to work with it if you want to. The <b>mybranch</b>\nbranch will not contain the merge, but next time you merge\nit from the <b>master</b> branch, Git will know how you\nmerged it, so you&rsquo;ll not have to do <i>that</i> merge\nagain.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Another\nuseful tool, especially if you do not always work in\nX-Window environment, is <b>git\nshow-branch</b>.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngit show-branch --topo-order --more=1 master mybranch <br>\n* [master] Merge work in mybranch <br>\n! [mybranch] Some work. <br>\n-- <br>\n- [master] Merge work in mybranch <br>\n*+ [mybranch] Some work. <br>\n* [master^] Some\nfun.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>The\nfirst two lines indicate that it is showing the two branches\nwith the titles of their top-of-the-tree commits, you are\ncurrently on <b>master</b> branch (notice the asterisk\n<b>*</b> character), and the first column for the later\noutput lines is used to show commits contained in the\n<b>master</b> branch, and the second column for the\n<b>mybranch</b> branch. Three commits are shown along with\ntheir titles. All of them have non blank characters in the\nfirst column (<b>*</b> shows an ordinary commit on the\ncurrent branch, <b>-</b> is a merge commit), which means\nthey are now part of the <b>master</b> branch. Only the\n&quot;Some work&quot; commit has the plus <b>+</b> character\nin the second column, because <b>mybranch</b> has not been\nmerged to incorporate these commits from the master branch.\nThe string inside brackets before the commit log message is\na short name you can use to name the commit. In the above\nexample, <i>master</i> and <i>mybranch</i> are branch heads.\n<i>master^</i> is the first parent of <i>master</i> branch\nhead. Please see <a href=\"https://man.page/7/gitrevisions\">gitrevisions(7)</a> if you want to see\nmore complex\ncases.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nWithout the <i>--more=1</i> option, <i>git show-branch</i>\nwould not output the <i>[master^]</i> commit, as\n<i>[mybranch]</i> commit is a common ancestor of both\n<i>master</i> and <i>mybranch</i> tips. Please see\n<a href=\"https://man.page/1/git-show-branch\">git-show-branch(1)</a> for\ndetails.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nIf there were more commits on the <i>master</i> branch after\nthe merge, the merge commit itself would not be shown by\n<i>git show-branch</i> by default. You would need to provide\n<b>--sparse</b> option to make the merge commit visible in\nthis\ncase.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Now,\nlet&rsquo;s pretend you are the one who did all the work in\n<b>mybranch</b>, and the fruit of your hard work has finally\nbeen merged to the <b>master</b> branch. Let&rsquo;s go back\nto <b>mybranch</b>, and run <i>git merge</i> to get the\n&quot;upstream changes&quot; back to your\nbranch.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngit switch mybranch <br>\n$ git merge -m &quot;Merge upstream changes.&quot;\nmaster</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>This\noutputs something like this (the actual commit object names\nwould be\ndifferent)</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Updating\nfrom ae3a2da... to a80b4aa.... <br>\nFast-forward (no commit created; -m option ignored) <br>\nexample | 1 + <br>\nhello | 1 + <br>\n2 files changed, 2\ninsertions(+)</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>Because\nyour branch did not contain anything more than what had\nalready been merged into the <b>master</b> branch, the merge\noperation did not actually do a merge. Instead, it just\nupdated the top of the tree of your branch to that of the\n<b>master</b> branch. This is often called\n<i>fast-forward</i>\nmerge.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>You\ncan run <b>gitk --all</b> again to see how the commit\nancestry looks like, or run <i>show-branch</i>, which tells\nyou\nthis.</big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big>$\ngit show-branch master mybranch <br>\n! [master] Merge work in mybranch <br>\n* [mybranch] Merge work in mybranch <br>\n-- <br>\n-- [master] Merge work in\nmybranch</big></big></big></big></big></big></big></font></p>\n\n<h2>MERGING EXTERNAL WORK\n<a name=\"MERGING EXTERNAL WORK\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>It&rsquo;s\nusually much more common that you merge with somebody else\nthan merging with your own branches, so it&rsquo;s worth\npointing out that Git makes that very easy too, and in fact,\nit&rsquo;s not that different from doing a <i>git merge</i>.\nIn fact, a remote merge ends up being nothing more than\n&quot;fetch the work from a remote repository into a\ntemporary tag&quot; followed by a <i>git\nmerge</i>.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>Fetching\nfrom a remote repository is done by, unsurprisingly, <i>git\nfetch</i>:</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>$\ngit fetch\n&lt;remote-repository&gt;</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>One\nof the following transports can be used to name the\nrepository to download\nfrom:</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>SSH</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><b>remote.machine:/path/to/repo.git/</b>\nor</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><b>ssh://remote.machine/path/to/repo.git/</b></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>This\ntransport can be used for both uploading and downloading,\nand requires you to have a log-in privilege over <b>ssh</b>\nto the remote machine. It finds out the set of objects the\nother side lacks by exchanging the head commits both ends\nhave and transfers (close to) minimum set of objects. It is\nby far the most efficient way to exchange Git objects\nbetween\nrepositories.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>Local\ndirectory</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><b>/path/to/repo.git/</b></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>This\ntransport is the same as SSH transport but uses <i>sh</i> to\nrun both ends on the local machine instead of running other\nend on the remote machine via\n<i>ssh</i>.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>Git\nNative</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><b>git://remote.machine/path/to/repo.git/</b></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>This\ntransport was designed for anonymous downloading. Like SSH\ntransport, it finds out the set of objects the downstream\nside lacks and transfers (close to) minimum set of\nobjects.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>HTTP(S)</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><b>http://remote.machine/path/to/repo.git/</b></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>Downloader\nfrom http and https URL first obtains the topmost commit\nobject name from the remote site by looking at the specified\nrefname under <b>repo.git/refs/</b> directory, and then\ntries to obtain the commit object by downloading from\n<b>repo.git/objects/xx/xxx...</b> using the object name of\nthat commit object. Then it reads the commit object to find\nout its parent commits and the associate tree object; it\nrepeats this process until it gets all the necessary\nobjects. Because of this behavior, they are sometimes also\ncalled <i>commit\nwalkers</i>.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>The\n<i>commit walkers</i> are sometimes also called <i>dumb\ntransports</i>, because they do not require any Git aware\nsmart server like Git Native transport does. Any stock HTTP\nserver that does not even support directory index would\nsuffice. But you must prepare your repository with <i>git\nupdate-server-info</i> to help dumb transport\ndownloaders.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>Once\nyou fetch from the remote repository, you <b>merge</b> that\nwith your current\nbranch.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>However\n&mdash; it&rsquo;s such a common thing to <b>fetch</b> and\nthen immediately <b>merge</b>, that it&rsquo;s called <b>git\npull</b>, and you can simply\ndo</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>$\ngit pull\n&lt;remote-repository&gt;</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>and\noptionally give a branch-name for the remote end as a second\nargument.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nYou could do without using any branches at all, by keeping\nas many local repositories as you would like to have\nbranches, and merging between them with <i>git pull</i>,\njust like you merge between branches. The advantage of this\napproach is that it lets you keep a set of files for each\n<b>branch</b> checked out and you may find it easier to\nswitch back and forth if you juggle multiple lines of\ndevelopment simultaneously. Of course, you will pay the\nprice of more disk usage to hold multiple working trees, but\ndisk space is cheap these\ndays.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>It\nis likely that you will be pulling from the same remote\nrepository from time to time. As a short hand, you can store\nthe remote repository URL in the local repository&rsquo;s\nconfig file like\nthis:</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>$\ngit config remote.linus.url\nhttp://www.kernel.org/pub/scm/git/git.git/</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>and\nuse the &quot;linus&quot; keyword with <i>git pull</i>\ninstead of the full\nURL.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>Examples.</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>1.\n<b>git pull\nlinus</b></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>2.\n<b>git pull linus tag\nv0.99.1</b></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>the\nabove are equivalent\nto:</big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>1.\n<b>git pull http://www.kernel.org/pub/scm/git/git.git/\nHEAD</b></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big>2.\n<b>git pull http://www.kernel.org/pub/scm/git/git.git/ tag\nv0.99.1</b></big></big></big></big></big></big></big></big></font></p>\n\n<h2>HOW DOES THE MERGE WORK?\n<a name=\"HOW DOES THE MERGE WORK?\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>We\nsaid this tutorial shows what plumbing does to help you cope\nwith the porcelain that isn&rsquo;t flushing, but we so far\ndid not talk about how the merge really works. If you are\nfollowing this tutorial the first time, I&rsquo;d suggest to\nskip to &quot;Publishing your work&quot; section and come\nback here\nlater.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>OK,\nstill with me? To give us an example to look at, let&rsquo;s\ngo back to the earlier repository with &quot;hello&quot; and\n&quot;example&quot; file, and bring ourselves back to the\npre-merge\nstate:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit show-branch --more=2 master mybranch <br>\n! [master] Merge work in mybranch <br>\n* [mybranch] Merge work in mybranch <br>\n-- <br>\n-- [master] Merge work in mybranch <br>\n+* [master^2] Some work. <br>\n+* [master^] Some\nfun.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>Remember,\nbefore running <i>git merge</i>, our <b>master</b> head was\nat &quot;Some fun.&quot; commit, while our <b>mybranch</b>\nhead was at &quot;Some work.&quot;\ncommit.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit switch -C mybranch master^2 <br>\n$ git switch master <br>\n$ git reset --hard\nmaster^</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>After\nrewinding, the commit structure should look like\nthis:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit show-branch <br>\n* [master] Some fun. <br>\n! [mybranch] Some work. <br>\n-- <br>\n* [master] Some fun. <br>\n+ [mybranch] Some work. <br>\n*+ [master^] Initial\ncommit</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>Now\nwe are ready to experiment with the merge by\nhand.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><b>git\nmerge</b> command, when merging two branches, uses 3-way\nmerge algorithm. First, it finds the common ancestor between\nthem. The command it uses is <i>git\nmerge-base</i>:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\nmb=$(git merge-base HEAD\nmybranch)</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>The\ncommand writes the commit object name of the common ancestor\nto the standard output, so we captured its output to a\nvariable, because we will be using it in the next step. By\nthe way, the common ancestor commit is the &quot;Initial\ncommit&quot; commit in this case. You can tell it\nby:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit name-rev --name-only --tags $mb <br>\n\nmy-first-tag</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>After\nfinding out a common ancestor commit, the second step is\nthis:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit read-tree -m -u $mb HEAD\nmybranch</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>This\nis the same <i>git read-tree</i> command we have already\nseen, but it takes three trees, unlike previous examples.\nThis reads the contents of each tree into different\n<i>stage</i> in the index file (the first tree goes to stage\n1, the second to stage 2, etc.). After reading three trees\ninto three stages, the paths that are the same in all three\nstages are <i>collapsed</i> into stage 0. Also paths that\nare the same in two of three stages are collapsed into stage\n0, taking the SHA-1 from either stage 2 or stage 3,\nwhichever is different from stage 1 (i.e. only one side\nchanged from the common\nancestor).</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>After\n<i>collapsing</i> operation, paths that are different in\nthree trees are left in non-zero stages. At this point, you\ncan inspect the index file with this\ncommand:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit ls-files --stage <br>\n100644 7f8b141b65fdcee47321e399a2598a235a032422 0 example\n<br>\n100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1 hello <br>\n100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2 hello <br>\n100644 cc44c73eb783565da5831b4d820c962954019b69 3\nhello</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>In\nour example of only two files, we did not have unchanged\nfiles so only <i>example</i> resulted in collapsing. But in\nreal-life large projects, when only a small number of files\nchange in one commit, this <i>collapsing</i> tends to\ntrivially merge most of the paths fairly quickly, leaving\nonly a handful of real changes in non-zero\nstages.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>To\nlook at only non-zero stages, use <b>--unmerged</b>\nflag:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit ls-files --unmerged <br>\n100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1 hello <br>\n100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2 hello <br>\n100644 cc44c73eb783565da5831b4d820c962954019b69 3\nhello</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>The\nnext step of merging is to merge these three versions of the\nfile, using 3-way merge. This is done by giving <i>git\nmerge-one-file</i> command as one of the arguments to <i>git\nmerge-index</i>\ncommand:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit merge-index git-merge-one-file hello <br>\nAuto-merging hello <br>\nERROR: Merge conflict in hello <br>\nfatal: merge program\nfailed</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><i>git\nmerge-one-file</i> script is called with parameters to\ndescribe those three versions, and is responsible to leave\nthe merge results in the working tree. It is a fairly\nstraightforward shell script, and eventually calls\n<i>merge</i> program from RCS suite to perform a file-level\n3-way merge. In this case, <i>merge</i> detects conflicts,\nand the merge result with conflict marks is left in the\nworking tree.. This can be seen if you run <b>ls-files\n--stage</b> again at this\npoint:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit ls-files --stage <br>\n100644 7f8b141b65fdcee47321e399a2598a235a032422 0 example\n<br>\n100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1 hello <br>\n100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2 hello <br>\n100644 cc44c73eb783565da5831b4d820c962954019b69 3\nhello</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>This\nis the state of the index file and the working file after\n<i>git merge</i> returns control back to you, leaving the\nconflicting merge for you to resolve. Notice that the path\n<b>hello</b> is still unmerged, and what you see with <i>git\ndiff</i> at this point is differences since stage 2 (i.e.\nyour\nversion).</big></big></big></big></big></big></big></big></big></font></p>\n\n<h2>PUBLISHING YOUR WORK\n<a name=\"PUBLISHING YOUR WORK\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>So,\nwe can use somebody else&rsquo;s work from a remote\nrepository, but how can <b>you</b> prepare a repository to\nlet other people pull from\nit?</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>You\ndo your real work in your working tree that has your primary\nrepository hanging under it as its <b>.git</b> subdirectory.\nYou <b>could</b> make that repository accessible remotely\nand ask people to pull from it, but in practice that is not\nthe way things are usually done. A recommended way is to\nhave a public repository, make it reachable by other people,\nand when the changes you made in your primary working tree\nare in good shape, update the public repository from it.\nThis is often called\n<i>pushing</i>.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nThis public repository could further be mirrored, and that\nis how Git repositories at <b>kernel.org</b> are\nmanaged.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>Publishing\nthe changes from your local (private) repository to your\nremote (public) repository requires a write privilege on the\nremote machine. You need to have an SSH account there to run\na single command,\n<i>git-receive-pack</i>.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>First,\nyou need to create an empty repository on the remote machine\nthat will house your public repository. This empty\nrepository will be populated and be kept up to date by\npushing into it later. Obviously, this repository creation\nneeds to be done only\nonce.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>\n<i><br>\ngit push</i> uses a pair of commands, <i>git send-pack</i>\non your local machine, and <i>git-receive-pack</i> on the\nremote machine. The communication between the two over the\nnetwork internally uses an SSH\nconnection.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>Your\nprivate repository&rsquo;s Git directory is usually\n<b>.git</b>, but your public repository is often named after\nthe project name, i.e. <b>&lt;project&gt;.git</b>.\nLet&rsquo;s create such a public repository for project\n<b>my-git</b>. After logging into the remote machine, create\nan empty\ndirectory:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\nmkdir\nmy-git.git</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>Then,\nmake that directory into a Git repository by running <i>git\ninit</i>, but this time, since its name is not the usual\n<b>.git</b>, we do things slightly\ndifferently:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\nGIT_DIR=my-git.git git\ninit</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>Make\nsure this directory is available for others you want your\nchanges to be pulled via the transport of your choice. Also\nyou need to make sure that you have the\n<i>git-receive-pack</i> program on the\n<b>$PATH</b>.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nMany installations of sshd do not invoke your shell as the\nlogin shell when you directly run programs; what this means\nis that if your login shell is <i>bash</i>, only\n<b>.bashrc</b> is read and not <b>.bash_profile</b>. As a\nworkaround, make sure <b>.bashrc</b> sets up <b>$PATH</b> so\nthat you can run <i>git-receive-pack</i>\nprogram.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nIf you plan to publish this repository to be accessed over\nhttp, you should do <b>mv\nmy-git.git/hooks/post-update.sample\nmy-git.git/hooks/post-update</b> at this point. This makes\nsure that every time you push into this repository, <b>git\nupdate-server-info</b> is\nrun.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>Your\n&quot;public repository&quot; is now ready to accept your\nchanges. Come back to the machine you have your private\nrepository. From there, run this\ncommand:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit push &lt;public-host&gt;:/path/to/my-git.git\nmaster</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>This\nsynchronizes your public repository to match the named\nbranch head (i.e. <b>master</b> in this case) and objects\nreachable from them in your current\nrepository.</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>As\na real example, this is how I update my public Git\nrepository. Kernel.org mirror network takes care of the\npropagation to other publicly visible\nmachines:</big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big>$\ngit push\nmaster.kernel.org:/pub/scm/git/git.git/</big></big></big></big></big></big></big></big></big></font></p>\n\n<h2>PACKING YOUR REPOSITORY\n<a name=\"PACKING YOUR REPOSITORY\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>Earlier,\nwe saw that one file under <b>.git/objects/??/</b> directory\nis stored for each Git object you create. This\nrepresentation is efficient to create atomically and safely,\nbut not so convenient to transport over the network. Since\nGit objects are immutable once they are created, there is a\nway to optimize the storage by &quot;packing them\ntogether&quot;. The\ncommand</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>$\ngit\nrepack</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>will\ndo it for you. If you followed the tutorial examples, you\nwould have accumulated about 17 objects in\n<b>.git/objects/??/</b> directories by now. <i>git\nrepack</i> tells you how many objects it packed, and stores\nthe packed file in the <b>.git/objects/pack</b>\ndirectory.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>\n<br>\nYou will see two files, <b>pack-*.pack</b> and\n<b>pack-*.idx</b>, in <b>.git/objects/pack</b> directory.\nThey are closely related to each other, and if you ever copy\nthem by hand to a different repository for whatever reason,\nyou should make sure you copy them together. The former\nholds all the data from the objects in the pack, and the\nlatter holds the index for random\naccess.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>If\nyou are paranoid, running <i>git verify-pack</i> command\nwould detect if you have a corrupt pack, but do not worry\ntoo much. Our programs are always perfect\n;-).</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>Once\nyou have packed objects, you do not need to leave the\nunpacked objects that are contained in the pack file\nanymore.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>$\ngit\nprune-packed</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>would\nremove them for\nyou.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>You\ncan try running <b>find .git/objects -type f</b> before and\nafter you run <b>git prune-packed</b> if you are curious.\nAlso <b>git count-objects</b> would tell you how many\nunpacked objects are in your repository and how much space\nthey are\nconsuming.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big><b><big>Note</big>\n<br>\ngit pull</b> is slightly cumbersome for HTTP transport, as a\npacked repository may contain relatively few objects in a\nrelatively large pack. If you expect many HTTP pulls from\nyour public repository you might want to repack &amp; prune\noften, or\nnever.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>If\nyou run <b>git repack</b> again at this point, it will say\n&quot;Nothing new to pack.&quot;. Once you continue your\ndevelopment and accumulate the changes, running <b>git\nrepack</b> again will create a new pack, that contains\nobjects created since you packed your repository the last\ntime. We recommend that you pack your project soon after the\ninitial import (unless you are starting your project from\nscratch), and then run <b>git repack</b> every once in a\nwhile, depending on how active your project\nis.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big>When\na repository is synchronized via <b>git push</b> and <b>git\npull</b> objects packed in the source repository are usually\nstored unpacked in the destination. While this allows you to\nuse different packing strategies on both ends, it also means\nyou may need to repack both repositories every once in a\nwhile.</big></big></big></big></big></big></big></big></big></big></font></p>\n\n<h2>WORKING WITH OTHERS\n<a name=\"WORKING WITH OTHERS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big><big><big><big><big><big><big><big><big><big><big>Although\nGit is a truly distributed system, it is often convenient to\norganize your project with an informal hierarchy of\ndevelopers. Linux kernel development is run this way. There\nis a nice illustration (page 17, &quot;Merges to\nMainline&quot;)\nin</big></big></big></big></big></big></big></big></big></big></big></font>\n<big><big><big><big><big><big><big><big><big><big><big><b><font color=\"#0000FF\">Randy\nDunlap&rsquo;s presentation</font></b></big>\n<font color=\"#000000\">[2]\n<big>.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>It\nshould be stressed that this hierarchy is purely\n<b>informal</b>. There is nothing fundamental in Git that\nenforces the &quot;chain of patch flow&quot; this hierarchy\nimplies. You do not have to pull from only one remote\nrepository.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>A\nrecommended workflow for a &quot;project lead&quot; goes\nlike\nthis:</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>1.\nPrepare your primary repository on your local machine. Your\nwork is done\nthere.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>2.\nPrepare a public repository accessible to\nothers.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>If\nother people are pulling from your repository over dumb\ntransport protocols (HTTP), you need to keep this repository\n<i>dumb transport friendly</i>. After <b>git init</b>,\n<b>$GIT_DIR/hooks/post-update.sample</b> copied from the\nstandard templates would contain a call to <i>git\nupdate-server-info</i> but you need to manually enable the\nhook with <b>mv post-update.sample post-update</b>. This\nmakes sure <i>git update-server-info</i> keeps the necessary\nfiles up to\ndate.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>3.\nPush into the public repository from your primary\nrepository.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>4.\n<i>git repack</i> the public repository. This establishes a\nbig pack that contains the initial set of objects as the\nbaseline, and possibly <i>git prune</i> if the transport\nused for pulling from your repository supports packed\nrepositories.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>5.\nKeep working in your primary repository. Your changes\ninclude modifications of your own, patches you receive via\ne-mails, and merges resulting from pulling the\n&quot;public&quot; repositories of your &quot;subsystem\nmaintainers&quot;.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>You\ncan repack this private repository whenever you feel\nlike.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>6.\nPush your changes to the public repository, and announce it\nto the\npublic.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>7.\nEvery once in a while, <i>git repack</i> the public\nrepository. Go back to step 5. and continue\nworking.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>A\nrecommended work cycle for a &quot;subsystem\nmaintainer&quot; who works on that project and has an own\n&quot;public repository&quot; goes like\nthis:</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>1.\nPrepare your work repository, by running <i>git clone</i> on\nthe public repository of the &quot;project lead&quot;. The\nURL used for the initial cloning is stored in the\nremote.origin.url configuration\nvariable.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>2.\nPrepare a public repository accessible to others, just like\nthe &quot;project lead&quot; person\ndoes.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>3.\nCopy over the packed files from &quot;project lead&quot;\npublic repository to your public repository, unless the\n&quot;project lead&quot; repository lives on the same\nmachine as yours. In the latter case, you can use\n<b>objects/info/alternates</b> file to point at the\nrepository you are borrowing\nfrom.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>4.\nPush into the public repository from your primary\nrepository. Run <i>git repack</i>, and possibly <i>git\nprune</i> if the transport used for pulling from your\nrepository supports packed\nrepositories.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>5.\nKeep working in your primary repository. Your changes\ninclude modifications of your own, patches you receive via\ne-mails, and merges resulting from pulling the\n&quot;public&quot; repositories of your &quot;project\nlead&quot; and possibly your &quot;sub-subsystem\nmaintainers&quot;.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>You\ncan repack this private repository whenever you feel\nlike.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>6.\nPush your changes to your public repository, and ask your\n&quot;project lead&quot; and possibly your\n&quot;sub-subsystem maintainers&quot; to pull from\nit.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>7.\nEvery once in a while, <i>git repack</i> the public\nrepository. Go back to step 5. and continue\nworking.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>A\nrecommended work cycle for an &quot;individual\ndeveloper&quot; who does not have a &quot;public&quot;\nrepository is somewhat different. It goes like\nthis:</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>1.\nPrepare your work repository, by <i>git clone</i> the public\nrepository of the &quot;project lead&quot; (or a\n&quot;subsystem maintainer&quot;, if you work on a\nsubsystem). The URL used for the initial cloning is stored\nin the remote.origin.url configuration\nvariable.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>2.\nDo your work in your repository on <i>master</i>\nbranch.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>3.\nRun <b>git fetch origin</b> from the public repository of\nyour upstream every once in a while. This does only the\nfirst half of <b>git pull</b> but does not merge. The head\nof the public repository is stored in\n<b>.git/refs/remotes/origin/master</b>.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>4.\nUse <b>git cherry origin</b> to see which ones of your\npatches were accepted, and/or use <b>git rebase origin</b>\nto port your unmerged changes forward to the updated\nupstream.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>5.\nUse <b>git format-patch origin</b> to prepare patches for\ne-mail submission to your upstream and send it out. Go back\nto step 2. and\ncontinue.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n<h2>WORKING WITH OTHERS, SHARED REPOSITORY STYLE\n<a name=\"WORKING WITH OTHERS, SHARED REPOSITORY STYLE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>If\nyou are coming from a CVS background, the style of\ncooperation suggested in the previous section may be new to\nyou. You do not have to worry. Git supports the &quot;shared\npublic repository&quot; style of cooperation you are\nprobably more familiar with as\nwell.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>See\n<a href=\"https://man.page/7/gitcvs-migration\">gitcvs-migration(7)</a> for the\ndetails.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n<h2>BUNDLING YOUR WORK TOGETHER\n<a name=\"BUNDLING YOUR WORK TOGETHER\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>It\nis likely that you will be working on more than one thing at\na time. It is easy to manage those more-or-less independent\ntasks using branches with\nGit.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>We\nhave already seen how branches work previously, with\n&quot;fun and work&quot; example using two branches. The\nidea is the same if there are more than two branches.\nLet&rsquo;s say you started out from &quot;master&quot;\nhead, and have some new code in the &quot;master&quot;\nbranch, and two independent fixes in the\n&quot;commit-fix&quot; and &quot;diff-fix&quot;\nbranches:</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>$\ngit show-branch <br>\n! [commit-fix] Fix commit message normalization. <br>\n! [diff-fix] Fix rename detection. <br>\n* [master] Release candidate #1 <br>\n--- <br>\n+ [diff-fix] Fix rename detection. <br>\n+ [diff-fix~1] Better common substring algorithm. <br>\n+ [commit-fix] Fix commit message normalization. <br>\n* [master] Release candidate #1 <br>\n++* [diff-fix~2] Pretty-print\nmessages.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>Both\nfixes are tested well, and at this point, you want to merge\nin both of them. You could merge in <i>diff-fix</i> first\nand then <i>commit-fix</i> next, like\nthis:</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>$\ngit merge -m &quot;Merge fix in diff-fix&quot; diff-fix <br>\n$ git merge -m &quot;Merge fix in commit-fix&quot;\ncommit-fix</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>Which\nwould result\nin:</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>$\ngit show-branch <br>\n! [commit-fix] Fix commit message normalization. <br>\n! [diff-fix] Fix rename detection. <br>\n* [master] Merge fix in commit-fix <br>\n--- <br>\n- [master] Merge fix in commit-fix <br>\n+ * [commit-fix] Fix commit message normalization. <br>\n- [master~1] Merge fix in diff-fix <br>\n+* [diff-fix] Fix rename detection. <br>\n+* [diff-fix~1] Better common substring algorithm. <br>\n* [master~2] Release candidate #1 <br>\n++* [master~3] Pretty-print\nmessages.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>However,\nthere is no particular reason to merge in one branch first\nand the other next, when what you have are a set of truly\nindependent changes (if the order mattered, then they are\nnot independent by definition). You could instead merge\nthose two branches into the current branch at once. First\nlet&rsquo;s undo what we just did and start over. We would\nwant to get the master branch before these two merges by\nresetting it to\n<i>master~2</i>:</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>$\ngit reset --hard\nmaster~2</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>You\ncan make sure <b>git show-branch</b> matches the state\nbefore those two <i>git merge</i> you just did. Then,\ninstead of running two <i>git merge</i> commands in a row,\nyou would merge these two branch heads (this is known as\n<i>making an\nOctopus</i>):</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>$\ngit merge commit-fix diff-fix <br>\n$ git show-branch <br>\n! [commit-fix] Fix commit message normalization. <br>\n! [diff-fix] Fix rename detection. <br>\n* [master] Octopus merge of branches 'diff-fix' and\n'commit-fix' <br>\n--- <br>\n- [master] Octopus merge of branches 'diff-fix' and\n'commit-fix' <br>\n+ * [commit-fix] Fix commit message normalization. <br>\n+* [diff-fix] Fix rename detection. <br>\n+* [diff-fix~1] Better common substring algorithm. <br>\n* [master~1] Release candidate #1 <br>\n++* [master~2] Pretty-print\nmessages.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>Note\nthat you should not do Octopus just because you can. An\noctopus is a valid thing to do and often makes it easier to\nview the commit history if you are merging more than two\nindependent changes at the same time. However, if you have\nmerge conflicts with any of the branches you are merging in\nand need to hand resolve, that is an indication that the\ndevelopment happened in those branches were not independent\nafter all, and you should merge two at a time, documenting\nhow you resolved the conflicts, and the reason why you\npreferred changes made in one side over the other. Otherwise\nit would make the project history harder to follow, not\neasier.</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big><a href=\"https://man.page/7/gittutorial\">gittutorial(7)</a>,\n<a href=\"https://man.page/7/gittutorial-2\">gittutorial-2(7)</a>, <a href=\"https://man.page/7/gitcvs-migration\">gitcvs-migration(7)</a>,\n<a href=\"https://man.page/1/git-help\">git-help(1)</a>, <a href=\"https://man.page/7/giteveryday\">giteveryday(7)</a>,</big></font>\n<big><b><font color=\"#0000FF\">The Git User&rsquo;s\nManual</font></b></big>\n<font color=\"#000000\">[1]</font></big></big></big></big></big></big></big></big></big></big></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>Part\nof the <a href=\"https://man.page/1/git\">git(1)</a>\nsuite</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>1.</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>\n<td width=\"2%\"></td>\n<td width=\"29%\">\n\n\n\n<p style=\"margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>the\nGit User\nManual</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>\n<td width=\"54%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>file:///usr/share/doc/git/html/user-manual.html</big></font></big></big></big></big></big></big></big></big></big></big></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>2.</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>\n<td width=\"2%\"></td>\n<td width=\"41%\">\n\n\n\n<p style=\"margin-top: 1em\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>Randy\nDunlap&rsquo;s\npresentation</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>\n<td width=\"42%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><big><big><big><big><big><big><big><big><big><big><font color=\"#000000\"><big>https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf</big></font></big></big></big></big></big></big></big></big></big></big></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CREATING A GIT REPOSITORY\">CREATING A GIT REPOSITORY</a>","<a href=\"#POPULATING A GIT REPOSITORY\">POPULATING A GIT REPOSITORY</a>","<a href=\"#COMMITTING GIT STATE\">COMMITTING GIT STATE</a>","<a href=\"#MAKING A CHANGE\">MAKING A CHANGE</a>","<a href=\"#INSPECTING CHANGES\">INSPECTING CHANGES</a>","<a href=\"#TAGGING A VERSION\">TAGGING A VERSION</a>","<a href=\"#COPYING REPOSITORIES\">COPYING REPOSITORIES</a>","<a href=\"#CREATING A NEW BRANCH\">CREATING A NEW BRANCH</a>","<a href=\"#MERGING TWO BRANCHES\">MERGING TWO BRANCHES</a>","<a href=\"#MERGING EXTERNAL WORK\">MERGING EXTERNAL WORK</a>","<a href=\"#HOW DOES THE MERGE WORK?\">HOW DOES THE MERGE WORK?</a>","<a href=\"#PUBLISHING YOUR WORK\">PUBLISHING YOUR WORK</a>","<a href=\"#PACKING YOUR REPOSITORY\">PACKING YOUR REPOSITORY</a>","<a href=\"#WORKING WITH OTHERS\">WORKING WITH OTHERS</a>","<a href=\"#WORKING WITH OTHERS, SHARED REPOSITORY STYLE\">WORKING WITH OTHERS, SHARED REPOSITORY STYLE</a>","<a href=\"#BUNDLING YOUR WORK TOGETHER\">BUNDLING YOUR WORK TOGETHER</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#GIT\">GIT</a>","<a href=\"#NOTES\">NOTES</a>"],"level":7}