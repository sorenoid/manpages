{"name":"path_resolution","description":"path_resolution - how a pathname is resolved to a file","body":"\n\n<h1 align=\"center\">PATH_RESOLUTION</h1>\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">path_resolution\n- how a pathname is resolved to a file</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some UNIX/Linux\nsystem calls have as parameter one or more filenames. A\nfilename (or pathname) is resolved as follows.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Step 1:\nstart of the resolution process</b> <br>\nIf the pathname starts with the '/' character, the starting\nlookup directory is the root directory of the calling\nprocess. A process inherits its root directory from its\nparent. Usually this will be the root directory of the file\nhierarchy. A process may get a different root directory by\nuse of the <a href=\"https://man.page/2/chroot\">chroot(2)</a> system call, or may temporarily\nuse a different root directory by using <a href=\"https://man.page/2/openat2\">openat2(2)</a>\nwith the <b>RESOLVE_IN_ROOT</b> flag set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process may\nget an entirely private mount namespace in case it&mdash;or\none of its ancestors&mdash;was started by an invocation of\nthe <a href=\"https://man.page/2/clone\">clone(2)</a> system call that had the\n<b>CLONE_NEWNS</b> flag set. This handles the '/' part of\nthe pathname.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the pathname\ndoes not start with the '/' character, the starting lookup\ndirectory of the resolution process is the current working\ndirectory of the process &mdash; or in the case of\n<a href=\"https://man.page/2/openat\">openat(2)</a>-style system calls, the <i>dfd</i> argument\n(or the current working directory if <b>AT_FDCWD</b> is\npassed as the <i>dfd</i> argument). The current working\ndirectory is inherited from the parent, and can be changed\nby use of the <a href=\"https://man.page/2/chdir\">chdir(2)</a> system call.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Pathnames\nstarting with a '/' character are called absolute pathnames.\nPathnames not starting with a '/' are called relative\npathnames.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Step 2: walk\nalong the path</b> <br>\nSet the current lookup directory to the starting lookup\ndirectory. Now, for each nonfinal component of the pathname,\nwhere a component is a substring delimited by '/'\ncharacters, this component is looked up in the current\nlookup directory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the process\ndoes not have search permission on the current lookup\ndirectory, an <b>EACCES</b> error is returned\n(&quot;Permission denied&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncomponent is not found, an <b>ENOENT</b> error is returned\n(&quot;No such file or directory&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncomponent is found, but is neither a directory nor a\nsymbolic link, an <b>ENOTDIR</b> error is returned\n(&quot;Not a directory&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncomponent is found and is a directory, we set the current\nlookup directory to that directory, and go to the next\ncomponent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncomponent is found and is a symbolic link (symlink), we\nfirst resolve this symbolic link (with the current lookup\ndirectory as starting lookup directory). Upon error, that\nerror is returned. If the result is not a directory, an\n<b>ENOTDIR</b> error is returned. If the resolution of the\nsymbolic link is successful and returns a directory, we set\nthe current lookup directory to that directory, and go to\nthe next component. Note that the resolution process here\ncan involve recursion if the prefix (&rsquo;dirname&rsquo;)\ncomponent of a pathname contains a filename that is a\nsymbolic link that resolves to a directory (where the prefix\ncomponent of that directory may contain a symbolic link, and\nso on). In order to protect the kernel against stack\noverflow, and also to protect against denial of service,\nthere are limits on the maximum recursion depth, and on the\nmaximum number of symbolic links followed. An <b>ELOOP</b>\nerror is returned when the maximum is exceeded (&quot;Too\nmany levels of symbolic links&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As currently\nimplemented on Linux, the maximum number of symbolic links\nthat will be followed while resolving a pathname is 40. In\nkernels before 2.6.18, the limit on the recursion depth was\n5. Starting with Linux 2.6.18, this limit was raised to 8.\nIn Linux 4.2, the kernel&rsquo;s pathname-resolution code\nwas reworked to eliminate the use of recursion, so that the\nonly limit that remains is the maximum of 40 resolutions for\nthe entire pathname.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The resolution\nof symbolic links during this stage can be blocked by using\n<a href=\"https://man.page/2/openat2\">openat2(2)</a>, with the <b>RESOLVE_NO_SYMLINKS</b> flag\nset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Step 3: find\nthe final entry</b> <br>\nThe lookup of the final component of the pathname goes just\nlike that of all other components, as described in the\nprevious step, with two differences: (i) the final component\nneed not be a directory (at least as far as the path\nresolution process is concerned&mdash;it may have to be a\ndirectory, or a nondirectory, because of the requirements of\nthe specific system call), and (ii) it is not necessarily an\nerror if the component is not found&mdash;maybe we are just\ncreating it. The details on the treatment of the final entry\nare described in the manual pages of the specific system\ncalls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>. and ..</b>\n<br>\nBy convention, every directory has the entries &quot;.&quot;\nand &quot;..&quot;, which refer to the directory itself and\nto its parent directory, respectively.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The path\nresolution process will assume that these entries have their\nconventional meanings, regardless of whether they are\nactually present in the physical filesystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One cannot walk\nup past the root: &quot;/..&quot; is the same as\n&quot;/&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Mount\npoints</b> <br>\nAfter a &quot;mount dev path&quot; command, the pathname\n&quot;path&quot; refers to the root of the filesystem\nhierarchy on the device &quot;dev&quot;, and no longer to\nwhatever it referred to earlier.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One can walk\nout of a mounted filesystem: &quot;path/..&quot; refers to\nthe parent directory of &quot;path&quot;, outside of the\nfilesystem hierarchy on &quot;dev&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Traversal of\nmount points can be blocked by using <a href=\"https://man.page/2/openat2\">openat2(2)</a>, with\nthe <b>RESOLVE_NO_XDEV</b> flag set (though note that this\nalso restricts bind mount traversal).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Trailing\nslashes</b> <br>\nIf a pathname ends in a '/', that forces resolution of the\npreceding component as in Step 2: it has to exist and\nresolve to a directory. Otherwise, a trailing '/' is\nignored. (Or, equivalently, a pathname with a trailing '/'\nis equivalent to the pathname obtained by appending '.' to\nit.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Final\nsymlink</b> <br>\nIf the last component of a pathname is a symbolic link, then\nit depends on the system call whether the file referred to\nwill be the symbolic link or the result of path resolution\non its contents. For example, the system call\n<a href=\"https://man.page/2/lstat\">lstat(2)</a> will operate on the symlink, while\n<a href=\"https://man.page/2/stat\">stat(2)</a> operates on the file pointed to by the\nsymlink.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Length\nlimit</b> <br>\nThere is a maximum length for pathnames. If the pathname (or\nsome intermediate pathname obtained while resolving symbolic\nlinks) is too long, an <b>ENAMETOOLONG</b> error is returned\n(&quot;Filename too long&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Empty\npathname</b> <br>\nIn the original UNIX, the empty pathname referred to the\ncurrent directory. Nowadays POSIX decrees that an empty\npathname must not be resolved successfully. Linux returns\n<b>ENOENT</b> in this case.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Permissions</b>\n<br>\nThe permission bits of a file consist of three groups of\nthree bits; see <a href=\"https://man.page/1/chmod\">chmod(1)</a> and <a href=\"https://man.page/2/stat\">stat(2)</a>. The\nfirst group of three is used when the effective user ID of\nthe calling process equals the owner ID of the file. The\nsecond group of three is used when the group ID of the file\neither equals the effective group ID of the calling process,\nor is one of the supplementary group IDs of the calling\nprocess (as set by <a href=\"https://man.page/2/setgroups\">setgroups(2)</a>). When neither holds,\nthe third group is used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Of the three\nbits used, the first bit determines read permission, the\nsecond write permission, and the last execute permission in\ncase of ordinary files, or search permission in case of\ndirectories.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux uses the\nfsuid instead of the effective user ID in permission checks.\nOrdinarily the fsuid will equal the effective user ID, but\nthe fsuid can be changed by the system call\n<a href=\"https://man.page/2/setfsuid\">setfsuid(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(Here\n&quot;fsuid&quot; stands for something like &quot;filesystem\nuser ID&quot;. The concept was required for the\nimplementation of a user space NFS server at a time when\nprocesses could send a signal to a process with the same\neffective user ID. It is obsolete now. Nobody should use\n<a href=\"https://man.page/2/setfsuid\">setfsuid(2)</a>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Similarly,\nLinux uses the fsgid (&quot;filesystem group ID&quot;)\ninstead of the effective group ID. See\n<a href=\"https://man.page/2/setfsgid\">setfsgid(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Bypassing\npermission checks: superuser and capabilities</b> <br>\nOn a traditional UNIX system, the superuser (<i>root</i>,\nuser ID 0) is all-powerful, and bypasses all permissions\nrestrictions when accessing files.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux,\nsuperuser privileges are divided into capabilities (see\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>). Two capabilities are relevant for\nfile permissions checks: <b>CAP_DAC_OVERRIDE</b> and\n<b>CAP_DAC_READ_SEARCH</b>. (A process has these\ncapabilities if its fsuid is 0.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>CAP_DAC_OVERRIDE</b> capability overrides all permission\nchecking, but grants execute permission only when at least\none of the file&rsquo;s three execute permission bits is\nset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>CAP_DAC_READ_SEARCH</b> capability grants read and search\npermission on directories, and read permission on ordinary\nfiles.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/readlink\">readlink(2)</a>,\n<a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/credentials\">credentials(7)</a>,\n<a href=\"https://man.page/7/symlink\">symlink(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}