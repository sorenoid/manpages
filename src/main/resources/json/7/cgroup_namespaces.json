{"name":"cgroup_namespaces","body":"\n\n<h1 align=\"center\">CGROUP_NAMESPACES</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cgroup_namespaces\n- overview of Linux cgroup namespaces</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an overview\nof namespaces, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Cgroup\nnamespaces virtualize the view of a process&rsquo;s cgroups\n(see <a href=\"https://man.page/7/cgroups\">cgroups(7)</a>) as seen via\n<i>/proc/[pid]/cgroup</i> and\n<i>/proc/[pid]/mountinfo</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each cgroup\nnamespace has its own set of cgroup root directories. These\nroot directories are the base points for the relative\nlocations displayed in the corresponding records in the\n<i>/proc/[pid]/cgroup</i> file. When a process creates a new\ncgroup namespace using <a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a>\nwith the <b>CLONE_NEWCGROUP</b> flag, its current cgroups\ndirectories become the cgroup root directories of the new\nnamespace. (This applies both for the cgroups version 1\nhierarchies and the cgroups version 2 unified\nhierarchy.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When reading\nthe cgroup memberships of a &quot;target&quot; process from\n<i>/proc/[pid]/cgroup</i>, the pathname shown in the third\nfield of each record will be relative to the reading\nprocess&rsquo;s root directory for the corresponding cgroup\nhierarchy. If the cgroup directory of the target process\nlies outside the root directory of the reading\nprocess&rsquo;s cgroup namespace, then the pathname will\nshow <i>../</i> entries for each ancestor level in the\ncgroup hierarchy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session demonstrates the effect of creating a new\ncgroup namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">First, (as\nsuperuser) in a shell in the initial cgroup namespace, we\ncreate a child cgroup in the <i>freezer</i> hierarchy, and\nplace a process in that cgroup that we will use as part of\nthe demonstration below:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"># <b>mkdir -p\n/sys/fs/cgroup/freezer/sub2</b> <br>\n# <b>sleep 10000 &amp;</b> # Create a process that lives for\na while <br>\n[1] 20124 <br>\n# <b>echo 20124 &gt;\n/sys/fs/cgroup/freezer/sub2/cgroup.procs</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">We then create\nanother child cgroup in the <i>freezer</i> hierarchy and put\nthe shell into that cgroup:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"># <b>mkdir -p\n/sys/fs/cgroup/freezer/sub</b> <br>\n# <b>echo $$</b> # Show PID of this shell <br>\n30655 <br>\n# <b>echo 30655 &gt;\n/sys/fs/cgroup/freezer/sub/cgroup.procs</b> <br>\n# <b>cat /proc/self/cgroup | grep freezer</b> <br>\n7:freezer:/sub</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Next, we use\n<a href=\"https://man.page/1/unshare\">unshare(1)</a> to create a process running a new shell in\nnew cgroup and mount namespaces:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#\n<b>PS1=&quot;sh2# &quot; unshare -Cm bash</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From the new\nshell started by <a href=\"https://man.page/1/unshare\">unshare(1)</a>, we then inspect the\n<i>/proc/[pid]/cgroup</i> files of, respectively, the new\nshell, a process that is in the initial cgroup namespace\n(<i>init</i>, with PID 1), and the process in the sibling\ncgroup (<i>sub2</i>):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sh2# <b>cat\n/proc/self/cgroup | grep freezer</b> <br>\n7:freezer:/ <br>\nsh2# <b>cat /proc/1/cgroup | grep freezer</b> <br>\n7:freezer:/.. <br>\nsh2# <b>cat /proc/20124/cgroup | grep freezer</b> <br>\n7:freezer:/../sub2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From the output\nof the first command, we see that the freezer cgroup\nmembership of the new shell (which is in the same cgroup as\nthe initial shell) is shown defined relative to the freezer\ncgroup root directory that was established when the new\ncgroup namespace was created. (In absolute terms, the new\nshell is in the <i>/sub</i> freezer cgroup, and the root\ndirectory of the freezer cgroup hierarchy in the new cgroup\nnamespace is also <i>/sub</i>. Thus, the new shell&rsquo;s\ncgroup membership is displayed as '/'.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, when\nwe look in <i>/proc/self/mountinfo</i> we see the following\nanomaly:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sh2# <b>cat\n/proc/self/mountinfo | grep freezer</b> <br>\n155 145 0:32 /.. /sys/fs/cgroup/freezer ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fourth\nfield of this line (<i>/..</i>) should show the directory in\nthe cgroup filesystem which forms the root of this mount.\nSince by the definition of cgroup namespaces, the\nprocess&rsquo;s current freezer cgroup directory became its\nroot freezer cgroup directory, we should see '/' in this\nfield. The problem here is that we are seeing a mount entry\nfor the cgroup filesystem corresponding to the initial\ncgroup namespace (whose cgroup filesystem is indeed rooted\nat the parent directory of <i>sub</i>). To fix this problem,\nwe must remount the freezer cgroup filesystem from the new\nshell (i.e., perform the mount from a process that is in the\nnew cgroup namespace), after which we see the expected\nresults:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sh2# <b>mount\n--make-rslave /</b> # Don't propagate mount events <br>\n# to other namespaces <br>\nsh2# <b>umount /sys/fs/cgroup/freezer</b> <br>\nsh2# <b>mount -t cgroup -o freezer freezer\n/sys/fs/cgroup/freezer</b> <br>\nsh2# <b>cat /proc/self/mountinfo | grep freezer</b> <br>\n155 145 0:32 / /sys/fs/cgroup/freezer rw,relatime ...</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Namespaces are\na Linux-specific feature.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Use of cgroup\nnamespaces requires a kernel that is configured with the\n<b>CONFIG_CGROUPS</b> option.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nvirtualization provided by cgroup namespaces serves a number\nof purposes:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>It prevents information leaks whereby cgroup directory\npaths outside of a container would otherwise be visible to\nprocesses in the container. Such leakages could, for\nexample, reveal information about the container framework to\ncontainerized applications.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>It eases tasks such as container migration. The\nvirtualization provided by cgroup namespaces allows\ncontainers to be isolated from knowledge of the pathnames of\nancestor cgroups. Without such isolation, the full cgroup\npathnames (displayed in <i>/proc/self/cgroups</i>) would\nneed to be replicated on the target system when migrating a\ncontainer; those pathnames would also need to be unique, so\nthat they don&rsquo;t conflict with other pathnames on the\ntarget system.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>It allows better confinement of containerized processes,\nbecause it is possible to mount the container&rsquo;s cgroup\nfilesystems such that the container processes can&rsquo;t\ngain access to ancestor cgroup directories. Consider, for\nexample, the following scenario:</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\"></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">We have a cgroup directory,\n<i>/cg/1</i>, that is owned by user ID 9000.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"80%\">\n\n\n<p>We have a process, <i>X</i>, also owned by user ID 9000,\nthat is namespaced under the cgroup <i>/cg/1/2</i> (i.e.,\n<i>X</i> was placed in a new cgroup namespace via\n<a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a> with the\n<b>CLONE_NEWCGROUP</b> flag).</p></td></tr>\n</table>\n\n<p style=\"margin-left:14%; margin-top: 1em\">In the absence\nof cgroup namespacing, because the cgroup directory\n<i>/cg/1</i> is owned (and writable) by UID 9000 and process\n<i>X</i> is also owned by user ID 9000, process <i>X</i>\nwould be able to modify the contents of cgroups files (i.e.,\nchange cgroup settings) not only in <i>/cg/1/2</i> but also\nin the ancestor cgroup directory <i>/cg/1</i>. Namespacing\nprocess <i>X</i> under the cgroup directory <i>/cg/1/2</i>,\nin combination with suitable mount operations for the cgroup\nfilesystem (as shown above), prevents it modifying files in\n<i>/cg/1</i>, since it cannot even see the contents of that\ndirectory (or of further removed cgroup ancestor\ndirectories). Combined with correct enforcement of\nhierarchical limits, this prevents process <i>X</i> from\nescaping the limits imposed by ancestor cgroups.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/unshare\">unshare(1)</a>,\n<a href=\"https://man.page/2/clone\">clone(2)</a>, <a href=\"https://man.page/2/setns\">setns(2)</a>, <a href=\"https://man.page/2/unshare\">unshare(2)</a>,\n<a href=\"https://man.page/5/proc\">proc(5)</a>, <a href=\"https://man.page/7/cgroups\">cgroups(7)</a>, <a href=\"https://man.page/7/credentials\">credentials(7)</a>,\n<a href=\"https://man.page/7/namespaces\">namespaces(7)</a>, <a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}