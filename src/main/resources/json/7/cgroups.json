{"name":"cgroups","body":"\n\n<h1 align=\"center\">CGROUPS</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cgroups - Linux\ncontrol groups</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Control groups,\nusually referred to as cgroups, are a Linux kernel feature\nwhich allow processes to be organized into hierarchical\ngroups whose usage of various types of resources can then be\nlimited and monitored. The kernel&rsquo;s cgroup interface\nis provided through a pseudo-filesystem called cgroupfs.\nGrouping is implemented in the core cgroup kernel code,\nwhile resource tracking and limits are implemented in a set\nof per-resource-type subsystems (memory, CPU, and so\non).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Terminology</b>\n<br>\nA <i>cgroup</i> is a collection of processes that are bound\nto a set of limits or parameters defined via the cgroup\nfilesystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<i>subsystem</i> is a kernel component that modifies the\nbehavior of the processes in a cgroup. Various subsystems\nhave been implemented, making it possible to do things such\nas limiting the amount of CPU time and memory available to a\ncgroup, accounting for the CPU time used by a cgroup, and\nfreezing and resuming execution of the processes in a\ncgroup. Subsystems are sometimes also known as <i>resource\ncontrollers</i> (or simply, controllers).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The cgroups for\na controller are arranged in a <i>hierarchy</i>. This\nhierarchy is defined by creating, removing, and renaming\nsubdirectories within the cgroup filesystem. At each level\nof the hierarchy, attributes (e.g., limits) can be defined.\nThe limits, control, and accounting provided by cgroups\ngenerally have effect throughout the subhierarchy underneath\nthe cgroup where the attributes are defined. Thus, for\nexample, the limits placed on a cgroup at a higher level in\nthe hierarchy cannot be exceeded by descendant cgroups.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups\nversion 1 and version 2</b> <br>\nThe initial release of the cgroups implementation was in\nLinux 2.6.24. Over time, various cgroup controllers have\nbeen added to allow the management of various types of\nresources. However, the development of these controllers was\nlargely uncoordinated, with the result that many\ninconsistencies arose between controllers and management of\nthe cgroup hierarchies became rather complex. A longer\ndescription of these problems can be found in the kernel\nsource file <i>Documentation/admin-guide/cgroup-v2.rst</i>\n(or <i>Documentation/cgroup-v2.txt</i> in Linux 4.17 and\nearlier).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because of the\nproblems with the initial cgroups implementation (cgroups\nversion 1), starting in Linux 3.10, work began on a new,\northogonal implementation to remedy these problems.\nInitially marked experimental, and hidden behind the\n<i>-o&nbsp;__DEVEL__sane_behavior</i> mount option, the new\nversion (cgroups version 2) was eventually made official\nwith the release of Linux 4.5. Differences between the two\nversions are described in the text below. The file\n<i>cgroup.sane_behavior</i>, present in cgroups v1, is a\nrelic of this mount option. The file always reports\n&quot;0&quot; and is only retained for backward\ncompatibility.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Although\ncgroups v2 is intended as a replacement for cgroups v1, the\nolder system continues to exist (and for compatibility\nreasons is unlikely to be removed). Currently, cgroups v2\nimplements only a subset of the controllers available in\ncgroups v1. The two systems are implemented so that both v1\ncontrollers and v2 controllers can be mounted on the same\nsystem. Thus, for example, it is possible to use those\ncontrollers that are supported under version 2, while also\nusing version 1 controllers where version 2 does not yet\nsupport those controllers. The only restriction here is that\na controller can&rsquo;t be simultaneously employed in both\na cgroups v1 hierarchy and in the cgroups v2 hierarchy.</p>\n\n<h2>CGROUPS VERSION 1\n<a name=\"CGROUPS VERSION 1\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Under cgroups\nv1, each controller may be mounted against a separate cgroup\nfilesystem that provides its own hierarchical organization\nof the processes on the system. It is also possible to\ncomount multiple (or even all) cgroups v1 controllers\nagainst the same cgroup filesystem, meaning that the\ncomounted controllers manage the same hierarchical\norganization of processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For each\nmounted hierarchy, the directory tree mirrors the control\ngroup hierarchy. Each control group is represented by a\ndirectory, with each of its child control cgroups\nrepresented as a child directory. For instance,\n<i>/user/joe/1.session</i> represents control group\n<i>1.session</i>, which is a child of cgroup <i>joe</i>,\nwhich is a child of <i>/user</i>. Under each cgroup\ndirectory is a set of files which can be read or written to,\nreflecting resource limits and a few general cgroup\nproperties.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Tasks\n(threads) versus processes</b> <br>\nIn cgroups v1, a distinction is drawn between\n<i>processes</i> and <i>tasks</i>. In this view, a process\ncan consist of multiple tasks (more commonly called threads,\nfrom a user-space perspective, and called such in the\nremainder of this man page). In cgroups v1, it is possible\nto independently manipulate the cgroup memberships of the\nthreads in a process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The cgroups v1\nability to split threads across different cgroups caused\nproblems in some cases. For example, it made no sense for\nthe <i>memory</i> controller, since all of the threads of a\nprocess share a single address space. Because of these\nproblems, the ability to independently manipulate the cgroup\nmemberships of the threads in a process was removed in the\ninitial cgroups v2 implementation, and subsequently restored\nin a more limited form (see the discussion of &quot;thread\nmode&quot; below).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Mounting v1\ncontrollers</b> <br>\nThe use of cgroups requires a kernel built with the\n<b>CONFIG_CGROUP</b> option. In addition, each of the v1\ncontrollers has an associated configuration option that must\nbe set in order to employ that controller.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to use\na v1 controller, it must be mounted against a cgroup\nfilesystem. The usual place for such mounts is under a\n<a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a> filesystem mounted at <i>/sys/fs/cgroup</i>.\nThus, one might mount the <i>cpu</i> controller as\nfollows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mount -t cgroup\n-o cpu none /sys/fs/cgroup/cpu</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is possible\nto comount multiple controllers against the same hierarchy.\nFor example, here the <i>cpu</i> and <i>cpuacct</i>\ncontrollers are comounted against a single hierarchy:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mount -t cgroup\n-o cpu,cpuacct none /sys/fs/cgroup/cpu,cpuacct</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Comounting\ncontrollers has the effect that a process is in the same\ncgroup for all of the comounted controllers. Separately\nmounting controllers allows a process to be in cgroup\n<i>/foo1</i> for one controller while being in\n<i>/foo2/foo3</i> for another.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is possible\nto comount all v1 controllers against the same\nhierarchy:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mount -t cgroup\n-o all cgroup /sys/fs/cgroup</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(One can\nachieve the same result by omitting <i>-o all</i>, since it\nis the default if no controllers are explicitly\nspecified.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is not\npossible to mount the same controller against multiple\ncgroup hierarchies. For example, it is not possible to mount\nboth the <i>cpu</i> and <i>cpuacct</i> controllers against\none hierarchy, and to mount the <i>cpu</i> controller alone\nagainst another hierarchy. It is possible to create multiple\nmount points with exactly the same set of comounted\ncontrollers. However, in this case all that results is\nmultiple mount points providing a view of the same\nhierarchy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that on\nmany systems, the v1 controllers are automatically mounted\nunder <i>/sys/fs/cgroup</i>; in particular,\n<a href=\"https://man.page/1/systemd\">systemd(1)</a> automatically creates such mount\npoints.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Unmounting\nv1 controllers</b> <br>\nA mounted cgroup filesystem can be unmounted using the\n<b>umount</b>(8) command, as in the following example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">umount\n/sys/fs/cgroup/pids</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>But note\nwell</i>: a cgroup filesystem is unmounted only if it is not\nbusy, that is, it has no child cgroups. If this is not the\ncase, then the only effect of the <b>umount</b>(8) is to\nmake the mount invisible. Thus, to ensure that the mount\npoint is really removed, one must first remove all child\ncgroups, which in turn can be done only after all member\nprocesses have been moved from those cgroups to the root\ncgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups\nversion 1 controllers</b> <br>\nEach of the cgroups version 1 controllers is governed by a\nkernel configuration option (listed below). Additionally,\nthe availability of the cgroups feature is governed by the\n<b>CONFIG_CGROUPS</b> kernel configuration option. <i><br>\ncpu</i> (since Linux 2.6.24; <b>CONFIG_CGROUP_SCHED</b>)</p>\n\n<p style=\"margin-left:22%;\">Cgroups can be guaranteed a\nminimum number of &quot;CPU shares&quot; when a system is\nbusy. This does not limit a cgroup&rsquo;s CPU usage if the\nCPUs are not busy. For further information, see\n<i>Documentation/scheduler/sched-design-CFS.rst</i> (or\n<i>Documentation/scheduler/sched-design-CFS.txt</i> in Linux\n5.2 and earlier).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In Linux 3.2,\nthis controller was extended to provide CPU\n&quot;bandwidth&quot; control. If the kernel is configured\nwith <b>CONFIG_CFS_BANDWIDTH</b>, then within each\nscheduling period (defined via a file in the cgroup\ndirectory), it is possible to define an upper limit on the\nCPU time allocated to the processes in a cgroup. This upper\nlimit applies even if there is no other competition for the\nCPU. Further information can be found in the kernel source\nfile <i>Documentation/scheduler/sched-bwc.rst</i> (or\n<i>Documentation/scheduler/sched-bwc.txt</i> in Linux 5.2\nand earlier).</p>\n\n<p style=\"margin-left:11%;\"><i>cpuacct</i> (since Linux\n2.6.24; <b>CONFIG_CGROUP_CPUACCT</b>)</p>\n\n<p style=\"margin-left:22%;\">This provides accounting for\nCPU usage by groups of processes.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/cpuacct.rst</i> (or\n<i>Documentation/cgroup-v1/cpuacct.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>cpuset</i> (since Linux\n2.6.24; <b>CONFIG_CPUSETS</b>)</p>\n\n<p style=\"margin-left:22%;\">This cgroup can be used to bind\nthe processes in a cgroup to a specified set of CPUs and\nNUMA nodes.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/cpusets.rst</i> (or\n<i>Documentation/cgroup-v1/cpusets.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>memory</i> (since Linux\n2.6.25; <b>CONFIG_MEMCG</b>)</p>\n\n<p style=\"margin-left:22%;\">The memory controller supports\nreporting and limiting of process memory, kernel memory, and\nswap used by cgroups.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/memory.rst</i> (or\n<i>Documentation/cgroup-v1/memory.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>devices</i> (since Linux\n2.6.26; <b>CONFIG_CGROUP_DEVICE</b>)</p>\n\n<p style=\"margin-left:22%;\">This supports controlling which\nprocesses may create (mknod) devices as well as open them\nfor reading or writing. The policies may be specified as\nallow-lists and deny-lists. Hierarchy is enforced, so new\nrules must not violate existing rules for the target or\nancestor cgroups.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/devices.rst</i> (or\n<i>Documentation/cgroup-v1/devices.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>freezer</i> (since Linux\n2.6.28; <b>CONFIG_CGROUP_FREEZER</b>)</p>\n\n<p style=\"margin-left:22%;\">The <i>freezer</i> cgroup can\nsuspend and restore (resume) all processes in a cgroup.\nFreezing a cgroup <i>/A</i> also causes its children, for\nexample, processes in <i>/A/B</i>, to be frozen.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/freezer-subsystem.rst</i>\n(or <i>Documentation/cgroup-v1/freezer-subsystem.txt</i> in\nLinux 5.2 and earlier).</p>\n\n<p style=\"margin-left:11%;\"><i>net_cls</i> (since Linux\n2.6.29; <b>CONFIG_CGROUP_NET_CLASSID</b>)</p>\n\n<p style=\"margin-left:22%;\">This places a classid,\nspecified for the cgroup, on network packets created by a\ncgroup. These classids can then be used in firewall rules,\nas well as used to shape traffic using <b>tc</b>(8). This\napplies only to packets leaving the cgroup, not to traffic\narriving at the cgroup.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/net_cls.rst</i> (or\n<i>Documentation/cgroup-v1/net_cls.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>blkio</i> (since Linux\n2.6.33; <b>CONFIG_BLK_CGROUP</b>)</p>\n\n<p style=\"margin-left:22%;\">The <i>blkio</i> cgroup\ncontrols and limits access to specified block devices by\napplying IO control in the form of throttling and upper\nlimits against leaf nodes and intermediate nodes in the\nstorage hierarchy.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Two policies\nare available. The first is a proportional-weight time-based\ndivision of disk implemented with CFQ. This is in effect for\nleaf nodes using CFQ. The second is a throttling policy\nwhich specifies upper I/O rate limits on a device.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/blkio-controller.rst</i>\n(or <i>Documentation/cgroup-v1/blkio-controller.txt</i> in\nLinux 5.2 and earlier).</p>\n\n<p style=\"margin-left:11%;\"><i>perf_event</i> (since Linux\n2.6.39; <b>CONFIG_CGROUP_PERF</b>)</p>\n\n<p style=\"margin-left:22%;\">This controller allows\n<i>perf</i> monitoring of the set of processes grouped in a\ncgroup.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source files</p>\n\n<p style=\"margin-left:11%;\"><i>net_prio</i> (since Linux\n3.3; <b>CONFIG_CGROUP_NET_PRIO</b>)</p>\n\n<p style=\"margin-left:22%;\">This allows priorities to be\nspecified, per network interface, for cgroups.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/net_prio.rst</i> (or\n<i>Documentation/cgroup-v1/net_prio.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>hugetlb</i> (since Linux\n3.5; <b>CONFIG_CGROUP_HUGETLB</b>)</p>\n\n<p style=\"margin-left:22%;\">This supports limiting the use\nof huge pages by cgroups.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/hugetlb.rst</i> (or\n<i>Documentation/cgroup-v1/hugetlb.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>pids</i> (since Linux 4.3;\n<b>CONFIG_CGROUP_PIDS</b>)</p>\n\n<p style=\"margin-left:22%;\">This controller permits\nlimiting the number of process that may be created in a\ncgroup (and its descendants).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/pids.rst</i> (or\n<i>Documentation/cgroup-v1/pids.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%;\"><i>rdma</i> (since Linux 4.11;\n<b>CONFIG_CGROUP_RDMA</b>)</p>\n\n<p style=\"margin-left:22%;\">The RDMA controller permits\nlimiting the use of RDMA/IB-specific resources per\ncgroup.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Further\ninformation can be found in the kernel source file\n<i>Documentation/admin-guide/cgroup-v1/rdma.rst</i> (or\n<i>Documentation/cgroup-v1/rdma.txt</i> in Linux 5.2 and\nearlier).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Creating\ncgroups and moving processes</b> <br>\nA cgroup filesystem initially contains a single root cgroup,\n&rsquo;/&rsquo;, which all processes belong to. A new cgroup\nis created by creating a directory in the cgroup\nfilesystem:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mkdir\n/sys/fs/cgroup/cpu/cg1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This creates a\nnew empty cgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process may\nbe moved to this cgroup by writing its PID into the\ncgroup&rsquo;s <i>cgroup.procs</i> file:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">echo $$ &gt;\n/sys/fs/cgroup/cpu/cg1/cgroup.procs</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Only one PID at\na time should be written to this file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Writing the\nvalue 0 to a <i>cgroup.procs</i> file causes the writing\nprocess to be moved to the corresponding cgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When writing a\nPID into the <i>cgroup.procs</i>, all threads in the process\nare moved into the new cgroup at once.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Within a\nhierarchy, a process can be a member of exactly one cgroup.\nWriting a process&rsquo;s PID to a <i>cgroup.procs</i> file\nautomatically removes it from the cgroup of which it was\npreviously a member.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cgroup.procs</i> file can be read to obtain a list of the\nprocesses that are members of a cgroup. The returned list of\nPIDs is not guaranteed to be in order. Nor is it guaranteed\nto be free of duplicates. (For example, a PID may be\nrecycled while reading from the list.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In cgroups v1,\nan individual thread can be moved to another cgroup by\nwriting its thread ID (i.e., the kernel thread ID returned\nby <a href=\"https://man.page/2/clone\">clone(2)</a> and <a href=\"https://man.page/2/gettid\">gettid(2)</a>) to the <i>tasks</i>\nfile in a cgroup directory. This file can be read to\ndiscover the set of threads that are members of the\ncgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Removing\ncgroups</b> <br>\nTo remove a cgroup, it must first have no child cgroups and\ncontain no (nonzombie) processes. So long as that is the\ncase, one can simply remove the corresponding directory\npathname. Note that files in a cgroup directory cannot and\nneed not be removed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v1\nrelease notification</b> <br>\nTwo files can be used to determine whether the kernel\nprovides notifications when a cgroup becomes empty. A cgroup\nis considered to be empty when it contains no child cgroups\nand no member processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A special file\nin the root directory of each cgroup hierarchy,\n<i>release_agent</i>, can be used to register the pathname\nof a program that may be invoked when a cgroup in the\nhierarchy becomes empty. The pathname of the newly empty\ncgroup (relative to the cgroup mount point) is provided as\nthe sole command-line argument when the <i>release_agent</i>\nprogram is invoked. The <i>release_agent</i> program might\nremove the cgroup directory, or perhaps repopulate it with a\nprocess.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\nvalue of the <i>release_agent</i> file is empty, meaning\nthat no release agent is invoked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The content of\nthe <i>release_agent</i> file can also be specified via a\nmount option when the cgroup filesystem is mounted:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mount -o\nrelease_agent=pathname ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Whether or not\nthe <i>release_agent</i> program is invoked when a\nparticular cgroup becomes empty is determined by the value\nin the <i>notify_on_release</i> file in the corresponding\ncgroup directory. If this file contains the value 0, then\nthe <i>release_agent</i> program is not invoked. If it\ncontains the value 1, the <i>release_agent</i> program is\ninvoked. The default value for this file in the root cgroup\nis 0. At the time when a new cgroup is created, the value in\nthis file is inherited from the corresponding file in the\nparent cgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroup v1\nnamed hierarchies</b> <br>\nIn cgroups v1, it is possible to mount a cgroup hierarchy\nthat has no attached controllers:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mount -t cgroup\n-o none,name=somename none /some/mount/point</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Multiple\ninstances of such hierarchies can be mounted; each hierarchy\nmust have a unique name. The only purpose of such\nhierarchies is to track processes. (See the discussion of\nrelease notification below.) An example of this is the\n<i>name=systemd</i> cgroup hierarchy that is used by\n<a href=\"https://man.page/1/systemd\">systemd(1)</a> to track services and user sessions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n5.0, the <i>cgroup_no_v1</i> kernel boot option (described\nbelow) can be used to disable cgroup v1 named hierarchies,\nby specifying <i>cgroup_no_v1=named</i>.</p>\n\n<h2>CGROUPS VERSION 2\n<a name=\"CGROUPS VERSION 2\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In cgroups v2,\nall mounted controllers reside in a single unified\nhierarchy. While (different) controllers may be\nsimultaneously mounted under the v1 and v2 hierarchies, it\nis not possible to mount the same controller simultaneously\nunder both the v1 and the v2 hierarchies.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The new\nbehaviors in cgroups v2 are summarized here, and in some\ncases elaborated in the following subsections.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>Cgroups v2 provides a unified hierarchy against which\nall controllers are mounted.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>&quot;Internal&quot; processes are not permitted. With\nthe exception of the root cgroup, processes may reside only\nin leaf nodes (cgroups that do not themselves contain child\ncgroups). The details are somewhat more subtle than this,\nand are described below.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>Active cgroups must be specified via the files\n<i>cgroup.controllers</i> and\n<i>cgroup.subtree_control</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>The <i>tasks</i> file has been removed. In addition, the\n<i>cgroup.clone_children</i> file that is employed by the\n<i>cpuset</i> controller has been removed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>An improved mechanism for notification of empty cgroups\nis provided by the <i>cgroup.events</i> file.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For more\nchanges, see the\n<i>Documentation/admin-guide/cgroup-v2.rst</i> file in the\nkernel source (or <i>Documentation/cgroup-v2.txt</i> in\nLinux 4.17 and earlier).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some of the new\nbehaviors listed above saw subsequent modification with the\naddition in Linux 4.14 of &quot;thread mode&quot; (described\nbelow).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\nunified hierarchy</b> <br>\nIn cgroups v1, the ability to mount different controllers\nagainst different hierarchies was intended to allow great\nflexibility for application design. In practice, though, the\nflexibility turned out to be less useful than expected, and\nin many cases added complexity. Therefore, in cgroups v2,\nall available controllers are mounted against a single\nhierarchy. The available controllers are automatically\nmounted, meaning that it is not necessary (or possible) to\nspecify the controllers when mounting the cgroup v2\nfilesystem using a command such as the following:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mount -t\ncgroup2 none /mnt/cgroup2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A cgroup v2\ncontroller is available only if it is not currently in use\nvia a mount against a cgroup v1 hierarchy. Or, to put things\nanother way, it is not possible to employ the same\ncontroller against both a v1 hierarchy and the unified v2\nhierarchy. This means that it may be necessary first to\nunmount a v1 controller (as described above) before that\ncontroller is available in v2. Since <a href=\"https://man.page/1/systemd\">systemd(1)</a> makes\nheavy use of some v1 controllers by default, it can in some\ncases be simpler to boot the system with selected v1\ncontrollers disabled. To do this, specify the\n<i>cgroup_no_v1=list</i> option on the kernel boot command\nline; <i>list</i> is a comma-separated list of the names of\nthe controllers to disable, or the word <i>all</i> to\ndisable all v1 controllers. (This situation is correctly\nhandled by <a href=\"https://man.page/1/systemd\">systemd(1)</a>, which falls back to operating\nwithout the specified controllers.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that on\nmany modern systems, <a href=\"https://man.page/1/systemd\">systemd(1)</a> automatically mounts\nthe <i>cgroup2</i> filesystem at\n<i>/sys/fs/cgroup/unified</i> during the boot process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\nmount options</b> <br>\nThe following options (<i>mount -o</i>) can be specified\nwhen mounting the group v2 filesystem: <i><br>\nnsdelegate</i> (since Linux 4.15)</p>\n\n<p style=\"margin-left:22%;\">Treat cgroup namespaces as\ndelegation boundaries. For details, see below.</p>\n\n<p style=\"margin-left:11%;\"><i>memory_localevents</i>\n(since Linux 5.2)</p>\n\n<p style=\"margin-left:22%;\">The <i>memory.events</i> should\nshow statistics only for the cgroup itself, and not for any\ndescendant cgroups. This was the behavior before Linux 5.2.\nStarting in Linux 5.2, the default behavior is to include\nstatistics for descendant cgroups in <i>memory.events</i>,\nand this mount option can be used to revert to the legacy\nbehavior. This option is system wide and can be set on mount\nor modified through remount only from the initial mount\nnamespace; it is silently ignored in noninitial\nnamespaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\ncontrollers</b> <br>\nThe following controllers, documented in the kernel source\nfile <i>Documentation/admin-guide/cgroup-v2.rst</i> (or\n<i>Documentation/cgroup-v2.txt</i> in Linux 4.17 and\nearlier), are supported in cgroups version 2: <i><br>\ncpu</i> (since Linux 4.15)</p>\n\n<p style=\"margin-left:22%;\">This is the successor to the\nversion 1 <i>cpu</i> and <i>cpuacct</i> controllers.</p>\n\n<p style=\"margin-left:11%;\"><i>cpuset</i> (since Linux\n5.0)</p>\n\n<p style=\"margin-left:22%;\">This is the successor of the\nversion 1 <i>cpuset</i> controller.</p>\n\n<p style=\"margin-left:11%;\"><i>freezer</i> (since Linux\n5.2)</p>\n\n<p style=\"margin-left:22%;\">This is the successor of the\nversion 1 <i>freezer</i> controller.</p>\n\n<p style=\"margin-left:11%;\"><i>hugetlb</i> (since Linux\n5.6)</p>\n\n<p style=\"margin-left:22%;\">This is the successor of the\nversion 1 <i>hugetlb</i> controller.</p>\n\n<p style=\"margin-left:11%;\"><i>io</i> (since Linux 4.5)</p>\n\n<p style=\"margin-left:22%;\">This is the successor of the\nversion 1 <i>blkio</i> controller.</p>\n\n<p style=\"margin-left:11%;\"><i>memory</i> (since Linux\n4.5)</p>\n\n<p style=\"margin-left:22%;\">This is the successor of the\nversion 1 <i>memory</i> controller.</p>\n\n<p style=\"margin-left:11%;\"><i>perf_event</i> (since Linux\n4.11)</p>\n\n<p style=\"margin-left:22%;\">This is the same as the version\n1 <i>perf_event</i> controller.</p>\n\n<p style=\"margin-left:11%;\"><i>pids</i> (since Linux\n4.5)</p>\n\n<p style=\"margin-left:22%;\">This is the same as the version\n1 <i>pids</i> controller.</p>\n\n<p style=\"margin-left:11%;\"><i>rdma</i> (since Linux\n4.11)</p>\n\n<p style=\"margin-left:22%;\">This is the same as the version\n1 <i>rdma</i> controller.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is no\ndirect equivalent of the <i>net_cls</i> and <i>net_prio</i>\ncontrollers from cgroups version 1. Instead, support has\nbeen added to <b>iptables</b>(8) to allow eBPF filters that\nhook on cgroup v2 pathnames to make decisions about network\ntraffic on a per-cgroup basis.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The v2\n<i>devices</i> controller provides no interface files;\ninstead, device control is gated by attaching an eBPF\n(<b>BPF_CGROUP_DEVICE</b>) program to a v2 cgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\nsubtree control</b> <br>\nEach cgroup in the v2 hierarchy contains the following two\nfiles: <i><br>\ncgroup.controllers</i></p>\n\n<p style=\"margin-left:22%;\">This read-only file exposes a\nlist of the controllers that are <i>available</i> in this\ncgroup. The contents of this file match the contents of the\n<i>cgroup.subtree_control</i> file in the parent cgroup.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cgroup.subtree_control</i></p>\n\n<p style=\"margin-left:22%;\">This is a list of controllers\nthat are <i>active</i> (<i>enabled</i>) in the cgroup. The\nset of controllers in this file is a subset of the set in\nthe <i>cgroup.controllers</i> of this cgroup. The set of\nactive controllers is modified by writing strings to this\nfile containing space-delimited controller names, each\npreceded by &rsquo;+&rsquo; (to enable a controller) or\n&rsquo;-&rsquo; (to disable a controller), as in the\nfollowing example:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">echo '+pids\n-memory' &gt; x/y/cgroup.subtree_control</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">An attempt to\nenable a controller that is not present in\n<i>cgroup.controllers</i> leads to an <b>ENOENT</b> error\nwhen writing to the <i>cgroup.subtree_control</i> file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because the\nlist of controllers in <i>cgroup.subtree_control</i> is a\nsubset of those <i>cgroup.controllers</i>, a controller that\nhas been disabled in one cgroup in the hierarchy can never\nbe re-enabled in the subtree below that cgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\ncgroup&rsquo;s <i>cgroup.subtree_control</i> file determines\nthe set of controllers that are exercised in the\n<i>child</i> cgroups. When a controller (e.g., <i>pids</i>)\nis present in the <i>cgroup.subtree_control</i> file of a\nparent cgroup, then the corresponding controller-interface\nfiles (e.g., <i>pids.max</i>) are automatically created in\nthe children of that cgroup and can be used to exert\nresource control in the child cgroups.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\n&quot;no internal processes&quot; rule</b> <br>\nCgroups v2 enforces a so-called &quot;no internal\nprocesses&quot; rule. Roughly speaking, this rule means\nthat, with the exception of the root cgroup, processes may\nreside only in leaf nodes (cgroups that do not themselves\ncontain child cgroups). This avoids the need to decide how\nto partition resources between processes which are members\nof cgroup A and processes in child cgroups of A.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For instance,\nif cgroup <i>/cg1/cg2</i> exists, then a process may reside\nin <i>/cg1/cg2</i>, but not in <i>/cg1</i>. This is to avoid\nan ambiguity in cgroups v1 with respect to the delegation of\nresources between processes in <i>/cg1</i> and its child\ncgroups. The recommended approach in cgroups v2 is to create\na subdirectory called <i>leaf</i> for any nonleaf cgroup\nwhich should contain processes, but no child cgroups. Thus,\nprocesses which previously would have gone into <i>/cg1</i>\nwould now go into <i>/cg1/leaf</i>. This has the advantage\nof making explicit the relationship between processes in\n<i>/cg1/leaf</i> and <i>/cg1</i>&rsquo;s other children.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The &quot;no\ninternal processes&quot; rule is in fact more subtle than\nstated above. More precisely, the rule is that a (nonroot)\ncgroup can&rsquo;t both (1) have member processes, and (2)\ndistribute resources into child cgroups&mdash;that is, have\na nonempty <i>cgroup.subtree_control</i> file. Thus, it\n<i>is</i> possible for a cgroup to have both member\nprocesses and child cgroups, but before controllers can be\nenabled for that cgroup, the member processes must be moved\nout of the cgroup (e.g., perhaps into the child\ncgroups).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With the Linux\n4.14 addition of &quot;thread mode&quot; (described below),\nthe &quot;no internal processes&quot; rule has been relaxed\nin some cases.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\ncgroup.events file</b> <br>\nEach nonroot cgroup in the v2 hierarchy contains a read-only\nfile, <i>cgroup.events</i>, whose contents are key-value\npairs (delimited by newline characters, with the key and\nvalue separated by spaces) providing state information about\nthe cgroup:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cat\nmygrp/cgroup.events</b> <br>\npopulated 1 <br>\nfrozen 0</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nkeys may appear in this file: <i><br>\npopulated</i></p>\n\n<p style=\"margin-left:22%;\">The value of this key is either\n1, if this cgroup or any of its descendants has member\nprocesses, or otherwise 0.</p>\n\n<p style=\"margin-left:11%;\"><i>frozen</i> (since Linux\n5.2)</p>\n\n<p style=\"margin-left:22%;\">The value of this key is 1 if\nthis cgroup is currently frozen, or 0 if it is not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cgroup.events</i> file can be monitored, in order to\nreceive notification when the value of one of its keys\nchanges. Such monitoring can be done using\n<a href=\"https://man.page/7/inotify\">inotify(7)</a>, which notifies changes as\n<b>IN_MODIFY</b> events, or <a href=\"https://man.page/2/poll\">poll(2)</a>, which notifies\nchanges by returning the <b>POLLPRI</b> and <b>POLLERR</b>\nbits in the <i>revents</i> field.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroup v2\nrelease notification</b> <br>\nCgroups v2 provides a new mechanism for obtaining\nnotification when a cgroup becomes empty. The cgroups v1\n<i>release_agent</i> and <i>notify_on_release</i> files are\nremoved, and replaced by the <i>populated</i> key in the\n<i>cgroup.events</i> file. This key either has the value 0,\nmeaning that the cgroup (and its descendants) contain no\n(nonzombie) member processes, or 1, meaning that the cgroup\n(or one of its descendants) contains member processes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The cgroups v2\nrelease-notification mechanism offers the following\nadvantages over the cgroups v1 <i>release_agent</i>\nmechanism:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>It allows for cheaper notification, since a single\nprocess can monitor multiple <i>cgroup.events</i> files\n(using the techniques described earlier). By contrast, the\ncgroups v1 mechanism requires the expense of creating a\nprocess for each notification.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Notification for different cgroup subhierarchies can be\ndelegated to different processes. By contrast, the cgroups\nv1 mechanism allows only one release agent for an entire\nhierarchy.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\ncgroup.stat file</b> <br>\nEach cgroup in the v2 hierarchy contains a read-only\n<i>cgroup.stat</i> file (first introduced in Linux 4.14)\nthat consists of lines containing key-value pairs. The\nfollowing keys currently appear in this file: <i><br>\nnr_descendants</i></p>\n\n<p style=\"margin-left:22%;\">This is the total number of\nvisible (i.e., living) descendant cgroups underneath this\ncgroup.</p>\n\n\n<p style=\"margin-left:11%;\"><i>nr_dying_descendants</i></p>\n\n<p style=\"margin-left:22%;\">This is the total number of\ndying descendant cgroups underneath this cgroup. A cgroup\nenters the dying state after being deleted. It remains in\nthat state for an undefined period (which will depend on\nsystem load) while resources are freed before the cgroup is\ndestroyed. Note that the presence of some cgroups in the\ndying state is normal, and is not indicative of any\nproblem.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A process\ncan&rsquo;t be made a member of a dying cgroup, and a dying\ncgroup can&rsquo;t be brought back to life.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Limiting the\nnumber of descendant cgroups</b> <br>\nEach cgroup in the v2 hierarchy contains the following\nfiles, which can be used to view and set limits on the\nnumber of descendant cgroups under that cgroup: <i><br>\ncgroup.max.depth</i> (since Linux 4.14)</p>\n\n<p style=\"margin-left:22%;\">This file defines a limit on\nthe depth of nesting of descendant cgroups. A value of 0 in\nthis file means that no descendant cgroups can be created.\nAn attempt to create a descendant whose nesting level\nexceeds the limit fails (<i>mkdir</i>(2) fails with the\nerror <b>EAGAIN</b>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Writing the\nstring <i>&quot;max&quot;</i> to this file means that no\nlimit is imposed. The default value in this file is\n<i>&quot;max&quot;</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>cgroup.max.descendants</i>\n(since Linux 4.14)</p>\n\n<p style=\"margin-left:22%;\">This file defines a limit on\nthe number of live descendant cgroups that this cgroup may\nhave. An attempt to create more descendants than allowed by\nthe limit fails (<i>mkdir</i>(2) fails with the error\n<b>EAGAIN</b>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Writing the\nstring <i>&quot;max&quot;</i> to this file means that no\nlimit is imposed. The default value in this file is\n<i>&quot;max&quot;</i>.</p>\n\n<h2>CGROUPS DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER\n<a name=\"CGROUPS DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the context\nof cgroups, delegation means passing management of some\nsubtree of the cgroup hierarchy to a nonprivileged user.\nCgroups v1 provides support for delegation based on file\npermissions in the cgroup hierarchy but with less strict\ncontainment rules than v2 (as noted below). Cgroups v2\nsupports delegation with containment by explicit design. The\nfocus of the discussion in this section is on delegation in\ncgroups v2, with some differences for cgroups v1 noted along\nthe way.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some\nterminology is required in order to describe delegation. A\n<i>delegater</i> is a privileged user (i.e., root) who owns\na parent cgroup. A <i>delegatee</i> is a nonprivileged user\nwho will be granted the permissions needed to manage some\nsubhierarchy under that parent cgroup, known as the\n<i>delegated subtree</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To perform\ndelegation, the delegater makes certain directories and\nfiles writable by the delegatee, typically by changing the\nownership of the objects to be the user ID of the delegatee.\nAssuming that we want to delegate the hierarchy rooted at\n(say) <i>/dlgt_grp</i> and that there are not yet any child\ncgroups under that cgroup, the ownership of the following is\nchanged to the user ID of the delegatee: <i><br>\n/dlgt_grp</i></p>\n\n<p style=\"margin-left:22%;\">Changing the ownership of the\nroot of the subtree means that any new cgroups created under\nthe subtree (and the files they contain) will also be owned\nby the delegatee.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/dlgt_grp/cgroup.procs</i></p>\n\n<p style=\"margin-left:22%;\">Changing the ownership of this\nfile means that the delegatee can move processes into the\nroot of the delegated subtree.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/dlgt_grp/cgroup.subtree_control</i>\n(cgroups v2 only)</p>\n\n<p style=\"margin-left:22%;\">Changing the ownership of this\nfile means that the delegatee can enable controllers (that\nare present in <i>/dlgt_grp/cgroup.controllers</i>) in order\nto further redistribute resources at lower levels in the\nsubtree. (As an alternative to changing the ownership of\nthis file, the delegater might instead add selected\ncontrollers to this file.)</p>\n\n\n<p style=\"margin-left:11%;\"><i>/dlgt_grp/cgroup.threads</i>\n(cgroups v2 only)</p>\n\n<p style=\"margin-left:22%;\">Changing the ownership of this\nfile is necessary if a threaded subtree is being delegated\n(see the description of &quot;thread mode&quot;, below).\nThis permits the delegatee to write thread IDs to the file.\n(The ownership of this file can also be changed when\ndelegating a domain subtree, but currently this serves no\npurpose, since, as described below, it is not possible to\nmove a thread between domain cgroups by writing its thread\nID to the <i>cgroup.threads</i> file.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In cgroups v1,\nthe corresponding file that should instead be delegated is\nthe <i>tasks</i> file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The delegater\nshould <i>not</i> change the ownership of any of the\ncontroller interfaces files (e.g., <i>pids.max</i>,\n<i>memory.high</i>) in <i>dlgt_grp</i>. Those files are used\nfrom the next level above the delegated subtree in order to\ndistribute resources into the subtree, and the delegatee\nshould not have permission to change the resources that are\ndistributed into the delegated subtree.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See also the\ndiscussion of the <i>/sys/kernel/cgroup/delegate</i> file in\nNOTES for information about further delegatable files in\ncgroups v2.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After the\naforementioned steps have been performed, the delegatee can\ncreate child cgroups within the delegated subtree (the\ncgroup subdirectories and the files they contain will be\nowned by the delegatee) and move processes between cgroups\nin the subtree. If some controllers are present in\n<i>dlgt_grp/cgroup.subtree_control</i>, or the ownership of\nthat file was passed to the delegatee, the delegatee can\nalso control the further redistribution of the corresponding\nresources into the delegated subtree.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroups v2\ndelegation: nsdelegate and cgroup namespaces</b> <br>\nStarting with Linux 4.13, there is a second way to perform\ncgroup delegation in the cgroups v2 hierarchy. This is done\nby mounting or remounting the cgroup v2 filesystem with the\n<i>nsdelegate</i> mount option. For example, if the cgroup\nv2 filesystem has already been mounted, we can remount it\nwith the <i>nsdelegate</i> option as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mount -t\ncgroup2 -o remount,nsdelegate \\ <br>\nnone /sys/fs/cgroup/unified</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The effect of\nthis mount option is to cause cgroup namespaces to\nautomatically become delegation boundaries. More\nspecifically, the following restrictions apply for processes\ninside the cgroup namespace:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Writes to controller interface files in the root\ndirectory of the namespace will fail with the error\n<b>EPERM</b>. Processes inside the cgroup namespace can\nstill write to delegatable files in the root directory of\nthe cgroup namespace such as <i>cgroup.procs</i> and\n<i>cgroup.subtree_control</i>, and can create subhierarchy\nunderneath the root directory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Attempts to migrate processes across the namespace\nboundary are denied (with the error <b>ENOENT</b>).\nProcesses inside the cgroup namespace can still (subject to\nthe containment rules described below) move processes\nbetween cgroups <i>within</i> the subhierarchy under the\nnamespace root.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The ability to\ndefine cgroup namespaces as delegation boundaries makes\ncgroup namespaces more useful. To understand why, suppose\nthat we already have one cgroup hierarchy that has been\ndelegated to a nonprivileged user, <i>cecilia</i>, using the\nolder delegation technique described above. Suppose further\nthat <i>cecilia</i> wanted to further delegate a\nsubhierarchy under the existing delegated hierarchy. (For\nexample, the delegated hierarchy might be associated with an\nunprivileged container run by <i>cecilia</i>.) Even if a\ncgroup namespace was employed, because both hierarchies are\nowned by the unprivileged user <i>cecilia</i>, the following\nillegitimate actions could be performed:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">A process in the inferior\nhierarchy could change the resource controller settings in\nthe root directory of that hierarchy. (These resource\ncontroller settings are intended to allow control to be\nexercised from the <i>parent</i> cgroup; a process inside\nthe child cgroup should not be allowed to modify them.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>A process inside the inferior hierarchy could move\nprocesses into and out of the inferior hierarchy if the\ncgroups in the superior hierarchy were somehow visible.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Employing the\n<i>nsdelegate</i> mount option prevents both of these\npossibilities.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>nsdelegate</i> mount option only has an effect when\nperformed in the initial mount namespace; in other mount\nnamespaces, the option is silently ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>: On\nsome systems, <a href=\"https://man.page/1/systemd\">systemd(1)</a> automatically mounts the\ncgroup v2 filesystem. In order to experiment with the\n<i>nsdelegate</i> operation, it may be useful to boot the\nkernel with the following command-line options:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">cgroup_no_v1=all\nsystemd.legacy_systemd_cgroup_controller</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These options\ncause the kernel to boot with the cgroups v1 controllers\ndisabled (meaning that the controllers are available in the\nv2 hierarchy), and tells <a href=\"https://man.page/1/systemd\">systemd(1)</a> not to mount and\nuse the cgroup v2 hierarchy, so that the v2 hierarchy can be\nmanually mounted with the desired options after boot-up.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cgroup\ndelegation containment rules</b> <br>\nSome delegation <i>containment rules</i> ensure that the\ndelegatee can move processes between cgroups within the\ndelegated subtree, but can&rsquo;t move processes from\noutside the delegated subtree into the subtree or vice\nversa. A nonprivileged process (i.e., the delegatee) can\nwrite the PID of a &quot;target&quot; process into a\n<i>cgroup.procs</i> file only if all of the following are\ntrue:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The writer has write permission\non the <i>cgroup.procs</i> file in the destination\ncgroup.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The writer has write permission on the\n<i>cgroup.procs</i> file in the nearest common ancestor of\nthe source and destination cgroups. Note that in some cases,\nthe nearest common ancestor may be the source or destination\ncgroup itself. This requirement is not enforced for cgroups\nv1 hierarchies, with the consequence that containment in v1\nis less strict than in v2. (For example, in cgroups v1 the\nuser that owns two distinct delegated subhierarchies can\nmove a process between the hierarchies.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If the cgroup v2 filesystem was mounted with the\n<i>nsdelegate</i> option, the writer must be able to see the\nsource and destination cgroups from its cgroup\nnamespace.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>In cgroups v1: the effective UID of the writer (i.e.,\nthe delegatee) matches the real user ID or the saved\nset-user-ID of the target process. Before Linux 4.11, this\nrequirement also applied in cgroups v2 (This was a\nhistorical requirement inherited from cgroups v1 that was\nlater deemed unnecessary, since the other rules suffice for\ncontainment in cgroups v2.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Note</i>:\none consequence of these delegation containment rules is\nthat the unprivileged delegatee can&rsquo;t place the first\nprocess into the delegated subtree; instead, the delegater\nmust place the first process (a process owned by the\ndelegatee) into the delegated subtree.</p>\n\n<h2>CGROUPS VERSION 2 THREAD MODE\n<a name=\"CGROUPS VERSION 2 THREAD MODE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Among the\nrestrictions imposed by cgroups v2 that were not present in\ncgroups v1 are the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\"><i>No thread-granularity\ncontrol</i>: all of the threads of a process must be in the\nsame cgroup.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>No internal processes</i>: a cgroup can&rsquo;t both\nhave member processes and exercise controllers on child\ncgroups.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both of these\nrestrictions were added because the lack of these\nrestrictions had caused problems in cgroups v1. In\nparticular, the cgroups v1 ability to allow thread-level\ngranularity for cgroup membership made no sense for some\ncontrollers. (A notable example was the <i>memory</i>\ncontroller: since threads share an address space, it made no\nsense to split threads across different <i>memory</i>\ncgroups.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notwithstanding\nthe initial design decision in cgroups v2, there were use\ncases for certain controllers, notably the <i>cpu</i>\ncontroller, for which thread-level granularity of control\nwas meaningful and useful. To accommodate such use cases,\nLinux 4.14 added <i>thread mode</i> for cgroups v2.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Thread mode\nallows the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The creation of <i>threaded\nsubtrees</i> in which the threads of a process may be spread\nacross cgroups inside the tree. (A threaded subtree may\ncontain multiple multithreaded processes.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The concept of <i>threaded controllers</i>, which can\ndistribute resources across the cgroups in a threaded\nsubtree.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>A relaxation of the &quot;no internal processes\nrule&quot;, so that, within a threaded subtree, a cgroup can\nboth contain member threads and exercise resource control\nover child cgroups.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With the\naddition of thread mode, each nonroot cgroup now contains a\nnew file, <i>cgroup.type</i>, that exposes, and in some\ncircumstances can be used to change, the &quot;type&quot; of\na cgroup. This file contains one of the following type\nvalues:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><i>domain</i></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">This is a normal v2 cgroup that\nprovides process-granularity control. If a process is a\nmember of this cgroup, then all threads of the process are\n(by definition) in the same cgroup. This is the default\ncgroup type, and provides the same behavior that was\nprovided for cgroups in the initial cgroups v2\nimplementation.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>threaded</i></p>\n\n<p style=\"margin-left:22%;\">This cgroup is a member of a\nthreaded subtree. Threads can be added to this cgroup, and\ncontrollers can be enabled for the cgroup.</p>\n\n<p style=\"margin-left:11%;\"><i>domain threaded</i></p>\n\n<p style=\"margin-left:22%;\">This is a domain cgroup that\nserves as the root of a threaded subtree. This cgroup type\nis also known as &quot;threaded root&quot;.</p>\n\n<p style=\"margin-left:11%;\"><i>domain invalid</i></p>\n\n<p style=\"margin-left:22%;\">This is a cgroup inside a\nthreaded subtree that is in an &quot;invalid&quot; state.\nProcesses can&rsquo;t be added to the cgroup, and\ncontrollers can&rsquo;t be enabled for the cgroup. The only\nthing that can be done with this cgroup (other than deleting\nit) is to convert it to a <i>threaded</i> cgroup by writing\nthe string <i>&quot;threaded&quot;</i> to the\n<i>cgroup.type</i> file.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The rationale\nfor the existence of this &quot;interim&quot; type during\nthe creation of a threaded subtree (rather than the kernel\nsimply immediately converting all cgroups under the threaded\nroot to the type <i>threaded</i>) is to allow for possible\nfuture extensions to the thread mode model</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Threaded\nversus domain controllers</b> <br>\nWith the addition of threads mode, cgroups v2 now\ndistinguishes two types of resource controllers:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>Threaded</i> controllers: these controllers support\nthread-granularity for resource control and can be enabled\ninside threaded subtrees, with the result that the\ncorresponding controller-interface files appear inside the\ncgroups in the threaded subtree. As at Linux 4.19, the\nfollowing controllers are threaded: <i>cpu</i>,\n<i>perf_event</i>, and <i>pids</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>Domain</i> controllers: these controllers support\nonly process granularity for resource control. From the\nperspective of a domain controller, all threads of a process\nare always in the same cgroup. Domain controllers\ncan&rsquo;t be enabled inside a threaded subtree.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Creating a\nthreaded subtree</b> <br>\nThere are two pathways that lead to the creation of a\nthreaded subtree. The first pathway proceeds as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">We write the string\n<i>&quot;threaded&quot;</i> to the <i>cgroup.type</i> file\nof a cgroup <i>y/z</i> that currently has the type\n<i>domain</i>. This has the following effects:</p></td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">*</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\"></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">The type of the cgroup\n<i>y/z</i> becomes <i>threaded</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>The type of the parent cgroup, <i>y</i>, becomes\n<i>domain threaded</i>. The parent cgroup is the root of a\nthreaded subtree (also known as the &quot;threaded\nroot&quot;).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>All other cgroups under <i>y</i> that were not already\nof type <i>threaded</i> (because they were inside already\nexisting threaded subtrees under the new threaded root) are\nconverted to type <i>domain invalid</i>. Any subsequently\ncreated cgroups under <i>y</i> will also have the type\n<i>domain invalid</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">We write the\nstring <i>&quot;threaded&quot;</i> to each of the <i>domain\ninvalid</i> cgroups under <i>y</i>, in order to convert them\nto the type <i>threaded</i>. As a consequence of this step,\nall threads under the threaded root now have the type\n<i>threaded</i> and the threaded subtree is now fully\nusable. The requirement to write <i>&quot;threaded&quot;</i>\nto each of these cgroups is somewhat cumbersome, but allows\nfor possible future extensions to the thread-mode model.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second way\nof creating a threaded subtree is as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">In an existing cgroup, <i>z</i>,\nthat currently has the type <i>domain</i>, we (1) enable one\nor more threaded controllers and (2) make a process a member\nof <i>z</i>. (These two steps can be done in either order.)\nThis has the following consequences:</p></td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">*</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\"></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">The type of <i>z</i> becomes\n<i>domain threaded</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>All of the descendant cgroups of <i>x</i> that were not\nalready of type <i>threaded</i> are converted to type\n<i>domain invalid</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">As before, we\nmake the threaded subtree usable by writing the string\n<i>&quot;threaded&quot;</i> to each of the <i>domain\ninvalid</i> cgroups under <i>y</i>, in order to convert them\nto the type <i>threaded</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One of the\nconsequences of the above pathways to creating a threaded\nsubtree is that the threaded root cgroup can be a parent\nonly to <i>threaded</i> (and <i>domain invalid</i>) cgroups.\nThe threaded root cgroup can&rsquo;t be a parent of a\n<i>domain</i> cgroups, and a <i>threaded</i> cgroup\ncan&rsquo;t have a sibling that is a <i>domain</i>\ncgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Using a\nthreaded subtree</b> <br>\nWithin a threaded subtree, threaded controllers can be\nenabled in each subgroup whose type has been changed to\n<i>threaded</i>; upon doing so, the corresponding controller\ninterface files appear in the children of that cgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process can\nbe moved into a threaded subtree by writing its PID to the\n<i>cgroup.procs</i> file in one of the cgroups inside the\ntree. This has the effect of making all of the threads in\nthe process members of the corresponding cgroup and makes\nthe process a member of the threaded subtree. The threads of\nthe process can then be spread across the threaded subtree\nby writing their thread IDs (see <a href=\"https://man.page/2/gettid\">gettid(2)</a>) to the\n<i>cgroup.threads</i> files in different cgroups inside the\nsubtree. The threads of a process must all reside in the\nsame threaded subtree.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As with writing\nto <i>cgroup.procs</i>, some containment rules apply when\nwriting to the <i>cgroup.threads</i> file:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The writer must have write\npermission on the cgroup.threads file in the destination\ncgroup.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The writer must have write permission on the\n<i>cgroup.procs</i> file in the common ancestor of the\nsource and destination cgroups. (In some cases, the common\nancestor may be the source or destination cgroup\nitself.)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The source and destination cgroups must be in the same\nthreaded subtree. (Outside a threaded subtree, an attempt to\nmove a thread by writing its thread ID to the\n<i>cgroup.threads</i> file in a different <i>domain</i>\ncgroup fails with the error <b>EOPNOTSUPP</b>.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cgroup.threads</i> file is present in each cgroup\n(including <i>domain</i> cgroups) and can be read in order\nto discover the set of threads that is present in the\ncgroup. The set of thread IDs obtained when reading this\nfile is not guaranteed to be ordered or free of\nduplicates.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cgroup.procs</i> file in the threaded root shows the PIDs\nof all processes that are members of the threaded subtree.\nThe <i>cgroup.procs</i> files in the other cgroups in the\nsubtree are not readable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Domain\ncontrollers can&rsquo;t be enabled in a threaded subtree; no\ncontroller-interface files appear inside the cgroups\nunderneath the threaded root. From the point of view of a\ndomain controller, threaded subtrees are invisible: a\nmultithreaded process inside a threaded subtree appears to a\ndomain controller as a process that resides in the threaded\nroot cgroup.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Within a\nthreaded subtree, the &quot;no internal processes&quot; rule\ndoes not apply: a cgroup can both contain member processes\n(or thread) and exercise controllers on child cgroups.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Rules for\nwriting to cgroup.type and creating threaded subtrees</b>\n<br>\nA number of rules apply when writing to the\n<i>cgroup.type</i> file:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Only the string\n<i>&quot;threaded&quot;</i> may be written. In other words,\nthe only explicit transition that is possible is to convert\na <i>domain</i> cgroup to type <i>threaded</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The effect of writing <i>&quot;threaded&quot;</i>\ndepends on the current value in <i>cgroup.type</i>, as\nfollows:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:15%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\"></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\"><i>domain</i> or <i>domain\nthreaded</i>: start the creation of a threaded subtree\n(whose root is the parent of this cgroup) via the first of\nthe pathways described above;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>&bull;</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p><i>domain&nbsp;invalid</i>: convert this cgroup (which\nis inside a threaded subtree) to a usable (i.e.,\n<i>threaded</i>) state;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>&bull;</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p><i>threaded</i>: no effect (a &quot;no-op&quot;).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">We can&rsquo;t\nwrite to a <i>cgroup.type</i> file if the parent&rsquo;s\ntype is <i>domain invalid</i>. In other words, the cgroups\nof a threaded subtree must be converted to the\n<i>threaded</i> state in a top-down manner.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are also\nsome constraints that must be satisfied in order to create a\nthreaded subtree rooted at the cgroup <i>x</i>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">There can be no member processes\nin the descendant cgroups of <i>x</i>. (The cgroup <i>x</i>\ncan itself have member processes.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>No domain controllers may be enabled in <i>x</i>&rsquo;s\n<i>cgroup.subtree_control</i> file.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If any of the\nabove constraints is violated, then an attempt to write\n<i>&quot;threaded&quot;</i> to a <i>cgroup.type</i> file\nfails with the error <b>ENOTSUP</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\n&quot;domain threaded&quot; cgroup type</b> <br>\nAccording to the pathways described above, the type of a\ncgroup can change to <i>domain threaded</i> in either of the\nfollowing cases:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The string\n<i>&quot;threaded&quot;</i> is written to a child\ncgroup.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>A threaded controller is enabled inside the cgroup and a\nprocess is made a member of the cgroup.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A <i>domain\nthreaded</i> cgroup, <i>x</i>, can revert to the type\n<i>domain</i> if the above conditions no longer hold\ntrue&mdash;that is, if all <i>threaded</i> child cgroups of\n<i>x</i> are removed and either <i>x</i> no longer has\nthreaded controllers enabled or no longer has member\nprocesses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a\n<i>domain threaded</i> cgroup <i>x</i> reverts to the type\n<i>domain</i>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">All <i>domain invalid</i>\ndescendants of <i>x</i> that are not in lower-level threaded\nsubtrees revert to the type <i>domain</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The root cgroups in any lower-level threaded subtrees\nrevert to the type <i>domain threaded</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Exceptions\nfor the root cgroup</b> <br>\nThe root cgroup of the v2 hierarchy is treated\nexceptionally: it can be the parent of both <i>domain</i>\nand <i>threaded</i> cgroups. If the string\n<i>&quot;threaded&quot;</i> is written to the\n<i>cgroup.type</i> file of one of the children of the root\ncgroup, then</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The type of that cgroup becomes\n<i>threaded</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The type of any descendants of that cgroup that are not\npart of lower-level threaded subtrees changes to <i>domain\ninvalid</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that in\nthis case, there is no cgroup whose type becomes <i>domain\nthreaded</i>. (Notionally, the root cgroup can be considered\nas the threaded root for the cgroup whose type was changed\nto <i>threaded</i>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The aim of this\nexceptional treatment for the root cgroup is to allow a\nthreaded cgroup that employs the <i>cpu</i> controller to be\nplaced as high as possible in the hierarchy, so as to\nminimize the (small) cost of traversing the cgroup\nhierarchy.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The cgroups\nv2 &quot;cpu&quot; controller and realtime threads</b> <br>\nAs at Linux 4.19, the cgroups v2 <i>cpu</i> controller does\nnot support control of realtime threads (specifically\nthreads scheduled under any of the policies\n<b>SCHED_FIFO</b>, <b>SCHED_RR</b>, described\n<b>SCHED_DEADLINE</b>; see <a href=\"https://man.page/7/sched\">sched(7)</a>). Therefore, the\n<i>cpu</i> controller can be enabled in the root cgroup only\nif all realtime threads are in the root cgroup. (If there\nare realtime threads in nonroot cgroups, then a\n<a href=\"https://man.page/2/write\">write(2)</a> of the string <i>&quot;+cpu&quot;</i> to the\n<i>cgroup.subtree_control</i> file fails with the error\n<b>EINVAL</b>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On some\nsystems, <a href=\"https://man.page/1/systemd\">systemd(1)</a> places certain realtime threads\nin nonroot cgroups in the v2 hierarchy. On such systems,\nthese threads must first be moved to the root cgroup before\nthe <i>cpu</i> controller can be enabled.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nerrors can occur for <a href=\"https://man.page/2/mount\">mount(2)</a>:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>EBUSY</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">An attempt to mount a cgroup\nversion 1 filesystem specified neither the <i>name=</i>\noption (to mount a named hierarchy) nor a controller name\n(or <i>all</i>).</p></td></tr>\n</table>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A child process\ncreated via <a href=\"https://man.page/2/fork\">fork(2)</a> inherits its parent&rsquo;s\ncgroup memberships. A process&rsquo;s cgroup memberships are\npreserved across <a href=\"https://man.page/2/execve\">execve(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/clone3\">clone3(2)</a> <b>CLONE_INTO_CGROUP</b> flag can be used\nto create a child process that begins its life in a\ndifferent version 2 cgroup from the parent process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc\nfiles</b> <i><br>\n/proc/cgroups</i> (since Linux 2.6.24)</p>\n\n<p style=\"margin-left:22%;\">This file contains information\nabout the controllers that are compiled into the kernel. An\nexample of the contents of this file (reformatted for\nreadability) is the following:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">#subsys_name\nhierarchy num_cgroups enabled <br>\ncpuset 4 1 1 <br>\ncpu 8 1 1 <br>\ncpuacct 8 1 1 <br>\nblkio 6 1 1 <br>\nmemory 3 1 1 <br>\ndevices 10 84 1 <br>\nfreezer 7 1 1 <br>\nnet_cls 9 1 1 <br>\nperf_event 5 1 1 <br>\nnet_prio 9 1 1 <br>\nhugetlb 0 1 0 <br>\npids 2 1 1</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The fields in\nthis file are, from left to right:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>The name of the controller.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>The unique ID of the cgroup hierarchy on which this\ncontroller is mounted. If multiple cgroups v1 controllers\nare bound to the same hierarchy, then each will show the\nsame hierarchy ID in this field. The value in this field\nwill be 0 if:</p></td></tr>\n</table>\n\n<p style=\"margin-left:29%; margin-top: 1em\">a)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"10%\"></td>\n<td width=\"2%\"></td>\n<td width=\"66%\">\n\n\n<p style=\"margin-top: 1em\">the controller is not mounted on\na cgroups v1 hierarchy;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"10%\">\n\n\n<p>b)</p></td>\n<td width=\"2%\"></td>\n<td width=\"66%\">\n\n\n<p>the controller is bound to the cgroups v2 single unified\nhierarchy; or</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"10%\">\n\n\n<p>c)</p></td>\n<td width=\"2%\"></td>\n<td width=\"66%\">\n\n\n<p>the controller is disabled (see below).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"10%\">\n\n\n<p>3.</p></td>\n<td width=\"2%\"></td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:26%; margin-top: 1em\">The number of\ncontrol groups in this hierarchy using this controller.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">4.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\">This field contains the value 1\nif this controller is enabled, or 0 if it has been disabled\n(via the <i>cgroup_disable</i> kernel command-line boot\nparameter).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>/proc/[pid]/cgroup</i>\n(since Linux 2.6.24)</p>\n\n<p style=\"margin-left:22%;\">This file describes control\ngroups to which the process with the corresponding PID\nbelongs. The displayed information differs for cgroups\nversion 1 and version 2 hierarchies.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For each cgroup\nhierarchy of which the process is a member, there is one\nentry containing three colon-separated fields:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">hierarchy-ID:controller-list:cgroup-path</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For\nexample:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">5:cpuacct,cpu,cpuset:/daemons</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\ncolon-separated fields are, from left to right:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>For cgroups version 1 hierarchies, this field contains a\nunique hierarchy ID number that can be matched to a\nhierarchy ID in <i>/proc/cgroups</i>. For the cgroups\nversion 2 hierarchy, this field contains the value 0.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>For cgroups version 1 hierarchies, this field contains a\ncomma-separated list of the controllers bound to the\nhierarchy. For the cgroups version 2 hierarchy, this field\nis empty.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>This field contains the pathname of the control group in\nthe hierarchy to which the process belongs. This pathname is\nrelative to the mount point of the hierarchy.</p></td></tr>\n</table>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/sys/kernel/cgroup\nfiles</b> <i><br>\n/sys/kernel/cgroup/delegate</i> (since Linux 4.15)</p>\n\n<p style=\"margin-left:22%;\">This file exports a list of the\ncgroups v2 files (one per line) that are delegatable (i.e.,\nwhose ownership should be changed to the user ID of the\ndelegatee). In the future, the set of delegatable files may\nchange or grow, and this file provides a way for the kernel\nto inform user-space applications of which files must be\ndelegated. As at Linux 4.15, one sees the following when\ninspecting this file:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">$ <b>cat\n/sys/kernel/cgroup/delegate</b> <br>\ncgroup.procs <br>\ncgroup.subtree_control <br>\ncgroup.threads</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/kernel/cgroup/features</i>\n(since Linux 4.15)</p>\n\n<p style=\"margin-left:22%;\">Over time, the set of cgroups\nv2 features that are provided by the kernel may change or\ngrow, or some features may not be enabled by default. This\nfile provides a way for user-space applications to discover\nwhat features the running kernel supports and has enabled.\nFeatures are listed one per line:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">$ <b>cat\n/sys/kernel/cgroup/features</b> <br>\nnsdelegate <br>\nmemory_localevents</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The entries\nthat can appear in this file are: <i><br>\nmemory_localevents</i> (since Linux 5.2)</p>\n\n<p style=\"margin-left:32%;\">The kernel supports the\n<i>memory_localevents</i> mount option.</p>\n\n<p style=\"margin-left:22%;\"><i>nsdelegate</i> (since Linux\n4.15)</p>\n\n<p style=\"margin-left:32%;\">The kernel supports the\n<i>nsdelegate</i> mount option.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/prlimit\">prlimit(1)</a>,\n<a href=\"https://man.page/1/systemd\">systemd(1)</a>, <a href=\"https://man.page/1/systemd-cgls\">systemd-cgls(1)</a>,\n<a href=\"https://man.page/1/systemd-cgtop\">systemd-cgtop(1)</a>, <a href=\"https://man.page/2/clone\">clone(2)</a>,\n<a href=\"https://man.page/2/ioprio_set\">ioprio_set(2)</a>, <a href=\"https://man.page/2/perf_event_open\">perf_event_open(2)</a>,\n<a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>, <a href=\"https://man.page/7/cgroup_namespaces\">cgroup_namespaces(7)</a>,\n<a href=\"https://man.page/7/cpuset\">cpuset(7)</a>, <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>, <a href=\"https://man.page/7/sched\">sched(7)</a>,\n<a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\nsource file\n<i>Documentation/admin-guide/cgroup-v2.rst</i>.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CGROUPS VERSION 1\">CGROUPS VERSION 1</a>","<a href=\"#CGROUPS VERSION 2\">CGROUPS VERSION 2</a>","<a href=\"#CGROUPS DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER\">CGROUPS DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER</a>","<a href=\"#CGROUPS VERSION 2 THREAD MODE\">CGROUPS VERSION 2 THREAD MODE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}