{"name":"gitnamespaces","description":"gitnamespaces - Git namespaces","body":"\n\n<h1 align=\"center\">GITNAMESPACES</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">gitnamespaces -\nGit namespaces</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">GIT_NAMESPACE=&lt;namespace&gt;\n<i>git upload-pack</i> <br>\nGIT_NAMESPACE=&lt;namespace&gt; <i>git receive-pack</i></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Git supports\ndividing the refs of a single repository into multiple\nnamespaces, each of which has its own branches, tags, and\nHEAD. Git can expose each namespace as an independent\nrepository to pull from and push to, while sharing the\nobject store, and exposing all the refs to operations such\nas <a href=\"https://man.page/1/git-gc\">git-gc(1)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Storing\nmultiple repositories as namespaces of a single repository\navoids storing duplicate copies of the same objects, such as\nwhen storing multiple branches of the same source. The\nalternates mechanism provides similar support for avoiding\nduplicates, but alternates do not prevent duplication\nbetween new objects added to the repositories without\nongoing maintenance, while namespaces do.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To specify a\nnamespace, set the <b>GIT_NAMESPACE</b> environment variable\nto the namespace. For each ref namespace, Git stores the\ncorresponding refs in a directory under\n<b>refs/namespaces/</b>. For example,\n<b>GIT_NAMESPACE=foo</b> will store refs under\n<b>refs/namespaces/foo/</b>. You can also specify namespaces\nvia the <b>--namespace</b> option to <a href=\"https://man.page/1/git\">git(1)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\nnamespaces which include a <b>/</b> will expand to a\nhierarchy of namespaces; for example,\n<b>GIT_NAMESPACE=foo/bar</b> will store refs under\n<b>refs/namespaces/foo/refs/namespaces/bar/</b>. This makes\npaths in <b>GIT_NAMESPACE</b> behave hierarchically, so that\ncloning with <b>GIT_NAMESPACE=foo/bar</b> produces the same\nresult as cloning with <b>GIT_NAMESPACE=foo</b> and cloning\nfrom that repo with <b>GIT_NAMESPACE=bar</b>. It also avoids\nambiguity with strange namespace paths such as\n<b>foo/refs/heads/</b>, which could otherwise generate\ndirectory/file conflicts within the <b>refs</b>\ndirectory.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/git-upload-pack\">git-upload-pack(1)</a>\nand <a href=\"https://man.page/1/git-receive-pack\">git-receive-pack(1)</a> rewrite the names of refs as\nspecified by <b>GIT_NAMESPACE</b>. git-upload-pack and\ngit-receive-pack will ignore all references outside the\nspecified namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The smart HTTP\nserver, <a href=\"https://man.page/1/git-http-backend\">git-http-backend(1)</a>, will pass GIT_NAMESPACE\nthrough to the backend programs; see\n<a href=\"https://man.page/1/git-http-backend\">git-http-backend(1)</a> for sample configuration to\nexpose repository namespaces as repositories.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For a simple\nlocal test, you can use <a href=\"https://man.page/1/git-remote-ext\">git-remote-ext(1)</a>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git clone\next::'git --namespace=foo %s /tmp/prefixed.git'</p>\n\n<h2>SECURITY\n<a name=\"SECURITY\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fetch and\npush protocols are not designed to prevent one side from\nstealing data from the other repository that was not\nintended to be shared. If you have private data that you\nneed to protect from a malicious peer, your best option is\nto store it in another repository. This applies to both\nclients and servers. In particular, namespaces on a server\nare not effective for read access control; you should only\ngrant read access to a namespace to clients that you would\ntrust with read access to the entire repository.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The known\nattack vectors are as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">1. The victim\nsends &quot;have&quot; lines advertising the IDs of objects\nit has that are not explicitly intended to be shared but can\nbe used to optimize the transfer if the peer also has them.\nThe attacker chooses an object ID X to steal and sends a ref\nto X, but isn&rsquo;t required to send the content of X\nbecause the victim already has it. Now the victim believes\nthat the attacker has X, and it sends the content of X back\nto the attacker later. (This attack is most straightforward\nfor a client to perform on a server, by creating a ref to X\nin the namespace the client has access to and then fetching\nit. The most likely way for a server to perform it on a\nclient is to &quot;merge&quot; X into a public branch and\nhope that the user does additional work on this branch and\npushes it back to the server without noticing the\nmerge.)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">2. As in #1,\nthe attacker chooses an object ID X to steal. The victim\nsends an object Y that the attacker already has, and the\nattacker falsely claims to have X and not Y, so the victim\nsends Y as a delta against X. The delta reveals regions of X\nthat are similar to Y to the attacker.</p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Part of the\n<a href=\"https://man.page/1/git\">git(1)</a> suite</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SECURITY\">SECURITY</a>","<a href=\"#GIT\">GIT</a>"],"level":7}