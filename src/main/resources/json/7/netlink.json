{"name":"netlink","description":"netlink -\ncommunication between kernel and user space (AF_NETLINK)","body":"\n\n<h1 align=\"center\">NETLINK</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">netlink -\ncommunication between kernel and user space (AF_NETLINK)</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;asm/types.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;linux/netlink.h&gt;</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>netlink_socket\n= socket(AF_NETLINK,</b> <i>socket_type</i><b>,</b>\n<i>netlink_family</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Netlink is used\nto transfer information between the kernel and user-space\nprocesses. It consists of a standard sockets-based interface\nfor user space processes and an internal kernel API for\nkernel modules. The internal kernel interface is not\ndocumented in this manual page. There is also an obsolete\nnetlink interface via netlink character devices; this\ninterface is not documented here and is provided only for\nbackward compatibility.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Netlink is a\ndatagram-oriented service. Both <b>SOCK_RAW</b> and\n<b>SOCK_DGRAM</b> are valid values for <i>socket_type</i>.\nHowever, the netlink protocol does not distinguish between\ndatagram and raw sockets.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>netlink_family</i>\nselects the kernel module or netlink group to communicate\nwith. The currently assigned netlink families are: <b><br>\nNETLINK_ROUTE</b></p>\n\n<p style=\"margin-left:22%;\">Receives routing and link\nupdates and may be used to modify the routing tables (both\nIPv4 and IPv6), IP addresses, link parameters, neighbor\nsetups, queueing disciplines, traffic classes and packet\nclassifiers (see <a href=\"https://man.page/7/rtnetlink\">rtnetlink(7)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_W1</b> (Linux 2.6.13\nto 2.16.17)</p>\n\n<p style=\"margin-left:22%;\">Messages from 1-wire\nsubsystem.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_USERSOCK</b></p>\n\n<p style=\"margin-left:22%;\">Reserved for user-mode socket\nprotocols.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_FIREWALL</b> (up to\nand including Linux 3.4)</p>\n\n<p style=\"margin-left:22%;\">Transport IPv4 packets from\nnetfilter to user space. Used by <i>ip_queue</i> kernel\nmodule. After a long period of being declared obsolete (in\nfavor of the more advanced <i>nfnetlink_queue</i> feature),\n<b>NETLINK_FIREWALL</b> was removed in Linux 3.5.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_SOCK_DIAG</b> (since\nLinux 3.3)</p>\n\n<p style=\"margin-left:22%;\">Query information about sockets\nof various protocol families from the kernel (see\n<a href=\"https://man.page/7/sock_diag\">sock_diag(7)</a>).</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_INET_DIAG</b> (since\nLinux 2.6.14)</p>\n\n<p style=\"margin-left:22%;\">An obsolete synonym for\n<b>NETLINK_SOCK_DIAG</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_NFLOG</b> (up to and\nincluding Linux 3.16)</p>\n\n<p style=\"margin-left:22%;\">Netfilter/iptables ULOG.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_XFRM</b></p>\n\n<p style=\"margin-left:22%;\">IPsec.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_SELINUX</b> (since\nLinux 2.6.4)</p>\n\n<p style=\"margin-left:22%;\">SELinux event\nnotifications.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_ISCSI</b> (since\nLinux 2.6.15)</p>\n\n<p style=\"margin-left:22%;\">Open-iSCSI.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_AUDIT</b> (since\nLinux 2.6.6)</p>\n\n<p style=\"margin-left:22%;\">Auditing.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_FIB_LOOKUP</b>\n(since Linux 2.6.13)</p>\n\n<p style=\"margin-left:22%;\">Access to FIB lookup from user\nspace.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_CONNECTOR</b> (since\nLinux 2.6.14)</p>\n\n<p style=\"margin-left:22%;\">Kernel connector. See\n<i>Documentation/driver-api/connector.rst</i> (or\n<i>/Documentation/connector/connector.*</i> in kernel 5.2\nand earlier) in the Linux kernel source tree for further\ninformation.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_NETFILTER</b> (since\nLinux 2.6.14)</p>\n\n<p style=\"margin-left:22%;\">Netfilter subsystem.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_SCSITRANSPORT</b>\n(since Linux 2.6.19)</p>\n\n<p style=\"margin-left:22%;\">SCSI Transports.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_RDMA</b> (since\nLinux 3.0)</p>\n\n<p style=\"margin-left:22%;\">Infiniband RDMA.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_IP6_FW</b> (up to\nand including Linux 3.4)</p>\n\n<p style=\"margin-left:22%;\">Transport IPv6 packets from\nnetfilter to user space. Used by <i>ip6_queue</i> kernel\nmodule.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_DNRTMSG</b></p>\n\n<p style=\"margin-left:22%;\">DECnet routing messages.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_KOBJECT_UEVENT</b>\n(since Linux 2.6.10)</p>\n\n<p style=\"margin-left:22%;\">Kernel messages to user\nspace.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_GENERIC</b> (since\nLinux 2.6.15)</p>\n\n<p style=\"margin-left:22%;\">Generic netlink family for\nsimplified netlink usage.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_CRYPTO</b> (since\nLinux 3.2)</p>\n\n<p style=\"margin-left:22%;\">Netlink interface to request\ninformation about ciphers registered with the kernel crypto\nAPI as well as allow configuration of the kernel crypto\nAPI.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Netlink\nmessages consist of a byte stream with one or multiple\n<i>nlmsghdr</i> headers and associated payload. The byte\nstream should be accessed only with the standard\n<b>NLMSG_*</b> macros. See <a href=\"https://man.page/3/netlink\">netlink(3)</a> for further\ninformation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In multipart\nmessages (multiple <i>nlmsghdr</i> headers with associated\npayload in one byte stream) the first and all following\nheaders have the <b>NLM_F_MULTI</b> flag set, except for the\nlast header which has the type <b>NLMSG_DONE</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After each\n<i>nlmsghdr</i> the payload follows.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct nlmsghdr\n{ <br>\n__u32 nlmsg_len; /* Length of message including header */\n<br>\n__u16 nlmsg_type; /* Type of message content */ <br>\n__u16 nlmsg_flags; /* Additional flags */ <br>\n__u32 nlmsg_seq; /* Sequence number */ <br>\n__u32 nlmsg_pid; /* Sender port ID */ <br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>nlmsg_type</i>\ncan be one of the standard message types: <b>NLMSG_NOOP</b>\nmessage is to be ignored, <b>NLMSG_ERROR</b> message signals\nan error and the payload contains an <i>nlmsgerr</i>\nstructure, <b>NLMSG_DONE</b> message terminates a multipart\nmessage.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct nlmsgerr\n{ <br>\nint error; /* Negative errno or 0 for acknowledgements */\n<br>\nstruct nlmsghdr msg; /* Message header that caused the error\n*/ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A netlink\nfamily usually specifies more message types, see the\nappropriate manual pages for that, for example,\n<a href=\"https://man.page/7/rtnetlink\">rtnetlink(7)</a> for <b>NETLINK_ROUTE</b>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3527211.png\" alt=\"Image grohtml-3527211.png\"></p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3527212.png\" alt=\"Image grohtml-3527212.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\n<b>NLM_F_ATOMIC</b> requires the <b>CAP_NET_ADMIN</b>\ncapability or an effective UID of 0.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3527213.png\" alt=\"Image grohtml-3527213.png\"></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>nlmsg_seq</i>\nand <i>nlmsg_pid</i> are used to track messages.\n<i>nlmsg_pid</i> shows the origin of the message. Note that\nthere isn&rsquo;t a 1:1 relationship between\n<i>nlmsg_pid</i> and the PID of the process if the message\noriginated from a netlink socket. See the <b>ADDRESS\nFORMATS</b> section for further information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both\n<i>nlmsg_seq</i> and <i>nlmsg_pid</i> are opaque to netlink\ncore.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Netlink is not\na reliable protocol. It tries its best to deliver a message\nto its destination(s), but may drop messages when an\nout-of-memory condition or other error occurs. For reliable\ntransfer the sender can request an acknowledgement from the\nreceiver by setting the <b>NLM_F_ACK</b> flag. An\nacknowledgment is an <b>NLMSG_ERROR</b> packet with the\nerror field set to 0. The application must generate\nacknowledgements for received messages itself. The kernel\ntries to send an <b>NLMSG_ERROR</b> message for every failed\npacket. A user process should follow this convention\ntoo.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However,\nreliable transmissions from kernel to user are impossible in\nany case. The kernel can&rsquo;t send a netlink message if\nthe socket buffer is full: the message will be dropped and\nthe kernel and the user-space process will no longer have\nthe same view of kernel state. It is up to the application\nto detect when this happens (via the <b>ENOBUFS</b> error\nreturned by <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>) and resynchronize.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Address\nformats</b> <br>\nThe <i>sockaddr_nl</i> structure describes a netlink client\nin user space or in the kernel. A <i>sockaddr_nl</i> can be\neither unicast (only sent to one peer) or sent to netlink\nmulticast groups (<i>nl_groups</i> not equal 0).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nsockaddr_nl { <br>\nsa_family_t nl_family; /* AF_NETLINK */ <br>\nunsigned short nl_pad; /* Zero */ <br>\npid_t nl_pid; /* Port ID */ <br>\n__u32 nl_groups; /* Multicast groups mask */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>nl_pid</i>\nis the unicast address of netlink socket. It&rsquo;s always\n0 if the destination is in the kernel. For a user-space\nprocess, <i>nl_pid</i> is usually the PID of the process\nowning the destination socket. However, <i>nl_pid</i>\nidentifies a netlink socket, not a process. If a process\nowns several netlink sockets, then <i>nl_pid</i> can be\nequal to the process ID only for at most one socket. There\nare two ways to assign <i>nl_pid</i> to a netlink socket. If\nthe application sets <i>nl_pid</i> before calling\n<a href=\"https://man.page/2/bind\">bind(2)</a>, then it is up to the application to make\nsure that <i>nl_pid</i> is unique. If the application sets\nit to 0, the kernel takes care of assigning it. The kernel\nassigns the process ID to the first netlink socket the\nprocess opens and assigns a unique <i>nl_pid</i> to every\nnetlink socket that the process subsequently creates.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>nl_groups</i>\nis a bit mask with every bit representing a netlink group\nnumber. Each netlink family has a set of 32 multicast\ngroups. When <a href=\"https://man.page/2/bind\">bind(2)</a> is called on the socket, the\n<i>nl_groups</i> field in the <i>sockaddr_nl</i> should be\nset to a bit mask of the groups which it wishes to listen\nto. The default value for this field is zero which means\nthat no multicasts will be received. A socket may multicast\nmessages to any of the multicast groups by setting\n<i>nl_groups</i> to a bit mask of the groups it wishes to\nsend to when it calls <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> or does a\n<a href=\"https://man.page/2/connect\">connect(2)</a>. Only processes with an effective UID of 0\nor the <b>CAP_NET_ADMIN</b> capability may send or listen to\na netlink multicast group. Since Linux 2.6.13, messages\ncan&rsquo;t be broadcast to multiple groups. Any replies to\na message received for a multicast group should be sent back\nto the sending PID and the multicast group. Some Linux\nkernel subsystems may additionally allow other users to send\nand/or receive messages. As at Linux 3.0, the\n<b>NETLINK_KOBJECT_UEVENT</b>, <b>NETLINK_GENERIC</b>,\n<b>NETLINK_ROUTE</b>, and <b>NETLINK_SELINUX</b> groups\nallow other users to receive messages. No groups allow other\nusers to send messages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Socket\noptions</b> <br>\nTo set or get a netlink socket option, call\n<a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> to read or <a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a> to\nwrite the option with the option level argument set to\n<b>SOL_NETLINK</b>. Unless otherwise noted, <i>optval</i> is\na pointer to an <i>int</i>. <b><br>\nNETLINK_PKTINFO</b> (since Linux 2.6.14)</p>\n\n<p style=\"margin-left:22%;\">Enable <b>nl_pktinfo</b>\ncontrol messages for received packets to get the extended\ndestination group number.</p>\n\n\n<p style=\"margin-left:11%;\"><b>NETLINK_ADD_MEMBERSHIP</b>,&nbsp;<b>NETLINK_DROP_MEMBERSHIP</b>\n(since Linux 2.6.14)</p>\n\n<p style=\"margin-left:22%;\">Join/leave a group specified by\n<i>optval</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>NETLINK_LIST_MEMBERSHIPS</b>\n(since Linux 4.2)</p>\n\n<p style=\"margin-left:22%;\">Retrieve all groups a socket is\na member of. <i>optval</i> is a pointer to <b>__u32</b> and\n<i>optlen</i> is the size of the array. The array is filled\nwith the full membership set of the socket, and the required\narray size is returned in <i>optlen</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_BROADCAST_ERROR</b>\n(since Linux 2.6.30)</p>\n\n<p style=\"margin-left:22%;\">When not set,\n<b>netlink_broadcast()</b> only reports <b>ESRCH</b> errors\nand silently ignore <b>ENOBUFS</b> errors.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_NO_ENOBUFS</b>\n(since Linux 2.6.30)</p>\n\n<p style=\"margin-left:22%;\">This flag can be used by\nunicast and broadcast listeners to avoid receiving\n<b>ENOBUFS</b> errors.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_LISTEN_ALL_NSID</b>\n(since Linux 4.2)</p>\n\n<p style=\"margin-left:22%;\">When set, this socket will\nreceive netlink notifications from all network namespaces\nthat have an <i>nsid</i> assigned into the network namespace\nwhere the socket has been opened. The <i>nsid</i> is sent to\nuser space via an ancillary data.</p>\n\n<p style=\"margin-left:11%;\"><b>NETLINK_CAP_ACK</b> (since\nLinux 4.2)</p>\n\n<p style=\"margin-left:22%;\">The kernel may fail to allocate\nthe necessary room for the acknowledgment message back to\nuser space. This option trims off the payload of the\noriginal netlink message. The netlink message header is\nstill included, so the user can guess from the sequence\nnumber which message triggered the acknowledgment.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The socket\ninterface to netlink first appeared Linux 2.2.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux 2.0\nsupported a more primitive device-based netlink interface\n(which is still available as a compatibility option). This\nobsolete interface is not described here.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is often\nbetter to use netlink via <i>libnetlink</i> or <i>libnl</i>\nthan via the low-level kernel interface.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This manual\npage is not complete.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nexample creates a <b>NETLINK_ROUTE</b> netlink socket which\nwill listen to the <b>RTMGRP_LINK</b> (network interface\ncreate/delete/up/down events) and <b>RTMGRP_IPV4_IFADDR</b>\n(IPv4 addresses add/delete events) multicast groups.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nsockaddr_nl sa;</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">memset(&amp;sa,\n0, sizeof(sa)); <br>\nsa.nl_family = AF_NETLINK; <br>\nsa.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">fd =\nsocket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE); <br>\nbind(fd, (struct sockaddr *) &amp;sa, sizeof(sa));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The next\nexample demonstrates how to send a netlink message to the\nkernel (pid 0). Note that the application must take care of\nmessage sequence numbers in order to reliably track\nacknowledgements.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct nlmsghdr\n*nh; /* The nlmsghdr with payload to send */ <br>\nstruct sockaddr_nl sa; <br>\nstruct iovec iov = { nh, nh-&gt;nlmsg_len }; <br>\nstruct msghdr msg;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">msg = {\n&amp;sa, sizeof(sa), &amp;iov, 1, NULL, 0, 0 }; <br>\nmemset(&amp;sa, 0, sizeof(sa)); <br>\nsa.nl_family = AF_NETLINK; <br>\nnh-&gt;nlmsg_pid = 0; <br>\nnh-&gt;nlmsg_seq = ++sequence_number; <br>\n/* Request an ack from kernel by setting NLM_F_ACK */ <br>\nnh-&gt;nlmsg_flags |= NLM_F_ACK;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sendmsg(fd,\n&amp;msg, 0);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And the last\nexample is about reading netlink message.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int len; <br>\n/* 8192 to avoid message truncation on platforms with <br>\npage size &gt; 4096 */ <br>\nstruct nlmsghdr buf[8192/sizeof(struct nlmsghdr)]; <br>\nstruct iovec iov = { buf, sizeof(buf) }; <br>\nstruct sockaddr_nl sa; <br>\nstruct msghdr msg; <br>\nstruct nlmsghdr *nh;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">msg = {\n&amp;sa, sizeof(sa), &amp;iov, 1, NULL, 0, 0 }; <br>\nlen = recvmsg(fd, &amp;msg, 0);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for (nh =\n(struct nlmsghdr *) buf; NLMSG_OK (nh, len); <br>\nnh = NLMSG_NEXT (nh, len)) { <br>\n/* The end of multipart message */ <br>\nif (nh-&gt;nlmsg_type == NLMSG_DONE) <br>\nreturn;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(nh-&gt;nlmsg_type == NLMSG_ERROR) <br>\n/* Do some error handling */ <br>\n...</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Continue\nwith parsing payload */ <br>\n... <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/cmsg\">cmsg(3)</a>,\n<a href=\"https://man.page/3/netlink\">netlink(3)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/rtnetlink\">rtnetlink(7)</a>, <a href=\"https://man.page/7/sock_diag\">sock_diag(7)</a> <br>\n\n<a href=\"ftp://ftp.inr.ac.ru/ip-routing/iproute2*\">information\nabout libnetlink</a> <br>\n<a href=\"http://www.infradead.org/~tgr/libnl/\">information\nabout libnl</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">RFC 3549\n&quot;Linux Netlink as an IP Services Protocol&quot;</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}