{"name":"tc-hfsc","description":"tc-hfcs -\nHierarchical Fair Service Curve\n\n<h2>HISTORY &amp; INTRODUCTION\n<a name=\"HISTORY &amp; INTRODUCTION\"></a>\n</h2>\n\n\nHFSC\n(Hierarchical Fair Service Curve) is a network packet\nscheduling algorithm that was first presented at\nSIGCOMM&rsquo;97. Developed as a part of ALTQ (ALTernative\nQueuing) on NetBSD, found its way quickly to other BSD\nsystems, and then a few years ago became part of the linux\nkernel. Still, it&rsquo;s not the most popular scheduling\nalgorithm - especially if compared to HTB - and it&rsquo;s\nnot well documented for the enduser. This introduction aims\nto explain how HFSC works without using too much math\n(although some math it will be inevitable).\n\nIn short HFSC\naims to:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>1)</b></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>guarantee precise bandwidth and delay allocation for all\nleaf classes (realtime criterion)</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>2)</b></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>allocate excess bandwidth fairly as specified by class\nhierarchy (linkshare &amp; upperlimit criterion)</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>3)</b></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>minimize any discrepancy between the service curve and\nthe actual amount of service provided during linksharing</td></tr>\n</table>\n\nThe main\n&quot;selling&quot; point of HFSC is feature <b>(1)</b>,\nwhich is achieved by using nonlinear service curves (more\nabout what it actually is later). This is particularly\nuseful in VoIP or games, where not only a guarantee of\nconsistent bandwidth is important, but also limiting the\ninitial delay of a data stream. Note that it matters only\nfor leaf classes (where the actual queues are) - thus class\nhierarchy is ignored in the realtime case.\n\nFeature\n<b>(2)</b> is well, obvious - any algorithm featuring class\nhierarchy (such as HTB or CBQ) strives to achieve that. HFSC\ndoes that well, although you might end with unusual\nsituations, if you define service curves carelessly - see\nsection CORNER CASES for examples.\n\nFeature\n<b>(3)</b> is mentioned due to the nature of the problem.\nThere may be situations where it&rsquo;s either not possible\nto guarantee service of all curves at the same time, and/or\nit&rsquo;s impossible to do so fairly. Both will be\nexplained later. Note that this is mainly related to\ninterior (aka aggregate) classes, as the leafs are already\nhandled by <b>(1)</b>. Still, it&rsquo;s perfectly possible\nto create a leaf class without realtime service, and in such\na case the caveats will naturally extend to leaf classes as\nwell.\n\n<h2>ABBREVIATIONS\n<a name=\"ABBREVIATIONS\"></a>\n</h2>\n\n\nFor the\nremaining part of the document, we&rsquo;ll use following\nshortcuts:\n\n<p style=\"margin-left:17%; margin-top: 1em\">RT - realtime\n<br>\nLS - linkshare <br>\nUL - upperlimit <br>\nSC - service curve\n\n<h2>BASICS OF HFSC\n<a name=\"BASICS OF HFSC\"></a>\n</h2>\n\n\nTo understand\nhow HFSC works, we must first introduce a service curve.\nOverall, it&rsquo;s a nondecreasing function of some time\nunit, returning the amount of service (an allowed or\nallocated amount of bandwidth) at some specific point in\ntime. The purpose of it should be subconsciously obvious: if\na class was allowed to transfer not less than the amount\nspecified by its service curve, then the service curve is\nnot violated.\n\nStill, we need\nmore elaborate criterion than just the above (although in\nthe most generic case it can be reduced to it). The\ncriterion has to take two things into account:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">idling periods</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>the ability to &quot;look back&quot;, so if during\ncurrent active period the service curve is violated, maybe\nit isn&rsquo;t if we count excess bandwidth received during\nearlier active period(s)</td></tr>\n</table>\n\nLet&rsquo;s\ndefine the criterion as follows:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p style=\"margin-top: 1em\"><b>(1)</b></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">For each t1, there must exist t0\nin set B, so S(t1-t0)&nbsp;&lt;=&nbsp;w(t0,t1)</td></tr>\n</table>\n\nHere\n&rsquo;w&rsquo; denotes the amount of service received\nduring some time period between t0 and t1. B is a set of all\ntimes, where a session becomes active after idling period\n(further denoted as &rsquo;becoming backlogged&rsquo;). For\na clearer picture, imagine two situations:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\"><b>a)</b></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">our session was active during\ntwo periods, with a small time gap between them</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>b)</b></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>as in (a), but with a larger gap</td></tr>\n</table>\n\nConsider\n<b>(a)</b>: if the service received during both periods\nmeets <b>(1)</b>, then all is well. But what if it\ndoesn&rsquo;t do so during the 2nd period? If the amount of\nservice received during the 1st period is larger than the\nservice curve, then it might compensate for smaller service\nduring the 2nd period <i>and</i> the gap - if the gap is\nsmall enough.\n\nIf the gap is\nlarger <b>(b)</b> - then it&rsquo;s less likely to happen\n(unless the excess bandwidth allocated during the 1st part\nwas really large). Still, the larger the gap - the less\ninteresting is what happened in the past (e.g. 10 minutes\nago) - what matters is the current traffic that just\nstarted.\n\nFrom\nHFSC&rsquo;s perspective, more interesting is answering the\nfollowing question: when should we start transferring\npackets, so a service curve of a class is not violated. Or\nrephrasing it: How much X() amount of service should a\nsession receive by time t, so the service curve is not\nviolated. Function X() defined as below is the basic\nbuilding block of HFSC, used in: eligible, deadline,\nvirtual-time and fit-time curves. Of course, X() is based on\nequation <b>(1)</b> and is defined recursively:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">At the 1st backlogged period\nbeginning function X is initialized to generic service curve\nassigned to a class</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>At any subsequent backlogged period, X() is:</td></tr>\n</table>\n\n<p style=\"margin-left:23%;\"><b>min(X() from previous period\n; w(t0)+S(t-t0) for t&gt;=t0),</b> <br>\n... where t0 denotes the beginning of the current backlogged\nperiod.\n\nHFSC uses\neither linear, or two-piece linear service curves. In case\nof linear or two-piece linear convex functions (first slope\n&lt; second slope), min() in X&rsquo;s definition reduces to\nthe 2nd argument. But in case of two-piece concave\nfunctions, the 1st argument might quickly become lesser for\nsome t&gt;=t0. Note, that for some backlogged period, X() is\ndefined only from that period&rsquo;s beginning. We also\ndefine X^(-1)(w) as smallest t&gt;=t0, for which\nX(t)&nbsp;=&nbsp;w. We have to define it this way, as X() is\nusually not an injection.\n\nThe above\ngeneric X() can be one of the following:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p style=\"margin-top: 1em\">E()</td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">In realtime criterion, selects\npackets eligible for sending. If none are eligible, HFSC\nwill use linkshare criterion. Eligible time &rsquo;et&rsquo;\nis calculated with reference to packets&rsquo; heads (\net&nbsp;=&nbsp;E^(-1)(w) ). It&rsquo;s based on RT service\ncurve, <i>but in case of a convex curve, uses its 2nd slope\nonly.</i> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p>D()</td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>In realtime criterion, selects the most suitable packet\nfrom the ones chosen by E(). Deadline time &rsquo;dt&rsquo;\ncorresponds to packets&rsquo; tails\n(dt&nbsp;=&nbsp;D^(-1)(w+l), where &rsquo;l&rsquo; is\npacket&rsquo;s length). Based on RT service curve.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p>V()</td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>In linkshare criterion, arbitrates which packet to send\nnext. Note that V() is function of a virtual time - see\n<b>LINKSHARE CRITERION</b> section for details. Virtual time\n&rsquo;vt&rsquo; corresponds to packets&rsquo; heads\n(vt&nbsp;=&nbsp;V^(-1)(w)). Based on LS service curve.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p>F()</td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>An extension to linkshare criterion, used to limit at\nwhich speed linkshare criterion is allowed to dequeue.\nFit-time &rsquo;ft&rsquo; corresponds to packets&rsquo;\nheads as well (ft&nbsp;=&nbsp;F^(-1)(w)). Based on UL\nservice curve.</td></tr>\n</table>\n\nBe sure to make\nclean distinction between session&rsquo;s RT, LS and UL\nservice curves and the above &quot;utility&quot;\nfunctions.\n\n<h2>REALTIME CRITERION\n<a name=\"REALTIME CRITERION\"></a>\n</h2>\n\n\nRT criterion\n<i>ignores class hierarchy</i> and guarantees precise\nbandwidth and delay allocation. We say that a packet is\neligible for sending, when the current real time is later\nthan the eligible time of the packet. From all eligible\npackets, the one most suited for sending is the one with the\nshortest deadline time. This sounds simple, but consider the\nfollowing example:\n\nInterface\n10Mbit, two classes, both with two-piece linear service\ncurves:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">1st class - 2Mbit for 100ms,\nthen 7Mbit (convex - 1st slope &lt; 2nd slope)</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>2nd class - 7Mbit for 100ms, then 2Mbit (concave - 1st\nslope &gt; 2nd slope)</td></tr>\n</table>\n\nAssume for a\nmoment, that we only use D() for both finding eligible\npackets, and choosing the most fitting one, thus eligible\ntime would be computed as D^(-1)(w) and deadline time would\nbe computed as D^(-1)(w+l). If the 2nd class starts sending\npackets 1 second after the 1st class, it&rsquo;s of course\nimpossible to guarantee 14Mbit, as the interface capability\nis only 10Mbit. The only workaround in this scenario is to\nallow the 1st class to send the packets earlier that would\nnormally be allowed. That&rsquo;s where separate E() comes\nto help. Putting all the math aside (see HFSC paper for\ndetails), E() for RT concave service curve is just like D(),\nbut for the RT convex service curve - it&rsquo;s constructed\nusing <i>only</i> RT service curve&rsquo;s 2nd slope (in our\nexample <br>\n7Mbit).\n\nThe effect of\nsuch E() - packets will be sent earlier, and at the same\ntime D() <i>will</i> be updated - so the current deadline\ntime calculated from it will be later. Thus, when the 2nd\nclass starts sending packets later, both the 1st and the 2nd\nclass will be eligible, but the 2nd session&rsquo;s deadline\ntime will be smaller and its packets will be sent first.\nWhen the 1st class becomes idle at some later point, the 2nd\nclass will be able to &quot;buffer&quot; up again for later\nactive period of the 1st class.\n\nA short remark\n- in a situation, where the total amount of bandwidth\navailable on the interface is larger than the allocated\ntotal realtime parts (imagine a 10 Mbit interface, but\n1Mbit/2Mbit and 2Mbit/1Mbit classes), the sole speed of the\ninterface could suffice to guarantee the times.\n\nImportant part\nof RT criterion is that apart from updating its D() and E(),\nalso V() used by LS criterion is updated. Generally the RT\ncriterion is secondary to LS one, and used <i>only</i> if\nthere&rsquo;s a risk of violating precise realtime\nrequirements. Still, the &quot;participation&quot; in\nbandwidth distributed by LS criterion is there, so V() has\nto be updated along the way. LS criterion can than properly\ncompensate for non-ideal fair sharing situation, caused by\nRT scheduling. If you use UL service curve its F() will be\nupdated as well (UL service curve is an extension to LS one\n- see <b>UPPERLIMIT CRITERION</b> section).\n\nAnyway -\ncareless specification of LS and RT service curves can lead\nto potentially undesired situations (see CORNER CASES for\nexamples). This wasn&rsquo;t the case in HFSC paper where LS\nand RT service curves couldn&rsquo;t be specified\nseparately.\n\n<h2>LINKSHARING CRITERION\n<a name=\"LINKSHARING CRITERION\"></a>\n</h2>\n\n\nLS\ncriterion&rsquo;s task is to distribute bandwidth according\nto specified class hierarchy. Contrary to RT criterion,\nthere&rsquo;re no comparisons between current real time and\nvirtual time - the decision is based solely on direct\ncomparison of virtual times of all active subclasses - the\none with the smallest vt wins and gets scheduled. One\nimmediate conclusion from this fact is that absolute values\ndon&rsquo;t matter - only ratios between them (so for\nexample, two children classes with simple linear 1Mbit\nservice curves will get the same treatment from LS\ncriterion&rsquo;s perspective, as if they were 5Mbit). The\nother conclusion is, that in perfectly fluid system with\nlinear curves, all virtual times across whole class\nhierarchy would be equal.\n\nWhy is VC\ndefined in term of virtual time (and what is it)?\n\nImagine an\nexample: class A with two children - A1 and A2, both with\nlet&rsquo;s say 10Mbit SCs. If A2 is idle, A1 receives all\nthe bandwidth of A (and update its V() in the process). When\nA2 becomes active, A1&rsquo;s virtual time is already\n<i>far</i> later than A2&rsquo;s one. Considering the type\nof decision made by LS criterion, A1 would become idle for a\nlong time. We can workaround this situation by adjusting\nvirtual time of the class becoming active - we do that by\ngetting such time &quot;up to date&quot;. HFSC uses a mean\nof the smallest and the biggest virtual time of currently\nactive children fit for sending. As it&rsquo;s not real time\nanymore (excluding trivial case of situation where all\nclasses become active at the same time, and never become\nidle), it&rsquo;s called virtual time.\n\nSuch approach\nhas its price though. The problem is analogous to what was\npresented in previous section and is caused by non-linearity\nof service curves:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">either it&rsquo;s impossible to\nguarantee service curves and satisfy fairness during certain\ntime periods:</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Recall the\nexample from RT section, slightly modified (with 3Mbit\nslopes instead of 2Mbit ones):\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">1st class - 3Mbit for 100ms,\nthen 7Mbit (convex - 1st slope &lt; 2nd slope)</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>2nd class - 7Mbit for 100ms, then 3Mbit (concave - 1st\nslope &gt; 2nd slope)</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">They sum up\nnicely to 10Mbit - the interface&rsquo;s capacity. But if we\nwanted to only use LS for guarantees and fairness - it\nsimply won&rsquo;t work. In LS context, only V() is used for\nmaking decision which class to schedule. If the 2nd class\nbecomes active when the 1st one is in its second slope, the\nfairness will be preserved - ratio will be 1:1\n(7Mbit:7Mbit), but LS itself is of course unable to\nguarantee the absolute values themselves - as it would have\nto go beyond of what the interface is capable of.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">2)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">and/or it&rsquo;s impossible to\nguarantee service curves of all classes at the same time\n[fairly or not]:</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This is similar\nto the above case, but a bit more subtle. We will consider\ntwo subtrees, arbitrated by their common (root here)\nparent:\n\n<p style=\"margin-left:17%; margin-top: 1em\">R (root)\n-&nbsp;10Mbit\n\n<p style=\"margin-left:17%; margin-top: 1em\">A - 7Mbit, then\n3Mbit <br>\nA1 - 5Mbit, then 2Mbit <br>\nA2 - 2Mbit, then 1Mbit\n\n<p style=\"margin-left:17%; margin-top: 1em\">B - 3Mbit, then\n7Mbit\n\n<p style=\"margin-left:17%; margin-top: 1em\">R arbitrates\nbetween left subtree (A) and right (B). Assume that A2 and B\nare constantly backlogged, and at some later point A1\nbecomes backlogged (when all other classes are in their 2nd\nlinear part).\n\n<p style=\"margin-left:17%; margin-top: 1em\">What happens\nnow? B (choice made by R) will <i>always</i> get 7 Mbit as R\nis only (obviously) concerned with the ratio between its\ndirect children. Thus A subtree gets 3Mbit, but its children\nwould want (at the point when A1 became backlogged) 5Mbit +\n1Mbit. That&rsquo;s of course impossible, as they can only\nget 3Mbit due to interface limitation.\n\n<p style=\"margin-left:17%; margin-top: 1em\">In the left\nsubtree - we have the same situation as previously (fair\nsplit between A1 and A2, but violated guarantees), but in\nthe whole tree - there&rsquo;s no fairness (B got 7Mbit, but\nA1 and A2 have to fit together in 3Mbit) and there&rsquo;s\nno guarantees for all classes (only B got what it wanted).\nEven if we violated fairness in the A subtree and set\nA2&rsquo;s service curve to 0, A1 would still not get the\nrequired bandwidth.\n\n<h2>UPPERLIMIT CRITERION\n<a name=\"UPPERLIMIT CRITERION\"></a>\n</h2>\n\n\nUL criterion is\nan extensions to LS one, that permits sending packets only\nif current real time is later than fit-time\n(&rsquo;ft&rsquo;). So the modified LS criterion becomes:\nchoose the smallest virtual time from all active children,\nsuch that fit-time &lt; current real time also holds.\nFit-time is calculated from F(), which is based on UL\nservice curve. As you can see, its role is kinda similar to\nE() used in RT criterion. Also, for obvious reasons - you\ncan&rsquo;t specify UL service curve without LS one.\n\nThe main\npurpose of the UL service curve is to limit HFSC to\nbandwidth available on the upstream router (think adsl home\nmodem/router, and linux server as NAT/firewall/etc. with\n100Mbit+ connection to mentioned modem/router). Typically,\nit&rsquo;s used to create a single class directly under\nroot, setting a linear UL service curve to available\nbandwidth - and then creating your class structure from that\nclass downwards. Of course, you&rsquo;re free to add a UL\nservice curve (linear or not) to any class with LS\ncriterion.\n\nAn important\npart about the UL service curve is that whenever at some\npoint in time a class doesn&rsquo;t qualify for linksharing\ndue to its fit-time, the next time it does qualify it will\nupdate its virtual time to the smallest virtual time of all\nactive children fit for linksharing. This way, one of the\nmain things the LS criterion tries to achieve - equality of\nall virtual times across whole hierarchy - is preserved (in\nperfectly fluid system with only linear curves, all virtual\ntimes would be equal).\n\nWithout that,\n&rsquo;vt&rsquo; would lag behind other virtual times, and\ncould cause problems. Consider an interface with a capacity\nof 10Mbit, and the following leaf classes (just in case\nyou&rsquo;re skipping this text quickly - this example shows\nbehavior that <b><i>doesn&rsquo;t happen</i></b>):\n\nA - ls 5.0Mbit\n<br>\nB - ls 2.5Mbit <br>\nC - ls 2.5Mbit, ul 2.5Mbit\n\nIf B was idle,\nwhile A and C were constantly backlogged, A and C would\nnormally (as far as LS criterion is concerned) divide\nbandwidth in 2:1 ratio. But due to UL service curve in\nplace, C would get at most 2.5Mbit, and A would get the\nremaining 7.5Mbit. The longer the backlogged period, the\nmore the virtual times of A and C would drift apart. If B\nbecame backlogged at some later point in time, its virtual\ntime would be set to\n(A&rsquo;s&nbsp;vt&nbsp;+&nbsp;C&rsquo;s&nbsp;vt)/2, thus\nblocking A from sending any traffic until B&rsquo;s virtual\ntime catches up with A.\n\n<h2>SEPARATE LS / RT SCs\n<a name=\"SEPARATE LS / RT SCs\"></a>\n</h2>\n\n\nAnother\ndifference from the original HFSC paper is that RT and LS\nSCs can be specified separately. Moreover, leaf classes are\nallowed to have only either RT SC or LS SC. For interior\nclasses, only LS SCs make sense: any RT SC will be\nignored.\n\n<h2>CORNER CASES\n<a name=\"CORNER CASES\"></a>\n</h2>\n\n\nSeparate\nservice curves for LS and RT criteria can lead to certain\ntraps that come from &quot;fighting&quot; between ideal\nlinksharing and enforced realtime guarantees. Those\nsituations didn&rsquo;t exist in original HFSC paper, where\nspecifying separate LS / RT service curves was not\ndiscussed.\n\nConsider an\ninterface with a 10Mbit capacity, with the following leaf\nclasses:\n\nA - ls 5.0Mbit,\nrt 8Mbit <br>\nB - ls 2.5Mbit <br>\nC - ls 2.5Mbit\n\nImagine A and C\nare constantly backlogged. As B is idle, A and C would\ndivide bandwidth in 2:1 ratio, considering LS service curve\n(so in theory - 6.66 and 3.33). Alas RT criterion takes\npriority, so A will get 8Mbit and LS will be able to\ncompensate class C for only 2 Mbit - this will cause\ndiscrepancy between virtual times of A and C.\n\nAssume this\nsituation lasts for a long time with no idle periods, and\nsuddenly B becomes active. B&rsquo;s virtual time will be\nupdated to\n(A&rsquo;s&nbsp;vt&nbsp;+&nbsp;C&rsquo;s&nbsp;vt)/2,\neffectively landing in the middle between A&rsquo;s and\nC&rsquo;s virtual time. The effect - B, having no RT\nguarantees, will be punished and will not be allowed to\ntransfer until C&rsquo;s virtual time catches up.\n\nIf the\ninterface had a higher capacity, for example 100Mbit, this\nexample would behave perfectly fine though.\n\nLet&rsquo;s\nlook a bit closer at the above example - it\n&quot;cleverly&quot; invalidates one of the basic things LS\ncriterion tries to achieve - equality of all virtual times\nacross class hierarchy. Leaf classes without RT service\ncurves are literally left to their own fate (governed by\nmessed up virtual times).\n\nAlso, it\ndoesn&rsquo;t make much sense. Class A will always be\nguaranteed up to 8Mbit, and this is more than any absolute\nbandwidth that could happen from its LS criterion (excluding\ntrivial case of only A being active). If the bandwidth taken\nby A is smaller than absolute value from LS criterion, the\nunused part will be automatically assigned to other active\nclasses (as A has idling periods in such case). The only\n&quot;advantage&quot; is, that even in case of low bandwidth\non average, bursts would be handled at the speed defined by\nRT criterion. Still, if extra speed is needed (e.g. due to\nlatency), non linear service curves should be used in such\ncase.\n\nIn the other\nwords: the LS criterion is meaningless in the above\nexample.\n\nYou can quickly\n&quot;workaround&quot; it by making sure each leaf class has\nRT service curve assigned (thus guaranteeing all of them\nwill get some bandwidth), but it doesn&rsquo;t make it any\nmore valid.\n\nKeep in mind -\nif you use nonlinear curves and irregularities explained\nabove happen <i>only</i> in the first segment, then\nthere&rsquo;s little wrong with &quot;overusing&quot; RT\ncurve a bit:\n\nA - ls 5.0Mbit,\nrt 9Mbit/30ms, then 1Mbit <br>\nB - ls 2.5Mbit <br>\nC - ls 2.5Mbit\n\nHere, the vt of\nA will &quot;spike&quot; in the initial period, but then A\nwill never get more than 1Mbit until B &amp; C catch up.\nThen everything will be back to normal.\n\n<h2>LINUX AND TIMER RESOLUTION\n<a name=\"LINUX AND TIMER RESOLUTION\"></a>\n</h2>\n\n\nIn certain\nsituations, the scheduler can throttle itself and setup so\ncalled watchdog to wakeup dequeue function at some time\nlater. In case of HFSC it happens when for example no packet\nis eligible for scheduling, and UL service curve is used to\nlimit the speed at which LS criterion is allowed to dequeue\npackets. It&rsquo;s called throttling, and accuracy of it is\ndependent on how the kernel is compiled.\n\nThere&rsquo;re\n3 important options in modern kernels, as far as\ntimers&rsquo; resolution goes: &rsquo;tickless\nsystem&rsquo;, &rsquo;high resolution timer support&rsquo;\nand &rsquo;timer frequency&rsquo;.\n\nIf you have\n&rsquo;tickless system&rsquo; enabled, then the timer\ninterrupt will trigger as slowly as possible, but each time\na scheduler throttles itself (or any other part of the\nkernel needs better accuracy), the rate will be increased as\nneeded / possible. The ceiling is either &rsquo;timer\nfrequency&rsquo; if &rsquo;high resolution timer\nsupport&rsquo; is not available or not compiled in, or\nit&rsquo;s hardware dependent and can go <i>far</i> beyond\nthe highest &rsquo;timer frequency&rsquo; setting\navailable.\n\nIf\n&rsquo;tickless system&rsquo; is not enabled, the timer will\ntrigger at a fixed rate specified by &rsquo;timer\nfrequency&rsquo; - regardless if high resolution timers are\nor aren&rsquo;t available.\n\nThis is\nimportant to keep those settings in mind, as in scenario\nlike: no tickless, no HR timers, frequency set to 100hz -\nthrottling accuracy would be at 10ms. It doesn&rsquo;t\nautomatically mean you would be limited to ~0.8Mbit/s\n(assuming packets at ~1KB) - as long as your queues are\nprepared to cover for timer inaccuracy. Of course, in case\nof e.g. locally generated UDP traffic - appropriate socket\nsize is needed as well. Short example to make it more\nunderstandable (assume hardcore anti-schedule settings -\nHZ=100, no HR timers, no tickless):\n\ntc qdisc add\ndev eth0 root handle 1:0 hfsc default 1 <br>\ntc class add dev eth0 parent 1:0 classid 1:1 hfsc rt m2\n10Mbit\n\nAssuming packet\nof ~1KB size and HZ=100, that averages to ~0.8Mbit -\nanything beyond it (e.g. the above example with specified\nrate over 10x larger) will require appropriate queuing and\ncause bursts every ~10 ms. As you can imagine, any\nHFSC&rsquo;s RT guarantees will be seriously invalidated by\nthat. Aforementioned example is mainly important if you deal\nwith old hardware - as is particularly popular for home\nserver chores. Even then, you can easily set HZ=1000 and\nhave very accurate scheduling for typical adsl speeds.\n\nAnything modern\n(apic or even hpet msi based timers + &rsquo;tickless\nsystem&rsquo;) will provide enough accuracy for superb 1Gbit\nscheduling. For example, on one of my cheap dual-core AMD\nboards I have the following settings:\n\ntc qdisc add\ndev eth0 parent root handle 1:0 hfsc default 1 <br>\ntc class add dev eth0 parent 1:0 classid 1:1 hfsc rt m2\n300mbit\n\nAnd a\nsimple:\n\nnc -u\ndst.host.com 54321 &lt;/dev/zero <br>\nnc -l -p 54321 &gt;/dev/null\n\n...will yield\nthe following effects over a period of ~10 seconds (taken\nfrom /proc/interrupts):\n\n319: 42124229 0\nHPET_MSI-edge hpet2 (before) <br>\n319: 42436214 0 HPET_MSI-edge hpet2 (after 10s.)\n\nThat&rsquo;s\nroughly 31000/s. Now compare it with HZ=1000 setting. The\nobvious drawback of it is that cpu load can be rather high\nwith servicing that many timer interrupts. The example with\n300Mbit RT service curve on 1Gbit link is particularly ugly,\nas it requires a lot of throttling with minuscule\ndelays.\n\nAlso note that\nit&rsquo;s just an example showing the capabilities of\ncurrent hardware. The above example (essentially a 300Mbit\nTBF emulator) is pointless on an internal interface to begin\nwith: you will pretty much always want a regular LS service\ncurve there, and in such a scenario HFSC simply\ndoesn&rsquo;t throttle at all.\n\n300Mbit RT\nservice curve (selected columns from mpstat -P ALL 1):\n\n10:56:43 PM CPU\n%sys %irq %soft %idle <br>\n10:56:44 PM all 20.10 6.53 34.67 37.19 <br>\n10:56:44 PM 0 35.00 0.00 63.00 0.00 <br>\n10:56:44 PM 1 4.95 12.87 6.93 73.27\n\nSo, in the rare\ncase you need those speeds with only a RT service curve, or\nwith a UL service curve: remember the drawbacks.\n\n<h2>CAVEAT: RANDOM ONLINE EXAMPLES\n<a name=\"CAVEAT: RANDOM ONLINE EXAMPLES\"></a>\n</h2>\n\n\nFor reasons\nunknown (though well guessed), many examples you can google\nlove to overuse UL criterion and stuff it in every node\npossible. This makes no sense and works against what HFSC\ntries to do (and does pretty damn well). Use UL where it\nmakes sense: on the uppermost node to match upstream\nrouter&rsquo;s uplink capacity. Or in special cases, such as\ntesting (limit certain subtree to some speed), or customers\nthat must never get more than certain speed. In the last\ncase you can usually achieve the same by just using a RT\ncriterion without LS+UL on leaf nodes.\n\nAs for the\nrouter case - remember it&rsquo;s good to differentiate\nbetween &quot;traffic to router&quot; (remote console, web\nconfig, etc.) and &quot;outgoing traffic&quot;, so for\nexample:\n\ntc qdisc add\ndev eth0 root handle 1:0 hfsc default 0x8002 <br>\ntc class add dev eth0 parent 1:0 classid 1:999 hfsc rt m2\n50Mbit <br>\ntc class add dev eth0 parent 1:0 classid 1:1 hfsc ls m2\n2Mbit ul m2 2Mbit\n\n... so\n&quot;internet&quot; tree under 1:1 and &quot;router\nitself&quot; as 1:999\n\n<h2>LAYER2 ADAPTATION\n<a name=\"LAYER2 ADAPTATION\"></a>\n</h2>\n\n\nPlease refer to\n<b>tc-stab</b>(8)\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<b>tc</b>(8),\n<b>tc-hfsc</b>(8), <b>tc-stab</b>(8)\n\nPlease direct\nbugreports and patches to:\n&lt;netdev@vger.kernel.org&gt;\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\nManpage created\nby Michal Soltys (soltys@ziu.info)","body":"\n\n<h1 align=\"center\">TC-HFSC</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">tc-hfcs -\nHierarchical Fair Service Curve</p>\n\n<h2>HISTORY &amp; INTRODUCTION\n<a name=\"HISTORY &amp; INTRODUCTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HFSC\n(Hierarchical Fair Service Curve) is a network packet\nscheduling algorithm that was first presented at\nSIGCOMM&rsquo;97. Developed as a part of ALTQ (ALTernative\nQueuing) on NetBSD, found its way quickly to other BSD\nsystems, and then a few years ago became part of the linux\nkernel. Still, it&rsquo;s not the most popular scheduling\nalgorithm - especially if compared to HTB - and it&rsquo;s\nnot well documented for the enduser. This introduction aims\nto explain how HFSC works without using too much math\n(although some math it will be inevitable).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In short HFSC\naims to:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>1)</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>guarantee precise bandwidth and delay allocation for all\nleaf classes (realtime criterion)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>2)</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>allocate excess bandwidth fairly as specified by class\nhierarchy (linkshare &amp; upperlimit criterion)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>3)</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>minimize any discrepancy between the service curve and\nthe actual amount of service provided during linksharing</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The main\n&quot;selling&quot; point of HFSC is feature <b>(1)</b>,\nwhich is achieved by using nonlinear service curves (more\nabout what it actually is later). This is particularly\nuseful in VoIP or games, where not only a guarantee of\nconsistent bandwidth is important, but also limiting the\ninitial delay of a data stream. Note that it matters only\nfor leaf classes (where the actual queues are) - thus class\nhierarchy is ignored in the realtime case.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Feature\n<b>(2)</b> is well, obvious - any algorithm featuring class\nhierarchy (such as HTB or CBQ) strives to achieve that. HFSC\ndoes that well, although you might end with unusual\nsituations, if you define service curves carelessly - see\nsection CORNER CASES for examples.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Feature\n<b>(3)</b> is mentioned due to the nature of the problem.\nThere may be situations where it&rsquo;s either not possible\nto guarantee service of all curves at the same time, and/or\nit&rsquo;s impossible to do so fairly. Both will be\nexplained later. Note that this is mainly related to\ninterior (aka aggregate) classes, as the leafs are already\nhandled by <b>(1)</b>. Still, it&rsquo;s perfectly possible\nto create a leaf class without realtime service, and in such\na case the caveats will naturally extend to leaf classes as\nwell.</p>\n\n<h2>ABBREVIATIONS\n<a name=\"ABBREVIATIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For the\nremaining part of the document, we&rsquo;ll use following\nshortcuts:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">RT - realtime\n<br>\nLS - linkshare <br>\nUL - upperlimit <br>\nSC - service curve</p>\n\n<h2>BASICS OF HFSC\n<a name=\"BASICS OF HFSC\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">To understand\nhow HFSC works, we must first introduce a service curve.\nOverall, it&rsquo;s a nondecreasing function of some time\nunit, returning the amount of service (an allowed or\nallocated amount of bandwidth) at some specific point in\ntime. The purpose of it should be subconsciously obvious: if\na class was allowed to transfer not less than the amount\nspecified by its service curve, then the service curve is\nnot violated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Still, we need\nmore elaborate criterion than just the above (although in\nthe most generic case it can be reduced to it). The\ncriterion has to take two things into account:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">idling periods</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>the ability to &quot;look back&quot;, so if during\ncurrent active period the service curve is violated, maybe\nit isn&rsquo;t if we count excess bandwidth received during\nearlier active period(s)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Let&rsquo;s\ndefine the criterion as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p style=\"margin-top: 1em\"><b>(1)</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">For each t1, there must exist t0\nin set B, so S(t1-t0)&nbsp;&lt;=&nbsp;w(t0,t1)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here\n&rsquo;w&rsquo; denotes the amount of service received\nduring some time period between t0 and t1. B is a set of all\ntimes, where a session becomes active after idling period\n(further denoted as &rsquo;becoming backlogged&rsquo;). For\na clearer picture, imagine two situations:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\"><b>a)</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">our session was active during\ntwo periods, with a small time gap between them</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p><b>b)</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>as in (a), but with a larger gap</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider\n<b>(a)</b>: if the service received during both periods\nmeets <b>(1)</b>, then all is well. But what if it\ndoesn&rsquo;t do so during the 2nd period? If the amount of\nservice received during the 1st period is larger than the\nservice curve, then it might compensate for smaller service\nduring the 2nd period <i>and</i> the gap - if the gap is\nsmall enough.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the gap is\nlarger <b>(b)</b> - then it&rsquo;s less likely to happen\n(unless the excess bandwidth allocated during the 1st part\nwas really large). Still, the larger the gap - the less\ninteresting is what happened in the past (e.g. 10 minutes\nago) - what matters is the current traffic that just\nstarted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From\nHFSC&rsquo;s perspective, more interesting is answering the\nfollowing question: when should we start transferring\npackets, so a service curve of a class is not violated. Or\nrephrasing it: How much X() amount of service should a\nsession receive by time t, so the service curve is not\nviolated. Function X() defined as below is the basic\nbuilding block of HFSC, used in: eligible, deadline,\nvirtual-time and fit-time curves. Of course, X() is based on\nequation <b>(1)</b> and is defined recursively:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">At the 1st backlogged period\nbeginning function X is initialized to generic service curve\nassigned to a class</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>At any subsequent backlogged period, X() is:</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%;\"><b>min(X() from previous period\n; w(t0)+S(t-t0) for t&gt;=t0),</b> <br>\n... where t0 denotes the beginning of the current backlogged\nperiod.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">HFSC uses\neither linear, or two-piece linear service curves. In case\nof linear or two-piece linear convex functions (first slope\n&lt; second slope), min() in X&rsquo;s definition reduces to\nthe 2nd argument. But in case of two-piece concave\nfunctions, the 1st argument might quickly become lesser for\nsome t&gt;=t0. Note, that for some backlogged period, X() is\ndefined only from that period&rsquo;s beginning. We also\ndefine X^(-1)(w) as smallest t&gt;=t0, for which\nX(t)&nbsp;=&nbsp;w. We have to define it this way, as X() is\nusually not an injection.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The above\ngeneric X() can be one of the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p style=\"margin-top: 1em\">E()</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">In realtime criterion, selects\npackets eligible for sending. If none are eligible, HFSC\nwill use linkshare criterion. Eligible time &rsquo;et&rsquo;\nis calculated with reference to packets&rsquo; heads (\net&nbsp;=&nbsp;E^(-1)(w) ). It&rsquo;s based on RT service\ncurve, <i>but in case of a convex curve, uses its 2nd slope\nonly.</i></p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p>D()</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>In realtime criterion, selects the most suitable packet\nfrom the ones chosen by E(). Deadline time &rsquo;dt&rsquo;\ncorresponds to packets&rsquo; tails\n(dt&nbsp;=&nbsp;D^(-1)(w+l), where &rsquo;l&rsquo; is\npacket&rsquo;s length). Based on RT service curve.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p>V()</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>In linkshare criterion, arbitrates which packet to send\nnext. Note that V() is function of a virtual time - see\n<b>LINKSHARE CRITERION</b> section for details. Virtual time\n&rsquo;vt&rsquo; corresponds to packets&rsquo; heads\n(vt&nbsp;=&nbsp;V^(-1)(w)). Based on LS service curve.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p>F()</p></td>\n<td width=\"1%\"></td>\n<td width=\"77%\">\n\n\n<p>An extension to linkshare criterion, used to limit at\nwhich speed linkshare criterion is allowed to dequeue.\nFit-time &rsquo;ft&rsquo; corresponds to packets&rsquo;\nheads as well (ft&nbsp;=&nbsp;F^(-1)(w)). Based on UL\nservice curve.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Be sure to make\nclean distinction between session&rsquo;s RT, LS and UL\nservice curves and the above &quot;utility&quot;\nfunctions.</p>\n\n<h2>REALTIME CRITERION\n<a name=\"REALTIME CRITERION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">RT criterion\n<i>ignores class hierarchy</i> and guarantees precise\nbandwidth and delay allocation. We say that a packet is\neligible for sending, when the current real time is later\nthan the eligible time of the packet. From all eligible\npackets, the one most suited for sending is the one with the\nshortest deadline time. This sounds simple, but consider the\nfollowing example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Interface\n10Mbit, two classes, both with two-piece linear service\ncurves:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">1st class - 2Mbit for 100ms,\nthen 7Mbit (convex - 1st slope &lt; 2nd slope)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>2nd class - 7Mbit for 100ms, then 2Mbit (concave - 1st\nslope &gt; 2nd slope)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Assume for a\nmoment, that we only use D() for both finding eligible\npackets, and choosing the most fitting one, thus eligible\ntime would be computed as D^(-1)(w) and deadline time would\nbe computed as D^(-1)(w+l). If the 2nd class starts sending\npackets 1 second after the 1st class, it&rsquo;s of course\nimpossible to guarantee 14Mbit, as the interface capability\nis only 10Mbit. The only workaround in this scenario is to\nallow the 1st class to send the packets earlier that would\nnormally be allowed. That&rsquo;s where separate E() comes\nto help. Putting all the math aside (see HFSC paper for\ndetails), E() for RT concave service curve is just like D(),\nbut for the RT convex service curve - it&rsquo;s constructed\nusing <i>only</i> RT service curve&rsquo;s 2nd slope (in our\nexample <br>\n7Mbit).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The effect of\nsuch E() - packets will be sent earlier, and at the same\ntime D() <i>will</i> be updated - so the current deadline\ntime calculated from it will be later. Thus, when the 2nd\nclass starts sending packets later, both the 1st and the 2nd\nclass will be eligible, but the 2nd session&rsquo;s deadline\ntime will be smaller and its packets will be sent first.\nWhen the 1st class becomes idle at some later point, the 2nd\nclass will be able to &quot;buffer&quot; up again for later\nactive period of the 1st class.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A short remark\n- in a situation, where the total amount of bandwidth\navailable on the interface is larger than the allocated\ntotal realtime parts (imagine a 10 Mbit interface, but\n1Mbit/2Mbit and 2Mbit/1Mbit classes), the sole speed of the\ninterface could suffice to guarantee the times.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Important part\nof RT criterion is that apart from updating its D() and E(),\nalso V() used by LS criterion is updated. Generally the RT\ncriterion is secondary to LS one, and used <i>only</i> if\nthere&rsquo;s a risk of violating precise realtime\nrequirements. Still, the &quot;participation&quot; in\nbandwidth distributed by LS criterion is there, so V() has\nto be updated along the way. LS criterion can than properly\ncompensate for non-ideal fair sharing situation, caused by\nRT scheduling. If you use UL service curve its F() will be\nupdated as well (UL service curve is an extension to LS one\n- see <b>UPPERLIMIT CRITERION</b> section).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Anyway -\ncareless specification of LS and RT service curves can lead\nto potentially undesired situations (see CORNER CASES for\nexamples). This wasn&rsquo;t the case in HFSC paper where LS\nand RT service curves couldn&rsquo;t be specified\nseparately.</p>\n\n<h2>LINKSHARING CRITERION\n<a name=\"LINKSHARING CRITERION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">LS\ncriterion&rsquo;s task is to distribute bandwidth according\nto specified class hierarchy. Contrary to RT criterion,\nthere&rsquo;re no comparisons between current real time and\nvirtual time - the decision is based solely on direct\ncomparison of virtual times of all active subclasses - the\none with the smallest vt wins and gets scheduled. One\nimmediate conclusion from this fact is that absolute values\ndon&rsquo;t matter - only ratios between them (so for\nexample, two children classes with simple linear 1Mbit\nservice curves will get the same treatment from LS\ncriterion&rsquo;s perspective, as if they were 5Mbit). The\nother conclusion is, that in perfectly fluid system with\nlinear curves, all virtual times across whole class\nhierarchy would be equal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Why is VC\ndefined in term of virtual time (and what is it)?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Imagine an\nexample: class A with two children - A1 and A2, both with\nlet&rsquo;s say 10Mbit SCs. If A2 is idle, A1 receives all\nthe bandwidth of A (and update its V() in the process). When\nA2 becomes active, A1&rsquo;s virtual time is already\n<i>far</i> later than A2&rsquo;s one. Considering the type\nof decision made by LS criterion, A1 would become idle for a\nlong time. We can workaround this situation by adjusting\nvirtual time of the class becoming active - we do that by\ngetting such time &quot;up to date&quot;. HFSC uses a mean\nof the smallest and the biggest virtual time of currently\nactive children fit for sending. As it&rsquo;s not real time\nanymore (excluding trivial case of situation where all\nclasses become active at the same time, and never become\nidle), it&rsquo;s called virtual time.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Such approach\nhas its price though. The problem is analogous to what was\npresented in previous section and is caused by non-linearity\nof service curves:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">either it&rsquo;s impossible to\nguarantee service curves and satisfy fairness during certain\ntime periods:</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Recall the\nexample from RT section, slightly modified (with 3Mbit\nslopes instead of 2Mbit ones):</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">1st class - 3Mbit for 100ms,\nthen 7Mbit (convex - 1st slope &lt; 2nd slope)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>2nd class - 7Mbit for 100ms, then 3Mbit (concave - 1st\nslope &gt; 2nd slope)</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">They sum up\nnicely to 10Mbit - the interface&rsquo;s capacity. But if we\nwanted to only use LS for guarantees and fairness - it\nsimply won&rsquo;t work. In LS context, only V() is used for\nmaking decision which class to schedule. If the 2nd class\nbecomes active when the 1st one is in its second slope, the\nfairness will be preserved - ratio will be 1:1\n(7Mbit:7Mbit), but LS itself is of course unable to\nguarantee the absolute values themselves - as it would have\nto go beyond of what the interface is capable of.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">2)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">and/or it&rsquo;s impossible to\nguarantee service curves of all classes at the same time\n[fairly or not]:</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This is similar\nto the above case, but a bit more subtle. We will consider\ntwo subtrees, arbitrated by their common (root here)\nparent:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">R (root)\n-&nbsp;10Mbit</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A - 7Mbit, then\n3Mbit <br>\nA1 - 5Mbit, then 2Mbit <br>\nA2 - 2Mbit, then 1Mbit</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">B - 3Mbit, then\n7Mbit</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">R arbitrates\nbetween left subtree (A) and right (B). Assume that A2 and B\nare constantly backlogged, and at some later point A1\nbecomes backlogged (when all other classes are in their 2nd\nlinear part).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">What happens\nnow? B (choice made by R) will <i>always</i> get 7 Mbit as R\nis only (obviously) concerned with the ratio between its\ndirect children. Thus A subtree gets 3Mbit, but its children\nwould want (at the point when A1 became backlogged) 5Mbit +\n1Mbit. That&rsquo;s of course impossible, as they can only\nget 3Mbit due to interface limitation.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In the left\nsubtree - we have the same situation as previously (fair\nsplit between A1 and A2, but violated guarantees), but in\nthe whole tree - there&rsquo;s no fairness (B got 7Mbit, but\nA1 and A2 have to fit together in 3Mbit) and there&rsquo;s\nno guarantees for all classes (only B got what it wanted).\nEven if we violated fairness in the A subtree and set\nA2&rsquo;s service curve to 0, A1 would still not get the\nrequired bandwidth.</p>\n\n<h2>UPPERLIMIT CRITERION\n<a name=\"UPPERLIMIT CRITERION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">UL criterion is\nan extensions to LS one, that permits sending packets only\nif current real time is later than fit-time\n(&rsquo;ft&rsquo;). So the modified LS criterion becomes:\nchoose the smallest virtual time from all active children,\nsuch that fit-time &lt; current real time also holds.\nFit-time is calculated from F(), which is based on UL\nservice curve. As you can see, its role is kinda similar to\nE() used in RT criterion. Also, for obvious reasons - you\ncan&rsquo;t specify UL service curve without LS one.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The main\npurpose of the UL service curve is to limit HFSC to\nbandwidth available on the upstream router (think adsl home\nmodem/router, and linux server as NAT/firewall/etc. with\n100Mbit+ connection to mentioned modem/router). Typically,\nit&rsquo;s used to create a single class directly under\nroot, setting a linear UL service curve to available\nbandwidth - and then creating your class structure from that\nclass downwards. Of course, you&rsquo;re free to add a UL\nservice curve (linear or not) to any class with LS\ncriterion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An important\npart about the UL service curve is that whenever at some\npoint in time a class doesn&rsquo;t qualify for linksharing\ndue to its fit-time, the next time it does qualify it will\nupdate its virtual time to the smallest virtual time of all\nactive children fit for linksharing. This way, one of the\nmain things the LS criterion tries to achieve - equality of\nall virtual times across whole hierarchy - is preserved (in\nperfectly fluid system with only linear curves, all virtual\ntimes would be equal).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Without that,\n&rsquo;vt&rsquo; would lag behind other virtual times, and\ncould cause problems. Consider an interface with a capacity\nof 10Mbit, and the following leaf classes (just in case\nyou&rsquo;re skipping this text quickly - this example shows\nbehavior that <b><i>doesn&rsquo;t happen</i></b>):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A - ls 5.0Mbit\n<br>\nB - ls 2.5Mbit <br>\nC - ls 2.5Mbit, ul 2.5Mbit</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If B was idle,\nwhile A and C were constantly backlogged, A and C would\nnormally (as far as LS criterion is concerned) divide\nbandwidth in 2:1 ratio. But due to UL service curve in\nplace, C would get at most 2.5Mbit, and A would get the\nremaining 7.5Mbit. The longer the backlogged period, the\nmore the virtual times of A and C would drift apart. If B\nbecame backlogged at some later point in time, its virtual\ntime would be set to\n(A&rsquo;s&nbsp;vt&nbsp;+&nbsp;C&rsquo;s&nbsp;vt)/2, thus\nblocking A from sending any traffic until B&rsquo;s virtual\ntime catches up with A.</p>\n\n<h2>SEPARATE LS / RT SCs\n<a name=\"SEPARATE LS / RT SCs\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another\ndifference from the original HFSC paper is that RT and LS\nSCs can be specified separately. Moreover, leaf classes are\nallowed to have only either RT SC or LS SC. For interior\nclasses, only LS SCs make sense: any RT SC will be\nignored.</p>\n\n<h2>CORNER CASES\n<a name=\"CORNER CASES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Separate\nservice curves for LS and RT criteria can lead to certain\ntraps that come from &quot;fighting&quot; between ideal\nlinksharing and enforced realtime guarantees. Those\nsituations didn&rsquo;t exist in original HFSC paper, where\nspecifying separate LS / RT service curves was not\ndiscussed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider an\ninterface with a 10Mbit capacity, with the following leaf\nclasses:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A - ls 5.0Mbit,\nrt 8Mbit <br>\nB - ls 2.5Mbit <br>\nC - ls 2.5Mbit</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Imagine A and C\nare constantly backlogged. As B is idle, A and C would\ndivide bandwidth in 2:1 ratio, considering LS service curve\n(so in theory - 6.66 and 3.33). Alas RT criterion takes\npriority, so A will get 8Mbit and LS will be able to\ncompensate class C for only 2 Mbit - this will cause\ndiscrepancy between virtual times of A and C.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Assume this\nsituation lasts for a long time with no idle periods, and\nsuddenly B becomes active. B&rsquo;s virtual time will be\nupdated to\n(A&rsquo;s&nbsp;vt&nbsp;+&nbsp;C&rsquo;s&nbsp;vt)/2,\neffectively landing in the middle between A&rsquo;s and\nC&rsquo;s virtual time. The effect - B, having no RT\nguarantees, will be punished and will not be allowed to\ntransfer until C&rsquo;s virtual time catches up.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ninterface had a higher capacity, for example 100Mbit, this\nexample would behave perfectly fine though.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Let&rsquo;s\nlook a bit closer at the above example - it\n&quot;cleverly&quot; invalidates one of the basic things LS\ncriterion tries to achieve - equality of all virtual times\nacross class hierarchy. Leaf classes without RT service\ncurves are literally left to their own fate (governed by\nmessed up virtual times).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also, it\ndoesn&rsquo;t make much sense. Class A will always be\nguaranteed up to 8Mbit, and this is more than any absolute\nbandwidth that could happen from its LS criterion (excluding\ntrivial case of only A being active). If the bandwidth taken\nby A is smaller than absolute value from LS criterion, the\nunused part will be automatically assigned to other active\nclasses (as A has idling periods in such case). The only\n&quot;advantage&quot; is, that even in case of low bandwidth\non average, bursts would be handled at the speed defined by\nRT criterion. Still, if extra speed is needed (e.g. due to\nlatency), non linear service curves should be used in such\ncase.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the other\nwords: the LS criterion is meaningless in the above\nexample.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can quickly\n&quot;workaround&quot; it by making sure each leaf class has\nRT service curve assigned (thus guaranteeing all of them\nwill get some bandwidth), but it doesn&rsquo;t make it any\nmore valid.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Keep in mind -\nif you use nonlinear curves and irregularities explained\nabove happen <i>only</i> in the first segment, then\nthere&rsquo;s little wrong with &quot;overusing&quot; RT\ncurve a bit:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A - ls 5.0Mbit,\nrt 9Mbit/30ms, then 1Mbit <br>\nB - ls 2.5Mbit <br>\nC - ls 2.5Mbit</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here, the vt of\nA will &quot;spike&quot; in the initial period, but then A\nwill never get more than 1Mbit until B &amp; C catch up.\nThen everything will be back to normal.</p>\n\n<h2>LINUX AND TIMER RESOLUTION\n<a name=\"LINUX AND TIMER RESOLUTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In certain\nsituations, the scheduler can throttle itself and setup so\ncalled watchdog to wakeup dequeue function at some time\nlater. In case of HFSC it happens when for example no packet\nis eligible for scheduling, and UL service curve is used to\nlimit the speed at which LS criterion is allowed to dequeue\npackets. It&rsquo;s called throttling, and accuracy of it is\ndependent on how the kernel is compiled.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There&rsquo;re\n3 important options in modern kernels, as far as\ntimers&rsquo; resolution goes: &rsquo;tickless\nsystem&rsquo;, &rsquo;high resolution timer support&rsquo;\nand &rsquo;timer frequency&rsquo;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you have\n&rsquo;tickless system&rsquo; enabled, then the timer\ninterrupt will trigger as slowly as possible, but each time\na scheduler throttles itself (or any other part of the\nkernel needs better accuracy), the rate will be increased as\nneeded / possible. The ceiling is either &rsquo;timer\nfrequency&rsquo; if &rsquo;high resolution timer\nsupport&rsquo; is not available or not compiled in, or\nit&rsquo;s hardware dependent and can go <i>far</i> beyond\nthe highest &rsquo;timer frequency&rsquo; setting\navailable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n&rsquo;tickless system&rsquo; is not enabled, the timer will\ntrigger at a fixed rate specified by &rsquo;timer\nfrequency&rsquo; - regardless if high resolution timers are\nor aren&rsquo;t available.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is\nimportant to keep those settings in mind, as in scenario\nlike: no tickless, no HR timers, frequency set to 100hz -\nthrottling accuracy would be at 10ms. It doesn&rsquo;t\nautomatically mean you would be limited to ~0.8Mbit/s\n(assuming packets at ~1KB) - as long as your queues are\nprepared to cover for timer inaccuracy. Of course, in case\nof e.g. locally generated UDP traffic - appropriate socket\nsize is needed as well. Short example to make it more\nunderstandable (assume hardcore anti-schedule settings -\nHZ=100, no HR timers, no tickless):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">tc qdisc add\ndev eth0 root handle 1:0 hfsc default 1 <br>\ntc class add dev eth0 parent 1:0 classid 1:1 hfsc rt m2\n10Mbit</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Assuming packet\nof ~1KB size and HZ=100, that averages to ~0.8Mbit -\nanything beyond it (e.g. the above example with specified\nrate over 10x larger) will require appropriate queuing and\ncause bursts every ~10 ms. As you can imagine, any\nHFSC&rsquo;s RT guarantees will be seriously invalidated by\nthat. Aforementioned example is mainly important if you deal\nwith old hardware - as is particularly popular for home\nserver chores. Even then, you can easily set HZ=1000 and\nhave very accurate scheduling for typical adsl speeds.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Anything modern\n(apic or even hpet msi based timers + &rsquo;tickless\nsystem&rsquo;) will provide enough accuracy for superb 1Gbit\nscheduling. For example, on one of my cheap dual-core AMD\nboards I have the following settings:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">tc qdisc add\ndev eth0 parent root handle 1:0 hfsc default 1 <br>\ntc class add dev eth0 parent 1:0 classid 1:1 hfsc rt m2\n300mbit</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And a\nsimple:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nc -u\ndst.host.com 54321 &lt;/dev/zero <br>\nnc -l -p 54321 &gt;/dev/null</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...will yield\nthe following effects over a period of ~10 seconds (taken\nfrom /proc/interrupts):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">319: 42124229 0\nHPET_MSI-edge hpet2 (before) <br>\n319: 42436214 0 HPET_MSI-edge hpet2 (after 10s.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That&rsquo;s\nroughly 31000/s. Now compare it with HZ=1000 setting. The\nobvious drawback of it is that cpu load can be rather high\nwith servicing that many timer interrupts. The example with\n300Mbit RT service curve on 1Gbit link is particularly ugly,\nas it requires a lot of throttling with minuscule\ndelays.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also note that\nit&rsquo;s just an example showing the capabilities of\ncurrent hardware. The above example (essentially a 300Mbit\nTBF emulator) is pointless on an internal interface to begin\nwith: you will pretty much always want a regular LS service\ncurve there, and in such a scenario HFSC simply\ndoesn&rsquo;t throttle at all.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">300Mbit RT\nservice curve (selected columns from mpstat -P ALL 1):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">10:56:43 PM CPU\n%sys %irq %soft %idle <br>\n10:56:44 PM all 20.10 6.53 34.67 37.19 <br>\n10:56:44 PM 0 35.00 0.00 63.00 0.00 <br>\n10:56:44 PM 1 4.95 12.87 6.93 73.27</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, in the rare\ncase you need those speeds with only a RT service curve, or\nwith a UL service curve: remember the drawbacks.</p>\n\n<h2>CAVEAT: RANDOM ONLINE EXAMPLES\n<a name=\"CAVEAT: RANDOM ONLINE EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For reasons\nunknown (though well guessed), many examples you can google\nlove to overuse UL criterion and stuff it in every node\npossible. This makes no sense and works against what HFSC\ntries to do (and does pretty damn well). Use UL where it\nmakes sense: on the uppermost node to match upstream\nrouter&rsquo;s uplink capacity. Or in special cases, such as\ntesting (limit certain subtree to some speed), or customers\nthat must never get more than certain speed. In the last\ncase you can usually achieve the same by just using a RT\ncriterion without LS+UL on leaf nodes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As for the\nrouter case - remember it&rsquo;s good to differentiate\nbetween &quot;traffic to router&quot; (remote console, web\nconfig, etc.) and &quot;outgoing traffic&quot;, so for\nexample:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">tc qdisc add\ndev eth0 root handle 1:0 hfsc default 0x8002 <br>\ntc class add dev eth0 parent 1:0 classid 1:999 hfsc rt m2\n50Mbit <br>\ntc class add dev eth0 parent 1:0 classid 1:1 hfsc ls m2\n2Mbit ul m2 2Mbit</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">... so\n&quot;internet&quot; tree under 1:1 and &quot;router\nitself&quot; as 1:999</p>\n\n<h2>LAYER2 ADAPTATION\n<a name=\"LAYER2 ADAPTATION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Please refer to\n<b>tc-stab</b>(8)</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>tc</b>(8),\n<b>tc-hfsc</b>(8), <b>tc-stab</b>(8)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Please direct\nbugreports and patches to:\n&lt;netdev@vger.kernel.org&gt;</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Manpage created\nby Michal Soltys (soltys@ziu.info)</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#HISTORY &amp; INTRODUCTION\">HISTORY &amp; INTRODUCTION</a>","<a href=\"#ABBREVIATIONS\">ABBREVIATIONS</a>","<a href=\"#BASICS OF HFSC\">BASICS OF HFSC</a>","<a href=\"#REALTIME CRITERION\">REALTIME CRITERION</a>","<a href=\"#LINKSHARING CRITERION\">LINKSHARING CRITERION</a>","<a href=\"#UPPERLIMIT CRITERION\">UPPERLIMIT CRITERION</a>","<a href=\"#SEPARATE LS / RT SCs\">SEPARATE LS / RT SCs</a>","<a href=\"#CORNER CASES\">CORNER CASES</a>","<a href=\"#LINUX AND TIMER RESOLUTION\">LINUX AND TIMER RESOLUTION</a>","<a href=\"#CAVEAT: RANDOM ONLINE EXAMPLES\">CAVEAT: RANDOM ONLINE EXAMPLES</a>","<a href=\"#LAYER2 ADAPTATION\">LAYER2 ADAPTATION</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>"],"level":7}