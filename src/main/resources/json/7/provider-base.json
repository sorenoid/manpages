{"name":"provider-base","description":"provider-base -\nThe basic OpenSSL library &lt;-&gt; provider functions","body":"\n\n<h1 align=\"center\">PROVIDER-BASE</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">provider-base -\nThe basic OpenSSL library &lt;-&gt; provider functions</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;openssl/core_dispatch.h&gt; <br>\n/* <br>\n* None of these are actual functions, but are displayed like\nthis for <br>\n* the function signatures for functions that are offered as\nfunction <br>\n* pointers in OSSL_DISPATCH arrays. <br>\n*/ <br>\n/* Functions offered by libcrypto to the providers */ <br>\nconst OSSL_ITEM *core_gettable_params(const OSSL_CORE_HANDLE\n*handle); <br>\nint core_get_params(const OSSL_CORE_HANDLE *handle,\nOSSL_PARAM params[]); <br>\ntypedef void (*OSSL_thread_stop_handler_fn)(void *arg); <br>\nint core_thread_start(const OSSL_CORE_HANDLE *handle, <br>\nOSSL_thread_stop_handler_fn handfn, <br>\nvoid *arg); <br>\nOPENSSL_CORE_CTX *core_get_libctx(const OSSL_CORE_HANDLE\n*handle); <br>\nvoid core_new_error(const OSSL_CORE_HANDLE *handle); <br>\nvoid core_set_error_debug(const OSSL_CORE_HANDLE *handle,\n<br>\nconst char *file, int line, const char *func); <br>\nvoid core_vset_error(const OSSL_CORE_HANDLE *handle, <br>\nuint32_t reason, const char *fmt, va_list args); <br>\nint core_obj_add_sigid(const OSSL_CORE_HANDLE *prov, const\nchar *sign_name, <br>\nconst char *digest_name, const char *pkey_name); <br>\nint core_obj_create(const OSSL_CORE_HANDLE *handle, const\nchar *oid, <br>\nconst char *sn, const char *ln); <br>\n/* <br>\n* Some OpenSSL functionality is directly offered to\nproviders via <br>\n* dispatch <br>\n*/ <br>\nvoid *CRYPTO_malloc(size_t num, const char *file, int line);\n<br>\nvoid *CRYPTO_zalloc(size_t num, const char *file, int line);\n<br>\nvoid CRYPTO_free(void *ptr, const char *file, int line);\n<br>\nvoid CRYPTO_clear_free(void *ptr, size_t num, <br>\nconst char *file, int line); <br>\nvoid *CRYPTO_realloc(void *addr, size_t num, <br>\nconst char *file, int line); <br>\nvoid *CRYPTO_clear_realloc(void *addr, size_t old_num,\nsize_t num, <br>\nconst char *file, int line); <br>\nvoid *CRYPTO_secure_malloc(size_t num, const char *file, int\nline); <br>\nvoid *CRYPTO_secure_zalloc(size_t num, const char *file, int\nline); <br>\nvoid CRYPTO_secure_free(void *ptr, const char *file, int\nline); <br>\nvoid CRYPTO_secure_clear_free(void *ptr, size_t num, <br>\nconst char *file, int line); <br>\nint CRYPTO_secure_allocated(const void *ptr); <br>\nvoid OPENSSL_cleanse(void *ptr, size_t len); <br>\nunsigned char *OPENSSL_hexstr2buf(const char *str, long\n*buflen); <br>\nOSSL_CORE_BIO *BIO_new_file(const char *filename, const char\n*mode); <br>\nOSSL_CORE_BIO *BIO_new_membuf(const void *buf, int len);\n<br>\nint BIO_read_ex(OSSL_CORE_BIO *bio, void *data, size_t\ndata_len, <br>\nsize_t *bytes_read); <br>\nint BIO_write_ex(OSSL_CORE_BIO *bio, const void *data,\nsize_t data_len, <br>\nsize_t *written); <br>\nint BIO_up_ref(OSSL_CORE_BIO *bio); <br>\nint BIO_free(OSSL_CORE_BIO *bio); <br>\nint BIO_vprintf(OSSL_CORE_BIO *bio, const char *format,\nva_list args); <br>\nint BIO_vsnprintf(char *buf, size_t n, const char *fmt,\nva_list args); <br>\nvoid OSSL_SELF_TEST_set_callback(OSSL_LIB_CTX *libctx,\nOSSL_CALLBACK *cb, <br>\nvoid *cbarg); <br>\nsize_t get_entropy(const OSSL_CORE_HANDLE *handle, <br>\nunsigned char **pout, int entropy, <br>\nsize_t min_len, size_t max_len); <br>\nvoid cleanup_entropy(const OSSL_CORE_HANDLE *handle, <br>\nunsigned char *buf, size_t len); <br>\nsize_t get_nonce(const OSSL_CORE_HANDLE *handle, <br>\nunsigned char **pout, size_t min_len, size_t max_len, <br>\nconst void *salt, size_t salt_len); <br>\nvoid cleanup_nonce(const OSSL_CORE_HANDLE *handle, <br>\nunsigned char *buf, size_t len); <br>\n/* Functions for querying the providers in the application\nlibrary context */ <br>\nint provider_register_child_cb(const OSSL_CORE_HANDLE\n*handle, <br>\nint (*create_cb)(const OSSL_CORE_HANDLE *provider, <br>\nvoid *cbdata), <br>\nint (*remove_cb)(const OSSL_CORE_HANDLE *provider, <br>\nvoid *cbdata), <br>\nint (*global_props_cb)(const char *props, void *cbdata),\n<br>\nvoid *cbdata); <br>\nvoid provider_deregister_child_cb(const OSSL_CORE_HANDLE\n*handle); <br>\nconst char *provider_name(const OSSL_CORE_HANDLE *prov);\n<br>\nvoid *provider_get0_provider_ctx(const OSSL_CORE_HANDLE\n*prov); <br>\nconst OSSL_DISPATCH *provider_get0_dispatch(const\nOSSL_CORE_HANDLE *prov); <br>\nint provider_up_ref(const OSSL_CORE_HANDLE *prov, int\nactivate); <br>\nint provider_free(const OSSL_CORE_HANDLE *prov, int\ndeactivate); <br>\n/* Functions offered by the provider to libcrypto */ <br>\nvoid provider_teardown(void *provctx); <br>\nconst OSSL_ITEM *provider_gettable_params(void *provctx);\n<br>\nint provider_get_params(void *provctx, OSSL_PARAM params[]);\n<br>\nconst OSSL_ALGORITHM *provider_query_operation(void\n*provctx, <br>\nint operation_id, <br>\nconst int *no_store); <br>\nvoid provider_unquery_operation(void *provctx, int\noperation_id, <br>\nconst OSSL_ALGORITHM *algs); <br>\nconst OSSL_ITEM *provider_get_reason_strings(void *provctx);\n<br>\nint provider_get_capabilities(void *provctx, const char\n*capability, <br>\nOSSL_CALLBACK *cb, void *arg); <br>\nint provider_self_test(void *provctx);</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">All\n&quot;functions&quot; mentioned here are passed as function\npointers between <i>libcrypto</i> and the provider in\n<b><small>OSSL_DISPATCH</small></b> arrays, in the call of\nthe provider initialization function. See\n&quot;Provider&quot; in <a href=\"https://man.page/7/provider\">provider(7)</a> for a description\nof the initialization function. They are known as\n&quot;upcalls&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All these\n&quot;functions&quot; have a corresponding function type\ndefinition named <b>OSSL_FUNC_{name}_fn</b>, and a helper\nfunction to retrieve the function pointer from a\n<b><small>OSSL_DISPATCH</small></b> element named\n<b>OSSL_FUNC_{name}</b>. For example, the\n&quot;function&quot; <b>core_gettable_params()</b> has\nthese:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">typedef\nOSSL_PARAM * <br>\n(OSSL_FUNC_core_gettable_params_fn)(const OSSL_CORE_HANDLE\n*handle); <br>\nstatic ossl_inline OSSL_NAME_core_gettable_params_fn <br>\nOSSL_FUNC_core_gettable_params(const OSSL_DISPATCH\n*opf);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>OSSL_DISPATCH</small></b>\narrays are indexed by numbers that are provided as macros in\n<b>openssl-core_dispatch.h</b>(7), as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For <i>in</i>\n(the <b><small>OSSL_DISPATCH</small></b> array passed from\n<i>libcrypto</i> to the provider):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">core_gettable_params\nOSSL_FUNC_CORE_GETTABLE_PARAMS <br>\ncore_get_params OSSL_FUNC_CORE_GET_PARAMS <br>\ncore_thread_start OSSL_FUNC_CORE_THREAD_START <br>\ncore_get_libctx OSSL_FUNC_CORE_GET_LIBCTX <br>\ncore_new_error OSSL_FUNC_CORE_NEW_ERROR <br>\ncore_set_error_debug OSSL_FUNC_CORE_SET_ERROR_DEBUG <br>\ncore_vset_error OSSL_FUNC_CORE_VSET_ERROR <br>\ncore_obj_add_sigid OSSL_FUNC_CORE_OBJ_ADD_SIGID <br>\ncore_obj_create OSSL_FUNC_CORE_OBJ_CREATE <br>\nCRYPTO_malloc OSSL_FUNC_CRYPTO_MALLOC <br>\nCRYPTO_zalloc OSSL_FUNC_CRYPTO_ZALLOC <br>\nCRYPTO_free OSSL_FUNC_CRYPTO_FREE <br>\nCRYPTO_clear_free OSSL_FUNC_CRYPTO_CLEAR_FREE <br>\nCRYPTO_realloc OSSL_FUNC_CRYPTO_REALLOC <br>\nCRYPTO_clear_realloc OSSL_FUNC_CRYPTO_CLEAR_REALLOC <br>\nCRYPTO_secure_malloc OSSL_FUNC_CRYPTO_SECURE_MALLOC <br>\nCRYPTO_secure_zalloc OSSL_FUNC_CRYPTO_SECURE_ZALLOC <br>\nCRYPTO_secure_free OSSL_FUNC_CRYPTO_SECURE_FREE <br>\nCRYPTO_secure_clear_free OSSL_FUNC_CRYPTO_SECURE_CLEAR_FREE\n<br>\nCRYPTO_secure_allocated OSSL_FUNC_CRYPTO_SECURE_ALLOCATED\n<br>\nBIO_new_file OSSL_FUNC_BIO_NEW_FILE <br>\nBIO_new_mem_buf OSSL_FUNC_BIO_NEW_MEMBUF <br>\nBIO_read_ex OSSL_FUNC_BIO_READ_EX <br>\nBIO_write_ex OSSL_FUNC_BIO_WRITE_EX <br>\nBIO_up_ref OSSL_FUNC_BIO_UP_REF <br>\nBIO_free OSSL_FUNC_BIO_FREE <br>\nBIO_vprintf OSSL_FUNC_BIO_VPRINTF <br>\nBIO_vsnprintf OSSL_FUNC_BIO_VSNPRINTF <br>\nBIO_puts OSSL_FUNC_BIO_PUTS <br>\nBIO_gets OSSL_FUNC_BIO_GETS <br>\nBIO_ctrl OSSL_FUNC_BIO_CTRL <br>\nOPENSSL_cleanse OSSL_FUNC_OPENSSL_CLEANSE <br>\nOSSL_SELF_TEST_set_callback OSSL_FUNC_SELF_TEST_CB <br>\nossl_rand_get_entropy OSSL_FUNC_GET_ENTROPY <br>\nossl_rand_cleanup_entropy OSSL_FUNC_CLEANUP_ENTROPY <br>\nossl_rand_get_nonce OSSL_FUNC_GET_NONCE <br>\nossl_rand_cleanup_nonce OSSL_FUNC_CLEANUP_NONCE <br>\nprovider_register_child_cb\nOSSL_FUNC_PROVIDER_REGISTER_CHILD_CB <br>\nprovider_deregister_child_cb\nOSSL_FUNC_PROVIDER_DEREGISTER_CHILD_CB <br>\nprovider_name OSSL_FUNC_PROVIDER_NAME <br>\nprovider_get0_provider_ctx\nOSSL_FUNC_PROVIDER_GET0_PROVIDER_CTX <br>\nprovider_get0_dispatch OSSL_FUNC_PROVIDER_GET0_DISPATCH <br>\nprovider_up_ref OSSL_FUNC_PROVIDER_UP_REF <br>\nprovider_free OSSL_FUNC_PROVIDER_FREE</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For <i>*out</i>\n(the <b><small>OSSL_DISPATCH</small></b> array passed from\nthe provider to <i>libcrypto</i>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">provider_teardown\nOSSL_FUNC_PROVIDER_TEARDOWN <br>\nprovider_gettable_params OSSL_FUNC_PROVIDER_GETTABLE_PARAMS\n<br>\nprovider_get_params OSSL_FUNC_PROVIDER_GET_PARAMS <br>\nprovider_query_operation OSSL_FUNC_PROVIDER_QUERY_OPERATION\n<br>\nprovider_unquery_operation\nOSSL_FUNC_PROVIDER_UNQUERY_OPERATION <br>\nprovider_get_reason_strings\nOSSL_FUNC_PROVIDER_GET_REASON_STRINGS <br>\nprovider_get_capabilities\nOSSL_FUNC_PROVIDER_GET_CAPABILITIES <br>\nprovider_self_test OSSL_FUNC_PROVIDER_SELF_TEST</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Core\nfunctions <br>\ncore_gettable_params()</b> returns a constant array of\ndescriptor <b><small>OSSL_PARAM</small></b> , for parameters\nthat <b>core_get_params()</b> can handle.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>core_get_params()</b>\nretrieves parameters from the core for the given\n<i>handle</i>. See &quot;Core parameters&quot; below for a\ndescription of currently known parameters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>core_thread_start()</b> function informs the core that\nthe provider has stated an interest in the current thread.\nThe core will inform the provider when the thread eventually\nstops. It must be passed the <i>handle</i> for this\nprovider, as well as a callback <i>handfn</i> which will be\ncalled when the thread stops. The callback will subsequently\nbe called, with the supplied argument <i>arg</i>, from the\nthread that is stopping and gets passed the provider context\nas an argument. This may be useful to perform thread\nspecific clean up such as freeing thread local\nvariables.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>core_get_libctx()</b>\nretrieves the core context in which the library object for\nthe current provider is stored, accessible through the\n<i>handle</i>. This function is useful only for built-in\nproviders such as the default provider. Never cast this to\n<small>OSSL_LIB_CTX</small> in a provider that is not\nbuilt-in as the <small>OSSL_LIB_CTX</small> of the library\nloading the provider might be a completely different\nstructure than the <small>OSSL_LIB_CTX</small> of the\nlibrary the provider is linked to. Use\n<a href=\"https://man.page/3/OSSL_LIB_CTX_new_child\">OSSL_LIB_CTX_new_child(3)</a> instead to obtain a proper\nlibrary context that is linked to the application library\ncontext.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>core_new_error()</b>,\n<b>core_set_error_debug()</b> and <b>core_vset_error()</b>\nare building blocks for reporting an error back to the core,\nwith reference to the <i>handle</i>. <b><br>\ncore_new_error()</b></p>\n\n<p style=\"margin-left:17%;\">allocates a new thread specific\nerror record.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This\ncorresponds to the OpenSSL function <a href=\"https://man.page/3/ERR_new\">ERR_new(3)</a>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>core_set_error_debug()</b></p>\n\n<p style=\"margin-left:17%;\">sets debugging information in\nthe current thread specific error record. The debugging\ninformation includes the name of the file <i>file</i>, the\nline <i>line</i> and the function name <i>func</i> where the\nerror occurred.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This\ncorresponds to the OpenSSL function\n<a href=\"https://man.page/3/ERR_set_debug\">ERR_set_debug(3)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>core_vset_error()</b></p>\n\n<p style=\"margin-left:17%;\">sets the <i>reason</i> for the\nerror, along with any addition data. The <i>reason</i> is a\nnumber defined by the provider and used to index the reason\nstrings table that&rsquo;s returned by\n<b>provider_get_reason_strings()</b>. The additional data is\ngiven as a format string <i>fmt</i> and a set of arguments\n<i>args</i>, which are treated in the same manner as with\n<b>BIO_vsnprintf()</b>. <i>file</i> and <i>line</i> may also\nbe passed to indicate exactly where the error occurred or\nwas reported.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This\ncorresponds to the OpenSSL function\n<a href=\"https://man.page/3/ERR_vset_error\">ERR_vset_error(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>core_obj_create()</b> function registers a new\n<small>OID</small> and associated short name <i>sn</i> and\nlong name <i>ln</i> for the given <i>handle</i>. It is\nsimilar to the OpenSSL function <a href=\"https://man.page/3/OBJ_create\">OBJ_create(3)</a> except\nthat it returns 1 on success or 0 on failure. It will treat\nas success the case where the <small>OID</small> already\nexists (even if the short name <i>sn</i> or long name\n<i>ln</i> provided as arguments differ from those associated\nwith the existing <small>OID,</small> in which case the new\nnames are not associated). This function is not thread\nsafe.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>core_obj_add_sigid()</b> function registers a new\ncomposite signature algorithm (<i>sign_name</i>) consisting\nof an underlying signature algorithm (<i>pkey_name</i>) and\ndigest algorithm (<i>digest_name</i>) for the given\n<i>handle</i>. It assumes that the OIDs for the composite\nsignature algorithm as well as for the underlying signature\nand digest algorithms are either already known to OpenSSL or\nhave been registered via a call to <b>core_obj_create()</b>.\nIt corresponds to the OpenSSL function\n<a href=\"https://man.page/3/OBJ_add_sigid\">OBJ_add_sigid(3)</a>, except that the objects are\nidentified by name rather than a numeric <small>NID.</small>\nAny name ( <small>OID,</small> short name or long name) can\nbe used to identify the object. It will treat as success the\ncase where the composite signature algorithm already exists\n(even if registered against a different underlying signature\nor digest algorithm). For <i>digest_name</i>,\n<small>NULL</small> or an empty string is permissible for\nsignature algorithms that do not need a digest to operate\ncorrectly. The function returns 1 on success or 0 on\nfailure. This function is not thread safe.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CRYPTO_malloc()</b>,\n<b>CRYPTO_zalloc()</b>, <b>CRYPTO_free()</b>,\n<b>CRYPTO_clear_free()</b>, <b>CRYPTO_realloc()</b>,\n<b>CRYPTO_clear_realloc()</b>,\n<b>CRYPTO_secure_malloc()</b>,\n<b>CRYPTO_secure_zalloc()</b>, <b>CRYPTO_secure_free()</b>,\n<b>CRYPTO_secure_clear_free()</b>,\n<b>CRYPTO_secure_allocated()</b>, <b>BIO_new_file()</b>,\n<b>BIO_new_mem_buf()</b>, <b>BIO_read_ex()</b>,\n<b>BIO_write_ex()</b>, <b>BIO_up_ref()</b>,\n<b>BIO_free()</b>, <b>BIO_vprintf()</b>,\n<b>BIO_vsnprintf()</b>, <b>BIO_gets()</b>,\n<b>BIO_puts()</b>, <b>BIO_ctrl()</b>,\n<b>OPENSSL_cleanse()</b> and <b>OPENSSL_hexstr2buf()</b>\ncorrespond exactly to the public functions with the same\nname. As a matter of fact, the pointers in the\n<b><small>OSSL_DISPATCH</small></b> array are typically\ndirect pointers to those public functions. Note that the\n<small>BIO</small> functions take an\n<b><small>OSSL_CORE_BIO</small></b> type rather than the\nstandard <b><small>BIO</small></b> type. This is to ensure\nthat a provider does not mix BIOs from the core with BIOs\nused on the provider side (the two are not compatible).\n<b>OSSL_SELF_TEST_set_callback()</b> is used to set an\noptional callback that can be passed into a provider. This\nmay be ignored by a provider.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>get_entropy()</b>\nretrieves seeding material from the operating system. The\nseeding material will have at least <i>entropy</i> bytes of\nrandomness and the output will have at least <i>min_len</i>\nand at most <i>max_len</i> bytes. The buffer address is\nstored in <i>*pout</i> and the buffer length is returned to\nthe caller. On error, zero is returned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>cleanup_entropy()</b>\nis used to clean up and free the buffer returned by\n<b>get_entropy()</b>. The entropy pointer returned by\n<b>get_entropy()</b> is passed in <b>buf</b> and its length\nin <b>len</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>get_nonce()</b>\nretrieves a nonce using the passed <i>salt</i> parameter of\nlength <i>salt_len</i> and operating system specific\ninformation. The <i>salt</i> should contain uniquely\nidentifying information and this is included, in an\nunspecified manner, as part of the output. The output is\nstored in a buffer which contrains at least <i>min_len</i>\nand at most <i>max_len</i> bytes. The buffer address is\nstored in <i>*pout</i> and the buffer length returned to the\ncaller. On error, zero is returned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>cleanup_nonce()</b>\nis used to clean up and free the buffer returned by\n<b>get_nonce()</b>. The nonce pointer returned by\n<b>get_nonce()</b> is passed in <b>buf</b> and its length in\n<b>len</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_register_child_cb()</b>\nregisters callbacks for being informed about the loading and\nunloading of providers in the application&rsquo;s library\ncontext. <i>handle</i> is this provider&rsquo;s handle and\n<i>cbdata</i> is this provider&rsquo;s data that will be\npassed back to the callbacks. It returns 1 on success or 0\notherwise. These callbacks may be called while holding locks\nin libcrypto. In order to avoid deadlocks the callback\nimplementation must not be long running and must not call\nother OpenSSL <small>API</small> functions or upcalls.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>create_cb</i>\nis a callback that will be called when a new provider is\nloaded into the application&rsquo;s library context. It is\nalso called for any providers that are already loaded at the\npoint that this callback is registered. The callback is\npassed the handle being used for the new provider being\nloadded and this provider&rsquo;s data in <i>cbdata</i>. It\nshould return 1 on success or 0 on failure.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>remove_cb</i>\nis a callback that will be called when a new provider is\nunloaded from the application&rsquo;s library context. It is\npassed the handle being used for the provider being unloaded\nand this provider&rsquo;s data in <i>cbdata</i>. It should\nreturn 1 on success or 0 on failure.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>global_props_cb</i>\nis a callback that will be called when the global properties\nfrom the parent library context are changed. It should\nreturn 1 on success or 0 on failure.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_deregister_child_cb()</b>\nunregisters callbacks previously registered via\n<b>provider_register_child_cb()</b>. If\n<b>provider_register_child_cb()</b> has been called then\n<b>provider_deregister_child_cb()</b> should be called at or\nbefore the point that this provider&rsquo;s teardown\nfunction is called.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_name()</b>\nreturns a string giving the name of the provider identified\nby <i>handle</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_get0_provider_ctx()</b>\nreturns the provider context that is associated with the\nprovider identified by <i>prov</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_get0_dispatch()</b>\ngets the dispatch table registered by the provider\nidentified by <i>prov</i> when it initialised.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_up_ref()</b>\nincrements the reference count on the provider <i>prov</i>.\nIf <i>activate</i> is nonzero then the provider is also\nloaded if it is not already loaded. It returns 1 on success\nor 0 on failure.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_free()</b>\ndecrements the reference count on the provider <i>prov</i>.\nIf <i>deactivate</i> is nonzero then the provider is also\nunloaded if it is not already loaded. It returns 1 on\nsuccess or 0 on failure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Provider\nfunctions <br>\nprovider_teardown()</b> is called when a provider is shut\ndown and removed from the core&rsquo;s provider store. It\nmust free the passed <i>provctx</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_gettable_params()</b>\nshould return a constant array of descriptor\n<b><small>OSSL_PARAM</small></b> , for parameters that\n<b>provider_get_params()</b> can handle.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_get_params()</b>\nshould process the <b><small>OSSL_PARAM</small></b> array\n<i>params</i>, setting the values of the parameters it\nunderstands.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_query_operation()</b>\nshould return a constant\n<b><small>OSSL_ALGORITHM</small></b> that corresponds to the\ngiven <i>operation_id</i>. It should indicate if the core\nmay store a reference to this array by setting\n<i>*no_store</i> to 0 (core may store a reference) or 1\n(core may not store a reference).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_unquery_operation()</b>\ninforms the provider that the result of a\n<b>provider_query_operation()</b> is no longer directly\nrequired and that the function pointers have been copied.\nThe <i>operation_id</i> should match that passed to\n<b>provider_query_operation()</b> and <i>algs</i> should be\nits return value.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_get_reason_strings()</b>\nshould return a constant <b><small>OSSL_ITEM</small></b>\narray that provides reason strings for reason codes the\nprovider may use when reporting errors using\n<b>core_put_error()</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>provider_get_capabilities()</b> function should call the\ncallback <i>cb</i> passing it a set of\n<b><small>OSSL_PARAM</small></b> s and the caller supplied\nargument <i>arg</i>. The <b><small>OSSL_PARAM</small></b> s\nshould provide details about the capability with the name\ngiven in the <i>capability</i> argument relevant for the\nprovider context <i>provctx</i>. If a provider supports\nmultiple capabilities with the given name then it may call\nthe callback multiple times (one for each capability).\nCapabilities can be useful for describing the services that\na provider can offer. For further details see the &quot;\n<small>CAPABILITIES&quot;</small> section below. It should\nreturn 1 on success or 0 on error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>provider_self_test()</b> function should perform known\nanswer tests on a subset of the algorithms that it uses, and\nmay also verify the integrity of the provider module. It\nshould return 1 on success or 0 on error. It will return 1\nif this function is not used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">None of these\nfunctions are mandatory, but a provider is fairly useless\nwithout at least <b>provider_query_operation()</b>, and\n<b>provider_gettable_params()</b> is fairly useless if not\naccompanied by <b>provider_get_params()</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Provider\nparameters <br>\nprovider_get_params()</b> can return the following provider\nparameters to the core: <br>\n&quot;name&quot; (\n<b><small>OSSL_PROV_PARAM_NAME</small></b> ) &lt;\n<small>UTF8</small> string ptr&gt;</p>\n\n<p style=\"margin-left:17%;\">This points to a string that\nshould give a unique name for the provider.</p>\n\n<p style=\"margin-left:11%;\">&quot;version&quot; (\n<b><small>OSSL_PROV_PARAM_VERSION</small></b> ) &lt;\n<small>UTF8</small> string ptr&gt;</p>\n\n<p style=\"margin-left:17%;\">This points to a string that is\na version number associated with this provider. OpenSSL\nin-built providers use <small>OPENSSL_VERSION_STR,</small>\nbut this may be different for any third party provider. This\nstring is for informational purposes only.</p>\n\n<p style=\"margin-left:11%;\">&quot;buildinfo&quot; (\n<b><small>OSSL_PROV_PARAM_BUILDINFO</small></b> ) &lt;\n<small>UTF8</small> string ptr&gt;</p>\n\n<p style=\"margin-left:17%;\">This points to a string that is\na build information associated with this provider. OpenSSL\nin-built providers use\n<small>OPENSSL_FULL_VERSION_STR,</small> but this may be\ndifferent for any third party provider.</p>\n\n<p style=\"margin-left:11%;\">&quot;status&quot; (\n<b><small>OSSL_PROV_PARAM_STATUS</small></b> ) &lt;unsigned\ninteger&gt;</p>\n\n<p style=\"margin-left:17%;\">This returns 0 if the provider\nhas entered an error state, otherwise it returns 1.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>provider_gettable_params()</b>\nshould return the above parameters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Core\nparameters <br>\ncore_get_params()</b> can retrieve the following core\nparameters for each provider: <br>\n&quot;openssl-version&quot; (\n<b><small>OSSL_PROV_PARAM_CORE_VERSION</small></b> ) &lt;\n<small>UTF8</small> string ptr&gt;</p>\n\n<p style=\"margin-left:17%;\">This points to the OpenSSL\nlibraries&rsquo; full version string, i.e. the string\nexpanded from the macro\n<b><small>OPENSSL_VERSION_STR</small></b> .</p>\n\n<p style=\"margin-left:11%;\">&quot;provider-name&quot; (\n<b><small>OSSL_PROV_PARAM_CORE_PROV_NAME</small></b> ) &lt;\n<small>UTF8</small> string ptr&gt;</p>\n\n<p style=\"margin-left:17%;\">This points to the OpenSSL\nlibraries&rsquo; idea of what the calling provider is\nnamed.</p>\n\n<p style=\"margin-left:11%;\">&quot;module-filename&quot; (\n<b><small>OSSL_PROV_PARAM_CORE_MODULE_FILENAME</small></b> )\n&lt; <small>UTF8</small> string <br>\nptr&gt;</p>\n\n<p style=\"margin-left:17%;\">This points to a string\ncontaining the full filename of the providers module\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additionally,\nprovider specific configuration parameters from the config\nfile are available, in dotted name form. The dotted name\nform is a concatenation of section names and final config\ncommand name separated by periods.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nlet&rsquo;s say we have the following config example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">config_diagnostics\n= 1 <br>\nopenssl_conf = openssl_init <br>\n[openssl_init] <br>\nproviders = providers_sect <br>\n[providers_sect] <br>\nfoo = foo_sect <br>\n[foo_sect] <br>\nactivate = 1 <br>\ndata1 = 2 <br>\ndata2 = str <br>\nmore = foo_more <br>\n[foo_more] <br>\ndata3 = foo,bar</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The provider\nwill have these additional parameters available: <br>\n&quot;activate&quot;</p>\n\n<p style=\"margin-left:17%;\">pointing at the string\n&quot;1&quot;</p>\n\n<p style=\"margin-left:11%;\">&quot;data1&quot;</p>\n\n<p style=\"margin-left:17%;\">pointing at the string\n&quot;2&quot;</p>\n\n<p style=\"margin-left:11%;\">&quot;data2&quot;</p>\n\n<p style=\"margin-left:17%;\">pointing at the string\n&quot;str&quot;</p>\n\n<p style=\"margin-left:11%;\">&quot;more.data3&quot;</p>\n\n<p style=\"margin-left:17%;\">pointing at the string\n&quot;foo,bar&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For more\ninformation on handling parameters, see\n<b><small>OSSL_PARAM</small></b> (3) as\n<a href=\"https://man.page/3/OSSL_PARAM_int\">OSSL_PARAM_int(3)</a>.</p>\n\n<h2>CAPABILITIES\n<a name=\"CAPABILITIES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Capabilities\ndescribe some of the services that a provider can offer.\nApplications can query the capabilities to discover those\nservices.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>&quot;TLS-GROUP&quot;\nCapability</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;TLS-GROUP&quot; capability can be queried by libssl to\ndiscover the list of <small>TLS</small> groups that a\nprovider can support. Each group supported can be used for\n<i>key exchange</i> ( <small>KEX</small> ) or <i>key\nencapsulation method</i> ( <small>KEM</small> ) during a\n<small>TLS</small> handshake. <small>TLS</small> clients can\nadvertise the list of <small>TLS</small> groups they support\nin the supported_groups extension, and <small>TLS</small>\nservers can select a group from the offered list that they\nalso support. In this way a provider can add to the list of\ngroups that libssl already supports with additional\nones.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each\n<small>TLS</small> group that a provider supports should be\ndescribed via the callback passed in through the\nprovider_get_capabilities function. Each group should have\nthe following details supplied (all are mandatory, except\n<b><small>OSSL_CAPABILITY_TLS_GROUP_IS_KEM</small></b> ):\n<br>\n&quot;tls-group-name&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_NAME</small></b> ) &lt;\n<small>UTF8</small> string&gt;</p>\n\n<p style=\"margin-left:17%;\">The name of the group as given\nin the <small>IANA TLS</small> Supported Groups registry\n&lt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8&gt;.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;tls-group-name-internal&quot;\n(\n<b><small>OSSL_CAPABILITY_TLS_GROUP_NAME_INTERNAL</small></b>\n) <br>\n&lt; <small>UTF8</small> string&gt;</p>\n\n<p style=\"margin-left:17%;\">The name of the group as known\nby the provider. This could be the same as the\n&quot;tls-group-name&quot;, but does not have to be.</p>\n\n<p style=\"margin-left:11%;\">&quot;tls-group-id&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_ID</small></b> )\n&lt;unsigned integer&gt;</p>\n\n<p style=\"margin-left:17%;\">The <small>TLS</small> group id\nvalue as given in the <small>IANA TLS</small> Supported\nGroups registry.</p>\n\n<p style=\"margin-left:11%;\">&quot;tls-group-alg&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_ALG</small></b> ) &lt;\n<small>UTF8</small> string&gt;</p>\n\n<p style=\"margin-left:17%;\">The name of a Key Management\nalgorithm that the provider offers and that should be used\nwith this group. Keys created should be able to support\n<i>key exchange</i> or <i>key encapsulation method</i> (\n<small>KEM</small> ), as implied by the optional\n<b><small>OSSL_CAPABILITY_TLS_GROUP_IS_KEM</small></b> flag.\nThe algorithm must support key and parameter generation as\nwell as the key/parameter generation parameter,\n<b><small>OSSL_PKEY_PARAM_GROUP_NAME</small></b> . The group\nname given via &quot;tls-group-name-internal&quot; above\nwill be passed via\n<b><small>OSSL_PKEY_PARAM_GROUP_NAME</small></b> when libssl\nwishes to generate keys/parameters.</p>\n\n<p style=\"margin-left:11%;\">&quot;tls-group-sec-bits&quot;\n(\n<b><small>OSSL_CAPABILITY_TLS_GROUP_SECURITY_BITS</small></b>\n) <br>\n&lt;unsigned integer&gt;</p>\n\n<p style=\"margin-left:17%;\">The number of bits of security\noffered by keys in this group. The number of bits should be\ncomparable with the ones given in table 2 and 3 of the\n<small>NIST SP800-57</small> document.</p>\n\n<p style=\"margin-left:11%;\">&quot;tls-group-is-kem&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_IS_KEM</small></b> )\n&lt;unsigned <br>\ninteger&gt;</p>\n\n<p style=\"margin-left:17%;\">Boolean flag to describe if the\ngroup should be used in <i>key exchange</i> (\n<small>KEX</small> ) mode (0, default) or in <i>key\nencapsulation method</i> ( <small>KEM</small> ) mode\n(1).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This parameter\nis optional: if not specified, <small>KEX</small> mode is\nassumed as the default mode for the group.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In\n<small>KEX</small> mode, in a typical Diffie-Hellman\nfashion, both sides execute <i>keygen</i> then <i>derive</i>\nagainst the peer public key. To operate in\n<small>KEX</small> mode, the group implementation must\nsupport the provider functions as described in\n<a href=\"https://man.page/7/provider-keyexch\">provider-keyexch(7)</a>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In\n<small>KEM</small> mode, the client executes <i>keygen</i>\nand sends its public key, the server executes\n<i>encapsulate</i> using the client&rsquo;s public key and\nsends back the resulting <i>ciphertext</i>, finally the\nclient executes <i>decapsulate</i> to retrieve the same\n<i>shared secret</i> generated by the server&rsquo;s\n<i>encapsulate</i>. To operate in <small>KEM</small> mode,\nthe group implementation must support the provider functions\nas described in <a href=\"https://man.page/7/provider-kem\">provider-kem(7)</a>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Both in\n<small>KEX</small> and <small>KEM</small> mode, the\nresulting <i>shared secret</i> is then used according to the\nprotocol specification.</p>\n\n<p style=\"margin-left:11%;\">&quot;tls-min-tls&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_MIN_TLS</small></b> )\n&lt;integer&gt; <br>\n&quot;tls-max-tls&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_MAX_TLS</small></b> )\n&lt;integer&gt; <br>\n&quot;tls-min-dtls&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_MIN_DTLS</small></b> )\n&lt;integer&gt; <br>\n&quot;tls-max-dtls&quot; (\n<b><small>OSSL_CAPABILITY_TLS_GROUP_MAX_DTLS</small></b> )\n&lt;integer&gt;</p>\n\n<p style=\"margin-left:17%;\">These parameters can be used to\ndescribe the minimum and maximum <small>TLS</small> and\n<small>DTLS</small> versions supported by the group. The\nvalues equate to the on-the-wire encoding of the various\n<small>TLS</small> versions. For example TLSv1.3 is 0x0304\n(772 decimal), and TLSv1.2 is 0x0303 (771 decimal). A 0\nindicates that there is no defined minimum or maximum. A -1\nindicates that the group should not be used in that\nprotocol.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is an\nexample of a simple provider made available as a dynamically\nloadable module. It implements the fictitious algorithm\n&quot;FOO&quot; for the fictitious operation\n&quot;BAR&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;malloc.h&gt; <br>\n#include &lt;openssl/core.h&gt; <br>\n#include &lt;openssl/core_dispatch.h&gt; <br>\n/* Errors used in this provider */ <br>\n#define E_MALLOC 1 <br>\nstatic const OSSL_ITEM reasons[] = { <br>\n{ E_MALLOC, &quot;memory allocation failure&quot; }. <br>\n{ 0, NULL } /* Termination */ <br>\n}; <br>\n/* <br>\n* To ensure we get the function signature right, forward\ndeclare <br>\n* them using function types provided by\nopenssl/core_dispatch.h <br>\n*/ <br>\nOSSL_FUNC_bar_newctx_fn foo_newctx; <br>\nOSSL_FUNC_bar_freectx_fn foo_freectx; <br>\nOSSL_FUNC_bar_init_fn foo_init; <br>\nOSSL_FUNC_bar_update_fn foo_update; <br>\nOSSL_FUNC_bar_final_fn foo_final; <br>\nOSSL_FUNC_provider_query_operation_fn p_query; <br>\nOSSL_FUNC_provider_get_reason_strings_fn p_reasons; <br>\nOSSL_FUNC_provider_teardown_fn p_teardown; <br>\nOSSL_provider_init_fn OSSL_provider_init; <br>\nOSSL_FUNC_core_put_error *c_put_error = NULL; <br>\n/* Provider context */ <br>\nstruct prov_ctx_st { <br>\nOSSL_CORE_HANDLE *handle; <br>\n} <br>\n/* operation context for the algorithm FOO */ <br>\nstruct foo_ctx_st { <br>\nstruct prov_ctx_st *provctx; <br>\nint b; <br>\n}; <br>\nstatic void *foo_newctx(void *provctx) <br>\n{ <br>\nstruct foo_ctx_st *fooctx = malloc(sizeof(*fooctx)); <br>\nif (fooctx != NULL) <br>\nfooctx-&gt;provctx = provctx; <br>\nelse <br>\nc_put_error(provctx-&gt;handle, E_MALLOC, __FILE__,\n__LINE__); <br>\nreturn fooctx; <br>\n} <br>\nstatic void foo_freectx(void *fooctx) <br>\n{ <br>\nfree(fooctx); <br>\n} <br>\nstatic int foo_init(void *vfooctx) <br>\n{ <br>\nstruct foo_ctx_st *fooctx = vfooctx; <br>\nfooctx-&gt;b = 0x33; <br>\n} <br>\nstatic int foo_update(void *vfooctx, unsigned char *in,\nsize_t inl) <br>\n{ <br>\nstruct foo_ctx_st *fooctx = vfooctx; <br>\n/* did you expect something serious? */ <br>\nif (inl == 0) <br>\nreturn 1; <br>\nfor (; inl-- &gt; 0; in++) <br>\n*in ^= fooctx-&gt;b; <br>\nreturn 1; <br>\n} <br>\nstatic int foo_final(void *vfooctx) <br>\n{ <br>\nstruct foo_ctx_st *fooctx = vfooctx; <br>\nfooctx-&gt;b = 0x66; <br>\n} <br>\nstatic const OSSL_DISPATCH foo_fns[] = { <br>\n{ OSSL_FUNC_BAR_NEWCTX, (void (*)(void))foo_newctx }, <br>\n{ OSSL_FUNC_BAR_FREECTX, (void (*)(void))foo_freectx }, <br>\n{ OSSL_FUNC_BAR_INIT, (void (*)(void))foo_init }, <br>\n{ OSSL_FUNC_BAR_UPDATE, (void (*)(void))foo_update }, <br>\n{ OSSL_FUNC_BAR_FINAL, (void (*)(void))foo_final }, <br>\n{ 0, NULL } <br>\n}; <br>\nstatic const OSSL_ALGORITHM bars[] = { <br>\n{ &quot;FOO&quot;, &quot;provider=chumbawamba&quot;, foo_fns\n}, <br>\n{ NULL, NULL, NULL } <br>\n}; <br>\nstatic const OSSL_ALGORITHM *p_query(void *provctx, int\noperation_id, <br>\nint *no_store) <br>\n{ <br>\nswitch (operation_id) { <br>\ncase OSSL_OP_BAR: <br>\nreturn bars; <br>\n} <br>\nreturn NULL; <br>\n} <br>\nstatic const OSSL_ITEM *p_reasons(void *provctx) <br>\n{ <br>\nreturn reasons; <br>\n} <br>\nstatic void p_teardown(void *provctx) <br>\n{ <br>\nfree(provctx); <br>\n} <br>\nstatic const OSSL_DISPATCH prov_fns[] = { <br>\n{ OSSL_FUNC_PROVIDER_TEARDOWN, (void (*)(void))p_teardown },\n<br>\n{ OSSL_FUNC_PROVIDER_QUERY_OPERATION, (void\n(*)(void))p_query }, <br>\n{ OSSL_FUNC_PROVIDER_GET_REASON_STRINGS, (void\n(*)(void))p_reasons }, <br>\n{ 0, NULL } <br>\n}; <br>\nint OSSL_provider_init(const OSSL_CORE_HANDLE *handle, <br>\nconst OSSL_DISPATCH *in, <br>\nconst OSSL_DISPATCH **out, <br>\nvoid **provctx) <br>\n{ <br>\nstruct prov_ctx_st *pctx = NULL; <br>\nfor (; in-&gt;function_id != 0; in++) <br>\nswitch (in-&gt;function_id) { <br>\ncase OSSL_FUNC_CORE_PUT_ERROR: <br>\nc_put_error = OSSL_FUNC_core_put_error(in); <br>\nbreak; <br>\n} <br>\n*out = prov_fns; <br>\nif ((pctx = malloc(sizeof(*pctx))) == NULL) { <br>\n/* <br>\n* ALEA IACTA EST, if the core retrieves the reason table\n<br>\n* regardless, that string will be displayed, otherwise not.\n<br>\n*/ <br>\nc_put_error(handle, E_MALLOC, __FILE__, __LINE__); <br>\nreturn 0; <br>\n} <br>\npctx-&gt;handle = handle; <br>\nreturn 1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This relies on\na few things existing in <i>openssl/core_dispatch.h</i>:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nOSSL_OP_BAR 4711 <br>\n#define OSSL_FUNC_BAR_NEWCTX 1 <br>\ntypedef void *(OSSL_FUNC_bar_newctx_fn)(void *provctx); <br>\nstatic ossl_inline OSSL_FUNC_bar_newctx(const OSSL_DISPATCH\n*opf) <br>\n{ return (OSSL_FUNC_bar_newctx_fn *)opf-&gt;function; } <br>\n#define OSSL_FUNC_BAR_FREECTX 2 <br>\ntypedef void (OSSL_FUNC_bar_freectx_fn)(void *ctx); <br>\nstatic ossl_inline OSSL_FUNC_bar_newctx(const OSSL_DISPATCH\n*opf) <br>\n{ return (OSSL_FUNC_bar_freectx_fn *)opf-&gt;function; }\n<br>\n#define OSSL_FUNC_BAR_INIT 3 <br>\ntypedef void *(OSSL_FUNC_bar_init_fn)(void *ctx); <br>\nstatic ossl_inline OSSL_FUNC_bar_init(const OSSL_DISPATCH\n*opf) <br>\n{ return (OSSL_FUNC_bar_init_fn *)opf-&gt;function; } <br>\n#define OSSL_FUNC_BAR_UPDATE 4 <br>\ntypedef void *(OSSL_FUNC_bar_update_fn)(void *ctx, <br>\nunsigned char *in, size_t inl); <br>\nstatic ossl_inline OSSL_FUNC_bar_update(const OSSL_DISPATCH\n*opf) <br>\n{ return (OSSL_FUNC_bar_update_fn *)opf-&gt;function; } <br>\n#define OSSL_FUNC_BAR_FINAL 5 <br>\ntypedef void *(OSSL_FUNC_bar_final_fn)(void *ctx); <br>\nstatic ossl_inline OSSL_FUNC_bar_final(const OSSL_DISPATCH\n*opf) <br>\n{ return (OSSL_FUNC_bar_final_fn *)opf-&gt;function; }</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/7/provider\">provider(7)</a></p>\n\n<h2>HISTORY\n<a name=\"HISTORY\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The concept of\nproviders and everything surrounding them was introduced in\nOpenSSL 3.0.</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n2019-2021 The OpenSSL Project Authors. All Rights\nReserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nthe Apache License 2.0 (the &quot;License&quot;). You may\nnot use this file except in compliance with the License. You\ncan obtain a copy in the file <small>LICENSE</small> in the\nsource distribution or at\n&lt;https://www.openssl.org/source/license.html&gt;.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CAPABILITIES\">CAPABILITIES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#HISTORY\">HISTORY</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":7}