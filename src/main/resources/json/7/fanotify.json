{"name":"fanotify","body":"\n\n<h1 align=\"center\">FANOTIFY</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fanotify -\nmonitoring filesystem events</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fanotify\nAPI provides notification and interception of filesystem\nevents. Use cases include virus scanning and hierarchical\nstorage management. In the original fanotify API, only a\nlimited set of events was supported. In particular, there\nwas no support for create, delete, and move events. The\nsupport for those events was added in Linux 5.1. (See\n<a href=\"https://man.page/7/inotify\">inotify(7)</a> for details of an API that did notify\nthose events pre Linux 5.1.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\ncapabilities compared to the <a href=\"https://man.page/7/inotify\">inotify(7)</a> API include\nthe ability to monitor all of the objects in a mounted\nfilesystem, the ability to make access permission decisions,\nand the possibility to read or modify files before access by\nother applications.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsystem calls are used with this API:\n<a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>, <a href=\"https://man.page/2/fanotify_mark\">fanotify_mark(2)</a>,\n<a href=\"https://man.page/2/read\">read(2)</a>, <a href=\"https://man.page/2/write\">write(2)</a>, and <a href=\"https://man.page/2/close\">close(2)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>fanotify_init(),\nfanotify_mark(), and notification groups</b> <br>\nThe <a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a> system call creates and\ninitializes an fanotify notification group and returns a\nfile descriptor referring to it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An fanotify\nnotification group is a kernel-internal object that holds a\nlist of files, directories, filesystems, and mount points\nfor which events shall be created.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For each entry\nin an fanotify notification group, two bit masks exist: the\n<i>mark</i> mask and the <i>ignore</i> mask. The mark mask\ndefines file activities for which an event shall be created.\nThe ignore mask defines activities for which no event shall\nbe generated. Having these two types of masks permits a\nfilesystem, mount point, or directory to be marked for\nreceiving events, while at the same time ignoring events for\nspecific objects under a mount point or directory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/fanotify_mark\">fanotify_mark(2)</a> system call adds a file, directory,\nfilesystem or mount point to a notification group and\nspecifies which events shall be reported (or ignored), or\nremoves or modifies such an entry.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A possible\nusage of the ignore mask is for a file cache. Events of\ninterest for a file cache are modification of a file and\nclosing of the same. Hence, the cached directory or mount\npoint is to be marked to receive these events. After\nreceiving the first event informing that a file has been\nmodified, the corresponding cache entry will be invalidated.\nNo further modification events for this file are of interest\nuntil the file is closed. Hence, the modify event can be\nadded to the ignore mask. Upon receiving the close event,\nthe modify event can be removed from the ignore mask and the\nfile cache entry can be updated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The entries in\nthe fanotify notification groups refer to files and\ndirectories via their inode number and to mounts via their\nmount ID. If files or directories are renamed or moved\nwithin the same mount, the respective entries survive. If\nfiles or directories are deleted or moved to another mount\nor if filesystems or mounts are unmounted, the corresponding\nentries are deleted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The event\nqueue</b> <br>\nAs events occur on the filesystem objects monitored by a\nnotification group, the fanotify system generates events\nthat are collected in a queue. These events can then be read\n(using <a href=\"https://man.page/2/read\">read(2)</a> or similar) from the fanotify file\ndescriptor returned by <a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Two types of\nevents are generated: <i>notification</i> events and\n<i>permission</i> events. Notification events are merely\ninformative and require no action to be taken by the\nreceiving application with one exception: if a valid file\ndescriptor is provided within a generic event, the file\ndescriptor must be closed. Permission events are requests to\nthe receiving application to decide whether permission for a\nfile access shall be granted. For these events, the\nrecipient must write a response which decides whether access\nis granted or not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An event is\nremoved from the event queue of the fanotify group when it\nhas been read. Permission events that have been read are\nkept in an internal list of the fanotify group until either\na permission decision has been taken by writing to the\nfanotify file descriptor or the fanotify file descriptor is\nclosed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading\nfanotify events</b> <br>\nCalling <a href=\"https://man.page/2/read\">read(2)</a> for the file descriptor returned by\n<a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a> blocks (if the flag\n<b>FAN_NONBLOCK</b> is not specified in the call to\n<a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>) until either a file event occurs or\nthe call is interrupted by a signal (see\n<a href=\"https://man.page/7/signal\">signal(7)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The use of one\nof the flags <b>FAN_REPORT_FID</b>,\n<b>FAN_REPORT_DIR_FID</b> in <a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>\ninfluences what data structures are returned to the event\nlistener for each event. Events reported to a group\ninitialized with one of these flags will use file handles to\nidentify filesystem objects instead of file descriptors.\n<br>\nAfter a successful</p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/read\">read(2)</a>, the read buffer\ncontains one or more of the following structures:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfanotify_event_metadata { <br>\n__u32 event_len; <br>\n__u8 vers; <br>\n__u8 reserved; <br>\n__u16 metadata_len; <br>\n__aligned_u64 mask; <br>\n__s32 fd; <br>\n__s32 pid; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In case of an\nfanotify group that identifies filesystem objects by file\nhandles, you should also expect to receive one or more\nadditional information records of the structure detailed\nbelow following the generic <i>fanotify_event_metadata</i>\nstructure within the read buffer:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfanotify_event_info_header { <br>\n__u8 info_type; <br>\n__u8 pad; <br>\n__u16 len; <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfanotify_event_info_fid { <br>\nstruct fanotify_event_info_header hdr; <br>\n__kernel_fsid_t fsid; <br>\nunsigned char file_handle[0]; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For performance\nreasons, it is recommended to use a large buffer size (for\nexample, 4096 bytes), so that multiple events can be\nretrieved by a single <a href=\"https://man.page/2/read\">read(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The return\nvalue of <a href=\"https://man.page/2/read\">read(2)</a> is the number of bytes placed in the\nbuffer, or -1 in case of an error (but see BUGS).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthe <i>fanotify_event_metadata</i> structure are as follows:\n<i><br>\nevent_len</i></p>\n\n<p style=\"margin-left:22%;\">This is the length of the data\nfor the current event and the offset to the next event in\nthe buffer. Unless the group identifies filesystem objects\nby file handles, the value of <i>event_len</i> is always\n<b>FAN_EVENT_METADATA_LEN</b>. For a group that identifies\nfilesystem objects by file handles, <i>event_len</i> also\nincludes the variable length file identifier records.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>vers</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This field holds a version number for the structure. It\nmust be compared to <b>FANOTIFY_METADATA_VERSION</b> to\nverify that the structures returned at run time match the\nstructures defined at compile time. In case of a mismatch,\nthe application should abandon trying to use the fanotify\nfile descriptor.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>reserved</i></p>\n\n<p style=\"margin-left:22%;\">This field is not used.</p>\n\n<p style=\"margin-left:11%;\"><i>metadata_len</i></p>\n\n<p style=\"margin-left:22%;\">This is the length of the\nstructure. The field was introduced to facilitate the\nimplementation of optional headers per event type. No such\noptional headers exist in the current implementation.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>mask</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This is a bit mask describing the event (see below).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>fd</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This is an open file descriptor for the object being\naccessed, or <b>FAN_NOFD</b> if a queue overflow occurred.\nWith an fanotify group that identifies filesystem objects by\nfile handles, applications should expect this value to be\nset to <b>FAN_NOFD</b> for each event that is received. The\nfile descriptor can be used to access the contents of the\nmonitored file or directory. The reading application is\nresponsible for closing this file descriptor.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">When calling\n<a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>, the caller may specify (via the\n<i>event_f_flags</i> argument) various file status flags\nthat are to be set on the open file description that\ncorresponds to this file descriptor. In addition, the\n(kernel-internal) <b>FMODE_NONOTIFY</b> file status flag is\nset on the open file description. This flag suppresses\nfanotify event generation. Hence, when the receiver of the\nfanotify event accesses the notified file or directory using\nthis file descriptor, no additional events will be\ncreated.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\"><i>pid</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">If flag <b>FAN_REPORT_TID</b>\nwas set in <a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>, this is the TID of the\nthread that caused the event. Otherwise, this the PID of the\nprocess that caused the event.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A program\nlistening to fanotify events can compare this PID to the PID\nreturned by <a href=\"https://man.page/2/getpid\">getpid(2)</a>, to determine whether the event\nis caused by the listener itself, or is due to a file access\nby another process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The bit mask in\n<i>mask</i> indicates which events have occurred for a\nsingle filesystem object. Multiple bits may be set in this\nmask, if more than one event occurred for the monitored\nfilesystem object. In particular, consecutive events for the\nsame filesystem object and originating from the same process\nmay be merged into a single event, with the exception that\ntwo permission events are never merged into one queue\nentry.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The bits that\nmay appear in <i>mask</i> are as follows: <b><br>\nFAN_ACCESS</b></p>\n\n<p style=\"margin-left:22%;\">A file or a directory (but see\nBUGS) was accessed (read).</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_OPEN</b></p>\n\n<p style=\"margin-left:22%;\">A file or a directory was\nopened.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_OPEN_EXEC</b></p>\n\n<p style=\"margin-left:22%;\">A file was opened with the\nintent to be executed. See NOTES in <a href=\"https://man.page/2/fanotify_mark\">fanotify_mark(2)</a>\nfor additional details.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_ATTRIB</b></p>\n\n<p style=\"margin-left:22%;\">A file or directory metadata\nwas changed.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_CREATE</b></p>\n\n<p style=\"margin-left:22%;\">A child file or directory was\ncreated in a watched parent.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_DELETE</b></p>\n\n<p style=\"margin-left:22%;\">A child file or directory was\ndeleted in a watched parent.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_DELETE_SELF</b></p>\n\n<p style=\"margin-left:22%;\">A watched file or directory was\ndeleted.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_MOVED_FROM</b></p>\n\n<p style=\"margin-left:22%;\">A file or directory has been\nmoved from a watched parent directory.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_MOVED_TO</b></p>\n\n<p style=\"margin-left:22%;\">A file or directory has been\nmoved to a watched parent directory.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_MOVE_SELF</b></p>\n\n<p style=\"margin-left:22%;\">A watched file or directory was\nmoved.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_MODIFY</b></p>\n\n<p style=\"margin-left:22%;\">A file was modified.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_CLOSE_WRITE</b></p>\n\n<p style=\"margin-left:22%;\">A file that was opened for\nwriting (<b>O_WRONLY</b> or <b>O_RDWR</b>) was closed.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_CLOSE_NOWRITE</b></p>\n\n<p style=\"margin-left:22%;\">A file or directory that was\nopened read-only (<b>O_RDONLY</b>) was closed.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_Q_OVERFLOW</b></p>\n\n<p style=\"margin-left:22%;\">The event queue exceeded the\nlimit of 16384 entries. This limit can be overridden by\nspecifying the <b>FAN_UNLIMITED_QUEUE</b> flag when calling\n<a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_ACCESS_PERM</b></p>\n\n<p style=\"margin-left:22%;\">An application wants to read a\nfile or directory, for example using <a href=\"https://man.page/2/read\">read(2)</a> or\n<a href=\"https://man.page/2/readdir\">readdir(2)</a>. The reader must write a response (as\ndescribed below) that determines whether the permission to\naccess the filesystem object shall be granted.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_OPEN_PERM</b></p>\n\n<p style=\"margin-left:22%;\">An application wants to open a\nfile or directory. The reader must write a response that\ndetermines whether the permission to open the filesystem\nobject shall be granted.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_OPEN_EXEC_PERM</b></p>\n\n<p style=\"margin-left:22%;\">An application wants to open a\nfile for execution. The reader must write a response that\ndetermines whether the permission to open the filesystem\nobject for execution shall be granted. See NOTES in\n<a href=\"https://man.page/2/fanotify_mark\">fanotify_mark(2)</a> for additional details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To check for\nany close event, the following bit mask may be used: <b><br>\nFAN_CLOSE</b></p>\n\n<p style=\"margin-left:22%;\">A file was closed. This is a\nsynonym for:</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\">FAN_CLOSE_WRITE\n| FAN_CLOSE_NOWRITE</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To check for\nany move event, the following bit mask may be used: <b><br>\nFAN_MOVE</b></p>\n\n<p style=\"margin-left:22%;\">A file or directory was moved.\nThis is a synonym for:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">FAN_MOVED_FROM\n| FAN_MOVED_TO</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nbits may appear in <i>mask</i> only in conjunction with\nother event type bits: <b><br>\nFAN_ONDIR</b></p>\n\n<p style=\"margin-left:22%;\">The events described in the\n<i>mask</i> have occurred on a directory object. Reporting\nevents on directories requires setting this flag in the mark\nmask. See <a href=\"https://man.page/2/fanotify_mark\">fanotify_mark(2)</a> for additional details.\nThe <b>FAN_ONDIR</b> flag is reported in an event mask only\nif the fanotify group identifies filesystem objects by file\nhandles.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthe <i>fanotify_event_info_fid</i> structure are as\nfollows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>hdr</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This is a structure of type\n<i>fanotify_event_info_header</i>. It is a generic header\nthat contains information used to describe an additional\ninformation record attached to the event. For example, when\nan fanotify file descriptor is created using\n<b>FAN_REPORT_FID</b>, a single information record is\nexpected to be attached to the event with <i>info_type</i>\nfield value of <b>FAN_EVENT_INFO_TYPE_FID</b>. When an\nfanotify file descriptor is created using the combination of\n<b>FAN_REPORT_FID</b> and <b>FAN_REPORT_DIR_FID</b>, there\nmay be two information records attached to the event: one\nwith <i>info_type</i> field value of\n<b>FAN_EVENT_INFO_TYPE_DFID</b>, identifying a parent\ndirectory object, and one with <i>info_type</i> field value\nof <b>FAN_EVENT_INFO_TYPE_FID</b>, identifying a\nnon-directory object. The <i>fanotify_event_info_header</i>\ncontains a <i>len</i> field. The value of <i>len</i> is the\nsize of the additional information record including the\n<i>fanotify_event_info_header</i> itself. The total size of\nall additional information records is not expected to be\nbigger than ( <i>event_len</i> - <i>metadata_len</i> ).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p><i>fsid</i></p></td>\n<td width=\"5%\"></td>\n<td width=\"78%\">\n\n\n<p>This is a unique identifier of the filesystem containing\nthe object associated with the event. It is a structure of\ntype <i>__kernel_fsid_t</i> and contains the same value as\n<i>f_fsid</i> when calling <a href=\"https://man.page/2/statfs\">statfs(2)</a>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>file_handle</i></p>\n\n<p style=\"margin-left:22%;\">This is a variable length\nstructure of type struct file_handle. It is an opaque handle\nthat corresponds to a specified object on a filesystem as\nreturned by <a href=\"https://man.page/2/name_to_handle_at\">name_to_handle_at(2)</a>. It can be used to\nuniquely identify a file on a filesystem and can be passed\nas an argument to <a href=\"https://man.page/2/open_by_handle_at\">open_by_handle_at(2)</a>. Note that for\nthe directory entry modification events <b>FAN_CREATE</b>,\n<b>FAN_DELETE</b>, and <b>FAN_MOVE</b>, the\n<i>file_handle</i> identifies the modified directory and not\nthe created/deleted/moved child object. If the value of\n<i>info_type</i> field is\n<b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, the file handle is\nfollowed by a null terminated string that identifies the\ncreated/deleted/moved directory entry name. For other events\nsuch as <b>FAN_OPEN</b>, <b>FAN_ATTRIB</b>,\n<b>FAN_DELETE_SELF</b>, and <b>FAN_MOVE_SELF</b>, if the\nvalue of <i>info_type</i> field is\n<b>FAN_EVENT_INFO_TYPE_FID</b>, the <i>file_handle</i>\nidentifies the object correlated to the event. If the value\nof <i>info_type</i> field is\n<b>FAN_EVENT_INFO_TYPE_DFID</b>, the <i>file_handle</i>\nidentifies the directory object correlated to the event or\nthe parent directory of a non-directory object correlated to\nthe event. If the value of <i>info_type</i> field is\n<b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, the <i>file_handle</i>\nidentifies the same directory object that would be reported\nwith <b>FAN_EVENT_INFO_TYPE_DFID</b> and the file handle is\nfollowed by a null terminated string that identifies the\nname of a directory entry in that directory, or\n&rsquo;.&rsquo; to identify the directory object itself.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmacros are provided to iterate over a buffer containing\nfanotify event metadata returned by a <a href=\"https://man.page/2/read\">read(2)</a> from an\nfanotify file descriptor: <b><br>\nFAN_EVENT_OK(meta, len)</b></p>\n\n<p style=\"margin-left:22%;\">This macro checks the remaining\nlength <i>len</i> of the buffer <i>meta</i> against the\nlength of the metadata structure and the <i>event_len</i>\nfield of the first metadata structure in the buffer.</p>\n\n<p style=\"margin-left:11%;\"><b>FAN_EVENT_NEXT(meta,\nlen)</b></p>\n\n<p style=\"margin-left:22%;\">This macro uses the length\nindicated in the <i>event_len</i> field of the metadata\nstructure pointed to by <i>meta</i> to calculate the address\nof the next metadata structure that follows <i>meta</i>.\n<i>len</i> is the number of bytes of metadata that currently\nremain in the buffer. The macro returns a pointer to the\nnext metadata structure that follows <i>meta</i>, and\nreduces <i>len</i> by the number of bytes in the metadata\nstructure that has been skipped over (i.e., it subtracts\n<i>meta-&gt;event_len</i> from <i>len</i>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nthere is: <b><br>\nFAN_EVENT_METADATA_LEN</b></p>\n\n<p style=\"margin-left:22%;\">This macro returns the size (in\nbytes) of the structure <i>fanotify_event_metadata</i>. This\nis the minimum size (and currently the only size) of any\nevent metadata.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Monitoring\nan fanotify file descriptor for events</b> <br>\nWhen an fanotify event occurs, the fanotify file descriptor\nindicates as readable when passed to <a href=\"https://man.page/7/epoll\">epoll(7)</a>,\n<a href=\"https://man.page/2/poll\">poll(2)</a>, or <a href=\"https://man.page/2/select\">select(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Dealing with\npermission events</b> <br>\nFor permission events, the application must <a href=\"https://man.page/2/write\">write(2)</a>\na structure of the following form to the fanotify file\ndescriptor:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfanotify_response { <br>\n__s32 fd; <br>\n__u32 response; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthis structure are as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>fd</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>This is the file descriptor from the structure\n<i>fanotify_event_metadata</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>response</i></p>\n\n<p style=\"margin-left:22%;\">This field indicates whether or\nnot the permission is to be granted. Its value must be\neither <b>FAN_ALLOW</b> to allow the file operation or\n<b>FAN_DENY</b> to deny the file operation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If access is\ndenied, the requesting application call will receive an\n<b>EPERM</b> error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Closing the\nfanotify file descriptor</b> <br>\nWhen all file descriptors referring to the fanotify\nnotification group are closed, the fanotify group is\nreleased and its resources are freed for reuse by the\nkernel. Upon <a href=\"https://man.page/2/close\">close(2)</a>, outstanding permission events\nwill be set to allowed.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc/[pid]/fdinfo</b>\n<br>\nThe file <i>/proc/[pid]/fdinfo/[fd]</i> contains information\nabout fanotify marks for file descriptor <i>fd</i> of\nprocess <i>pid</i>. See <a href=\"https://man.page/5/proc\">proc(5)</a> for details.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition to\nthe usual errors for <a href=\"https://man.page/2/read\">read(2)</a>, the following errors\ncan occur when reading from the fanotify file\ndescriptor:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The buffer is too small to hold the event.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The per-process limit on the number of open files has\nbeen reached. See the description of <b>RLIMIT_NOFILE</b> in\n<a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The system-wide limit on the total number of open files\nhas been reached. See <i>/proc/sys/fs/file-max</i> in\n<a href=\"https://man.page/5/proc\">proc(5)</a>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ETXTBSY</b></p>\n\n<p style=\"margin-left:22%;\">This error is returned by\n<a href=\"https://man.page/2/read\">read(2)</a> if <b>O_RDWR</b> or <b>O_WRONLY</b> was\nspecified in the <i>event_f_flags</i> argument when calling\n<a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a> and an event occurred for a\nmonitored file that is currently being executed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition to\nthe usual errors for <a href=\"https://man.page/2/write\">write(2)</a>, the following errors\ncan occur when writing to the fanotify file descriptor:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Fanotify access permissions are not enabled in the\nkernel configuration or the value of <i>response</i> in the\nresponse structure is not valid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The file descriptor <i>fd</i> in the response structure\nis not valid. This may occur when a response for the\npermission event has already been written.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fanotify\nAPI was introduced in version 2.6.36 of the Linux kernel and\nenabled in version 2.6.37. Fdinfo support was added in\nversion 3.8.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fanotify\nAPI is Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fanotify\nAPI is available only if the kernel was built with the\n<b>CONFIG_FANOTIFY</b> configuration option enabled. In\naddition, fanotify permission handling is available only if\nthe <b>CONFIG_FANOTIFY_ACCESS_PERMISSIONS</b> configuration\noption is enabled.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Limitations\nand caveats</b> <br>\nFanotify reports only events that a user-space program\ntriggers through the filesystem API. As a result, it does\nnot catch remote events that occur on network\nfilesystems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fanotify\nAPI does not report file accesses and modifications that may\noccur because of <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/msync\">msync(2)</a>, and\n<a href=\"https://man.page/2/munmap\">munmap(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Events for\ndirectories are created only if the directory itself is\nopened, read, and closed. Adding, removing, or changing\nchildren of a marked directory does not create events for\nthe monitored directory itself.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Fanotify\nmonitoring of directories is not recursive: to monitor\nsubdirectories under a directory, additional marks must be\ncreated. The <b>FAN_CREATE</b> event can be used for\ndetecting when a subdirectory has been created under a\nmarked directory. An additional mark must then be set on the\nnewly created subdirectory. This approach is racy, because\nit can lose events that occurred inside the newly created\nsubdirectory, before a mark is added on that subdirectory.\nMonitoring mounts offers the capability to monitor a whole\ndirectory tree in a race-free manner. Monitoring filesystems\noffers the capability to monitor changes made from any mount\nof a filesystem instance in a race-free manner.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The event queue\ncan overflow. In this case, events are lost.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n3.19, <a href=\"https://man.page/2/fallocate\">fallocate(2)</a> did not generate fanotify events.\nSince Linux 3.19, calls to <a href=\"https://man.page/2/fallocate\">fallocate(2)</a> generate\n<b>FAN_MODIFY</b> events.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As of Linux\n3.17, the following bugs exist:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">On Linux, a filesystem object\nmay be accessible through multiple paths, for example, a\npart of a filesystem may be remounted using the\n<i>--bind</i> option of <b>mount</b>(8). A listener that\nmarked a mount will be notified only of events that were\ntriggered for a filesystem object using the same mount. Any\nother event will pass unnoticed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>When an event is generated, no check is made to see\nwhether the user ID of the receiving process has\nauthorization to read or write the file before passing a\nfile descriptor for that file. This poses a security risk,\nwhen the <b>CAP_SYS_ADMIN</b> capability is set for programs\nexecuted by unprivileged users.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If a call to <a href=\"https://man.page/2/read\">read(2)</a> processes multiple events\nfrom the fanotify queue and an error occurs, the return\nvalue will be the total length of the events successfully\ncopied to the user-space buffer before the error occurred.\nThe return value will not be -1, and <i>errno</i> will not\nbe set. Thus, the reading application has no way to detect\nthe error.</p></td></tr>\n</table>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The two example\nprograms below demonstrate the usage of the fanotify\nAPI.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Example\nprogram: fanotify_example.c</b> <br>\nThe first program is an example of fanotify being used with\nits event object information passed in the form of a file\ndescriptor. The program marks the mount point passed as a\ncommand-line argument and waits for events of type\n<b>FAN_OPEN_PERM</b> and <b>FAN_CLOSE_WRITE</b>. When a\npermission event occurs, a <b>FAN_ALLOW</b> response is\ngiven.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session shows an example of running this program. This\nsession involved editing the file\n<i>/home/user/temp/notes</i>. Before the file was opened, a\n<b>FAN_OPEN_PERM</b> event occurred. After the file was\nclosed, a <b>FAN_CLOSE_WRITE</b> event occurred. Execution\nof the program ends when the user presses the ENTER key.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#\n<b>./fanotify_example /home</b> <br>\nPress enter key to terminate. <br>\nListening for events. <br>\nFAN_OPEN_PERM: File /home/user/temp/notes <br>\nFAN_CLOSE_WRITE: File /home/user/temp/notes</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Listening for\nevents stopped.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: fanotify_example.c</b> <br>\n#define _GNU_SOURCE /* Needed to get O_LARGEFILE definition\n*/ <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;limits.h&gt; <br>\n#include &lt;poll.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/fanotify.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read all\navailable fanotify events from the file descriptor 'fd'\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nhandle_events(int fd) <br>\n{ <br>\nconst struct fanotify_event_metadata *metadata; <br>\nstruct fanotify_event_metadata buf[200]; <br>\nssize_t len; <br>\nchar path[PATH_MAX]; <br>\nssize_t path_len; <br>\nchar procfd_path[PATH_MAX]; <br>\nstruct fanotify_response response;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Loop while\nevents can be read from fanotify file descriptor */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read some\nevents */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">len = read(fd,\nbuf, sizeof(buf)); <br>\nif (len == -1 &amp;&amp; errno != EAGAIN) { <br>\nperror(&quot;read&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Check if end\nof available data reached */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (len &lt;=\n0) <br>\nbreak;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Point to the\nfirst event in the buffer */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">metadata =\nbuf;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Loop over\nall events in the buffer */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while\n(FAN_EVENT_OK(metadata, len)) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Check that\nrun-time and compile-time structures match */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(metadata-&gt;vers != FANOTIFY_METADATA_VERSION) { <br>\nfprintf(stderr, <br>\n&quot;Mismatch of fanotify metadata version.\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/*\nmetadata-&gt;fd contains either FAN_NOFD, indicating a <br>\nqueue overflow, or a file descriptor (a nonnegative <br>\ninteger). Here, we simply ignore queue overflow. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(metadata-&gt;fd &gt;= 0) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Handle open\npermission event */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(metadata-&gt;mask &amp; FAN_OPEN_PERM) { <br>\nprintf(&quot;FAN_OPEN_PERM: &quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Allow file\nto be opened */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">response.fd =\nmetadata-&gt;fd; <br>\nresponse.response = FAN_ALLOW; <br>\nwrite(fd, &amp;response, sizeof(response)); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Handle\nclosing of writable file event */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(metadata-&gt;mask &amp; FAN_CLOSE_WRITE) <br>\nprintf(&quot;FAN_CLOSE_WRITE: &quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Retrieve and\nprint pathname of the accessed file */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">snprintf(procfd_path,\nsizeof(procfd_path), <br>\n&quot;/proc/self/fd/%d&quot;, metadata-&gt;fd); <br>\npath_len = readlink(procfd_path, path, <br>\nsizeof(path) - 1); <br>\nif (path_len == -1) { <br>\nperror(&quot;readlink&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">path[path_len]\n= '\\0'; <br>\nprintf(&quot;File %s\\n&quot;, path);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Close the\nfile descriptor of the event */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(metadata-&gt;fd);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Advance to\nnext event */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">metadata =\nFAN_EVENT_NEXT(metadata, len); <br>\n} <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nchar buf; <br>\nint fd, poll_num; <br>\nnfds_t nfds; <br>\nstruct pollfd fds[2];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Check mount\npoint is supplied */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Usage: %s MOUNT\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Press\nenter key to terminate.\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create the\nfile descriptor for accessing the fanotify API */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nfanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT |\nFAN_NONBLOCK, <br>\nO_RDONLY | O_LARGEFILE); <br>\nif (fd == -1) { <br>\nperror(&quot;fanotify_init&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Mark the\nmount for: <br>\n- permission events before opening files <br>\n- notification events after closing a write-enabled <br>\nfile descriptor */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT, <br>\nFAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD, <br>\nargv[1]) == -1) { <br>\nperror(&quot;fanotify_mark&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Prepare for\npolling */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nfds = 2;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Console\ninput */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fds[0].fd =\nSTDIN_FILENO; <br>\nfds[0].events = POLLIN;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Fanotify\ninput */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fds[1].fd = fd;\n<br>\nfds[1].events = POLLIN;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* This is the\nloop to wait for incoming events */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Listening\nfor events.\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while (1) {\n<br>\npoll_num = poll(fds, nfds, -1); <br>\nif (poll_num == -1) { <br>\nif (errno == EINTR) /* Interrupted by a signal */ <br>\ncontinue; /* Restart poll() */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">perror(&quot;poll&quot;);\n/* Unexpected error */ <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (poll_num\n&gt; 0) { <br>\nif (fds[0].revents &amp; POLLIN) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Console\ninput is available: empty stdin and quit */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while\n(read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf !=\n'\\n') <br>\ncontinue; <br>\nbreak; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fds[1].revents &amp; POLLIN) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Fanotify\nevents are available */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">handle_events(fd);\n<br>\n} <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Listening\nfor events stopped.\\n&quot;); <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Example\nprogram: fanotify_fid.c</b> <br>\nThe second program is an example of fanotify being used with\na group that identifies objects by file handles. The program\nmarks the filesystem object that is passed as a command-line\nargument and waits until an event of type <b>FAN_CREATE</b>\nhas occurred. The event mask indicates which type of\nfilesystem object&mdash;either a file or a\ndirectory&mdash;was created. Once all events have been read\nfrom the buffer and processed accordingly, the program\nsimply terminates.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell sessions show two different invocations of this\nprogram, with different actions performed on a watched\nobject.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first\nsession shows a mark being placed on <i>/home/user</i>. This\nis followed by the creation of a regular file,\n<i>/home/user/testfile.txt</i>. This results in a\n<b>FAN_CREATE</b> event being generated and reported against\nthe file&rsquo;s parent watched directory object and with\nthe created file name. Program execution ends once all\nevents captured within the buffer have been processed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#\n<b>./fanotify_fid /home/user</b> <br>\nListening for events. <br>\nFAN_CREATE (file created): <br>\nDirectory /home/user has been modified. <br>\nEntry 'testfile.txt' is not a subdirectory. <br>\nAll events processed successfully. Program exiting.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>touch\n/home/user/testfile.txt</b> # In another terminal</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second\nsession shows a mark being placed on <i>/home/user</i>. This\nis followed by the creation of a directory,\n<i>/home/user/testdir</i>. This specific action results in a\n<b>FAN_CREATE</b> event being generated and is reported with\nthe <b>FAN_ONDIR</b> flag set and with the created directory\nname.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#\n<b>./fanotify_fid /home/user</b> <br>\nListening for events. <br>\nFAN_CREATE | FAN_ONDIR (subdirectory created): <br>\nDirectory /home/user has been modified. <br>\nEntry 'testdir' is a subdirectory. <br>\nAll events processed successfully. Program exiting.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>mkdir -p\n/home/user/testdir</b> # In another terminal</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: fanotify_fid.c</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;limits.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;sys/stat.h&gt; <br>\n#include &lt;sys/fanotify.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nBUF_SIZE 256</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char **argv) <br>\n{ <br>\nint fd, ret, event_fd, mount_fd; <br>\nssize_t len, path_len; <br>\nchar path[PATH_MAX]; <br>\nchar procfd_path[PATH_MAX]; <br>\nchar events_buf[BUF_SIZE]; <br>\nstruct file_handle *file_handle; <br>\nstruct fanotify_event_metadata *metadata; <br>\nstruct fanotify_event_info_fid *fid; <br>\nconst char *file_name; <br>\nstruct stat sb;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Invalid number of command line\narguments.\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">mount_fd =\nopen(argv[1], O_DIRECTORY | O_RDONLY); <br>\nif (mount_fd == -1) { <br>\nperror(argv[1]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create an\nfanotify file descriptor with FAN_REPORT_DFID_NAME as <br>\na flag so that program can receive fid events with directory\n<br>\nentry name. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fd =\nfanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_DFID_NAME, 0);\n<br>\nif (fd == -1) { <br>\nperror(&quot;fanotify_init&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Place a mark\non the filesystem object supplied in argv[1]. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\nfanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR, <br>\nFAN_CREATE | FAN_ONDIR, <br>\nAT_FDCWD, argv[1]); <br>\nif (ret == -1) { <br>\nperror(&quot;fanotify_mark&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Listening\nfor events.\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read events\nfrom the event queue into a buffer */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">len = read(fd,\nevents_buf, sizeof(events_buf)); <br>\nif (len == -1 &amp;&amp; errno != EAGAIN) { <br>\nperror(&quot;read&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Process all\nevents within the buffer */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (metadata =\n(struct fanotify_event_metadata *) events_buf; <br>\nFAN_EVENT_OK(metadata, len); <br>\nmetadata = FAN_EVENT_NEXT(metadata, len)) { <br>\nfid = (struct fanotify_event_info_fid *) (metadata + 1);\n<br>\nfile_handle = (struct file_handle *) fid-&gt;handle;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Ensure that\nthe event info is of the correct type */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(fid-&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_FID || <br>\nfid-&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_DFID) { <br>\nfile_name = NULL; <br>\n} else if (fid-&gt;hdr.info_type ==\nFAN_EVENT_INFO_TYPE_DFID_NAME) { <br>\nfile_name = file_handle-&gt;f_handle + <br>\nfile_handle-&gt;handle_bytes; <br>\n} else { <br>\nfprintf(stderr, &quot;Received unexpected event info\ntype.\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(metadata-&gt;mask == FAN_CREATE) <br>\nprintf(&quot;FAN_CREATE (file created):\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(metadata-&gt;mask == (FAN_CREATE | FAN_ONDIR)) <br>\nprintf(&quot;FAN_CREATE | FAN_ONDIR (subdirectory\ncreated):\\n&quot;);</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>/* metadata-&gt;fd is set to FAN_NOFD when the group\nidentifies</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>objects by file handles. To obtain a file descriptor\nfor</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>the file object corresponding to an event you can use\nthe</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>struct file_handle that's provided within the</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>fanotify_event_info_fid in conjunction with the</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>open_by_handle_at(2) system call. A check for ESTALE\nis</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>done to accommodate for the situation where the file\nhandle</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"92%\">\n\n\n<p>for the object was deleted prior to this system call.\n*/</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">event_fd =\nopen_by_handle_at(mount_fd, file_handle, O_RDONLY); <br>\nif (event_fd == -1) { <br>\nif (errno == ESTALE) { <br>\nprintf(&quot;File handle is no longer valid. &quot; <br>\n&quot;File has been deleted\\n&quot;); <br>\ncontinue; <br>\n} else { <br>\nperror(&quot;open_by_handle_at&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">snprintf(procfd_path,\nsizeof(procfd_path), &quot;/proc/self/fd/%d&quot;, <br>\nevent_fd);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Retrieve and\nprint the path of the modified dentry */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">path_len =\nreadlink(procfd_path, path, sizeof(path) - 1); <br>\nif (path_len == -1) { <br>\nperror(&quot;readlink&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">path[path_len]\n= '\\0'; <br>\nprintf(&quot;\\tDirectory '%s' has been modified.\\n&quot;,\npath);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (file_name)\n{ <br>\nret = fstatat(event_fd, file_name, &amp;sb, 0); <br>\nif (ret == -1) { <br>\nif (errno != ENOENT) { <br>\nperror(&quot;fstatat&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nprintf(&quot;\\tEntry '%s' does not exist.\\n&quot;,\nfile_name); <br>\n} else if ((sb.st_mode &amp; S_IFMT) == S_IFDIR) { <br>\nprintf(&quot;\\tEntry '%s' is a subdirectory.\\n&quot;,\nfile_name); <br>\n} else { <br>\nprintf(&quot;\\tEntry '%s' is not a subdirectory.\\n&quot;,\n<br>\nfile_name); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Close\nassociated file descriptor for this event */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(event_fd);\n<br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;All\nevents processed successfully. Program exiting.\\n&quot;);\n<br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/fanotify_init\">fanotify_init(2)</a>,\n<a href=\"https://man.page/2/fanotify_mark\">fanotify_mark(2)</a>, <a href=\"https://man.page/7/inotify\">inotify(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}