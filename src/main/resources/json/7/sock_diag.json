{"name":"sock_diag","description":"sock_diag -\nobtaining information about sockets","body":"\n\n<h1 align=\"center\">SOCK_DIAG</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sock_diag -\nobtaining information about sockets</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/socket.h&gt; <br>\n#include &lt;linux/sock_diag.h&gt; <br>\n#include &lt;linux/unix_diag.h&gt;</b> /* for UNIX domain\nsockets */ <b><br>\n#include &lt;linux/inet_diag.h&gt;</b> /* for IPv4 and IPv6\nsockets */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>diag_socket\n= socket(AF_NETLINK,</b> <i>socket_type</i><b>,\nNETLINK_SOCK_DIAG);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sock_diag\nnetlink subsystem provides a mechanism for obtaining\ninformation about sockets of various address families from\nthe kernel. This subsystem can be used to obtain information\nabout individual sockets or request a list of sockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the request,\nthe caller can specify additional information it would like\nto obtain about the socket, for example, memory information\nor information specific to the address family.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When requesting\na list of sockets, the caller can specify filters that would\nbe applied by the kernel to select a subset of sockets to\nreport. For now, there is only the ability to filter sockets\nby state (connected, listening, and so on.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\nsock_diag reports only those sockets that have a name; that\nis, either sockets bound explicitly with <a href=\"https://man.page/2/bind\">bind(2)</a> or\nsockets that were automatically bound to an address (e.g.,\nby <a href=\"https://man.page/2/connect\">connect(2)</a>). This is the same set of sockets that\nis available via <i>/proc/net/unix</i>,\n<i>/proc/net/tcp</i>, <i>/proc/net/udp</i>, and so on.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Request</b>\n<br>\nThe request starts with a <i>struct nlmsghdr</i> header\ndescribed in <a href=\"https://man.page/7/netlink\">netlink(7)</a> with <i>nlmsg_type</i> field\nset to <b>SOCK_DIAG_BY_FAMILY</b>. It is followed by a\nheader specific to the address family that starts with a\ncommon part shared by all address families:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nsock_diag_req { <br>\n__u8 sdiag_family; <br>\n__u8 sdiag_protocol; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthis structure are as follows: <i><br>\nsdiag_family</i></p>\n\n<p style=\"margin-left:22%;\">An address family. It should be\nset to the appropriate <b>AF_*</b> constant.</p>\n\n<p style=\"margin-left:11%;\"><i>sdiag_protocol</i></p>\n\n<p style=\"margin-left:22%;\">Depends on <i>sdiag_family</i>.\nIt should be set to the appropriate <b>IPPROTO_*</b>\nconstant for <b>AF_INET</b> and <b>AF_INET6</b>, and to 0\notherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<i>nlmsg_flags</i> field of the <i>struct nlmsghdr</i>\nheader has the <b>NLM_F_DUMP</b> flag set, it means that a\nlist of sockets is being requested; otherwise it is a query\nabout an individual socket.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Response</b>\n<br>\nThe response starts with a <i>struct nlmsghdr</i> header and\nis followed by an array of objects specific to the address\nfamily. The array is to be accessed with the standard\n<b>NLMSG_*</b> macros from the <a href=\"https://man.page/3/netlink\">netlink(3)</a> API.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each object is\nthe NLA (netlink attributes) list that is to be accessed\nwith the <b>RTA_*</b> macros from <a href=\"https://man.page/3/rtnetlink\">rtnetlink(3)</a>\nAPI.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>UNIX domain\nsockets</b> <br>\nFor UNIX domain sockets the request is represented in the\nfollowing structure:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nunix_diag_req { <br>\n__u8 sdiag_family; <br>\n__u8 sdiag_protocol; <br>\n__u16 pad; <br>\n__u32 udiag_states; <br>\n__u32 udiag_ino; <br>\n__u32 udiag_show; <br>\n__u32 udiag_cookie[2]; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthis structure are as follows: <i><br>\nsdiag_family</i></p>\n\n<p style=\"margin-left:22%;\">The address family; it should\nbe set to <b>AF_UNIX</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>sdiag_protocol</i></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><i>pad</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"49%\">\n\n\n<p>These fields should be set to 0.</p></td>\n<td width=\"29%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>udiag_states</i></p>\n\n<p style=\"margin-left:22%;\">This is a bit mask that defines\na filter of sockets states. Only those sockets whose states\nare in this mask will be reported. Ignored when querying for\nan individual socket. Supported values are:</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">1 &lt;&lt;\n<b>TCP_ESTABLISHED</b></p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">1 &lt;&lt;\n<b>TCP_LISTEN</b></p>\n\n<p style=\"margin-left:11%;\"><i>udiag_ino</i></p>\n\n<p style=\"margin-left:22%;\">This is an inode number when\nquerying for an individual socket. Ignored when querying for\na list of sockets.</p>\n\n<p style=\"margin-left:11%;\"><i>udiag_show</i></p>\n\n<p style=\"margin-left:22%;\">This is a set of flags defining\nwhat kind of information to report. Each requested kind of\ninformation is reported back as a netlink attribute as\ndescribed below: <b><br>\nUDIAG_SHOW_NAME</b></p>\n\n<p style=\"margin-left:32%;\">The attribute reported in\nanswer to this request is <b>UNIX_DIAG_NAME</b>. The payload\nassociated with this attribute is the pathname to which the\nsocket was bound (a sequence of bytes up to\n<b>UNIX_PATH_MAX</b> length).</p>\n\n<p style=\"margin-left:22%;\"><b>UDIAG_SHOW_VFS</b></p>\n\n<p style=\"margin-left:32%;\">The attribute reported in\nanswer to this request is <b>UNIX_DIAG_VFS</b>. The payload\nassociated with this attribute is represented in the\nfollowing structure:</p>\n\n<p style=\"margin-left:38%; margin-top: 1em\">struct\nunix_diag_vfs { <br>\n__u32 udiag_vfs_dev; <br>\n__u32 udiag_vfs_ino; <br>\n};</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The fields of\nthis structure are as follows: <i><br>\nudiag_vfs_dev</i></p>\n\n<p style=\"margin-left:43%;\">The device number of the\ncorresponding on-disk socket inode.</p>\n\n<p style=\"margin-left:32%;\"><i>udiag_vfs_ino</i></p>\n\n<p style=\"margin-left:43%;\">The inode number of the\ncorresponding on-disk socket inode.</p>\n\n<p style=\"margin-left:22%;\"><b>UDIAG_SHOW_PEER</b></p>\n\n<p style=\"margin-left:32%;\">The attribute reported in\nanswer to this request is <b>UNIX_DIAG_PEER</b>. The payload\nassociated with this attribute is a __u32 value which is the\npeer&rsquo;s inode number. This attribute is reported for\nconnected sockets only.</p>\n\n<p style=\"margin-left:22%;\"><b>UDIAG_SHOW_ICONS</b></p>\n\n<p style=\"margin-left:32%;\">The attribute reported in\nanswer to this request is <b>UNIX_DIAG_ICONS</b>. The\npayload associated with this attribute is an array of __u32\nvalues which are inode numbers of sockets that has passed\nthe <a href=\"https://man.page/2/connect\">connect(2)</a> call, but hasn&rsquo;t been processed\nwith <a href=\"https://man.page/2/accept\">accept(2)</a> yet. This attribute is reported for\nlistening sockets only.</p>\n\n<p style=\"margin-left:22%;\"><b>UDIAG_SHOW_RQLEN</b></p>\n\n<p style=\"margin-left:32%;\">The attribute reported in\nanswer to this request is <b>UNIX_DIAG_RQLEN</b>. The\npayload associated with this attribute is represented in the\nfollowing structure:</p>\n\n<p style=\"margin-left:38%; margin-top: 1em\">struct\nunix_diag_rqlen { <br>\n__u32 udiag_rqueue; <br>\n__u32 udiag_wqueue; <br>\n};</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The fields of\nthis structure are as follows: <i><br>\nudiag_rqueue</i></p>\n\n<p style=\"margin-left:43%;\">For listening sockets: the\nnumber of pending connections. The length of the array\nassociated with the <b>UNIX_DIAG_ICONS</b> response\nattribute is equal to this value.</p>\n\n<p style=\"margin-left:43%; margin-top: 1em\">For established\nsockets: the amount of data in incoming queue.</p>\n\n<p style=\"margin-left:32%;\"><i>udiag_wqueue</i></p>\n\n<p style=\"margin-left:43%;\">For listening sockets: the\nbacklog length which equals to the value passed as the\nsecond argument to <a href=\"https://man.page/2/listen\">listen(2)</a>.</p>\n\n<p style=\"margin-left:43%; margin-top: 1em\">For established\nsockets: the amount of memory available for sending.</p>\n\n<p style=\"margin-left:22%;\"><b>UDIAG_SHOW_MEMINFO</b></p>\n\n<p style=\"margin-left:32%;\">The attribute reported in\nanswer to this request is <b>UNIX_DIAG_MEMINFO</b>. The\npayload associated with this attribute is an array of __u32\nvalues described below in the subsection &quot;Socket memory\ninformation&quot;.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The following\nattributes are reported back without any specific request:\n<b><br>\nUNIX_DIAG_SHUTDOWN</b></p>\n\n<p style=\"margin-left:32%;\">The payload associated with\nthis attribute is __u8 value which represents bits of\n<a href=\"https://man.page/2/shutdown\">shutdown(2)</a> state.</p>\n\n<p style=\"margin-left:11%;\"><i>udiag_cookie</i></p>\n\n<p style=\"margin-left:22%;\">This is an array of opaque\nidentifiers that could be used along with <i>udiag_ino</i>\nto specify an individual socket. It is ignored when querying\nfor a list of sockets, as well as when all its elements are\nset to -1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The response to\na query for UNIX domain sockets is represented as an array\nof</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nunix_diag_msg { <br>\n__u8 udiag_family; <br>\n__u8 udiag_type; <br>\n__u8 udiag_state; <br>\n__u8 pad; <br>\n__u32 udiag_ino; <br>\n__u32 udiag_cookie[2]; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">followed by\nnetlink attributes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthis structure are as follows: <i><br>\nudiag_family</i></p>\n\n<p style=\"margin-left:22%;\">This field has the same meaning\nas in <i>struct unix_diag_req</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>udiag_type</i></p>\n\n<p style=\"margin-left:22%;\">This is set to one of\n<b>SOCK_PACKET</b>, <b>SOCK_STREAM</b>, or\n<b>SOCK_SEQPACKET</b>.</p>\n\n<p style=\"margin-left:11%;\"><i>udiag_state</i></p>\n\n<p style=\"margin-left:22%;\">This is set to one of\n<b>TCP_LISTEN</b> or <b>TCP_ESTABLISHED</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><i>pad</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"35%\">\n\n\n<p>This field is set to 0.</p></td>\n<td width=\"43%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>udiag_ino</i></p>\n\n<p style=\"margin-left:22%;\">This is the socket inode\nnumber.</p>\n\n<p style=\"margin-left:11%;\"><i>udiag_cookie</i></p>\n\n<p style=\"margin-left:22%;\">This is an array of opaque\nidentifiers that could be used in subsequent queries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>IPv4 and\nIPv6 sockets</b> <br>\nFor IPv4 and IPv6 sockets, the request is represented in the\nfollowing structure:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\ninet_diag_req_v2 { <br>\n__u8 sdiag_family; <br>\n__u8 sdiag_protocol; <br>\n__u8 idiag_ext; <br>\n__u8 pad; <br>\n__u32 idiag_states; <br>\nstruct inet_diag_sockid id; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where <i>struct\ninet_diag_sockid</i> is defined as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\ninet_diag_sockid { <br>\n__be16 idiag_sport; <br>\n__be16 idiag_dport; <br>\n__be32 idiag_src[4]; <br>\n__be32 idiag_dst[4]; <br>\n__u32 idiag_if; <br>\n__u32 idiag_cookie[2]; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\n<i>struct inet_diag_req_v2</i> are as follows: <i><br>\nsdiag_family</i></p>\n\n<p style=\"margin-left:22%;\">This should be set to either\n<b>AF_INET</b> or <b>AF_INET6</b> for IPv4 or IPv6 sockets\nrespectively.</p>\n\n<p style=\"margin-left:11%;\"><i>sdiag_protocol</i></p>\n\n<p style=\"margin-left:22%;\">This should be set to one of\n<b>IPPROTO_TCP</b>, <b>IPPROTO_UDP</b>, or\n<b>IPPROTO_UDPLITE</b>.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_ext</i></p>\n\n<p style=\"margin-left:22%;\">This is a set of flags defining\nwhat kind of extended information to report. Each requested\nkind of information is reported back as a netlink attribute\nas described below: <b><br>\nINET_DIAG_TOS</b></p>\n\n<p style=\"margin-left:32%;\">The payload associated with\nthis attribute is a __u8 value which is the TOS of the\nsocket.</p>\n\n<p style=\"margin-left:22%;\"><b>INET_DIAG_TCLASS</b></p>\n\n<p style=\"margin-left:32%;\">The payload associated with\nthis attribute is a __u8 value which is the TClass of the\nsocket. IPv6 sockets only. For LISTEN and CLOSE sockets,\nthis is followed by <b>INET_DIAG_SKV6ONLY</b> attribute with\nassociated __u8 payload value meaning whether the socket is\nIPv6-only or not.</p>\n\n<p style=\"margin-left:22%;\"><b>INET_DIAG_MEMINFO</b></p>\n\n<p style=\"margin-left:32%;\">The payload associated with\nthis attribute is represented in the following\nstructure:</p>\n\n<p style=\"margin-left:38%; margin-top: 1em\">struct\ninet_diag_meminfo { <br>\n__u32 idiag_rmem; <br>\n__u32 idiag_wmem; <br>\n__u32 idiag_fmem; <br>\n__u32 idiag_tmem; <br>\n};</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">The fields of\nthis structure are as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"16%\">\n\n\n<p><i>idiag_rmem</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"49%\">\n\n\n<p>The amount of data in the receive queue.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"16%\">\n\n\n<p><i>idiag_wmem</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"49%\">\n\n\n<p>The amount of data that is queued by TCP but not yet\nsent.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"16%\">\n\n\n<p><i>idiag_fmem</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"49%\">\n\n\n<p>The amount of memory scheduled for future use (TCP\nonly).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"32%\"></td>\n<td width=\"16%\">\n\n\n<p><i>idiag_tmem</i></p></td>\n<td width=\"3%\"></td>\n<td width=\"49%\">\n\n\n<p>The amount of data in send queue.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>INET_DIAG_SKMEMINFO</b></p>\n\n<p style=\"margin-left:32%;\">The payload associated with\nthis attribute is an array of __u32 values described below\nin the subsection &quot;Socket memory information&quot;.</p>\n\n<p style=\"margin-left:22%;\"><b>INET_DIAG_INFO</b></p>\n\n<p style=\"margin-left:32%;\">The payload associated with\nthis attribute is specific to the address family. For TCP\nsockets, it is an object of type <i>struct tcp_info</i>.</p>\n\n<p style=\"margin-left:22%;\"><b>INET_DIAG_CONG</b></p>\n\n<p style=\"margin-left:32%;\">The payload associated with\nthis attribute is a string that describes the congestion\ncontrol algorithm used. For TCP sockets only.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><i>pad</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"36%\">\n\n\n<p>This should be set to 0.</p></td>\n<td width=\"42%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><i>idiag_states</i></p>\n\n<p style=\"margin-left:22%;\">This is a bit mask that defines\na filter of socket states. Only those sockets whose states\nare in this mask will be reported. Ignored when querying for\nan individual socket.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>id</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>This is a socket ID object that is used in dump\nrequests, in queries about individual sockets, and is\nreported back in each response. Unlike UNIX domain sockets,\nIPv4 and IPv6 sockets are identified using addresses and\nports. All values are in network byte order.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\n<i>struct inet_diag_sockid</i> are as follows: <i><br>\nidiag_sport</i></p>\n\n<p style=\"margin-left:22%;\">The source port.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_dport</i></p>\n\n<p style=\"margin-left:22%;\">The destination port.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_src</i></p>\n\n<p style=\"margin-left:22%;\">The source address.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_dst</i></p>\n\n<p style=\"margin-left:22%;\">The destination address.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_if</i></p>\n\n<p style=\"margin-left:22%;\">The interface number the socket\nis bound to.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_cookie</i></p>\n\n<p style=\"margin-left:22%;\">This is an array of opaque\nidentifiers that could be used along with other fields of\nthis structure to specify an individual socket. It is\nignored when querying for a list of sockets, as well as when\nall its elements are set to -1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The response to\na query for IPv4 or IPv6 sockets is represented as an array\nof</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\ninet_diag_msg { <br>\n__u8 idiag_family; <br>\n__u8 idiag_state; <br>\n__u8 idiag_timer; <br>\n__u8 idiag_retrans;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\ninet_diag_sockid id;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">__u32\nidiag_expires; <br>\n__u32 idiag_rqueue; <br>\n__u32 idiag_wqueue; <br>\n__u32 idiag_uid; <br>\n__u32 idiag_inode; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">followed by\nnetlink attributes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fields of\nthis structure are as follows: <i><br>\nidiag_family</i></p>\n\n<p style=\"margin-left:22%;\">This is the same field as in\n<i>struct inet_diag_req_v2</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_state</i></p>\n\n<p style=\"margin-left:22%;\">This denotes socket state as in\n<i>struct inet_diag_req_v2</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_timer</i></p>\n\n<p style=\"margin-left:22%;\">For TCP sockets, this field\ndescribes the type of timer that is currently active for the\nsocket. It is set to one of the following constants:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p><b>0</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"38%\">\n\n\n<p>no timer is active</p></td>\n<td width=\"22%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p><b>1</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"38%\">\n\n\n<p>a retransmit timer</p></td>\n<td width=\"22%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p><b>2</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"38%\">\n\n\n<p>a keep-alive timer</p></td>\n<td width=\"22%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p><b>3</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"38%\">\n\n\n<p>a TIME_WAIT timer</p></td>\n<td width=\"22%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p><b>4</b></p></td>\n<td width=\"9%\"></td>\n<td width=\"38%\">\n\n\n<p>a zero window probe timer</p></td>\n<td width=\"22%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For non-TCP\nsockets, this field is set to 0.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_retrans</i></p>\n\n<p style=\"margin-left:22%;\">For <i>idiag_timer</i> values\n1, 2, and 4, this field contains the number of retransmits.\nFor other <i>idiag_timer</i> values, this field is set to\n0.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_expires</i></p>\n\n<p style=\"margin-left:22%;\">For TCP sockets that have an\nactive timer, this field describes its expiration time in\nmilliseconds. For other sockets, this field is set to 0.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_rqueue</i></p>\n\n<p style=\"margin-left:22%;\">For listening sockets: the\nnumber of pending connections.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For other\nsockets: the amount of data in the incoming queue.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_wqueue</i></p>\n\n<p style=\"margin-left:22%;\">For listening sockets: the\nbacklog length.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For other\nsockets: the amount of memory available for sending.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_uid</i></p>\n\n<p style=\"margin-left:22%;\">This is the socket owner\nUID.</p>\n\n<p style=\"margin-left:11%;\"><i>idiag_inode</i></p>\n\n<p style=\"margin-left:22%;\">This is the socket inode\nnumber.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Socket\nmemory information</b> <br>\nThe payload associated with <b>UNIX_DIAG_MEMINFO</b> and\n<b>INET_DIAG_SKMEMINFO</b> netlink attributes is an array of\nthe following __u32 values: <b><br>\nSK_MEMINFO_RMEM_ALLOC</b></p>\n\n<p style=\"margin-left:22%;\">The amount of data in receive\nqueue.</p>\n\n<p style=\"margin-left:11%;\"><b>SK_MEMINFO_RCVBUF</b></p>\n\n<p style=\"margin-left:22%;\">The receive socket buffer as\nset by <b>SO_RCVBUF</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>SK_MEMINFO_WMEM_ALLOC</b></p>\n\n<p style=\"margin-left:22%;\">The amount of data in send\nqueue.</p>\n\n<p style=\"margin-left:11%;\"><b>SK_MEMINFO_SNDBUF</b></p>\n\n<p style=\"margin-left:22%;\">The send socket buffer as set\nby <b>SO_SNDBUF</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>SK_MEMINFO_FWD_ALLOC</b></p>\n\n<p style=\"margin-left:22%;\">The amount of memory scheduled\nfor future use (TCP only).</p>\n\n\n<p style=\"margin-left:11%;\"><b>SK_MEMINFO_WMEM_QUEUED</b></p>\n\n<p style=\"margin-left:22%;\">The amount of data queued by\nTCP, but not yet sent.</p>\n\n<p style=\"margin-left:11%;\"><b>SK_MEMINFO_OPTMEM</b></p>\n\n<p style=\"margin-left:22%;\">The amount of memory allocated\nfor the socket&rsquo;s service needs (e.g., socket\nfilter).</p>\n\n<p style=\"margin-left:11%;\"><b>SK_MEMINFO_BACKLOG</b></p>\n\n<p style=\"margin-left:22%;\">The amount of packets in the\nbacklog (not yet processed).</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>NETLINK_INET_DIAG</b>\nwas introduced in Linux 2.6.14 and supported <b>AF_INET</b>\nand <b>AF_INET6</b> sockets only. In Linux 3.3, it was\nrenamed to <b>NETLINK_SOCK_DIAG</b> and extended to support\n<b>AF_UNIX</b> sockets.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>UNIX_DIAG_MEMINFO</b>\nand <b>INET_DIAG_SKMEMINFO</b> were introduced in Linux\n3.6.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nNETLINK_SOCK_DIAG API is Linux-specific.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nexample program prints inode number, peer&rsquo;s inode\nnumber, and name of all UNIX domain sockets in the current\nnamespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;errno.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;sys/un.h&gt; <br>\n#include &lt;linux/netlink.h&gt; <br>\n#include &lt;linux/rtnetlink.h&gt; <br>\n#include &lt;linux/sock_diag.h&gt; <br>\n#include &lt;linux/unix_diag.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\nsend_query(int fd) <br>\n{ <br>\nstruct sockaddr_nl nladdr = { <br>\n.nl_family = AF_NETLINK <br>\n}; <br>\nstruct <br>\n{ <br>\nstruct nlmsghdr nlh; <br>\nstruct unix_diag_req udr; <br>\n} req = { <br>\n.nlh = { <br>\n.nlmsg_len = sizeof(req), <br>\n.nlmsg_type = SOCK_DIAG_BY_FAMILY, <br>\n.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP <br>\n}, <br>\n.udr = { <br>\n.sdiag_family = AF_UNIX, <br>\n.udiag_states = -1, <br>\n.udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER <br>\n} <br>\n}; <br>\nstruct iovec iov = { <br>\n.iov_base = &amp;req, <br>\n.iov_len = sizeof(req) <br>\n}; <br>\nstruct msghdr msg = { <br>\n.msg_name = &amp;nladdr, <br>\n.msg_namelen = sizeof(nladdr), <br>\n.msg_iov = &amp;iov, <br>\n.msg_iovlen = 1 <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { <br>\nif (sendmsg(fd, &amp;msg, 0) &lt; 0) { <br>\nif (errno == EINTR) <br>\ncontinue;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">perror(&quot;sendmsg&quot;);\n<br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return 0; <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\nprint_diag(const struct unix_diag_msg *diag, unsigned int\nlen) <br>\n{ <br>\nif (len &lt; NLMSG_LENGTH(sizeof(*diag))) { <br>\nfputs(&quot;short response\\n&quot;, stderr); <br>\nreturn -1; <br>\n} <br>\nif (diag-&gt;udiag_family != AF_UNIX) { <br>\nfprintf(stderr, &quot;unexpected family %u\\n&quot;,\ndiag-&gt;udiag_family); <br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">unsigned int\nrta_len = len - NLMSG_LENGTH(sizeof(*diag)); <br>\nunsigned int peer = 0; <br>\nsize_t path_len = 0; <br>\nchar path[sizeof(((struct sockaddr_un *) 0)-&gt;sun_path) +\n1];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (struct\nrtattr *attr = (struct rtattr *) (diag + 1); <br>\nRTA_OK(attr, rta_len); attr = RTA_NEXT(attr, rta_len)) {\n<br>\nswitch (attr-&gt;rta_type) { <br>\ncase UNIX_DIAG_NAME: <br>\nif (!path_len) { <br>\npath_len = RTA_PAYLOAD(attr); <br>\nif (path_len &gt; sizeof(path) - 1) <br>\npath_len = sizeof(path) - 1; <br>\nmemcpy(path, RTA_DATA(attr), path_len); <br>\npath[path_len] = '\\0'; <br>\n} <br>\nbreak;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">case\nUNIX_DIAG_PEER: <br>\nif (RTA_PAYLOAD(attr) &gt;= sizeof(peer)) <br>\npeer = *(unsigned int *) RTA_DATA(attr); <br>\nbreak; <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;inode=%u&quot;,\ndiag-&gt;udiag_ino);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (peer) <br>\nprintf(&quot;, peer=%u&quot;, peer);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (path_len)\n<br>\nprintf(&quot;, name=%s%s&quot;, *path ? &quot;&quot; :\n&quot;@&quot;, <br>\n*path ? path : path + 1);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">putchar('\\n');\n<br>\nreturn 0; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\nreceive_responses(int fd) <br>\n{ <br>\nlong buf[8192 / sizeof(long)]; <br>\nstruct sockaddr_nl nladdr = { <br>\n.nl_family = AF_NETLINK <br>\n}; <br>\nstruct iovec iov = { <br>\n.iov_base = buf, <br>\n.iov_len = sizeof(buf) <br>\n}; <br>\nint flags = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { <br>\nstruct msghdr msg = { <br>\n.msg_name = &amp;nladdr, <br>\n.msg_namelen = sizeof(nladdr), <br>\n.msg_iov = &amp;iov, <br>\n.msg_iovlen = 1 <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ssize_t ret =\nrecvmsg(fd, &amp;msg, flags);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (ret &lt; 0)\n{ <br>\nif (errno == EINTR) <br>\ncontinue;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">perror(&quot;recvmsg&quot;);\n<br>\nreturn -1; <br>\n} <br>\nif (ret == 0) <br>\nreturn 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">const struct\nnlmsghdr *h = (struct nlmsghdr *) buf;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(!NLMSG_OK(h, ret)) { <br>\nfputs(&quot;!NLMSG_OK\\n&quot;, stderr); <br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;\nNLMSG_OK(h, ret); h = NLMSG_NEXT(h, ret)) { <br>\nif (h-&gt;nlmsg_type == NLMSG_DONE) <br>\nreturn 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(h-&gt;nlmsg_type == NLMSG_ERROR) { <br>\nconst struct nlmsgerr *err = NLMSG_DATA(h);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(h-&gt;nlmsg_len &lt; NLMSG_LENGTH(sizeof(*err))) { <br>\nfputs(&quot;NLMSG_ERROR\\n&quot;, stderr); <br>\n} else { <br>\nerrno = -err-&gt;error; <br>\nperror(&quot;NLMSG_ERROR&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return -1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(h-&gt;nlmsg_type != SOCK_DIAG_BY_FAMILY) { <br>\nfprintf(stderr, &quot;unexpected nlmsg_type %u\\n&quot;, <br>\n(unsigned) h-&gt;nlmsg_type); <br>\nreturn -1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(print_diag(NLMSG_DATA(h), h-&gt;nlmsg_len)) <br>\nreturn -1; <br>\n} <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(void) <br>\n{ <br>\nint fd = socket(AF_NETLINK, SOCK_RAW,\nNETLINK_SOCK_DIAG);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (fd &lt; 0)\n{ <br>\nperror(&quot;socket&quot;); <br>\nreturn 1; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int ret =\nsend_query(fd) || receive_responses(fd);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(fd); <br>\nreturn ret; <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/netlink\">netlink(3)</a>,\n<a href=\"https://man.page/3/rtnetlink\">rtnetlink(3)</a>, <a href=\"https://man.page/7/netlink\">netlink(7)</a>, <a href=\"https://man.page/7/tcp\">tcp(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}