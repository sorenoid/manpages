{"name":"unix","body":"\n\n<h1 align=\"center\">UNIX</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">unix - sockets\nfor local interprocess communication</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/socket.h&gt; <br>\n#include &lt;sys/un.h&gt;</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>unix_socket</i>\n<b>= socket(AF_UNIX, type, 0);</b> <i><br>\nerror</i> <b>= socketpair(AF_UNIX, type, 0, int\n*</b><i>sv</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>AF_UNIX</b> (also known as <b>AF_LOCAL</b>) socket family\nis used to communicate between processes on the same machine\nefficiently. Traditionally, UNIX domain sockets can be\neither unnamed, or bound to a filesystem pathname (marked as\nbeing of type socket). Linux also supports an abstract\nnamespace which is independent of the filesystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Valid socket\ntypes in the UNIX domain are: <b>SOCK_STREAM</b>, for a\nstream-oriented socket; <b>SOCK_DGRAM</b>, for a\ndatagram-oriented socket that preserves message boundaries\n(as on most UNIX implementations, UNIX domain datagram\nsockets are always reliable and don&rsquo;t reorder\ndatagrams); and (since Linux 2.6.4) <b>SOCK_SEQPACKET</b>,\nfor a sequenced-packet socket that is connection-oriented,\npreserves message boundaries, and delivers messages in the\norder that they were sent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">UNIX domain\nsockets support passing file descriptors or process\ncredentials to other processes using ancillary data.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Address\nformat</b> <br>\nA UNIX domain socket address is represented in the following\nstructure:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nsockaddr_un { <br>\nsa_family_t sun_family; /* AF_UNIX */ <br>\nchar sun_path[108]; /* Pathname */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>sun_family</i> field always contains <b>AF_UNIX</b>. On\nLinux, <i>sun_path</i> is 108 bytes in size; see also NOTES,\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Various systems\ncalls (for example, <a href=\"https://man.page/2/bind\">bind(2)</a>, <a href=\"https://man.page/2/connect\">connect(2)</a>, and\n<a href=\"https://man.page/2/sendto\">sendto(2)</a>) take a <i>sockaddr_un</i> argument as\ninput. Some other system calls (for example,\n<a href=\"https://man.page/2/getsockname\">getsockname(2)</a>, <a href=\"https://man.page/2/getpeername\">getpeername(2)</a>,\n<a href=\"https://man.page/2/recvfrom\">recvfrom(2)</a>, and <a href=\"https://man.page/2/accept\">accept(2)</a>) return an argument\nof this type.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Three types of\naddress are distinguished in the <i>sockaddr_un</i>\nstructure:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>pathname</i>: a UNIX domain socket can be bound to a\nnull-terminated filesystem pathname using <a href=\"https://man.page/2/bind\">bind(2)</a>.\nWhen the address of a pathname socket is returned (by one of\nthe system calls noted above), its length is</p></td></tr>\n</table>\n\n\n<p style=\"margin-left:15%; margin-top: 1em\">offsetof(struct\nsockaddr_un, sun_path) + strlen(sun_path) + 1</p>\n\n<p style=\"margin-left:15%; margin-top: 1em\">and\n<i>sun_path</i> contains the null-terminated pathname. (On\nLinux, the above <b>offsetof</b>() expression equates to the\nsame value as <i>sizeof(sa_family_t)</i>, but some other\nimplementations include other fields before <i>sun_path</i>,\nso the <b>offsetof</b>() expression more portably describes\nthe size of the address structure.)</p>\n\n<p style=\"margin-left:15%; margin-top: 1em\">For further\ndetails of pathname sockets, see below.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\"><i>unnamed</i>: A stream socket\nthat has not been bound to a pathname using <a href=\"https://man.page/2/bind\">bind(2)</a>\nhas no name. Likewise, the two sockets created by\n<a href=\"https://man.page/2/socketpair\">socketpair(2)</a> are unnamed. When the address of an\nunnamed socket is returned, its length is\n<i>sizeof(sa_family_t)</i>, and <i>sun_path</i> should not\nbe inspected.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>abstract</i>: an abstract socket address is\ndistinguished (from a pathname socket) by the fact that\n<i>sun_path[0]</i> is a null byte ('\\0'). The socket&rsquo;s\naddress in this namespace is given by the additional bytes\nin <i>sun_path</i> that are covered by the specified length\nof the address structure. (Null bytes in the name have no\nspecial significance.) The name has no connection with\nfilesystem pathnames. When the address of an abstract socket\nis returned, the returned <i>addrlen</i> is greater than\n<i>sizeof(sa_family_t)</i> (i.e., greater than 2), and the\nname of the socket is contained in the first <i>(addrlen -\nsizeof(sa_family_t))</i> bytes of <i>sun_path</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Pathname\nsockets</b> <br>\nWhen binding a socket to a pathname, a few rules should be\nobserved for maximum portability and ease of coding:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The pathname in <i>sun_path</i>\nshould be null-terminated.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The length of the pathname, including the terminating\nnull byte, should not exceed the size of\n<i>sun_path</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The <i>addrlen</i> argument that describes the enclosing\n<i>sockaddr_un</i> structure should have a value of at\nleast:</p> </td></tr>\n</table>\n\n\n<p style=\"margin-left:15%; margin-top: 1em\">offsetof(struct\nsockaddr_un, sun_path)+strlen(addr.sun_path)+1</p>\n\n<p style=\"margin-left:15%; margin-top: 1em\">or, more\nsimply, <i>addrlen</i> can be specified as <i>sizeof(struct\nsockaddr_un)</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is some\nvariation in how implementations handle UNIX domain socket\naddresses that do not follow the above rules. For example,\nsome (but not all) implementations append a null terminator\nif none is present in the supplied <i>sun_path</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When coding\nportable applications, keep in mind that some\nimplementations have <i>sun_path</i> as short as 92\nbytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Various system\ncalls (<a href=\"https://man.page/2/accept\">accept(2)</a>, <a href=\"https://man.page/2/recvfrom\">recvfrom(2)</a>,\n<a href=\"https://man.page/2/getsockname\">getsockname(2)</a>, <a href=\"https://man.page/2/getpeername\">getpeername(2)</a>) return socket\naddress structures. When applied to UNIX domain sockets, the\nvalue-result <i>addrlen</i> argument supplied to the call\nshould be initialized as above. Upon return, the argument is\nset to indicate the <i>actual</i> size of the address\nstructure. The caller should check the value returned in\nthis argument: if the output value exceeds the input value,\nthen there is no guarantee that a null terminator is present\nin <i>sun_path</i>. (See BUGS.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Pathname\nsocket ownership and permissions</b> <br>\nIn the Linux implementation, pathname sockets honor the\npermissions of the directory they are in. Creation of a new\nsocket fails if the process does not have write and search\n(execute) permission on the directory in which the socket is\ncreated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On Linux,\nconnecting to a stream socket object requires write\npermission on that socket; sending a datagram to a datagram\nsocket likewise requires write permission on that socket.\nPOSIX does not make any statement about the effect of the\npermissions on a socket file, and on some systems (e.g.,\nolder BSDs), the socket permissions are ignored. Portable\nprograms should not rely on this feature for security.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When creating a\nnew socket, the owner and group of the socket file are set\naccording to the usual rules. The socket file has all\npermissions enabled, other than those that are turned off by\nthe process <a href=\"https://man.page/2/umask\">umask(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The owner,\ngroup, and permissions of a pathname socket can be changed\n(using <a href=\"https://man.page/2/chown\">chown(2)</a> and <a href=\"https://man.page/2/chmod\">chmod(2)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Abstract\nsockets</b> <br>\nSocket permissions have no meaning for abstract sockets: the\nprocess <a href=\"https://man.page/2/umask\">umask(2)</a> has no effect when binding an\nabstract socket, and changing the ownership and permissions\nof the object (via <a href=\"https://man.page/2/fchown\">fchown(2)</a> and <a href=\"https://man.page/2/fchmod\">fchmod(2)</a>)\nhas no effect on the accessibility of the socket.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Abstract\nsockets automatically disappear when all open references to\nthe socket are closed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The abstract\nsocket namespace is a nonportable Linux extension.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Socket\noptions</b> <br>\nFor historical reasons, these socket options are specified\nwith a <b>SOL_SOCKET</b> type even though they are\n<b>AF_UNIX</b> specific. They can be set with\n<a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a> and read with <a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> by\nspecifying <b>SOL_SOCKET</b> as the socket family. <b><br>\nSO_PASSCRED</b></p>\n\n<p style=\"margin-left:22%;\">Enabling this socket option\ncauses receipt of the credentials of the sending process in\nan <b>SCM_CREDENTIALS ancillary</b> message in each\nsubsequently received message. The returned credentials are\nthose specified by the sender using <b>SCM_CREDENTIALS</b>,\nor a default that includes the sender&rsquo;s PID, real user\nID, and real group ID, if the sender did not specify\n<b>SCM_CREDENTIALS</b> ancillary data.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">When this\noption is set and the socket is not yet connected, a unique\nname in the abstract namespace will be generated\nautomatically.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The value given\nas an argument to <a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a> and returned as the\nresult of <a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> is an integer boolean\nflag.</p>\n\n<p style=\"margin-left:11%;\"><b>SO_PASSSEC</b></p>\n\n<p style=\"margin-left:22%;\">Enables receiving of the\nSELinux security label of the peer socket in an ancillary\nmessage of type <b>SCM_SECURITY</b> (see below).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The value given\nas an argument to <a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a> and returned as the\nresult of <a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> is an integer boolean\nflag.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>SO_PASSSEC</b> option is supported for UNIX domain\ndatagram sockets since Linux 2.6.18; support for UNIX domain\nstream sockets was added in Linux 4.2.</p>\n\n<p style=\"margin-left:11%;\"><b>SO_PEEK_OFF</b></p>\n\n<p style=\"margin-left:22%;\">See <a href=\"https://man.page/7/socket\">socket(7)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>SO_PEERCRED</b></p>\n\n<p style=\"margin-left:22%;\">This read-only socket option\nreturns the credentials of the peer process connected to\nthis socket. The returned credentials are those that were in\neffect at the time of the call to <a href=\"https://man.page/2/connect\">connect(2)</a> or\n<a href=\"https://man.page/2/socketpair\">socketpair(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument to\n<a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> is a pointer to a <i>ucred</i>\nstructure; define the <b>_GNU_SOURCE</b> feature test macro\nto obtain the definition of that structure from\n<i>&lt;sys/socket.h&gt;</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The use of this\noption is possible only for connected <b>AF_UNIX</b> stream\nsockets and for <b>AF_UNIX</b> stream and datagram socket\npairs created using <a href=\"https://man.page/2/socketpair\">socketpair(2)</a>.</p>\n\n<p style=\"margin-left:11%;\"><b>SO_PEERSEC</b></p>\n\n<p style=\"margin-left:22%;\">This read-only socket option\nreturns the security context of the peer socket connected to\nthis socket. By default, this will be the same as the\nsecurity context of the process that created the peer socket\nunless overridden by the policy or by a process with the\nrequired permissions.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The argument to\n<a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> is a pointer to a buffer of the\nspecified length in bytes into which the security context\nstring will be copied. If the buffer length is less than the\nlength of the security context string, then\n<a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> returns -1, sets <i>errno</i> to\n<b>ERANGE</b>, and returns the required length via\n<i>optlen</i>. The caller should allocate at least\n<b>NAME_MAX</b> bytes for the buffer initially, although\nthis is not guaranteed to be sufficient. Resizing the buffer\nto the returned length and retrying may be necessary.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The security\ncontext string may include a terminating null character in\nthe returned length, but is not guaranteed to do so: a\nsecurity context &quot;foo&quot; might be represented as\neither {&rsquo;f&rsquo;,&rsquo;o&rsquo;,&rsquo;o&rsquo;} of\nlength 3 or\n{&rsquo;f&rsquo;,&rsquo;o&rsquo;,&rsquo;o&rsquo;,&rsquo;\\0&rsquo;}\nof length 4, which are considered to be interchangeable. The\nstring is printable, does not contain non-terminating null\ncharacters, and is in an unspecified encoding (in\nparticular, it is not guaranteed to be ASCII or UTF-8).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The use of this\noption for sockets in the <b>AF_UNIX</b> address family is\nsupported since Linux 2.6.2 for connected stream sockets,\nand since Linux 4.18 also for stream and datagram socket\npairs created using <a href=\"https://man.page/2/socketpair\">socketpair(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Autobind\nfeature</b> <br>\nIf a <a href=\"https://man.page/2/bind\">bind(2)</a> call specifies <i>addrlen</i> as\n<i>sizeof(sa_family_t)</i>, or the <b>SO_PASSCRED</b> socket\noption was specified for a socket that was not explicitly\nbound to an address, then the socket is autobound to an\nabstract address. The address consists of a null byte\nfollowed by 5 bytes in the character set <i>[0-9a-f]</i>.\nThus, there is a limit of 2^20 autobind addresses. (From\nLinux 2.1.15, when the autobind feature was added, 8 bytes\nwere used, and the limit was thus 2^32 autobind addresses.\nThe change to 5 bytes came in Linux 2.3.15.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Sockets\nAPI</b> <br>\nThe following paragraphs describe domain-specific details\nand unsupported features of the sockets API for UNIX domain\nsockets on Linux.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">UNIX domain\nsockets do not support the transmission of out-of-band data\n(the <b>MSG_OOB</b> flag for <a href=\"https://man.page/2/send\">send(2)</a> and\n<a href=\"https://man.page/2/recv\">recv(2)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/send\">send(2)</a> <b>MSG_MORE</b> flag is not supported by UNIX\ndomain sockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before Linux\n3.4, the use of <b>MSG_TRUNC</b> in the <i>flags</i>\nargument of <a href=\"https://man.page/2/recv\">recv(2)</a> was not supported by UNIX domain\nsockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>SO_SNDBUF</b> socket option does have an effect for UNIX\ndomain sockets, but the <b>SO_RCVBUF</b> option does not.\nFor datagram sockets, the <b>SO_SNDBUF</b> value imposes an\nupper limit on the size of outgoing datagrams. This limit is\ncalculated as the doubled (see <a href=\"https://man.page/7/socket\">socket(7)</a>) option\nvalue less 32 bytes used for overhead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Ancillary\nmessages</b> <br>\nAncillary data is sent and received using <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>\nand <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>. For historical reasons, the ancillary\nmessage types listed below are specified with a\n<b>SOL_SOCKET</b> type even though they are <b>AF_UNIX</b>\nspecific. To send them, set the <i>cmsg_level</i> field of\nthe struct <i>cmsghdr</i> to <b>SOL_SOCKET</b> and the\n<i>cmsg_type</i> field to the type. For more information,\nsee <a href=\"https://man.page/3/cmsg\">cmsg(3)</a>. <b><br>\nSCM_RIGHTS</b></p>\n\n<p style=\"margin-left:22%;\">Send or receive a set of open\nfile descriptors from another process. The data portion\ncontains an integer array of the file descriptors.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Commonly, this\noperation is referred to as &quot;passing a file\ndescriptor&quot; to another process. However, more\naccurately, what is being passed is a reference to an open\nfile description (see <a href=\"https://man.page/2/open\">open(2)</a>), and in the receiving\nprocess it is likely that a different file descriptor number\nwill be used. Semantically, this operation is equivalent to\nduplicating (<a href=\"https://man.page/2/dup\">dup(2)</a>) a file descriptor into the file\ndescriptor table of another process.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the buffer\nused to receive the ancillary data containing file\ndescriptors is too small (or is absent), then the ancillary\ndata is truncated (or discarded) and the excess file\ndescriptors are automatically closed in the receiving\nprocess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the number\nof file descriptors received in the ancillary data would\ncause the process to exceed its <b>RLIMIT_NOFILE</b>\nresource limit (see <a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>), the excess file\ndescriptors are automatically closed in the receiving\nprocess.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The kernel\nconstant <b>SCM_MAX_FD</b> defines a limit on the number of\nfile descriptors in the array. Attempting to send an array\nlarger than this limit causes <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> to fail with\nthe error <b>EINVAL</b>. <b>SCM_MAX_FD</b> has the value 253\n(or 255 in kernels before 2.6.38).</p>\n\n<p style=\"margin-left:11%;\"><b>SCM_CREDENTIALS</b></p>\n\n<p style=\"margin-left:22%;\">Send or receive UNIX\ncredentials. This can be used for authentication. The\ncredentials are passed as a <i>struct ucred</i> ancillary\nmessage. This structure is defined in\n<i>&lt;sys/socket.h&gt;</i> as follows:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct ucred {\n<br>\npid_t pid; /* Process ID of the sending process */ <br>\nuid_t uid; /* User ID of the sending process */ <br>\ngid_t gid; /* Group ID of the sending process */ <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Since glibc\n2.8, the <b>_GNU_SOURCE</b> feature test macro must be\ndefined (before including <i>any</i> header files) in order\nto obtain the definition of this structure.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The credentials\nwhich the sender specifies are checked by the kernel. A\nprivileged process is allowed to specify values that do not\nmatch its own. The sender must specify its own process ID\n(unless it has the capability <b>CAP_SYS_ADMIN</b>, in which\ncase the PID of any existing process may be specified), its\nreal user ID, effective user ID, or saved set-user-ID\n(unless it has <b>CAP_SETUID</b>), and its real group ID,\neffective group ID, or saved set-group-ID (unless it has\n<b>CAP_SETGID</b>).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">To receive a\n<i>struct ucred</i> message, the <b>SO_PASSCRED</b> option\nmust be enabled on the socket.</p>\n\n<p style=\"margin-left:11%;\"><b>SCM_SECURITY</b></p>\n\n<p style=\"margin-left:22%;\">Receive the SELinux security\ncontext (the security label) of the peer socket. The\nreceived ancillary data is a null-terminated string\ncontaining the security context. The receiver should\nallocate at least <b>NAME_MAX</b> bytes in the data portion\nof the ancillary message for this data.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">To receive the\nsecurity context, the <b>SO_PASSSEC</b> option must be\nenabled on the socket (see above).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When sending\nancillary data with <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>, only one item of each\nof the above types may be included in the sent message.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">At least one\nbyte of real data should be sent when sending ancillary\ndata. On Linux, this is required to successfully send\nancillary data over a UNIX domain stream socket. When\nsending ancillary data over a UNIX domain datagram socket,\nit is not necessary on Linux to send any accompanying real\ndata. However, portable applications should also include at\nleast one byte of real data when sending ancillary data over\na datagram socket.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When receiving\nfrom a stream socket, ancillary data forms a kind of barrier\nfor the received data. For example, suppose that the sender\ntransmits as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p><a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> of four bytes, with no ancillary\ndata.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p><a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> of one byte, with ancillary data.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p><a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> of four bytes, with no ancillary\ndata.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose that\nthe receiver now performs <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a> calls each with\na buffer size of 20 bytes. The first call will receive five\nbytes of data, along with the ancillary data sent by the\nsecond <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> call. The next call will receive\nthe remaining four bytes of data.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the space\nallocated for receiving incoming ancillary data is too small\nthen the ancillary data is truncated to the number of\nheaders that will fit in the supplied buffer (or, in the\ncase of an <b>SCM_RIGHTS</b> file descriptor list, the list\nof file descriptors may be truncated). If no buffer is\nprovided for incoming ancillary data (i.e., the\n<i>msg_control</i> field of the <i>msghdr</i> structure\nsupplied to <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a> is NULL), then the incoming\nancillary data is discarded. In both of these cases, the\n<b>MSG_CTRUNC</b> flag will be set in the\n<i>msg.msg_flags</i> value returned by\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Ioctls</b>\n<br>\nThe following <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> calls return information in\n<i>value</i>. The correct syntax is:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>int</b>\n<i>value</i><b>;</b> <i><br>\nerror</i> <b>= ioctl(</b><i>unix_socket</i><b>,</b>\n<i>ioctl_type</i><b>, &amp;</b><i>value</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>ioctl_type</i>\ncan be: <b><br>\nSIOCINQ</b></p>\n\n<p style=\"margin-left:22%;\">For <b>SOCK_STREAM</b> sockets,\nthis call returns the number of unread bytes in the receive\nbuffer. The socket must not be in LISTEN state, otherwise an\nerror (<b>EINVAL</b>) is returned. <b>SIOCINQ</b> is defined\nin <i>&lt;linux/sockios.h&gt;</i>. Alternatively, you can\nuse the synonymous <b>FIONREAD</b>, defined in\n<i>&lt;sys/ioctl.h&gt;</i>. For <b>SOCK_DGRAM</b> sockets,\nthe returned value is the same as for Internet domain\ndatagram sockets; see <a href=\"https://man.page/7/udp\">udp(7)</a>.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>EADDRINUSE</b></p>\n\n<p style=\"margin-left:22%;\">The specified local address is\nalready in use or the filesystem socket object already\nexists.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>This error can occur for <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> when sending\na file descriptor as ancillary data over a UNIX domain\nsocket (see the description of <b>SCM_RIGHTS</b>, above),\nand indicates that the file descriptor number that is being\nsent is not valid (e.g., it is not an open file\ndescriptor).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ECONNREFUSED</b></p>\n\n<p style=\"margin-left:22%;\">The remote address specified by\n<a href=\"https://man.page/2/connect\">connect(2)</a> was not a listening socket. This error can\nalso occur if the target pathname is not a socket.</p>\n\n<p style=\"margin-left:11%;\"><b>ECONNRESET</b></p>\n\n<p style=\"margin-left:22%;\">Remote socket was unexpectedly\nclosed.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>User memory address was not valid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Invalid argument passed. A common cause is that the\nvalue <b>AF_UNIX</b> was not specified in the\n<i>sun_type</i> field of passed addresses, or the socket was\nin an invalid state for the applied operation.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EISCONN</b></p>\n\n<p style=\"margin-left:22%;\"><a href=\"https://man.page/2/connect\">connect(2)</a> called on an\nalready connected socket or a target address was specified\non a connected socket.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The pathname in the remote address specified to\n<a href=\"https://man.page/2/connect\">connect(2)</a> did not exist.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Out of memory.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTCONN</b></p>\n\n<p style=\"margin-left:22%;\">Socket operation needs a target\naddress, but the socket is not connected.</p>\n\n<p style=\"margin-left:11%;\"><b>EOPNOTSUPP</b></p>\n\n<p style=\"margin-left:22%;\">Stream operation called on\nnon-stream oriented socket or tried to use the out-of-band\ndata option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>The sender passed invalid credentials in the <i>struct\nucred</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EPIPE</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Remote socket was closed on a stream socket. If enabled,\na <b>SIGPIPE</b> is sent as well. This can be avoided by\npassing the <b>MSG_NOSIGNAL</b> flag to <a href=\"https://man.page/2/send\">send(2)</a> or\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EPROTONOSUPPORT</b></p>\n\n<p style=\"margin-left:22%;\">Passed protocol is not\n<b>AF_UNIX</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>EPROTOTYPE</b></p>\n\n<p style=\"margin-left:22%;\">Remote socket does not match\nthe local socket type (<b>SOCK_DGRAM</b> versus\n<b>SOCK_STREAM</b>).</p>\n\n<p style=\"margin-left:11%;\"><b>ESOCKTNOSUPPORT</b></p>\n\n<p style=\"margin-left:22%;\">Unknown socket type.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>ESRCH</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>While sending an ancillary message containing\ncredentials (<b>SCM_CREDENTIALS</b>), the caller specified a\nPID that does not match any existing process.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ETOOMANYREFS</b></p>\n\n<p style=\"margin-left:22%;\">This error can occur for\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> when sending a file descriptor as\nancillary data over a UNIX domain socket (see the\ndescription of <b>SCM_RIGHTS</b>, above). It occurs if the\nnumber of &quot;in-flight&quot; file descriptors exceeds the\n<b>RLIMIT_NOFILE</b> resource limit and the caller does not\nhave the <b>CAP_SYS_RESOURCE</b> capability. An in-flight\nfile descriptor is one that has been sent using\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> but has not yet been accepted in the\nrecipient process using <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This error is\ndiagnosed since mainline Linux 4.5 (and in some earlier\nkernel versions where the fix has been backported). In\nearlier kernel versions, it was possible to place an\nunlimited number of file descriptors in flight, by sending\neach file descriptor with <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> and then closing\nthe file descriptor so that it was not accounted against the\n<b>RLIMIT_NOFILE</b> resource limit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other errors\ncan be generated by the generic socket layer or by the\nfilesystem while generating a filesystem socket object. See\nthe appropriate manual pages for more information.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCM_CREDENTIALS</b>\nand the abstract namespace were introduced with Linux 2.2\nand should not be used in portable programs. (Some\nBSD-derived systems also support credential passing, but the\nimplementation details differ.)</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Binding to a\nsocket with a filename creates a socket in the filesystem\nthat must be deleted by the caller when it is no longer\nneeded (using <a href=\"https://man.page/2/unlink\">unlink(2)</a>). The usual UNIX close-behind\nsemantics apply; the socket can be unlinked at any time and\nwill be finally removed from the filesystem when the last\nreference to it is closed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To pass file\ndescriptors or credentials over a <b>SOCK_STREAM</b> socket,\nyou must to send or receive at least one byte of\nnonancillary data in the same <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> or\n<a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a> call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">UNIX domain\nstream sockets do not support the notion of out-of-band\ndata.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When binding a\nsocket to an address, Linux is one of the implementations\nthat appends a null terminator if none is supplied in\n<i>sun_path</i>. In most cases this is unproblematic: when\nthe socket address is retrieved, it will be one byte longer\nthan that supplied when the socket was bound. However, there\nis one case where confusing behavior can result: if 108\nnon-null bytes are supplied when a socket is bound, then the\naddition of the null terminator takes the length of the\npathname beyond <i>sizeof(sun_path)</i>. Consequently, when\nretrieving the socket address (for example, via\n<a href=\"https://man.page/2/accept\">accept(2)</a>), if the input <i>addrlen</i> argument for\nthe retrieving call is specified as <i>sizeof(struct\nsockaddr_un)</i>, then the returned address structure\n<i>won&rsquo;t</i> have a null terminator in\n<i>sun_path</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nsome implementations don&rsquo;t require a null terminator\nwhen binding a socket (the <i>addrlen</i> argument is used\nto determine the length of <i>sun_path</i>) and when the\nsocket address is retrieved on these implementations, there\nis no null terminator in <i>sun_path</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Applications\nthat retrieve socket addresses can (portably) code to handle\nthe possibility that there is no null terminator in\n<i>sun_path</i> by respecting the fact that the number of\nvalid bytes in the pathname is:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">strnlen(addr.sun_path,\naddrlen - offsetof(sockaddr_un, sun_path))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Alternatively,\nan application can retrieve the socket address by allocating\na buffer of size <i>sizeof(struct sockaddr_un)+1</i> that is\nzeroed out before the retrieval. The retrieving call can\nspecify <i>addrlen</i> as <i>sizeof(struct sockaddr_un)</i>,\nand the extra zero byte ensures that there will be a null\nterminator for the string returned in <i>sun_path</i>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">void\n*addrp;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">addrlen =\nsizeof(struct sockaddr_un); <br>\naddrp = malloc(addrlen + 1); <br>\nif (addrp == NULL) <br>\n/* Handle error */ ; <br>\nmemset(addrp, 0, addrlen + 1);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(getsockname(sfd, (struct sockaddr *) addrp, &amp;addrlen))\n== -1) <br>\n/* handle error */ ;</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">printf(&quot;sun_path\n= %s\\n&quot;, ((struct sockaddr_un *)\naddrp)-&gt;sun_path);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This sort of\nmessiness can be avoided if it is guaranteed that the\napplications that <i>create</i> pathname sockets follow the\nrules outlined above under <i>Pathname sockets</i>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\ncode demonstrates the use of sequenced-packet sockets for\nlocal interprocess communication. It consists of two\nprograms. The server program waits for a connection from the\nclient program. The client sends each of its command-line\narguments in separate messages. The server treats the\nincoming messages as integers and adds them up. The client\nsends the command string &quot;END&quot;. The server sends\nback a message containing the sum of the client&rsquo;s\nintegers. The client prints the sum and exits. The server\nwaits for the next client to connect. To stop the server,\nthe client is called with the command-line argument\n&quot;DOWN&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\noutput was recorded while running the server in the\nbackground and repeatedly executing the client. Execution of\nthe server program ends when it receives the\n&quot;DOWN&quot; command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Example\noutput</b></p>\n\n<p style=\"margin-left:17%;\">$ <b>./server &amp;</b> <br>\n[1] 25887 <br>\n$ <b>./client 3 4</b> <br>\nResult = 7 <br>\n$ <b>./client 11 -5</b> <br>\nResult = 6 <br>\n$ <b>./client DOWN</b> <br>\nResult = 0 <br>\n[1]+ Done ./server <br>\n$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n/* <br>\n* File connection.h <br>\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nSOCKET_NAME &quot;/tmp/9Lq7BNBnBycd6nxy.socket&quot; <br>\n#define BUFFER_SIZE 12</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* File server.c <br>\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;sys/un.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &quot;connection.h&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct sockaddr_un name; <br>\nint down_flag = 0; <br>\nint ret; <br>\nint connection_socket; <br>\nint data_socket; <br>\nint result; <br>\nchar buffer[BUFFER_SIZE];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create local\nsocket. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">connection_socket\n= socket(AF_UNIX, SOCK_SEQPACKET, 0); <br>\nif (connection_socket == -1) { <br>\nperror(&quot;socket&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* For portability clear the whole structure, since some <br>\n* implementations have additional (nonstandard) fields in\n<br>\n* the structure. <br>\n*/</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(&amp;name,\n0, sizeof(name));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Bind socket\nto socket name. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">name.sun_family\n= AF_UNIX; <br>\nstrncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) -\n1);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\nbind(connection_socket, (const struct sockaddr *) &amp;name,\n<br>\nsizeof(name)); <br>\nif (ret == -1) { <br>\nperror(&quot;bind&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* Prepare for accepting connections. The backlog size is set\n<br>\n* to 20. So while one request is being processed other\nrequests <br>\n* can be waiting. <br>\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\nlisten(connection_socket, 20); <br>\nif (ret == -1) { <br>\nperror(&quot;listen&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* This is the\nmain loop for handling connections. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Wait for\nincoming connection. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">data_socket =\naccept(connection_socket, NULL, NULL); <br>\nif (data_socket == -1) { <br>\nperror(&quot;accept&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">result = 0;\n<br>\nfor (;;) {</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Wait for\nnext data packet. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\nread(data_socket, buffer, sizeof(buffer)); <br>\nif (ret == -1) { <br>\nperror(&quot;read&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Ensure\nbuffer is 0-terminated. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">buffer[sizeof(buffer)\n- 1] = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Handle\ncommands. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(!strncmp(buffer, &quot;DOWN&quot;, sizeof(buffer))) { <br>\ndown_flag = 1; <br>\nbreak; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(!strncmp(buffer, &quot;END&quot;, sizeof(buffer))) { <br>\nbreak; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Add received\nsummand. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">result +=\natoi(buffer); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Send result.\n*/</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sprintf(buffer,\n&quot;%d&quot;, result); <br>\nret = write(data_socket, buffer, sizeof(buffer)); <br>\nif (ret == -1) { <br>\nperror(&quot;write&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Close\nsocket. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(data_socket);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Quit on DOWN\ncommand. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (down_flag)\n{ <br>\nbreak; <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(connection_socket);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Unlink the\nsocket. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">unlink(SOCKET_NAME);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* File client.c <br>\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;errno.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;sys/un.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &quot;connection.h&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct sockaddr_un addr; <br>\nint ret; <br>\nint data_socket; <br>\nchar buffer[BUFFER_SIZE];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create local\nsocket. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">data_socket =\nsocket(AF_UNIX, SOCK_SEQPACKET, 0); <br>\nif (data_socket == -1) { <br>\nperror(&quot;socket&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* For portability clear the whole structure, since some <br>\n* implementations have additional (nonstandard) fields in\n<br>\n* the structure. <br>\n*/</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(&amp;addr,\n0, sizeof(addr));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Connect\nsocket to socket address */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">addr.sun_family\n= AF_UNIX; <br>\nstrncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) -\n1);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\nconnect(data_socket, (const struct sockaddr *) &amp;addr,\n<br>\nsizeof(addr)); <br>\nif (ret == -1) { <br>\nfprintf(stderr, &quot;The server is down.\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Send\narguments. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int i = 1;\ni &lt; argc; ++i) { <br>\nret = write(data_socket, argv[i], strlen(argv[i]) + 1); <br>\nif (ret == -1) { <br>\nperror(&quot;write&quot;); <br>\nbreak; <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Request\nresult. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">strcpy(buffer,\n&quot;END&quot;); <br>\nret = write(data_socket, buffer, strlen(buffer) + 1); <br>\nif (ret == -1) { <br>\nperror(&quot;write&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Receive\nresult. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\nread(data_socket, buffer, sizeof(buffer)); <br>\nif (ret == -1) { <br>\nperror(&quot;read&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Ensure\nbuffer is 0-terminated. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">buffer[sizeof(buffer)\n- 1] = 0;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Result\n= %s\\n&quot;, buffer);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Close\nsocket. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(data_socket);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an example\nof the use of <b>SCM_RIGHTS</b> see <a href=\"https://man.page/3/cmsg\">cmsg(3)</a>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>,\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>, <a href=\"https://man.page/2/socket\">socket(2)</a>, <a href=\"https://man.page/2/socketpair\">socketpair(2)</a>,\n<a href=\"https://man.page/3/cmsg\">cmsg(3)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/credentials\">credentials(7)</a>, <a href=\"https://man.page/7/socket\">socket(7)</a>, <a href=\"https://man.page/7/udp\">udp(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}