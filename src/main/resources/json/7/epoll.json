{"name":"epoll","body":"\n\n<h1 align=\"center\">EPOLL</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">epoll - I/O\nevent notification facility</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/epoll.h&gt;</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>epoll</b> API performs a similar task to <a href=\"https://man.page/2/poll\">poll(2)</a>:\nmonitoring multiple file descriptors to see if I/O is\npossible on any of them. The <b>epoll</b> API can be used\neither as an edge-triggered or a level-triggered interface\nand scales well to large numbers of watched file\ndescriptors.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The central\nconcept of the <b>epoll</b> API is the <b>epoll</b>\n<i>instance</i>, an in-kernel data structure which, from a\nuser-space perspective, can be considered as a container for\ntwo lists:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The <i>interest</i> list (sometimes also called the\n<b>epoll</b> set): the set of file descriptors that the\nprocess has registered an interest in monitoring.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The <i>ready</i> list: the set of file descriptors that\nare &quot;ready&quot; for I/O. The ready list is a subset of\n(or, more precisely, a set of references to) the file\ndescriptors in the interest list. The ready list is\ndynamically populated by the kernel as a result of I/O\nactivity on those file descriptors.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsystem calls are provided to create and manage an\n<b>epoll</b> instance:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\"><a href=\"https://man.page/2/epoll_create\">epoll_create(2)</a> creates a\nnew <b>epoll</b> instance and returns a file descriptor\nreferring to that instance. (The more recent\n<a href=\"https://man.page/2/epoll_create1\">epoll_create1(2)</a> extends the functionality of\n<a href=\"https://man.page/2/epoll_create\">epoll_create(2)</a>.)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Interest in particular file descriptors is then\nregistered via <a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a>, which adds items to the\ninterest list of the <b>epoll</b> instance.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p><a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> waits for I/O events, blocking the\ncalling thread if no events are currently available. (This\nsystem call can be thought of as fetching items from the\nready list of the <b>epoll</b> instance.)</p></td></tr>\n</table>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Level-triggered\nand edge-triggered</b> <br>\nThe <b>epoll</b> event distribution interface is able to\nbehave both as edge-triggered (ET) and as level-triggered\n(LT). The difference between the two mechanisms can be\ndescribed as follows. Suppose that this scenario\nhappens:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">The file descriptor that\nrepresents the read side of a pipe (<i>rfd</i>) is\nregistered on the <b>epoll</b> instance.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>A pipe writer writes 2&nbsp;kB of data on the write side\nof the pipe.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>A call to <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> is done that will return\n<i>rfd</i> as a ready file descriptor.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>The pipe reader reads 1&nbsp;kB of data from\n<i>rfd</i>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5.</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>A call to <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> is done.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<i>rfd</i> file descriptor has been added to the\n<b>epoll</b> interface using the <b>EPOLLET</b>\n(edge-triggered) flag, the call to <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> done\nin step <b>5</b> will probably hang despite the available\ndata still present in the file input buffer; meanwhile the\nremote peer might be expecting a response based on the data\nit already sent. The reason for this is that edge-triggered\nmode delivers events only when changes occur on the\nmonitored file descriptor. So, in step <b>5</b> the caller\nmight end up waiting for some data that is already present\ninside the input buffer. In the above example, an event on\n<i>rfd</i> will be generated because of the write done in\n<b>2</b> and the event is consumed in <b>3</b>. Since the\nread operation done in <b>4</b> does not consume the whole\nbuffer data, the call to <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> done in step\n<b>5</b> might block indefinitely.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An application\nthat employs the <b>EPOLLET</b> flag should use nonblocking\nfile descriptors to avoid having a blocking read or write\nstarve a task that is handling multiple file descriptors.\nThe suggested way to use <b>epoll</b> as an edge-triggered\n(<b>EPOLLET</b>) interface is as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">a)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">with nonblocking file\ndescriptors; and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>b)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>by waiting for an event only after <a href=\"https://man.page/2/read\">read(2)</a> or\n<a href=\"https://man.page/2/write\">write(2)</a> return <b>EAGAIN</b>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By contrast,\nwhen used as a level-triggered interface (the default, when\n<b>EPOLLET</b> is not specified), <b>epoll</b> is simply a\nfaster <a href=\"https://man.page/2/poll\">poll(2)</a>, and can be used wherever the latter\nis used since it shares the same semantics.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since even with\nedge-triggered <b>epoll</b>, multiple events can be\ngenerated upon receipt of multiple chunks of data, the\ncaller has the option to specify the <b>EPOLLONESHOT</b>\nflag, to tell <b>epoll</b> to disable the associated file\ndescriptor after the receipt of an event with\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>. When the <b>EPOLLONESHOT</b> flag is\nspecified, it is the caller&rsquo;s responsibility to rearm\nthe file descriptor using <a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a> with\n<b>EPOLL_CTL_MOD</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If multiple\nthreads (or processes, if child processes have inherited the\n<b>epoll</b> file descriptor across <a href=\"https://man.page/2/fork\">fork(2)</a>) are\nblocked in <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> waiting on the same epoll\nfile descriptor and a file descriptor in the interest list\nthat is marked for edge-triggered (<b>EPOLLET</b>)\nnotification becomes ready, just one of the threads (or\nprocesses) is awoken from <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>. This\nprovides a useful optimization for avoiding &quot;thundering\nherd&quot; wake-ups in some scenarios.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Interaction\nwith autosleep</b> <br>\nIf the system is in <b>autosleep</b> mode via\n<i>/sys/power/autosleep</i> and an event happens which wakes\nthe device from sleep, the device driver will keep the\ndevice awake only until that event is queued. To keep the\ndevice awake until the event has been processed, it is\nnecessary to use the <a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a> <b>EPOLLWAKEUP</b>\nflag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\n<b>EPOLLWAKEUP</b> flag is set in the <b>events</b> field\nfor a <i>struct epoll_event</i>, the system will be kept\nawake from the moment the event is queued, through the\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> call which returns the event until the\nsubsequent <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> call. If the event should\nkeep the system awake beyond that time, then a separate\n<i>wake_lock</i> should be taken before the second\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc\ninterfaces</b> <br>\nThe following interfaces can be used to limit the amount of\nkernel memory consumed by epoll: <i><br>\n/proc/sys/fs/epoll/max_user_watches</i> (since Linux\n2.6.28)</p>\n\n<p style=\"margin-left:22%;\">This specifies a limit on the\ntotal number of file descriptors that a user can register\nacross all epoll instances on the system. The limit is per\nreal user ID. Each registered file descriptor costs roughly\n90 bytes on a 32-bit kernel, and roughly 160 bytes on a\n64-bit kernel. Currently, the default value for\n<i>max_user_watches</i> is 1/25 (4%) of the available low\nmemory, divided by the registration cost in bytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Example for\nsuggested usage</b> <br>\nWhile the usage of <b>epoll</b> when employed as a\nlevel-triggered interface does have the same semantics as\n<a href=\"https://man.page/2/poll\">poll(2)</a>, the edge-triggered usage requires more\nclarification to avoid stalls in the application event loop.\nIn this example, listener is a nonblocking socket on which\n<a href=\"https://man.page/2/listen\">listen(2)</a> has been called. The function\n<i>do_use_fd()</i> uses the new ready file descriptor until\n<b>EAGAIN</b> is returned by either <a href=\"https://man.page/2/read\">read(2)</a> or\n<a href=\"https://man.page/2/write\">write(2)</a>. An event-driven state machine application\nshould, after having received <b>EAGAIN</b>, record its\ncurrent state so that at the next call to <i>do_use_fd()</i>\nit will continue to <a href=\"https://man.page/2/read\">read(2)</a> or <a href=\"https://man.page/2/write\">write(2)</a> from\nwhere it stopped before.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define\nMAX_EVENTS 10 <br>\nstruct epoll_event ev, events[MAX_EVENTS]; <br>\nint listen_sock, conn_sock, nfds, epollfd;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Code to set\nup listening socket, 'listen_sock', <br>\n(socket(), bind(), listen()) omitted */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">epollfd =\nepoll_create1(0); <br>\nif (epollfd == -1) { <br>\nperror(&quot;epoll_create1&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">ev.events =\nEPOLLIN; <br>\nev.data.fd = listen_sock; <br>\nif (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev)\n== -1) { <br>\nperror(&quot;epoll_ctl: listen_sock&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for (;;) { <br>\nnfds = epoll_wait(epollfd, events, MAX_EVENTS, -1); <br>\nif (nfds == -1) { <br>\nperror(&quot;epoll_wait&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for (n = 0; n\n&lt; nfds; ++n) { <br>\nif (events[n].data.fd == listen_sock) { <br>\nconn_sock = accept(listen_sock, <br>\n(struct sockaddr *) &amp;addr, &amp;addrlen); <br>\nif (conn_sock == -1) { <br>\nperror(&quot;accept&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nsetnonblocking(conn_sock); <br>\nev.events = EPOLLIN | EPOLLET; <br>\nev.data.fd = conn_sock; <br>\nif (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, <br>\n&amp;ev) == -1) { <br>\nperror(&quot;epoll_ctl: conn_sock&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\n} else { <br>\ndo_use_fd(events[n].data.fd); <br>\n} <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When used as an\nedge-triggered interface, for performance reasons, it is\npossible to add the file descriptor inside the <b>epoll</b>\ninterface (<b>EPOLL_CTL_ADD</b>) once by specifying\n(<b>EPOLLIN</b>|<b>EPOLLOUT</b>). This allows you to avoid\ncontinuously switching between <b>EPOLLIN</b> and\n<b>EPOLLOUT</b> calling <a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a> with\n<b>EPOLL_CTL_MOD</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Questions\nand answers</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>0.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>What is the key used to distinguish the file descriptors\nregistered in an interest list?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The key is the\ncombination of the file descriptor number and the open file\ndescription (also known as an &quot;open file handle&quot;,\nthe kernel&rsquo;s internal representation of an open\nfile).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">What happens if you register the\nsame file descriptor on an <b>epoll</b> instance twice?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You will\nprobably get <b>EEXIST</b>. However, it is possible to add a\nduplicate (<a href=\"https://man.page/2/dup\">dup(2)</a>, <a href=\"https://man.page/2/dup2\">dup2(2)</a>, <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>\n<b>F_DUPFD</b>) file descriptor to the same <b>epoll</b>\ninstance. This can be a useful technique for filtering\nevents, if the duplicate file descriptors are registered\nwith different <i>events</i> masks.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Can two <b>epoll</b> instances\nwait for the same file descriptor? If so, are events\nreported to both <b>epoll</b> file descriptors?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Yes, and events\nwould be reported to both. However, careful programming may\nbe needed to do this correctly.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">3.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Is the <b>epoll</b> file\ndescriptor itself poll/epoll/selectable?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Yes. If an\n<b>epoll</b> file descriptor has events waiting, then it\nwill indicate as being readable.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">4.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">What happens if one attempts to\nput an <b>epoll</b> file descriptor into its own file\ndescriptor set?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n<a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a> call fails (<b>EINVAL</b>). However, you\ncan add an <b>epoll</b> file descriptor inside another\n<b>epoll</b> file descriptor set.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">5.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Can I send an <b>epoll</b> file\ndescriptor over a UNIX domain socket to another process?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Yes, but it\ndoes not make sense to do this, since the receiving process\nwould not have copies of the file descriptors in the\ninterest list.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">6.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Will closing a file descriptor\ncause it to be removed from all <b>epoll</b> interest\nlists?</p> </td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Yes, but be\naware of the following point. A file descriptor is a\nreference to an open file description (see <a href=\"https://man.page/2/open\">open(2)</a>).\nWhenever a file descriptor is duplicated via <a href=\"https://man.page/2/dup\">dup(2)</a>,\n<a href=\"https://man.page/2/dup2\">dup2(2)</a>, <a href=\"https://man.page/2/fcntl\">fcntl(2)</a> <b>F_DUPFD</b>, or\n<a href=\"https://man.page/2/fork\">fork(2)</a>, a new file descriptor referring to the same\nopen file description is created. An open file description\ncontinues to exist until all file descriptors referring to\nit have been closed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A file\ndescriptor is removed from an interest list only after all\nthe file descriptors referring to the underlying open file\ndescription have been closed. This means that even after a\nfile descriptor that is part of an interest list has been\nclosed, events may be reported for that file descriptor if\nother file descriptors referring to the same underlying file\ndescription remain open. To prevent this happening, the file\ndescriptor must be explicitly removed from the interest list\n(using <a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a> <b>EPOLL_CTL_DEL</b>) before it\nis duplicated. Alternatively, the application must ensure\nthat all file descriptors are closed (which may be difficult\nif file descriptors were duplicated behind the scenes by\nlibrary functions that used <a href=\"https://man.page/2/dup\">dup(2)</a> or\n<a href=\"https://man.page/2/fork\">fork(2)</a>).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">7.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">If more than one event occurs\nbetween <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> calls, are they combined or\nreported separately?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">They will be\ncombined.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">8.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Does an operation on a file\ndescriptor affect the already collected but not yet reported\nevents?</p> </td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can do two\noperations on an existing file descriptor. Remove would be\nmeaningless for this case. Modify will reread available\nI/O.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">9.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Do I need to continuously\nread/write a file descriptor until <b>EAGAIN</b> when using\nthe <b>EPOLLET</b> flag (edge-triggered behavior)?</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Receiving an\nevent from <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a> should suggest to you that\nsuch file descriptor is ready for the requested I/O\noperation. You must consider it ready until the next\n(nonblocking) read/write yields <b>EAGAIN</b>. When and how\nyou will use the file descriptor is entirely up to you.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\npacket/token-oriented files (e.g., datagram socket, terminal\nin canonical mode), the only way to detect the end of the\nread/write I/O space is to continue to read/write until\n<b>EAGAIN</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\nstream-oriented files (e.g., pipe, FIFO, stream socket), the\ncondition that the read/write I/O space is exhausted can\nalso be detected by checking the amount of data read from /\nwritten to the target file descriptor. For example, if you\ncall <a href=\"https://man.page/2/read\">read(2)</a> by asking to read a certain amount of\ndata and <a href=\"https://man.page/2/read\">read(2)</a> returns a lower number of bytes, you\ncan be sure of having exhausted the read I/O space for the\nfile descriptor. The same is true when writing using\n<a href=\"https://man.page/2/write\">write(2)</a>. (Avoid this latter technique if you cannot\nguarantee that the monitored file descriptor always refers\nto a stream-oriented file.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Possible\npitfalls and ways to avoid them <br>\no Starvation (edge-triggered)</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If there is a\nlarge amount of I/O space, it is possible that by trying to\ndrain it the other files will not get processed causing\nstarvation. (This problem is not specific to\n<b>epoll</b>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The solution is\nto maintain a ready list and mark the file descriptor as\nready in its associated data structure, thereby allowing the\napplication to remember which files need to be processed but\nstill round robin amongst all the ready files. This also\nsupports ignoring subsequent events you receive for file\ndescriptors that are already ready. <b><br>\no If using an event cache...</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you use an\nevent cache or store all the file descriptors returned from\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>, then make sure to provide a way to\nmark its closure dynamically (i.e., caused by a previous\nevent&rsquo;s processing). Suppose you receive 100 events\nfrom <a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>, and in event #47 a condition\ncauses event #13 to be closed. If you remove the structure\nand <a href=\"https://man.page/2/close\">close(2)</a> the file descriptor for event #13, then\nyour event cache might still say there are events waiting\nfor that file descriptor causing confusion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One solution\nfor this is to call, during the processing of event 47,\n<b>epoll_ctl</b>(<b>EPOLL_CTL_DEL</b>) to delete file\ndescriptor 13 and <a href=\"https://man.page/2/close\">close(2)</a>, then mark its associated\ndata structure as removed and link it to a cleanup list. If\nyou find another event for file descriptor 13 in your batch\nprocessing, you will discover the file descriptor had been\npreviously removed and there will be no confusion.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>epoll</b> API was introduced in Linux kernel 2.5.44.\nSupport was added to glibc in version 2.3.2.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>epoll</b> API is Linux-specific. Some other systems\nprovide similar mechanisms, for example, FreeBSD has\n<i>kqueue</i>, and Solaris has <i>/dev/poll</i>.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The set of file\ndescriptors that is being monitored via an epoll file\ndescriptor can be viewed via the entry for the epoll file\ndescriptor in the process&rsquo;s <i>/proc/[pid]/fdinfo</i>\ndirectory. See <a href=\"https://man.page/5/proc\">proc(5)</a> for further details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/2/kcmp\">kcmp(2)</a> <b>KCMP_EPOLL_TFD</b> operation can be used\nto test whether a file descriptor is present in an epoll\ninstance.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/epoll_create\">epoll_create(2)</a>,\n<a href=\"https://man.page/2/epoll_create1\">epoll_create1(2)</a>, <a href=\"https://man.page/2/epoll_ctl\">epoll_ctl(2)</a>,\n<a href=\"https://man.page/2/epoll_wait\">epoll_wait(2)</a>, <a href=\"https://man.page/2/poll\">poll(2)</a>, <a href=\"https://man.page/2/select\">select(2)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}