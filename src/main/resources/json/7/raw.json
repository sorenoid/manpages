{"name":"raw","description":"raw - Linux\nIPv4 raw sockets","body":"\n\n<h1 align=\"center\">RAW</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">raw - Linux\nIPv4 raw sockets</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/socket.h&gt; <br>\n#include &lt;netinet/in.h&gt; <br>\nraw_socket = socket(AF_INET, SOCK_RAW, int</b>\n<i>protocol</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Raw sockets\nallow new IPv4 protocols to be implemented in user space. A\nraw socket receives or sends the raw datagram not including\nlink level headers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The IPv4 layer\ngenerates an IP header when sending a packet unless the\n<b>IP_HDRINCL</b> socket option is enabled on the socket.\nWhen it is enabled, the packet must contain an IP header.\nFor receiving, the IP header is always included in the\npacket.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to\ncreate a raw socket, a process must have the\n<b>CAP_NET_RAW</b> capability in the user namespace that\ngoverns its network namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All packets or\nerrors matching the <i>protocol</i> number specified for the\nraw socket are passed to this socket. For a list of the\nallowed protocols, see the IANA list of assigned protocol\nnumbers at\n<a href=\"http://www.iana.org/assignments/protocol-numbers/\">http://www.iana.org/assignments/protocol-numbers/</a>\nand <a href=\"https://man.page/3/getprotobyname\">getprotobyname(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A protocol of\n<b>IPPROTO_RAW</b> implies enabled <b>IP_HDRINCL</b> and is\nable to send any IP protocol that is specified in the passed\nheader. Receiving of all IP protocols via <b>IPPROTO_RAW</b>\nis not possible using raw sockets.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3498451.png\" alt=\"Image grohtml-3498451.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>IP_HDRINCL</b> is specified and the IP header has a\nnonzero destination address, then the destination address of\nthe socket is used to route the packet. When\n<b>MSG_DONTROUTE</b> is specified, the destination address\nshould refer to a local interface, otherwise a routing table\nlookup is done anyway but gatewayed routes are ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>IP_HDRINCL</b> isn&rsquo;t set, then IP header options\ncan be set on raw sockets with <a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a>; see\n<a href=\"https://man.page/7/ip\">ip(7)</a> for more information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting with\nLinux 2.2, all IP header fields and options can be set using\nIP socket options. This means raw sockets are usually needed\nonly for new protocols or protocols with no user interface\n(like ICMP).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a packet\nis received, it is passed to any raw sockets which have been\nbound to its protocol before it is passed to other protocol\nhandlers (e.g., kernel protocol modules).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Address\nformat</b> <br>\nFor sending and receiving datagrams (<a href=\"https://man.page/2/sendto\">sendto(2)</a>,\n<a href=\"https://man.page/2/recvfrom\">recvfrom(2)</a>, and similar), raw sockets use the\nstandard <i>sockaddr_in</i> address structure defined in\n<a href=\"https://man.page/7/ip\">ip(7)</a>. The <i>sin_port</i> field could be used to\nspecify the IP protocol number, but it is ignored for\nsending in Linux 2.2 and later, and should be always set to\n0 (see BUGS). For incoming packets, <i>sin_port</i> is set\nto zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Socket\noptions</b> <br>\nRaw socket options can be set with <a href=\"https://man.page/2/setsockopt\">setsockopt(2)</a> and\nread with <a href=\"https://man.page/2/getsockopt\">getsockopt(2)</a> by passing the\n<b>IPPROTO_RAW</b> family flag. <b><br>\nICMP_FILTER</b></p>\n\n<p style=\"margin-left:22%;\">Enable a special filter for raw\nsockets bound to the <b>IPPROTO_ICMP</b> protocol. The value\nhas a bit set for each ICMP message type which should be\nfiltered out. The default is to filter no ICMP messages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nall <a href=\"https://man.page/7/ip\">ip(7)</a> <b>IPPROTO_IP</b> socket options valid for\ndatagram sockets are supported.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Error\nhandling</b> <br>\nErrors originating from the network are passed to the user\nonly when the socket is connected or the <b>IP_RECVERR</b>\nflag is enabled. For connected sockets, only <b>EMSGSIZE</b>\nand <b>EPROTO</b> are passed for compatibility. With\n<b>IP_RECVERR</b>, all network errors are saved in the error\nqueue.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">User tried to send to a\nbroadcast address without having the broadcast flag set on\nthe socket.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An invalid memory address was supplied.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Invalid argument.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EMSGSIZE</b></p>\n\n<p style=\"margin-left:22%;\">Packet too big. Either Path MTU\nDiscovery is enabled (the <b>IP_MTU_DISCOVER</b> socket\nflag) or the packet size exceeds the maximum allowed IPv4\npacket size of 64&nbsp;kB.</p>\n\n<p style=\"margin-left:11%;\"><b>EOPNOTSUPP</b></p>\n\n<p style=\"margin-left:22%;\">Invalid flag has been passed to\na socket call (like <b>MSG_OOB</b>).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The user doesn&rsquo;t have permission to open raw\nsockets. Only processes with an effective user ID of 0 or\nthe <b>CAP_NET_RAW</b> attribute may do that.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPROTO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An ICMP error has arrived reporting a parameter\nproblem.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>IP_RECVERR</b>\nand <b>ICMP_FILTER</b> are new in Linux 2.2. They are Linux\nextensions and should not be used in portable programs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux 2.0\nenabled some bug-to-bug compatibility with BSD in the raw\nsocket code when the <b>SO_BSDCOMPAT</b> socket option was\nset; since Linux 2.2, this option no longer has that\neffect.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default, raw\nsockets do path MTU (Maximum Transmission Unit) discovery.\nThis means the kernel will keep track of the MTU to a\nspecific target IP address and return <b>EMSGSIZE</b> when a\nraw packet write exceeds it. When this happens, the\napplication should decrease the packet size. Path MTU\ndiscovery can be also turned off using the\n<b>IP_MTU_DISCOVER</b> socket option or the\n<i>/proc/sys/net/ipv4/ip_no_pmtu_disc</i> file, see\n<a href=\"https://man.page/7/ip\">ip(7)</a> for details. When turned off, raw sockets will\nfragment outgoing packets that exceed the interface MTU.\nHowever, disabling it is not recommended for performance and\nreliability reasons.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A raw socket\ncan be bound to a specific local address using the\n<a href=\"https://man.page/2/bind\">bind(2)</a> call. If it isn&rsquo;t bound, all packets\nwith the specified IP protocol are received. In addition, a\nraw socket can be bound to a specific network device using\n<b>SO_BINDTODEVICE</b>; see <a href=\"https://man.page/7/socket\">socket(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An\n<b>IPPROTO_RAW</b> socket is send only. If you really want\nto receive all IP packets, use a <a href=\"https://man.page/7/packet\">packet(7)</a> socket\nwith the <b>ETH_P_IP</b> protocol. Note that packet sockets\ndon&rsquo;t reassemble IP fragments, unlike raw sockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want to\nreceive all ICMP packets for a datagram socket, it is often\nbetter to use <b>IP_RECVERR</b> on that particular socket;\nsee <a href=\"https://man.page/7/ip\">ip(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Raw sockets may\ntap all IP protocols in Linux, even protocols like ICMP or\nTCP which have a protocol module in the kernel. In this\ncase, the packets are passed to both the kernel module and\nthe raw socket(s). This should not be relied upon in\nportable programs, many other BSD socket implementation have\nlimitations here.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Linux never\nchanges headers passed from the user (except for filling in\nsome zeroed fields as described for <b>IP_HDRINCL</b>). This\ndiffers from many other implementations of raw sockets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Raw sockets are\ngenerally rather unportable and should be avoided in\nprograms intended to be portable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sending on raw\nsockets should take the IP protocol from <i>sin_port</i>;\nthis ability was lost in Linux 2.2. The workaround is to use\n<b>IP_HDRINCL</b>.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Transparent\nproxy extensions are not described.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\n<b>IP_HDRINCL</b> option is set, datagrams will not be\nfragmented and are limited to the interface MTU.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Setting the IP\nprotocol for sending in <i>sin_port</i> got lost in Linux\n2.2. The protocol that the socket was bound to or that was\nspecified in the initial <a href=\"https://man.page/2/socket\">socket(2)</a> call is always\nused.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>,\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>, <a href=\"https://man.page/7/ip\">ip(7)</a>,\n<a href=\"https://man.page/7/socket\">socket(7)</a></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>RFC&nbsp;1191</b>\nfor path MTU discovery. <b>RFC&nbsp;791</b> and the\n<i>&lt;linux/ip.h&gt;</i> header file for the IP\nprotocol.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}