{"name":"cpuset","description":"cpuset -\nconfine processes to processor and memory node subsets\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nThe cpuset\nfilesystem is a pseudo-filesystem interface to the kernel\ncpuset mechanism, which is used to control the processor\nplacement and memory placement of processes. It is commonly\nmounted at <i>/dev/cpuset</i>.\n\nOn systems with\nkernels compiled with built in support for cpusets, all\nprocesses are attached to a cpuset, and cpusets are always\npresent. If a system supports cpusets, then it will have the\nentry <b>nodev cpuset</b> in the file\n<i>/proc/filesystems</i>. By mounting the cpuset filesystem\n(see the <b>EXAMPLES</b> section below), the administrator\ncan configure the cpusets on a system to control the\nprocessor and memory placement of processes on that system.\nBy default, if the cpuset configuration on a system is not\nmodified or if the cpuset filesystem is not even mounted,\nthen the cpuset mechanism, though present, has no effect on\nthe system&rsquo;s behavior.\n\nA cpuset\ndefines a list of CPUs and memory nodes.\n\nThe CPUs of a\nsystem include all the logical processing units on which a\nprocess can execute, including, if present, multiple\nprocessor cores within a package and Hyper-Threads within a\nprocessor core. Memory nodes include all distinct banks of\nmain memory; small and SMP systems typically have just one\nmemory node that contains all the system&rsquo;s main\nmemory, while NUMA (non-uniform memory access) systems have\nmultiple memory nodes.\n\nCpusets are\nrepresented as directories in a hierarchical\npseudo-filesystem, where the top directory in the hierarchy\n(<i>/dev/cpuset</i>) represents the entire system (all\nonline CPUs and memory nodes) and any cpuset that is the\nchild (descendant) of another parent cpuset contains a\nsubset of that parent&rsquo;s CPUs and memory nodes. The\ndirectories and files representing cpusets have normal\nfilesystem permissions.\n\nEvery process\nin the system belongs to exactly one cpuset. A process is\nconfined to run only on the CPUs in the cpuset it belongs\nto, and to allocate memory only on the memory nodes in that\ncpuset. When a process <a href=\"https://man.page/2/fork\">fork(2)</a>s, the child process is\nplaced in the same cpuset as its parent. With sufficient\nprivilege, a process may be moved from one cpuset to another\nand the allowed CPUs and memory nodes of an existing cpuset\nmay be changed.\n\nWhen the system\nbegins booting, a single cpuset is defined that includes all\nCPUs and memory nodes on the system, and all processes are\nin that cpuset. During the boot process, or later during\nnormal system operation, other cpusets may be created, as\nsubdirectories of this top cpuset, under the control of the\nsystem administrator, and processes may be placed in these\nother cpusets.\n\nCpusets are\nintegrated with the <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a> scheduling\naffinity mechanism and the <a href=\"https://man.page/2/mbind\">mbind(2)</a> and\n<a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a> memory-placement mechanisms in the\nkernel. Neither of these mechanisms let a process make use\nof a CPU or memory node that is not allowed by that\nprocess&rsquo;s cpuset. If changes to a process&rsquo;s\ncpuset placement conflict with these other mechanisms, then\ncpuset placement is enforced even if it means overriding\nthese other mechanisms. The kernel accomplishes this\noverriding by silently restricting the CPUs and memory nodes\nrequested by these other mechanisms to those allowed by the\ninvoking process&rsquo;s cpuset. This can result in these\nother calls returning an error, if for example, such a call\nends up requesting an empty set of CPUs or memory nodes,\nafter that request is restricted to the invoking\nprocess&rsquo;s cpuset.\n\nTypically, a\ncpuset is used to manage the CPU and memory-node confinement\nfor a set of cooperating processes such as a batch scheduler\njob, and these other mechanisms are used to manage the\nplacement of individual processes or memory regions within\nthat set or job.\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\nEach directory\nbelow <i>/dev/cpuset</i> represents a cpuset and contains a\nfixed set of pseudo-files describing the state of that\ncpuset.\n\nNew cpusets are\ncreated using the <a href=\"https://man.page/2/mkdir\">mkdir(2)</a> system call or the\n<a href=\"https://man.page/1/mkdir\">mkdir(1)</a> command. The properties of a cpuset, such as\nits flags, allowed CPUs and memory nodes, and attached\nprocesses, are queried and modified by reading or writing to\nthe appropriate file in that cpuset&rsquo;s directory, as\nlisted below.\n\nThe\npseudo-files in each cpuset directory are automatically\ncreated when the cpuset is created, as a result of the\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a> invocation. It is not possible to directly\nadd or remove these pseudo-files.\n\nA cpuset\ndirectory that contains no child cpuset directories, and has\nno attached processes, can be removed using <a href=\"https://man.page/2/rmdir\">rmdir(2)</a>\nor <a href=\"https://man.page/1/rmdir\">rmdir(1)</a>. It is not necessary, or possible, to\nremove the pseudo-files inside the directory before removing\nit.\n\nThe\npseudo-files in each cpuset directory are small text files\nthat may be read and written using traditional shell\nutilities such as <a href=\"https://man.page/1/cat\">cat(1)</a>, and <a href=\"https://man.page/1/echo\">echo(1)</a>, or from\na program by using file I/O library functions or system\ncalls, such as <a href=\"https://man.page/2/open\">open(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, and <a href=\"https://man.page/2/close\">close(2)</a>.\n\nThe\npseudo-files in a cpuset directory represent internal kernel\nstate and do not have any persistent image on disk. Each of\nthese per-cpuset files is listed and described below.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>tasks</i></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>List of the process IDs (PIDs) of the processes in that\ncpuset. The list is formatted as a series of ASCII decimal\nnumbers, each followed by a newline. A process may be added\nto a cpuset (automatically removing it from the cpuset that\npreviously contained it) by writing its PID to that\ncpuset&rsquo;s <i>tasks</i> file (with or without a trailing\nnewline). </td></tr>\n</table>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>Warning:</b>\nonly one PID may be written to the <i>tasks</i> file at a\ntime. If a string is written that contains more than one\nPID, only the first one will be used.\n\n<p style=\"margin-left:11%;\"><i>notify_on_release</i>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), that\ncpuset will receive special handling after it is released,\nthat is, after all processes cease using it (i.e., terminate\nor are moved to a different cpuset) and all child cpuset\ndirectories have been removed. See the <b>Notify On\nRelease</b> section, below.\n\n<p style=\"margin-left:11%;\"><i>cpuset.cpus</i>\n\n<p style=\"margin-left:22%;\">List of the physical numbers of\nthe CPUs on which processes in that cpuset are allowed to\nexecute. See <b>List Format</b> below for a description of\nthe format of <i>cpus</i>.\n\n<p style=\"margin-left:22%; margin-top: 1em\">The CPUs\nallowed to a cpuset may be changed by writing a new list to\nits <i>cpus</i> file.\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.cpu_exclusive</i>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\ncpuset has exclusive use of its CPUs (no sibling or cousin\ncpuset may overlap CPUs). By default, this is off (0). Newly\ncreated cpusets also initially default this to off (0).\n\n<p style=\"margin-left:22%; margin-top: 1em\">Two cpusets are\n<i>sibling</i> cpusets if they share the same parent cpuset\nin the <i>/dev/cpuset</i> hierarchy. Two cpusets are\n<i>cousin</i> cpusets if neither is the ancestor of the\nother. Regardless of the <i>cpu_exclusive</i> setting, if\none cpuset is the ancestor of another, and if both of these\ncpusets have nonempty <i>cpus</i>, then their <i>cpus</i>\nmust overlap, because the <i>cpus</i> of any cpuset are\nalways a subset of the <i>cpus</i> of its parent cpuset.\n\n<p style=\"margin-left:11%;\"><i>cpuset.mems</i>\n\n<p style=\"margin-left:22%;\">List of memory nodes on which\nprocesses in this cpuset are allowed to allocate memory. See\n<b>List Format</b> below for a description of the format of\n<i>mems</i>.\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.mem_exclusive</i>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\ncpuset has exclusive use of its memory nodes (no sibling or\ncousin may overlap). Also if set (1), the cpuset is a\n<b>Hardwall</b> cpuset (see below). By default, this is off\n(0). Newly created cpusets also initially default this to\noff (0).\n\n<p style=\"margin-left:22%; margin-top: 1em\">Regardless of\nthe <i>mem_exclusive</i> setting, if one cpuset is the\nancestor of another, then their memory nodes must overlap,\nbecause the memory nodes of any cpuset are always a subset\nof the memory nodes of that cpuset&rsquo;s parent\ncpuset.\n\n<p style=\"margin-left:11%;\"><i>cpuset.mem_hardwall</i>\n(since Linux 2.6.26)\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\ncpuset is a <b>Hardwall</b> cpuset (see below). Unlike\n<b>mem_exclusive</b>, there is no constraint on whether\ncpusets marked <b>mem_hardwall</b> may have overlapping\nmemory nodes with sibling or cousin cpusets. By default,\nthis is off (0). Newly created cpusets also initially\ndefault this to off (0).\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_migrate</i>\n(since Linux 2.6.16)\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), then\nmemory migration is enabled. By default, this is off (0).\nSee the <b>Memory Migration</b> section, below.\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_pressure</i>\n(since Linux 2.6.16)\n\n<p style=\"margin-left:22%;\">A measure of how much memory\npressure the processes in this cpuset are causing. See the\n<b>Memory Pressure</b> section, below. Unless\n<i>memory_pressure_enabled</i> is enabled, always has value\nzero (0). This file is read-only. See the <b>WARNINGS</b>\nsection, below.\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_pressure_enabled</i>\n(since Linux 2.6.16)\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). This file is\npresent only in the root cpuset, normally\n<i>/dev/cpuset</i>. If set (1), the <i>memory_pressure</i>\ncalculations are enabled for all cpusets in the system. By\ndefault, this is off (0). See the <b>Memory Pressure</b>\nsection, below.\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_spread_page</i>\n(since Linux 2.6.17)\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1),\npages in the kernel page cache (filesystem buffers) are\nuniformly spread across the cpuset. By default, this is off\n(0) in the top cpuset, and inherited from the parent cpuset\nin newly created cpusets. See the <b>Memory Spread</b>\nsection, below.\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_spread_slab</i>\n(since Linux 2.6.17)\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\nkernel slab caches for file I/O (directory and inode\nstructures) are uniformly spread across the cpuset. By\ndefault, is off (0) in the top cpuset, and inherited from\nthe parent cpuset in newly created cpusets. See the\n<b>Memory Spread</b> section, below.\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.sched_load_balance</i>\n(since Linux 2.6.24)\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1, the\ndefault) the kernel will automatically load balance\nprocesses in that cpuset over the allowed CPUs in that\ncpuset. If cleared (0) the kernel will avoid load balancing\nprocesses in this cpuset, <i>unless</i> some other cpuset\nwith overlapping CPUs has its <i>sched_load_balance</i> flag\nset. See <b>Scheduler Load Balancing</b>, below, for further\ndetails.\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.sched_relax_domain_level</i>\n(since Linux 2.6.26)\n\n<p style=\"margin-left:22%;\">Integer, between -1 and a small\npositive value. The <i>sched_relax_domain_level</i> controls\nthe width of the range of CPUs over which the kernel\nscheduler performs immediate rebalancing of runnable tasks\nacross CPUs. If <i>sched_load_balance</i> is disabled, then\nthe setting of <i>sched_relax_domain_level</i> does not\nmatter, as no such load balancing is done. If\n<i>sched_load_balance</i> is enabled, then the higher the\nvalue of the <i>sched_relax_domain_level</i>, the wider the\nrange of CPUs over which immediate load balancing is\nattempted. See <b>Scheduler Relax Domain Level</b>, below,\nfor further details.\n\nIn addition to\nthe above pseudo-files in each directory below\n<i>/dev/cpuset</i>, each process has a pseudo-file,\n<i>/proc/&lt;pid&gt;/cpuset</i>, that displays the path of\nthe process&rsquo;s cpuset directory relative to the root of\nthe cpuset filesystem.\n\nAlso the\n<i>/proc/&lt;pid&gt;/status</i> file for each process has\nfour added lines, displaying the process&rsquo;s\n<i>Cpus_allowed</i> (on which CPUs it may be scheduled) and\n<i>Mems_allowed</i> (on which memory nodes it may obtain\nmemory), in the two formats <b>Mask Format</b> and <b>List\nFormat</b> (see below) as shown in the following\nexample:\n\n<p style=\"margin-left:17%; margin-top: 1em\">Cpus_allowed:\nffffffff,ffffffff,ffffffff,ffffffff <br>\nCpus_allowed_list: 0-127 <br>\nMems_allowed: ffffffff,ffffffff <br>\nMems_allowed_list: 0-63\n\nThe\n&quot;allowed&quot; fields were added in Linux 2.6.24; the\n&quot;allowed_list&quot; fields were added in Linux\n2.6.26.\n\n<h2>EXTENDED CAPABILITIES\n<a name=\"EXTENDED CAPABILITIES\"></a>\n</h2>\n\n\nIn addition to\ncontrolling which <i>cpus</i> and <i>mems</i> a process is\nallowed to use, cpusets provide the following extended\ncapabilities.\n\n<b>Exclusive\ncpusets</b> <br>\nIf a cpuset is marked <i>cpu_exclusive</i> or\n<i>mem_exclusive</i>, no other cpuset, other than a direct\nancestor or descendant, may share any of the same CPUs or\nmemory nodes.\n\nA cpuset that\nis <i>mem_exclusive</i> restricts kernel allocations for\nbuffer cache pages and other internal kernel data pages\ncommonly shared by the kernel across multiple users. All\ncpusets, whether <i>mem_exclusive</i> or not, restrict\nallocations of memory for user space. This enables\nconfiguring a system so that several independent jobs can\nshare common kernel data, while isolating each job&rsquo;s\nuser allocation in its own cpuset. To do this, construct a\nlarge <i>mem_exclusive</i> cpuset to hold all the jobs, and\nconstruct child, non-<i>mem_exclusive</i> cpusets for each\nindividual job. Only a small amount of kernel memory, such\nas requests from interrupt handlers, is allowed to be placed\non memory nodes outside even a <i>mem_exclusive</i>\ncpuset.\n\n\n<b>Hardwall</b>\n<br>\nA cpuset that has <i>mem_exclusive</i> or\n<i>mem_hardwall</i> set is a <i>hardwall</i> cpuset. A\n<i>hardwall</i> cpuset restricts kernel allocations for\npage, buffer, and other data commonly shared by the kernel\nacross multiple users. All cpusets, whether <i>hardwall</i>\nor not, restrict allocations of memory for user space.\n\nThis enables\nconfiguring a system so that several independent jobs can\nshare common kernel data, such as filesystem pages, while\nisolating each job&rsquo;s user allocation in its own\ncpuset. To do this, construct a large <i>hardwall</i> cpuset\nto hold all the jobs, and construct child cpusets for each\nindividual job which are not <i>hardwall</i> cpusets.\n\nOnly a small\namount of kernel memory, such as requests from interrupt\nhandlers, is allowed to be taken outside even a\n<i>hardwall</i> cpuset.\n\n<b>Notify on\nrelease</b> <br>\nIf the <i>notify_on_release</i> flag is enabled (1) in a\ncpuset, then whenever the last process in the cpuset leaves\n(exits or attaches to some other cpuset) and the last child\ncpuset of that cpuset is removed, the kernel will run the\ncommand <i>/sbin/cpuset_release_agent</i>, supplying the\npathname (relative to the mount point of the cpuset\nfilesystem) of the abandoned cpuset. This enables automatic\nremoval of abandoned cpusets.\n\nThe default\nvalue of <i>notify_on_release</i> in the root cpuset at\nsystem boot is disabled (0). The default value of other\ncpusets at creation is the current value of their\nparent&rsquo;s <i>notify_on_release</i> setting.\n\nThe command\n<i>/sbin/cpuset_release_agent</i> is invoked, with the name\n(<i>/dev/cpuset</i> relative path) of the to-be-released\ncpuset in <i>argv[1]</i>.\n\nThe usual\ncontents of the command <i>/sbin/cpuset_release_agent</i> is\nsimply the shell script:\n\n<p style=\"margin-left:17%; margin-top: 1em\">#!/bin/sh <br>\nrmdir /dev/cpuset/$1\n\nAs with other\nflag values below, this flag can be changed by writing an\nASCII number 0 or 1 (with optional trailing newline) into\nthe file, to clear or set the flag, respectively.\n\n<b>Memory\npressure</b> <br>\nThe <i>memory_pressure</i> of a cpuset provides a simple\nper-cpuset running average of the rate that the processes in\na cpuset are attempting to free up in-use memory on the\nnodes of the cpuset to satisfy additional memory\nrequests.\n\nThis enables\nbatch managers that are monitoring jobs running in dedicated\ncpusets to efficiently detect what level of memory pressure\nthat job is causing.\n\nThis is useful\nboth on tightly managed systems running a wide mix of\nsubmitted jobs, which may choose to terminate or\nreprioritize jobs that are trying to use more memory than\nallowed on the nodes assigned them, and with tightly\ncoupled, long-running, massively parallel scientific\ncomputing jobs that will dramatically fail to meet required\nperformance goals if they start to use more memory than\nallowed to them.\n\nThis mechanism\nprovides a very economical way for the batch manager to\nmonitor a cpuset for signs of memory pressure. It&rsquo;s up\nto the batch manager or other user code to decide what\naction to take if it detects signs of memory pressure.\n\nUnless memory\npressure calculation is enabled by setting the pseudo-file\n<i>/dev/cpuset/cpuset.memory_pressure_enabled</i>, it is not\ncomputed for any cpuset, and reads from any\n<i>memory_pressure</i> always return zero, as represented by\nthe ASCII string &quot;0\\n&quot;. See the <b>WARNINGS</b>\nsection, below.\n\nA per-cpuset,\nrunning average is employed for the following reasons:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Because this meter is per-cpuset rather than per-process\nor per virtual memory region, the system load imposed by a\nbatch scheduler monitoring this metric is sharply reduced on\nlarge systems, because a scan of the tasklist can be avoided\non each set of queries.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Because this meter is a running average rather than an\naccumulating counter, a batch scheduler can detect memory\npressure with a single read, instead of having to read and\naccumulate results for a period of time.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Because this meter is per-cpuset rather than\nper-process, the batch scheduler can obtain the key\ninformation&mdash;memory pressure in a cpuset&mdash;with a\nsingle read, rather than having to query and accumulate\nresults over all the (dynamically changing) set of processes\nin the cpuset.</td></tr>\n</table>\n\nThe\n<i>memory_pressure</i> of a cpuset is calculated using a\nper-cpuset simple digital filter that is kept within the\nkernel. For each cpuset, this filter tracks the recent rate\nat which processes attached to that cpuset enter the kernel\ndirect reclaim code.\n\nThe kernel\ndirect reclaim code is entered whenever a process has to\nsatisfy a memory page request by first finding some other\npage to repurpose, due to lack of any readily available\nalready free pages. Dirty filesystem pages are repurposed by\nfirst writing them to disk. Unmodified filesystem buffer\npages are repurposed by simply dropping them, though if that\npage is needed again, it will have to be reread from\ndisk.\n\nThe\n<i>cpuset.memory_pressure</i> file provides an integer\nnumber representing the recent (half-life of 10 seconds)\nrate of entries to the direct reclaim code caused by any\nprocess in the cpuset, in units of reclaims attempted per\nsecond, times 1000.\n\n<b>Memory\nspread</b> <br>\nThere are two Boolean flag files per cpuset that control\nwhere the kernel allocates pages for the filesystem buffers\nand related in-kernel data structures. They are called\n<i>cpuset.memory_spread_page</i> and\n<i>cpuset.memory_spread_slab</i>.\n\nIf the\nper-cpuset Boolean flag file\n<i>cpuset.memory_spread_page</i> is set, then the kernel\nwill spread the filesystem buffers (page cache) evenly over\nall the nodes that the faulting process is allowed to use,\ninstead of preferring to put those pages on the node where\nthe process is running.\n\nIf the\nper-cpuset Boolean flag file\n<i>cpuset.memory_spread_slab</i> is set, then the kernel\nwill spread some filesystem-related slab caches, such as\nthose for inodes and directory entries, evenly over all the\nnodes that the faulting process is allowed to use, instead\nof preferring to put those pages on the node where the\nprocess is running.\n\nThe setting of\nthese flags does not affect the data segment (see\n<a href=\"https://man.page/2/brk\">brk(2)</a>) or stack segment pages of a process.\n\nBy default,\nboth kinds of memory spreading are off and the kernel\nprefers to allocate memory pages on the node local to where\nthe requesting process is running. If that node is not\nallowed by the process&rsquo;s NUMA memory policy or cpuset\nconfiguration or if there are insufficient free memory pages\non that node, then the kernel looks for the nearest node\nthat is allowed and has sufficient free memory.\n\nWhen new\ncpusets are created, they inherit the memory spread settings\nof their parent.\n\nSetting memory\nspreading causes allocations for the affected page or slab\ncaches to ignore the process&rsquo;s NUMA memory policy and\nbe spread instead. However, the effect of these changes in\nmemory placement caused by cpuset-specified memory spreading\nis hidden from the <a href=\"https://man.page/2/mbind\">mbind(2)</a> or\n<a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a> calls. These two NUMA memory policy\ncalls always appear to behave as if no cpuset-specified\nmemory spreading is in effect, even if it is. If cpuset\nmemory spreading is subsequently turned off, the NUMA memory\npolicy most recently specified by these calls is\nautomatically reapplied.\n\nBoth\n<i>cpuset.memory_spread_page</i> and\n<i>cpuset.memory_spread_slab</i> are Boolean flag files. By\ndefault, they contain &quot;0&quot;, meaning that the\nfeature is off for that cpuset. If a &quot;1&quot; is\nwritten to that file, that turns the named feature on.\n\n\nCpuset-specified\nmemory spreading behaves similarly to what is known (in\nother contexts) as round-robin or interleave memory\nplacement.\n\n\nCpuset-specified\nmemory spreading can provide substantial performance\nimprovements for jobs that:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">a)</td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">need to place thread-local data\non memory nodes close to the CPUs which are running the\nthreads that most frequently access that data; but also</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>b)</td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>need to access large filesystem data sets that must to\nbe spread across the several nodes in the job&rsquo;s cpuset\nin order to fit.</td></tr>\n</table>\n\nWithout this\npolicy, the memory allocation across the nodes in the\njob&rsquo;s cpuset can become very uneven, especially for\njobs that might have just a single thread initializing or\nreading in the data set.\n\n<b>Memory\nmigration</b> <br>\nNormally, under the default setting (disabled) of\n<i>cpuset.memory_migrate</i>, once a page is allocated\n(given a physical page of main memory), then that page stays\non whatever node it was allocated, so long as it remains\nallocated, even if the cpuset&rsquo;s memory-placement\npolicy <i>mems</i> subsequently changes.\n\nWhen memory\nmigration is enabled in a cpuset, if the <i>mems</i> setting\nof the cpuset is changed, then any memory page in use by any\nprocess in the cpuset that is on a memory node that is no\nlonger allowed will be migrated to a memory node that is\nallowed.\n\nFurthermore, if\na process is moved into a cpuset with <i>memory_migrate</i>\nenabled, any memory pages it uses that were on memory nodes\nallowed in its previous cpuset, but which are not allowed in\nits new cpuset, will be migrated to a memory node allowed in\nthe new cpuset.\n\nThe relative\nplacement of a migrated page within the cpuset is preserved\nduring these migration operations if possible. For example,\nif the page was on the second valid node of the prior\ncpuset, then the page will be placed on the second valid\nnode of the new cpuset, if possible.\n\n<b>Scheduler\nload balancing</b> <br>\nThe kernel scheduler automatically load balances processes.\nIf one CPU is underutilized, the kernel will look for\nprocesses on other more overloaded CPUs and move those\nprocesses to the underutilized CPU, within the constraints\nof such placement mechanisms as cpusets and\n<a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>.\n\nThe algorithmic\ncost of load balancing and its impact on key shared kernel\ndata structures such as the process list increases more than\nlinearly with the number of CPUs being balanced. For\nexample, it costs more to load balance across one large set\nof CPUs than it does to balance across two smaller sets of\nCPUs, each of half the size of the larger set. (The precise\nrelationship between the number of CPUs being balanced and\nthe cost of load balancing depends on implementation details\nof the kernel process scheduler, which is subject to change\nover time, as improved kernel scheduler algorithms are\nimplemented.)\n\nThe per-cpuset\nflag <i>sched_load_balance</i> provides a mechanism to\nsuppress this automatic scheduler load balancing in cases\nwhere it is not needed and suppressing it would have\nworthwhile performance benefits.\n\nBy default,\nload balancing is done across all CPUs, except those marked\nisolated using the kernel boot time &quot;isolcpus=&quot;\nargument. (See <b>Scheduler Relax Domain Level</b>, below,\nto change this default.)\n\nThis default\nload balancing across all CPUs is not well suited to the\nfollowing two situations:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">On large systems, load balancing\nacross many CPUs is expensive. If the system is managed\nusing cpusets to place independent jobs on separate sets of\nCPUs, full load balancing is unnecessary.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Systems supporting real-time on some CPUs need to\nminimize system overhead on those CPUs, including avoiding\nprocess load balancing if that is not needed.</td></tr>\n</table>\n\nWhen the\nper-cpuset flag <i>sched_load_balance</i> is enabled (the\ndefault setting), it requests load balancing across all the\nCPUs in that cpuset&rsquo;s allowed CPUs, ensuring that load\nbalancing can move a process (not otherwise pinned, as by\n<a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>) from any CPU in that cpuset to\nany other.\n\nWhen the\nper-cpuset flag <i>sched_load_balance</i> is disabled, then\nthe scheduler will avoid load balancing across the CPUs in\nthat cpuset, <i>except</i> in so far as is necessary because\nsome overlapping cpuset has <i>sched_load_balance</i>\nenabled.\n\nSo, for\nexample, if the top cpuset has the flag\n<i>sched_load_balance</i> enabled, then the scheduler will\nload balance across all CPUs, and the setting of the\n<i>sched_load_balance</i> flag in other cpusets has no\neffect, as we&rsquo;re already fully load balancing.\n\nTherefore in\nthe above two situations, the flag <i>sched_load_balance</i>\nshould be disabled in the top cpuset, and only some of the\nsmaller, child cpusets would have this flag enabled.\n\nWhen doing\nthis, you don&rsquo;t usually want to leave any unpinned\nprocesses in the top cpuset that might use nontrivial\namounts of CPU, as such processes may be artificially\nconstrained to some subset of CPUs, depending on the\nparticulars of this flag setting in descendant cpusets. Even\nif such a process could use spare CPU cycles in some other\nCPUs, the kernel scheduler might not consider the\npossibility of load balancing that process to the underused\nCPU.\n\nOf course,\nprocesses pinned to a particular CPU can be left in a cpuset\nthat disables <i>sched_load_balance</i> as those processes\naren&rsquo;t going anywhere else anyway.\n\n<b>Scheduler\nrelax domain level</b> <br>\nThe kernel scheduler performs immediate load balancing\nwhenever a CPU becomes free or another task becomes\nrunnable. This load balancing works to ensure that as many\nCPUs as possible are usefully employed running tasks. The\nkernel also performs periodic load balancing off the\nsoftware clock described in <a href=\"https://man.page/7/time\">time(7)</a>. The setting of\n<i>sched_relax_domain_level</i> applies only to immediate\nload balancing. Regardless of the\n<i>sched_relax_domain_level</i> setting, periodic load\nbalancing is attempted over all CPUs (unless disabled by\nturning off <i>sched_load_balance</i>.) In any case, of\ncourse, tasks will be scheduled to run only on CPUs allowed\nby their cpuset, as modified by <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>\nsystem calls.\n\nOn small\nsystems, such as those with just a few CPUs, immediate load\nbalancing is useful to improve system interactivity and to\nminimize wasteful idle CPU cycles. But on large systems,\nattempting immediate load balancing across a large number of\nCPUs can be more costly than it is worth, depending on the\nparticular performance characteristics of the job mix and\nthe hardware.\n\nThe exact\nmeaning of the small integer values of\n<i>sched_relax_domain_level</i> will depend on internal\nimplementation details of the kernel scheduler code and on\nthe non-uniform architecture of the hardware. Both of these\nwill evolve over time and vary by system architecture and\nkernel version.\n\nAs of this\nwriting, when this capability was introduced in Linux\n2.6.26, on certain popular architectures, the positive\nvalues of <i>sched_relax_domain_level</i> have the following\nmeanings.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\"><b>(1)</b></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Perform immediate load balancing\nacross Hyper-Thread siblings on the same core.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(2)</b></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across other cores in\nthe same package.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(3)</b></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across other CPUs on\nthe same node or blade.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(4)</b></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across over several\n(implementation detail) nodes [On NUMA systems].</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(5)</b></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across over all CPUs in\nsystem [On NUMA systems].</td></tr>\n</table>\n\nThe\n<i>sched_relax_domain_level</i> value of zero (0) always\nmeans don&rsquo;t perform immediate load balancing, hence\nthat load balancing is done only periodically, not\nimmediately when a CPU becomes available or another task\nbecomes runnable.\n\nThe\n<i>sched_relax_domain_level</i> value of minus one (-1)\nalways means use the system default value. The system\ndefault value can vary by architecture and kernel version.\nThis system default value can be changed by kernel boot-time\n&quot;relax_domain_level=&quot; argument.\n\nIn the case of\nmultiple overlapping cpusets which have conflicting\n<i>sched_relax_domain_level</i> values, then the highest\nsuch value applies to all CPUs in any of the overlapping\ncpusets. In such cases, the value <b>minus one (-1)</b> is\nthe lowest value, overridden by any other value, and the\nvalue <b>zero (0)</b> is the next lowest value.\n\n<h2>FORMATS\n<a name=\"FORMATS\"></a>\n</h2>\n\n\nThe following\nformats are used to represent sets of CPUs and memory\nnodes.\n\n<b>Mask\nformat</b> <br>\nThe <b>Mask Format</b> is used to represent CPU and\nmemory-node bit masks in the <i>/proc/&lt;pid&gt;/status</i>\nfile.\n\nThis format\ndisplays each 32-bit word in hexadecimal (using ASCII\ncharacters &quot;0&quot; - &quot;9&quot; and &quot;a&quot; -\n&quot;f&quot;); words are filled with leading zeros, if\nrequired. For masks longer than one word, a comma separator\nis used between words. Words are displayed in big-endian\norder, which has the most significant bit first. The hex\ndigits within a word are also in big-endian order.\n\nThe number of\n32-bit words displayed is the minimum number needed to\ndisplay all bits of the bit mask, based on the size of the\nbit mask.\n\nExamples of the\n<b>Mask Format</b>:\n\n<p style=\"margin-left:17%; margin-top: 1em\">00000001 # just\nbit 0 set <br>\n40000000,00000000,00000000 # just bit 94 set <br>\n00000001,00000000,00000000 # just bit 64 set <br>\n000000ff,00000000 # bits 32-39 set <br>\n00000000,000e3862 # 1,5,6,11-13,17-19 set\n\nA mask with\nbits 0, 1, 2, 4, 8, 16, 32, and 64 set displays as:\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">00000001,00000001,00010117\n\nThe first\n&quot;1&quot; is for bit 64, the second for bit 32, the\nthird for bit 16, the fourth for bit 8, the fifth for bit 4,\nand the &quot;7&quot; is for bits 2, 1, and 0.\n\n<b>List\nformat</b> <br>\nThe <b>List Format</b> for <i>cpus</i> and <i>mems</i> is a\ncomma-separated list of CPU or memory-node numbers and\nranges of numbers, in ASCII decimal.\n\nExamples of the\n<b>List Format</b>:\n\n<p style=\"margin-left:17%; margin-top: 1em\">0-4,9 # bits 0,\n1, 2, 3, 4, and 9 set <br>\n0-2,7,12-14 # bits 0, 1, 2, 7, 12, 13, and 14 set\n\n<h2>RULES\n<a name=\"RULES\"></a>\n</h2>\n\n\nThe following\nrules apply to each cpuset:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Its CPUs and memory nodes must\nbe a (possibly equal) subset of its parent&rsquo;s.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>It can be marked <i>cpu_exclusive</i> only if its parent\nis. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>It can be marked <i>mem_exclusive</i> only if its parent\nis. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If it is <i>cpu_exclusive</i>, its CPUs may not overlap\nany sibling.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If it is <i>memory_exclusive</i>, its memory nodes may\nnot overlap any sibling.</td></tr>\n</table>\n\n<h2>PERMISSIONS\n<a name=\"PERMISSIONS\"></a>\n</h2>\n\n\nThe permissions\nof a cpuset are determined by the permissions of the\ndirectories and pseudo-files in the cpuset filesystem,\nnormally mounted at <i>/dev/cpuset</i>.\n\nFor instance, a\nprocess can put itself in some other cpuset (than its\ncurrent one) if it can write the <i>tasks</i> file for that\ncpuset. This requires execute permission on the encompassing\ndirectories and write permission on the <i>tasks</i>\nfile.\n\nAn additional\nconstraint is applied to requests to place some other\nprocess in a cpuset. One process may not attach another to a\ncpuset unless it would have permission to send that process\na signal (see <a href=\"https://man.page/2/kill\">kill(2)</a>).\n\nA process may\ncreate a child cpuset if it can access and write the parent\ncpuset directory. It can modify the CPUs or memory nodes in\na cpuset if it can access that cpuset&rsquo;s directory\n(execute permissions on the each of the parent directories)\nand write the corresponding <i>cpus</i> or <i>mems</i>\nfile.\n\nThere is one\nminor difference between the manner in which these\npermissions are evaluated and the manner in which normal\nfilesystem operation permissions are evaluated. The kernel\ninterprets relative pathnames starting at a process&rsquo;s\ncurrent working directory. Even if one is operating on a\ncpuset file, relative pathnames are interpreted relative to\nthe process&rsquo;s current working directory, not relative\nto the process&rsquo;s current cpuset. The only ways that\ncpuset paths relative to a process&rsquo;s current cpuset\ncan be used are if either the process&rsquo;s current\nworking directory is its cpuset (it first did a <b>cd</b> or\n<a href=\"https://man.page/2/chdir\">chdir(2)</a> to its cpuset directory beneath\n<i>/dev/cpuset</i>, which is a bit unusual) or if some user\ncode converts the relative cpuset path to a full filesystem\npath.\n\nIn theory, this\nmeans that user code should specify cpusets using absolute\npathnames, which requires knowing the mount point of the\ncpuset filesystem (usually, but not necessarily,\n<i>/dev/cpuset</i>). In practice, all user level code that\nthis author is aware of simply assumes that if the cpuset\nfilesystem is mounted, then it is mounted at\n<i>/dev/cpuset</i>. Furthermore, it is common practice for\ncarefully written user code to verify the presence of the\npseudo-file <i>/dev/cpuset/tasks</i> in order to verify that\nthe cpuset pseudo-filesystem is currently mounted.\n\n<h2>WARNINGS\n<a name=\"WARNINGS\"></a>\n</h2>\n\n\n<b>Enabling\nmemory_pressure</b> <br>\nBy default, the per-cpuset file\n<i>cpuset.memory_pressure</i> always contains zero (0).\nUnless this feature is enabled by writing &quot;1&quot; to\nthe pseudo-file\n<i>/dev/cpuset/cpuset.memory_pressure_enabled</i>, the\nkernel does not compute per-cpuset\n<i>memory_pressure</i>.\n\n<b>Using the\necho command</b> <br>\nWhen using the <b>echo</b> command at the shell prompt to\nchange the values of cpuset files, beware that the built-in\n<b>echo</b> command in some shells does not display an error\nmessage if the <a href=\"https://man.page/2/write\">write(2)</a> system call fails. For\nexample, if the command:\n\n<p style=\"margin-left:17%; margin-top: 1em\">echo 19 &gt;\ncpuset.mems\n\nfailed because\nmemory node 19 was not allowed (perhaps the current system\ndoes not have a memory node 19), then the <b>echo</b>\ncommand might not display any error. It is better to use the\n<b>/bin/echo</b> external command to change cpuset file\nsettings, as this command will display <a href=\"https://man.page/2/write\">write(2)</a>\nerrors, as in the example:\n\n<p style=\"margin-left:17%; margin-top: 1em\">/bin/echo 19\n&gt; cpuset.mems <br>\n/bin/echo: write error: Invalid argument\n\n<h2>EXCEPTIONS\n<a name=\"EXCEPTIONS\"></a>\n</h2>\n\n\n<b>Memory\nplacement</b> <br>\nNot all allocations of system memory are constrained by\ncpusets, for the following reasons.\n\nIf hot-plug\nfunctionality is used to remove all the CPUs that are\ncurrently assigned to a cpuset, then the kernel will\nautomatically update the <i>cpus_allowed</i> of all\nprocesses attached to CPUs in that cpuset to allow all CPUs.\nWhen memory hot-plug functionality for removing memory nodes\nis available, a similar exception is expected to apply there\nas well. In general, the kernel prefers to violate cpuset\nplacement, rather than starving a process that has had all\nits allowed CPUs or memory nodes taken offline. User code\nshould reconfigure cpusets to refer only to online CPUs and\nmemory nodes when using hot-plug to add or remove such\nresources.\n\nA few\nkernel-critical, internal memory-allocation requests, marked\nGFP_ATOMIC, must be satisfied immediately. The kernel may\ndrop some request or malfunction if one of these allocations\nfail. If such a request cannot be satisfied within the\ncurrent process&rsquo;s cpuset, then we relax the cpuset,\nand look for memory anywhere we can find it. It&rsquo;s\nbetter to violate the cpuset than stress the kernel.\n\nAllocations of\nmemory requested by kernel drivers while processing an\ninterrupt lack any relevant process context, and are not\nconfined by cpusets.\n\n<b>Renaming\ncpusets</b> <br>\nYou can use the <a href=\"https://man.page/2/rename\">rename(2)</a> system call to rename\ncpusets. Only simple renaming is supported; that is,\nchanging the name of a cpuset directory is permitted, but\nmoving a directory into a different directory is not\npermitted.\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\nThe Linux\nkernel implementation of cpusets sets <i>errno</i> to\nspecify the reason for a failed system call affecting\ncpusets.\n\nThe possible\n<i>errno</i> settings and their meaning when set on a failed\ncpuset call are as listed below.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>E2BIG</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Attempted a <a href=\"https://man.page/2/write\">write(2)</a> on a\nspecial cpuset file with a length larger than some\nkernel-determined upper limit on the length of such\nwrites. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> the process ID (PID) of a\nprocess to a cpuset <i>tasks</i> file when one lacks\npermission to move that process.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to add, using <a href=\"https://man.page/2/write\">write(2)</a>, a CPU or memory\nnode to a cpuset, when that CPU or memory node was not\nalready in its parent.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to set, using <a href=\"https://man.page/2/write\">write(2)</a>,\n<i>cpuset.cpu_exclusive</i> or <i>cpuset.mem_exclusive</i>\non a cpuset whose parent lacks the same setting.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a\n<i>cpuset.memory_pressure</i> file.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to create a file in a cpuset directory.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove, using <a href=\"https://man.page/2/rmdir\">rmdir(2)</a>, a cpuset\nwith attached processes.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove, using <a href=\"https://man.page/2/rmdir\">rmdir(2)</a>, a cpuset\nwith child cpusets.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove a CPU or memory node from a cpuset\nthat is also in a child of that cpuset.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EEXIST</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to create, using <a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset\nthat already exists.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EEXIST</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/rename\">rename(2)</a> a cpuset to a name that\nalready exists.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/read\">read(2)</a> or <a href=\"https://man.page/2/write\">write(2)</a> a cpuset\nfile using a buffer that is outside the writing processes\naccessible address space.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to change a cpuset, using <a href=\"https://man.page/2/write\">write(2)</a>, in\na way that would violate a <i>cpu_exclusive</i> or\n<i>mem_exclusive</i> attribute of that cpuset or any of its\nsiblings. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> an empty <i>cpuset.cpus</i>\nor <i>cpuset.mems</i> list to a cpuset which has attached\nprocesses or child cpusets.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a <i>cpuset.cpus</i> or\n<i>cpuset.mems</i> list which included a range with the\nsecond number smaller than the first number.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a <i>cpuset.cpus</i> or\n<i>cpuset.mems</i> list which included an invalid character\nin the string.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a list to a\n<i>cpuset.cpus</i> file that did not include any online\nCPUs. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a list to a\n<i>cpuset.mems</i> file that did not include any online\nmemory nodes.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a list to a\n<i>cpuset.mems</i> file that included a node that held no\nmemory. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a string to a cpuset\n<i>tasks</i> file that does not begin with an ASCII decimal\ninteger. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/rename\">rename(2)</a> a cpuset into a different\ndirectory. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENAMETOOLONG</b>\n\n<p style=\"margin-left:22%;\">Attempted to <a href=\"https://man.page/2/read\">read(2)</a> a\n<i>/proc/&lt;pid&gt;/cpuset</i> file for a cpuset path that\nis longer than the kernel page size.\n\n<p style=\"margin-left:11%;\"><b>ENAMETOOLONG</b>\n\n<p style=\"margin-left:22%;\">Attempted to create, using\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset whose base directory name is\nlonger than 255 characters.\n\n<p style=\"margin-left:11%;\"><b>ENAMETOOLONG</b>\n\n<p style=\"margin-left:22%;\">Attempted to create, using\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset whose full pathname, including the\nmount point (typically &quot;/dev/cpuset/&quot;) prefix, is\nlonger than 4095 characters.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENODEV</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The cpuset was removed by another process at the same\ntime as a <a href=\"https://man.page/2/write\">write(2)</a> was attempted on one of the\npseudo-files in the cpuset directory.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to create, using <a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset in\na parent cpuset that doesn&rsquo;t exist.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/access\">access(2)</a> or <a href=\"https://man.page/2/open\">open(2)</a> a\nnonexistent file in a cpuset directory.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Insufficient memory is available within the kernel; can\noccur on a variety of system calls affecting cpusets, but\nonly if the system is extremely short of memory.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSPC</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> the process ID (PID) of a\nprocess to a cpuset <i>tasks</i> file when the cpuset had an\nempty <i>cpuset.cpus</i> or empty <i>cpuset.mems</i>\nsetting. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSPC</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> an empty <i>cpuset.cpus</i>\nor <i>cpuset.mems</i> setting to a cpuset that has tasks\nattached. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTDIR</b>\n\n<p style=\"margin-left:22%;\">Attempted to <a href=\"https://man.page/2/rename\">rename(2)</a> a\nnonexistent cpuset.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove a file from a cpuset directory.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ERANGE</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Specified a <i>cpuset.cpus</i> or <i>cpuset.mems</i>\nlist to the kernel which included a number too large for the\nkernel to set in its bit masks.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESRCH</b></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> the process ID (PID) of a\nnonexistent process to a cpuset <i>tasks</i> file.</td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\nCpusets\nappeared in version 2.6.12 of the Linux kernel.\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\nDespite its\nname, the <i>pid</i> parameter is actually a thread ID, and\neach thread in a threaded group can be attached to a\ndifferent cpuset. The value returned from a call to\n<a href=\"https://man.page/2/gettid\">gettid(2)</a> can be passed in the argument\n<i>pid</i>.\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n\n<i>cpuset.memory_pressure</i>\ncpuset files can be opened for writing, creation, or\ntruncation, but then the <a href=\"https://man.page/2/write\">write(2)</a> fails with\n<i>errno</i> set to <b>EACCES</b>, and the creation and\ntruncation options on <a href=\"https://man.page/2/open\">open(2)</a> have no effect.\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\nThe following\nexamples demonstrate querying and setting cpuset options\nusing shell commands.\n\n<b>Creating and\nattaching to a cpuset.</b> <br>\nTo create a new cpuset and attach the current command shell\nto it, the steps are:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">mkdir /dev/cpuset (if not\nalready done)</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>mount -t cpuset none /dev/cpuset (if not already\ndone) </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Create the new cpuset using <a href=\"https://man.page/1/mkdir\">mkdir(1)</a>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Assign CPUs and memory nodes to the new cpuset.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Attach the shell to the new cpuset.</td></tr>\n</table>\n\nFor example,\nthe following sequence of commands will set up a cpuset\nnamed &quot;Charlie&quot;, containing just CPUs 2 and 3, and\nmemory node 1, and then attach the current shell to that\ncpuset.\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>mkdir\n/dev/cpuset</b> <br>\n$ <b>mount -t cpuset cpuset /dev/cpuset</b> <br>\n$ <b>cd /dev/cpuset</b> <br>\n$ <b>mkdir Charlie</b> <br>\n$ <b>cd Charlie</b> <br>\n$ <b>/bin/echo 2-3 &gt; cpuset.cpus</b> <br>\n$ <b>/bin/echo 1 &gt; cpuset.mems</b> <br>\n$ <b>/bin/echo $$ &gt; tasks</b> <br>\n# The current shell is now running in cpuset Charlie <br>\n# The next line should display '/Charlie' <br>\n$ <b>cat /proc/self/cpuset</b>\n\n<b>Migrating a\njob to different memory nodes.</b> <br>\nTo migrate a job (the set of processes attached to a cpuset)\nto different CPUs and memory nodes in the system, including\nmoving the memory pages currently allocated to that job,\nperform the following steps.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Let&rsquo;s say we want to move\nthe job in cpuset <i>alpha</i> (CPUs 4&ndash;7 and memory\nnodes 2&ndash;3) to a new cpuset <i>beta</i> (CPUs\n16&ndash;19 and memory nodes 8&ndash;9).</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>First create the new cpuset <i>beta</i>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Then allow CPUs 16&ndash;19 and memory nodes 8&ndash;9\nin <i>beta</i>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Then enable <i>memory_migration</i> in <i>beta</i>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5)</td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Then move each process from <i>alpha</i> to\n<i>beta</i>. </td></tr>\n</table>\n\nThe following\nsequence of commands accomplishes this.\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cd\n/dev/cpuset</b> <br>\n$ <b>mkdir beta</b> <br>\n$ <b>cd beta</b> <br>\n$ <b>/bin/echo 16-19 &gt; cpuset.cpus</b> <br>\n$ <b>/bin/echo 8-9 &gt; cpuset.mems</b> <br>\n$ <b>/bin/echo 1 &gt; cpuset.memory_migrate</b> <br>\n$ <b>while read i; do /bin/echo $i; done &lt; ../alpha/tasks\n&gt; tasks</b>\n\nThe above\nshould move any processes in <i>alpha</i> to <i>beta</i>,\nand any memory held by these processes on memory nodes\n2&ndash;3 to memory nodes 8&ndash;9, respectively.\n\nNotice that the\nlast step of the above sequence did not do:\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cp\n../alpha/tasks tasks</b>\n\nThe\n<i>while</i> loop, rather than the seemingly easier use of\nthe <a href=\"https://man.page/1/cp\">cp(1)</a> command, was necessary because only one\nprocess PID at a time may be written to the <i>tasks</i>\nfile.\n\nThe same effect\n(writing one PID at a time) as the <i>while</i> loop can be\naccomplished more efficiently, in fewer keystrokes and in\nsyntax that works on any shell, but alas more obscurely, by\nusing the <b>-u</b> (unbuffered) option of\n<a href=\"https://man.page/1/sed\">sed(1)</a>:\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>sed -un p\n&lt; ../alpha/tasks &gt; tasks</b>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/1/taskset\">taskset(1)</a>,\n<a href=\"https://man.page/2/get_mempolicy\">get_mempolicy(2)</a>, <a href=\"https://man.page/2/getcpu\">getcpu(2)</a>, <a href=\"https://man.page/2/mbind\">mbind(2)</a>,\n<a href=\"https://man.page/2/sched_getaffinity\">sched_getaffinity(2)</a>, <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>,\n<a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a>, <a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>,\n<a href=\"https://man.page/3/CPU_SET\">CPU_SET(3)</a>, <a href=\"https://man.page/5/proc\">proc(5)</a>, <a href=\"https://man.page/7/cgroups\">cgroups(7)</a>,\n<a href=\"https://man.page/7/numa\">numa(7)</a>, <a href=\"https://man.page/7/sched\">sched(7)</a>, <b>migratepages</b>(8),\n<b>numactl</b>(8)\n\n\n<i>Documentation/admin-guide/cgroup-v1/cpusets.rst</i>\nin the Linux kernel source tree (or\n<i>Documentation/cgroup-v1/cpusets.txt</i> before Linux\n4.18, and <i>Documentation/cpusets.txt</i> before Linux\n2.6.29)\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\nThis page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.","body":"\n\n<h1 align=\"center\">CPUSET</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cpuset -\nconfine processes to processor and memory node subsets</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The cpuset\nfilesystem is a pseudo-filesystem interface to the kernel\ncpuset mechanism, which is used to control the processor\nplacement and memory placement of processes. It is commonly\nmounted at <i>/dev/cpuset</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On systems with\nkernels compiled with built in support for cpusets, all\nprocesses are attached to a cpuset, and cpusets are always\npresent. If a system supports cpusets, then it will have the\nentry <b>nodev cpuset</b> in the file\n<i>/proc/filesystems</i>. By mounting the cpuset filesystem\n(see the <b>EXAMPLES</b> section below), the administrator\ncan configure the cpusets on a system to control the\nprocessor and memory placement of processes on that system.\nBy default, if the cpuset configuration on a system is not\nmodified or if the cpuset filesystem is not even mounted,\nthen the cpuset mechanism, though present, has no effect on\nthe system&rsquo;s behavior.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A cpuset\ndefines a list of CPUs and memory nodes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The CPUs of a\nsystem include all the logical processing units on which a\nprocess can execute, including, if present, multiple\nprocessor cores within a package and Hyper-Threads within a\nprocessor core. Memory nodes include all distinct banks of\nmain memory; small and SMP systems typically have just one\nmemory node that contains all the system&rsquo;s main\nmemory, while NUMA (non-uniform memory access) systems have\nmultiple memory nodes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Cpusets are\nrepresented as directories in a hierarchical\npseudo-filesystem, where the top directory in the hierarchy\n(<i>/dev/cpuset</i>) represents the entire system (all\nonline CPUs and memory nodes) and any cpuset that is the\nchild (descendant) of another parent cpuset contains a\nsubset of that parent&rsquo;s CPUs and memory nodes. The\ndirectories and files representing cpusets have normal\nfilesystem permissions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Every process\nin the system belongs to exactly one cpuset. A process is\nconfined to run only on the CPUs in the cpuset it belongs\nto, and to allocate memory only on the memory nodes in that\ncpuset. When a process <a href=\"https://man.page/2/fork\">fork(2)</a>s, the child process is\nplaced in the same cpuset as its parent. With sufficient\nprivilege, a process may be moved from one cpuset to another\nand the allowed CPUs and memory nodes of an existing cpuset\nmay be changed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the system\nbegins booting, a single cpuset is defined that includes all\nCPUs and memory nodes on the system, and all processes are\nin that cpuset. During the boot process, or later during\nnormal system operation, other cpusets may be created, as\nsubdirectories of this top cpuset, under the control of the\nsystem administrator, and processes may be placed in these\nother cpusets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Cpusets are\nintegrated with the <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a> scheduling\naffinity mechanism and the <a href=\"https://man.page/2/mbind\">mbind(2)</a> and\n<a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a> memory-placement mechanisms in the\nkernel. Neither of these mechanisms let a process make use\nof a CPU or memory node that is not allowed by that\nprocess&rsquo;s cpuset. If changes to a process&rsquo;s\ncpuset placement conflict with these other mechanisms, then\ncpuset placement is enforced even if it means overriding\nthese other mechanisms. The kernel accomplishes this\noverriding by silently restricting the CPUs and memory nodes\nrequested by these other mechanisms to those allowed by the\ninvoking process&rsquo;s cpuset. This can result in these\nother calls returning an error, if for example, such a call\nends up requesting an empty set of CPUs or memory nodes,\nafter that request is restricted to the invoking\nprocess&rsquo;s cpuset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Typically, a\ncpuset is used to manage the CPU and memory-node confinement\nfor a set of cooperating processes such as a batch scheduler\njob, and these other mechanisms are used to manage the\nplacement of individual processes or memory regions within\nthat set or job.</p>\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each directory\nbelow <i>/dev/cpuset</i> represents a cpuset and contains a\nfixed set of pseudo-files describing the state of that\ncpuset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">New cpusets are\ncreated using the <a href=\"https://man.page/2/mkdir\">mkdir(2)</a> system call or the\n<a href=\"https://man.page/1/mkdir\">mkdir(1)</a> command. The properties of a cpuset, such as\nits flags, allowed CPUs and memory nodes, and attached\nprocesses, are queried and modified by reading or writing to\nthe appropriate file in that cpuset&rsquo;s directory, as\nlisted below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\npseudo-files in each cpuset directory are automatically\ncreated when the cpuset is created, as a result of the\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a> invocation. It is not possible to directly\nadd or remove these pseudo-files.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A cpuset\ndirectory that contains no child cpuset directories, and has\nno attached processes, can be removed using <a href=\"https://man.page/2/rmdir\">rmdir(2)</a>\nor <a href=\"https://man.page/1/rmdir\">rmdir(1)</a>. It is not necessary, or possible, to\nremove the pseudo-files inside the directory before removing\nit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\npseudo-files in each cpuset directory are small text files\nthat may be read and written using traditional shell\nutilities such as <a href=\"https://man.page/1/cat\">cat(1)</a>, and <a href=\"https://man.page/1/echo\">echo(1)</a>, or from\na program by using file I/O library functions or system\ncalls, such as <a href=\"https://man.page/2/open\">open(2)</a>, <a href=\"https://man.page/2/read\">read(2)</a>,\n<a href=\"https://man.page/2/write\">write(2)</a>, and <a href=\"https://man.page/2/close\">close(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\npseudo-files in a cpuset directory represent internal kernel\nstate and do not have any persistent image on disk. Each of\nthese per-cpuset files is listed and described below.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><i>tasks</i></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>List of the process IDs (PIDs) of the processes in that\ncpuset. The list is formatted as a series of ASCII decimal\nnumbers, each followed by a newline. A process may be added\nto a cpuset (automatically removing it from the cpuset that\npreviously contained it) by writing its PID to that\ncpuset&rsquo;s <i>tasks</i> file (with or without a trailing\nnewline).</p> </td></tr>\n</table>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>Warning:</b>\nonly one PID may be written to the <i>tasks</i> file at a\ntime. If a string is written that contains more than one\nPID, only the first one will be used.</p>\n\n<p style=\"margin-left:11%;\"><i>notify_on_release</i></p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), that\ncpuset will receive special handling after it is released,\nthat is, after all processes cease using it (i.e., terminate\nor are moved to a different cpuset) and all child cpuset\ndirectories have been removed. See the <b>Notify On\nRelease</b> section, below.</p>\n\n<p style=\"margin-left:11%;\"><i>cpuset.cpus</i></p>\n\n<p style=\"margin-left:22%;\">List of the physical numbers of\nthe CPUs on which processes in that cpuset are allowed to\nexecute. See <b>List Format</b> below for a description of\nthe format of <i>cpus</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The CPUs\nallowed to a cpuset may be changed by writing a new list to\nits <i>cpus</i> file.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.cpu_exclusive</i></p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\ncpuset has exclusive use of its CPUs (no sibling or cousin\ncpuset may overlap CPUs). By default, this is off (0). Newly\ncreated cpusets also initially default this to off (0).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Two cpusets are\n<i>sibling</i> cpusets if they share the same parent cpuset\nin the <i>/dev/cpuset</i> hierarchy. Two cpusets are\n<i>cousin</i> cpusets if neither is the ancestor of the\nother. Regardless of the <i>cpu_exclusive</i> setting, if\none cpuset is the ancestor of another, and if both of these\ncpusets have nonempty <i>cpus</i>, then their <i>cpus</i>\nmust overlap, because the <i>cpus</i> of any cpuset are\nalways a subset of the <i>cpus</i> of its parent cpuset.</p>\n\n<p style=\"margin-left:11%;\"><i>cpuset.mems</i></p>\n\n<p style=\"margin-left:22%;\">List of memory nodes on which\nprocesses in this cpuset are allowed to allocate memory. See\n<b>List Format</b> below for a description of the format of\n<i>mems</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.mem_exclusive</i></p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\ncpuset has exclusive use of its memory nodes (no sibling or\ncousin may overlap). Also if set (1), the cpuset is a\n<b>Hardwall</b> cpuset (see below). By default, this is off\n(0). Newly created cpusets also initially default this to\noff (0).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Regardless of\nthe <i>mem_exclusive</i> setting, if one cpuset is the\nancestor of another, then their memory nodes must overlap,\nbecause the memory nodes of any cpuset are always a subset\nof the memory nodes of that cpuset&rsquo;s parent\ncpuset.</p>\n\n<p style=\"margin-left:11%;\"><i>cpuset.mem_hardwall</i>\n(since Linux 2.6.26)</p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\ncpuset is a <b>Hardwall</b> cpuset (see below). Unlike\n<b>mem_exclusive</b>, there is no constraint on whether\ncpusets marked <b>mem_hardwall</b> may have overlapping\nmemory nodes with sibling or cousin cpusets. By default,\nthis is off (0). Newly created cpusets also initially\ndefault this to off (0).</p>\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_migrate</i>\n(since Linux 2.6.16)</p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), then\nmemory migration is enabled. By default, this is off (0).\nSee the <b>Memory Migration</b> section, below.</p>\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_pressure</i>\n(since Linux 2.6.16)</p>\n\n<p style=\"margin-left:22%;\">A measure of how much memory\npressure the processes in this cpuset are causing. See the\n<b>Memory Pressure</b> section, below. Unless\n<i>memory_pressure_enabled</i> is enabled, always has value\nzero (0). This file is read-only. See the <b>WARNINGS</b>\nsection, below.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_pressure_enabled</i>\n(since Linux 2.6.16)</p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). This file is\npresent only in the root cpuset, normally\n<i>/dev/cpuset</i>. If set (1), the <i>memory_pressure</i>\ncalculations are enabled for all cpusets in the system. By\ndefault, this is off (0). See the <b>Memory Pressure</b>\nsection, below.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_spread_page</i>\n(since Linux 2.6.17)</p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1),\npages in the kernel page cache (filesystem buffers) are\nuniformly spread across the cpuset. By default, this is off\n(0) in the top cpuset, and inherited from the parent cpuset\nin newly created cpusets. See the <b>Memory Spread</b>\nsection, below.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.memory_spread_slab</i>\n(since Linux 2.6.17)</p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1), the\nkernel slab caches for file I/O (directory and inode\nstructures) are uniformly spread across the cpuset. By\ndefault, is off (0) in the top cpuset, and inherited from\nthe parent cpuset in newly created cpusets. See the\n<b>Memory Spread</b> section, below.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.sched_load_balance</i>\n(since Linux 2.6.24)</p>\n\n<p style=\"margin-left:22%;\">Flag (0 or 1). If set (1, the\ndefault) the kernel will automatically load balance\nprocesses in that cpuset over the allowed CPUs in that\ncpuset. If cleared (0) the kernel will avoid load balancing\nprocesses in this cpuset, <i>unless</i> some other cpuset\nwith overlapping CPUs has its <i>sched_load_balance</i> flag\nset. See <b>Scheduler Load Balancing</b>, below, for further\ndetails.</p>\n\n\n<p style=\"margin-left:11%;\"><i>cpuset.sched_relax_domain_level</i>\n(since Linux 2.6.26)</p>\n\n<p style=\"margin-left:22%;\">Integer, between -1 and a small\npositive value. The <i>sched_relax_domain_level</i> controls\nthe width of the range of CPUs over which the kernel\nscheduler performs immediate rebalancing of runnable tasks\nacross CPUs. If <i>sched_load_balance</i> is disabled, then\nthe setting of <i>sched_relax_domain_level</i> does not\nmatter, as no such load balancing is done. If\n<i>sched_load_balance</i> is enabled, then the higher the\nvalue of the <i>sched_relax_domain_level</i>, the wider the\nrange of CPUs over which immediate load balancing is\nattempted. See <b>Scheduler Relax Domain Level</b>, below,\nfor further details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition to\nthe above pseudo-files in each directory below\n<i>/dev/cpuset</i>, each process has a pseudo-file,\n<i>/proc/&lt;pid&gt;/cpuset</i>, that displays the path of\nthe process&rsquo;s cpuset directory relative to the root of\nthe cpuset filesystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also the\n<i>/proc/&lt;pid&gt;/status</i> file for each process has\nfour added lines, displaying the process&rsquo;s\n<i>Cpus_allowed</i> (on which CPUs it may be scheduled) and\n<i>Mems_allowed</i> (on which memory nodes it may obtain\nmemory), in the two formats <b>Mask Format</b> and <b>List\nFormat</b> (see below) as shown in the following\nexample:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Cpus_allowed:\nffffffff,ffffffff,ffffffff,ffffffff <br>\nCpus_allowed_list: 0-127 <br>\nMems_allowed: ffffffff,ffffffff <br>\nMems_allowed_list: 0-63</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;allowed&quot; fields were added in Linux 2.6.24; the\n&quot;allowed_list&quot; fields were added in Linux\n2.6.26.</p>\n\n<h2>EXTENDED CAPABILITIES\n<a name=\"EXTENDED CAPABILITIES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition to\ncontrolling which <i>cpus</i> and <i>mems</i> a process is\nallowed to use, cpusets provide the following extended\ncapabilities.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Exclusive\ncpusets</b> <br>\nIf a cpuset is marked <i>cpu_exclusive</i> or\n<i>mem_exclusive</i>, no other cpuset, other than a direct\nancestor or descendant, may share any of the same CPUs or\nmemory nodes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A cpuset that\nis <i>mem_exclusive</i> restricts kernel allocations for\nbuffer cache pages and other internal kernel data pages\ncommonly shared by the kernel across multiple users. All\ncpusets, whether <i>mem_exclusive</i> or not, restrict\nallocations of memory for user space. This enables\nconfiguring a system so that several independent jobs can\nshare common kernel data, while isolating each job&rsquo;s\nuser allocation in its own cpuset. To do this, construct a\nlarge <i>mem_exclusive</i> cpuset to hold all the jobs, and\nconstruct child, non-<i>mem_exclusive</i> cpusets for each\nindividual job. Only a small amount of kernel memory, such\nas requests from interrupt handlers, is allowed to be placed\non memory nodes outside even a <i>mem_exclusive</i>\ncpuset.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Hardwall</b>\n<br>\nA cpuset that has <i>mem_exclusive</i> or\n<i>mem_hardwall</i> set is a <i>hardwall</i> cpuset. A\n<i>hardwall</i> cpuset restricts kernel allocations for\npage, buffer, and other data commonly shared by the kernel\nacross multiple users. All cpusets, whether <i>hardwall</i>\nor not, restrict allocations of memory for user space.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This enables\nconfiguring a system so that several independent jobs can\nshare common kernel data, such as filesystem pages, while\nisolating each job&rsquo;s user allocation in its own\ncpuset. To do this, construct a large <i>hardwall</i> cpuset\nto hold all the jobs, and construct child cpusets for each\nindividual job which are not <i>hardwall</i> cpusets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Only a small\namount of kernel memory, such as requests from interrupt\nhandlers, is allowed to be taken outside even a\n<i>hardwall</i> cpuset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Notify on\nrelease</b> <br>\nIf the <i>notify_on_release</i> flag is enabled (1) in a\ncpuset, then whenever the last process in the cpuset leaves\n(exits or attaches to some other cpuset) and the last child\ncpuset of that cpuset is removed, the kernel will run the\ncommand <i>/sbin/cpuset_release_agent</i>, supplying the\npathname (relative to the mount point of the cpuset\nfilesystem) of the abandoned cpuset. This enables automatic\nremoval of abandoned cpusets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\nvalue of <i>notify_on_release</i> in the root cpuset at\nsystem boot is disabled (0). The default value of other\ncpusets at creation is the current value of their\nparent&rsquo;s <i>notify_on_release</i> setting.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The command\n<i>/sbin/cpuset_release_agent</i> is invoked, with the name\n(<i>/dev/cpuset</i> relative path) of the to-be-released\ncpuset in <i>argv[1]</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The usual\ncontents of the command <i>/sbin/cpuset_release_agent</i> is\nsimply the shell script:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#!/bin/sh <br>\nrmdir /dev/cpuset/$1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As with other\nflag values below, this flag can be changed by writing an\nASCII number 0 or 1 (with optional trailing newline) into\nthe file, to clear or set the flag, respectively.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Memory\npressure</b> <br>\nThe <i>memory_pressure</i> of a cpuset provides a simple\nper-cpuset running average of the rate that the processes in\na cpuset are attempting to free up in-use memory on the\nnodes of the cpuset to satisfy additional memory\nrequests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This enables\nbatch managers that are monitoring jobs running in dedicated\ncpusets to efficiently detect what level of memory pressure\nthat job is causing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is useful\nboth on tightly managed systems running a wide mix of\nsubmitted jobs, which may choose to terminate or\nreprioritize jobs that are trying to use more memory than\nallowed on the nodes assigned them, and with tightly\ncoupled, long-running, massively parallel scientific\ncomputing jobs that will dramatically fail to meet required\nperformance goals if they start to use more memory than\nallowed to them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This mechanism\nprovides a very economical way for the batch manager to\nmonitor a cpuset for signs of memory pressure. It&rsquo;s up\nto the batch manager or other user code to decide what\naction to take if it detects signs of memory pressure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Unless memory\npressure calculation is enabled by setting the pseudo-file\n<i>/dev/cpuset/cpuset.memory_pressure_enabled</i>, it is not\ncomputed for any cpuset, and reads from any\n<i>memory_pressure</i> always return zero, as represented by\nthe ASCII string &quot;0\\n&quot;. See the <b>WARNINGS</b>\nsection, below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A per-cpuset,\nrunning average is employed for the following reasons:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Because this meter is per-cpuset rather than per-process\nor per virtual memory region, the system load imposed by a\nbatch scheduler monitoring this metric is sharply reduced on\nlarge systems, because a scan of the tasklist can be avoided\non each set of queries.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Because this meter is a running average rather than an\naccumulating counter, a batch scheduler can detect memory\npressure with a single read, instead of having to read and\naccumulate results for a period of time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Because this meter is per-cpuset rather than\nper-process, the batch scheduler can obtain the key\ninformation&mdash;memory pressure in a cpuset&mdash;with a\nsingle read, rather than having to query and accumulate\nresults over all the (dynamically changing) set of processes\nin the cpuset.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>memory_pressure</i> of a cpuset is calculated using a\nper-cpuset simple digital filter that is kept within the\nkernel. For each cpuset, this filter tracks the recent rate\nat which processes attached to that cpuset enter the kernel\ndirect reclaim code.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The kernel\ndirect reclaim code is entered whenever a process has to\nsatisfy a memory page request by first finding some other\npage to repurpose, due to lack of any readily available\nalready free pages. Dirty filesystem pages are repurposed by\nfirst writing them to disk. Unmodified filesystem buffer\npages are repurposed by simply dropping them, though if that\npage is needed again, it will have to be reread from\ndisk.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cpuset.memory_pressure</i> file provides an integer\nnumber representing the recent (half-life of 10 seconds)\nrate of entries to the direct reclaim code caused by any\nprocess in the cpuset, in units of reclaims attempted per\nsecond, times 1000.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Memory\nspread</b> <br>\nThere are two Boolean flag files per cpuset that control\nwhere the kernel allocates pages for the filesystem buffers\nand related in-kernel data structures. They are called\n<i>cpuset.memory_spread_page</i> and\n<i>cpuset.memory_spread_slab</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nper-cpuset Boolean flag file\n<i>cpuset.memory_spread_page</i> is set, then the kernel\nwill spread the filesystem buffers (page cache) evenly over\nall the nodes that the faulting process is allowed to use,\ninstead of preferring to put those pages on the node where\nthe process is running.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nper-cpuset Boolean flag file\n<i>cpuset.memory_spread_slab</i> is set, then the kernel\nwill spread some filesystem-related slab caches, such as\nthose for inodes and directory entries, evenly over all the\nnodes that the faulting process is allowed to use, instead\nof preferring to put those pages on the node where the\nprocess is running.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The setting of\nthese flags does not affect the data segment (see\n<a href=\"https://man.page/2/brk\">brk(2)</a>) or stack segment pages of a process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nboth kinds of memory spreading are off and the kernel\nprefers to allocate memory pages on the node local to where\nthe requesting process is running. If that node is not\nallowed by the process&rsquo;s NUMA memory policy or cpuset\nconfiguration or if there are insufficient free memory pages\non that node, then the kernel looks for the nearest node\nthat is allowed and has sufficient free memory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When new\ncpusets are created, they inherit the memory spread settings\nof their parent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Setting memory\nspreading causes allocations for the affected page or slab\ncaches to ignore the process&rsquo;s NUMA memory policy and\nbe spread instead. However, the effect of these changes in\nmemory placement caused by cpuset-specified memory spreading\nis hidden from the <a href=\"https://man.page/2/mbind\">mbind(2)</a> or\n<a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a> calls. These two NUMA memory policy\ncalls always appear to behave as if no cpuset-specified\nmemory spreading is in effect, even if it is. If cpuset\nmemory spreading is subsequently turned off, the NUMA memory\npolicy most recently specified by these calls is\nautomatically reapplied.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both\n<i>cpuset.memory_spread_page</i> and\n<i>cpuset.memory_spread_slab</i> are Boolean flag files. By\ndefault, they contain &quot;0&quot;, meaning that the\nfeature is off for that cpuset. If a &quot;1&quot; is\nwritten to that file, that turns the named feature on.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Cpuset-specified\nmemory spreading behaves similarly to what is known (in\nother contexts) as round-robin or interleave memory\nplacement.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Cpuset-specified\nmemory spreading can provide substantial performance\nimprovements for jobs that:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">a)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">need to place thread-local data\non memory nodes close to the CPUs which are running the\nthreads that most frequently access that data; but also</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>b)</p></td>\n<td width=\"1%\"></td>\n<td width=\"85%\">\n\n\n<p>need to access large filesystem data sets that must to\nbe spread across the several nodes in the job&rsquo;s cpuset\nin order to fit.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Without this\npolicy, the memory allocation across the nodes in the\njob&rsquo;s cpuset can become very uneven, especially for\njobs that might have just a single thread initializing or\nreading in the data set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Memory\nmigration</b> <br>\nNormally, under the default setting (disabled) of\n<i>cpuset.memory_migrate</i>, once a page is allocated\n(given a physical page of main memory), then that page stays\non whatever node it was allocated, so long as it remains\nallocated, even if the cpuset&rsquo;s memory-placement\npolicy <i>mems</i> subsequently changes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When memory\nmigration is enabled in a cpuset, if the <i>mems</i> setting\nof the cpuset is changed, then any memory page in use by any\nprocess in the cpuset that is on a memory node that is no\nlonger allowed will be migrated to a memory node that is\nallowed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Furthermore, if\na process is moved into a cpuset with <i>memory_migrate</i>\nenabled, any memory pages it uses that were on memory nodes\nallowed in its previous cpuset, but which are not allowed in\nits new cpuset, will be migrated to a memory node allowed in\nthe new cpuset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The relative\nplacement of a migrated page within the cpuset is preserved\nduring these migration operations if possible. For example,\nif the page was on the second valid node of the prior\ncpuset, then the page will be placed on the second valid\nnode of the new cpuset, if possible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Scheduler\nload balancing</b> <br>\nThe kernel scheduler automatically load balances processes.\nIf one CPU is underutilized, the kernel will look for\nprocesses on other more overloaded CPUs and move those\nprocesses to the underutilized CPU, within the constraints\nof such placement mechanisms as cpusets and\n<a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The algorithmic\ncost of load balancing and its impact on key shared kernel\ndata structures such as the process list increases more than\nlinearly with the number of CPUs being balanced. For\nexample, it costs more to load balance across one large set\nof CPUs than it does to balance across two smaller sets of\nCPUs, each of half the size of the larger set. (The precise\nrelationship between the number of CPUs being balanced and\nthe cost of load balancing depends on implementation details\nof the kernel process scheduler, which is subject to change\nover time, as improved kernel scheduler algorithms are\nimplemented.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The per-cpuset\nflag <i>sched_load_balance</i> provides a mechanism to\nsuppress this automatic scheduler load balancing in cases\nwhere it is not needed and suppressing it would have\nworthwhile performance benefits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nload balancing is done across all CPUs, except those marked\nisolated using the kernel boot time &quot;isolcpus=&quot;\nargument. (See <b>Scheduler Relax Domain Level</b>, below,\nto change this default.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This default\nload balancing across all CPUs is not well suited to the\nfollowing two situations:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">On large systems, load balancing\nacross many CPUs is expensive. If the system is managed\nusing cpusets to place independent jobs on separate sets of\nCPUs, full load balancing is unnecessary.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Systems supporting real-time on some CPUs need to\nminimize system overhead on those CPUs, including avoiding\nprocess load balancing if that is not needed.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\nper-cpuset flag <i>sched_load_balance</i> is enabled (the\ndefault setting), it requests load balancing across all the\nCPUs in that cpuset&rsquo;s allowed CPUs, ensuring that load\nbalancing can move a process (not otherwise pinned, as by\n<a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>) from any CPU in that cpuset to\nany other.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\nper-cpuset flag <i>sched_load_balance</i> is disabled, then\nthe scheduler will avoid load balancing across the CPUs in\nthat cpuset, <i>except</i> in so far as is necessary because\nsome overlapping cpuset has <i>sched_load_balance</i>\nenabled.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, for\nexample, if the top cpuset has the flag\n<i>sched_load_balance</i> enabled, then the scheduler will\nload balance across all CPUs, and the setting of the\n<i>sched_load_balance</i> flag in other cpusets has no\neffect, as we&rsquo;re already fully load balancing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Therefore in\nthe above two situations, the flag <i>sched_load_balance</i>\nshould be disabled in the top cpuset, and only some of the\nsmaller, child cpusets would have this flag enabled.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When doing\nthis, you don&rsquo;t usually want to leave any unpinned\nprocesses in the top cpuset that might use nontrivial\namounts of CPU, as such processes may be artificially\nconstrained to some subset of CPUs, depending on the\nparticulars of this flag setting in descendant cpusets. Even\nif such a process could use spare CPU cycles in some other\nCPUs, the kernel scheduler might not consider the\npossibility of load balancing that process to the underused\nCPU.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Of course,\nprocesses pinned to a particular CPU can be left in a cpuset\nthat disables <i>sched_load_balance</i> as those processes\naren&rsquo;t going anywhere else anyway.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Scheduler\nrelax domain level</b> <br>\nThe kernel scheduler performs immediate load balancing\nwhenever a CPU becomes free or another task becomes\nrunnable. This load balancing works to ensure that as many\nCPUs as possible are usefully employed running tasks. The\nkernel also performs periodic load balancing off the\nsoftware clock described in <a href=\"https://man.page/7/time\">time(7)</a>. The setting of\n<i>sched_relax_domain_level</i> applies only to immediate\nload balancing. Regardless of the\n<i>sched_relax_domain_level</i> setting, periodic load\nbalancing is attempted over all CPUs (unless disabled by\nturning off <i>sched_load_balance</i>.) In any case, of\ncourse, tasks will be scheduled to run only on CPUs allowed\nby their cpuset, as modified by <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>\nsystem calls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On small\nsystems, such as those with just a few CPUs, immediate load\nbalancing is useful to improve system interactivity and to\nminimize wasteful idle CPU cycles. But on large systems,\nattempting immediate load balancing across a large number of\nCPUs can be more costly than it is worth, depending on the\nparticular performance characteristics of the job mix and\nthe hardware.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The exact\nmeaning of the small integer values of\n<i>sched_relax_domain_level</i> will depend on internal\nimplementation details of the kernel scheduler code and on\nthe non-uniform architecture of the hardware. Both of these\nwill evolve over time and vary by system architecture and\nkernel version.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As of this\nwriting, when this capability was introduced in Linux\n2.6.26, on certain popular architectures, the positive\nvalues of <i>sched_relax_domain_level</i> have the following\nmeanings.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\"><b>(1)</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Perform immediate load balancing\nacross Hyper-Thread siblings on the same core.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(2)</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across other cores in\nthe same package.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(3)</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across other CPUs on\nthe same node or blade.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(4)</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across over several\n(implementation detail) nodes [On NUMA systems].</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>(5)</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Perform immediate load balancing across over all CPUs in\nsystem [On NUMA systems].</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>sched_relax_domain_level</i> value of zero (0) always\nmeans don&rsquo;t perform immediate load balancing, hence\nthat load balancing is done only periodically, not\nimmediately when a CPU becomes available or another task\nbecomes runnable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>sched_relax_domain_level</i> value of minus one (-1)\nalways means use the system default value. The system\ndefault value can vary by architecture and kernel version.\nThis system default value can be changed by kernel boot-time\n&quot;relax_domain_level=&quot; argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the case of\nmultiple overlapping cpusets which have conflicting\n<i>sched_relax_domain_level</i> values, then the highest\nsuch value applies to all CPUs in any of the overlapping\ncpusets. In such cases, the value <b>minus one (-1)</b> is\nthe lowest value, overridden by any other value, and the\nvalue <b>zero (0)</b> is the next lowest value.</p>\n\n<h2>FORMATS\n<a name=\"FORMATS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nformats are used to represent sets of CPUs and memory\nnodes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Mask\nformat</b> <br>\nThe <b>Mask Format</b> is used to represent CPU and\nmemory-node bit masks in the <i>/proc/&lt;pid&gt;/status</i>\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This format\ndisplays each 32-bit word in hexadecimal (using ASCII\ncharacters &quot;0&quot; - &quot;9&quot; and &quot;a&quot; -\n&quot;f&quot;); words are filled with leading zeros, if\nrequired. For masks longer than one word, a comma separator\nis used between words. Words are displayed in big-endian\norder, which has the most significant bit first. The hex\ndigits within a word are also in big-endian order.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The number of\n32-bit words displayed is the minimum number needed to\ndisplay all bits of the bit mask, based on the size of the\nbit mask.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Examples of the\n<b>Mask Format</b>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">00000001 # just\nbit 0 set <br>\n40000000,00000000,00000000 # just bit 94 set <br>\n00000001,00000000,00000000 # just bit 64 set <br>\n000000ff,00000000 # bits 32-39 set <br>\n00000000,000e3862 # 1,5,6,11-13,17-19 set</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A mask with\nbits 0, 1, 2, 4, 8, 16, 32, and 64 set displays as:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">00000001,00000001,00010117</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first\n&quot;1&quot; is for bit 64, the second for bit 32, the\nthird for bit 16, the fourth for bit 8, the fifth for bit 4,\nand the &quot;7&quot; is for bits 2, 1, and 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>List\nformat</b> <br>\nThe <b>List Format</b> for <i>cpus</i> and <i>mems</i> is a\ncomma-separated list of CPU or memory-node numbers and\nranges of numbers, in ASCII decimal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Examples of the\n<b>List Format</b>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">0-4,9 # bits 0,\n1, 2, 3, 4, and 9 set <br>\n0-2,7,12-14 # bits 0, 1, 2, 7, 12, 13, and 14 set</p>\n\n<h2>RULES\n<a name=\"RULES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nrules apply to each cpuset:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">Its CPUs and memory nodes must\nbe a (possibly equal) subset of its parent&rsquo;s.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>It can be marked <i>cpu_exclusive</i> only if its parent\nis.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>It can be marked <i>mem_exclusive</i> only if its parent\nis.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If it is <i>cpu_exclusive</i>, its CPUs may not overlap\nany sibling.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>If it is <i>memory_exclusive</i>, its memory nodes may\nnot overlap any sibling.</p></td></tr>\n</table>\n\n<h2>PERMISSIONS\n<a name=\"PERMISSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The permissions\nof a cpuset are determined by the permissions of the\ndirectories and pseudo-files in the cpuset filesystem,\nnormally mounted at <i>/dev/cpuset</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For instance, a\nprocess can put itself in some other cpuset (than its\ncurrent one) if it can write the <i>tasks</i> file for that\ncpuset. This requires execute permission on the encompassing\ndirectories and write permission on the <i>tasks</i>\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An additional\nconstraint is applied to requests to place some other\nprocess in a cpuset. One process may not attach another to a\ncpuset unless it would have permission to send that process\na signal (see <a href=\"https://man.page/2/kill\">kill(2)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process may\ncreate a child cpuset if it can access and write the parent\ncpuset directory. It can modify the CPUs or memory nodes in\na cpuset if it can access that cpuset&rsquo;s directory\n(execute permissions on the each of the parent directories)\nand write the corresponding <i>cpus</i> or <i>mems</i>\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is one\nminor difference between the manner in which these\npermissions are evaluated and the manner in which normal\nfilesystem operation permissions are evaluated. The kernel\ninterprets relative pathnames starting at a process&rsquo;s\ncurrent working directory. Even if one is operating on a\ncpuset file, relative pathnames are interpreted relative to\nthe process&rsquo;s current working directory, not relative\nto the process&rsquo;s current cpuset. The only ways that\ncpuset paths relative to a process&rsquo;s current cpuset\ncan be used are if either the process&rsquo;s current\nworking directory is its cpuset (it first did a <b>cd</b> or\n<a href=\"https://man.page/2/chdir\">chdir(2)</a> to its cpuset directory beneath\n<i>/dev/cpuset</i>, which is a bit unusual) or if some user\ncode converts the relative cpuset path to a full filesystem\npath.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In theory, this\nmeans that user code should specify cpusets using absolute\npathnames, which requires knowing the mount point of the\ncpuset filesystem (usually, but not necessarily,\n<i>/dev/cpuset</i>). In practice, all user level code that\nthis author is aware of simply assumes that if the cpuset\nfilesystem is mounted, then it is mounted at\n<i>/dev/cpuset</i>. Furthermore, it is common practice for\ncarefully written user code to verify the presence of the\npseudo-file <i>/dev/cpuset/tasks</i> in order to verify that\nthe cpuset pseudo-filesystem is currently mounted.</p>\n\n<h2>WARNINGS\n<a name=\"WARNINGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Enabling\nmemory_pressure</b> <br>\nBy default, the per-cpuset file\n<i>cpuset.memory_pressure</i> always contains zero (0).\nUnless this feature is enabled by writing &quot;1&quot; to\nthe pseudo-file\n<i>/dev/cpuset/cpuset.memory_pressure_enabled</i>, the\nkernel does not compute per-cpuset\n<i>memory_pressure</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Using the\necho command</b> <br>\nWhen using the <b>echo</b> command at the shell prompt to\nchange the values of cpuset files, beware that the built-in\n<b>echo</b> command in some shells does not display an error\nmessage if the <a href=\"https://man.page/2/write\">write(2)</a> system call fails. For\nexample, if the command:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">echo 19 &gt;\ncpuset.mems</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">failed because\nmemory node 19 was not allowed (perhaps the current system\ndoes not have a memory node 19), then the <b>echo</b>\ncommand might not display any error. It is better to use the\n<b>/bin/echo</b> external command to change cpuset file\nsettings, as this command will display <a href=\"https://man.page/2/write\">write(2)</a>\nerrors, as in the example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/bin/echo 19\n&gt; cpuset.mems <br>\n/bin/echo: write error: Invalid argument</p>\n\n<h2>EXCEPTIONS\n<a name=\"EXCEPTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Memory\nplacement</b> <br>\nNot all allocations of system memory are constrained by\ncpusets, for the following reasons.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If hot-plug\nfunctionality is used to remove all the CPUs that are\ncurrently assigned to a cpuset, then the kernel will\nautomatically update the <i>cpus_allowed</i> of all\nprocesses attached to CPUs in that cpuset to allow all CPUs.\nWhen memory hot-plug functionality for removing memory nodes\nis available, a similar exception is expected to apply there\nas well. In general, the kernel prefers to violate cpuset\nplacement, rather than starving a process that has had all\nits allowed CPUs or memory nodes taken offline. User code\nshould reconfigure cpusets to refer only to online CPUs and\nmemory nodes when using hot-plug to add or remove such\nresources.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A few\nkernel-critical, internal memory-allocation requests, marked\nGFP_ATOMIC, must be satisfied immediately. The kernel may\ndrop some request or malfunction if one of these allocations\nfail. If such a request cannot be satisfied within the\ncurrent process&rsquo;s cpuset, then we relax the cpuset,\nand look for memory anywhere we can find it. It&rsquo;s\nbetter to violate the cpuset than stress the kernel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Allocations of\nmemory requested by kernel drivers while processing an\ninterrupt lack any relevant process context, and are not\nconfined by cpusets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Renaming\ncpusets</b> <br>\nYou can use the <a href=\"https://man.page/2/rename\">rename(2)</a> system call to rename\ncpusets. Only simple renaming is supported; that is,\nchanging the name of a cpuset directory is permitted, but\nmoving a directory into a different directory is not\npermitted.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux\nkernel implementation of cpusets sets <i>errno</i> to\nspecify the reason for a failed system call affecting\ncpusets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The possible\n<i>errno</i> settings and their meaning when set on a failed\ncpuset call are as listed below.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>E2BIG</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Attempted a <a href=\"https://man.page/2/write\">write(2)</a> on a\nspecial cpuset file with a length larger than some\nkernel-determined upper limit on the length of such\nwrites.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> the process ID (PID) of a\nprocess to a cpuset <i>tasks</i> file when one lacks\npermission to move that process.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to add, using <a href=\"https://man.page/2/write\">write(2)</a>, a CPU or memory\nnode to a cpuset, when that CPU or memory node was not\nalready in its parent.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to set, using <a href=\"https://man.page/2/write\">write(2)</a>,\n<i>cpuset.cpu_exclusive</i> or <i>cpuset.mem_exclusive</i>\non a cpuset whose parent lacks the same setting.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a\n<i>cpuset.memory_pressure</i> file.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to create a file in a cpuset directory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove, using <a href=\"https://man.page/2/rmdir\">rmdir(2)</a>, a cpuset\nwith attached processes.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove, using <a href=\"https://man.page/2/rmdir\">rmdir(2)</a>, a cpuset\nwith child cpusets.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove a CPU or memory node from a cpuset\nthat is also in a child of that cpuset.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EEXIST</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to create, using <a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset\nthat already exists.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EEXIST</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/rename\">rename(2)</a> a cpuset to a name that\nalready exists.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/read\">read(2)</a> or <a href=\"https://man.page/2/write\">write(2)</a> a cpuset\nfile using a buffer that is outside the writing processes\naccessible address space.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to change a cpuset, using <a href=\"https://man.page/2/write\">write(2)</a>, in\na way that would violate a <i>cpu_exclusive</i> or\n<i>mem_exclusive</i> attribute of that cpuset or any of its\nsiblings.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> an empty <i>cpuset.cpus</i>\nor <i>cpuset.mems</i> list to a cpuset which has attached\nprocesses or child cpusets.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a <i>cpuset.cpus</i> or\n<i>cpuset.mems</i> list which included a range with the\nsecond number smaller than the first number.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a <i>cpuset.cpus</i> or\n<i>cpuset.mems</i> list which included an invalid character\nin the string.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a list to a\n<i>cpuset.cpus</i> file that did not include any online\nCPUs.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a list to a\n<i>cpuset.mems</i> file that did not include any online\nmemory nodes.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a list to a\n<i>cpuset.mems</i> file that included a node that held no\nmemory.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> a string to a cpuset\n<i>tasks</i> file that does not begin with an ASCII decimal\ninteger.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/rename\">rename(2)</a> a cpuset into a different\ndirectory.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENAMETOOLONG</b></p>\n\n<p style=\"margin-left:22%;\">Attempted to <a href=\"https://man.page/2/read\">read(2)</a> a\n<i>/proc/&lt;pid&gt;/cpuset</i> file for a cpuset path that\nis longer than the kernel page size.</p>\n\n<p style=\"margin-left:11%;\"><b>ENAMETOOLONG</b></p>\n\n<p style=\"margin-left:22%;\">Attempted to create, using\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset whose base directory name is\nlonger than 255 characters.</p>\n\n<p style=\"margin-left:11%;\"><b>ENAMETOOLONG</b></p>\n\n<p style=\"margin-left:22%;\">Attempted to create, using\n<a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset whose full pathname, including the\nmount point (typically &quot;/dev/cpuset/&quot;) prefix, is\nlonger than 4095 characters.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENODEV</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The cpuset was removed by another process at the same\ntime as a <a href=\"https://man.page/2/write\">write(2)</a> was attempted on one of the\npseudo-files in the cpuset directory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to create, using <a href=\"https://man.page/2/mkdir\">mkdir(2)</a>, a cpuset in\na parent cpuset that doesn&rsquo;t exist.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/access\">access(2)</a> or <a href=\"https://man.page/2/open\">open(2)</a> a\nnonexistent file in a cpuset directory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Insufficient memory is available within the kernel; can\noccur on a variety of system calls affecting cpusets, but\nonly if the system is extremely short of memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSPC</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> the process ID (PID) of a\nprocess to a cpuset <i>tasks</i> file when the cpuset had an\nempty <i>cpuset.cpus</i> or empty <i>cpuset.mems</i>\nsetting.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSPC</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> an empty <i>cpuset.cpus</i>\nor <i>cpuset.mems</i> setting to a cpuset that has tasks\nattached.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENOTDIR</b></p>\n\n<p style=\"margin-left:22%;\">Attempted to <a href=\"https://man.page/2/rename\">rename(2)</a> a\nnonexistent cpuset.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to remove a file from a cpuset directory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ERANGE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Specified a <i>cpuset.cpus</i> or <i>cpuset.mems</i>\nlist to the kernel which included a number too large for the\nkernel to set in its bit masks.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ESRCH</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Attempted to <a href=\"https://man.page/2/write\">write(2)</a> the process ID (PID) of a\nnonexistent process to a cpuset <i>tasks</i> file.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Cpusets\nappeared in version 2.6.12 of the Linux kernel.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Despite its\nname, the <i>pid</i> parameter is actually a thread ID, and\neach thread in a threaded group can be attached to a\ndifferent cpuset. The value returned from a call to\n<a href=\"https://man.page/2/gettid\">gettid(2)</a> can be passed in the argument\n<i>pid</i>.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>cpuset.memory_pressure</i>\ncpuset files can be opened for writing, creation, or\ntruncation, but then the <a href=\"https://man.page/2/write\">write(2)</a> fails with\n<i>errno</i> set to <b>EACCES</b>, and the creation and\ntruncation options on <a href=\"https://man.page/2/open\">open(2)</a> have no effect.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nexamples demonstrate querying and setting cpuset options\nusing shell commands.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Creating and\nattaching to a cpuset.</b> <br>\nTo create a new cpuset and attach the current command shell\nto it, the steps are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">mkdir /dev/cpuset (if not\nalready done)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>mount -t cpuset none /dev/cpuset (if not already\ndone)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Create the new cpuset using <a href=\"https://man.page/1/mkdir\">mkdir(1)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Assign CPUs and memory nodes to the new cpuset.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Attach the shell to the new cpuset.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nthe following sequence of commands will set up a cpuset\nnamed &quot;Charlie&quot;, containing just CPUs 2 and 3, and\nmemory node 1, and then attach the current shell to that\ncpuset.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>mkdir\n/dev/cpuset</b> <br>\n$ <b>mount -t cpuset cpuset /dev/cpuset</b> <br>\n$ <b>cd /dev/cpuset</b> <br>\n$ <b>mkdir Charlie</b> <br>\n$ <b>cd Charlie</b> <br>\n$ <b>/bin/echo 2-3 &gt; cpuset.cpus</b> <br>\n$ <b>/bin/echo 1 &gt; cpuset.mems</b> <br>\n$ <b>/bin/echo $$ &gt; tasks</b> <br>\n# The current shell is now running in cpuset Charlie <br>\n# The next line should display '/Charlie' <br>\n$ <b>cat /proc/self/cpuset</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Migrating a\njob to different memory nodes.</b> <br>\nTo migrate a job (the set of processes attached to a cpuset)\nto different CPUs and memory nodes in the system, including\nmoving the memory pages currently allocated to that job,\nperform the following steps.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Let&rsquo;s say we want to move\nthe job in cpuset <i>alpha</i> (CPUs 4&ndash;7 and memory\nnodes 2&ndash;3) to a new cpuset <i>beta</i> (CPUs\n16&ndash;19 and memory nodes 8&ndash;9).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>First create the new cpuset <i>beta</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Then allow CPUs 16&ndash;19 and memory nodes 8&ndash;9\nin <i>beta</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Then enable <i>memory_migration</i> in <i>beta</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5)</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Then move each process from <i>alpha</i> to\n<i>beta</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsequence of commands accomplishes this.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cd\n/dev/cpuset</b> <br>\n$ <b>mkdir beta</b> <br>\n$ <b>cd beta</b> <br>\n$ <b>/bin/echo 16-19 &gt; cpuset.cpus</b> <br>\n$ <b>/bin/echo 8-9 &gt; cpuset.mems</b> <br>\n$ <b>/bin/echo 1 &gt; cpuset.memory_migrate</b> <br>\n$ <b>while read i; do /bin/echo $i; done &lt; ../alpha/tasks\n&gt; tasks</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The above\nshould move any processes in <i>alpha</i> to <i>beta</i>,\nand any memory held by these processes on memory nodes\n2&ndash;3 to memory nodes 8&ndash;9, respectively.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notice that the\nlast step of the above sequence did not do:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cp\n../alpha/tasks tasks</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>while</i> loop, rather than the seemingly easier use of\nthe <a href=\"https://man.page/1/cp\">cp(1)</a> command, was necessary because only one\nprocess PID at a time may be written to the <i>tasks</i>\nfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The same effect\n(writing one PID at a time) as the <i>while</i> loop can be\naccomplished more efficiently, in fewer keystrokes and in\nsyntax that works on any shell, but alas more obscurely, by\nusing the <b>-u</b> (unbuffered) option of\n<a href=\"https://man.page/1/sed\">sed(1)</a>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>sed -un p\n&lt; ../alpha/tasks &gt; tasks</b></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/taskset\">taskset(1)</a>,\n<a href=\"https://man.page/2/get_mempolicy\">get_mempolicy(2)</a>, <a href=\"https://man.page/2/getcpu\">getcpu(2)</a>, <a href=\"https://man.page/2/mbind\">mbind(2)</a>,\n<a href=\"https://man.page/2/sched_getaffinity\">sched_getaffinity(2)</a>, <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>,\n<a href=\"https://man.page/2/sched_setscheduler\">sched_setscheduler(2)</a>, <a href=\"https://man.page/2/set_mempolicy\">set_mempolicy(2)</a>,\n<a href=\"https://man.page/3/CPU_SET\">CPU_SET(3)</a>, <a href=\"https://man.page/5/proc\">proc(5)</a>, <a href=\"https://man.page/7/cgroups\">cgroups(7)</a>,\n<a href=\"https://man.page/7/numa\">numa(7)</a>, <a href=\"https://man.page/7/sched\">sched(7)</a>, <b>migratepages</b>(8),\n<b>numactl</b>(8)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Documentation/admin-guide/cgroup-v1/cpusets.rst</i>\nin the Linux kernel source tree (or\n<i>Documentation/cgroup-v1/cpusets.txt</i> before Linux\n4.18, and <i>Documentation/cpusets.txt</i> before Linux\n2.6.29)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#FILES\">FILES</a>","<a href=\"#EXTENDED CAPABILITIES\">EXTENDED CAPABILITIES</a>","<a href=\"#FORMATS\">FORMATS</a>","<a href=\"#RULES\">RULES</a>","<a href=\"#PERMISSIONS\">PERMISSIONS</a>","<a href=\"#WARNINGS\">WARNINGS</a>","<a href=\"#EXCEPTIONS\">EXCEPTIONS</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}