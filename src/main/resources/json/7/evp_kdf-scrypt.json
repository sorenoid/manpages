{"name":"evp_kdf-scrypt","description":"EVP_KDF-SCRYPT - The scrypt EVP_KDF implementation","body":"\n\n<h1 align=\"center\">EVP_KDF-SCRYPT</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_KDF-SCRYPT\n- The scrypt EVP_KDF implementation</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Support for\ncomputing the <b>scrypt</b> password-based\n<small>KDF</small> through the <b><small>EVP_KDF</small></b>\n<small>API.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<small>EVP_KDF-SCRYPT</small> algorithm implements the\nscrypt password-based key derivation function, as described\nin <small>RFC 7914.</small> It is memory-hard in the sense\nthat it deliberately requires a significant amount of\n<small>RAM</small> for efficient computation. The intention\nof this is to render brute forcing of passwords on systems\nthat lack large amounts of main memory (such as GPUs or\nASICs) computationally infeasible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">scrypt provides\nthree work factors that can be customized: N, r and p. N,\nwhich has to be a positive power of two, is the general work\nfactor and scales <small>CPU</small> time in an\napproximately linear fashion. r is the block size of the\ninternally used hash function and p is the parallelization\nfactor. Both r and p need to be greater than zero. The\namount of <small>RAM</small> that scrypt requires for its\ncomputation is roughly (128 * N * r * p) bytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the original\npaper of Colin Percival (&quot;Stronger Key Derivation via\nSequential Memory-Hard Functions&quot;, 2009), the suggested\nvalues that give a computation time of less than 5 seconds\non a 2.5 GHz Intel Core 2 Duo are N = 2^20 = 1048576, r = 8,\np = 1. Consequently, the required amount of memory for this\ncomputation is roughly 1 GiB. On a more recent\n<small>CPU</small> (Intel i7-5930K at 3.5 GHz), this\ncomputation takes about 3 seconds. When N, r or p are not\nspecified, they default to 1048576, 8, and 1, respectively.\nThe maximum amount of <small>RAM</small> that may be used by\nscrypt defaults to 1025 MiB.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Identity</b>\n<br>\n&quot; <small>SCRYPT&quot;</small> is the name for this\nimplementation; it can be used with the\n<b>EVP_KDF_fetch()</b> function.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Supported\nparameters</b> <br>\nThe supported parameters are: <br>\n&quot;pass&quot; (\n<b><small>OSSL_KDF_PARAM_PASSWORD</small></b> ) &lt;octet\nstring&gt; <br>\n&quot;salt&quot; ( <b><small>OSSL_KDF_PARAM_SALT</small></b>\n) &lt;octet string&gt;</p>\n\n<p style=\"margin-left:17%;\">These parameters work as\ndescribed in &quot; <small>PARAMETERS&quot;</small> in\n<b><small>EVP_KDF</small></b> (3).</p>\n\n<p style=\"margin-left:11%;\">&quot;n&quot; (\n<b><small>OSSL_KDF_PARAM_SCRYPT_N</small></b> ) &lt;unsigned\ninteger&gt; <br>\n&quot;r&quot; (\n<b><small>OSSL_KDF_PARAM_SCRYPT_R</small></b> ) &lt;unsigned\ninteger&gt; <br>\n&quot;p&quot; (\n<b><small>OSSL_KDF_PARAM_SCRYPT_P</small></b> ) &lt;unsigned\ninteger&gt; <br>\n&quot;maxmem_bytes&quot; (\n<b><small>OSSL_KDF_PARAM_SCRYPT_MAXMEM</small></b> )\n&lt;unsigned integer&gt;</p>\n\n<p style=\"margin-left:17%;\">These parameters configure the\nscrypt work factors N, r, maxmem and p. Both N and\nmaxmem_bytes are parameters of type <b>uint64_t</b>. Both r\nand p are parameters of type <b>uint32_t</b>.</p>\n\n<p style=\"margin-left:11%;\">&quot;properties&quot; (\n<b><small>OSSL_KDF_PARAM_PROPERTIES</small></b> ) &lt;\n<small>UTF8</small> string&gt;</p>\n\n<p style=\"margin-left:17%;\">This can be used to set the\nproperty query string when fetching the fixed digest\ninternally. <small>NULL</small> is used if this value is not\nset.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A context for\nscrypt can be obtained by calling:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_KDF *kdf =\nEVP_KDF_fetch(NULL, &quot;SCRYPT&quot;, NULL); <br>\nEVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The output\nlength of an scrypt key derivation is specified via the\n&quot;keylen&quot; parameter to the <a href=\"https://man.page/3/EVP_KDF_derive\">EVP_KDF_derive(3)</a>\nfunction.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This example\nderives a 64-byte long test vector using scrypt with the\npassword &quot;password&quot;, salt &quot;NaCl&quot; and N =\n1024, r = 8, p = 16.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">EVP_KDF *kdf;\n<br>\nEVP_KDF_CTX *kctx; <br>\nunsigned char out[64]; <br>\nOSSL_PARAM params[6], *p = params; <br>\nkdf = EVP_KDF_fetch(NULL, &quot;SCRYPT&quot;, NULL); <br>\nkctx = EVP_KDF_CTX_new(kdf); <br>\nEVP_KDF_free(kdf); <br>\n*p++ =\nOSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD,\n<br>\n&quot;password&quot;, (size_t)8); <br>\n*p++ =\nOSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT, <br>\n&quot;NaCl&quot;, (size_t)4); <br>\n*p++ = OSSL_PARAM_construct_uint64(OSSL_KDF_PARAM_SCRYPT_N,\n(uint64_t)1024); <br>\n*p++ = OSSL_PARAM_construct_uint32(OSSL_KDF_PARAM_SCRYPT_R,\n(uint32_t)8); <br>\n*p++ = OSSL_PARAM_construct_uint32(OSSL_KDF_PARAM_SCRYPT_P,\n(uint32_t)16); <br>\n*p = OSSL_PARAM_construct_end(); <br>\nif (EVP_KDF_derive(kctx, out, sizeof(out), params) &lt;= 0)\n{ <br>\nerror(&quot;EVP_KDF_derive&quot;); <br>\n} <br>\n{ <br>\nconst unsigned char expected[sizeof(out)] = { <br>\n0xfd, 0xba, 0xbe, 0x1c, 0x9d, 0x34, 0x72, 0x00, <br>\n0x78, 0x56, 0xe7, 0x19, 0x0d, 0x01, 0xe9, 0xfe, <br>\n0x7c, 0x6a, 0xd7, 0xcb, 0xc8, 0x23, 0x78, 0x30, <br>\n0xe7, 0x73, 0x76, 0x63, 0x4b, 0x37, 0x31, 0x62, <br>\n0x2e, 0xaf, 0x30, 0xd9, 0x2e, 0x22, 0xa3, 0x88, <br>\n0x6f, 0xf1, 0x09, 0x27, 0x9d, 0x98, 0x30, 0xda, <br>\n0xc7, 0x27, 0xaf, 0xb9, 0x4a, 0x83, 0xee, 0x6d, <br>\n0x83, 0x60, 0xcb, 0xdf, 0xa2, 0xcc, 0x06, 0x40 <br>\n}; <br>\nassert(!memcmp(out, expected, sizeof(out))); <br>\n} <br>\nEVP_KDF_CTX_free(kctx);</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>RFC\n7914</small></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small><b>EVP_KDF</b></small>\n(3), <a href=\"https://man.page/3/EVP_KDF_CTX_new\">EVP_KDF_CTX_new(3)</a>, <a href=\"https://man.page/3/EVP_KDF_CTX_free\">EVP_KDF_CTX_free(3)</a>,\n<a href=\"https://man.page/3/EVP_KDF_CTX_set_params\">EVP_KDF_CTX_set_params(3)</a>, <a href=\"https://man.page/3/EVP_KDF_derive\">EVP_KDF_derive(3)</a>,\n&quot; <small>PARAMETERS&quot;</small> in\n<b><small>EVP_KDF</small></b> (3)</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n2017-2021 The OpenSSL Project Authors. All Rights\nReserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Licensed under\nthe Apache License 2.0 (the &quot;License&quot;). You may\nnot use this file except in compliance with the License. You\ncan obtain a copy in the file <small>LICENSE</small> in the\nsource distribution or at\n&lt;https://www.openssl.org/source/license.html&gt;.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":7}