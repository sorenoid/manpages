{"name":"pid_namespaces","description":"pid_namespaces\n- overview of Linux PID namespaces\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nFor an overview\nof namespaces, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.\n\nPID namespaces\nisolate the process ID number space, meaning that processes\nin different PID namespaces can have the same PID. PID\nnamespaces allow containers to provide functionality such as\nsuspending/resuming the set of processes in the container\nand migrating the container to a new host while the\nprocesses inside the container maintain the same PIDs.\n\nPIDs in a new\nPID namespace start at 1, somewhat like a standalone system,\nand calls to <a href=\"https://man.page/2/fork\">fork(2)</a>, <a href=\"https://man.page/2/vfork\">vfork(2)</a>, or\n<a href=\"https://man.page/2/clone\">clone(2)</a> will produce processes with PIDs that are\nunique within the namespace.\n\nUse of PID\nnamespaces requires a kernel that is configured with the\n<b>CONFIG_PID_NS</b> option.\n\n<b>The\nnamespace init process</b> <br>\nThe first process created in a new namespace (i.e., the\nprocess created using <a href=\"https://man.page/2/clone\">clone(2)</a> with the\n<b>CLONE_NEWPID</b> flag, or the first child created by a\nprocess after a call to <a href=\"https://man.page/2/unshare\">unshare(2)</a> using the\n<b>CLONE_NEWPID</b> flag) has the PID 1, and is the\n&quot;init&quot; process for the namespace (see\n<a href=\"https://man.page/1/init\">init(1)</a>). This process becomes the parent of any\nchild processes that are orphaned because a process that\nresides in this PID namespace terminated (see below for\nfurther details).\n\nIf the\n&quot;init&quot; process of a PID namespace terminates, the\nkernel terminates all of the processes in the namespace via\na <b>SIGKILL</b> signal. This behavior reflects the fact\nthat the &quot;init&quot; process is essential for the\ncorrect operation of a PID namespace. In this case, a\nsubsequent <a href=\"https://man.page/2/fork\">fork(2)</a> into this PID namespace fail with\nthe error <b>ENOMEM</b>; it is not possible to create a new\nprocess in a PID namespace whose &quot;init&quot; process\nhas terminated. Such scenarios can occur when, for example,\na process uses an open file descriptor for a\n<i>/proc/[pid]/ns/pid</i> file corresponding to a process\nthat was in a namespace to <a href=\"https://man.page/2/setns\">setns(2)</a> into that\nnamespace after the &quot;init&quot; process has terminated.\nAnother possible scenario can occur after a call to\n<a href=\"https://man.page/2/unshare\">unshare(2)</a>: if the first child subsequently created\nby a <a href=\"https://man.page/2/fork\">fork(2)</a> terminates, then subsequent calls to\n<a href=\"https://man.page/2/fork\">fork(2)</a> fail with <b>ENOMEM</b>.\n\nOnly signals\nfor which the &quot;init&quot; process has established a\nsignal handler can be sent to the &quot;init&quot; process\nby other members of the PID namespace. This restriction\napplies even to privileged processes, and prevents other\nmembers of the PID namespace from accidentally killing the\n&quot;init&quot; process.\n\nLikewise, a\nprocess in an ancestor namespace can&mdash;subject to the\nusual permission checks described in\n<a href=\"https://man.page/2/kill\">kill(2)</a>&mdash;send signals to the &quot;init&quot;\nprocess of a child PID namespace only if the\n&quot;init&quot; process has established a handler for that\nsignal. (Within the handler, the <i>siginfo_t si_pid</i>\nfield described in <a href=\"https://man.page/2/sigaction\">sigaction(2)</a> will be zero.)\n<b>SIGKILL</b> or <b>SIGSTOP</b> are treated exceptionally:\nthese signals are forcibly delivered when sent from an\nancestor PID namespace. Neither of these signals can be\ncaught by the &quot;init&quot; process, and so will result\nin the usual actions associated with those signals\n(respectively, terminating and stopping the process).\n\nStarting with\nLinux 3.4, the <a href=\"https://man.page/2/reboot\">reboot(2)</a> system call causes a signal\nto be sent to the namespace &quot;init&quot; process. See\n<a href=\"https://man.page/2/reboot\">reboot(2)</a> for more details.\n\n<b>Nesting PID\nnamespaces</b> <br>\nPID namespaces can be nested: each PID namespace has a\nparent, except for the initial (&quot;root&quot;) PID\nnamespace. The parent of a PID namespace is the PID\nnamespace of the process that created the namespace using\n<a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a>. PID namespaces thus\nform a tree, with all namespaces ultimately tracing their\nancestry to the root namespace. Since Linux 3.7, the kernel\nlimits the maximum nesting depth for PID namespaces to\n32.\n\nA process is\nvisible to other processes in its PID namespace, and to the\nprocesses in each direct ancestor PID namespace going back\nto the root PID namespace. In this context,\n&quot;visible&quot; means that one process can be the target\nof operations by another process using system calls that\nspecify a process ID. Conversely, the processes in a child\nPID namespace can&rsquo;t see processes in the parent and\nfurther removed ancestor namespaces. More succinctly: a\nprocess can see (e.g., send signals with <a href=\"https://man.page/2/kill\">kill(2)</a>, set\nnice values with <a href=\"https://man.page/2/setpriority\">setpriority(2)</a>, etc.) only processes\ncontained in its own PID namespace and in descendants of\nthat namespace.\n\nA process has\none process ID in each of the layers of the PID namespace\nhierarchy in which is visible, and walking back though each\ndirect ancestor namespace through to the root PID namespace.\nSystem calls that operate on process IDs always operate\nusing the process ID that is visible in the PID namespace of\nthe caller. A call to <a href=\"https://man.page/2/getpid\">getpid(2)</a> always returns the\nPID associated with the namespace in which the process was\ncreated.\n\nSome processes\nin a PID namespace may have parents that are outside of the\nnamespace. For example, the parent of the initial process in\nthe namespace (i.e., the <a href=\"https://man.page/1/init\">init(1)</a> process with PID 1)\nis necessarily in another namespace. Likewise, the direct\nchildren of a process that uses <a href=\"https://man.page/2/setns\">setns(2)</a> to cause its\nchildren to join a PID namespace are in a different PID\nnamespace from the caller of <a href=\"https://man.page/2/setns\">setns(2)</a>. Calls to\n<a href=\"https://man.page/2/getppid\">getppid(2)</a> for such processes return 0.\n\nWhile processes\nmay freely descend into child PID namespaces (e.g., using\n<a href=\"https://man.page/2/setns\">setns(2)</a> with a PID namespace file descriptor), they\nmay not move in the other direction. That is to say,\nprocesses may not enter any ancestor namespaces (parent,\ngrandparent, etc.). Changing PID namespaces is a one-way\noperation.\n\nThe\n<b>NS_GET_PARENT ioctl</b>(2) operation can be used to\ndiscover the parental relationship between PID namespaces;\nsee <a href=\"https://man.page/2/ioctl_ns\">ioctl_ns(2)</a>.\n\n<b>setns(2) and\nunshare(2) semantics</b> <br>\nCalls to <a href=\"https://man.page/2/setns\">setns(2)</a> that specify a PID namespace file\ndescriptor and calls to <a href=\"https://man.page/2/unshare\">unshare(2)</a> with the\n<b>CLONE_NEWPID</b> flag cause children subsequently created\nby the caller to be placed in a different PID namespace from\nthe caller. (Since Linux 4.12, that PID namespace is shown\nvia the <i>/proc/[pid]/ns/pid_for_children</i> file, as\ndescribed in <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.) These calls do not,\nhowever, change the PID namespace of the calling process,\nbecause doing so would change the caller&rsquo;s idea of its\nown PID (as reported by <b>getpid</b>()), which would break\nmany applications and libraries.\n\nTo put things\nanother way: a process&rsquo;s PID namespace membership is\ndetermined when the process is created and cannot be changed\nthereafter. Among other things, this means that the parental\nrelationship between processes mirrors the parental\nrelationship between PID namespaces: the parent of a process\nis either in the same namespace or resides in the immediate\nparent PID namespace.\n\nA process may\ncall <a href=\"https://man.page/2/unshare\">unshare(2)</a> with the <b>CLONE_NEWPID</b> flag\nonly once. After it has performed this operation, its\n<i>/proc/PID/ns/pid_for_children</i> symbolic link will be\nempty until the first child is created in the namespace.\n\n<b>Adoption of\norphaned children</b> <br>\nWhen a child process becomes orphaned, it is reparented to\nthe &quot;init&quot; process in the PID namespace of its\nparent (unless one of the nearer ancestors of the parent\nemployed the <a href=\"https://man.page/2/prctl\">prctl(2)</a> <b>PR_SET_CHILD_SUBREAPER</b>\ncommand to mark itself as the reaper of orphaned descendant\nprocesses). Note that because of the <a href=\"https://man.page/2/setns\">setns(2)</a> and\n<a href=\"https://man.page/2/unshare\">unshare(2)</a> semantics described above, this may be the\n&quot;init&quot; process in the PID namespace that is the\n<i>parent</i> of the child&rsquo;s PID namespace, rather\nthan the &quot;init&quot; process in the child&rsquo;s own\nPID namespace.\n\n\n<b>Compatibility\nof CLONE_NEWPID with other CLONE_* flags</b> <br>\nIn current versions of Linux, <b>CLONE_NEWPID</b>\ncan&rsquo;t be combined with <b>CLONE_THREAD</b>. Threads\nare required to be in the same PID namespace such that the\nthreads in a process can send signals to each other.\nSimilarly, it must be possible to see all of the threads of\na processes in the <a href=\"https://man.page/5/proc\">proc(5)</a> filesystem. Additionally,\nif two threads were in different PID namespaces, the process\nID of the process sending a signal could not be meaningfully\nencoded when a signal is sent (see the description of the\n<i>siginfo_t</i> type in <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>). Since this is\ncomputed when a signal is enqueued, a signal queue shared by\nprocesses in multiple PID namespaces would defeat that.\n\nIn earlier\nversions of Linux, <b>CLONE_NEWPID</b> was additionally\ndisallowed (failing with the error <b>EINVAL</b>) in\ncombination with <b>CLONE_SIGHAND</b> (before Linux 4.3) as\nwell as <b>CLONE_VM</b> (before Linux 3.12). The changes\nthat lifted these restrictions have also been ported to\nearlier stable kernels.\n\n<b>/proc and\nPID namespaces</b> <br>\nA <i>/proc</i> filesystem shows (in the <i>/proc/[pid]</i>\ndirectories) only processes visible in the PID namespace of\nthe process that performed the mount, even if the\n<i>/proc</i> filesystem is viewed from processes in other\nnamespaces.\n\nAfter creating\na new PID namespace, it is useful for the child to change\nits root directory and mount a new procfs instance at\n<i>/proc</i> so that tools such as <a href=\"https://man.page/1/ps\">ps(1)</a> work\ncorrectly. If a new mount namespace is simultaneously\ncreated by including <b>CLONE_NEWNS</b> in the <i>flags</i>\nargument of <a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a>, then it\nisn&rsquo;t necessary to change the root directory: a new\nprocfs instance can be mounted directly over\n<i>/proc</i>.\n\nFrom a shell,\nthe command to mount <i>/proc</i> is:\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ mount -t proc\nproc /proc\n\nCalling\n<a href=\"https://man.page/2/readlink\">readlink(2)</a> on the path <i>/proc/self</i> yields the\nprocess ID of the caller in the PID namespace of the procfs\nmount (i.e., the PID namespace of the process that mounted\nthe procfs). This can be useful for introspection purposes,\nwhen a process wants to discover its PID in other\nnamespaces.\n\n<b>/proc files\n<br>\n/proc/sys/kernel/ns_last_pid</b> (since Linux 3.3)\n\n<p style=\"margin-left:22%;\">This file (which is virtualized\nper PID namespace) displays the last PID that was allocated\nin this PID namespace. When the next PID is allocated, the\nkernel will search for the lowest unallocated PID that is\ngreater than this value, and when this file is subsequently\nread it will show that PID.\n\n<p style=\"margin-left:22%; margin-top: 1em\">This file is\nwritable by a process that has the <b>CAP_SYS_ADMIN</b> or\n(since Linux 5.9) <b>CAP_CHECKPOINT_RESTORE</b> capability\ninside the user namespace that owns the PID namespace. This\nmakes it possible to determine the PID that is allocated to\nthe next process that is created inside this PID\nnamespace.\n\n\n<b>Miscellaneous</b>\n<br>\nWhen a process ID is passed over a UNIX domain socket to a\nprocess in a different PID namespace (see the description of\n<b>SCM_CREDENTIALS</b> in <a href=\"https://man.page/7/unix\">unix(7)</a>), it is translated\ninto the corresponding PID value in the receiving\nprocess&rsquo;s PID namespace.\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\nNamespaces are\na Linux-specific feature.\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\nSee\n<a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a>.\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/2/clone\">clone(2)</a>,\n<a href=\"https://man.page/2/reboot\">reboot(2)</a>, <a href=\"https://man.page/2/setns\">setns(2)</a>, <a href=\"https://man.page/2/unshare\">unshare(2)</a>,\n<a href=\"https://man.page/5/proc\">proc(5)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/credentials\">credentials(7)</a>, <a href=\"https://man.page/7/mount_namespaces\">mount_namespaces(7)</a>,\n<a href=\"https://man.page/7/namespaces\">namespaces(7)</a>, <a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a>,\n<b>switch_root</b>(8)\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\nThis page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.","body":"\n\n<h1 align=\"center\">PID_NAMESPACES</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pid_namespaces\n- overview of Linux PID namespaces</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an overview\nof namespaces, see <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PID namespaces\nisolate the process ID number space, meaning that processes\nin different PID namespaces can have the same PID. PID\nnamespaces allow containers to provide functionality such as\nsuspending/resuming the set of processes in the container\nand migrating the container to a new host while the\nprocesses inside the container maintain the same PIDs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PIDs in a new\nPID namespace start at 1, somewhat like a standalone system,\nand calls to <a href=\"https://man.page/2/fork\">fork(2)</a>, <a href=\"https://man.page/2/vfork\">vfork(2)</a>, or\n<a href=\"https://man.page/2/clone\">clone(2)</a> will produce processes with PIDs that are\nunique within the namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Use of PID\nnamespaces requires a kernel that is configured with the\n<b>CONFIG_PID_NS</b> option.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\nnamespace init process</b> <br>\nThe first process created in a new namespace (i.e., the\nprocess created using <a href=\"https://man.page/2/clone\">clone(2)</a> with the\n<b>CLONE_NEWPID</b> flag, or the first child created by a\nprocess after a call to <a href=\"https://man.page/2/unshare\">unshare(2)</a> using the\n<b>CLONE_NEWPID</b> flag) has the PID 1, and is the\n&quot;init&quot; process for the namespace (see\n<a href=\"https://man.page/1/init\">init(1)</a>). This process becomes the parent of any\nchild processes that are orphaned because a process that\nresides in this PID namespace terminated (see below for\nfurther details).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n&quot;init&quot; process of a PID namespace terminates, the\nkernel terminates all of the processes in the namespace via\na <b>SIGKILL</b> signal. This behavior reflects the fact\nthat the &quot;init&quot; process is essential for the\ncorrect operation of a PID namespace. In this case, a\nsubsequent <a href=\"https://man.page/2/fork\">fork(2)</a> into this PID namespace fail with\nthe error <b>ENOMEM</b>; it is not possible to create a new\nprocess in a PID namespace whose &quot;init&quot; process\nhas terminated. Such scenarios can occur when, for example,\na process uses an open file descriptor for a\n<i>/proc/[pid]/ns/pid</i> file corresponding to a process\nthat was in a namespace to <a href=\"https://man.page/2/setns\">setns(2)</a> into that\nnamespace after the &quot;init&quot; process has terminated.\nAnother possible scenario can occur after a call to\n<a href=\"https://man.page/2/unshare\">unshare(2)</a>: if the first child subsequently created\nby a <a href=\"https://man.page/2/fork\">fork(2)</a> terminates, then subsequent calls to\n<a href=\"https://man.page/2/fork\">fork(2)</a> fail with <b>ENOMEM</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Only signals\nfor which the &quot;init&quot; process has established a\nsignal handler can be sent to the &quot;init&quot; process\nby other members of the PID namespace. This restriction\napplies even to privileged processes, and prevents other\nmembers of the PID namespace from accidentally killing the\n&quot;init&quot; process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Likewise, a\nprocess in an ancestor namespace can&mdash;subject to the\nusual permission checks described in\n<a href=\"https://man.page/2/kill\">kill(2)</a>&mdash;send signals to the &quot;init&quot;\nprocess of a child PID namespace only if the\n&quot;init&quot; process has established a handler for that\nsignal. (Within the handler, the <i>siginfo_t si_pid</i>\nfield described in <a href=\"https://man.page/2/sigaction\">sigaction(2)</a> will be zero.)\n<b>SIGKILL</b> or <b>SIGSTOP</b> are treated exceptionally:\nthese signals are forcibly delivered when sent from an\nancestor PID namespace. Neither of these signals can be\ncaught by the &quot;init&quot; process, and so will result\nin the usual actions associated with those signals\n(respectively, terminating and stopping the process).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting with\nLinux 3.4, the <a href=\"https://man.page/2/reboot\">reboot(2)</a> system call causes a signal\nto be sent to the namespace &quot;init&quot; process. See\n<a href=\"https://man.page/2/reboot\">reboot(2)</a> for more details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Nesting PID\nnamespaces</b> <br>\nPID namespaces can be nested: each PID namespace has a\nparent, except for the initial (&quot;root&quot;) PID\nnamespace. The parent of a PID namespace is the PID\nnamespace of the process that created the namespace using\n<a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a>. PID namespaces thus\nform a tree, with all namespaces ultimately tracing their\nancestry to the root namespace. Since Linux 3.7, the kernel\nlimits the maximum nesting depth for PID namespaces to\n32.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process is\nvisible to other processes in its PID namespace, and to the\nprocesses in each direct ancestor PID namespace going back\nto the root PID namespace. In this context,\n&quot;visible&quot; means that one process can be the target\nof operations by another process using system calls that\nspecify a process ID. Conversely, the processes in a child\nPID namespace can&rsquo;t see processes in the parent and\nfurther removed ancestor namespaces. More succinctly: a\nprocess can see (e.g., send signals with <a href=\"https://man.page/2/kill\">kill(2)</a>, set\nnice values with <a href=\"https://man.page/2/setpriority\">setpriority(2)</a>, etc.) only processes\ncontained in its own PID namespace and in descendants of\nthat namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process has\none process ID in each of the layers of the PID namespace\nhierarchy in which is visible, and walking back though each\ndirect ancestor namespace through to the root PID namespace.\nSystem calls that operate on process IDs always operate\nusing the process ID that is visible in the PID namespace of\nthe caller. A call to <a href=\"https://man.page/2/getpid\">getpid(2)</a> always returns the\nPID associated with the namespace in which the process was\ncreated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some processes\nin a PID namespace may have parents that are outside of the\nnamespace. For example, the parent of the initial process in\nthe namespace (i.e., the <a href=\"https://man.page/1/init\">init(1)</a> process with PID 1)\nis necessarily in another namespace. Likewise, the direct\nchildren of a process that uses <a href=\"https://man.page/2/setns\">setns(2)</a> to cause its\nchildren to join a PID namespace are in a different PID\nnamespace from the caller of <a href=\"https://man.page/2/setns\">setns(2)</a>. Calls to\n<a href=\"https://man.page/2/getppid\">getppid(2)</a> for such processes return 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">While processes\nmay freely descend into child PID namespaces (e.g., using\n<a href=\"https://man.page/2/setns\">setns(2)</a> with a PID namespace file descriptor), they\nmay not move in the other direction. That is to say,\nprocesses may not enter any ancestor namespaces (parent,\ngrandparent, etc.). Changing PID namespaces is a one-way\noperation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>NS_GET_PARENT ioctl</b>(2) operation can be used to\ndiscover the parental relationship between PID namespaces;\nsee <a href=\"https://man.page/2/ioctl_ns\">ioctl_ns(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>setns(2) and\nunshare(2) semantics</b> <br>\nCalls to <a href=\"https://man.page/2/setns\">setns(2)</a> that specify a PID namespace file\ndescriptor and calls to <a href=\"https://man.page/2/unshare\">unshare(2)</a> with the\n<b>CLONE_NEWPID</b> flag cause children subsequently created\nby the caller to be placed in a different PID namespace from\nthe caller. (Since Linux 4.12, that PID namespace is shown\nvia the <i>/proc/[pid]/ns/pid_for_children</i> file, as\ndescribed in <a href=\"https://man.page/7/namespaces\">namespaces(7)</a>.) These calls do not,\nhowever, change the PID namespace of the calling process,\nbecause doing so would change the caller&rsquo;s idea of its\nown PID (as reported by <b>getpid</b>()), which would break\nmany applications and libraries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To put things\nanother way: a process&rsquo;s PID namespace membership is\ndetermined when the process is created and cannot be changed\nthereafter. Among other things, this means that the parental\nrelationship between processes mirrors the parental\nrelationship between PID namespaces: the parent of a process\nis either in the same namespace or resides in the immediate\nparent PID namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A process may\ncall <a href=\"https://man.page/2/unshare\">unshare(2)</a> with the <b>CLONE_NEWPID</b> flag\nonly once. After it has performed this operation, its\n<i>/proc/PID/ns/pid_for_children</i> symbolic link will be\nempty until the first child is created in the namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Adoption of\norphaned children</b> <br>\nWhen a child process becomes orphaned, it is reparented to\nthe &quot;init&quot; process in the PID namespace of its\nparent (unless one of the nearer ancestors of the parent\nemployed the <a href=\"https://man.page/2/prctl\">prctl(2)</a> <b>PR_SET_CHILD_SUBREAPER</b>\ncommand to mark itself as the reaper of orphaned descendant\nprocesses). Note that because of the <a href=\"https://man.page/2/setns\">setns(2)</a> and\n<a href=\"https://man.page/2/unshare\">unshare(2)</a> semantics described above, this may be the\n&quot;init&quot; process in the PID namespace that is the\n<i>parent</i> of the child&rsquo;s PID namespace, rather\nthan the &quot;init&quot; process in the child&rsquo;s own\nPID namespace.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Compatibility\nof CLONE_NEWPID with other CLONE_* flags</b> <br>\nIn current versions of Linux, <b>CLONE_NEWPID</b>\ncan&rsquo;t be combined with <b>CLONE_THREAD</b>. Threads\nare required to be in the same PID namespace such that the\nthreads in a process can send signals to each other.\nSimilarly, it must be possible to see all of the threads of\na processes in the <a href=\"https://man.page/5/proc\">proc(5)</a> filesystem. Additionally,\nif two threads were in different PID namespaces, the process\nID of the process sending a signal could not be meaningfully\nencoded when a signal is sent (see the description of the\n<i>siginfo_t</i> type in <a href=\"https://man.page/2/sigaction\">sigaction(2)</a>). Since this is\ncomputed when a signal is enqueued, a signal queue shared by\nprocesses in multiple PID namespaces would defeat that.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In earlier\nversions of Linux, <b>CLONE_NEWPID</b> was additionally\ndisallowed (failing with the error <b>EINVAL</b>) in\ncombination with <b>CLONE_SIGHAND</b> (before Linux 4.3) as\nwell as <b>CLONE_VM</b> (before Linux 3.12). The changes\nthat lifted these restrictions have also been ported to\nearlier stable kernels.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc and\nPID namespaces</b> <br>\nA <i>/proc</i> filesystem shows (in the <i>/proc/[pid]</i>\ndirectories) only processes visible in the PID namespace of\nthe process that performed the mount, even if the\n<i>/proc</i> filesystem is viewed from processes in other\nnamespaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After creating\na new PID namespace, it is useful for the child to change\nits root directory and mount a new procfs instance at\n<i>/proc</i> so that tools such as <a href=\"https://man.page/1/ps\">ps(1)</a> work\ncorrectly. If a new mount namespace is simultaneously\ncreated by including <b>CLONE_NEWNS</b> in the <i>flags</i>\nargument of <a href=\"https://man.page/2/clone\">clone(2)</a> or <a href=\"https://man.page/2/unshare\">unshare(2)</a>, then it\nisn&rsquo;t necessary to change the root directory: a new\nprocfs instance can be mounted directly over\n<i>/proc</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From a shell,\nthe command to mount <i>/proc</i> is:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ mount -t proc\nproc /proc</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Calling\n<a href=\"https://man.page/2/readlink\">readlink(2)</a> on the path <i>/proc/self</i> yields the\nprocess ID of the caller in the PID namespace of the procfs\nmount (i.e., the PID namespace of the process that mounted\nthe procfs). This can be useful for introspection purposes,\nwhen a process wants to discover its PID in other\nnamespaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/proc files\n<br>\n/proc/sys/kernel/ns_last_pid</b> (since Linux 3.3)</p>\n\n<p style=\"margin-left:22%;\">This file (which is virtualized\nper PID namespace) displays the last PID that was allocated\nin this PID namespace. When the next PID is allocated, the\nkernel will search for the lowest unallocated PID that is\ngreater than this value, and when this file is subsequently\nread it will show that PID.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This file is\nwritable by a process that has the <b>CAP_SYS_ADMIN</b> or\n(since Linux 5.9) <b>CAP_CHECKPOINT_RESTORE</b> capability\ninside the user namespace that owns the PID namespace. This\nmakes it possible to determine the PID that is allocated to\nthe next process that is created inside this PID\nnamespace.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Miscellaneous</b>\n<br>\nWhen a process ID is passed over a UNIX domain socket to a\nprocess in a different PID namespace (see the description of\n<b>SCM_CREDENTIALS</b> in <a href=\"https://man.page/7/unix\">unix(7)</a>), it is translated\ninto the corresponding PID value in the receiving\nprocess&rsquo;s PID namespace.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Namespaces are\na Linux-specific feature.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/clone\">clone(2)</a>,\n<a href=\"https://man.page/2/reboot\">reboot(2)</a>, <a href=\"https://man.page/2/setns\">setns(2)</a>, <a href=\"https://man.page/2/unshare\">unshare(2)</a>,\n<a href=\"https://man.page/5/proc\">proc(5)</a>, <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>,\n<a href=\"https://man.page/7/credentials\">credentials(7)</a>, <a href=\"https://man.page/7/mount_namespaces\">mount_namespaces(7)</a>,\n<a href=\"https://man.page/7/namespaces\">namespaces(7)</a>, <a href=\"https://man.page/7/user_namespaces\">user_namespaces(7)</a>,\n<b>switch_root</b>(8)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":7}