{"name":"getaddrinfo","body":"\n\n<h1 align=\"center\">GETADDRINFO</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">getaddrinfo,\nfreeaddrinfo, gai_strerror - network address and service\ntranslation</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/types.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;netdb.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ngetaddrinfo(const char *</b><i>node</i><b>, const char\n*</b><i>service</i><b>, <br>\nconst struct addrinfo *</b><i>hints</i><b>, <br>\nstruct addrinfo **</b><i>res</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nfreeaddrinfo(struct addrinfo *</b><i>res</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>const char\n*gai_strerror(int</b> <i>errcode</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>getaddrinfo</b>(),\n<b>freeaddrinfo</b>(), <b>gai_strerror</b>(): <br>\nSince glibc 2.22: _POSIX_C_SOURCE &gt;= 200112L <br>\nGlibc 2.21 and earlier: _POSIX_C_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given\n<i>node</i> and <i>service</i>, which identify an Internet\nhost and a service, <b>getaddrinfo</b>() returns one or more\n<i>addrinfo</i> structures, each of which contains an\nInternet address that can be specified in a call to\n<a href=\"https://man.page/2/bind\">bind(2)</a> or <a href=\"https://man.page/2/connect\">connect(2)</a>. The\n<b>getaddrinfo</b>() function combines the functionality\nprovided by the <a href=\"https://man.page/3/gethostbyname\">gethostbyname(3)</a> and\n<a href=\"https://man.page/3/getservbyname\">getservbyname(3)</a> functions into a single interface,\nbut unlike the latter functions, <b>getaddrinfo</b>() is\nreentrant and allows programs to eliminate IPv4-versus-IPv6\ndependencies.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>addrinfo</i> structure used by <b>getaddrinfo</b>()\ncontains the following fields:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct addrinfo\n{ <br>\nint ai_flags; <br>\nint ai_family; <br>\nint ai_socktype; <br>\nint ai_protocol; <br>\nsocklen_t ai_addrlen; <br>\nstruct sockaddr *ai_addr; <br>\nchar *ai_canonname; <br>\nstruct addrinfo *ai_next; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>hints</i> argument points to an <i>addrinfo</i> structure\nthat specifies criteria for selecting the socket address\nstructures returned in the list pointed to by <i>res</i>. If\n<i>hints</i> is not NULL it points to an <i>addrinfo</i>\nstructure whose <i>ai_family</i>, <i>ai_socktype</i>, and\n<i>ai_protocol</i> specify criteria that limit the set of\nsocket addresses returned by <b>getaddrinfo</b>(), as\nfollows: <i><br>\nai_family</i></p>\n\n<p style=\"margin-left:22%;\">This field specifies the\ndesired address family for the returned addresses. Valid\nvalues for this field include <b>AF_INET</b> and\n<b>AF_INET6</b>. The value <b>AF_UNSPEC</b> indicates that\n<b>getaddrinfo</b>() should return socket addresses for any\naddress family (either IPv4 or IPv6, for example) that can\nbe used with <i>node</i> and <i>service</i>.</p>\n\n<p style=\"margin-left:11%;\"><i>ai_socktype</i></p>\n\n<p style=\"margin-left:22%;\">This field specifies the\npreferred socket type, for example <b>SOCK_STREAM</b> or\n<b>SOCK_DGRAM</b>. Specifying 0 in this field indicates that\nsocket addresses of any type can be returned by\n<b>getaddrinfo</b>().</p>\n\n<p style=\"margin-left:11%;\"><i>ai_protocol</i></p>\n\n<p style=\"margin-left:22%;\">This field specifies the\nprotocol for the returned socket addresses. Specifying 0 in\nthis field indicates that socket addresses with any protocol\ncan be returned by <b>getaddrinfo</b>().</p>\n\n<p style=\"margin-left:11%;\"><i>ai_flags</i></p>\n\n<p style=\"margin-left:22%;\">This field specifies additional\noptions, described below. Multiple flags are specified by\nbitwise OR-ing them together.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All the other\nfields in the structure pointed to by <i>hints</i> must\ncontain either 0 or a null pointer, as appropriate.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Specifying\n<i>hints</i> as NULL is equivalent to setting\n<i>ai_socktype</i> and <i>ai_protocol</i> to 0;\n<i>ai_family</i> to <b>AF_UNSPEC</b>; and <i>ai_flags</i> to\n<b>(AI_V4MAPPED&nbsp;|&nbsp;AI_ADDRCONFIG)</b>. (POSIX\nspecifies different defaults for <i>ai_flags</i>; see\nNOTES.) <i>node</i> specifies either a numerical network\naddress (for IPv4, numbers-and-dots notation as supported by\n<a href=\"https://man.page/3/inet_aton\">inet_aton(3)</a>; for IPv6, hexadecimal string format as\nsupported by <a href=\"https://man.page/3/inet_pton\">inet_pton(3)</a>), or a network hostname,\nwhose network addresses are looked up and resolved. If\n<i>hints.ai_flags</i> contains the <b>AI_NUMERICHOST</b>\nflag, then <i>node</i> must be a numerical network address.\nThe <b>AI_NUMERICHOST</b> flag suppresses any potentially\nlengthy network host address lookups.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>AI_PASSIVE</b> flag is specified in\n<i>hints.ai_flags</i>, and <i>node</i> is NULL, then the\nreturned socket addresses will be suitable for\n<a href=\"https://man.page/2/bind\">bind(2)</a>ing a socket that will <a href=\"https://man.page/2/accept\">accept(2)</a>\nconnections. The returned socket address will contain the\n&quot;wildcard address&quot; (<b>INADDR_ANY</b> for IPv4\naddresses, <b>IN6ADDR_ANY_INIT</b> for IPv6 address). The\nwildcard address is used by applications (typically servers)\nthat intend to accept connections on any of the host&rsquo;s\nnetwork addresses. If <i>node</i> is not NULL, then the\n<b>AI_PASSIVE</b> flag is ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>AI_PASSIVE</b> flag is not set in <i>hints.ai_flags</i>,\nthen the returned socket addresses will be suitable for use\nwith <a href=\"https://man.page/2/connect\">connect(2)</a>, <a href=\"https://man.page/2/sendto\">sendto(2)</a>, or\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>. If <i>node</i> is NULL, then the network\naddress will be set to the loopback interface address\n(<b>INADDR_LOOPBACK</b> for IPv4 addresses,\n<b>IN6ADDR_LOOPBACK_INIT</b> for IPv6 address); this is used\nby applications that intend to communicate with peers\nrunning on the same host.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>service</i>\nsets the port in each returned address structure. If this\nargument is a service name (see <a href=\"https://man.page/5/services\">services(5)</a>), it is\ntranslated to the corresponding port number. This argument\ncan also be specified as a decimal number, which is simply\nconverted to binary. If <i>service</i> is NULL, then the\nport number of the returned socket addresses will be left\nuninitialized. If <b>AI_NUMERICSERV</b> is specified in\n<i>hints.ai_flags</i> and <i>service</i> is not NULL, then\n<i>service</i> must point to a string containing a numeric\nport number. This flag is used to inhibit the invocation of\na name resolution service in cases where it is known not to\nbe required.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Either\n<i>node</i> or <i>service</i>, but not both, may be\nNULL.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>getaddrinfo</b>() function allocates and initializes a\nlinked list of <i>addrinfo</i> structures, one for each\nnetwork address that matches <i>node</i> and <i>service</i>,\nsubject to any restrictions imposed by <i>hints</i>, and\nreturns a pointer to the start of the list in <i>res</i>.\nThe items in the linked list are linked by the\n<i>ai_next</i> field.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are\nseveral reasons why the linked list may have more than one\n<i>addrinfo</i> structure, including: the network host is\nmultihomed, accessible over multiple protocols (e.g., both\n<b>AF_INET</b> and <b>AF_INET6</b>); or the same service is\navailable from multiple socket types (one <b>SOCK_STREAM</b>\naddress and another <b>SOCK_DGRAM</b> address, for example).\nNormally, the application should try using the addresses in\nthe order in which they are returned. The sorting function\nused within <b>getaddrinfo</b>() is defined in\nRFC&nbsp;3484; the order can be tweaked for a particular\nsystem by editing <i>/etc/gai.conf</i> (available since\nglibc 2.5).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>hints.ai_flags</i> includes the <b>AI_CANONNAME</b> flag,\nthen the <i>ai_canonname</i> field of the first of the\n<i>addrinfo</i> structures in the returned list is set to\npoint to the official name of the host.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The remaining\nfields of each returned <i>addrinfo</i> structure are\ninitialized as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>The <i>ai_family</i>, <i>ai_socktype</i>, and\n<i>ai_protocol</i> fields return the socket creation\nparameters (i.e., these fields have the same meaning as the\ncorresponding arguments of <a href=\"https://man.page/2/socket\">socket(2)</a>). For example,\n<i>ai_family</i> might return <b>AF_INET</b> or\n<b>AF_INET6</b>; <i>ai_socktype</i> might return\n<b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>; and\n<i>ai_protocol</i> returns the protocol for the socket.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>A pointer to the socket address is placed in the\n<i>ai_addr</i> field, and the length of the socket address,\nin bytes, is placed in the <i>ai_addrlen</i> field.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>hints.ai_flags</i> includes the <b>AI_ADDRCONFIG</b>\nflag, then IPv4 addresses are returned in the list pointed\nto by <i>res</i> only if the local system has at least one\nIPv4 address configured, and IPv6 addresses are returned\nonly if the local system has at least one IPv6 address\nconfigured. The loopback address is not considered for this\ncase as valid as a configured address. This flag is useful\non, for example, IPv4-only systems, to ensure that\n<b>getaddrinfo</b>() does not return IPv6 socket addresses\nthat would always fail in <a href=\"https://man.page/2/connect\">connect(2)</a> or\n<a href=\"https://man.page/2/bind\">bind(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>hints.ai_flags</i> specifies the <b>AI_V4MAPPED</b> flag,\nand <i>hints.ai_family</i> was specified as <b>AF_INET6</b>,\nand no matching IPv6 addresses could be found, then return\nIPv4-mapped IPv6 addresses in the list pointed to by\n<i>res</i>. If both <b>AI_V4MAPPED</b> and <b>AI_ALL</b> are\nspecified in <i>hints.ai_flags</i>, then return both IPv6\nand IPv4-mapped IPv6 addresses in the list pointed to by\n<i>res</i>. <b>AI_ALL</b> is ignored if <b>AI_V4MAPPED</b>\nis not also specified.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>freeaddrinfo</b>() function frees the memory that was\nallocated for the dynamically allocated linked list\n<i>res</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Extensions\nto getaddrinfo() for Internationalized Domain Names</b> <br>\nStarting with glibc 2.3.4, <b>getaddrinfo</b>() has been\nextended to selectively allow the incoming and outgoing\nhostnames to be transparently converted to and from the\nInternationalized Domain Name (IDN) format (see RFC 3490,\n<i>Internationalizing Domain Names in Applications\n(IDNA)</i>). Four new flags are defined:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>AI_IDN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">If this flag is specified, then\nthe node name given in <i>node</i> is converted to IDN\nformat if necessary. The source encoding is that of the\ncurrent locale.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the input\nname contains non-ASCII characters, then the IDN encoding is\nused. Those parts of the node name (delimited by dots) that\ncontain non-ASCII characters are encoded using ASCII\nCompatible Encoding (ACE) before being passed to the name\nresolution functions.</p>\n\n<p style=\"margin-left:11%;\"><b>AI_CANONIDN</b></p>\n\n<p style=\"margin-left:22%;\">After a successful name lookup,\nand if the <b>AI_CANONNAME</b> flag was specified,\n<b>getaddrinfo</b>() will return the canonical name of the\nnode corresponding to the <i>addrinfo</i> structure value\npassed back. The return value is an exact copy of the value\nreturned by the name resolution function.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the name is\nencoded using ACE, then it will contain the <i>xn--</i>\nprefix for one or more components of the name. To convert\nthese components into a readable form the <b>AI_CANONIDN</b>\nflag can be passed in addition to <b>AI_CANONNAME</b>. The\nresulting string is encoded using the current locale&rsquo;s\nencoding.</p>\n\n\n<p style=\"margin-left:11%;\"><b>AI_IDN_ALLOW_UNASSIGNED</b>,\n<b>AI_IDN_USE_STD3_ASCII_RULES</b></p>\n\n<p style=\"margin-left:22%;\">Setting these flags will enable\nthe IDNA_ALLOW_UNASSIGNED (allow unassigned Unicode code\npoints) and IDNA_USE_STD3_ASCII_RULES (check output to make\nsure it is a STD3 conforming hostname) flags respectively to\nbe used in the IDNA handling.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>getaddrinfo</b>()\nreturns 0 if it succeeds, or one of the following nonzero\nerror codes: <b><br>\nEAI_ADDRFAMILY</b></p>\n\n<p style=\"margin-left:22%;\">The specified network host does\nnot have any network addresses in the requested address\nfamily.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_AGAIN</b></p>\n\n<p style=\"margin-left:22%;\">The name server returned a\ntemporary failure indication. Try again later.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_BADFLAGS</b></p>\n\n<p style=\"margin-left:22%;\"><i>hints.ai_flags</i> contains\ninvalid flags; or, <i>hints.ai_flags</i> included\n<b>AI_CANONNAME</b> and <i>name</i> was NULL.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_FAIL</b></p>\n\n<p style=\"margin-left:22%;\">The name server returned a\npermanent failure indication.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_FAMILY</b></p>\n\n<p style=\"margin-left:22%;\">The requested address family is\nnot supported.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_MEMORY</b></p>\n\n<p style=\"margin-left:22%;\">Out of memory.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_NODATA</b></p>\n\n<p style=\"margin-left:22%;\">The specified network host\nexists, but does not have any network addresses defined.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_NONAME</b></p>\n\n<p style=\"margin-left:22%;\">The <i>node</i> or\n<i>service</i> is not known; or both <i>node</i> and\n<i>service</i> are NULL; or <b>AI_NUMERICSERV</b> was\nspecified in <i>hints.ai_flags</i> and <i>service</i> was\nnot a numeric port-number string.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_SERVICE</b></p>\n\n<p style=\"margin-left:22%;\">The requested service is not\navailable for the requested socket type. It may be available\nthrough another socket type. For example, this error could\noccur if <i>service</i> was &quot;shell&quot; (a service\navailable only on stream sockets), and either\n<i>hints.ai_protocol</i> was <b>IPPROTO_UDP</b>, or\n<i>hints.ai_socktype</i> was <b>SOCK_DGRAM</b>; or the error\ncould occur if <i>service</i> was not NULL, and\n<i>hints.ai_socktype</i> was <b>SOCK_RAW</b> (a socket type\nthat does not support the concept of services).</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_SOCKTYPE</b></p>\n\n<p style=\"margin-left:22%;\">The requested socket type is\nnot supported. This could occur, for example, if\n<i>hints.ai_socktype</i> and <i>hints.ai_protocol</i> are\ninconsistent (e.g., <b>SOCK_DGRAM</b> and\n<b>IPPROTO_TCP</b>, respectively).</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_SYSTEM</b></p>\n\n<p style=\"margin-left:22%;\">Other system error, check\n<i>errno</i> for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>gai_strerror</b>() function translates these error codes\nto a human readable string, suitable for error\nreporting.</p>\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>/etc/gai.conf</i></p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3293531.png\" alt=\"Image grohtml-3293531.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008. The <b>getaddrinfo</b>() function is\ndocumented in RFC&nbsp;2553.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>getaddrinfo</b>()\nsupports the <i>address</i><b>%</b><i>scope-id</i> notation\nfor specifying the IPv6 scope-ID.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>AI_ADDRCONFIG</b>,\n<b>AI_ALL</b>, and <b>AI_V4MAPPED</b> are available since\nglibc 2.3.3. <b>AI_NUMERICSERV</b> is available since glibc\n2.3.4.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">According to\nPOSIX.1, specifying <i>hints</i> as NULL should cause\n<i>ai_flags</i> to be assumed as 0. The GNU C library\ninstead assumes a value of\n<b>(AI_V4MAPPED&nbsp;|&nbsp;AI_ADDRCONFIG)</b> for this\ncase, since this value is considered an improvement on the\nspecification.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprograms demonstrate the use of <b>getaddrinfo</b>(),\n<b>gai_strerror</b>(), <b>freeaddrinfo</b>(), and\n<a href=\"https://man.page/3/getnameinfo\">getnameinfo(3)</a>. The programs are an echo server and\nclient for UDP datagrams.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Server\nprogram</b> <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;netdb.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nBUF_SIZE 500</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct addrinfo hints; <br>\nstruct addrinfo *result, *rp; <br>\nint sfd, s; <br>\nstruct sockaddr_storage peer_addr; <br>\nsocklen_t peer_addr_len; <br>\nssize_t nread; <br>\nchar buf[BUF_SIZE];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Usage: %s port\\n&quot;, argv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(&amp;hints,\n0, sizeof(hints)); <br>\nhints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */ <br>\nhints.ai_socktype = SOCK_DGRAM; /* Datagram socket */ <br>\nhints.ai_flags = AI_PASSIVE; /* For wildcard IP address */\n<br>\nhints.ai_protocol = 0; /* Any protocol */ <br>\nhints.ai_canonname = NULL; <br>\nhints.ai_addr = NULL; <br>\nhints.ai_next = NULL;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\ngetaddrinfo(NULL, argv[1], &amp;hints, &amp;result); <br>\nif (s != 0) { <br>\nfprintf(stderr, &quot;getaddrinfo: %s\\n&quot;,\ngai_strerror(s)); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/*\ngetaddrinfo() returns a list of address structures. <br>\nTry each address until we successfully bind(2). <br>\nIf socket(2) (or bind(2)) fails, we (close the socket <br>\nand) try the next address. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (rp =\nresult; rp != NULL; rp = rp-&gt;ai_next) { <br>\nsfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, <br>\nrp-&gt;ai_protocol); <br>\nif (sfd == -1) <br>\ncontinue;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (bind(sfd,\nrp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0) <br>\nbreak; /* Success */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(sfd);\n<br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">freeaddrinfo(result);\n/* No longer needed */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (rp == NULL)\n{ /* No address succeeded */ <br>\nfprintf(stderr, &quot;Could not bind\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read\ndatagrams and echo them back to sender */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { <br>\npeer_addr_len = sizeof(peer_addr); <br>\nnread = recvfrom(sfd, buf, BUF_SIZE, 0, <br>\n(struct sockaddr *) &amp;peer_addr, &amp;peer_addr_len);\n<br>\nif (nread == -1) <br>\ncontinue; /* Ignore failed request */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">char\nhost[NI_MAXHOST], service[NI_MAXSERV];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\ngetnameinfo((struct sockaddr *) &amp;peer_addr, <br>\npeer_addr_len, host, NI_MAXHOST, <br>\nservice, NI_MAXSERV, NI_NUMERICSERV); <br>\nif (s == 0) <br>\nprintf(&quot;Received %zd bytes from %s:%s\\n&quot;, <br>\nnread, host, service); <br>\nelse <br>\nfprintf(stderr, &quot;getnameinfo: %s\\n&quot;,\ngai_strerror(s));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (sendto(sfd,\nbuf, nread, 0, <br>\n(struct sockaddr *) &amp;peer_addr, <br>\npeer_addr_len) != nread) <br>\nfprintf(stderr, &quot;Error sending response\\n&quot;); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Client\nprogram</b> <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;sys/socket.h&gt; <br>\n#include &lt;netdb.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nBUF_SIZE 500</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nstruct addrinfo hints; <br>\nstruct addrinfo *result, *rp; <br>\nint sfd, s; <br>\nsize_t len; <br>\nssize_t nread; <br>\nchar buf[BUF_SIZE];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n3) { <br>\nfprintf(stderr, &quot;Usage: %s host port msg...\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Obtain\naddress(es) matching host/port */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memset(&amp;hints,\n0, sizeof(hints)); <br>\nhints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */ <br>\nhints.ai_socktype = SOCK_DGRAM; /* Datagram socket */ <br>\nhints.ai_flags = 0; <br>\nhints.ai_protocol = 0; /* Any protocol */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\ngetaddrinfo(argv[1], argv[2], &amp;hints, &amp;result); <br>\nif (s != 0) { <br>\nfprintf(stderr, &quot;getaddrinfo: %s\\n&quot;,\ngai_strerror(s)); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/*\ngetaddrinfo() returns a list of address structures. <br>\nTry each address until we successfully connect(2). <br>\nIf socket(2) (or connect(2)) fails, we (close the socket\n<br>\nand) try the next address. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (rp =\nresult; rp != NULL; rp = rp-&gt;ai_next) { <br>\nsfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, <br>\nrp-&gt;ai_protocol); <br>\nif (sfd == -1) <br>\ncontinue;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(connect(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) != -1) <br>\nbreak; /* Success */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close(sfd);\n<br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">freeaddrinfo(result);\n/* No longer needed */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (rp == NULL)\n{ /* No address succeeded */ <br>\nfprintf(stderr, &quot;Could not connect\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Send\nremaining command-line arguments as separate <br>\ndatagrams, and read responses from server */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 3;\nj &lt; argc; j++) { <br>\nlen = strlen(argv[j]) + 1; <br>\n/* +1 for terminating null byte */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (len &gt;\nBUF_SIZE) { <br>\nfprintf(stderr, <br>\n&quot;Ignoring long message in argument %d\\n&quot;, j); <br>\ncontinue; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (write(sfd,\nargv[j], len) != len) { <br>\nfprintf(stderr, &quot;partial/failed write\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nread =\nread(sfd, buf, BUF_SIZE); <br>\nif (nread == -1) { <br>\nperror(&quot;read&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Received\n%zd bytes: %s\\n&quot;, nread, buf); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/getaddrinfo_a\">getaddrinfo_a(3)</a>,\n<a href=\"https://man.page/3/gethostbyname\">gethostbyname(3)</a>, <a href=\"https://man.page/3/getnameinfo\">getnameinfo(3)</a>,\n<a href=\"https://man.page/3/inet\">inet(3)</a>, <b>gai.conf</b>(5), <a href=\"https://man.page/7/hostname\">hostname(7)</a>,\n<a href=\"https://man.page/7/ip\">ip(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#FILES\">FILES</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}