{"name":"html::parser","description":"HTML::Parser -\nHTML parser class","body":"\n\n<h1 align=\"center\">HTML::Parser</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Parser -\nHTML parser class</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use strict;\n<br>\nuse warnings; <br>\nuse HTML::Parser (); <br>\n# Create parser object <br>\nmy $p = HTML::Parser-&gt;new( <br>\napi_version =&gt; 3, <br>\nstart_h =&gt; [\\&amp;start, &quot;tagname, attr&quot;], <br>\nend_h =&gt; [\\&amp;end, &quot;tagname&quot;], <br>\nmarked_sections =&gt; 1, <br>\n); <br>\n# Parse document text chunk by chunk <br>\n$p-&gt;parse($chunk1); <br>\n$p-&gt;parse($chunk2); <br>\n# ... <br>\n# signal end of document <br>\n$p-&gt;eof; <br>\n# Parse directly from file <br>\n$p-&gt;parse_file(&quot;foo.html&quot;); <br>\n# or <br>\nopen(my $fh, &quot;&lt;:utf8&quot;, &quot;foo.html&quot;) ||\ndie; <br>\n$p-&gt;parse_file($fh);</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Objects of the\n&quot;HTML::Parser&quot; class will recognize markup and\nseparate it from plain text (alias data content) in\n<small>HTML</small> documents. As different kinds of markup\nand text are recognized, the corresponding event handlers\nare invoked.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;HTML::Parser&quot;\nis not a generic <small>SGML</small> parser. We have tried\nto make it able to deal with the <small>HTML</small> that is\nactually &quot;out there&quot;, and it normally parses as\nclosely as possible to the way the popular web browsers do\nit instead of strictly following one of the many\n<small>HTML</small> specifications from W3C. Where there is\ndisagreement, there is often an option that you can enable\nto get the official behaviour.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The document to\nbe parsed may be supplied in arbitrary chunks. This makes\non-the-fly parsing as documents are received from the\nnetwork possible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If event driven\nparsing does not feel right for your application, you might\nwant to use &quot;HTML::PullParser&quot;. This is an\n&quot;HTML::Parser&quot; subclass that allows a more\nconventional program structure.</p>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethod is used to construct a new &quot;HTML::Parser&quot;\nobject: <br>\n$p = HTML::Parser-&gt;new( %options_and_handlers )</p>\n\n<p style=\"margin-left:17%;\">This class method creates a new\n&quot;HTML::Parser&quot; object and returns it. Key/value\nargument pairs may be provided to assign event handlers or\ninitialize parser options. The handlers and parser options\ncan also be set or modified later by the method calls\ndescribed below.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If a top level\nkey is in the form &quot;&lt;event&gt;_h&quot; (e.g.,\n&quot;text_h&quot;) then it assigns a handler to that event,\notherwise it initializes a parser option. The event handler\nspecification value must be an array reference. Multiple\nhandlers may also be assigned with the &rsquo;handlers =&gt;\n[%handlers]&rsquo; option. See examples below.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If <b>new()</b>\nis called without any arguments, it will create a parser\nthat uses callback methods compatible with version 2 of\n&quot;HTML::Parser&quot;. See the section on &quot;version 2\ncompatibility&quot; below for details.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The special\nconstructor option &rsquo;api_version =&gt; 2&rsquo; can be\nused to initialize version 2 callbacks while still setting\nother options and handlers. The &rsquo;api_version =&gt;\n3&rsquo; option can be used if you don&rsquo;t want to set\nany options and don&rsquo;t want to fall back to v2\ncompatible mode.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Examples:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p =\nHTML::Parser-&gt;new( <br>\napi_version =&gt; 3, <br>\ntext_h =&gt; [ sub {...}, &quot;dtext&quot; ] <br>\n);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This creates a\nnew parser object with a text event handler subroutine that\nreceives the original text with general entities\ndecoded.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p =\nHTML::Parser-&gt;new( <br>\napi_version =&gt; 3, <br>\nstart_h =&gt; [ 'my_start', &quot;self,tokens&quot; ] <br>\n);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This creates a\nnew parser object with a start event handler method that\nreceives the $p and the tokens array.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p =\nHTML::Parser-&gt;new( <br>\napi_version =&gt; 3, <br>\nhandlers =&gt; { <br>\ntext =&gt; [\\@array, &quot;event,text&quot;], <br>\ncomment =&gt; [\\@array, &quot;event,text&quot;], <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This creates a\nnew parser object that stores the event type and the\noriginal text in @array for text and comment events.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethods feed the <small>HTML</small> document to the\n&quot;HTML::Parser&quot; object: <br>\n$p-&gt;parse( $string )</p>\n\n<p style=\"margin-left:17%;\">Parse $string as the next chunk\nof the <small>HTML</small> document. Handlers invoked should\nnot attempt to modify the $string in-place until\n$p-&gt;parse returns.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If an invoked\nevent handler aborts parsing by calling $p-&gt;eof, then\n$p-&gt;<b>parse()</b> will return a <small>FALSE</small>\nvalue. Otherwise the return value is a reference to the\nparser object ($p).</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;parse( $code_ref )</p>\n\n<p style=\"margin-left:17%;\">If a code reference is passed\nas the argument to be parsed, then the chunks to be parsed\nare obtained by invoking this function repeatedly. Parsing\ncontinues until the function returns an empty (or undefined)\nresult. When this happens $p-&gt;eof is automatically\nsignaled.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Parsing will\nalso abort if one of the event handlers calls\n$p-&gt;eof.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The effect of\nthis is the same as:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">while (1) {\n<br>\nmy $chunk = &amp;$code_ref(); <br>\nif (!defined($chunk) || !length($chunk)) { <br>\n$p-&gt;eof; <br>\nreturn $p; <br>\n} <br>\n$p-&gt;parse($chunk) || return undef; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">But it is more\nefficient as this loop runs internally in <small>XS</small>\ncode.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;parse_file( $file )</p>\n\n<p style=\"margin-left:17%;\">Parse text directly from a\nfile. The $file argument can be a filename, an open file\nhandle, or a reference to an open file handle.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If $file\ncontains a filename and the file can&rsquo;t be opened, then\nthe method returns an undefined value and $! tells why it\nfailed. Otherwise the return value is a reference to the\nparser object.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If a file\nhandle is passed as the $file argument, then the file will\nnormally be read until <small>EOF,</small> but not\nclosed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If an invoked\nevent handler aborts parsing by calling $p-&gt;eof, then\n$p-&gt;<b>parse_file()</b> may not have read the entire\nfile.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">On systems with\nmulti-byte line terminators, the values passed for the\noffset and length argspecs may be too low if\n<b>parse_file()</b> is called on a file handle that is not\nin binary mode.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If a filename\nis passed in, then <b>parse_file()</b> will open the file in\nbinary mode.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;eof</p>\n\n<p style=\"margin-left:17%;\">Signals the end of the\n<small>HTML</small> document. Calling the $p-&gt;eof method\noutside a handler callback will flush any remaining buffered\ntext (which triggers the &quot;text&quot; event if there is\nany remaining text).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Calling\n$p-&gt;eof inside a handler will terminate parsing at that\npoint and cause $p-&gt;parse to return a\n<small>FALSE</small> value. This also terminates parsing by\n$p-&gt;<b>parse_file()</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">After\n$p-&gt;eof has been called, the <b>parse()</b> and\n<b>parse_file()</b> methods can be invoked to feed new\ndocuments with the parser object.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The return\nvalue from <b>eof()</b> is a reference to the parser\nobject.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Most parser\noptions are controlled by boolean attributes. Each boolean\nattribute is enabled by calling the corresponding method\nwith a <small>TRUE</small> argument and disabled with a\n<small>FALSE</small> argument. The attribute value is left\nunchanged if no argument is given. The return value from\neach method is the old attribute value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Methods that\ncan be used to get and/or set parser options are: <br>\n$p-&gt;attr_encoded <br>\n$p-&gt;attr_encoded( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, the\n&quot;attr&quot; and @attr argspecs will have general\nentities for attribute values decoded. Enabling this\nattribute leaves entities alone.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;backquote <br>\n$p-&gt;backquote( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, only &rsquo; and\n&quot; are recognized as quote characters around attribute\nvalues. <small>MSIE</small> also recognizes backquotes for\nsome reason. Enabling this attribute provides compatibility\nwith this behaviour.</p>\n\n\n<p style=\"margin-left:11%;\">$p-&gt;boolean_attribute_value(\n$val )</p>\n\n<p style=\"margin-left:17%;\">This method sets the value\nreported for boolean attributes inside <small>HTML</small>\nstart tags. By default, the name of the attribute is also\nused as its value. This affects the values reported for\n&quot;tokens&quot; and &quot;attr&quot; argspecs.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;case_sensitive <br>\n$p-&gt;case_sensitive( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, tag names and\nattribute names are down-cased. Enabling this attribute\nleaves them as found in the <small>HTML</small> source\ndocument.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;closing_plaintext <br>\n$p-&gt;closing_plaintext( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default,\n&quot;plaintext&quot; element can never be closed.\nEverything up to the end of the document is parsed in\n<small>CDATA</small> mode. This historical behaviour is what\nat least <small>MSIE</small> does. Enabling this attribute\nmakes closing &quot; &lt;/plaintext&quot; &gt; tag effective\nand the parsing process will resume after seeing this tag.\nThis emulates early gecko-based browsers.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;empty_element_tags <br>\n$p-&gt;empty_element_tags( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, empty element tags\nare not recognized as such and the &quot;/&quot; before\n&quot;&gt;&quot; is just treated like a normal name\ncharacter (unless &quot;strict_names&quot; is enabled).\nEnabling this attribute make &quot;HTML::Parser&quot;\nrecognize these tags.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Empty element\ntags look like start tags, but end with the character\nsequence &quot;/&gt;&quot; instead of &quot;&gt;&quot;. When\nrecognized by &quot;HTML::Parser&quot; they cause an\nartificial end event in addition to the start event. The\n&quot;text&quot; for the artificial end event will be empty\nand the &quot;tokenpos&quot; array will be undefined even\nthough the token array will have one element containing the\ntag name.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;marked_sections <br>\n$p-&gt;marked_sections( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, section markings\nlike &lt;![CDATA[...]]&gt; are treated like ordinary text.\nWhen this attribute is enabled section markings are\nhonoured.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">There are\ncurrently no events associated with the marked section\nmarkup, but the text can be returned as\n&quot;skipped_text&quot;.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;strict_comment <br>\n$p-&gt;strict_comment( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, comments are\nterminated by the first occurrence of &quot;--&gt;&quot;.\nThis is the behaviour of most popular browsers (like\nMozilla, Opera and <small>MSIE</small> ), but it is not\ncorrect according to the official <small>HTML</small>\nstandard. Officially, you need an even number of\n&quot;--&quot; tokens before the closing &quot;&gt;&quot; is\nrecognized and there may not be anything but whitespace\nbetween an even and an odd &quot;--&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The official\nbehaviour is enabled by enabling this attribute.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Enabling of\n&rsquo;strict_comment&rsquo; also disables recognizing these\nforms as comments:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;/\ncomment&gt; <br>\n&lt;! comment&gt;</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;strict_end <br>\n$p-&gt;strict_end( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, attributes and\nother junk are allowed to be present on end tags in a manner\nthat emulates <small>MSIE</small> &rsquo;s behaviour.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The official\nbehaviour is enabled with this attribute. If enabled, only\nwhitespace is allowed between the tagname and the final\n&quot;&gt;&quot;.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;strict_names <br>\n$p-&gt;strict_names( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, almost anything is\nallowed in tag and attribute names. This is the behaviour of\nmost popular browsers and allows us to parse some broken\ntags with invalid attribute values like:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;IMG\nSRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">By default,\n&quot; <small>LIST</small> ]&quot; is parsed as a boolean\nattribute, not as part of the <small>ALT</small> value as\nwas clearly intended. This is also what Mozilla sees.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The official\nbehaviour is enabled by enabling this attribute. If enabled,\nit will cause the tag above to be reported as text since\n&quot; <small>LIST</small> ]&quot; is not a legal attribute\nname.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;unbroken_text <br>\n$p-&gt;unbroken_text( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, blocks of text are\ngiven to the text handler as soon as possible (but the\nparser takes care always to break text at a boundary between\nwhitespace and non-whitespace so single words and entities\ncan always be decoded safely). This might create breaks that\nmake it hard to do transformations on the text. When this\nattribute is enabled, blocks of text are always reported in\none piece. This will delay the text event until the\nfollowing (non-text) event has been recognized by the\nparser.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\n&quot;offset&quot; argspec will give you the offset of the\nfirst segment of text and &quot;length&quot; is the combined\nlength of the segments. Since there might be ignored tags in\nbetween, these numbers can&rsquo;t be used to directly index\nin the original document file.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;utf8_mode <br>\n$p-&gt;utf8_mode( $bool )</p>\n\n<p style=\"margin-left:17%;\">Enable this option when parsing\nraw undecoded <small>UTF-8.</small> This tells the parser\nthat the entities expanded for strings reported by\n&quot;attr&quot;, @attr and &quot;dtext&quot; should be\nexpanded as decoded <small>UTF-8</small> so they end up\ncompatible with the surrounding text.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If\n&quot;utf8_mode&quot; is enabled then it is an error to pass\nstrings containing characters with code above 255 to the\n<b>parse()</b> method, and the <b>parse()</b> method will\ncroak if you try.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Example: The\nUnicode character &quot;\\x{2665}&quot; is\n&quot;\\xE2\\x99\\xA5&quot; when <small>UTF-8</small> encoded.\nThe character can also be represented by the entity\n&quot;&amp;hearts;&quot; or &quot;&amp;#x2665&quot;. If we\nfeed the parser:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;parse(&quot;\\xE2\\x99\\xA5&amp;hearts;&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">then\n&quot;dtext&quot; will be reported as\n&quot;\\xE2\\x99\\xA5\\x{2665}&quot; without\n&quot;utf8_mode&quot; enabled, but as\n&quot;\\xE2\\x99\\xA5\\xE2\\x99\\xA5&quot; when enabled. The later\nstring is what you want.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This option is\nonly available with perl-5.8 or better.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;xml_mode <br>\n$p-&gt;xml_mode( $bool )</p>\n\n<p style=\"margin-left:17%;\">Enabling this attribute changes\nthe parser to allow some <small>XML</small> constructs. This\nenables the behaviour controlled by individually by the\n&quot;case_sensitive&quot;, &quot;empty_element_tags&quot;,\n&quot;strict_names&quot; and &quot;xml_pic&quot; attributes\nand also suppresses special treatment of elements that are\nparsed as <small>CDATA</small> for <small>HTML.</small></p>\n\n<p style=\"margin-left:11%;\">$p-&gt;xml_pic <br>\n$p-&gt;xml_pic( $bool )</p>\n\n<p style=\"margin-left:17%;\">By default, <i>processing\ninstructions</i> are terminated by &quot;&gt;&quot;. When\nthis attribute is enabled, processing instructions are\nterminated by &quot;?&gt;&quot; instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As markup and\ntext is recognized, handlers are invoked. The following\nmethod is used to set up handlers for different events: <br>\n$p-&gt;handler( event =&gt; \\&amp;subroutine, $argspec )\n<br>\n$p-&gt;handler( event =&gt; $method_name, $argspec ) <br>\n$p-&gt;handler( event =&gt; \\@accum, $argspec ) <br>\n$p-&gt;handler( event =&gt; &quot;&quot; ); <br>\n$p-&gt;handler( event =&gt; undef ); <br>\n$p-&gt;handler( event );</p>\n\n<p style=\"margin-left:17%;\">This method assigns a\nsubroutine, method, or array to handle an event.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Event is one of\n&quot;text&quot;, &quot;start&quot;, &quot;end&quot;,\n&quot;declaration&quot;, &quot;comment&quot;,\n&quot;process&quot;, &quot;start_document&quot;,\n&quot;end_document&quot; or &quot;default&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;\\&amp;subroutine&quot; is a reference to a subroutine\nwhich is called to handle the event.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n$method_name is the name of a method of $p which is called\nto handle the event.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The @accum is\nan array that will hold the event information as\nsub-arrays.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the second\nargument is &quot;&quot;, the event is ignored. If it is\nundef, the default handler is invoked for the event.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The $argspec is\na string that describes the information to be reported for\nthe event. Any requested information that does not apply to\na specific event is passed as &quot;undef&quot;. If argspec\nis omitted, then it is left unchanged.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The return\nvalue from $p-&gt;handler is the old callback routine or a\nreference to the accumulator array.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Any return\nvalues from handler callback routines/methods are always\nignored. A handler callback can request parsing to be\naborted by invoking the $p-&gt;eof method. A handler\ncallback is not allowed to invoke the $p-&gt;<b>parse()</b>\nor $p-&gt;<b>parse_file()</b> method. An exception will be\nraised if it tries.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Examples:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;handler(start\n=&gt; &quot;start&quot;, 'self, attr, attrseq, text' );</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This causes the\n&quot;start&quot; method of object $p to be called for\n&rsquo;start&rsquo; events. The callback signature is\n&quot;$p-&gt;start(\\%attr, \\@attr_seq, $text)&quot;.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;handler(start\n=&gt; \\&amp;start, 'attr, attrseq, text' );</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This causes\nsubroutine <b>start()</b> to be called for\n&rsquo;start&rsquo; events. The callback signature is\nstart(\\%attr, \\@attr_seq, $text).</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;handler(start\n=&gt; \\@accum, '&quot;S&quot;, attr, attrseq, text' );</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This causes\n&rsquo;start&rsquo; event information to be saved in @accum.\nThe array elements will be [&rsquo;S&rsquo;, \\%attr,\n\\@attr_seq, $text].</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;handler(start\n=&gt; &quot;&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This causes\n&rsquo;start&rsquo; events to be ignored. It also suppresses\ninvocations of any default handler for start events. It is\nin most cases equivalent to $p-&gt;handler(start =&gt; sub\n{}), but is more efficient. It is different from the\nempty-sub-handler in that &quot;skipped_text&quot; is not\nreset by it.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;handler(start\n=&gt; undef);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This causes no\nhandler to be associated with start events. If there is a\ndefault handler it will be invoked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Filters based\non tags can be set up to limit the number of events\nreported. The main bottleneck during parsing is often the\nhuge number of callbacks made from the parser. Applying\nfilters can improve performance significantly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethods control filters: <br>\n$p-&gt;ignore_elements( @tags )</p>\n\n<p style=\"margin-left:17%;\">Both the &quot;start&quot;\nevent and the &quot;end&quot; event as well as any events\nthat would be reported in between are suppressed. The\nignored elements can contain nested occurrences of itself.\nExample:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;ignore_elements(qw(script\nstyle));</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;script&quot; and &quot;style&quot; tags will always\nnest properly since their content is parsed in\n<small>CDATA</small> mode. For most other tags\n&quot;ignore_elements&quot; must be used with caution since\n<small>HTML</small> is often not <i>well formed</i>.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;ignore_tags( @tags )</p>\n\n<p style=\"margin-left:17%;\">Any &quot;start&quot; and\n&quot;end&quot; events involving any of the tags given are\nsuppressed. To reset the filter (i.e. don&rsquo;t suppress\nany &quot;start&quot; and &quot;end&quot; events), call\n&quot;ignore_tags&quot; without an argument.</p>\n\n<p style=\"margin-left:11%;\">$p-&gt;report_tags( @tags )</p>\n\n<p style=\"margin-left:17%;\">Any &quot;start&quot; and\n&quot;end&quot; events involving any of the tags <i>not</i>\ngiven are suppressed. To reset the filter (i.e. report all\n&quot;start&quot; and &quot;end&quot; events), call\n&quot;report_tags&quot; without an argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Internally, the\nsystem has two filter lists, one for &quot;report_tags&quot;\nand one for &quot;ignore_tags&quot;, and both filters are\napplied. This effectively gives &quot;ignore_tags&quot;\nprecedence over &quot;report_tags&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Examples:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$p-&gt;ignore_tags(qw(style));\n<br>\n$p-&gt;report_tags(qw(script style));</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">results in only\n&quot;script&quot; events being reported.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Argspec</b>\n<br>\nArgspec is a string containing a comma-separated list that\ndescribes the information reported by the event. The\nfollowing argspec identifier names can be used: <br>\n&quot;attr&quot;</p>\n\n<p style=\"margin-left:17%;\">Attr causes a reference to a\nhash of attribute name/value pairs to be passed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Boolean\nattributes&rsquo; values are either the value set by\n$p-&gt;boolean_attribute_value, or the attribute name if no\nvalue has been set by $p-&gt;boolean_attribute_value.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This passes\nundef except for &quot;start&quot; events.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Unless\n&quot;xml_mode&quot; or &quot;case_sensitive&quot; is\nenabled, the attribute names are forced to lower case.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">General\nentities are decoded in the attribute values and one layer\nof matching quotes enclosing the attribute values is\nremoved.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The Unicode\ncharacter set is assumed for entity decoding.</p>\n\n<p style=\"margin-left:11%;\">@attr</p>\n\n<p style=\"margin-left:17%;\">Basically the same as\n&quot;attr&quot;, but keys and values are passed as\nindividual arguments and the original sequence of the\nattributes is kept. The parameters passed will be the same\nas the @attr calculated here:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">@attr = map {\n$_ =&gt; $attr-&gt;{$_} } @$attrseq;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">assuming $attr\nand $attrseq here are the hash and array passed as the\nresult of &quot;attr&quot; and &quot;attrseq&quot;\nargspecs.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This passes no\nvalues for events besides &quot;start&quot;.</p>\n\n<p style=\"margin-left:11%;\">&quot;attrseq&quot;</p>\n\n<p style=\"margin-left:17%;\">Attrseq causes a reference to\nan array of attribute names to be passed. This can be useful\nif you want to walk the &quot;attr&quot; hash in the\noriginal sequence.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This passes\nundef except for &quot;start&quot; events.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Unless\n&quot;xml_mode&quot; or &quot;case_sensitive&quot; is\nenabled, the attribute names are forced to lower case.</p>\n\n<p style=\"margin-left:11%;\">&quot;column&quot;</p>\n\n<p style=\"margin-left:17%;\">Column causes the column number\nof the start of the event to be passed. The first column on\na line is 0.</p>\n\n<p style=\"margin-left:11%;\">&quot;dtext&quot;</p>\n\n<p style=\"margin-left:17%;\">Dtext causes the decoded text\nto be passed. General entities are automatically decoded\nunless the event was inside a <small>CDATA</small> section\nor was between literal start and end tags\n(&quot;script&quot;, &quot;style&quot;, &quot;xmp&quot;,\n&quot;iframe&quot;, &quot;title&quot;, &quot;textarea&quot;\nand &quot;plaintext&quot;).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The Unicode\ncharacter set is assumed for entity decoding. With Perl\nversion 5.6 or earlier only the Latin-1 range is supported,\nand entities for characters outside the range 0..255 are\nleft unchanged.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This passes\nundef except for &quot;text&quot; events.</p>\n\n<p style=\"margin-left:11%;\">&quot;event&quot;</p>\n\n<p style=\"margin-left:17%;\">Event causes the event name to\nbe passed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The event name\nis one of &quot;text&quot;, &quot;start&quot;,\n&quot;end&quot;, &quot;declaration&quot;,\n&quot;comment&quot;, &quot;process&quot;,\n&quot;start_document&quot; or &quot;end_document&quot;.</p>\n\n<p style=\"margin-left:11%;\">&quot;is_cdata&quot;</p>\n\n<p style=\"margin-left:17%;\">Is_cdata causes a\n<small>TRUE</small> value to be passed if the event is\ninside a <small>CDATA</small> section or between literal\nstart and end tags (&quot;script&quot;, &quot;style&quot;,\n&quot;xmp&quot;, &quot;iframe&quot;, &quot;title&quot;,\n&quot;textarea&quot; and &quot;plaintext&quot;).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if the flag is\n<small>FALSE</small> for a text event, then you should\nnormally either use &quot;dtext&quot; or decode the entities\nyourself before the text is processed further.</p>\n\n<p style=\"margin-left:11%;\">&quot;length&quot;</p>\n\n<p style=\"margin-left:17%;\">Length causes the number of\nbytes of the source text of the event to be passed.</p>\n\n<p style=\"margin-left:11%;\">&quot;line&quot;</p>\n\n<p style=\"margin-left:17%;\">Line causes the line number of\nthe start of the event to be passed. The first line in the\ndocument is 1. Line counting doesn&rsquo;t start until at\nleast one handler requests this value to be reported.</p>\n\n<p style=\"margin-left:11%;\">&quot;offset&quot;</p>\n\n<p style=\"margin-left:17%;\">Offset causes the byte position\nin the <small>HTML</small> document of the start of the\nevent to be passed. The first byte in the document has\noffset 0.</p>\n\n<p style=\"margin-left:11%;\">&quot;offset_end&quot;</p>\n\n<p style=\"margin-left:17%;\">Offset_end causes the byte\nposition in the <small>HTML</small> document of the end of\nthe event to be passed. This is the same as\n&quot;offset&quot; + &quot;length&quot;.</p>\n\n<p style=\"margin-left:11%;\">&quot;self&quot;</p>\n\n<p style=\"margin-left:17%;\">Self causes the current object\nto be passed to the handler. If the handler is a method,\nthis must be the first element in the argspec.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">An alternative\nto passing self as an argspec is to register closures that\ncapture $self by themselves as handlers. Unfortunately this\ncreates circular references which prevent the HTML::Parser\nobject from being garbage collected. Using the\n&quot;self&quot; argspec avoids this problem.</p>\n\n<p style=\"margin-left:11%;\">&quot;skipped_text&quot;</p>\n\n<p style=\"margin-left:17%;\">Skipped_text returns the\nconcatenated text of all the events that have been skipped\nsince the last time an event was reported. Events might be\nskipped because no handler is registered for them or because\nsome filter applies. Skipped text also includes marked\nsection markup, since there are no events that can catch\nit.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If an\n&quot;&quot;-handler is registered for an event, then the\ntext for this event is not included in\n&quot;skipped_text&quot;. Skipped text both before and after\nthe &quot;&quot;-event is included in the next reported\n&quot;skipped_text&quot;.</p>\n\n<p style=\"margin-left:11%;\">&quot;tag&quot;</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;tagname&quot;,\nbut prefixed with &quot;/&quot; if it belongs to an\n&quot;end&quot; event and &quot;!&quot; for a declaration.\nThe &quot;tag&quot; does not have any prefix for\n&quot;start&quot; events, and is in this case identical to\n&quot;tagname&quot;.</p>\n\n<p style=\"margin-left:11%;\">&quot;tagname&quot;</p>\n\n<p style=\"margin-left:17%;\">This is the element name (or\n<i>generic identifier</i> in <small>SGML</small> jargon) for\nstart and end tags. Since <small>HTML</small> is case\ninsensitive, this name is forced to lower case to ease\nstring matching.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Since\n<small>XML</small> is case sensitive, the tagname case is\nnot changed when &quot;xml_mode&quot; is enabled. The same\nhappens if the &quot;case_sensitive&quot; attribute is\nset.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The declaration\ntype of declaration elements is also passed as a tagname,\neven if that is a bit strange. In fact, in the current\nimplementation tagname is identical to &quot;token0&quot;\nexcept that the name may be forced to lower case.</p>\n\n<p style=\"margin-left:11%;\">&quot;token0&quot;</p>\n\n<p style=\"margin-left:17%;\">Token0 causes the original text\nof the first token string to be passed. This should always\nbe the same as $tokens-&gt;[0].</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;declaration&quot; events, this is the declaration\ntype.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;start&quot; and &quot;end&quot; events, this is the\ntag name.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;process&quot; and non-strict &quot;comment&quot;\nevents, this is everything inside the tag.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This passes\nundef if there are no tokens in the event.</p>\n\n<p style=\"margin-left:11%;\">&quot;tokenpos&quot;</p>\n\n<p style=\"margin-left:17%;\">Tokenpos causes a reference to\nan array of token positions to be passed. For each string\nthat appears in &quot;tokens&quot;, this array contains two\nnumbers. The first number is the offset of the start of the\ntoken in the original &quot;text&quot; and the second number\nis the length of the token.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Boolean\nattributes in a &quot;start&quot; event will have (0,0) for\nthe attribute value offset and length.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This passes\nundef if there are no tokens in the event (e.g.,\n&quot;text&quot;) and for artificial &quot;end&quot; events\ntriggered by empty element tags.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you are\nusing these offsets and lengths to modify &quot;text&quot;,\nyou should either work from right to left, or be very\ncareful to calculate the changes to the offsets.</p>\n\n<p style=\"margin-left:11%;\">&quot;tokens&quot;</p>\n\n<p style=\"margin-left:17%;\">Tokens causes a reference to an\narray of token strings to be passed. The strings are exactly\nas they were found in the original text, no decoding or case\nchanges are applied.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;declaration&quot; events, the array contains each\nword, comment, and delimited string starting with the\ndeclaration type.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;comment&quot; events, this contains each sub-comment.\nIf $p-&gt;strict_comments is disabled, there will be only\none sub-comment.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;start&quot; events, this contains the original tag\nname followed by the attribute name/value pairs. The values\nof boolean attributes will be either the value set by\n$p-&gt;boolean_attribute_value, or the attribute name if no\nvalue has been set by $p-&gt;boolean_attribute_value.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;end&quot; events, this contains the original tag name\n(always one token).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n&quot;process&quot; events, this contains the process\ninstructions (always one token).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This passes\n&quot;undef&quot; for &quot;text&quot; events.</p>\n\n<p style=\"margin-left:11%;\">&quot;text&quot;</p>\n\n<p style=\"margin-left:17%;\">Text causes the source text\n(including markup element delimiters) to be passed.</p>\n\n<p style=\"margin-left:11%;\">&quot;undef&quot;</p>\n\n<p style=\"margin-left:17%;\">Pass an undefined value. Useful\nas padding where the same handler routine is registered for\nmultiple events.</p>\n\n<p style=\"margin-left:11%;\">'...'</p>\n\n<p style=\"margin-left:17%;\">A literal string of 0 to 255\ncharacters enclosed in single (&rsquo;) or double (&quot;)\nquotes is passed as entered.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The whole\nargspec string can be wrapped up in '@{...}' to signal that\nthe resulting event array should be flattened. This only\nmakes a difference if an array reference is used as the\nhandler target. Consider this example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$p-&gt;handler(text\n=&gt; [], 'text'); <br>\n$p-&gt;handler(text =&gt; [], '@{text}']);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With two text\nevents; &quot;foo&quot;, &quot;bar&quot;; then the first\nexample will end up with [[&quot;foo&quot;],\n[&quot;bar&quot;]] and the second with [&quot;foo&quot;,\n&quot;bar&quot;] in the handler target array.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Events</b>\n<br>\nHandlers for the following events can be registered: <br>\n&quot;comment&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered when a\nmarkup comment is recognized.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;!-- This is\na comment -- -- So is this --&gt;</p>\n\n<p style=\"margin-left:11%;\">&quot;declaration&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered when a\n<i>markup declaration</i> is recognized.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For typical\n<small>HTML</small> documents, the only declaration you are\nlikely to find is &lt;!DOCTYPE ...&gt;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;!DOCTYPE\nHTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; <br>\n&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">DTDs inside\n&lt;!DOCTYPE ...&gt; will confuse HTML::Parser.</p>\n\n<p style=\"margin-left:11%;\">&quot;default&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered for\nevents that do not have a specific handler. You can set up a\nhandler for this event to catch stuff you did not want to\ncatch explicitly.</p>\n\n<p style=\"margin-left:11%;\">&quot;end&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered when an\nend tag is recognized.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;/A&gt;</p>\n\n<p style=\"margin-left:11%;\">&quot;end_document&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered when\n$p-&gt;eof is called and after any remaining text is\nflushed. There is no document text associated with this\nevent.</p>\n\n<p style=\"margin-left:11%;\">&quot;process&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered when a\nprocessing instructions markup is recognized.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The format and\ncontent of processing instructions are system and\napplication dependent.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Examples:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;? HTML\nprocessing instructions &gt; <br>\n&lt;? XML processing instructions ?&gt;</p>\n\n<p style=\"margin-left:11%;\">&quot;start&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered when a\nstart tag is recognized.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;A\nHREF=&quot;http://www.perl.com/&quot;&gt;</p>\n\n<p style=\"margin-left:11%;\">&quot;start_document&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered before\nany other events for a new document. A handler for it can be\nused to initialize stuff. There is no document text\nassociated with this event.</p>\n\n<p style=\"margin-left:11%;\">&quot;text&quot;</p>\n\n<p style=\"margin-left:17%;\">This event is triggered when\nplain text (characters) is recognized. The text may contain\nmultiple lines. A sequence of text may be broken between\nseveral text events unless $p-&gt;unbroken_text is\nenabled.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The parser will\nmake sure that it does not break a word or a sequence of\nwhitespace between two text events.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Unicode</b>\n<br>\n&quot;HTML::Parser&quot; can parse Unicode strings when\nrunning under perl-5.8 or better. If Unicode is passed to\n$p-&gt;<b>parse()</b> then chunks of Unicode will be\nreported to the handlers. The offset and length argspecs\nwill also report their position in terms of characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is safe to\nparse raw undecoded <small>UTF-8</small> if you either avoid\ndecoding entities and make sure to not use <i>argspecs</i>\nthat do, or enable the &quot;utf8_mode&quot; for the parser.\nParsing of undecoded <small>UTF-8</small> might be useful\nwhen parsing from a file where you need the reported offsets\nand lengths to match the byte offsets in the file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a filename\nis passed to $p-&gt;<b>parse_file()</b> then the file will\nbe read in binary mode. This will be fine if the file\ncontains only <small>ASCII</small> or Latin-1 characters. If\nthe file contains <small>UTF-8</small> encoded text then\ncare must be taken when decoding entities as described in\nthe previous paragraph, but better is to open the file with\nthe <small>UTF-8</small> layer so that it is decoded\nproperly:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">open(my $fh,\n&quot;&lt;:utf8&quot;, &quot;index.html&quot;) || die\n&quot;...: $!&quot;; <br>\n$p-&gt;parse_file($fh);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the file\ncontains text encoded in a charset besides\n<small>ASCII,</small> Latin-1 or <small>UTF-8</small> then\ndecoding will always be needed.</p>\n\n<h2>VERSION 2 COMPATIBILITY\n<a name=\"VERSION 2 COMPATIBILITY\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When an\n&quot;HTML::Parser&quot; object is constructed with no\narguments, a set of handlers is automatically provided that\nis compatible with the old HTML::Parser version 2 callback\nmethods.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is\nequivalent to the following method calls:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$p-&gt;handler(start\n=&gt; &quot;start&quot;, &quot;self, tagname, attr, attrseq,\ntext&quot;); <br>\n$p-&gt;handler(end =&gt; &quot;end&quot;, &quot;self,\ntagname, text&quot;); <br>\n$p-&gt;handler(text =&gt; &quot;text&quot;, &quot;self,\ntext, is_cdata&quot;); <br>\n$p-&gt;handler(process =&gt; &quot;process&quot;,\n&quot;self, token0, text&quot;); <br>\n$p-&gt;handler( <br>\ncomment =&gt; sub { <br>\nmy($self, $tokens) = @_; <br>\nfor (@$tokens) {$self-&gt;comment($_);} <br>\n}, <br>\n&quot;self, tokens&quot; <br>\n); <br>\n$p-&gt;handler( <br>\ndeclaration =&gt; sub { <br>\nmy $self = shift; <br>\n$self-&gt;declaration(substr($_[0], 2, -1)); <br>\n}, <br>\n&quot;self, text&quot; <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Setting up\nthese handlers can also be requested with the\n&quot;api_version =&gt; 2&quot; constructor option.</p>\n\n<h2>SUBCLASSING\n<a name=\"SUBCLASSING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;HTML::Parser&quot; class is able to be subclassed.\nParser objects are plain hashes and &quot;HTML::Parser&quot;\nreserves only hash keys that start with\n&quot;_hparser&quot;. The parser state can be set up by\ninvoking the <b>init()</b> method, which takes the same\narguments as <b>new()</b>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first\nsimple example shows how you might strip out comments from\nan <small>HTML</small> document. We achieve this by setting\nup a comment handler that does nothing and a default handler\nthat will print out anything else:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTML::Parser; <br>\nHTML::Parser-&gt;new( <br>\ndefault_h =&gt; [sub { print shift }, 'text'], <br>\ncomment_h =&gt; [&quot;&quot;], <br>\n)-&gt;parse_file(shift || die) || die $!;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An alternative\nimplementation is:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTML::Parser; <br>\nHTML::Parser-&gt;new( <br>\nend_document_h =&gt; [sub { print shift }, 'skipped_text'],\n<br>\ncomment_h =&gt; [&quot;&quot;], <br>\n)-&gt;parse_file(shift || die) || die $!;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This will in\nmost cases be much more efficient since only a single\ncallback will be made.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The next\nexample prints out the text that is inside the &lt;title&gt;\nelement of an <small>HTML</small> document. Here we start by\nsetting up a start handler. When it sees the title start tag\nit enables a text handler that prints any text found and an\nend handler that will terminate parsing as soon as the title\nend tag is seen:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTML::Parser (); <br>\nsub start_handler { <br>\nreturn if shift ne &quot;title&quot;; <br>\nmy $self = shift; <br>\n$self-&gt;handler(text =&gt; sub { print shift },\n&quot;dtext&quot;); <br>\n$self-&gt;handler( <br>\nend =&gt; sub { <br>\nshift-&gt;eof if shift eq &quot;title&quot;; <br>\n}, <br>\n&quot;tagname,self&quot; <br>\n); <br>\n} <br>\nmy $p = HTML::Parser-&gt;new(api_version =&gt; 3); <br>\n$p-&gt;handler(start =&gt; \\&amp;start_handler,\n&quot;tagname,self&quot;); <br>\n$p-&gt;parse_file(shift || die) || die $!; <br>\nprint &quot;\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On a Debian\nbox, more examples can be found in the\n/usr/share/doc/libhtml-parser-perl/examples directory. The\nprogram &quot;hrefsub&quot; shows how you can edit all links\nfound in a document and &quot;htextsub&quot; how to edit the\ntext only; the program &quot;hstrip&quot; shows how you can\nstrip out certain tags/elements and/or attributes; and the\nprogram &quot;htext&quot; show how to obtain the plain text,\nbut not any script/style content.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can browse\nthe <i>eg/</i> directory online from the <i>[Browse]</i>\nlink on the http://search.cpan.org/~gaas/HTML-Parser/\npage.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&lt;style&gt; and &lt;script&gt; sections do not end with\nthe first &quot;&lt;/&quot;, but need the complete\ncorresponding end tag. The standard behaviour is not really\npractical.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\n<i>strict_comment</i> option is enabled, we still recognize\ncomments where there is something other than whitespace\nbetween even and odd &quot;--&quot; markers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once\n$p-&gt;boolean_attribute_value has been set, there is no way\nto restore the default behaviour.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is\ncurrently no way to get both quote characters into the same\nliteral argspec.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Empty tags,\ne.g. &quot;&lt;&gt;&quot; and &quot;&lt;/&gt;&quot;, are not\nrecognized. <small>SGML</small> allows them to repeat the\nprevious start tag or close the previous start tag\nrespectively.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>NET</small>\ntags, e.g. &quot;code/.../&quot; are not recognized. This is\n<small>SGML</small> shorthand for\n&quot;&lt;code&gt;...&lt;/code&gt;&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Incomplete\nstart or end tags, e.g.\n&quot;&lt;tt&lt;b&gt;...&lt;/b&lt;/tt&gt;&quot; are not\nrecognized.</p>\n\n<h2>DIAGNOSTICS\n<a name=\"DIAGNOSTICS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmessages may be produced by HTML::Parser. The notation in\nthis listing is the same as used in perldiag: <br>\nNot a reference to a hash</p>\n\n<p style=\"margin-left:17%;\">(F) The object blessed into or\nsubclassed from HTML::Parser is not a hash as required by\nthe HTML::Parser methods.</p>\n\n<p style=\"margin-left:11%;\">Bad signature in parser state\nobject at %p</p>\n\n<p style=\"margin-left:17%;\">(F) The _hparser_xs_state\nelement does not refer to a valid state structure. Something\nmust have changed the internal value stored in this hash\nelement, or the memory has been overwritten.</p>\n\n<p style=\"margin-left:11%;\">_hparser_xs_state element is\nnot a reference</p>\n\n<p style=\"margin-left:17%;\">(F) The _hparser_xs_state\nelement has been destroyed.</p>\n\n<p style=\"margin-left:11%;\">Can&rsquo;t find\n&rsquo;_hparser_xs_state&rsquo; element in HTML::Parser\nhash</p>\n\n<p style=\"margin-left:17%;\">(F) The _hparser_xs_state\nelement is missing from the parser hash. It was either\ndeleted, or not created when the object was created.</p>\n\n<p style=\"margin-left:11%;\"><small>API</small> version %s\nnot supported by HTML::Parser %s</p>\n\n<p style=\"margin-left:17%;\">(F) The constructor option\n&rsquo;api_version&rsquo; with an argument greater than or\nequal to 4 is reserved for future extensions.</p>\n\n<p style=\"margin-left:11%;\">Bad constructor option\n&rsquo;%s&rsquo;</p>\n\n<p style=\"margin-left:17%;\">(F) An unknown constructor\noption key was passed to the <b>new()</b> or <b>init()</b>\nmethods.</p>\n\n<p style=\"margin-left:11%;\">Parse loop not allowed</p>\n\n<p style=\"margin-left:17%;\">(F) A handler invoked the\n<b>parse()</b> or <b>parse_file()</b> method. This is not\npermitted.</p>\n\n<p style=\"margin-left:11%;\">marked sections not\nsupported</p>\n\n<p style=\"margin-left:17%;\">(F) The\n$p-&gt;<b>marked_sections()</b> method was invoked in a\nHTML::Parser module that was compiled without support for\nmarked sections.</p>\n\n<p style=\"margin-left:11%;\">Unknown boolean attribute\n(%d)</p>\n\n<p style=\"margin-left:17%;\">(F) Something is wrong with the\ninternal logic that set up aliases for boolean\nattributes.</p>\n\n<p style=\"margin-left:11%;\">Only code or array references\nallowed as handler</p>\n\n<p style=\"margin-left:17%;\">(F) The second argument for\n$p-&gt;handler must be either a subroutine reference, then\nname of a subroutine or method, or a reference to an\narray.</p>\n\n<p style=\"margin-left:11%;\">No handler for %s events</p>\n\n<p style=\"margin-left:17%;\">(F) The first argument to\n$p-&gt;handler must be a valid event name; i.e. one of\n&quot;start&quot;, &quot;end&quot;, &quot;text&quot;,\n&quot;process&quot;, &quot;declaration&quot; or\n&quot;comment&quot;.</p>\n\n<p style=\"margin-left:11%;\">Unrecognized identifier %s in\nargspec</p>\n\n<p style=\"margin-left:17%;\">(F) The identifier is not a\nknown argspec name. Use one of the names mentioned in the\nargspec section above.</p>\n\n<p style=\"margin-left:11%;\">Literal string is longer than\n255 chars in argspec</p>\n\n<p style=\"margin-left:17%;\">(F) The current implementation\nlimits the length of literals in an argspec to 255\ncharacters. Make the literal shorter.</p>\n\n<p style=\"margin-left:11%;\">Backslash reserved for literal\nstring in argspec</p>\n\n<p style=\"margin-left:17%;\">(F) The backslash character\n&quot;\\&quot; is not allowed in argspec literals. It is\nreserved to permit quoting inside a literal in a later\nversion.</p>\n\n<p style=\"margin-left:11%;\">Unterminated literal string in\nargspec</p>\n\n<p style=\"margin-left:17%;\">(F) The terminating quote\ncharacter for a literal was not found.</p>\n\n<p style=\"margin-left:11%;\">Bad argspec (%s)</p>\n\n<p style=\"margin-left:17%;\">(F) Only identifier names,\nliterals, spaces and commas are allowed in argspecs.</p>\n\n<p style=\"margin-left:11%;\">Missing comma separator in\nargspec</p>\n\n<p style=\"margin-left:17%;\">(F) Identifiers in an argspec\nmust be separated with &quot;,&quot;.</p>\n\n<p style=\"margin-left:11%;\">Parsing of undecoded\n<small>UTF-8</small> will give garbage when decoding\nentities</p>\n\n<p style=\"margin-left:17%;\">(W) The first chunk parsed\nappears to contain undecoded <small>UTF-8</small> and one or\nmore argspecs that decode entities are used for the callback\nhandlers.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The result of\ndecoding will be a mix of encoded and decoded characters for\nany entities that expand to characters with code above 127.\nThis is not a good thing.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The recommended\nsolution is to apply <b>Encode::decode_utf8()</b> on the\ndata before feeding it to the $p-&gt;<b>parse()</b>. For\n$p-&gt;<b>parse_file()</b> pass a file that has been opened\nin &quot;:utf8&quot; mode.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The alternative\nsolution is to enable the &quot;utf8_mode&quot; and not\ndecode before passing strings to $p-&gt;<b>parse()</b>. The\nparser can process raw undecoded <small>UTF-8</small> sanely\nif the &quot;utf8_mode&quot; is enabled, or if the\n&quot;attr&quot;, @attr or &quot;dtext&quot; argspecs are\navoided.</p>\n\n<p style=\"margin-left:11%;\">Parsing string decoded with\nwrong endian selection</p>\n\n<p style=\"margin-left:17%;\">(W) The first character in the\ndocument is U+FFFE. This is not a legal Unicode character\nbut a byte swapped &quot;BOM&quot;. The result of parsing\nwill likely be garbage.</p>\n\n<p style=\"margin-left:11%;\">Parsing of undecoded\n<small>UTF-32</small></p>\n\n<p style=\"margin-left:17%;\">(W) The parser found the\nUnicode <small>UTF-32</small> &quot;BOM&quot; signature at\nthe start of the document. The result of parsing will likely\nbe garbage.</p>\n\n<p style=\"margin-left:11%;\">Parsing of undecoded\n<small>UTF-16</small></p>\n\n<p style=\"margin-left:17%;\">(W) The parser found the\nUnicode <small>UTF-16</small> &quot;BOM&quot; signature at\nthe start of the document. The result of parsing will likely\nbe garbage.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Entities,\nHTML::PullParser, HTML::TokeParser, HTML::HeadParser,\nHTML::LinkExtor, HTML::Form</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::TreeBuilder\n(part of the <i>HTML-Tree</i> distribution)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;http://www.w3.org/TR/html4/&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">More\ninformation about marked sections and processing\ninstructions may be found at\n&lt;http://www.is-thought.co.uk/book/sgml-8.htm&gt;.</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n1996-2016 Gisle Aas. All rights reserved. <br>\nCopyright 1999-2000 Michael A. Chase. All rights\nreserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#VERSION 2 COMPATIBILITY\">VERSION 2 COMPATIBILITY</a>","<a href=\"#SUBCLASSING\">SUBCLASSING</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#DIAGNOSTICS\">DIAGNOSTICS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":3}