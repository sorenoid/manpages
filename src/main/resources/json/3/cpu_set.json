{"name":"cpu_set","body":"\n\n<h1 align=\"center\">CPU_SET</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">CPU_SET,\nCPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR,\nCPU_XOR, CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE,\nCPU_SET_S, CPU_CLR_S, CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S,\nCPU_AND_S, CPU_OR_S, CPU_XOR_S, CPU_EQUAL_S - macros for\nmanipulating CPU sets</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;sched.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nCPU_ZERO(cpu_set_t *</b><i>set</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nCPU_SET(int</b> <i>cpu</i><b>, cpu_set_t\n*</b><i>set</i><b>); <br>\nvoid CPU_CLR(int</b> <i>cpu</i><b>, cpu_set_t\n*</b><i>set</i><b>); <br>\nint CPU_ISSET(int</b> <i>cpu</i><b>, cpu_set_t\n*</b><i>set</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nCPU_COUNT(cpu_set_t *</b><i>set</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nCPU_AND(cpu_set_t *</b><i>destset</i><b>, <br>\ncpu_set_t *</b><i>srcset1</i><b>, cpu_set_t\n*</b><i>srcset2</i><b>); <br>\nvoid CPU_OR(cpu_set_t *</b><i>destset</i><b>, <br>\ncpu_set_t *</b><i>srcset1</i><b>, cpu_set_t\n*</b><i>srcset2</i><b>); <br>\nvoid CPU_XOR(cpu_set_t *</b><i>destset</i><b>, <br>\ncpu_set_t *</b><i>srcset1</i><b>, cpu_set_t\n*</b><i>srcset2</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nCPU_EQUAL(cpu_set_t *</b><i>set1</i><b>, cpu_set_t\n*</b><i>set2</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>cpu_set_t\n*CPU_ALLOC(int</b> <i>num_cpus</i><b>); <br>\nvoid CPU_FREE(cpu_set_t *</b><i>set</i><b>); <br>\nsize_t CPU_ALLOC_SIZE(int</b> <i>num_cpus</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nCPU_ZERO_S(size_t</b> <i>setsize</i><b>, cpu_set_t\n*</b><i>set</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nCPU_SET_S(int</b> <i>cpu</i><b>, size_t</b>\n<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>); <br>\nvoid CPU_CLR_S(int</b> <i>cpu</i><b>, size_t</b>\n<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>); <br>\nint CPU_ISSET_S(int</b> <i>cpu</i><b>, size_t</b>\n<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nCPU_COUNT_S(size_t</b> <i>setsize</i><b>, cpu_set_t\n*</b><i>set</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nCPU_AND_S(size_t</b> <i>setsize</i><b>, cpu_set_t\n*</b><i>destset</i><b>, <br>\ncpu_set_t *</b><i>srcset1</i><b>, cpu_set_t\n*</b><i>srcset2</i><b>); <br>\nvoid CPU_OR_S(size_t</b> <i>setsize</i><b>, cpu_set_t\n*</b><i>destset</i><b>, <br>\ncpu_set_t *</b><i>srcset1</i><b>, cpu_set_t\n*</b><i>srcset2</i><b>); <br>\nvoid CPU_XOR_S(size_t</b> <i>setsize</i><b>, cpu_set_t\n*</b><i>destset</i><b>, <br>\ncpu_set_t *</b><i>srcset1</i><b>, cpu_set_t\n*</b><i>srcset2</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nCPU_EQUAL_S(size_t</b> <i>setsize</i><b>, cpu_set_t\n*</b><i>set1</i><b>, cpu_set_t *</b><i>set2</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cpu_set_t</i> data structure represents a set of CPUs.\nCPU sets are used by <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a> and similar\ninterfaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cpu_set_t</i> data type is implemented as a bit mask.\nHowever, the data structure should be treated as opaque: all\nmanipulation of CPU sets should be done via the macros\ndescribed in this page.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmacros are provided to operate on the CPU set <i>set</i>:\n<b><br>\nCPU_ZERO</b>()</p>\n\n<p style=\"margin-left:22%;\">Clears <i>set</i>, so that it\ncontains no CPUs.</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_SET</b>()</p>\n\n<p style=\"margin-left:22%;\">Add CPU <i>cpu</i> to\n<i>set</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_CLR</b>()</p>\n\n<p style=\"margin-left:22%;\">Remove CPU <i>cpu</i> from\n<i>set</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_ISSET</b>()</p>\n\n<p style=\"margin-left:22%;\">Test to see if CPU <i>cpu</i>\nis a member of <i>set</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_COUNT</b>()</p>\n\n<p style=\"margin-left:22%;\">Return the number of CPUs in\n<i>set</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Where a\n<i>cpu</i> argument is specified, it should not produce side\neffects, since the above macros may evaluate the argument\nmore than once.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first CPU\non the system corresponds to a <i>cpu</i> value of 0, the\nnext CPU corresponds to a <i>cpu</i> value of 1, and so on.\nNo assumptions should be made about particular CPUs being\navailable, or the set of CPUs being contiguous, since CPUs\ncan be taken offline dynamically or be otherwise absent. The\nconstant <b>CPU_SETSIZE</b> (currently 1024) specifies a\nvalue one greater than the maximum CPU number that can be\nstored in <i>cpu_set_t</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmacros perform logical operations on CPU sets: <b><br>\nCPU_AND</b>()</p>\n\n<p style=\"margin-left:22%;\">Store the intersection of the\nsets <i>srcset1</i> and <i>srcset2</i> in <i>destset</i>\n(which may be one of the source sets).</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_OR</b>()</p>\n\n<p style=\"margin-left:22%;\">Store the union of the sets\n<i>srcset1</i> and <i>srcset2</i> in <i>destset</i> (which\nmay be one of the source sets).</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_XOR</b>()</p>\n\n<p style=\"margin-left:22%;\">Store the XOR of the sets\n<i>srcset1</i> and <i>srcset2</i> in <i>destset</i> (which\nmay be one of the source sets). The XOR means the set of\nCPUs that are in either <i>srcset1</i> or <i>srcset2</i>,\nbut not both.</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_EQUAL</b>()</p>\n\n<p style=\"margin-left:22%;\">Test whether two CPU set\ncontain exactly the same CPUs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Dynamically\nsized CPU sets</b> <br>\nBecause some applications may require the ability to\ndynamically size CPU sets (e.g., to allocate sets larger\nthan that defined by the standard <i>cpu_set_t</i> data\ntype), glibc nowadays provides a set of macros to support\nthis.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmacros are used to allocate and deallocate CPU sets: <b><br>\nCPU_ALLOC</b>()</p>\n\n<p style=\"margin-left:22%;\">Allocate a CPU set large enough\nto hold CPUs in the range 0 to <i>num_cpus-1</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_ALLOC_SIZE</b>()</p>\n\n<p style=\"margin-left:22%;\">Return the size in bytes of the\nCPU set that would be needed to hold CPUs in the range 0 to\n<i>num_cpus-1</i>. This macro provides the value that can be\nused for the <i>setsize</i> argument in the <b>CPU_*_S</b>()\nmacros described below.</p>\n\n<p style=\"margin-left:11%;\"><b>CPU_FREE</b>()</p>\n\n<p style=\"margin-left:22%;\">Free a CPU set previously\nallocated by <b>CPU_ALLOC</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macros\nwhose names end with &quot;_S&quot; are the analogs of the\nsimilarly named macros without the suffix. These macros\nperform the same tasks as their analogs, but operate on the\ndynamically allocated CPU set(s) whose size is\n<i>setsize</i> bytes.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CPU_ISSET</b>()\nand <b>CPU_ISSET_S</b>() return nonzero if <i>cpu</i> is in\n<i>set</i>; otherwise, it returns 0.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CPU_COUNT</b>()\nand <b>CPU_COUNT_S</b>() return the number of CPUs in\n<i>set</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CPU_EQUAL</b>()\nand <b>CPU_EQUAL_S</b>() return nonzero if the two CPU sets\nare equal; otherwise they return 0.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CPU_ALLOC</b>()\nreturns a pointer on success, or NULL on failure. (Errors\nare as for <a href=\"https://man.page/3/malloc\">malloc(3)</a>.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CPU_ALLOC_SIZE</b>()\nreturns the number of bytes required to store a CPU set of\nthe specified cardinality.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The other\nfunctions do not return a value.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>CPU_ZERO</b>(), <b>CPU_SET</b>(), <b>CPU_CLR</b>(), and\n<b>CPU_ISSET</b>() macros were added in glibc 2.3.3.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CPU_COUNT</b>()\nfirst appeared in glibc 2.6.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CPU_AND</b>(),\n<b>CPU_OR</b>(), <b>CPU_XOR</b>(), <b>CPU_EQUAL</b>(),\n<b>CPU_ALLOC</b>(), <b>CPU_ALLOC_SIZE</b>(),\n<b>CPU_FREE</b>(), <b>CPU_ZERO_S</b>(), <b>CPU_SET_S</b>(),\n<b>CPU_CLR_S</b>(), <b>CPU_ISSET_S</b>(),\n<b>CPU_AND_S</b>(), <b>CPU_OR_S</b>(), <b>CPU_XOR_S</b>(),\nand <b>CPU_EQUAL_S</b>() first appeared in glibc 2.7.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These\ninterfaces are Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">To duplicate a\nCPU set, use <a href=\"https://man.page/3/memcpy\">memcpy(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since CPU sets\nare bit masks allocated in units of long words, the actual\nnumber of CPUs in a dynamically allocated CPU set will be\nrounded up to the next multiple of <i>sizeof(unsigned\nlong)</i>. An application should consider the contents of\nthese extra bits to be undefined.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notwithstanding\nthe similarity in the names, note that the constant\n<b>CPU_SETSIZE</b> indicates the number of CPUs in the\n<i>cpu_set_t</i> data type (thus, it is effectively a count\nof the bits in the bit mask), while the <i>setsize</i>\nargument of the <b>CPU_*_S</b>() macros is a size in\nbytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The data types\nfor arguments and return values shown in the SYNOPSIS are\nhints what about is expected in each case. However, since\nthese interfaces are implemented as macros, the compiler\nwon&rsquo;t necessarily catch all type errors if you violate\nthe suggestions.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On 32-bit\nplatforms with glibc 2.8 and earlier, <b>CPU_ALLOC</b>()\nallocates twice as much space as is required, and\n<b>CPU_ALLOC_SIZE</b>() returns a value twice as large as it\nshould. This bug should not affect the semantics of a\nprogram, but does result in wasted memory and less efficient\noperation of the macros that operate on dynamically\nallocated CPU sets. These bugs are fixed in glibc 2.9.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram demonstrates the use of some of the macros used for\ndynamically allocated CPU sets.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\n_GNU_SOURCE <br>\n#include &lt;sched.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;assert.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\ncpu_set_t *cpusetp; <br>\nsize_t size; <br>\nint num_cpus;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s &lt;num-cpus&gt;\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">num_cpus =\natoi(argv[1]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">cpusetp =\nCPU_ALLOC(num_cpus); <br>\nif (cpusetp == NULL) { <br>\nperror(&quot;CPU_ALLOC&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">size =\nCPU_ALLOC_SIZE(num_cpus);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">CPU_ZERO_S(size,\ncpusetp); <br>\nfor (int cpu = 0; cpu &lt; num_cpus; cpu += 2) <br>\nCPU_SET_S(cpu, size, cpusetp);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;CPU_COUNT()\nof set: %d\\n&quot;, CPU_COUNT_S(size, cpusetp));</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">CPU_FREE(cpusetp);\n<br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>,\n<a href=\"https://man.page/3/pthread_attr_setaffinity_np\">pthread_attr_setaffinity_np(3)</a>,\n<a href=\"https://man.page/3/pthread_setaffinity_np\">pthread_setaffinity_np(3)</a>, <a href=\"https://man.page/7/cpuset\">cpuset(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}