{"name":"net::dbus::baseobject","description":"Net::DBus::BaseObject - base class for exporting objects to the bus","body":"\n\n<h1 align=\"center\">Net::DBus::BaseObject</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus::BaseObject\n- base class for exporting objects to the bus</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"># We're going\nto be a DBus object <br>\nuse base qw(Net::DBus::BaseObject); <br>\n# Export a 'Greeting' signal taking a stringl string\nparameter <br>\ndbus_signal(&quot;Greeting&quot;, [&quot;string&quot;]);\n<br>\n# Export 'Hello' as a method accepting a single string <br>\n# parameter, and returning a single string value <br>\ndbus_method(&quot;Hello&quot;, [&quot;string&quot;],\n[&quot;string&quot;]); <br>\nsub new { <br>\nmy $class = shift; <br>\nmy $service = shift; <br>\nmy $self = $class-&gt;SUPER::new($service,\n&quot;/org/demo/HelloWorld&quot;); <br>\nbless $self, $class; <br>\nreturn $self; <br>\n} <br>\nsub _dispatch_object { <br>\nmy $self = shift; <br>\nmy $connection = shift; <br>\nmy $message = shift; <br>\nif (....$message refers to a object's method ... ) { <br>\n...dispatch this object's interfaces/methods... <br>\nreturn $reply; <br>\n} <br>\n}</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This the base\nof all objects which are exported to the message bus. It\nprovides the core support for type introspection required\nfor objects exported to the message. When sub-classing this\nobject, the &quot;_dispatch&quot; object should be\nimplemented to handle processing of incoming messages. The\nNet::DBus::Exporter module is used to declare which methods\n(and signals) are being exported to the message bus.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All packages\ninheriting from this, will automatically have the interface\n&quot;org.freedesktop.DBus.Introspectable&quot; registered\nwith Net::DBus::Exporter, and the &quot;Introspect&quot;\nmethod within this exported.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Application\ndevelopers will rarely want to use this class directly,\ninstead either Net::DBus::Object or\n&quot;Net::DBus::ProxyObject&quot; are the common choices.\nThis class will only be used if wanting to write a new\napproach to dispatching incoming method calls.</p>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $object =\nNet::DBus::BaseObject-&gt;new($service, $path)</p>\n\n<p style=\"margin-left:17%;\">This creates a new DBus object\nwith an path of $path registered within the service\n$service. The $path parameter should be a string complying\nwith the usual DBus requirements for object paths, while the\n$service parameter should be an instance of\nNet::DBus::Service. The latter is typically obtained by\ncalling the &quot;export_service&quot; method on the\nNet::DBus object.</p>\n\n<p style=\"margin-left:11%;\">my $object =\nNet::DBus::BaseObject-&gt;new($parentobj, $subpath)</p>\n\n<p style=\"margin-left:17%;\">This creates a new DBus child\nobject with an path of $subpath relative to its parent\n$parentobj. The $subpath parameter should be a string\ncomplying with the usual DBus requirements for object paths,\nwhile the $parentobj parameter should be an instance of\nNet::DBus::BaseObject.</p>\n\n\n<p style=\"margin-left:11%;\">$object-&gt;<b>disconnect()</b>;</p>\n\n<p style=\"margin-left:17%;\">This method disconnects the\nobject from the bus, such that it will no longer receive\nmessages sent by other clients. Any child objects will be\nrecursively disconnected too. After an object has been\ndisconnected, it is possible for Perl to garbage collect the\nobject instance. It will also make it possible to connect a\nnewly created object to the same path.</p>\n\n<p style=\"margin-left:11%;\">my $bool =\n$object-&gt;is_connected</p>\n\n<p style=\"margin-left:17%;\">Returns a true value if the\nobject is connected to the bus, and thus capable of being\naccessed by remote clients. Returns false if the object is\ndisconnected &amp; thus ready for garbage collection. All\nobjects start off in the connected state, and will only\ntransition if the &quot;disconnect&quot; method is\ncalled.</p>\n\n<p style=\"margin-left:11%;\">my $service =\n$object-&gt;get_service</p>\n\n<p style=\"margin-left:17%;\">Retrieves the\nNet::DBus::Service object within which this object is\nexported.</p>\n\n<p style=\"margin-left:11%;\">my $path =\n$object-&gt;get_object_path</p>\n\n<p style=\"margin-left:17%;\">Retrieves the path under which\nthis object is exported</p>\n\n\n<p style=\"margin-left:11%;\">$object-&gt;emit_signal_in($name,\n$interface, $client, @args);</p>\n\n<p style=\"margin-left:17%;\">Emits a signal from the object,\nwith a name of $name. If the $interface parameter is\ndefined, the signal will be scoped within that interface. If\nthe $client parameter is defined, the signal will be unicast\nto that client on the bus. The signal and the data types of\nthe arguments @args must have been registered with\nNet::DBus::Exporter by calling the &quot;dbus_signal&quot;\nmethod.</p>\n\n\n<p style=\"margin-left:11%;\">$self-&gt;emit_signal_to($name,\n$client, @args);</p>\n\n<p style=\"margin-left:17%;\">Emits a signal from the object,\nwith a name of $name. The signal and the data types of the\narguments @args must have been registered with\nNet::DBus::Exporter by calling the &quot;dbus_signal&quot;\nmethod. The signal will be sent only to the client named by\nthe $client parameter.</p>\n\n<p style=\"margin-left:11%;\">$self-&gt;emit_signal($name,\n@args);</p>\n\n<p style=\"margin-left:17%;\">Emits a signal from the object,\nwith a name of $name. The signal and the data types of the\narguments @args must have been registered with\nNet::DBus::Exporter by calling the &quot;dbus_signal&quot;\nmethod. The signal will be broadcast to all clients on the\nbus.</p>\n\n\n<p style=\"margin-left:11%;\">$object-&gt;connect_to_signal_in($name,\n$interface, $coderef);</p>\n\n<p style=\"margin-left:17%;\">Connects a callback to a signal\nemitted by the object. The $name parameter is the name of\nthe signal within the object, and $coderef is a reference to\nan anonymous subroutine. When the signal $name is emitted by\nthe remote object, the subroutine $coderef will be invoked,\nand passed the parameters from the signal. The $interface\nparameter is used to specify the explicit interface defining\nthe signal to connect to.</p>\n\n\n<p style=\"margin-left:11%;\">$object-&gt;connect_to_signal($name,\n$coderef);</p>\n\n<p style=\"margin-left:17%;\">Connects a callback to a signal\nemitted by the object. The $name parameter is the name of\nthe signal within the object, and $coderef is a reference to\nan anonymous subroutine. When the signal $name is emitted by\nthe remote object, the subroutine $coderef will be invoked,\nand passed the parameters from the signal.</p>\n\n<p style=\"margin-left:11%;\">$reply =\n$object-&gt;_dispatch_object($connection, $message);</p>\n\n<p style=\"margin-left:17%;\">The\n&quot;_dispatch_object&quot; method is to be used to handle\ndispatch of methods implemented by the object. The default\nimplementation is a no-op and should be overridden by\nsubclasses todo whatever processing is required. If the\n$message could be handled then another\n&quot;Net::DBus::Binding::Message&quot; instance should be\nreturned for the reply. If &quot;undef&quot; is returned,\nthen a generic error will be returned to the caller.</p>\n\n<p style=\"margin-left:11%;\">$currvalue =\n$object-&gt;_dispatch_property($name); =item <br>\n$object-&gt;_dispatch_property($name, $newvalue);</p>\n\n<p style=\"margin-left:17%;\">The\n&quot;_dispatch_property&quot; method is to be used to\nhandle dispatch of property reads and writes. The $name\nparameter is the name of the property being accessed. If\n$newvalue is supplied then the property is to be updated,\notherwise the current value is to be returned. The default\nimplementation will simply raise an error, so must be\noverridden in subclasses.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Daniel P.\nBerrange</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright (C)\n2005-2011 Daniel P. Berrange</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus,\nNet::DBus::Service, Net::DBus::Object,\nNet::DBus::ProxyObject, Net::DBus::Exporter,\nNet::DBus::RemoteObject</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>"],"level":3}