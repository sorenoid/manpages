{"name":"net::dbus::binding::connection","description":"Net::DBus::Binding::Connection\n- A connection between client and server","body":"\n\n<h1 align=\"center\">Net::DBus::Binding::Connection</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus::Binding::Connection\n- A connection between client and server</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Creating a\nconnection to a server and sending a message</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nNet::DBus::Binding::Connection; <br>\nmy $con = Net::DBus::Binding::Connection-&gt;new(address\n=&gt; &quot;unix:path=/path/to/socket&quot;); <br>\n$con-&gt;send($message);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Registering\nmessage handlers</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub\nhandle_something { <br>\nmy $con = shift; <br>\nmy $msg = shift; <br>\n... do something with the message... <br>\n} <br>\n$con-&gt;register_message_handler( <br>\n&quot;/some/object/path&quot;, <br>\n\\&amp;handle_something);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Hooking up to\nan event loop:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $reactor =\nNet::DBus::Binding::Reactor-&gt;new(); <br>\n$reactor-&gt;manage($con); <br>\n$reactor-&gt;run();</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">An outgoing\nconnection to a server, or an incoming connection from a\nclient. The methods defined on this module have a close\ncorrespondence to the dbus_connection_XXX methods in the C\n<small>API,</small> so for further details on their\nbehaviour, the C <small>API</small> documentation may be of\nuse.</p>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $con =\nNet::DBus::Binding::Connection-&gt;new(address =&gt; <br>\n&quot;unix:path=/path/to/socket&quot;);</p>\n\n<p style=\"margin-left:17%;\">Creates a new connection to the\nremove server specified by the parameter\n&quot;address&quot;. If the &quot;private&quot; parameter is\nsupplied, and set to a True value the connection opened is\nprivate; otherwise a shared connection is opened. A private\nconnection must be explicitly shutdown with the\n&quot;disconnect&quot; method before the last reference to\nthe object is released. A shared connection must never be\nexplicitly disconnected.</p>\n\n<p style=\"margin-left:11%;\">$status =\n$con-&gt;<b>is_connected()</b>;</p>\n\n<p style=\"margin-left:17%;\">Returns zero if the connection\nhas been disconnected, otherwise a positive value is\nreturned.</p>\n\n<p style=\"margin-left:11%;\">$status =\n$con-&gt;<b>is_authenticated()</b>;</p>\n\n<p style=\"margin-left:17%;\">Returns zero if the connection\nhas not yet successfully completed authentication, otherwise\na positive value is returned.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;<b>disconnect()</b></p>\n\n<p style=\"margin-left:17%;\">Closes this connection to the\nremote host. This method is called automatically during\ngarbage collection (ie in the <small>DESTROY</small> method)\nif the programmer forgets to explicitly disconnect.</p>\n\n<p style=\"margin-left:11%;\">$con-&gt;<b>flush()</b></p>\n\n<p style=\"margin-left:17%;\">Blocks execution until all data\nin the outgoing data stream has been sent. This method will\nnot re-enter the application event loop.</p>\n\n<p style=\"margin-left:11%;\">$con-&gt;send($message)</p>\n\n<p style=\"margin-left:17%;\">Queues a message up for sending\nto the remote host. The data will be sent asynchronously as\nthe applications event loop determines there is space in the\noutgoing socket send buffer. To force immediate sending of\nthe data, follow this method will a call to\n&quot;flush&quot;. This method will return the serial number\nof the message, which can be used to identify a subsequent\nreply (if any).</p>\n\n<p style=\"margin-left:11%;\">my $reply =\n$con-&gt;send_with_reply_and_block($msg, $timeout);</p>\n\n<p style=\"margin-left:17%;\">Queues a message up for sending\nto the remote host and blocks until it has been sent, and a\ncorresponding reply received. The return value of this\nmethod will be a\n&quot;Net::DBus::Binding::Message::MethodReturn&quot; or\n&quot;Net::DBus::Binding::Message::Error&quot; object.</p>\n\n<p style=\"margin-left:11%;\">my $pending_call =\n$con-&gt;send_with_reply($msg, $timeout);</p>\n\n<p style=\"margin-left:17%;\">Queues a message up for sending\nto the remote host and returns immediately providing a\nreference to a &quot;Net::DBus::Binding::PendingCall&quot;\nobject. This object can be used to wait / watch for a reply.\nThis allows methods to be processed asynchronously.</p>\n\n<p style=\"margin-left:11%;\">$con-&gt;dispatch;</p>\n\n<p style=\"margin-left:17%;\">Dispatches any pending messages\nin the incoming queue to their message handlers. This method\nis typically called on each iteration of the main\napplication event loop where data has been read from the\nincoming socket.</p>\n\n<p style=\"margin-left:11%;\">$message =\n$con-&gt;borrow_message</p>\n\n<p style=\"margin-left:17%;\">Temporarily removes the first\nmessage from the incoming message queue. No other thread may\naccess the message while it is &rsquo;borrowed&rsquo;, so it\nshould be replaced in the queue with the\n&quot;return_message&quot; method, or removed permanently\nwith th &quot;steal_message&quot; method as soon as is\npractical.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;return_message($msg)</p>\n\n<p style=\"margin-left:17%;\">Replaces a previously borrowed\nmessage in the incoming message queue for subsequent\ndispatch to registered message handlers.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;steal_message($msg)</p>\n\n<p style=\"margin-left:17%;\">Permanently remove a borrowed\nmessage from the incoming message queue. No registered\nmessage handlers will now be run for this message.</p>\n\n<p style=\"margin-left:11%;\">$msg =\n$con-&gt;<b>pop_message()</b>;</p>\n\n<p style=\"margin-left:17%;\">Permanently removes the first\nmessage on the incoming message queue, without running any\nregistered message handlers. If you have hooked the\nconnection up to an event loop\n(&quot;Net::DBus::Binding::Reactor&quot; for example), you\nprobably don&rsquo;t want to be calling this method.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;set_watch_callbacks(\\&amp;add_watch,\n\\&amp;remove_watch, \\&amp;toggle_watch);</p>\n\n<p style=\"margin-left:17%;\">Register a set of callbacks for\nadding, removing &amp; updating watches in the\napplication&rsquo;s event loop. Each parameter should be a\ncode reference, which on each invocation, will be supplied\nwith two parameters, the connection object and the watch\nobject. If you are using a\n&quot;Net::DBus::Binding::Reactor&quot; object as the\napplication event loop, then the &rsquo;manage&rsquo; method\non that object will call this on your behalf.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;set_timeout_callbacks(\\&amp;add_timeout,\n\\&amp;remove_timeout, <br>\n\\&amp;toggle_timeout);</p>\n\n<p style=\"margin-left:17%;\">Register a set of callbacks for\nadding, removing &amp; updating timeouts in the\napplication&rsquo;s event loop. Each parameter should be a\ncode reference, which on each invocation, will be supplied\nwith two parameters, the connection object and the timeout\nobject. If you are using a\n&quot;Net::DBus::Binding::Reactor&quot; object as the\napplication event loop, then the &rsquo;manage&rsquo; method\non that object will call this on your behalf.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;register_object_path($path,\n\\&amp;handler)</p>\n\n<p style=\"margin-left:17%;\">Registers a handler for\nmessages whose path matches that specified in the $path\nparameter. The supplied code reference will be invoked with\ntwo parameters, the connection object on which the message\nwas received, and the message to be processed (an instance\nof the &quot;Net::DBus::Binding::Message&quot; class).</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;unregister_object_path($path)</p>\n\n<p style=\"margin-left:17%;\">Unregisters the handler\nassociated with the object path $path. The handler would\npreviously have been registered with the\n&quot;register_object_path&quot; or\n&quot;register_fallback&quot; methods.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;register_fallback($path,\n\\&amp;handler)</p>\n\n<p style=\"margin-left:17%;\">Registers a handler for\nmessages whose path starts with the prefix specified in the\n$path parameter. The supplied code reference will be invoked\nwith two parameters, the connection object on which the\nmessage was received, and the message to be processed (an\ninstance of the &quot;Net::DBus::Binding::Message&quot;\nclass).</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;set_max_message_size($bytes)</p>\n\n<p style=\"margin-left:17%;\">Sets the maximum allowable size\nof a single incoming message. Messages over this size will\nbe rejected prior to exceeding this threshold. The message\nsize is specified in bytes.</p>\n\n<p style=\"margin-left:11%;\">$bytes =\n$con-&gt;<b>get_max_message_size()</b>;</p>\n\n<p style=\"margin-left:17%;\">Retrieves the maximum allowable\nincoming message size. The returned size is measured in\nbytes.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;set_max_received_size($bytes)</p>\n\n<p style=\"margin-left:17%;\">Sets the maximum size of the\nincoming message queue. Once this threshold is exceeded, no\nmore messages will be read from wire before one or more of\nthe existing messages are dispatched to their registered\nhandlers. The implication is that the message queue can\nexceed this threshold by at most the size of a single\nmessage.</p>\n\n<p style=\"margin-left:11%;\">$bytes\n$con-&gt;<b>get_max_received_size()</b></p>\n\n<p style=\"margin-left:17%;\">Retrieves the maximum incoming\nmessage queue size. The returned size is measured in\nbytes.</p>\n\n\n<p style=\"margin-left:11%;\">$con-&gt;add_filter($coderef);</p>\n\n<p style=\"margin-left:17%;\">Adds a filter to the connection\nwhich will be invoked whenever a message is received. The\n$coderef should be a reference to a subroutine, which\nreturns a true value if the message should be filtered out,\nor a false value if the normal message dispatch should be\nperformed.</p>\n\n<p style=\"margin-left:11%;\">my $msg =\n$con-&gt;make_raw_message($rawmsg)</p>\n\n<p style=\"margin-left:17%;\">Creates a new message,\ninitializing it from the low level C message object provided\nby the $rawmsg parameter. The returned object will be cast\nto the appropriate subclass of\nNet::DBus::Binding::Message.</p>\n\n<p style=\"margin-left:11%;\">my $msg =\n$con-&gt;make_error_message( replyto =&gt; $method_call,\nname =&gt; <br>\n$name, description =&gt; $description);</p>\n\n<p style=\"margin-left:17%;\">Creates a new message,\nrepresenting an error which occurred during the handling of\nthe method call object passed in as the &quot;replyto&quot;\nparameter. The &quot;name&quot; parameter is the formal name\nof the error condition, while the &quot;description&quot; is\na short piece of text giving more specific information on\nthe error.</p>\n\n<p style=\"margin-left:11%;\">my $call =\n$con-&gt;make_method_call_message( $service_name,\n$object_path, <br>\n$interface, $method_name);</p>\n\n<p style=\"margin-left:17%;\">Create a message representing a\ncall on the object located at the path $object_path within\nthe client owning the well-known name given by\n$service_name. The method to be invoked has the name\n$method_name within the interface specified by the\n$interface parameter.</p>\n\n<p style=\"margin-left:11%;\">my $msg =\n$con-&gt;make_method_return_message( replyto =&gt;\n$method_call);</p>\n\n<p style=\"margin-left:17%;\">Create a message representing a\nreply to the method call passed in the &quot;replyto&quot;\nparameter.</p>\n\n<p style=\"margin-left:11%;\">my $signal =\n$con-&gt;make_signal_message( object_path =&gt; $path,\ninterface <br>\n=&gt; $interface, signal_name =&gt; $name);</p>\n\n<p style=\"margin-left:17%;\">Creates a new message,\nrepresenting a signal [to be] emitted by the object located\nunder the path given by the &quot;object_path&quot;\nparameter. The name of the signal is given by the\n&quot;signal_name&quot; parameter, and is scoped to the\ninterface given by the &quot;interface&quot; parameter.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Daniel P.\nBerrange</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright (C)\n2004-2011 Daniel P. Berrange</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus::Binding::Server,\nNet::DBus::Binding::Bus,\nNet::DBus::Binding::Message::Signal,\nNet::DBus::Binding::Message::MethodCall,\nNet::DBus::Binding::Message::MethodReturn,\nNet::DBus::Binding::Message::Error</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>"],"level":3}