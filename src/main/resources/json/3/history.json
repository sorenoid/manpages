{"name":"history","description":"history - GNU\nHistory Library\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\nThe GNU History\nLibrary is Copyright (C) 1989-2020 by the Free Software\nFoundation, Inc.\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nMany programs\nread input from the user a line at a time. The GNU History\nlibrary is able to keep track of those lines, associate\narbitrary data with each line, and utilize information from\nprevious lines in composing new ones.\n\n<h2>HISTORY EXPANSION\n<a name=\"HISTORY EXPANSION\"></a>\n</h2>\n\n\nThe history\nlibrary supports a history expansion feature that is\nidentical to the history expansion in <b>bash.</b> This\nsection describes what syntax features are available.\n\nHistory\nexpansions introduce words from the history list into the\ninput stream, making it easy to repeat commands, insert the\narguments to a previous command into the current input line,\nor fix errors in previous commands quickly.\n\nHistory\nexpansion is usually performed immediately after a complete\nline is read. It takes place in two parts. The first is to\ndetermine which line from the history list to use during\nsubstitution. The second is to select portions of that line\nfor inclusion into the current one. The line selected from\nthe history is the <i>event</i>, and the portions of that\nline that are acted upon are <i>words</i>. Various\n<i>modifiers</i> are available to manipulate the selected\nwords. The line is broken into words in the same fashion as\n<b>bash</b> does when reading input, so that several words\nthat would otherwise be separated are considered one word\nwhen surrounded by quotes (see the description of\n<b>history_tokenize()</b> below). History expansions are\nintroduced by the appearance of the history expansion\ncharacter, which is <b>!</b> by default. Only backslash\n(<b>\\</b>) and single quotes can quote the history expansion\ncharacter.\n\n<b>Event\nDesignators</b> <br>\nAn event designator is a reference to a command line entry\nin the history list. Unless the reference is absolute,\nevents are relative to the current position in the history\nlist.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Start a history substitution, except when followed by a\n<b>blank</b>, newline, = or (.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!</b><i>n</i></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Refer to command line <i>n</i>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!-</b><i>n</i></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Refer to the current command minus <i>n</i>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!!</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Refer to the previous command. This is a synonym for\n&rsquo;!-1&rsquo;. </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>!</b><i>string</i>\n\n<p style=\"margin-left:22%;\">Refer to the most recent\ncommand preceding the current position in the history list\nstarting with <i>string</i>.\n\n\n<p style=\"margin-left:11%;\"><b>!?</b><i>string</i><b>[?]</b>\n\n<p style=\"margin-left:22%;\">Refer to the most recent\ncommand preceding the current position in the history list\ncontaining <i>string</i>. The trailing <b>?</b> may be\nomitted if <i>string</i> is followed immediately by a\nnewline. If <i>string</i> is missing, the string from the\nmost recent search is used; it is an error if there is no\nprevious search string.\n\n<p style=\"margin-left:11%;\"><b><big>^</big></b>\n<i>string1</i> <b><big>^</big></b> <i>string2</i>\n<b><big>^</big></b>\n\n<p style=\"margin-left:22%;\">Quick substitution. Repeat the\nlast command, replacing <i>string1</i> with <i>string2</i>.\nEquivalent to &rsquo;&rsquo;!!:s <big>^</big> <i>string1</i>\n<big>^</big> <i>string2</i> <big>^</big> &rsquo;&rsquo; (see\n<b>Modifiers</b> below).\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>!#</b></td>\n<td width=\"8%\"></td>\n<td width=\"56%\">\n\n\n<p>The entire command line typed so far.</td>\n<td width=\"22%\">\n</td></tr>\n</table>\n\n<b>Word\nDesignators</b> <br>\nWord designators are used to select desired words from the\nevent. A <b>:</b> separates the event specification from the\nword designator. It may be omitted if the word designator\nbegins with a <b>^</b>, <b>$</b>, <b>*</b>, <b>-</b>, or\n<b>%</b>. Words are numbered from the beginning of the line,\nwith the first word being denoted by 0 (zero). Words are\ninserted into the current line separated by single spaces.\n<b><br>\n0 (zero)</b>\n\n<p style=\"margin-left:22%;\">The zeroth word. For the shell,\nthis is the command word.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><i>n</i></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>n</i>th word.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>^</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The first argument. That is, word 1.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>$</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The last word. This is usually the last argument, but\nwill expand to the zeroth word if there is only one word in\nthe line.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>%</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The first word matched by the most recent\n&rsquo;?<i>string</i>?&rsquo; search, if the search string\nbegins with a character that is part of a word.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><i>x</i><b>-</b><i>y</i></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>A range of words; &rsquo;-<i>y</i>&rsquo; abbreviates\n&rsquo;0-<i>y</i>&rsquo;. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>*</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>All of the words but the zeroth. This is a synonym for\n&rsquo;<i>1-$</i>&rsquo;. It is not an error to use <b>*</b>\nif there is just one word in the event; the empty string is\nreturned in that case.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>x*</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Abbreviates <i>x-$</i>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>x-</b></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Abbreviates <i>x-$</i> like <b>x*</b>, but omits the\nlast word. If <b>x</b> is missing, it defaults to 0.</td></tr>\n</table>\n\nIf a word\ndesignator is supplied without an event specification, the\nprevious command is used as the event.\n\n\n<b>Modifiers</b>\n<br>\nAfter the optional word designator, there may appear a\nsequence of one or more of the following modifiers, each\npreceded by a &rsquo;:&rsquo;. These modify, or edit, the\nword or words selected from the history event.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\"><b>h</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Remove a trailing file name\ncomponent, leaving only the head.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>t</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Remove all leading file name components, leaving the\ntail. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>r</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Remove a trailing suffix of the form <i>.xxx</i>,\nleaving the basename.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>e</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Remove all but the trailing suffix.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>p</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Print the new command but do not execute it.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>q</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Quote the substituted words, escaping further\nsubstitutions. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>x</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Quote the substituted words as with <b>q</b>, but break\ninto words at <b>blanks</b> and newlines. The <b>q</b> and\n<b>x</b> modifiers are mutually exclusive; the last one\nsupplied is used.</td></tr>\n</table>\n\n\n<p style=\"margin-left:11%;\"><b>s/</b><i>old</i><b>/</b><i>new</i><b>/</b>\n\n<p style=\"margin-left:22%;\">Substitute <i>new</i> for the\nfirst occurrence of <i>old</i> in the event line. Any\ncharacter may be used as the delimiter in place of /. The\nfinal delimiter is optional if it is the last character of\nthe event line. The delimiter may be quoted in <i>old</i>\nand <i>new</i> with a single backslash. If &amp; appears in\n<i>new</i>, it is replaced by <i>old</i>. A single backslash\nwill quote the &amp;. If <i>old</i> is null, it is set to\nthe last <i>old</i> substituted, or, if no previous history\nsubstitutions took place, the last <i>string</i> in a\n<b>!?</b><i>string</i><b>[?]</b> search. If <i>new</i> is\nnull, each matching <i>old</i> is deleted.\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>&amp;</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Repeat the previous substitution.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>g</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Cause changes to be applied over the entire event line.\nThis is used in conjunction with &rsquo;<b>:s</b>&rsquo;\n(e.g.,\n&rsquo;<b>:gs/</b><i>old</i><b>/</b><i>new</i><b>/</b>&rsquo;)\nor &rsquo;<b>:&amp;</b>&rsquo;. If used with\n&rsquo;<b>:s</b>&rsquo;, any delimiter can be used in place\nof /, and the final delimiter is optional if it is the last\ncharacter of the event line. An <b>a</b> may be used as a\nsynonym for <b>g</b>.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>G</b></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Apply the following &rsquo;<b>s</b>&rsquo; or\n&rsquo;<b>&amp;</b>&rsquo; modifier once to each word in the\nevent line.</td></tr>\n</table>\n\n<h2>PROGRAMMING WITH HISTORY FUNCTIONS\n<a name=\"PROGRAMMING WITH HISTORY FUNCTIONS\"></a>\n</h2>\n\n\nThis section\ndescribes how to use the History library in other\nprograms.\n\n\n<b>Introduction\nto History</b> <br>\nA programmer using the History library has available\nfunctions for remembering lines on a history list,\nassociating arbitrary data with a line, removing lines from\nthe list, searching through the list for a line containing\nan arbitrary text string, and referencing any line in the\nlist directly. In addition, a history <i>expansion</i>\nfunction is available which provides for a consistent user\ninterface across different programs.\n\nThe user using\nprograms written with the History library has the benefit of\na consistent user interface with a set of well-known\ncommands for manipulating the text of previous lines and\nusing that text in new commands. The basic history\nmanipulation commands are identical to the history\nsubstitution provided by <b>bash</b>.\n\nThe programmer\ncan also use the Readline library, which includes some\nhistory manipulation by default, and has the added advantage\nof command line editing.\n\nBefore\ndeclaring any functions using any functionality the History\nlibrary provides in other code, an application writer should\ninclude the file <i>&lt;readline/history.h&gt;</i> in any\nfile that uses the History library&rsquo;s features. It\nsupplies extern declarations for all of the library&rsquo;s\npublic functions and variables, and declares all of the\npublic data structures.\n\n<b>History\nStorage</b> <br>\nThe history list is an array of history entries. A history\nentry is declared as follows:\n\n<i>typedef void\n*</i> <b>histdata_t;</b>\n\ntypedef struct\n_hist_entry { <br>\nchar *line; <br>\nchar *timestamp; <br>\nhistdata_t data; <br>\n} HIST_ENTRY;\n\nThe history\nlist itself might therefore be declared as\n\n<i>HIST_ENTRY\n**</i> <b>the_history_list;</b>\n\nThe state of\nthe History library is encapsulated into a single\nstructure:\n\n/* <br>\n* A structure used to pass around the current state of the\nhistory. <br>\n*/ <br>\ntypedef struct _hist_state { <br>\nHIST_ENTRY **entries; /* Pointer to the entries themselves.\n*/ <br>\nint offset; /* The location pointer within this array. */\n<br>\nint length; /* Number of elements within this array. */ <br>\nint size; /* Number of slots allocated to this array. */\n<br>\nint flags; <br>\n} HISTORY_STATE;\n\nIf the flags\nmember includes <b>HS_STIFLED</b>, the history has been\nstifled.\n\n<h2>History Functions\n<a name=\"History Functions\"></a>\n</h2>\n\n\nThis section\ndescribes the calling sequence for the various functions\nexported by the GNU History library.\n\n\n<b>Initializing\nHistory and State Management</b> <br>\nThis section describes functions used to initialize and\nmanage the state of the History library when you want to use\nthe history functions in your program.\n\n<i>void</i>\n<b>using_history</b> (<i>void</i>) <br>\nBegin a session in which the history functions might be\nused. This initializes the interactive variables.\n\n\n<i>HISTORY_STATE\n*</i> <b>history_get_history_state</b> (<i>void</i>) <br>\nReturn a structure describing the current state of the input\nhistory.\n\n<i>void</i>\n<b>history_set_history_state</b> (<i>HISTORY_STATE\n*state</i>) <br>\nSet the state of the history list according to\n<i>state</i>.\n\n<b>History List\nManagement</b> <br>\nThese functions manage individual entries on the history\nlist, or set parameters managing the list itself.\n\n<i>void</i>\n<b>add_history</b> (<i>const char *string</i>) <br>\nPlace <i>string</i> at the end of the history list. The\nassociated data field (if any) is set to <b>NULL</b>. If the\nmaximum number of history entries has been set using\n<b>stifle_history()</b>, and the new number of history\nentries would exceed that maximum, the oldest history entry\nis removed.\n\n<i>void</i>\n<b>add_history_time</b> (<i>const char *string</i>) <br>\nChange the time stamp associated with the most recent\nhistory entry to <i>string</i>.\n\n<i>HIST_ENTRY\n*</i> <b>remove_history</b> (<i>int which</i>) <br>\nRemove history entry at offset <i>which</i> from the\nhistory. The removed element is returned so you can free the\nline, data, and containing structure.\n\n\n<i>histdata_t</i>\n<b>free_history_entry</b> (<i>HIST_ENTRY *histent</i>) <br>\nFree the history entry <i>histent</i> and any history\nlibrary private data associated with it. Returns the\napplication-specific data so the caller can dispose of\nit.\n\n<i>HIST_ENTRY\n*</i> <b>replace_history_entry</b> (<i>int which, const char\n*line, histdata_t data</i>) <br>\nMake the history entry at offset <i>which</i> have\n<i>line</i> and <i>data</i>. This returns the old entry so\nthe caller can dispose of any application-specific data. In\nthe case of an invalid <i>which</i>, a <b>NULL</b> pointer\nis returned.\n\n<i>void</i>\n<b>clear_history</b> (<i>void</i>) <br>\nClear the history list by deleting all the entries.\n\n<i>void</i>\n<b>stifle_history</b> (<i>int max</i>) <br>\nStifle the history list, remembering only the last\n<i>max</i> entries. The history list will contain only\n<i>max</i> entries at a time.\n\n<i>int</i>\n<b>unstifle_history</b> (<i>void</i>) <br>\nStop stifling the history. This returns the previously-set\nmaximum number of history entries (as set by\n<b>stifle_history()</b>). history was stifled. The value is\npositive if the history was stifled, negative if it\nwasn&rsquo;t.\n\n<i>int</i>\n<b>history_is_stifled</b> (<i>void</i>) <br>\nReturns non-zero if the history is stifled, zero if it is\nnot.\n\n<b>Information\nAbout the History List</b> <br>\nThese functions return information about the entire history\nlist or individual list entries.\n\n<i>HIST_ENTRY\n**</i> <b>history_list</b> (<i>void</i>) <br>\nReturn a <b>NULL</b> terminated array of <i>HIST_ENTRY *</i>\nwhich is the current input history. Element 0 of this list\nis the beginning of time. If there is no history, return\n<b>NULL</b>.\n\n<i>int</i>\n<b>where_history</b> (<i>void</i>) <br>\nReturns the offset of the current history element.\n\n<i>HIST_ENTRY\n*</i> <b>current_history</b> (<i>void</i>) <br>\nReturn the history entry at the current position, as\ndetermined by <b>where_history()</b>. If there is no entry\nthere, return a <b>NULL</b> pointer.\n\n<i>HIST_ENTRY\n*</i> <b>history_get</b> (<i>int offset</i>) <br>\nReturn the history entry at position <i>offset</i>. The\nrange of valid values of <i>offset</i> starts at\n<b>history_base</b> and ends at <b>history_length</b> - 1.\nIf there is no entry there, or if <i>offset</i> is outside\nthe valid range, return a <b>NULL</b> pointer.\n\n<i>time_t</i>\n<b>history_get_time</b> (<i>HIST_ENTRY *</i>) <br>\nReturn the time stamp associated with the history entry\npassed as the argument.\n\n<i>int</i>\n<b>history_total_bytes</b> (<i>void</i>) <br>\nReturn the number of bytes that the primary history entries\nare using. This function returns the sum of the lengths of\nall the lines in the history.\n\n<b>Moving\nAround the History List</b> <br>\nThese functions allow the current index into the history\nlist to be set or changed.\n\n<i>int</i>\n<b>history_set_pos</b> (<i>int pos</i>) <br>\nSet the current history offset to <i>pos</i>, an absolute\nindex into the list. Returns 1 on success, 0 if <i>pos</i>\nis less than zero or greater than the number of history\nentries.\n\n<i>HIST_ENTRY\n*</i> <b>previous_history</b> (<i>void</i>) <br>\nBack up the current history offset to the previous history\nentry, and return a pointer to that entry. If there is no\nprevious entry, return a <b>NULL</b> pointer.\n\n<i>HIST_ENTRY\n*</i> <b>next_history</b> (<i>void</i>) <br>\nIf the current history offset refers to a valid history\nentry, increment the current history offset. If the\npossibly-incremented history offset refers to a valid\nhistory entry, return a pointer to that entry; otherwise,\nreturn a <b>NULL</b> pointer.\n\n<b>Searching\nthe History List</b> <br>\nThese functions allow searching of the history list for\nentries containing a specific string. Searching may be\nperformed both forward and backward from the current history\nposition. The search may be <i>anchored</i>, meaning that\nthe string must match at the beginning of the history\nentry.\n\n<i>int</i>\n<b>history_search</b> (<i>const char *string, int\ndirection</i>) <br>\nSearch the history for <i>string</i>, starting at the\ncurrent history offset. If <i>direction</i> is less than 0,\nthen the search is through previous entries, otherwise\nthrough subsequent entries. If <i>string</i> is found, then\nthe current history index is set to that history entry, and\nthe value returned is the offset in the line of the entry\nwhere <i>string</i> was found. Otherwise, nothing is\nchanged, and a -1 is returned.\n\n<i>int</i>\n<b>history_search_prefix</b> (<i>const char *string, int\ndirection</i>) <br>\nSearch the history for <i>string</i>, starting at the\ncurrent history offset. The search is anchored: matching\nlines must begin with <i>string</i>. If <i>direction</i> is\nless than 0, then the search is through previous entries,\notherwise through subsequent entries. If <i>string</i> is\nfound, then the current history index is set to that entry,\nand the return value is 0. Otherwise, nothing is changed,\nand a -1 is returned.\n\n<i>int</i>\n<b>history_search_pos</b> (<i>const char *string, int\ndirection, int pos</i>) <br>\nSearch for <i>string</i> in the history list, starting at\n<i>pos</i>, an absolute index into the list. If\n<i>direction</i> is negative, the search proceeds backward\nfrom <i>pos</i>, otherwise forward. Returns the absolute\nindex of the history element where <i>string</i> was found,\nor -1 otherwise.\n\n<b>Managing the\nHistory File</b> <br>\nThe History library can read the history from and write it\nto a file. This section documents the functions for managing\na history file.\n\n<i>int</i>\n<b>read_history</b> (<i>const char *filename</i>) <br>\nAdd the contents of <i>filename</i> to the history list, a\nline at a time. If <i>filename</i> is <b>NULL</b>, then read\nfrom <i>~/.history</i>. Returns 0 if successful, or\n<b>errno</b> if not.\n\n<i>int</i>\n<b>read_history_range</b> (<i>const char *filename, int\nfrom, int to</i>) <br>\nRead a range of lines from <i>filename</i>, adding them to\nthe history list. Start reading at line <i>from</i> and end\nat <i>to</i>. If <i>from</i> is zero, start at the\nbeginning. If <i>to</i> is less than <i>from</i>, then read\nuntil the end of the file. If <i>filename</i> is\n<b>NULL</b>, then read from <i>~/.history</i>. Returns 0 if\nsuccessful, or <b>errno</b> if not.\n\n<i>int</i>\n<b>write_history</b> (<i>const char *filename</i>) <br>\nWrite the current history to <i>filename</i>, overwriting\n<i>filename</i> if necessary. If <i>filename</i> is\n<b>NULL</b>, then write the history list to\n<i>~/.history</i>. Returns 0 on success, or <b>errno</b> on\na read or write error.\n\n<i>int</i>\n<b>append_history</b> (<i>int nelements, const char\n*filename</i>) <br>\nAppend the last <i>nelements</i> of the history list to\n<i>filename</i>. If <i>filename</i> is <b>NULL</b>, then\nappend to <i>~/.history</i>. Returns 0 on success, or\n<b>errno</b> on a read or write error.\n\n<i>int</i>\n<b>history_truncate_file</b> (<i>const char *filename, int\nnlines</i>) <br>\nTruncate the history file <i>filename</i>, leaving only the\nlast <i>nlines</i> lines. If <i>filename</i> is <b>NULL</b>,\nthen <i>~/.history</i> is truncated. Returns 0 on success,\nor <b>errno</b> on failure.\n\n<b>History\nExpansion</b> <br>\nThese functions implement history expansion.\n\n<i>int</i>\n<b>history_expand</b> (<i>char *string, char **output</i>)\n<br>\nExpand <i>string</i>, placing the result into <i>output</i>,\na pointer to a string. Returns:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">0</td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">If no expansions took place (or,\nif the only change in the text was the removal of escape\ncharacters preceding the history expansion character);</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>1</td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p>if expansions did take place;</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>-1</td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p>if there was an error in expansion;</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>2</td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p>if the returned line should be displayed, but not\nexecuted, as with the <b>:p</b> modifier.</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">If an error occurred in\nexpansion, then <i>output</i> contains a descriptive error\nmessage.\n\n<i>char *</i>\n<b>get_history_event</b> (<i>const char *string, int\n*cindex, int qchar</i>) <br>\nReturns the text of the history event beginning at\n<i>string</i> + <i>*cindex</i>. <i>*cindex</i> is modified\nto point to after the event specifier. At function entry,\n<i>cindex</i> points to the index into <i>string</i> where\nthe history event specification begins. <i>qchar</i> is a\ncharacter that is allowed to end the event specification in\naddition to the &rsquo;&rsquo;normal&rsquo;&rsquo;\nterminating characters.\n\n<i>char **</i>\n<b>history_tokenize</b> (<i>const char *string</i>) <br>\nReturn an array of tokens parsed out of <i>string</i>, much\nas the shell might. The tokens are split on the characters\nin the <b>history_word_delimiters</b> variable, and shell\nquoting conventions are obeyed.\n\n<i>char *</i>\n<b>history_arg_extract</b> (<i>int first, int last, const\nchar *string</i>) <br>\nExtract a string segment consisting of the <i>first</i>\nthrough <i>last</i> arguments present in <i>string</i>.\nArguments are split using <b>history_tokenize()</b>.\n\n<b>History\nVariables</b> <br>\nThis section describes the externally-visible variables\nexported by the GNU History Library.\n\n<i>int</i>\n<b>history_base</b> <br>\nThe logical offset of the first entry in the history\nlist.\n\n<i>int</i>\n<b>history_length</b> <br>\nThe number of entries currently stored in the history\nlist.\n\n<i>int</i>\n<b>history_max_entries</b> <br>\nThe maximum number of history entries. This must be changed\nusing <b>stifle_history()</b>.\n\n<i>int</i>\n<b>history_write_timestamps</b> <br>\nIf non-zero, timestamps are written to the history file, so\nthey can be preserved between sessions. The default value is\n0, meaning that timestamps are not saved. The current\ntimestamp format uses the value of\n<i>history_comment_char</i> to delimit timestamp entries in\nthe history file. If that variable does not have a value\n(the default), timestamps will not be written.\n\n<i>char</i>\n<b>history_expansion_char</b> <br>\nThe character that introduces a history event. The default\nis <b>!</b>. Setting this to 0 inhibits history\nexpansion.\n\n<i>char</i>\n<b>history_subst_char</b> <br>\nThe character that invokes word substitution if found at the\nstart of a line. The default is <b>^</b>.\n\n<i>char</i>\n<b>history_comment_char</b> <br>\nDuring tokenization, if this character is seen as the first\ncharacter of a word, then it and all subsequent characters\nup to a newline are ignored, suppressing history expansion\nfor the remainder of the line. This is disabled by\ndefault.\n\n<i>char *</i>\n<b>history_word_delimiters</b> <br>\nThe characters that separate tokens for\n<b>history_tokenize()</b>. The default value is\n<b>&quot;&nbsp;\\t\\n()&lt;&gt;;&amp;|&quot;</b>.\n\n<i>char *</i>\n<b>history_no_expand_chars</b> <br>\nThe list of characters which inhibit history expansion if\nfound immediately following <b>history_expansion_char</b>.\nThe default is space, tab, newline, <b>\\r</b>, and\n<b>=</b>.\n\n<i>char *</i>\n<b>history_search_delimiter_chars</b> <br>\nThe list of additional characters which can delimit a\nhistory search string, in addition to space, tab, <i>:</i>\nand <i>?</i> in the case of a substring search. The default\nis empty.\n\n<i>int</i>\n<b>history_quotes_inhibit_expansion</b> <br>\nIf non-zero, double-quoted words are not scanned for the\nhistory expansion character or the history comment\ncharacter. The default value is 0.\n\n\n<i>rl_linebuf_func_t\n*</i> <b>history_inhibit_expansion_function</b> <br>\nThis should be set to the address of a function that takes\ntwo arguments: a <b>char *</b> (<i>string</i>) and an\n<b>int</b> index into that string (<i>i</i>). It should\nreturn a non-zero value if the history expansion starting at\n<i>string[i]</i> should not be performed; zero if the\nexpansion should be done. It is intended for use by\napplications like <b>bash</b> that use the history expansion\ncharacter for additional purposes. By default, this variable\nis set to <b>NULL</b>.\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n\n<i>~/.history</i>\n\n<p style=\"margin-left:22%;\">Default filename for reading\nand writing saved history\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<i>The Gnu\nReadline Library</i>, Brian Fox and Chet Ramey <i><br>\nThe Gnu History Library</i>, Brian Fox and Chet Ramey\n<i><br>\nbash</i>(1) <i><br>\nreadline</i>(3)\n\n<h2>AUTHORS\n<a name=\"AUTHORS\"></a>\n</h2>\n\n\nBrian Fox, Free\nSoftware Foundation <br>\nbfox@gnu.org\n\nChet Ramey,\nCase Western Reserve University <br>\nchet.ramey@case.edu\n\n<h2>BUG REPORTS\n<a name=\"BUG REPORTS\"></a>\n</h2>\n\n\nIf you find a\nbug in the <b>history</b> library, you should report it. But\nfirst, you should make sure that it really is a bug, and\nthat it appears in the latest version of the <b>history</b>\nlibrary that you have.\n\nOnce you have\ndetermined that a bug actually exists, mail a bug report to\n<i>bug-readline</i>@<i>gnu.org</i>. If you have a fix, you\nare welcome to mail that as well! Suggestions and\n&rsquo;philosophical&rsquo; bug reports may be mailed to\n<i>bug-readline</i>@<i>gnu.org</i> or posted to the Usenet\nnewsgroup <b>gnu.bash.bug</b>.\n\nComments and\nbug reports concerning this manual page should be directed\nto <i>chet.ramey@case.edu</i>.","body":"\n\n<h1 align=\"center\">HISTORY</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">history - GNU\nHistory Library</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The GNU History\nLibrary is Copyright (C) 1989-2020 by the Free Software\nFoundation, Inc.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many programs\nread input from the user a line at a time. The GNU History\nlibrary is able to keep track of those lines, associate\narbitrary data with each line, and utilize information from\nprevious lines in composing new ones.</p>\n\n<h2>HISTORY EXPANSION\n<a name=\"HISTORY EXPANSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The history\nlibrary supports a history expansion feature that is\nidentical to the history expansion in <b>bash.</b> This\nsection describes what syntax features are available.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">History\nexpansions introduce words from the history list into the\ninput stream, making it easy to repeat commands, insert the\narguments to a previous command into the current input line,\nor fix errors in previous commands quickly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">History\nexpansion is usually performed immediately after a complete\nline is read. It takes place in two parts. The first is to\ndetermine which line from the history list to use during\nsubstitution. The second is to select portions of that line\nfor inclusion into the current one. The line selected from\nthe history is the <i>event</i>, and the portions of that\nline that are acted upon are <i>words</i>. Various\n<i>modifiers</i> are available to manipulate the selected\nwords. The line is broken into words in the same fashion as\n<b>bash</b> does when reading input, so that several words\nthat would otherwise be separated are considered one word\nwhen surrounded by quotes (see the description of\n<b>history_tokenize()</b> below). History expansions are\nintroduced by the appearance of the history expansion\ncharacter, which is <b>!</b> by default. Only backslash\n(<b>\\</b>) and single quotes can quote the history expansion\ncharacter.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Event\nDesignators</b> <br>\nAn event designator is a reference to a command line entry\nin the history list. Unless the reference is absolute,\nevents are relative to the current position in the history\nlist.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Start a history substitution, except when followed by a\n<b>blank</b>, newline, = or (.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!</b><i>n</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Refer to command line <i>n</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!-</b><i>n</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Refer to the current command minus <i>n</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>!!</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Refer to the previous command. This is a synonym for\n&rsquo;!-1&rsquo;.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>!</b><i>string</i></p>\n\n<p style=\"margin-left:22%;\">Refer to the most recent\ncommand preceding the current position in the history list\nstarting with <i>string</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>!?</b><i>string</i><b>[?]</b></p>\n\n<p style=\"margin-left:22%;\">Refer to the most recent\ncommand preceding the current position in the history list\ncontaining <i>string</i>. The trailing <b>?</b> may be\nomitted if <i>string</i> is followed immediately by a\nnewline. If <i>string</i> is missing, the string from the\nmost recent search is used; it is an error if there is no\nprevious search string.</p>\n\n<p style=\"margin-left:11%;\"><b><big>^</big></b>\n<i>string1</i> <b><big>^</big></b> <i>string2</i>\n<b><big>^</big></b></p>\n\n<p style=\"margin-left:22%;\">Quick substitution. Repeat the\nlast command, replacing <i>string1</i> with <i>string2</i>.\nEquivalent to &rsquo;&rsquo;!!:s <big>^</big> <i>string1</i>\n<big>^</big> <i>string2</i> <big>^</big> &rsquo;&rsquo; (see\n<b>Modifiers</b> below).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>!#</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"56%\">\n\n\n<p>The entire command line typed so far.</p></td>\n<td width=\"22%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Word\nDesignators</b> <br>\nWord designators are used to select desired words from the\nevent. A <b>:</b> separates the event specification from the\nword designator. It may be omitted if the word designator\nbegins with a <b>^</b>, <b>$</b>, <b>*</b>, <b>-</b>, or\n<b>%</b>. Words are numbered from the beginning of the line,\nwith the first word being denoted by 0 (zero). Words are\ninserted into the current line separated by single spaces.\n<b><br>\n0 (zero)</b></p>\n\n<p style=\"margin-left:22%;\">The zeroth word. For the shell,\nthis is the command word.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><i>n</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>n</i>th word.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>^</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The first argument. That is, word 1.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>$</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The last word. This is usually the last argument, but\nwill expand to the zeroth word if there is only one word in\nthe line.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>%</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>The first word matched by the most recent\n&rsquo;?<i>string</i>?&rsquo; search, if the search string\nbegins with a character that is part of a word.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><i>x</i><b>-</b><i>y</i></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>A range of words; &rsquo;-<i>y</i>&rsquo; abbreviates\n&rsquo;0-<i>y</i>&rsquo;.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>*</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>All of the words but the zeroth. This is a synonym for\n&rsquo;<i>1-$</i>&rsquo;. It is not an error to use <b>*</b>\nif there is just one word in the event; the empty string is\nreturned in that case.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>x*</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Abbreviates <i>x-$</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p><b>x-</b></p></td>\n<td width=\"7%\"></td>\n<td width=\"78%\">\n\n\n<p>Abbreviates <i>x-$</i> like <b>x*</b>, but omits the\nlast word. If <b>x</b> is missing, it defaults to 0.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a word\ndesignator is supplied without an event specification, the\nprevious command is used as the event.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Modifiers</b>\n<br>\nAfter the optional word designator, there may appear a\nsequence of one or more of the following modifiers, each\npreceded by a &rsquo;:&rsquo;. These modify, or edit, the\nword or words selected from the history event.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\"><b>h</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Remove a trailing file name\ncomponent, leaving only the head.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>t</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Remove all leading file name components, leaving the\ntail.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>r</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Remove a trailing suffix of the form <i>.xxx</i>,\nleaving the basename.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>e</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Remove all but the trailing suffix.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>p</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Print the new command but do not execute it.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>q</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Quote the substituted words, escaping further\nsubstitutions.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>x</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Quote the substituted words as with <b>q</b>, but break\ninto words at <b>blanks</b> and newlines. The <b>q</b> and\n<b>x</b> modifiers are mutually exclusive; the last one\nsupplied is used.</p></td></tr>\n</table>\n\n\n<p style=\"margin-left:11%;\"><b>s/</b><i>old</i><b>/</b><i>new</i><b>/</b></p>\n\n<p style=\"margin-left:22%;\">Substitute <i>new</i> for the\nfirst occurrence of <i>old</i> in the event line. Any\ncharacter may be used as the delimiter in place of /. The\nfinal delimiter is optional if it is the last character of\nthe event line. The delimiter may be quoted in <i>old</i>\nand <i>new</i> with a single backslash. If &amp; appears in\n<i>new</i>, it is replaced by <i>old</i>. A single backslash\nwill quote the &amp;. If <i>old</i> is null, it is set to\nthe last <i>old</i> substituted, or, if no previous history\nsubstitutions took place, the last <i>string</i> in a\n<b>!?</b><i>string</i><b>[?]</b> search. If <i>new</i> is\nnull, each matching <i>old</i> is deleted.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>&amp;</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Repeat the previous substitution.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>g</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Cause changes to be applied over the entire event line.\nThis is used in conjunction with &rsquo;<b>:s</b>&rsquo;\n(e.g.,\n&rsquo;<b>:gs/</b><i>old</i><b>/</b><i>new</i><b>/</b>&rsquo;)\nor &rsquo;<b>:&amp;</b>&rsquo;. If used with\n&rsquo;<b>:s</b>&rsquo;, any delimiter can be used in place\nof /, and the final delimiter is optional if it is the last\ncharacter of the event line. An <b>a</b> may be used as a\nsynonym for <b>g</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>G</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Apply the following &rsquo;<b>s</b>&rsquo; or\n&rsquo;<b>&amp;</b>&rsquo; modifier once to each word in the\nevent line.</p></td></tr>\n</table>\n\n<h2>PROGRAMMING WITH HISTORY FUNCTIONS\n<a name=\"PROGRAMMING WITH HISTORY FUNCTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This section\ndescribes how to use the History library in other\nprograms.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Introduction\nto History</b> <br>\nA programmer using the History library has available\nfunctions for remembering lines on a history list,\nassociating arbitrary data with a line, removing lines from\nthe list, searching through the list for a line containing\nan arbitrary text string, and referencing any line in the\nlist directly. In addition, a history <i>expansion</i>\nfunction is available which provides for a consistent user\ninterface across different programs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The user using\nprograms written with the History library has the benefit of\na consistent user interface with a set of well-known\ncommands for manipulating the text of previous lines and\nusing that text in new commands. The basic history\nmanipulation commands are identical to the history\nsubstitution provided by <b>bash</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The programmer\ncan also use the Readline library, which includes some\nhistory manipulation by default, and has the added advantage\nof command line editing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before\ndeclaring any functions using any functionality the History\nlibrary provides in other code, an application writer should\ninclude the file <i>&lt;readline/history.h&gt;</i> in any\nfile that uses the History library&rsquo;s features. It\nsupplies extern declarations for all of the library&rsquo;s\npublic functions and variables, and declares all of the\npublic data structures.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>History\nStorage</b> <br>\nThe history list is an array of history entries. A history\nentry is declared as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>typedef void\n*</i> <b>histdata_t;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">typedef struct\n_hist_entry { <br>\nchar *line; <br>\nchar *timestamp; <br>\nhistdata_t data; <br>\n} HIST_ENTRY;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The history\nlist itself might therefore be declared as</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n**</i> <b>the_history_list;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The state of\nthe History library is encapsulated into a single\nstructure:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* <br>\n* A structure used to pass around the current state of the\nhistory. <br>\n*/ <br>\ntypedef struct _hist_state { <br>\nHIST_ENTRY **entries; /* Pointer to the entries themselves.\n*/ <br>\nint offset; /* The location pointer within this array. */\n<br>\nint length; /* Number of elements within this array. */ <br>\nint size; /* Number of slots allocated to this array. */\n<br>\nint flags; <br>\n} HISTORY_STATE;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the flags\nmember includes <b>HS_STIFLED</b>, the history has been\nstifled.</p>\n\n<h2>History Functions\n<a name=\"History Functions\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This section\ndescribes the calling sequence for the various functions\nexported by the GNU History library.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Initializing\nHistory and State Management</b> <br>\nThis section describes functions used to initialize and\nmanage the state of the History library when you want to use\nthe history functions in your program.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>void</i>\n<b>using_history</b> (<i>void</i>) <br>\nBegin a session in which the history functions might be\nused. This initializes the interactive variables.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HISTORY_STATE\n*</i> <b>history_get_history_state</b> (<i>void</i>) <br>\nReturn a structure describing the current state of the input\nhistory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>void</i>\n<b>history_set_history_state</b> (<i>HISTORY_STATE\n*state</i>) <br>\nSet the state of the history list according to\n<i>state</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>History List\nManagement</b> <br>\nThese functions manage individual entries on the history\nlist, or set parameters managing the list itself.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>void</i>\n<b>add_history</b> (<i>const char *string</i>) <br>\nPlace <i>string</i> at the end of the history list. The\nassociated data field (if any) is set to <b>NULL</b>. If the\nmaximum number of history entries has been set using\n<b>stifle_history()</b>, and the new number of history\nentries would exceed that maximum, the oldest history entry\nis removed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>void</i>\n<b>add_history_time</b> (<i>const char *string</i>) <br>\nChange the time stamp associated with the most recent\nhistory entry to <i>string</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n*</i> <b>remove_history</b> (<i>int which</i>) <br>\nRemove history entry at offset <i>which</i> from the\nhistory. The removed element is returned so you can free the\nline, data, and containing structure.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>histdata_t</i>\n<b>free_history_entry</b> (<i>HIST_ENTRY *histent</i>) <br>\nFree the history entry <i>histent</i> and any history\nlibrary private data associated with it. Returns the\napplication-specific data so the caller can dispose of\nit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n*</i> <b>replace_history_entry</b> (<i>int which, const char\n*line, histdata_t data</i>) <br>\nMake the history entry at offset <i>which</i> have\n<i>line</i> and <i>data</i>. This returns the old entry so\nthe caller can dispose of any application-specific data. In\nthe case of an invalid <i>which</i>, a <b>NULL</b> pointer\nis returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>void</i>\n<b>clear_history</b> (<i>void</i>) <br>\nClear the history list by deleting all the entries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>void</i>\n<b>stifle_history</b> (<i>int max</i>) <br>\nStifle the history list, remembering only the last\n<i>max</i> entries. The history list will contain only\n<i>max</i> entries at a time.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>unstifle_history</b> (<i>void</i>) <br>\nStop stifling the history. This returns the previously-set\nmaximum number of history entries (as set by\n<b>stifle_history()</b>). history was stifled. The value is\npositive if the history was stifled, negative if it\nwasn&rsquo;t.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_is_stifled</b> (<i>void</i>) <br>\nReturns non-zero if the history is stifled, zero if it is\nnot.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Information\nAbout the History List</b> <br>\nThese functions return information about the entire history\nlist or individual list entries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n**</i> <b>history_list</b> (<i>void</i>) <br>\nReturn a <b>NULL</b> terminated array of <i>HIST_ENTRY *</i>\nwhich is the current input history. Element 0 of this list\nis the beginning of time. If there is no history, return\n<b>NULL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>where_history</b> (<i>void</i>) <br>\nReturns the offset of the current history element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n*</i> <b>current_history</b> (<i>void</i>) <br>\nReturn the history entry at the current position, as\ndetermined by <b>where_history()</b>. If there is no entry\nthere, return a <b>NULL</b> pointer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n*</i> <b>history_get</b> (<i>int offset</i>) <br>\nReturn the history entry at position <i>offset</i>. The\nrange of valid values of <i>offset</i> starts at\n<b>history_base</b> and ends at <b>history_length</b> - 1.\nIf there is no entry there, or if <i>offset</i> is outside\nthe valid range, return a <b>NULL</b> pointer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>time_t</i>\n<b>history_get_time</b> (<i>HIST_ENTRY *</i>) <br>\nReturn the time stamp associated with the history entry\npassed as the argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_total_bytes</b> (<i>void</i>) <br>\nReturn the number of bytes that the primary history entries\nare using. This function returns the sum of the lengths of\nall the lines in the history.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Moving\nAround the History List</b> <br>\nThese functions allow the current index into the history\nlist to be set or changed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_set_pos</b> (<i>int pos</i>) <br>\nSet the current history offset to <i>pos</i>, an absolute\nindex into the list. Returns 1 on success, 0 if <i>pos</i>\nis less than zero or greater than the number of history\nentries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n*</i> <b>previous_history</b> (<i>void</i>) <br>\nBack up the current history offset to the previous history\nentry, and return a pointer to that entry. If there is no\nprevious entry, return a <b>NULL</b> pointer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>HIST_ENTRY\n*</i> <b>next_history</b> (<i>void</i>) <br>\nIf the current history offset refers to a valid history\nentry, increment the current history offset. If the\npossibly-incremented history offset refers to a valid\nhistory entry, return a pointer to that entry; otherwise,\nreturn a <b>NULL</b> pointer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Searching\nthe History List</b> <br>\nThese functions allow searching of the history list for\nentries containing a specific string. Searching may be\nperformed both forward and backward from the current history\nposition. The search may be <i>anchored</i>, meaning that\nthe string must match at the beginning of the history\nentry.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_search</b> (<i>const char *string, int\ndirection</i>) <br>\nSearch the history for <i>string</i>, starting at the\ncurrent history offset. If <i>direction</i> is less than 0,\nthen the search is through previous entries, otherwise\nthrough subsequent entries. If <i>string</i> is found, then\nthe current history index is set to that history entry, and\nthe value returned is the offset in the line of the entry\nwhere <i>string</i> was found. Otherwise, nothing is\nchanged, and a -1 is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_search_prefix</b> (<i>const char *string, int\ndirection</i>) <br>\nSearch the history for <i>string</i>, starting at the\ncurrent history offset. The search is anchored: matching\nlines must begin with <i>string</i>. If <i>direction</i> is\nless than 0, then the search is through previous entries,\notherwise through subsequent entries. If <i>string</i> is\nfound, then the current history index is set to that entry,\nand the return value is 0. Otherwise, nothing is changed,\nand a -1 is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_search_pos</b> (<i>const char *string, int\ndirection, int pos</i>) <br>\nSearch for <i>string</i> in the history list, starting at\n<i>pos</i>, an absolute index into the list. If\n<i>direction</i> is negative, the search proceeds backward\nfrom <i>pos</i>, otherwise forward. Returns the absolute\nindex of the history element where <i>string</i> was found,\nor -1 otherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Managing the\nHistory File</b> <br>\nThe History library can read the history from and write it\nto a file. This section documents the functions for managing\na history file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>read_history</b> (<i>const char *filename</i>) <br>\nAdd the contents of <i>filename</i> to the history list, a\nline at a time. If <i>filename</i> is <b>NULL</b>, then read\nfrom <i>~/.history</i>. Returns 0 if successful, or\n<b>errno</b> if not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>read_history_range</b> (<i>const char *filename, int\nfrom, int to</i>) <br>\nRead a range of lines from <i>filename</i>, adding them to\nthe history list. Start reading at line <i>from</i> and end\nat <i>to</i>. If <i>from</i> is zero, start at the\nbeginning. If <i>to</i> is less than <i>from</i>, then read\nuntil the end of the file. If <i>filename</i> is\n<b>NULL</b>, then read from <i>~/.history</i>. Returns 0 if\nsuccessful, or <b>errno</b> if not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>write_history</b> (<i>const char *filename</i>) <br>\nWrite the current history to <i>filename</i>, overwriting\n<i>filename</i> if necessary. If <i>filename</i> is\n<b>NULL</b>, then write the history list to\n<i>~/.history</i>. Returns 0 on success, or <b>errno</b> on\na read or write error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>append_history</b> (<i>int nelements, const char\n*filename</i>) <br>\nAppend the last <i>nelements</i> of the history list to\n<i>filename</i>. If <i>filename</i> is <b>NULL</b>, then\nappend to <i>~/.history</i>. Returns 0 on success, or\n<b>errno</b> on a read or write error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_truncate_file</b> (<i>const char *filename, int\nnlines</i>) <br>\nTruncate the history file <i>filename</i>, leaving only the\nlast <i>nlines</i> lines. If <i>filename</i> is <b>NULL</b>,\nthen <i>~/.history</i> is truncated. Returns 0 on success,\nor <b>errno</b> on failure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>History\nExpansion</b> <br>\nThese functions implement history expansion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_expand</b> (<i>char *string, char **output</i>)\n<br>\nExpand <i>string</i>, placing the result into <i>output</i>,\na pointer to a string. Returns:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">0</p></td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">If no expansions took place (or,\nif the only change in the text was the removal of escape\ncharacters preceding the history expansion character);</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>1</p></td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p>if expansions did take place;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>-1</p></td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p>if there was an error in expansion;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>2</p></td>\n<td width=\"7%\"></td>\n<td width=\"68%\">\n\n\n<p>if the returned line should be displayed, but not\nexecuted, as with the <b>:p</b> modifier.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">If an error occurred in\nexpansion, then <i>output</i> contains a descriptive error\nmessage.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char *</i>\n<b>get_history_event</b> (<i>const char *string, int\n*cindex, int qchar</i>) <br>\nReturns the text of the history event beginning at\n<i>string</i> + <i>*cindex</i>. <i>*cindex</i> is modified\nto point to after the event specifier. At function entry,\n<i>cindex</i> points to the index into <i>string</i> where\nthe history event specification begins. <i>qchar</i> is a\ncharacter that is allowed to end the event specification in\naddition to the &rsquo;&rsquo;normal&rsquo;&rsquo;\nterminating characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char **</i>\n<b>history_tokenize</b> (<i>const char *string</i>) <br>\nReturn an array of tokens parsed out of <i>string</i>, much\nas the shell might. The tokens are split on the characters\nin the <b>history_word_delimiters</b> variable, and shell\nquoting conventions are obeyed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char *</i>\n<b>history_arg_extract</b> (<i>int first, int last, const\nchar *string</i>) <br>\nExtract a string segment consisting of the <i>first</i>\nthrough <i>last</i> arguments present in <i>string</i>.\nArguments are split using <b>history_tokenize()</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>History\nVariables</b> <br>\nThis section describes the externally-visible variables\nexported by the GNU History Library.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_base</b> <br>\nThe logical offset of the first entry in the history\nlist.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_length</b> <br>\nThe number of entries currently stored in the history\nlist.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_max_entries</b> <br>\nThe maximum number of history entries. This must be changed\nusing <b>stifle_history()</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_write_timestamps</b> <br>\nIf non-zero, timestamps are written to the history file, so\nthey can be preserved between sessions. The default value is\n0, meaning that timestamps are not saved. The current\ntimestamp format uses the value of\n<i>history_comment_char</i> to delimit timestamp entries in\nthe history file. If that variable does not have a value\n(the default), timestamps will not be written.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char</i>\n<b>history_expansion_char</b> <br>\nThe character that introduces a history event. The default\nis <b>!</b>. Setting this to 0 inhibits history\nexpansion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char</i>\n<b>history_subst_char</b> <br>\nThe character that invokes word substitution if found at the\nstart of a line. The default is <b>^</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char</i>\n<b>history_comment_char</b> <br>\nDuring tokenization, if this character is seen as the first\ncharacter of a word, then it and all subsequent characters\nup to a newline are ignored, suppressing history expansion\nfor the remainder of the line. This is disabled by\ndefault.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char *</i>\n<b>history_word_delimiters</b> <br>\nThe characters that separate tokens for\n<b>history_tokenize()</b>. The default value is\n<b>&quot;&nbsp;\\t\\n()&lt;&gt;;&amp;|&quot;</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char *</i>\n<b>history_no_expand_chars</b> <br>\nThe list of characters which inhibit history expansion if\nfound immediately following <b>history_expansion_char</b>.\nThe default is space, tab, newline, <b>\\r</b>, and\n<b>=</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>char *</i>\n<b>history_search_delimiter_chars</b> <br>\nThe list of additional characters which can delimit a\nhistory search string, in addition to space, tab, <i>:</i>\nand <i>?</i> in the case of a substring search. The default\nis empty.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>int</i>\n<b>history_quotes_inhibit_expansion</b> <br>\nIf non-zero, double-quoted words are not scanned for the\nhistory expansion character or the history comment\ncharacter. The default value is 0.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>rl_linebuf_func_t\n*</i> <b>history_inhibit_expansion_function</b> <br>\nThis should be set to the address of a function that takes\ntwo arguments: a <b>char *</b> (<i>string</i>) and an\n<b>int</b> index into that string (<i>i</i>). It should\nreturn a non-zero value if the history expansion starting at\n<i>string[i]</i> should not be performed; zero if the\nexpansion should be done. It is intended for use by\napplications like <b>bash</b> that use the history expansion\ncharacter for additional purposes. By default, this variable\nis set to <b>NULL</b>.</p>\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>~/.history</i></p>\n\n<p style=\"margin-left:22%;\">Default filename for reading\nand writing saved history</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>The Gnu\nReadline Library</i>, Brian Fox and Chet Ramey <i><br>\nThe Gnu History Library</i>, Brian Fox and Chet Ramey\n<i><br>\nbash</i>(1) <i><br>\nreadline</i>(3)</p>\n\n<h2>AUTHORS\n<a name=\"AUTHORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Brian Fox, Free\nSoftware Foundation <br>\nbfox@gnu.org</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Chet Ramey,\nCase Western Reserve University <br>\nchet.ramey@case.edu</p>\n\n<h2>BUG REPORTS\n<a name=\"BUG REPORTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you find a\nbug in the <b>history</b> library, you should report it. But\nfirst, you should make sure that it really is a bug, and\nthat it appears in the latest version of the <b>history</b>\nlibrary that you have.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once you have\ndetermined that a bug actually exists, mail a bug report to\n<i>bug-readline</i>@<i>gnu.org</i>. If you have a fix, you\nare welcome to mail that as well! Suggestions and\n&rsquo;philosophical&rsquo; bug reports may be mailed to\n<i>bug-readline</i>@<i>gnu.org</i> or posted to the Usenet\nnewsgroup <b>gnu.bash.bug</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Comments and\nbug reports concerning this manual page should be directed\nto <i>chet.ramey@case.edu</i>.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#HISTORY EXPANSION\">HISTORY EXPANSION</a>","<a href=\"#PROGRAMMING WITH HISTORY FUNCTIONS\">PROGRAMMING WITH HISTORY FUNCTIONS</a>","<a href=\"#History Functions\">History Functions</a>","<a href=\"#FILES\">FILES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHORS\">AUTHORS</a>","<a href=\"#BUG REPORTS\">BUG REPORTS</a>"],"level":3}