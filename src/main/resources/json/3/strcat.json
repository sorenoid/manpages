{"name":"strcat","body":"\n\n<h1 align=\"center\">STRCAT</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">strcat, strncat\n- concatenate two strings</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;string.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>char\n*strcat(char *</b><i>dest</i><b>, const char\n*</b><i>src</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>char\n*strncat(char *</b><i>dest</i><b>, const char\n*</b><i>src</i><b>, size_t</b> <i>n</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>strcat</b>() function appends the <i>src</i> string to\nthe <i>dest</i> string, overwriting the terminating null\nbyte ('\\0') at the end of <i>dest</i>, and then adds a\nterminating null byte. The strings may not overlap, and the\n<i>dest</i> string must have enough space for the result. If\n<i>dest</i> is not large enough, program behavior is\nunpredictable; <i>buffer overruns are a favorite avenue for\nattacking secure programs</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>strncat</b>() function is similar, except that</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>it will use at most <i>n</i> bytes from <i>src</i>;\nand</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><i>src</i> does not need to be null-terminated if it\ncontains <i>n</i> or more bytes.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As with\n<b>strcat</b>(), the resulting string in <i>dest</i> is\nalways null-terminated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>src</i>\ncontains <i>n</i> or more bytes, <b>strncat</b>() writes\n<i>n+1</i> bytes to <i>dest</i> (<i>n</i> from <i>src</i>\nplus the terminating null byte). Therefore, the size of\n<i>dest</i> must be at least <i>strlen(dest)+n+1</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A simple\nimplementation of <b>strncat</b>() might be:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">char * <br>\nstrncat(char *dest, const char *src, size_t n) <br>\n{ <br>\nsize_t dest_len = strlen(dest); <br>\nsize_t i;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for (i = 0 ; i\n&lt; n &amp;&amp; src[i] != '\\0' ; i++) <br>\ndest[dest_len + i] = src[i]; <br>\ndest[dest_len + i] = '\\0';</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">return dest;\n<br>\n}</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>strcat</b>() and <b>strncat</b>() functions return a\npointer to the resulting string <i>dest</i>.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3346411.png\" alt=\"Image grohtml-3346411.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008, C89, C99, SVr4, 4.3BSD.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some systems\n(the BSDs, Solaris, and others) provide the following\nfunction:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">size_t\nstrlcat(char *dest, const char *src, size_t size);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\nappends the null-terminated string <i>src</i> to the string\n<i>dest</i>, copying at most <i>size-strlen(dest)-1</i> from\n<i>src</i>, and adds a terminating null byte to the result,\n<i>unless size</i> is less than <i>strlen(dest)</i>. This\nfunction fixes the buffer overrun problem of\n<b>strcat</b>(), but the caller must still handle the\npossibility of data loss if <i>size</i> is too small. The\nfunction returns the length of the string <b>strlcat</b>()\ntried to create; if the return value is greater than or\nequal to <i>size</i>, data loss occurred. If data loss\nmatters, the caller <i>must</i> either check the arguments\nbefore the call, or test the function return value.\n<b>strlcat</b>() is not present in glibc and is not\nstandardized by POSIX, but is available on Linux via the\n<i>libbsd</i> library.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because\n<b>strcat</b>() and <b>strncat</b>() must find the null byte\nthat terminates the string <i>dest</i> using a search that\nstarts at the beginning of the string, the execution time of\nthese functions scales according to the length of the string\n<i>dest</i>. This can be demonstrated by running the program\nbelow. (If the goal is to concatenate many strings to one\ntarget, then manually copying the bytes from each source\nstring while maintaining a pointer to the end of the target\nstring will provide better performance.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;time.h&gt; <br>\n#include &lt;stdio.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\n#define LIM 4000000 <br>\nchar p[LIM + 1]; /* +1 for terminating null byte */ <br>\ntime_t base;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">base =\ntime(NULL); <br>\np[0] = '\\0';</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; LIM; j++) { <br>\nif ((j % 10000) == 0) <br>\nprintf(&quot;%d %jd\\n&quot;, j, (intmax_t) (time(NULL) -\nbase)); <br>\nstrcat(p, &quot;a&quot;); <br>\n} <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/bcopy\">bcopy(3)</a>,\n<a href=\"https://man.page/3/memccpy\">memccpy(3)</a>, <a href=\"https://man.page/3/memcpy\">memcpy(3)</a>, <a href=\"https://man.page/3/strcpy\">strcpy(3)</a>,\n<a href=\"https://man.page/3/string\">string(3)</a>, <a href=\"https://man.page/3/strncpy\">strncpy(3)</a>, <a href=\"https://man.page/3/wcscat\">wcscat(3)</a>,\n<a href=\"https://man.page/3/wcsncat\">wcsncat(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}