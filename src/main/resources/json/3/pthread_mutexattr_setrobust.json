{"name":"pthread_mutexattr_setrobust","body":"\n\n<h1 align=\"center\">PTHREAD_MUTEXATTR_SETROBUST</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pthread_mutexattr_getrobust,\npthread_mutexattr_setrobust - get and set the robustness\nattribute of a mutex attributes object</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;pthread.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\npthread_mutexattr_getrobust(const pthread_mutexattr_t\n*</b><i>attr</i><b>, <br>\nint *</b><i>robustness</i><b>); <br>\nint pthread_mutexattr_setrobust(const pthread_mutexattr_t\n*</b><i>attr</i><b>, <br>\nint</b> <i>robustness</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Compile and\nlink with <i>-pthread</i>.</p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pthread_mutexattr_getrobust</b>(),\n<b>pthread_mutexattr_setrobust</b>():</p>\n\n<p style=\"margin-left:17%;\">_POSIX_C_SOURCE &gt;=\n200809L</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>pthread_mutexattr_getrobust</b>() function places the\nvalue of the robustness attribute of the mutex attributes\nobject referred to by <i>attr</i> in <i>*robustness</i>. The\n<b>pthread_mutexattr_setrobust</b>() function sets the value\nof the robustness attribute of the mutex attributes object\nreferred to by <i>attr</i> to the value specified in\n<i>*robustness</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The robustness\nattribute specifies the behavior of the mutex when the\nowning thread dies without unlocking the mutex. The\nfollowing values are valid for <i>robustness</i>: <b><br>\nPTHREAD_MUTEX_STALLED</b></p>\n\n<p style=\"margin-left:22%;\">This is the default value for a\nmutex attributes object. If a mutex is initialized with the\n<b>PTHREAD_MUTEX_STALLED</b> attribute and its owner dies\nwithout unlocking it, the mutex remains locked afterwards\nand any future attempts to call <a href=\"https://man.page/3/pthread_mutex_lock\">pthread_mutex_lock(3)</a>\non the mutex will block indefinitely.</p>\n\n\n<p style=\"margin-left:11%;\"><b>PTHREAD_MUTEX_ROBUST</b></p>\n\n<p style=\"margin-left:22%;\">If a mutex is initialized with\nthe <b>PTHREAD_MUTEX_ROBUST</b> attribute and its owner dies\nwithout unlocking it, any future attempts to call\n<a href=\"https://man.page/3/pthread_mutex_lock\">pthread_mutex_lock(3)</a> on this mutex will succeed and\nreturn <b>EOWNERDEAD</b> to indicate that the original owner\nno longer exists and the mutex is in an inconsistent state.\nUsually after <b>EOWNERDEAD</b> is returned, the next owner\nshould call <a href=\"https://man.page/3/pthread_mutex_consistent\">pthread_mutex_consistent(3)</a> on the\nacquired mutex to make it consistent again before using it\nany further.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the next\nowner unlocks the mutex using <a href=\"https://man.page/3/pthread_mutex_unlock\">pthread_mutex_unlock(3)</a>\nbefore making it consistent, the mutex will be permanently\nunusable and any subsequent attempts to lock it using\n<a href=\"https://man.page/3/pthread_mutex_lock\">pthread_mutex_lock(3)</a> will fail with the error\n<b>ENOTRECOVERABLE</b>. The only permitted operation on such\na mutex is <a href=\"https://man.page/3/pthread_mutex_destroy\">pthread_mutex_destroy(3)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the next\nowner terminates before calling\n<a href=\"https://man.page/3/pthread_mutex_consistent\">pthread_mutex_consistent(3)</a>, further\n<a href=\"https://man.page/3/pthread_mutex_lock\">pthread_mutex_lock(3)</a> operations on this mutex will\nstill return <b>EOWNERDEAD</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\n<i>attr</i> argument of <b>pthread_mutexattr_getrobust</b>()\nand <b>pthread_mutexattr_setrobust</b>() should refer to a\nmutex attributes object that was initialized by\n<a href=\"https://man.page/3/pthread_mutexattr_init\">pthread_mutexattr_init(3)</a>, otherwise the behavior is\nundefined.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\nthese functions return 0. On error, they return a positive\nerror number.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the glibc\nimplementation, <b>pthread_mutexattr_getrobust</b>() always\nreturn zero.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">A value other than\n<b>PTHREAD_MUTEX_STALLED</b> or <b>PTHREAD_MUTEX_ROBUST</b>\nwas passed to <b>pthread_mutexattr_setrobust</b>().</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pthread_mutexattr_getrobust</b>()\nand <b>pthread_mutexattr_setrobust</b>() were added to glibc\nin version 2.12.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2008.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the Linux\nimplementation, when using process-shared robust mutexes, a\nwaiting thread also receives the <b>EOWNERDEAD</b>\nnotification if the owner of a robust mutex performs an\n<a href=\"https://man.page/2/execve\">execve(2)</a> without first unlocking the mutex. POSIX.1\ndoes not specify this detail, but the same behavior also\noccurs in at least some other implementations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before the\naddition of <b>pthread_mutexattr_getrobust</b>() and\n<b>pthread_mutexattr_setrobust</b>() to POSIX, glibc defined\nthe following equivalent nonstandard functions if\n<b>_GNU_SOURCE</b> was defined:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\npthread_mutexattr_getrobust_np(const pthread_mutexattr_t\n*</b><i>attr</i><b>, <br>\nint *</b><i>robustness</i><b>); <br>\nint pthread_mutexattr_setrobust_np(const pthread_mutexattr_t\n*</b><i>attr</i><b>, <br>\nint</b> <i>robustness</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Correspondingly,\nthe constants <b>PTHREAD_MUTEX_STALLED_NP</b> and\n<b>PTHREAD_MUTEX_ROBUST_NP</b> were also defined.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These\nGNU-specific APIs, which first appeared in glibc 2.4, are\nnowadays obsolete and should not be used in new\nprograms.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow demonstrates the use of the robustness attribute of a\nmutex attributes object. In this program, a thread holding\nthe mutex dies prematurely without unlocking the mutex. The\nmain thread subsequently acquires the mutex successfully and\ngets the error <b>EOWNERDEAD</b>, after which it makes the\nmutex consistent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session shows what we see when running this\nprogram:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./a.out</b> <br>\n[original owner] Setting lock... <br>\n[original owner] Locked. Now exiting without unlocking. <br>\n[main] Attempting to lock the robust mutex. <br>\n[main] pthread_mutex_lock() returned EOWNERDEAD <br>\n[main] Now make the mutex consistent <br>\n[main] Mutex is now consistent; unlocking</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;pthread.h&gt; <br>\n#include &lt;errno.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error_en(en, msg) \\ <br>\ndo { errno = en; perror(msg); exit(EXIT_FAILURE); } while\n(0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static\npthread_mutex_t mtx;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void *\n<br>\noriginal_owner_thread(void *ptr) <br>\n{ <br>\nprintf(&quot;[original owner] Setting lock...\\n&quot;); <br>\npthread_mutex_lock(&amp;mtx); <br>\nprintf(&quot;[original owner] Locked. Now exiting without\nunlocking.\\n&quot;); <br>\npthread_exit(NULL); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\npthread_t thr; <br>\npthread_mutexattr_t attr; <br>\nint s;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pthread_mutexattr_init(&amp;attr);\n<br>\n/* initialize the attributes object */ <br>\npthread_mutexattr_setrobust(&amp;attr,\nPTHREAD_MUTEX_ROBUST); <br>\n/* set robustness */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pthread_mutex_init(&amp;mtx,\n&amp;attr); /* initialize the mutex */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pthread_create(&amp;thr,\nNULL, original_owner_thread, NULL);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sleep(2);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/*\n&quot;original_owner_thread&quot; should have exited by now\n*/</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;[main]\nAttempting to lock the robust mutex.\\n&quot;); <br>\ns = pthread_mutex_lock(&amp;mtx); <br>\nif (s == EOWNERDEAD) { <br>\nprintf(&quot;[main] pthread_mutex_lock() returned\nEOWNERDEAD\\n&quot;); <br>\nprintf(&quot;[main] Now make the mutex consistent\\n&quot;);\n<br>\ns = pthread_mutex_consistent(&amp;mtx); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_mutex_consistent&quot;);\n<br>\nprintf(&quot;[main] Mutex is now consistent;\nunlocking\\n&quot;); <br>\ns = pthread_mutex_unlock(&amp;mtx); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_mutex_unlock&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n} else if (s == 0) { <br>\nprintf(&quot;[main] pthread_mutex_lock() unexpectedly\nsucceeded\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} else { <br>\nprintf(&quot;[main] pthread_mutex_lock() unexpectedly\nfailed\\n&quot;); <br>\nhandle_error_en(s, &quot;pthread_mutex_lock&quot;); <br>\n} <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/get_robust_list\">get_robust_list(2)</a>,\n<a href=\"https://man.page/2/set_robust_list\">set_robust_list(2)</a>,\n<a href=\"https://man.page/3/pthread_mutex_consistent\">pthread_mutex_consistent(3)</a>,\n<a href=\"https://man.page/3/pthread_mutex_init\">pthread_mutex_init(3)</a>, <a href=\"https://man.page/3/pthread_mutex_lock\">pthread_mutex_lock(3)</a>,\n<a href=\"https://man.page/7/pthreads\">pthreads(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}