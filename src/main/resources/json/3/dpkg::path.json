{"name":"dpkg::path","description":"Dpkg::Path -\nsome common path handling functions\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nIt provides\nsome functions to handle various path.\n\n<h2>FUNCTIONS\n<a name=\"FUNCTIONS\"></a>\n</h2>\n\n\n\nget_pkg_root_dir($file)\n\n<p style=\"margin-left:23%;\">This function will scan upwards\nthe hierarchy of directory to find out the directory which\ncontains the &quot; <small>DEBIAN&quot;</small>\nsub-directory and it will return its path. This directory is\nthe root directory of a package being built.\n\n<p style=\"margin-left:23%; margin-top: 1em\">If no\n<small>DEBIAN</small> subdirectory is found, it will return\nundef.\n\n\n<p style=\"margin-left:11%;\">relative_to_pkg_root($file)\n\n<p style=\"margin-left:23%;\">Returns the filename relative\nto get_pkg_root_dir($file).\n\n<p style=\"margin-left:11%;\">guess_pkg_root_dir($file)\n\n<p style=\"margin-left:23%;\">This function tries to guess\nthe root directory of the package build tree. It will first\nuse <b>get_pkg_root_dir()</b>, but it will fallback to a\nmore imprecise check: namely it will use the parent\ndirectory that is a sub-directory of the debian\ndirectory.\n\n<p style=\"margin-left:23%; margin-top: 1em\">It can still\nreturn undef if a file outside of the debian sub-directory\nis provided.\n\n\n<p style=\"margin-left:11%;\">check_files_are_the_same($file1,\n$file2, $resolve_symlink)\n\n<p style=\"margin-left:23%;\">This function verifies that\nboth files are the same by checking that the device numbers\nand the inode numbers returned by\n<b>stat()</b>/<b>lstat()</b> are the same. If\n$resolve_symlink is true then <b>stat()</b> is used,\notherwise <b>lstat()</b> is used.\n\n<p style=\"margin-left:11%;\">canonpath($file)\n\n<p style=\"margin-left:23%;\">This function returns a cleaned\npath. It simplifies double //, and remove /./ and /../\nintelligently. For /../ it simplifies the path only if the\nprevious element is not a symlink. Thus it should only be\nused on real filenames.\n\n<p style=\"margin-left:11%;\">$newpath =\nresolve_symlink($symlink)\n\n<p style=\"margin-left:23%;\">Return the filename of the file\npointed by the symlink. The new name is canonicalized by\n<b>canonpath()</b>.\n\n\n<p style=\"margin-left:11%;\">check_directory_traversal($basedir,\n$dir)\n\n<p style=\"margin-left:23%;\">This function verifies that the\ndirectory $dir does not contain any symlink that goes beyond\n$basedir (which should be either equal or a parent of\n$dir).\n\n<p style=\"margin-left:11%;\">$cmdpath =\nfind_command($command)\n\n<p style=\"margin-left:23%;\">Return the path of the command\nif defined and available on an absolute or relative path or\non the $PATH, undef otherwise.\n\n<p style=\"margin-left:11%;\">$control_file =\nget_control_path($pkg, $filetype)\n\n<p style=\"margin-left:23%;\">Return the path of the control\nfile of type $filetype for the given package.\n\n<p style=\"margin-left:11%;\">@control_files =\nget_control_path($pkg)\n\n<p style=\"margin-left:23%;\">Return the path of all\navailable control files for the given package.\n\n<p style=\"margin-left:11%;\">$file =\nfind_build_file($basename)\n\n<p style=\"margin-left:23%;\">Selects the right variant of\nthe given file: the arch-specific variant\n(&quot;$basename.$arch&quot;) has priority over the\nOS-specific variant (&quot;$basename.$os&quot;) which has\npriority over the default variant (&quot;$basename&quot;).\nIf none of the files exists, then it returns undef.\n\n<p style=\"margin-left:11%;\">@files =\nfind_build_file($basename)\n\n<p style=\"margin-left:23%;\">Return the available variants\nof the given file. Returns an empty list if none of the\nfiles exists.\n\n<h2>CHANGES\n<a name=\"CHANGES\"></a>\n</h2>\n\n\n<b>Version 1.05\n(dpkg 1.20.4)</b> <br>\nNew function: <b>check_directory_traversal()</b>.\n\n<b>Version 1.04\n(dpkg 1.17.11)</b> <br>\nUpdate semantics: <b>find_command()</b> now handles an empty\nor undef argument.\n\n<b>Version 1.03\n(dpkg 1.16.1)</b> <br>\nNew function: <b>find_build_file()</b>\n\n<b>Version 1.02\n(dpkg 1.16.0)</b> <br>\nNew function: <b>get_control_path()</b>\n\n<b>Version 1.01\n(dpkg 1.15.8)</b> <br>\nNew function: <b>find_command()</b>\n\n<b>Version 1.00\n(dpkg 1.15.6)</b> <br>\nMark the module as public.","body":"\n\n<h1 align=\"center\">Dpkg::Path</h1>\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Dpkg::Path -\nsome common path handling functions</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">It provides\nsome functions to handle various path.</p>\n\n<h2>FUNCTIONS\n<a name=\"FUNCTIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">get_pkg_root_dir($file)</p>\n\n<p style=\"margin-left:23%;\">This function will scan upwards\nthe hierarchy of directory to find out the directory which\ncontains the &quot; <small>DEBIAN&quot;</small>\nsub-directory and it will return its path. This directory is\nthe root directory of a package being built.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If no\n<small>DEBIAN</small> subdirectory is found, it will return\nundef.</p>\n\n\n<p style=\"margin-left:11%;\">relative_to_pkg_root($file)</p>\n\n<p style=\"margin-left:23%;\">Returns the filename relative\nto get_pkg_root_dir($file).</p>\n\n<p style=\"margin-left:11%;\">guess_pkg_root_dir($file)</p>\n\n<p style=\"margin-left:23%;\">This function tries to guess\nthe root directory of the package build tree. It will first\nuse <b>get_pkg_root_dir()</b>, but it will fallback to a\nmore imprecise check: namely it will use the parent\ndirectory that is a sub-directory of the debian\ndirectory.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">It can still\nreturn undef if a file outside of the debian sub-directory\nis provided.</p>\n\n\n<p style=\"margin-left:11%;\">check_files_are_the_same($file1,\n$file2, $resolve_symlink)</p>\n\n<p style=\"margin-left:23%;\">This function verifies that\nboth files are the same by checking that the device numbers\nand the inode numbers returned by\n<b>stat()</b>/<b>lstat()</b> are the same. If\n$resolve_symlink is true then <b>stat()</b> is used,\notherwise <b>lstat()</b> is used.</p>\n\n<p style=\"margin-left:11%;\">canonpath($file)</p>\n\n<p style=\"margin-left:23%;\">This function returns a cleaned\npath. It simplifies double //, and remove /./ and /../\nintelligently. For /../ it simplifies the path only if the\nprevious element is not a symlink. Thus it should only be\nused on real filenames.</p>\n\n<p style=\"margin-left:11%;\">$newpath =\nresolve_symlink($symlink)</p>\n\n<p style=\"margin-left:23%;\">Return the filename of the file\npointed by the symlink. The new name is canonicalized by\n<b>canonpath()</b>.</p>\n\n\n<p style=\"margin-left:11%;\">check_directory_traversal($basedir,\n$dir)</p>\n\n<p style=\"margin-left:23%;\">This function verifies that the\ndirectory $dir does not contain any symlink that goes beyond\n$basedir (which should be either equal or a parent of\n$dir).</p>\n\n<p style=\"margin-left:11%;\">$cmdpath =\nfind_command($command)</p>\n\n<p style=\"margin-left:23%;\">Return the path of the command\nif defined and available on an absolute or relative path or\non the $PATH, undef otherwise.</p>\n\n<p style=\"margin-left:11%;\">$control_file =\nget_control_path($pkg, $filetype)</p>\n\n<p style=\"margin-left:23%;\">Return the path of the control\nfile of type $filetype for the given package.</p>\n\n<p style=\"margin-left:11%;\">@control_files =\nget_control_path($pkg)</p>\n\n<p style=\"margin-left:23%;\">Return the path of all\navailable control files for the given package.</p>\n\n<p style=\"margin-left:11%;\">$file =\nfind_build_file($basename)</p>\n\n<p style=\"margin-left:23%;\">Selects the right variant of\nthe given file: the arch-specific variant\n(&quot;$basename.$arch&quot;) has priority over the\nOS-specific variant (&quot;$basename.$os&quot;) which has\npriority over the default variant (&quot;$basename&quot;).\nIf none of the files exists, then it returns undef.</p>\n\n<p style=\"margin-left:11%;\">@files =\nfind_build_file($basename)</p>\n\n<p style=\"margin-left:23%;\">Return the available variants\nof the given file. Returns an empty list if none of the\nfiles exists.</p>\n\n<h2>CHANGES\n<a name=\"CHANGES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Version 1.05\n(dpkg 1.20.4)</b> <br>\nNew function: <b>check_directory_traversal()</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Version 1.04\n(dpkg 1.17.11)</b> <br>\nUpdate semantics: <b>find_command()</b> now handles an empty\nor undef argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Version 1.03\n(dpkg 1.16.1)</b> <br>\nNew function: <b>find_build_file()</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Version 1.02\n(dpkg 1.16.0)</b> <br>\nNew function: <b>get_control_path()</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Version 1.01\n(dpkg 1.15.8)</b> <br>\nNew function: <b>find_command()</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Version 1.00\n(dpkg 1.15.6)</b> <br>\nMark the module as public.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#FUNCTIONS\">FUNCTIONS</a>","<a href=\"#CHANGES\">CHANGES</a>"],"level":3}