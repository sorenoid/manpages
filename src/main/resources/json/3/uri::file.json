{"name":"uri::file","description":"URI::file - URI that maps to local file names","body":"\n\n<h1 align=\"center\">URI::file</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">URI::file - URI\nthat maps to local file names</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use URI::file;\n<br>\n$u1 = URI-&gt;new(&quot;file:/foo/bar&quot;); <br>\n$u2 = URI-&gt;new(&quot;foo/bar&quot;, &quot;file&quot;);\n<br>\n$u3 = URI::file-&gt;new($path); <br>\n$u4 = URI::file-&gt;new(&quot;c:\\\\windows\\\\&quot;,\n&quot;win32&quot;); <br>\n$u1-&gt;file; <br>\n$u1-&gt;file(&quot;mac&quot;);</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;URI::file&quot; class supports &quot;URI&quot; objects\nbelonging to the <i>file</i> <small>URI</small> scheme. This\nscheme allows us to map the conventional file names found on\nvarious computer systems to the <small>URI</small> name\nspace. An old specification of the <i>file</i>\n<small>URI</small> scheme is found in <small>RFC\n1738.</small> Some older background information is also in\n<small>RFC 1630.</small> There are no newer specifications\nas far as I know.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you simply\nwant to construct <i>file</i> <small>URI</small> objects\nfrom <small>URI</small> strings, use the normal\n&quot;URI&quot; constructor. If you want to construct\n<i>file</i> <small>URI</small> objects from the actual file\nnames used by various systems, then use one of the following\n&quot;URI::file&quot; constructors: <br>\n$u = URI::file-&gt;new( $filename, [$os] )</p>\n\n<p style=\"margin-left:17%;\">Maps a file name to the\n<i>file:</i> <small>URI</small> name space, creates a\n<small>URI</small> object and returns it. The $filename is\ninterpreted as belonging to the indicated operating system\n($os), which defaults to the value of the $^O variable. The\n$filename can be either absolute or relative, and the\ncorresponding type of <small>URI</small> object for $os is\nreturned.</p>\n\n<p style=\"margin-left:11%;\">$u = URI::file-&gt;new_abs(\n$filename, [$os] )</p>\n\n<p style=\"margin-left:17%;\">Same as URI::file-&gt;new, but\nmakes sure that the <small>URI</small> returned represents\nan absolute file name. If the $filename argument is\nrelative, then the name is resolved relative to the current\ndirectory, i.e. this constructor is really the same as:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">URI::file-&gt;new($filename)-&gt;abs(URI::file-&gt;cwd);</p>\n\n<p style=\"margin-left:11%;\">$u = URI::file-&gt;cwd</p>\n\n<p style=\"margin-left:17%;\">Returns a <i>file</i>\n<small>URI</small> that represents the current working\ndirectory. See Cwd.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethods are supported for <i>file</i> <small>URI</small> (in\naddition to the common and generic methods described in\n<small>URI</small> ): <br>\n$u-&gt;file( [$os] )</p>\n\n<p style=\"margin-left:17%;\">Returns a file name. It maps\nfrom the <small>URI</small> name space to the file name\nspace of the indicated operating system.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">It might return\n&quot;undef&quot; if the name can not be represented in the\nindicated file system.</p>\n\n<p style=\"margin-left:11%;\">$u-&gt;dir( [$os] )</p>\n\n<p style=\"margin-left:17%;\">Some systems use a different\nform for names of directories than for plain files. Use this\nmethod if you know you want to use the name for a\ndirectory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;URI::file&quot; module can be used to map generic file\nnames to names suitable for the current system. As such, it\ncan work as a nice replacement for the\n&quot;File::Spec&quot; module. For instance, the following\ncode translates the UNIX-style file name <i>Foo/Bar.pm</i>\nto a name suitable for the local system:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$file =\nURI::file-&gt;new(&quot;Foo/Bar.pm&quot;,\n&quot;unix&quot;)-&gt;file; <br>\ndie &quot;Can't map filename Foo/Bar.pm for $^O&quot; unless\ndefined $file; <br>\nopen(FILE, $file) || die &quot;Can't open '$file': $!&quot;;\n<br>\n# do something with FILE</p>\n\n<h2>MAPPING NOTES\n<a name=\"MAPPING NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Most computer\nsystems today have hierarchically organized file systems.\nMapping the names used in these systems to the generic\n<small>URI</small> syntax allows us to work with relative\nfile URIs that behave as they should when resolved using the\ngeneric algorithm for URIs (specified in <small>RFC\n2396</small> ). Mapping a file name to the generic\n<small>URI</small> syntax involves mapping the path\nseparator character to &quot;/&quot; and encoding any\nreserved characters that appear in the path segments of the\nfile name. If path segments consisting of the strings\n&quot;.&quot; or &quot;..&quot; have a different meaning\nthan what is specified for generic URIs, then these must be\nencoded as well.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the file\nsystem has device, volume or drive specifications as the\nroot of the name space, then it makes sense to map them to\nthe authority field of the generic <small>URI</small>\nsyntax. This makes sure that relative URIs can not be\nresolved &quot;above&quot; them, i.e. generally how relative\nfile names work in those systems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another common\nuse of the authority field is to encode the host on which\nthis file name is valid. The host name &quot;localhost&quot;\nis special and generally has the same meaning as a missing\nor empty authority field. This use is in conflict with using\nit as a device specification, but can often be resolved for\ndevice specifications having characters not legal in plain\nhost names.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">File name to\n<small>URI</small> mapping in normally not one-to-one. There\nare usually many URIs that map to any given file name. For\ninstance, an authority of &quot;localhost&quot; maps the\nsame as a <small>URI</small> with a missing or empty\nauthority.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Example 1: The\nMac classic (Mac <small>OS 9</small> and earlier) used\n&quot;:&quot; as path separator, but not in the same way as\na generic <small>URI.</small> &quot;:foo&quot; was a\nrelative name. &quot;foo:bar&quot; was an absolute name.\nAlso, path segments could contain the &quot;/&quot;\ncharacter as well as the literal &quot;.&quot; or\n&quot;..&quot;. So the mapping looks like this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Mac classic URI\n<br>\n---------- ------------------- <br>\n:foo:bar &lt;==&gt; foo/bar <br>\n: &lt;==&gt; ./ <br>\n::foo:bar &lt;==&gt; ../foo/bar <br>\n::: &lt;==&gt; ../../ <br>\nfoo:bar &lt;==&gt; file:/foo/bar <br>\nfoo:bar: &lt;==&gt; file:/foo/bar/ <br>\n.. &lt;==&gt; %2E%2E <br>\n&lt;undef&gt; &lt;== / <br>\nfoo/ &lt;== file:/foo%2F <br>\n./foo.txt &lt;== file:/.%2Ffoo.txt</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that if\nyou want a relative <small>URL,</small> you *must* begin the\npath with a :. Any path that begins with [^:] is treated as\nabsolute.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Example 2: The\n<small>UNIX</small> file system is easy to map, as it uses\nthe same path separator as URIs, has a single root, and\nsegments of &quot;.&quot; and &quot;..&quot; have the same\nmeaning. URIs that have the character &quot;\\0&quot; or\n&quot;/&quot; as part of any path segment can not be turned\ninto valid <small>UNIX</small> file names.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">UNIX URI <br>\n---------- ------------------ <br>\nfoo/bar &lt;==&gt; foo/bar <br>\n/foo/bar &lt;==&gt; file:/foo/bar <br>\n/foo/bar &lt;== file://localhost/foo/bar <br>\nfile: ==&gt; ./file: <br>\n&lt;undef&gt; &lt;== file:/fo%00/bar <br>\n/ &lt;==&gt; file:/</p>\n\n<h2>CONFIGURATION VARIABLES\n<a name=\"CONFIGURATION VARIABLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nconfiguration variables influence how the class and its\nmethods behave: <br>\n%URI::file::OS_CLASS</p>\n\n<p style=\"margin-left:17%;\">This hash maps\n<small>OS</small> identifiers to implementation classes. You\nmight want to add or modify this if you want to plug in your\nown file handler class. Normally the keys should match the\n$^O values in use.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If there is no\nmapping then the &quot;Unix&quot; implementation is\nused.</p>\n\n\n<p style=\"margin-left:11%;\">$URI::file::DEFAULT_AUTHORITY</p>\n\n<p style=\"margin-left:17%;\">This determine what\n&quot;authority&quot; string to include in absolute file\nURIs. It defaults to &quot;&quot;. If you prefer verbose\nURIs you might set it to be &quot;localhost&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Setting this\nvalue to &quot;undef&quot; force behaviour compatible to\n<small>URI</small> v1.31 and earlier. In this mode host\nnames in <small>UNC</small> paths and drive letters are\nmapped to the authority component on Windows, while we\nproduce authority-less URIs on Unix.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>URI</small>\n, File::Spec, perlport</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n1995-1998,2004 Gisle Aas.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#MAPPING NOTES\">MAPPING NOTES</a>","<a href=\"#CONFIGURATION VARIABLES\">CONFIGURATION VARIABLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":3}