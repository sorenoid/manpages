{"name":"libnftables","body":"\n\n<h1 align=\"center\">LIBNFTABLES</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">libnftables -\nnftables frontend library</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;nftables/libnftables.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct\nnft_ctx *nft_ctx_new(uint32_t</b> <i>flags</i><b>); <br>\nvoid nft_ctx_free(struct nft_ctx</b>\n<i>*ctx</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool\nnft_ctx_get_dry_run(struct nft_ctx</b> <i>*ctx</i><b>); <br>\nvoid nft_ctx_set_dry_run(struct nft_ctx</b> <i>*ctx</i><b>,\nbool</b> <i>dry</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>unsigned int\nnft_ctx_output_get_flags(struct nft_ctx</b> <i>*ctx</i><b>);\n<br>\nvoid nft_ctx_output_set_flags(struct nft_ctx</b>\n<i>*ctx</i><b>, unsigned int</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>unsigned int\nnft_ctx_output_get_debug(struct nft_ctx</b> <i>*ctx</i><b>);\n<br>\nvoid nft_ctx_output_set_debug(struct nft_ctx</b>\n<i>*ctx</i><b>, unsigned int</b> <i>mask</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>FILE\n*nft_ctx_set_output(struct nft_ctx</b> <i>*ctx</i><b>,\nFILE</b> <i>*fp</i><b>); <br>\nint nft_ctx_buffer_output(struct nft_ctx</b>\n<i>*ctx</i><b>); <br>\nint nft_ctx_unbuffer_output(struct nft_ctx</b>\n<i>*ctx</i><b>); <br>\nconst char *nft_ctx_get_output_buffer(struct nft_ctx</b>\n<i>*ctx</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>FILE\n*nft_ctx_set_error(struct nft_ctx</b> <i>*ctx</i><b>,\nFILE</b> <i>*fp</i><b>); <br>\nint nft_ctx_buffer_error(struct nft_ctx</b> <i>*ctx</i><b>);\n<br>\nint nft_ctx_unbuffer_error(struct nft_ctx</b>\n<i>*ctx</i><b>); <br>\nconst char *nft_ctx_get_error_buffer(struct nft_ctx</b>\n<i>*ctx</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nnft_ctx_add_include_path(struct nft_ctx</b> <i>*ctx</i><b>,\nconst char</b> <i>*path</i><b>); <br>\nvoid nft_ctx_clear_include_paths(struct nft_ctx</b>\n<i>*ctx</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nnft_run_cmd_from_buffer(struct nft_ctx</b> <i>*nft</i><b>,\nconst char</b> <i>*buf</i><b>); <br>\nint nft_run_cmd_from_filename(struct nft_ctx</b>\n<i>*nft</i><b>, <br>\nconst char</b> <i>*filename</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Link with\n<i>-lnftables</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library\nwas designed with nftables integration into applications in\nmind. Its API is therefore kept as simple as possible, which\nsomewhat limits its flexibility. Due to support for JSON\nmarkup of input and output though, convenience in\nconstructing and parsing of input and output data may be\nachieved by using a third-party library such as\n<b>libjansson</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">At the very\nbasic level, one has to allocate a new object of type\n<b>struct nft_ctx</b> using <b>nft_ctx_new</b>() function,\nthen pass commands via <b>nft_run_cmd_from_buffer</b>() or\n<b>nft_run_cmd_from_filename</b>() functions. By default,\nany output is written to <b>stdout</b> (or <b>stderr</b> for\nerror messages). These file pointers may be changed using\n<b>nft_ctx_set_output</b>() and <b>nft_ctx_set_error</b>()\nfunctions. On top of that, it is possible to have any output\nbuffered by the library for later retrieval as a static\nbuffer. See <b>nft_ctx_buffer_output</b>() and\n<b>nft_ctx_buffer_error</b>() functions for details.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>nft_ctx_new()\nand nft_ctx_free()</b> <br>\nThese functions aid in nft context management. In order to\nmake use of the library, at least one context object has to\nbe allocated. The context holds temporary data such as\ncaches, library configuration and (if enabled) output and\nerror buffers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_new</b>() function allocates and returns a new\ncontext object. The parameter <i>flags</i> is unused at this\npoint and should be set to zero. For convenience, the macro\n<b>NFT_CTX_DEFAULT</b> is defined to that value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_free</b>() function frees the context object\npointed to by <i>ctx</i>, including any caches or buffers it\nmay hold.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>nft_ctx_get_dry_run()\nand nft_ctx_set_dry_run()</b> <br>\nDry-run setting controls whether ruleset changes are\nactually committed on kernel side or not. It allows to check\nwhether a given operation would succeed without making\nactual changes to the ruleset. The default setting is\n<b>false</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_get_dry_run</b>() function returns the dry-run\nsetting&rsquo;s value contained in <i>ctx</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_set_dry_run</b>() function sets the dry-run\nsetting in <i>ctx</i> to the value of <i>dry</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>nft_ctx_output_get_flags()\nand nft_ctx_output_set_flags()</b> <br>\nThe flags setting controls the output format.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">enum { <br>\nNFT_CTX_OUTPUT_REVERSEDNS = (1 &lt;&lt; 0), <br>\nNFT_CTX_OUTPUT_SERVICE = (1 &lt;&lt; 1), <br>\nNFT_CTX_OUTPUT_STATELESS = (1 &lt;&lt; 2), <br>\nNFT_CTX_OUTPUT_HANDLE = (1 &lt;&lt; 3), <br>\nNFT_CTX_OUTPUT_JSON = (1 &lt;&lt; 4), <br>\nNFT_CTX_OUTPUT_ECHO = (1 &lt;&lt; 5), <br>\nNFT_CTX_OUTPUT_GUID = (1 &lt;&lt; 6), <br>\nNFT_CTX_OUTPUT_NUMERIC_PROTO = (1 &lt;&lt; 7), <br>\nNFT_CTX_OUTPUT_NUMERIC_PRIO = (1 &lt;&lt; 8), <br>\nNFT_CTX_OUTPUT_NUMERIC_SYMBOL = (1 &lt;&lt; 9), <br>\nNFT_CTX_OUTPUT_NUMERIC_TIME = (1 &lt;&lt; 10), <br>\nNFT_CTX_OUTPUT_NUMERIC_ALL = (NFT_CTX_OUTPUT_NUMERIC_PROTO |\n<br>\nNFT_CTX_OUTPUT_NUMERIC_PRIO | <br>\nNFT_CTX_OUTPUT_NUMERIC_SYMBOL | <br>\nNFT_CTX_OUTPUT_NUMERIC_TIME), <br>\nNFT_CTX_OUTPUT_TERSE = (1 &lt;&lt; 11), <br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_REVERSEDNS</p>\n\n<p style=\"margin-left:17%;\">Reverse DNS lookups are\nperformed for IP addresses when printing. Note that this may\nadd significant delay to <b>list</b> commands depending on\nDNS resolver speed.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_SERVICE</p>\n\n<p style=\"margin-left:17%;\">Print port numbers as services\nas described in the /etc/services file.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_STATELESS</p>\n\n<p style=\"margin-left:17%;\">If stateless output has been\nrequested, then stateful data is not printed. Stateful data\nrefers to those objects that carry run-time data, e.g. the\n<b>counter</b> statement holds packet and byte counter\nvalues, making it stateful.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_HANDLE</p>\n\n<p style=\"margin-left:17%;\">Upon insertion into the\nruleset, some elements are assigned a unique handle for\nidentification purposes. For example, when deleting a table\nor chain, it may be identified either by name or handle.\nRules on the other hand must be deleted by handle, because\nthere is no other way to uniquely identify them. This flag\nmakes ruleset listings include handle values.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_JSON</p>\n\n<p style=\"margin-left:17%;\">If enabled at compile-time,\nlibnftables accepts input in JSON format and is able to\nprint output in JSON format as well. See\n<a href=\"https://man.page/5/libnftables-json\">libnftables-json(5)</a> for a description of the\nsupported schema. This flag controls JSON output format,\ninput is auto-detected.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_ECHO</p>\n\n<p style=\"margin-left:17%;\">The echo setting makes\nlibnftables print the changes once they are committed to the\nkernel, just like a running instance of <b>nft monitor</b>\nwould. Amongst other things, this allows to retrieve an\nadded rule&rsquo;s handle atomically.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_GUID</p>\n\n<p style=\"margin-left:17%;\">Display UID and GID as\ndescribed in the /etc/passwd and /etc/group files.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_NUMERIC_PROTO</p>\n\n<p style=\"margin-left:17%;\">Display layer 4 protocol\nnumerically.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_NUMERIC_PRIO</p>\n\n<p style=\"margin-left:17%;\">Display base chain priority\nnumerically.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_NUMERIC_SYMBOL</p>\n\n<p style=\"margin-left:17%;\">Display expression datatype as\nnumeric value.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_NUMERIC_TIME</p>\n\n<p style=\"margin-left:17%;\">Display time, day and hour\nvalues in numeric format.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_NUMERIC_ALL</p>\n\n<p style=\"margin-left:17%;\">Display all numerically.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_CTX_OUTPUT_TERSE</p>\n\n<p style=\"margin-left:17%;\">If terse output has been\nrequested, then the contents of sets are not printed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_output_get_flags</b>() function returns the\noutput flags setting&rsquo;s value in <i>ctx</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_output_set_flags</b>() function sets the output\nflags setting in <i>ctx</i> to the value of <i>val</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>nft_ctx_output_get_debug()\nand nft_ctx_output_set_debug()</b> <br>\nLibnftables supports separate debugging of different parts\nof its internals. To facilitate this, debugging output is\ncontrolled via a bit mask. The bits are defined as such:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">enum\nnft_debug_level { <br>\nNFT_DEBUG_SCANNER = 0x1, <br>\nNFT_DEBUG_PARSER = 0x2, <br>\nNFT_DEBUG_EVALUATION = 0x4, <br>\nNFT_DEBUG_NETLINK = 0x8, <br>\nNFT_DEBUG_MNL = 0x10, <br>\nNFT_DEBUG_PROTO_CTX = 0x20, <br>\nNFT_DEBUG_SEGTREE = 0x40, <br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_DEBUG_SCANNER</p>\n\n<p style=\"margin-left:17%;\">Print LEX debug output.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_DEBUG_PARSER</p>\n\n<p style=\"margin-left:17%;\">Print YACC debug output.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_DEBUG_EVALUATION</p>\n\n<p style=\"margin-left:17%;\">Print debug information about\nevaluation phase.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_DEBUG_NETLINK</p>\n\n<p style=\"margin-left:17%;\">Print netlink debug output.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_DEBUG_MNL</p>\n\n<p style=\"margin-left:17%;\">Print libmnl debug output.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_DEBUG_PROTO_CTX</p>\n\n<p style=\"margin-left:17%;\">Print protocol context debug\noutput.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">NFT_DEBUG_SEGTREE</p>\n\n<p style=\"margin-left:17%;\">Print segtree (i.e. interval\nsets) debug output.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_output_get_debug</b>() function returns the debug\noutput setting&rsquo;s value in <i>ctx</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_output_set_debug</b>() function sets the debug\noutput setting in <i>ctx</i> to the value of\n<i>mask</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Controlling\nlibrary standard and error output</b> <br>\nBy default, any output from the library (e.g., after a\n<b>list</b> command) is written to <i>stdout</i> and any\nerror messages are written to <i>stderr</i>. To give\napplications control over them, there are functions to\nassign custom file pointers as well as having the library\nbuffer what would be written for later retrieval in a static\nbuffer. This buffer is guaranteed to be null-terminated and\nmust not be freed. Note that the retrieval functions rewind\nthe buffer position indicator. Further library output will\nprobably overwrite the buffer content and potentially render\nit invalid (due to reallocation).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_set_output</b>() and <b>nft_ctx_set_error</b>()\nfunctions set the output or error file pointer in <i>ctx</i>\nto the value of <i>fp</i>. They return the previous value to\naid in temporary file pointer overrides. On error, these\nfunctions return NULL. This happens only if <i>fp</i> is\nNULL or invalid (tested using <b>ferror</b>() function).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_buffer_output</b>() and\n<b>nft_ctx_buffer_error</b>() functions enable library\nstandard or error output buffering. The functions return\nzero on success, non-zero otherwise. This may happen if the\ninternal call to <b>fopencookie</b>() failed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_unbuffer_output</b>() and\n<b>nft_ctx_unbuffer_error</b>() functions disable library\nstandard or error output buffering. On failure, the\nfunctions return non-zero which may only happen if buffering\nwas not enabled at the time the function was called.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_get_output_buffer</b>() and\n<b>nft_ctx_get_error_buffer</b>() functions return a pointer\nto the buffered output (which may be empty).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>nft_ctx_add_include_path()\nand nft_ctx_clear_include_path()</b> <br>\nThe <b>include</b> command in nftables rulesets allows to\noutsource parts of the ruleset into a different file. The\ninclude path defines where these files are searched for.\nLibnftables allows to have a list of those paths which are\nsearched in order. The default include path list contains a\nsingle compile-time defined entry (typically\n<i>/etc/</i>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_add_include_path</b>() function extends the list\nof include paths in <i>ctx</i> by the one given in\n<i>path</i>. The function returns zero on success or\nnon-zero if memory allocation failed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_ctx_clear_include_paths</b>() function removes all\ninclude paths, even the built-in default one.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>nft_run_cmd_from_buffer()\nand nft_run_cmd_from_filename()</b> <br>\nThese functions perform the actual work of parsing user\ninput into nftables commands and executing them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_run_cmd_from_buffer</b>() function passes the\ncommand(s) contained in <i>buf</i> (which must be\nnull-terminated) to the library, respecting settings and\nstate in <i>nft</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>nft_run_cmd_from_filename</b>() function passes the\ncontent of <i>filename</i> to the library, respecting\nsettings and state in <i>nft</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both functions\nreturn zero on success. A non-zero return code indicates an\nerror while parsing or executing the command. This event\nshould be accompanied by an error message written to library\nerror output.</p>\n\n<h2>EXAMPLE\n<a name=\"EXAMPLE\"></a>\n</h2>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">#include\n&lt;stdio.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;nftables/libnftables.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int main(void)\n<br>\n{ <br>\nchar *list_cmd = &quot;list ruleset&quot;; <br>\nstruct nft_ctx *nft; <br>\nconst char *output, *p; <br>\nchar buf[256]; <br>\nint rc = 0;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">nft =\nnft_ctx_new(NFT_CTX_DEFAULT); <br>\nif (!nft) <br>\nreturn 1;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">while (1) {\n<br>\nif (nft_ctx_buffer_output(nft) || <br>\nnft_run_cmd_from_buffer(nft, list_cmd)) { <br>\nrc = 1; <br>\nbreak; <br>\n} <br>\noutput = nft_ctx_get_output_buffer(nft); <br>\nif (strlen(output)) { <br>\nprintf(&quot;\\nThis is the current ruleset:\\n| &quot;); <br>\nfor (p = output; *(p + 1); p++) { <br>\nif (*p == '\\n') <br>\nprintf(&quot;\\n| &quot;); <br>\nelse <br>\nputchar(*p); <br>\n} <br>\nputchar('\\n'); <br>\n} else { <br>\nprintf(&quot;\\nCurrent ruleset is empty.\\n&quot;); <br>\n} <br>\nnft_ctx_unbuffer_output(nft);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">printf(&quot;\\nEnter\ncommand ('q' to quit): &quot;); <br>\nfflush(stdout); <br>\nfgets(buf, 256, stdin); <br>\nif (strlen(buf)) <br>\nbuf[strlen(buf) - 1] = '\\0';</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (buf[0] ==\n'q' &amp;&amp; buf[1] == '\\0') <br>\nbreak;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(nft_run_cmd_from_buffer(nft, buf)) { <br>\nrc = 1; <br>\nbreak; <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">nft_ctx_free(nft);\n<br>\nreturn rc; <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/5/libnftables-json\">libnftables-json(5)</a>,\n<b>nft</b>(8)</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Phil\nSutter</b> &lt;phil@nwl.cc&gt;</p>\n \n<p style=\"margin-left:17%;\">Author.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#EXAMPLE\">EXAMPLE</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>"],"level":3}