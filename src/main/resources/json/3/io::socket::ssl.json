{"name":"io::socket::ssl","description":"IO::Socket::SSL - SSL sockets with IO::Socket interface","body":"\n\n<h1 align=\"center\">IO::Socket::SSL</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL\n- SSL sockets with IO::Socket interface</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use strict;\n<br>\nuse IO::Socket::SSL; <br>\n# simple client <br>\nmy $cl = IO::Socket::SSL-&gt;new('www.google.com:443'); <br>\nprint $cl &quot;GET / HTTP/1.0\\r\\n\\r\\n&quot;; <br>\nprint &lt;$cl&gt;; <br>\n# simple server <br>\nmy $srv = IO::Socket::SSL-&gt;new( <br>\nLocalAddr =&gt; '0.0.0.0:1234', <br>\nListen =&gt; 10, <br>\nSSL_cert_file =&gt; 'server-cert.pem', <br>\nSSL_key_file =&gt; 'server-key.pem', <br>\n); <br>\n$srv-&gt;accept;</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL\nmakes using <small>SSL/TLS</small> much easier by wrapping\nthe necessary functionality into the familiar IO::Socket\ninterface and providing secure defaults whenever possible.\nThis way, existing applications can be made SSL-aware\nwithout much effort, at least if you do blocking I/O and\ndon&rsquo;t use select or poll.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But, under the\nhood, <small>SSL</small> is a complex beast. So there are\nlots of methods to make it do what you need if the default\nbehavior is not adequate. Because it is easy to\ninadvertently introduce critical security bugs or just hard\nto debug problems, I would recommend studying the following\ndocumentation carefully.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\ndocumentation consists of the following parts:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Essential Information About\n<small>SSL/TLS&quot;</small></p> </td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Basic <small>SSL</small> Client&quot;</p></td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Basic <small>SSL</small> Server&quot;</p></td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Common Usage Errors&quot;</p></td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Common Problems with <small>SSL&quot;</small></p></td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Using Non-Blocking Sockets&quot;</p></td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Advanced Usage&quot;</p></td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Integration Into Own Modules&quot;</p></td>\n<td width=\"26%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"57%\">\n\n\n<p>&quot;Description Of Methods&quot;</p></td>\n<td width=\"26%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\ndocumentation can be found in</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">IO::Socket::SSL::Intercept -\nDoing Man-In-The-Middle with <small>SSL</small></p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>IO::Socket::SSL::Utils - Useful functions for\ncertificates etc</p></td></tr>\n</table>\n\n<h2>Essential Information About SSL/TLS\n<a name=\"Essential Information About SSL/TLS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>SSL</small>\n(Secure Socket Layer) or its successor <small>TLS</small>\n(Transport Layer Security) are protocols to facilitate\nend-to-end security. These protocols are used when accessing\nweb sites (https), delivering or retrieving email, and in\nlots of other use cases. In the following documentation we\nwill refer to both <small>SSL</small> and <small>TLS</small>\nas simply &rsquo; <small>SSL</small> &rsquo;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>SSL</small>\nenables end-to-end security by providing two essential\nfunctions: <br>\nEncryption</p>\n\n<p style=\"margin-left:17%;\">This part encrypts the data for\ntransit between the communicating parties, so that nobody in\nbetween can read them. It also provides tamper resistance so\nthat nobody in between can manipulate the data.</p>\n\n<p style=\"margin-left:11%;\">Identification</p>\n\n<p style=\"margin-left:17%;\">This part makes sure that you\ntalk to the right peer. If the identification is done\nincorrectly it is easy to mount man-in-the-middle attacks,\ne.g. if Alice wants to talk to Bob it would be possible for\nMallory to put itself in the middle, so that Alice talks to\nMallory and Mallory to Bob. All the data would still be\nencrypted, but not end-to-end between Alice and Bob, but\nonly between Alice and Mallory and then between Mallory and\nBob. Thus Mallory would be able to read and modify all\ntraffic between Alice and Bob.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Identification\nis the part which is the hardest to understand and the\neasiest to get wrong.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With\n<small>SSL,</small> the Identification is usually done with\n<b>certificates</b> inside a <b><small>PKI</small></b>\n(Public Key Infrastructure). These Certificates are\ncomparable to an identity card, which contains information\nabout the owner of the card. The card then is somehow\n<b>signed</b> by the <b>issuer</b> of the card, the\n<b><small>CA</small></b> (Certificate Agency).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To verify the\nidentity of the peer the following must be done inside\n<small>SSL:</small></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Get the certificate from the peer. If the peer does not\npresent a certificate we cannot verify it.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Check if we trust the certificate, e.g. make sure\nit&rsquo;s not a forgery.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">We believe that\na certificate is not a fake if we either know the\ncertificate already or if we <b>trust</b> the issuer (the\n<small>CA</small> ) and can verify the issuers signature on\nthe certificate. In reality there is often a hierarchy of\ncertificate agencies and we only directly trust the root of\nthis hierarchy. In this case the peer not only sends his own\ncertificate, but also all <b>intermediate certificates</b>.\nVerification will be done by building a <b>trust path</b>\nfrom the trusted root up to the peers certificate and\nchecking in each step if the we can verify the\nissuer&rsquo;s signature.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This step often\ncauses problems because the client does not know the\nnecessary trusted root certificates. These are usually\nstored in a system dependent <small>CA</small> store, but\noften the browsers have their own <small>CA</small>\nstore.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Check if the certificate is\nstill valid. Each certificate has a lifetime and should not\nbe used after that time because it might be compromised or\nthe underlying cryptography got broken in the mean time.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Check if the subject of the certificate matches the\npeer. This is like comparing the picture on the identity\ncard against the person representing the identity card.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When connecting\nto a server this is usually done by comparing the hostname\nused for connecting against the names represented in the\ncertificate. A certificate might contain multiple names or\nwildcards, so that it can be used for multiple hosts (e.g.\n*.example.com and *.example.org).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Although nobody\nsane would accept an identity card where the picture does\nnot match the person we see, it is a common implementation\nerror with <small>SSL</small> to omit this check or get it\nwrong.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Check if the certificate was\nrevoked by the issuer. This might be the case if the\ncertificate was compromised somehow and now somebody else\nmight use it to claim the wrong identity. Such revocations\nhappened a lot after the heartbleed attack.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\n<small>SSL</small> there are two ways to verify a\nrevocation, <small>CRL</small> and <small>OCSP.</small> With\nCRLs (Certificate Revocation List) the <small>CA</small>\nprovides a list of serial numbers for revoked certificates.\nThe client somehow has to download the list (which can be\nhuge) and keep it up to date. With <small>OCSP</small>\n(Online Certificate Status Protocol) the client can check a\nsingle certificate directly by asking the issuer.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Revocation is\nthe hardest part of the verification and none of\ntoday&rsquo;s browsers get it fully correct. But, they are\nstill better than most other implementations which\ndon&rsquo;t implement revocation checks or leave the hard\nparts to the developer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When accessing\na web site with <small>SSL</small> or delivering mail in a\nsecure way the identity is usually only checked one way,\ne.g. the client wants to make sure it talks to the right\nserver, but the server usually does not care which client it\ntalks to. But, sometimes the server wants to identify the\nclient too and will request a certificate from the client\nwhich the server must verify in a similar way.</p>\n\n<h2>Basic SSL Client\n<a name=\"Basic SSL Client\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A basic\n<small>SSL</small> client is simple:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $client =\nIO::Socket::SSL-&gt;new('www.example.com:443') <br>\nor die &quot;error=$!, ssl_error=$SSL_ERROR&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This will take\nthe OpenSSL default <small>CA</small> store as the store for\nthe trusted <small>CA.</small> This usually works on\n<small>UNIX</small> systems. If there are no certificates in\nthe store it will try use Mozilla::CA which provides the\ndefault CAs of Firefox.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the default\nsettings, IO::Socket::SSL will use a safer cipher set and\n<small>SSL</small> version, do a proper hostname check\nagainst the certificate, and use <small>SNI</small> (server\nname indication) to send the hostname inside the\n<small>SSL</small> handshake. This is necessary to work with\nservers which have different certificates behind the same\n<small>IP</small> address. It will also check the revocation\nof the certificate with <small>OCSP,</small> but currently\nonly if the server provides <small>OCSP</small> stapling\n(for deeper checks see &quot;ocsp_resolver&quot;\nmethod).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Lots of options\ncan be used to change ciphers, <small>SSL</small> version,\nlocation of <small>CA</small> and much more. See\ndocumentation of methods for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With protocols\nlike <small>SMTP</small> it is necessary to upgrade an\nexisting socket to <small>SSL.</small> This can be done like\nthis:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $client =\nIO::Socket::INET-&gt;new('mx.example.com:25') or die $!;\n<br>\n# .. read greeting from server <br>\n# .. send EHLO and read response <br>\n# .. send STARTTLS command and read response <br>\n# .. if response was successful we can upgrade the socket to\nSSL now: <br>\nIO::Socket::SSL-&gt;start_SSL($client, <br>\n# explicitly set hostname we should use for SNI <br>\nSSL_hostname =&gt; 'mx.example.com' <br>\n) or die $SSL_ERROR;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A more complete\nexample for a simple <small>HTTP</small> client:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $client =\nIO::Socket::SSL-&gt;new( <br>\n# where to connect <br>\nPeerHost =&gt; &quot;www.example.com&quot;, <br>\nPeerPort =&gt; &quot;https&quot;, <br>\n# certificate verification - VERIFY_PEER is default <br>\nSSL_verify_mode =&gt; SSL_VERIFY_PEER, <br>\n# location of CA store <br>\n# need only be given if default store should not be used\n<br>\nSSL_ca_path =&gt; '/etc/ssl/certs', # typical CA path on\nLinux <br>\nSSL_ca_file =&gt; '/etc/ssl/cert.pem', # typical CA file on\nBSD <br>\n# or just use default path on system: <br>\nIO::Socket::SSL::default_ca(), # either explicitly <br>\n# or implicitly by not giving SSL_ca_* <br>\n# easy hostname verification <br>\n# It will use PeerHost as default name a verification <br>\n# scheme as default, which is safe enough for most purposes.\n<br>\nSSL_verifycn_name =&gt; 'foo.bar', <br>\nSSL_verifycn_scheme =&gt; 'http', <br>\n# SNI support - defaults to PeerHost <br>\nSSL_hostname =&gt; 'foo.bar', <br>\n) or die &quot;failed connect or ssl handshake:\n$!,$SSL_ERROR&quot;; <br>\n# send and receive over SSL connection <br>\nprint $client &quot;GET / HTTP/1.0\\r\\n\\r\\n&quot;; <br>\nprint &lt;$client&gt;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And to do\nrevocation checks with <small>OCSP</small> (only available\nwith OpenSSL 1.0.0 or higher and Net::SSLeay 1.59 or\nhigher):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># default will\ntry OCSP stapling and check only leaf certificate <br>\nmy $client = IO::Socket::SSL-&gt;new($dst); <br>\n# better yet: require checking of full chain <br>\nmy $client = IO::Socket::SSL-&gt;new( <br>\nPeerAddr =&gt; $dst, <br>\nSSL_ocsp_mode =&gt; SSL_OCSP_FULL_CHAIN, <br>\n); <br>\n# even better: make OCSP errors fatal <br>\n# (this will probably fail with lots of sites because of bad\nOCSP setups) <br>\n# also use common OCSP response cache <br>\nmy $ocsp_cache = IO::Socket::SSL::OCSP_Cache-&gt;new; <br>\nmy $client = IO::Socket::SSL-&gt;new( <br>\nPeerAddr =&gt; $dst, <br>\nSSL_ocsp_mode =&gt; SSL_OCSP_FULL_CHAIN|SSL_OCSP_FAIL_HARD,\n<br>\nSSL_ocsp_cache =&gt; $ocsp_cache, <br>\n); <br>\n# disable OCSP stapling in case server has problems with it\n<br>\nmy $client = IO::Socket::SSL-&gt;new( <br>\nPeerAddr =&gt; $dst, <br>\nSSL_ocsp_mode =&gt; SSL_OCSP_NO_STAPLE, <br>\n); <br>\n# check any certificates which are not yet checked by OCSP\nstapling or <br>\n# where we have already cached results. For your own\nresolving combine <br>\n# $ocsp-&gt;requests with\n$ocsp-&gt;add_response(uri,response). <br>\nmy $ocsp = $client-&gt;ocsp_resolver(); <br>\nmy $errors = $ocsp-&gt;resolve_blocking(); <br>\nif ($errors) { <br>\nwarn &quot;OCSP verification failed: $errors&quot;; <br>\nclose($client); <br>\n}</p>\n\n<h2>Basic SSL Server\n<a name=\"Basic SSL Server\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A basic\n<small>SSL</small> server looks similar to other IO::Socket\nservers, only that it also contains settings for certificate\nand key:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># simple server\n<br>\nmy $server = IO::Socket::SSL-&gt;new( <br>\n# where to listen <br>\nLocalAddr =&gt; '127.0.0.1', <br>\nLocalPort =&gt; 8080, <br>\nListen =&gt; 10, <br>\n# which certificate to offer <br>\n# with SNI support there can be different certificates per\nhostname <br>\nSSL_cert_file =&gt; 'cert.pem', <br>\nSSL_key_file =&gt; 'key.pem', <br>\n) or die &quot;failed to listen: $!&quot;; <br>\n# accept client <br>\nmy $client = $server-&gt;accept or die <br>\n&quot;failed to accept or ssl handshake:\n$!,$SSL_ERROR&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This will\nautomatically use a secure set of ciphers and\n<small>SSL</small> version and also supports Forward Secrecy\nwith (Elliptic-Curve) Diffie-Hellmann Key Exchange.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you are\ndoing a forking or threading server, we recommend that you\ndo the <small>SSL</small> handshake inside the new\nprocess/thread so that the master is free for new\nconnections. We recommend this because a client with\nimproper or slow <small>SSL</small> handshake could make the\nserver block in the handshake which would be bad to do on\nthe listening socket:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># inet server\n<br>\nmy $server = IO::Socket::INET-&gt;new( <br>\n# where to listen <br>\nLocalAddr =&gt; '127.0.0.1', <br>\nLocalPort =&gt; 8080, <br>\nListen =&gt; 10, <br>\n); <br>\n# accept client <br>\nmy $client = $server-&gt;accept or die; <br>\n# SSL upgrade client (in new process/thread) <br>\nIO::Socket::SSL-&gt;start_SSL($client, <br>\nSSL_server =&gt; 1, <br>\nSSL_cert_file =&gt; 'cert.pem', <br>\nSSL_key_file =&gt; 'key.pem', <br>\n) or die &quot;failed to ssl handshake:\n$SSL_ERROR&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Like with\nnormal sockets, neither forking nor threading servers scale\nwell. It is recommended to use non-blocking sockets instead,\nsee &quot;Using Non-Blocking Sockets&quot;</p>\n\n<h2>Common Usage Errors\n<a name=\"Common Usage Errors\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is a list\nof typical errors seen with the use of IO::Socket::SSL:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"71%\">\n\n\n<p style=\"margin-top: 1em\">Disabling verification with\n&quot;SSL_verify_mode&quot;.</p> </td>\n<td width=\"12%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">As described in\n&quot;Essential Information About\n<small>SSL/TLS&quot;</small> , a proper identification of\nthe peer is essential and failing to verify makes\nMan-In-The-Middle attacks possible.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Nevertheless,\nlots of scripts and even public modules or applications\ndisable verification, because it is probably the easiest way\nto make the thing work and usually nobody notices any\nsecurity problems anyway.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the\nverification does not succeed with the default settings, one\ncan do the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"11%\"></td>\n<td width=\"71%\">\n\n\n<p style=\"margin-top: 1em\">Make sure the needed CAs are in\nthe store, maybe use &quot;SSL_ca_file&quot; or\n&quot;SSL_ca_path&quot; to specify a different\n<small>CA</small> store.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"11%\"></td>\n<td width=\"71%\">\n\n\n<p>If the validation fails because the certificate is\nself-signed and that&rsquo;s what you expect, you can use\nthe &quot;SSL_fingerprint&quot; option to accept specific\nleaf certificates by their certificate or pubkey\nfingerprint.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"11%\"></td>\n<td width=\"71%\">\n\n\n<p>If the validation failed because the hostname does not\nmatch and you cannot access the host with the name given in\nthe certificate, you can use &quot;SSL_verifycn_name&quot;\nto specify the hostname you expect in the certificate.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A common error\npattern is also to disable verification if they found no\n<small>CA</small> store (different modules look at different\n&quot;default&quot; places). Because IO::Socket::SSL is now\nable to provide a usable <small>CA</small> store on most\nplatforms ( <small>UNIX,</small> Mac <small>OSX</small> and\nWindows) it is better to use the defaults provided by\nIO::Socket::SSL. If necessary these can be checked with the\n&quot;default_ca&quot; method.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Polling of <small>SSL</small>\nsockets (e.g. select, poll and other event loops).</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you sysread\none byte on a normal socket it will result in a syscall to\nread one byte. Thus, if more than one byte is available on\nthe socket it will be kept in the network stack of your\n<small>OS</small> and the next select or poll call will\nreturn the socket as readable. But, with <small>SSL</small>\nyou don&rsquo;t deliver single bytes. Multiple data bytes\nare packaged and encrypted together in an <small>SSL</small>\nframe. Decryption can only be done on the whole frame, so a\nsysread for one byte actually reads the complete\n<small>SSL</small> frame from the socket, decrypts it and\nreturns the first decrypted byte. Further sysreads will\nreturn more bytes from the same frame until all bytes are\nreturned and the next <small>SSL</small> frame will be read\nfrom the socket.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Thus, in order\nto decide if you can read more data (e.g. if sysread will\nblock) you must check if there are still data in the current\n<small>SSL</small> frame by calling &quot;pending&quot; and\nif there are no data pending you might check the underlying\nsocket with select or poll. Another way might be if you try\nto sysread at least 16kByte all the time. 16kByte is the\nmaximum size of an <small>SSL</small> frame and because\nsysread returns data from only a single <small>SSL</small>\nframe you can guarantee that there are no pending data.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Additionally,\ncontrary to plain sockets the data delivered on the socket\nare not necessarily application payload. It might be a\n<small>TLS</small> handshake, it might just be the beginning\nof a <small>TLS</small> record or it might be\n<small>TLS</small> session tickets which are send after the\n<small>TLS</small> handshake in <small>TLS 1.3.</small> In\nsuch situations select will return that data are available\nfor read since it only looks at the plain socket. A sysread\non the IO::Socket::SSL socket will not return any data\nthough since it is an abstraction which only returns\napplication data. This causes the sysread to hang in case\nthe socket was blocking or to return an error with\n<small>EAGAIN</small> on non-blocking sockets. Applications\nusing select or similar should therefore set the socket to\nnon-blocking and also expect that the sysread might\ntemporarily fail with <small>EAGAIN.</small></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\n&quot;Using Non-Blocking Sockets&quot;.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"81%\">\n\n\n<p style=\"margin-top: 1em\">Expecting exactly the same\nbehavior as plain sockets.</p></td>\n<td width=\"2%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">IO::Socket::SSL\ntries to emulate the usual socket behavior as good as\npossible, but full emulation can not be done. Specifically a\nread on the <small>SSL</small> socket might also result in a\nwrite on the <small>TCP</small> socket or a write on the\n<small>SSL</small> socket might result in a read on the\n<small>TCP</small> socket. Also &quot;accept&quot; and\n<b>close</b> on the <small>SSL</small> socket will result in\nwriting and reading data to the <small>TCP</small> socket\ntoo.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Especially the\nhidden writes might result in a connection reset if the\nunderlying <small>TCP</small> socket is already closed by\nthe peer. Unless signal <small>PIPE</small> is explicitly\nhandled by the application this will usually result in the\napplication crashing. It is thus recommended to explicitly\n<small>IGNORE</small> signal <small>PIPE</small> so that the\nerrors get propagated as <small>EPIPE</small> instead of\ncausing a crash of the application.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Set &rsquo;SSL_version&rsquo; or\n&rsquo;SSL_cipher_list&rsquo; to a &quot;better&quot;\nvalue.</p> </td></tr>\n</table>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">IO::Socket::SSL\ntries to set these values to reasonable, secure values which\nare compatible with the rest of the world. But, there are\nsome scripts or modules out there which tried to be smart\nand get more secure or compatible settings. Unfortunately,\nthey did this years ago and never updated these values, so\nthey are still forced to do only &rsquo;TLSv1&rsquo;\n(instead of also using TLSv12 or TLSv11). Or they set\n&rsquo; <small>HIGH</small> &rsquo; as the cipher list and\nthought they were secure, but did not notice that &rsquo;\n<small>HIGH</small> &rsquo; includes anonymous ciphers, e.g.\nwithout identification of the peer.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">So it is\nrecommended to leave the settings at the secure defaults\nwhich IO::Socket::SSL sets and which get updated from time\nto time to better fit the real world.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Make <small>SSL</small> settings\ninaccessible by the user, together with bad builtin\nsettings.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Some modules\nuse IO::Socket::SSL, but don&rsquo;t make the\n<small>SSL</small> settings available to the user. This is\noften combined with bad builtin settings or defaults (like\nswitching verification off).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Thus the user\nneeds to hack around these restrictions by using\n&quot;set_args_filter_hack&quot; or similar.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"43%\">\n\n\n<p style=\"margin-top: 1em\">Use of constants as strings.</p></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Constants like\n&quot;SSL_VERIFY_PEER&quot; or &quot;SSL_WANT_READ&quot;\nshould be used as constants and not be put inside quotes,\nbecause they represent numerical values.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">Forking and handling the socket\nin parent and child.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A <b>fork</b>\nof the process will duplicate the internal user space\n<small>SSL</small> state of the socket. If both master and\nchild interact with the socket by using their own\n<small>SSL</small> state strange error messages will happen.\nSuch interaction includes explicit or implicit <b>close</b>\nof the <small>SSL</small> socket. To avoid this the socket\nshould be explicitly closed with <b>SSL_no_shutdown</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"55%\">\n\n\n<p style=\"margin-top: 1em\">Forking and executing a new\nprocess.</p> </td>\n<td width=\"28%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Since the\n<small>SSL</small> state is stored in user space it will be\nduplicated by a <b>fork</b> but it will be lost when doing\n<b>exec</b>. This means it is not possible to simply\nredirect stdin and stdout for the new process to the\n<small>SSL</small> socket by duplicating the relevant file\nhandles. Instead explicitly exchanging plain data between\nchild-process and <small>SSL</small> socket are needed.</p>\n\n<h2>Common Problems with SSL\n<a name=\"Common Problems with SSL\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>SSL</small>\nis a complex protocol with multiple implementations and each\nof these has their own quirks. While most of these\nimplementations work together, it often gets problematic\nwith older versions, minimal versions in load balancers, or\nplain wrong setups.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Unfortunately\nthese problems are hard to debug. Helpful for debugging are\na knowledge of <small>SSL</small> internals, wireshark and\nthe use of the debug settings of IO::Socket::SSL and\nNet::SSLeay, which can both be set with\n$IO::Socket::SSL::DEBUG. The following debugs levels are\ndefined, but used not in any consistent way:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">0 - No debugging (default).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>1 - Print out errors from IO::Socket::SSL and ciphers\nfrom Net::SSLeay.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>2 - Print also information about call flow from\nIO::Socket::SSL and progress information from\nNet::SSLeay.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>3 - Print also some data dumps from IO::Socket::SSL and\nfrom Net::SSLeay.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also,\n&quot;analyze-ssl.pl&quot; from the ssl-tools repository at\n&lt;https://github.com/noxxi/p5-ssl-tools&gt; might be a\nhelpful tool when debugging <small>SSL</small> problems, as\ndo the &quot;openssl&quot; command line tool and a check\nwith a different <small>SSL</small> implementation (e.g. a\nweb browser).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nproblems are not uncommon:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">Bad server setup: missing\nintermediate certificates.</p></td>\n<td width=\"3%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">It is a regular\nproblem that administrators fail to include all necessary\ncertificates into their server setup, e.g. everything needed\nto build the trust chain from the trusted root. If they\ncheck the setup with the browser everything looks ok,\nbecause browsers work around these problems by caching any\nintermediate certificates and apply them to new connections\nif certificates are missing.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">But, fresh\nbrowser profiles which have never seen these intermediates\ncannot fill in the missing certificates and fail to verify;\nthe same is true with IO::Socket::SSL.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Old versions of servers or load\nbalancers which do not understand specific\n<small>TLS</small> versions or croak on specific data.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">From time to\ntime one encounters an <small>SSL</small> peer, which just\ncloses the connection inside the <small>SSL</small>\nhandshake. This can usually be worked around by downgrading\nthe <small>SSL</small> version, e.g. by setting\n&quot;SSL_version&quot;. Modern Browsers usually deal with\nsuch servers by automatically downgrading the\n<small>SSL</small> version and repeat the connection attempt\nuntil they succeed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Worse servers\ndo not close the underlying <small>TCP</small> connection\nbut instead just drop the relevant packet. This is harder to\ndetect because it looks like a stalled connection. But\ndowngrading the <small>SSL</small> version often works here\ntoo.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A cause of such\nproblems are often load balancers or security devices, which\nhave hardware acceleration and only a minimal (and less\nrobust) <small>SSL</small> stack. They can often be detected\nbecause they support much fewer ciphers than other\nimplementations.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"43%\">\n\n\n<p style=\"margin-top: 1em\">Bad or old OpenSSL versions.</p></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">IO::Socket::SSL\nuses OpenSSL with the help of the Net::SSLeay library. It is\nrecommend to have a recent version of this library, because\nit has more features and usually fewer known bugs.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"60%\">\n\n\n<p style=\"margin-top: 1em\">Validation of client\ncertificates fail.</p></td>\n<td width=\"23%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Make sure that\nthe purpose of the certificate allows use as ssl client\n(check with &quot;openssl x509 -purpose&quot;, that the\nnecessary root certificate is in the path specified by\n&quot;SSL_ca*&quot; (or the default path) and that any\nintermediate certificates needed to build the trust chain\nare sent by the client.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Validation of self-signed\ncertificate fails even if it is given with\n&quot;SSL_ca*&quot; argument.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;SSL_ca*&quot; arguments do not give a general trust\nstore for arbitrary certificates but only specify a store\nfor <small>CA</small> certificates which then can be used to\nverify other certificates. This especially means that\ncertificates which are not a <small>CA</small> get simply\nignored, notably self-signed certificates which do not also\nhave the CA-flag set.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This behavior\nof OpenSSL differs from the more general trust-store concept\nwhich can be found in browsers and where it is possible to\nsimply added arbitrary certificates ( <small>CA</small> or\nnot) as trusted.</p>\n\n<h2>Using Non-Blocking Sockets\n<a name=\"Using Non-Blocking Sockets\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you have a\nnon-blocking socket, the expected behavior on read, write,\naccept or connect is to set $! to <small>EWOULDBLOCK</small>\nif the operation cannot be completed immediately. Note that\n<small>EWOULDBLOCK</small> is the same as\n<small>EAGAIN</small> on <small>UNIX</small> systems, but is\ndifferent on Windows.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With\n<small>SSL,</small> handshakes might occur at any time, even\nwithin an established connection. In these cases it is\nnecessary to finish the handshake before you can read or\nwrite data. This might result in situations where you want\nto read but must first finish the write of a handshake or\nwhere you want to write but must first finish a read. In\nthese cases $! is set to <small>EAGAIN</small> like\nexpected, and additionally $SSL_ERROR is set to either\n<small>SSL_WANT_READ</small> or\n<small>SSL_WANT_WRITE.</small> Thus if you get\n<small>EWOULDBLOCK</small> on a <small>SSL</small> socket\nyou must check $SSL_ERROR for SSL_WANT_* and adapt your\nevent mask accordingly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using readline\non non-blocking sockets does not make much sense and I would\nadvise against using it. And, while the behavior is not\ndocumented for other IO::Socket classes, it will try to\nemulate the behavior seen there, e.g. to return the received\ndata instead of blocking, even if the line is not complete.\nIf an unrecoverable error occurs it will return nothing,\neven if it already received some data.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also, I would\nadvise against using &quot;accept&quot; with a non-blocking\n<small>SSL</small> object because it might block and this is\nnot what most would expect. The reason for this is that\n&quot;accept&quot; on a non-blocking <small>TCP</small>\nsocket (e.g. IO::Socket::IP, IO::Socket::INET..) results in\na new <small>TCP</small> socket which does not inherit the\nnon-blocking behavior of the master socket. And thus, the\ninitial <small>SSL</small> handshake on the new socket\ninside &quot;IO::Socket::SSL::accept&quot; will be done in a\nblocking way. To work around this you are safer by doing a\n<small>TCP</small> accept and later upgrade the\n<small>TCP</small> socket in a non-blocking way with\n&quot;start_SSL&quot; and &quot;accept_SSL&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $cl =\nIO::Socket::SSL-&gt;new($dst); <br>\n$cl-&gt;blocking(0); <br>\nmy $sel = IO::Select-&gt;new($cl); <br>\nwhile (1) { <br>\n# with SSL a call for reading n bytes does not result in\nreading of n <br>\n# bytes from the socket, but instead it must read at least\none full SSL <br>\n# frame. If the socket has no new bytes, but there are\nunprocessed data <br>\n# from the SSL frame can_read will block! <br>\n# wait for data on socket <br>\n$sel-&gt;can_read(); <br>\n# new data on socket or eof <br>\nREAD: <br>\n# this does not read only 1 byte from socket, but reads the\ncomplete SSL <br>\n# frame and then just returns one byte. On subsequent calls\nit than <br>\n# returns more byte of the same SSL frame until it needs to\nread the <br>\n# next frame. <br>\nmy $n = sysread( $cl,my $buf,1); <br>\nif ( ! defined $n ) { <br>\ndie $! if not $!{EWOULDBLOCK}; <br>\nnext if $SSL_ERROR == SSL_WANT_READ; <br>\nif ( $SSL_ERROR == SSL_WANT_WRITE ) { <br>\n# need to write data on renegotiation <br>\n$sel-&gt;can_write; <br>\nnext; <br>\n} <br>\ndie &quot;something went wrong: $SSL_ERROR&quot;; <br>\n} elsif ( ! $n ) { <br>\nlast; # eof <br>\n} else { <br>\n# read next bytes <br>\n# we might have still data within the current SSL frame <br>\n# thus first process these data instead of waiting on the\nunderlying <br>\n# socket object <br>\ngoto READ if $cl-&gt;pending; # goto sysread <br>\nnext; # goto $sel-&gt;can_read <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additionally\nthere are differences to plain sockets when using select,\npoll, kqueue or similar technologies to get notified if data\nare available. Relying only on these calls is not sufficient\nin all cases since unread data might be internally buffered\nin the <small>SSL</small> stack. To detect such buffering\n<b>pending()</b> need to be used. Alternatively the\nbuffering can be avoided by using <b>sysread</b> with the\nmaximum size of an <small>SSL</small> frame. See\n&quot;Common Usage Errors&quot; for details.</p>\n\n<h2>Advanced Usage\n<a name=\"Advanced Usage\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>SNI</small>\nSupport</b> <br>\nNewer extensions to <small>SSL</small> can distinguish\nbetween multiple hostnames on the same <small>IP</small>\naddress using Server Name Indication ( <small>SNI</small>\n).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Support for\n<small>SNI</small> on the client side was added somewhere in\nthe OpenSSL 0.9.8 series, but with 1.0 a bug was fixed when\nthe server could not decide about its hostname. Therefore\nclient side <small>SNI</small> is only supported with\nOpenSSL 1.0 or higher in IO::Socket::SSL. With a supported\nversion, <small>SNI</small> is used automatically on the\nclient side, if it can determine the hostname from\n&quot;PeerAddr&quot; or &quot;PeerHost&quot; (which are\nsynonyms in the underlying IO::Socket:: classes and thus\nshould never be set both or at least not to different\nvalues). On unsupported OpenSSL versions it will silently\nnot use <small>SNI.</small> The hostname can also be given\nexplicitly given with &quot;SSL_hostname&quot;, but in this\ncase it will throw in error, if <small>SNI</small> is not\nsupported. To check for support you might call\n&quot;IO::Socket::SSL-&gt;can_client_sni()&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On the server\nside, earlier versions of OpenSSL are supported, but only\ntogether with Net::SSLeay version &gt;= 1.50. To check for\nsupport you might call\n&quot;IO::Socket::SSL-&gt;can_server_sni()&quot;. If server\nside <small>SNI</small> is supported, you might specify\ndifferent certificates per host with &quot;SSL_cert*&quot;\nand &quot;SSL_key*&quot;, and check the requested name using\n&quot;get_servername&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Talk Plain\nand <small>SSL</small> With The Same Socket</b> <br>\nIt is often required to first exchange some plain data and\nthen upgrade the socket to <small>SSL</small> after some\nkind of <small>STARTTLS</small> command. Protocols like\n<small>FTPS</small> even need a way to downgrade the socket\nagain back to plain.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The common way\nto do this would be to create a normal socket and use\n&quot;start_SSL&quot; to upgrade and stop_SSL to\ndowngrade:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $sock =\nIO::Socket::INET-&gt;new(...) or die $!; <br>\n... exchange plain data on $sock until starttls command ...\n<br>\nIO::Socket::SSL-&gt;start_SSL($sock,%sslargs) or die\n$SSL_ERROR; <br>\n... now $sock is an IO::Socket::SSL object ... <br>\n... exchange data with SSL on $sock until stoptls command\n... <br>\n$sock-&gt;stop_SSL or die $SSL_ERROR; <br>\n... now $sock is again an IO::Socket::INET object ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But, lots of\nmodules just derive directly from IO::Socket::INET. While\nthis base class can be replaced with IO::Socket::SSL, these\nmodules cannot easily support different base classes for\n<small>SSL</small> and plain data and switch between these\nclasses on a starttls command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To help in this\ncase, IO::Socket::SSL can be reduced to a plain socket on\nstartup, and connect_SSL/accept_SSL/start_SSL can be used to\nenable <small>SSL</small> and &quot;stop_SSL&quot; to talk\nplain again:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $sock =\nIO::Socket::SSL-&gt;new( <br>\nPeerAddr =&gt; ... <br>\nSSL_startHandshake =&gt; 0, <br>\n%sslargs <br>\n) or die $!; <br>\n... exchange plain data on $sock until starttls command ...\n<br>\n$sock-&gt;connect_SSL or die $SSL_ERROR; <br>\n... now $sock is an IO::Socket::SSL object ... <br>\n... exchange data with SSL on $sock until stoptls command\n... <br>\n$sock-&gt;stop_SSL or die $SSL_ERROR; <br>\n... $sock is still an IO::Socket::SSL object ... <br>\n... but data exchanged again in plain ...</p>\n\n<h2>Integration Into Own Modules\n<a name=\"Integration Into Own Modules\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL\nbehaves similarly to other IO::Socket modules and thus could\nbe integrated in the same way, but you have to take special\ncare when using non-blocking I/O (like for handling\ntimeouts) or using select or poll. Please study the\ndocumentation on how to deal with these differences.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also, it is\nrecommended to not set or touch most of the\n&quot;SSL_*&quot; options, so that they keep their secure\ndefaults. It is also recommended to let the user override\nthese <small>SSL</small> specific settings without the need\nof global settings or hacks like\n&quot;set_args_filter_hack&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The notable\nexception is &quot;SSL_verifycn_scheme&quot;. This should be\nset to the hostname verification scheme required by the\nmodule or protocol.</p>\n\n<h2>Description Of Methods\n<a name=\"Description Of Methods\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL\ninherits from another IO::Socket module. The choice of the\nsuper class depends on the installed modules:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">If IO::Socket::IP with at least\nversion 0.20 is installed it will use this module as super\nclass, transparently providing IPv6 and IPv4 support.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>If IO::Socket::INET6 is installed it will use this\nmodule as super class, transparently providing IPv6 and IPv4\nsupport.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Otherwise it will fall back to IO::Socket::INET, which\nis a perl core module. With IO::Socket::INET you only get\nIPv4 support.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Please be aware\nthat with the IPv6 capable super classes, it will look first\nfor the IPv6 address of a given hostname. If the resolver\nprovides an IPv6 address, but the host cannot be reached by\nIPv6, there will be no automatic fallback to IPv4. To avoid\nthese problems you can enforce IPv4 for a specific socket by\nusing the &quot;Domain&quot; or &quot;Family&quot; option\nwith the value <small>AF_INET</small> as described in\nIO::Socket::IP. Alternatively you can enforce IPv4 globally\nby loading IO::Socket::SSL with the option\n&rsquo;inet4&rsquo;, in which case it will use the IPv4 only\nclass IO::Socket::INET as the super class.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL\nwill provide all of the methods of its super class, but\nsometimes it will override them to match the behavior\nexpected from <small>SSL</small> or to provide additional\narguments.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The new or\nchanged methods are described below, but please also read\nthe section about <small>SSL</small> specific error\nhandling. <br>\nError Handling</p>\n\n<p style=\"margin-left:17%;\">If an <small>SSL</small>\nspecific error occurs, the global variable $SSL_ERROR will\nbe set. If the error occurred on an existing\n<small>SSL</small> socket, the method &quot;errstr&quot;\nwill give access to the latest socket specific error. Both\n$SSL_ERROR and the &quot;errstr&quot; method give a dualvar\nsimilar to $!, e.g. providing an error number in numeric\ncontext or an error description in string context.</p>\n\n<p style=\"margin-left:11%;\"><b>new(...)</b></p>\n\n<p style=\"margin-left:17%;\">Creates a new IO::Socket::SSL\nobject. You may use all the friendly options that came\nbundled with the super class (e.g. IO::Socket::IP,\nIO::Socket::INET, ...) plus (optionally) the ones described\nbelow. If you don&rsquo;t specify any <small>SSL</small>\nrelated options it will do its best in using secure\ndefaults, e.g. choosing good ciphers, enabling proper\nverification, etc. <br>\nSSL_server</p>\n\n<p style=\"margin-left:20%;\">Set this option to a true value\nif the socket should be used as a server. If this is not\nexplicitly set it is assumed if the &quot;Listen&quot;\nparameter is given when creating the socket.</p>\n\n<p style=\"margin-left:17%;\">SSL_hostname</p>\n\n<p style=\"margin-left:20%;\">This can be given to specify\nthe hostname used for <small>SNI,</small> which is needed if\nyou have multiple <small>SSL</small> hostnames on the same\n<small>IP</small> address. If not given it will try to\ndetermine the hostname from &quot;PeerAddr&quot;, which will\nfail if only an <small>IP</small> was given or if this\nargument is used within &quot;start_SSL&quot;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If you want to\ndisable <small>SNI,</small> set this argument to\n&rsquo;&rsquo;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Currently only\nsupported for the client side and will be ignored for the\nserver side.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">See section\n&quot; <small>SNI</small> Support&quot; for details of\n<small>SNI</small> the support.</p>\n\n<p style=\"margin-left:17%;\">SSL_startHandshake</p>\n\n<p style=\"margin-left:20%;\">If this option is set to false\n(defaults to true) it will not start the <small>SSL</small>\nhandshake yet. This has to be done later with\n&quot;accept_SSL&quot; or &quot;connect_SSL&quot;. Before\nthe handshake is started read/write/etc. can be used to\nexchange plain data.</p>\n\n<p style=\"margin-left:17%;\">SSL_keepSocketOnError</p>\n\n<p style=\"margin-left:20%;\">If this option is set to true\n(defaults to false) it will not close the underlying\n<small>TCP</small> socket on errors. In most cases there is\nno real use for this behavior since both sides of the\n<small>TCP</small> connection will probably have a different\nidea of the current state of the connection.</p>\n\n<p style=\"margin-left:17%;\">SSL_ca | SSL_ca_file |\nSSL_ca_path</p>\n\n<p style=\"margin-left:20%;\">Usually you want to verify that\nthe peer certificate has been signed by a trusted\ncertificate authority. In this case you should use this\noption to specify the file (&quot;SSL_ca_file&quot;) or\ndirectory (&quot;SSL_ca_path&quot;) containing the\ncertificate(s) of the trusted certificate authorities.</p>\n\n\n<p style=\"margin-left:20%; margin-top: 1em\">&quot;SSL_ca_path&quot;\ncan also be an array or a string containing multiple path,\nwhere the path are separated by the platform specific\nseparator. This separator is &quot;;&quot; on\n<small>DOS,</small> Windows, Netware, &quot;,&quot; on\n<small>VMS</small> and &quot;:&quot; for all the other\nsystems. If multiple path are given at least one of these\nmust be accessible.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">You can also\ngive a list of X509* certificate handles (like you get from\nNet::SSLeay or IO::Socket::SSL::Utils::PEM_xxx2cert) with\n&quot;SSL_ca&quot;. These will be added to the\n<small>CA</small> store before path and file and thus take\nprecedence. If neither SSL_ca, nor SSL_ca_file or\nSSL_ca_path are set it will use &quot;default_ca()&quot; to\ndetermine the user-set or system defaults. If you really\ndon&rsquo;t want to set a <small>CA</small> set SSL_ca_file\nor SSL_ca_path to &quot;\\undef&quot; or SSL_ca to an empty\nlist. (unfortunately '' is used by some modules using\nIO::Socket::SSL when <small>CA</small> is not explicitly\ngiven).</p>\n\n<p style=\"margin-left:17%;\">SSL_client_ca |\nSSL_client_ca_file</p>\n\n<p style=\"margin-left:20%;\">If verify_mode is\n<small>VERIFY_PEER</small> on the server side these options\ncan be used to set the list of acceptable CAs for the\nclient. This way the client can select they required\ncertificate from a list of certificates. The value for these\noptions is similar to &quot;SSL_ca&quot; and\n&quot;SSL_ca_file&quot;.</p>\n\n<p style=\"margin-left:17%;\">SSL_fingerprint</p>\n\n<p style=\"margin-left:20%;\">Sometimes you have a\nself-signed certificate or a certificate issued by an\nunknown <small>CA</small> and you really want to accept it,\nbut don&rsquo;t want to disable verification at all. In this\ncase you can specify the fingerprint of the certificate as\n'algo$hex_fingerprint'. &quot;algo&quot; is a fingerprint\nalgorithm supported by OpenSSL, e.g.\n&rsquo;sha1&rsquo;,&rsquo;sha256&rsquo;... and\n&quot;hex_fingerprint&quot; is the hexadecimal\nrepresentation of the binary fingerprint. Any colons inside\nthe hex string will be ignored.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If you want to\nuse the fingerprint of the pubkey inside the certificate\ninstead of the certificate use the syntax\n'algo$pub$hex_fingerprint' instead. To get the fingerprint\nof an established connection you can use\n&quot;get_fingerprint&quot;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">It is also\npossible to skip &quot;algo$&quot;, i.e. only specify the\nfingerprint. In this case the likely algorithms will be\nautomatically detected based on the length of the digest\nstring.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">You can specify\na list of fingerprints in case you have several acceptable\ncertificates. If a fingerprint matches the topmost (i.e.\nleaf) certificate no additional validations can make the\nverification fail.</p>\n\n<p style=\"margin-left:17%;\">SSL_cert_file | SSL_cert |\nSSL_key_file | SSL_key</p>\n\n<p style=\"margin-left:20%;\">If you create a server you\nusually need to specify a server certificate which should be\nverified by the client. Same is true for client\ncertificates, which should be verified by the server. The\ncertificate can be given as a file with SSL_cert_file or as\nan internal representation of an X509* object (like you get\nfrom Net::SSLeay or IO::Socket::SSL::Utils::PEM_xxx2cert)\nwith SSL_cert. If given as a file it will automatically\ndetect the format. Supported file formats are <small>PEM,\nDER</small> and PKCS#12, where <small>PEM</small> and\nPKCS#12 can contain the certificate and the chain to use,\nwhile <small>DER</small> can only contain a single\ncertificate.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If given as a\nlist of X509* please note, that the all the chain\ncertificates (e.g. all except the first) will be\n&quot;consumed&quot; by openssl and will be freed if the\n<small>SSL</small> context gets destroyed - so you should\nnever free them yourself. But the servers certificate (e.g.\nthe first) will not be consumed by openssl and thus must be\nfreed by the application.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">For each\ncertificate a key is need, which can either be given as a\nfile with SSL_key_file or as an internal representation of\nan EVP_PKEY* object with SSL_key (like you get from\nNet::SSLeay or IO::Socket::SSL::Utils::PEM_xxx2key). If a\nkey was already given within the PKCS#12 file specified by\nSSL_cert_file it will ignore any SSL_key or SSL_key_file. If\nno SSL_key or SSL_key_file was given it will try to use the\n<small>PEM</small> file given with SSL_cert_file again,\nmaybe it contains the key too.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If your\n<small>SSL</small> server should be able to use different\ncertificates on the same <small>IP</small> address,\ndepending on the name given by <small>SNI,</small> you can\nuse a hash reference instead of a file with\n&quot;&lt;hostname =&quot; cert_file&gt;&gt;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If your\n<small>SSL</small> server should be able to use both\n<small>RSA</small> and <small>ECDSA</small> certificates for\nthe same domain/IP a similar hash reference like with\n<small>SNI</small> is given. The domain names used to\nspecify the additional certificates should be\n&quot;hostname%whatever&quot;, i.e. &quot;hostname%ecc&quot;\nor similar. This needs at least OpenSSL 1.0.2. To let the\nserver pick the certificate based on the clients cipher\npreference &quot;SSL_honor_cipher_order&quot; should be set\nto false.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">In case certs\nand keys are needed but not given it might fall back to\nbuiltin defaults, see &quot;Defaults for Cert, Key and\n<small>CA&quot;.</small></p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Examples:</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">SSL_cert_file\n=&gt; 'mycert.pem', <br>\nSSL_key_file =&gt; 'mykey.pem', <br>\nSSL_cert_file =&gt; { <br>\n&quot;foo.example.org&quot; =&gt; 'foo-cert.pem', <br>\n&quot;foo.example.org%ecc&quot; =&gt; 'foo-ecc-cert.pem',\n<br>\n&quot;bar.example.org&quot; =&gt; 'bar-cert.pem', <br>\n# used when nothing matches or client does not support SNI\n<br>\n'' =&gt; 'default-cert.pem', <br>\n'%ecc' =&gt; 'default-ecc-cert.pem', <br>\n}, <br>\nSSL_key_file =&gt; { <br>\n&quot;foo.example.org&quot; =&gt; 'foo-key.pem', <br>\n&quot;foo.example.org%ecc&quot; =&gt; 'foo-ecc-key.pem',\n<br>\n&quot;bar.example.org&quot; =&gt; 'bar-key.pem', <br>\n# used when nothing matches or client does not support SNI\n<br>\n'' =&gt; 'default-key.pem', <br>\n'%ecc' =&gt; 'default-ecc-key.pem', <br>\n}</p>\n\n<p style=\"margin-left:17%;\">SSL_passwd_cb</p>\n\n<p style=\"margin-left:20%;\">If your private key is\nencrypted, you might not want the default password prompt\nfrom Net::SSLeay. This option takes a reference to a\nsubroutine that should return the password required to\ndecrypt your private key.</p>\n\n<p style=\"margin-left:17%;\">SSL_use_cert</p>\n\n<p style=\"margin-left:20%;\">If this is true, it forces\nIO::Socket::SSL to use a certificate and key, even if you\nare setting up an <small>SSL</small> client. If this is set\nto 0 (the default), then you will only need a certificate\nand key if you are setting up a server.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">SSL_use_cert\nwill implicitly be set if SSL_server is set. For convenience\nit is also set if it was not given but a cert was given for\nuse (SSL_cert_file or similar).</p>\n\n<p style=\"margin-left:17%;\">SSL_version</p>\n\n<p style=\"margin-left:20%;\">Sets the version of the\n<small>SSL</small> protocol used to transmit data.\n&rsquo;SSLv23&rsquo; uses a handshake compatible with\n<small>SSL2.0, SSL3.0</small> and <small>TLS1</small> .x,\nwhile &rsquo;SSLv2&rsquo;, &rsquo;SSLv3&rsquo;,\n&rsquo;TLSv1&rsquo;, &rsquo;TLSv1_1&rsquo;,\n&rsquo;TLSv1_2&rsquo;, or &rsquo;TLSv1_3&rsquo; restrict\nhandshake and protocol to the specified version. All values\nare case-insensitive. Instead of &rsquo;TLSv1_1&rsquo;,\n&rsquo;TLSv1_2&rsquo;, and &rsquo;TLSv1_3&rsquo; one can\nalso use &rsquo;TLSv11&rsquo;, &rsquo;TLSv12&rsquo;, and\n&rsquo;TLSv13&rsquo;. Support for &rsquo;TLSv1_1&rsquo;,\n&rsquo;TLSv1_2&rsquo;, and &rsquo;TLSv1_3&rsquo; requires\nrecent versions of Net::SSLeay and openssl.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Independent\nfrom the handshake format you can limit to set of accepted\n<small>SSL</small> versions by adding !version separated by\n&rsquo;:&rsquo;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">The default\nSSL_version is &rsquo;SSLv23:!SSLv3:!SSLv2&rsquo; which\nmeans, that the handshake format is compatible to\n<small>SSL2.0</small> and higher, but that the successful\nhandshake is limited to <small>TLS1.0</small> and higher,\nthat is no <small>SSL2.0</small> or <small>SSL3.0</small>\nbecause both of these versions have serious security issues\nand should not be used anymore. You can also use !TLSv1_1\nand !TLSv1_2 to disable <small>TLS</small> versions 1.1 and\n1.2 while still allowing <small>TLS</small> version 1.0.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Setting the\nversion instead to &rsquo;TLSv1&rsquo; might break\ninteraction with older clients, which need and\n<small>SSL2.0</small> compatible handshake. On the other\nside some clients just close the connection when they\nreceive a <small>TLS</small> version 1.1 request. In this\ncase setting the version to\n&rsquo;SSLv23:!SSLv2:!SSLv3:!TLSv1_1:!TLSv1_2&rsquo; might\nhelp.</p>\n\n<p style=\"margin-left:17%;\">SSL_cipher_list</p>\n\n<p style=\"margin-left:20%;\">If this option is set the\ncipher list for the connection will be set to the given\nvalue, e.g. something like &rsquo; <small>ALL:</small>\n!LOW:!EXP:!aNULL&rsquo;. This will only affect ciphers for\n<small>TLS 1.2</small> and lower. See the OpenSSL\ndocumentation\n(&lt;https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html#CIPHER-STRINGS&gt;)\nfor more details.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Unless you fail\nto contact your peer because of no shared ciphers it is\nrecommended to leave this option at the default setting,\nwhich uses the system default but disables some insecure\nciphers which might still be enabled on older systems.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">In case\ndifferent cipher lists are needed for different\n<small>SNI</small> hosts a hash can be given with the host\nas key and the cipher suite as value, similar to\n<b>SSL_cert*</b>.</p>\n\n<p style=\"margin-left:17%;\">SSL_ciphersuites</p>\n\n<p style=\"margin-left:20%;\">If this option is set the\n<small>TLS 1.3</small> ciphersuites for the connection will\nbe set to the given value. This is similar to\nSSL_cipher_list, but only for <small>TLS 1.3</small>\nciphers. See argument &quot;-ciphersuits&quot; in the\nOpenSSL documentation\n(&lt;https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html&gt;)\nfor details.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Unless you fail\nto contact your peer because of no shared ciphers it is\nrecommended to leave this option at the default setting,\nwhich uses the system default.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">In case\ndifferent cipher lists are needed for different\n<small>SNI</small> hosts a hash can be given with the host\nas key and the cipher suite as value, similar to\n<b>SSL_cert*</b>.</p>\n\n<p style=\"margin-left:17%;\">SSL_honor_cipher_order</p>\n\n<p style=\"margin-left:20%;\">If this option is true the\ncipher order the server specified is used instead of the\norder proposed by the client. This option defaults to true\nto make use of our secure cipher list setting.</p>\n\n<p style=\"margin-left:17%;\">SSL_dh_file</p>\n\n<p style=\"margin-left:20%;\">To create a server which\nprovides forward secrecy you need to either give the\n<small>DH</small> parameters or (better, because faster) the\n<small>ECDH</small> curve. This setting cares about\n<small>DH</small> parameters.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">To support\nnon-elliptic Diffie-Hellman key exchange a suitable file\nneeds to be given here or the SSL_dh should be used with an\nappropriate value. See dhparam command in openssl for more\ninformation.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If neither\n&quot;SSL_dh_file&quot; nor &quot;SSL_dh&quot; are set a\nbuiltin <small>DH</small> parameter with a length of 2048\nbit is used to offer <small>DH</small> key exchange by\ndefault. If you don&rsquo;t want this (e.g. disable\n<small>DH</small> key exchange) explicitly set this or the\n&quot;SSL_dh&quot; parameter to undef.</p>\n\n<p style=\"margin-left:17%;\">SSL_dh</p>\n\n<p style=\"margin-left:20%;\">Like SSL_dh_file, but instead\nof giving a file you use a preloaded or generated DH*.</p>\n\n<p style=\"margin-left:17%;\">SSL_ecdh_curve</p>\n\n<p style=\"margin-left:20%;\">To create a server which\nprovides forward secrecy you need to either give the\n<small>DH</small> parameters or (better, because faster) the\n<small>ECDH</small> curve. This setting cares about the\n<small>ECDH</small> curve(s).</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">To support\nElliptic Curve Diffie-Hellmann key exchange the\n<small>OID</small> or <small>NID</small> of at least one\nsuitable curve needs to be provided here.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">With OpenSSL\n1.1.0+ this parameter defaults to &quot;auto&quot;, which\nmeans that it lets OpenSSL pick the best settings. If\nsupport for CTX_set_ecdh_auto is implemented in Net::SSLeay\n(needs at least version 1.86) it will use this to implement\nthe same default. Otherwise it will default to\n&quot;prime256v1&quot; (builtin of OpenSSL) in order to\noffer <small>ECDH</small> key exchange by default.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If setting\ngroups or curves is supported by Net::SSLeay (needs at least\nversion 1.86) then multiple curves can be given here in the\norder of the preference, i.e. &quot;P-521:P-384:P-256&quot;.\nWhen used at the client side this will include the supported\ncurves as extension in the <small>TLS</small> handshake.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If you\ndon&rsquo;t want to have <small>ECDH</small> key exchange\nthis could be set to undef or set &quot;SSL_ciphers&quot; to\nexclude all of these ciphers.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">You can check\nif <small>ECDH</small> support is available by calling\n&quot;IO::Socket::SSL-&gt;can_ecdh&quot;.</p>\n\n<p style=\"margin-left:17%;\">SSL_verify_mode</p>\n\n<p style=\"margin-left:20%;\">This option sets the\nverification mode for the peer certificate. You may combine\n<small>SSL_VERIFY_PEER</small> (verify_peer),\n<small>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</small> (fail\nverification if no peer certificate exists; ignored for\nclients), <small>SSL_VERIFY_CLIENT_ONCE</small> (verify\nclient once; ignored for clients). See OpenSSL man page for\nSSL_CTX_set_verify for more information.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">The default is\n<small>SSL_VERIFY_NONE</small> for server (e.g. no check for\nclient certificate) and <small>SSL_VERIFY_PEER</small> for\nclient (check server certificate).</p>\n\n<p style=\"margin-left:17%;\">SSL_verify_callback</p>\n\n<p style=\"margin-left:20%;\">If you want to verify\ncertificates yourself, you can pass a sub reference along\nwith this parameter to do so. When the callback is called,\nit will be passed: <br>\n1. a true/false value that indicates what OpenSSL thinks of\nthe <br>\ncertificate, <br>\n2. a C-style memory address of the certificate store, <br>\n3. a string containing the certificate&rsquo;s issuer\nattributes and <br>\nowner attributes, and <br>\n4. a string containing any errors encountered (0 if no\nerrors). <br>\n5. a C-style memory address of the peer&rsquo;s own\ncertificate <br>\n(convertible to <small>PEM</small> form with <b><br>\nNet::SSLeay::PEM_get_string_X509()</b>). <br>\n6. The depth of the certificate in the chain. Depth 0 is the\nleaf <br>\ncertificate.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">The function\nshould return 1 or 0, depending on whether it thinks the\ncertificate is valid or invalid. The default is to let\nOpenSSL do all of the busy work.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">The callback\nwill be called for each element in the certificate\nchain.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">See the OpenSSL\ndocumentation for SSL_CTX_set_verify for more\ninformation.</p>\n\n<p style=\"margin-left:17%;\">SSL_verifycn_scheme</p>\n\n<p style=\"margin-left:20%;\">The scheme is used to correctly\nverify the identity inside the certificate by using the\nhostname of the peer. See the information about the\nverification schemes in <b>verify_hostname</b>.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If you\ndon&rsquo;t specify a scheme it will use\n&rsquo;default&rsquo;, but only complain loudly if the name\nverification fails instead of letting the whole certificate\nverification fail. <small>THIS WILL CHANGE,</small> e.g. it\nwill let the certificate verification fail in the future if\nthe hostname does not match the certificate !!!! To override\nthe name used in verification use\n<b>SSL_verifycn_name</b>.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">The scheme\n&rsquo;default&rsquo; is a superset of the usual schemes,\nwhich will accept the hostname in common name and\nsubjectAltName and allow wildcards everywhere. While using\nthis scheme is way more secure than no name verification at\nall you better should use the scheme specific to your\napplication protocol, e.g. &rsquo;http&rsquo;,\n&rsquo;ftp&rsquo;...</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If you are\nreally sure, that you don&rsquo;t want to verify the\nidentity using the hostname you can use &rsquo;none&rsquo;\nas a scheme. In this case you&rsquo;d better have\nalternative forms of verification, like a certificate\nfingerprint or do a manual verification later by calling\n<b>verify_hostname</b> yourself.</p>\n\n<p style=\"margin-left:17%;\">SSL_verifycn_publicsuffix</p>\n\n<p style=\"margin-left:20%;\">This option is used to specify\nthe behavior when checking wildcards certificates for public\nsuffixes, e.g. no wildcard certificates for *.com or *.co.uk\nshould be accepted, while *.example.com or *.example.co.uk\nis ok.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If not\nspecified it will simply use the builtin default of\nIO::Socket::SSL::PublicSuffix, you can create another object\nwith from_string or from_file of this module.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">To disable\nverification of public suffix set this option to ''.</p>\n\n<p style=\"margin-left:17%;\">SSL_verifycn_name</p>\n\n<p style=\"margin-left:20%;\">Set the name which is used in\nverification of hostname. If SSL_verifycn_scheme is set and\nno SSL_verifycn_name is given it will try to use\nSSL_hostname or PeerHost and PeerAddr settings and fail if\nno name can be determined. If SSL_verifycn_scheme is not set\nit will use a default scheme and warn if it cannot determine\na hostname, but it will not fail.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Using PeerHost\nor PeerAddr works only if you create the connection directly\nwith &quot;IO::Socket::SSL-&gt;new&quot;, if an\nIO::Socket::INET object is upgraded with <b>start_SSL</b>\nthe name has to be given in <b>SSL_verifycn_name</b> or\n<b>SSL_hostname</b>.</p>\n\n<p style=\"margin-left:17%;\">SSL_check_crl</p>\n\n<p style=\"margin-left:20%;\">If you want to verify that the\npeer certificate has not been revoked by the signing\nauthority, set this value to true. OpenSSL will search for\nthe <small>CRL</small> in your SSL_ca_path, or use the file\nspecified by SSL_crl_file. See the Net::SSLeay documentation\nfor more details. Note that this functionality appears to be\nbroken with OpenSSL &lt; v0.9.7b, so its use with lower\nversions will result in an error.</p>\n\n<p style=\"margin-left:17%;\">SSL_crl_file</p>\n\n<p style=\"margin-left:20%;\">If you want to specify the\n<small>CRL</small> file to be used, set this value to the\npathname to be used. This must be used in addition to\nsetting SSL_check_crl.</p>\n\n<p style=\"margin-left:17%;\">SSL_ocsp_mode</p>\n\n<p style=\"margin-left:20%;\">Defines how certificate\nrevocation is done using <small>OCSP</small> (Online Status\nRevocation Protocol). The default is to send a request for\n<small>OCSP</small> stapling to the server and if the server\nsends an <small>OCSP</small> response back the result will\nbe used.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Any other\n<small>OCSP</small> checking needs to be done manually with\n&quot;ocsp_resolver&quot;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">The following\nflags can be combined with &quot;|&quot;: <small><br>\nSSL_OCSP_NO_STAPLE</small></p>\n\n<p style=\"margin-left:32%;\">Don&rsquo;t ask for\n<small>OCSP</small> stapling. This is the default if\nSSL_verify_mode is <small>VERIFY_NONE.</small></p>\n\n\n<p style=\"margin-left:20%;\"><small>SSL_OCSP_TRY_STAPLE</small></p>\n\n<p style=\"margin-left:32%;\">Try <small>OCSP</small>\nstapling, but don&rsquo;t complain if it gets no stapled\nresponse back. This is the default if SSL_verify_mode is\n<small>VERIFY_PEER</small> (the default).</p>\n\n\n<p style=\"margin-left:20%;\"><small>SSL_OCSP_MUST_STAPLE</small></p>\n\n<p style=\"margin-left:32%;\">Consider it a hard error, if\nthe server does not send a stapled <small>OCSP</small>\nresponse back. Most servers currently send no stapled\n<small>OCSP</small> response back.</p>\n\n\n<p style=\"margin-left:20%;\"><small>SSL_OCSP_FAIL_HARD</small></p>\n\n<p style=\"margin-left:32%;\">Fail hard on response errors,\ndefault is to fail soft like the browsers do. Soft errors\nmean, that the <small>OCSP</small> response is not usable,\ne.g. no response, error response, no valid signature etc.\nCertificate revocations inside a verified response are\nconsidered hard errors in any case.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Soft errors\ninside a stapled response are never considered hard, e.g. it\nis expected that in this case an <small>OCSP</small> request\nwill be send to the responsible <small>OCSP</small>\nresponder.</p>\n\n\n<p style=\"margin-left:20%;\"><small>SSL_OCSP_FULL_CHAIN</small></p>\n\n<p style=\"margin-left:32%;\">This will set up the\n&quot;ocsp_resolver&quot; so that all certificates from the\npeer chain will be checked, otherwise only the leaf\ncertificate will be checked against revocation.</p>\n\n<p style=\"margin-left:17%;\">SSL_ocsp_staple_callback</p>\n\n<p style=\"margin-left:20%;\">If this callback is defined, it\nwill be called with the <small>SSL</small> object and the\n<small>OCSP</small> response handle obtained from the peer,\ne.g. &quot;&lt;$cb-&quot;($ssl,$resp)&gt;&gt;. If the peer\ndid not provide a stapled <small>OCSP</small> response the\nfunction will be called with &quot;$resp=undef&quot;.\nBecause the <small>OCSP</small> response handle is no longer\nvalid after leaving this function it should not by copied or\nfreed. If access to the response is necessary after leaving\nthis function it can be serialized with\n&quot;Net::SSLeay::i2d_OCSP_RESPONSE&quot;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If no such\ncallback is provided, it will use the default one, which\nverifies the response and uses it to check if the\ncertificate(s) of the connection got revoked.</p>\n\n<p style=\"margin-left:17%;\">SSL_ocsp_cache</p>\n\n<p style=\"margin-left:20%;\">With this option a cache can be\ngiven for caching <small>OCSP</small> responses, which could\nbe shared between different <small>SSL</small> contexts. If\nnot given a cache specific to the <small>SSL</small> context\nonly will be used.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">You can either\ncreate a new cache with\n&quot;IO::Socket::SSL::OCSP_Cache-&gt;new([size])&quot; or\nimplement your own cache, which needs to have methods\n&quot;put($key,\\%entry)&quot; and &quot;get($key)&quot;\n(returning &quot;\\%entry&quot;) where entry is the hash\nrepresentation of the <small>OCSP</small> response with\nfields like &quot;nextUpdate&quot;. The default\nimplementation of the cache will consider responses valid as\nlong as &quot;nextUpdate&quot; is less then the current\ntime.</p>\n\n<p style=\"margin-left:17%;\">SSL_reuse_ctx</p>\n\n<p style=\"margin-left:20%;\">If you have already set the\nabove options for a previous instance of IO::Socket::SSL,\nthen you can reuse the <small>SSL</small> context of that\ninstance by passing it as the value for the SSL_reuse_ctx\nparameter. You may also create a new instance of the\nIO::Socket::SSL::SSL_Context class, using any context\noptions that you desire without specifying connection\noptions, and pass that here instead.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">If you use this\noption, all other context-related options that you pass in\nthe same call to <b>new()</b> will be ignored unless the\ncontext supplied was invalid. Note that, contrary to\nversions of IO::Socket::SSL below v0.90, a global\n<small>SSL</small> context will not be implicitly used\nunless you use the <b>set_default_context()</b>\nfunction.</p>\n\n<p style=\"margin-left:17%;\">SSL_create_ctx_callback</p>\n\n<p style=\"margin-left:20%;\">With this callback you can make\nindividual settings to the context after it got created and\nthe default setup was done. The callback will be called with\nthe <small>CTX</small> object from Net::SSLeay as the single\nargument.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Example for\nlimiting the server session cache size:</p>\n\n\n<p style=\"margin-left:20%; margin-top: 1em\">SSL_create_ctx_callback\n=&gt; sub { <br>\nmy $ctx = shift; <br>\nNet::SSLeay::CTX_sess_set_cache_size($ctx,128); <br>\n}</p>\n\n<p style=\"margin-left:17%;\">SSL_session_cache_size</p>\n\n<p style=\"margin-left:20%;\">If you make repeated\nconnections to the same host/port and the <small>SSL</small>\nrenegotiation time is an issue, you can turn on client-side\nsession caching with this option by specifying a positive\ncache size. For successive connections, pass the\nSSL_reuse_ctx option to the <b>new()</b> calls (or use\n<b>set_default_context()</b>) to make use of the cached\nsessions. The session cache size refers to the number of\nunique host/port pairs that can be stored at one time; the\noldest sessions in the cache will be removed if new ones are\nadded.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">This option\ndoes not effect the session cache a server has for\nit&rsquo;s clients, e.g. it does not affect\n<small>SSL</small> objects with SSL_server set.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Note that\nsession caching with <small>TLS 1.3</small> needs at least\nNet::SSLeay 1.86.</p>\n\n<p style=\"margin-left:17%;\">SSL_session_cache</p>\n\n<p style=\"margin-left:20%;\">Specifies session cache object\nwhich should be used instead of creating a new. Overrules\nSSL_session_cache_size. This option is useful if you want to\nreuse the cache, but not the rest of the context.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">A session cache\nobject can be created using\n&quot;IO::Socket::SSL::Session_Cache-&gt;new( cachesize\n)&quot;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Use\n<b>set_default_session_cache()</b> to set a global cache\nobject.</p>\n\n<p style=\"margin-left:17%;\">SSL_session_key</p>\n\n<p style=\"margin-left:20%;\">Specifies a key to use for\nlookups and inserts into client-side session cache. Per\ndefault ip:port of destination will be used, but sometimes\nyou want to share the same session over multiple ports on\nthe same server (like with <small>FTPS</small> ).</p>\n\n<p style=\"margin-left:17%;\">SSL_session_id_context</p>\n\n<p style=\"margin-left:20%;\">This gives an id for the\nservers session cache. It&rsquo;s necessary if you want\nclients to connect with a client certificate. If not given\nbut SSL_verify_mode specifies the need for client\ncertificate a context unique id will be picked.</p>\n\n<p style=\"margin-left:17%;\">SSL_error_trap</p>\n\n<p style=\"margin-left:20%;\">When using the <b>accept()</b>\nor <b>connect()</b> methods, it may be the case that the\nactual socket connection works but the <small>SSL</small>\nnegotiation fails, as in the case of an <small>HTTP</small>\nclient connecting to an <small>HTTPS</small> server. Passing\na subroutine ref attached to this parameter allows you to\ngain control of the orphaned socket instead of having it be\nclosed forcibly. The subroutine, if called, will be passed\ntwo parameters: a reference to the socket on which the\n<small>SSL</small> negotiation failed and the full text of\nthe error message.</p>\n\n<p style=\"margin-left:17%;\">SSL_npn_protocols</p>\n\n<p style=\"margin-left:20%;\">If used on the server side it\nspecifies list of protocols advertised by <small>SSL</small>\nserver as an array ref, e.g.\n[&rsquo;spdy/2&rsquo;,&rsquo;http1.1&rsquo;]. On the client\nside it specifies the protocols offered by the client for\n<small>NPN</small> as an array ref. See also method\n&quot;next_proto_negotiated&quot;.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Next Protocol\nNegotiation ( <small>NPN</small> ) is available with\nNet::SSLeay 1.46+ and openssl-1.0.1+. <small>NPN</small> is\nunavailable in TLSv1.3 protocol. To check support you might\ncall &quot;IO::Socket::SSL-&gt;can_npn()&quot;. If you use\nthis option with an unsupported Net::SSLeay/OpenSSL it will\nthrow an error.</p>\n\n<p style=\"margin-left:17%;\">SSL_alpn_protocols</p>\n\n<p style=\"margin-left:20%;\">If used on the server side it\nspecifies list of protocols supported by the\n<small>SSL</small> server as an array ref, e.g.\n[&rsquo;http/2.0&rsquo;,\n&rsquo;spdy/3.1&rsquo;,&rsquo;http/1.1&rsquo;]. On the\nclient side it specifies the protocols advertised by the\nclient for <small>ALPN</small> as an array ref. See also\nmethod &quot;alpn_selected&quot;.</p>\n\n\n<p style=\"margin-left:20%; margin-top: 1em\">Application-Layer\nProtocol Negotiation ( <small>ALPN</small> ) is available\nwith Net::SSLeay 1.56+ and openssl-1.0.2+. More details\nabout the extension are in <small>RFC7301.</small> To check\nsupport you might call\n&quot;IO::Socket::SSL-&gt;can_alpn()&quot;. If you use this\noption with an unsupported Net::SSLeay/OpenSSL it will throw\nan error.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Note that some\nclient implementations may encounter problems if both\n<small>NPN</small> and <small>ALPN</small> are specified.\nSince <small>ALPN</small> is intended as a replacement for\n<small>NPN,</small> try providing <small>ALPN</small>\nprotocols then fall back to <small>NPN</small> if that\nfails.</p>\n\n<p style=\"margin-left:17%;\">SSL_ticket_keycb =&gt;\n[$sub,$data] | $sub</p>\n\n<p style=\"margin-left:20%;\">This is a callback used for\nstateless session reuse (Session Tickets, <small>RFC\n5077</small> ).</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">This callback\nwill be called as &quot;$sub-&gt;($data,[$key_name])&quot;\nwhere $data is the argument given to SSL_ticket_keycb (or\nundef) and $key_name depends on the mode: <br>\nencrypt ticket</p>\n\n<p style=\"margin-left:32%;\">If a ticket needs to be\nencrypted the callback will be called without $key_name. In\nthis case it should return\n&quot;($current_key,$current_key_name&quot;) where\n$current_key is the current key (32 byte random data) and\n$current_key_name the name associated with this key (exactly\n16 byte). This $current_key_name will be incorporated into\nthe ticket.</p>\n\n<p style=\"margin-left:20%;\">decrypt ticket</p>\n\n<p style=\"margin-left:32%;\">If a ticket needs to be\ndecrypted the callback will be called with $key_name as\nfound in the ticket. It should return\n&quot;($key,$current_key_name&quot;) where $key is the key\nassociated with the given $key_name and $current_key_name\nthe name associated with the currently active key. If\n$current_key_name is different from the given $key_name the\ncallback will be called again to re-encrypt the ticket with\nthe currently active key.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">If no key can\nbe found which matches the given $key_name then this\nfunction should return nothing (empty list).</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">This mechanism\nshould be used to limit the life time for each key\nencrypting the ticket. Compromise of a ticket encryption key\nmight lead to decryption of <small>SSL</small> sessions\nwhich used session tickets protected by this key.</p>\n\n<p style=\"margin-left:20%; margin-top: 1em\">Example:</p>\n\n\n<p style=\"margin-left:20%; margin-top: 1em\">Net::SSLeay::RAND_bytes(my\n$oldkey,32); <br>\nNet::SSLeay::RAND_bytes(my $newkey,32); <br>\nmy $oldkey_name = pack(&quot;a16&quot;,'oldsecret'); <br>\nmy $newkey_name = pack(&quot;a16&quot;,'newsecret'); <br>\nmy @keys = ( <br>\n[ $newkey_name, $newkey ], # current active key <br>\n[ $oldkey_name, $oldkey ], # already expired <br>\n); <br>\nmy $keycb = [ sub { <br>\nmy ($mykeys,$name) = @_; <br>\n# return (current_key, current_key_name) if no name given\n<br>\nreturn ($mykeys-&gt;[0][1],$mykeys-&gt;[0][0]) if ! $name;\n<br>\n# return (matching_key, current_key_name) if we find a key\nmatching <br>\n# the given name <br>\nfor(my $i = 0; $i&lt;@$mykeys; $i++) { <br>\nnext if $name ne $mykeys-&gt;[$i][0]; <br>\nreturn ($mykeys-&gt;[$i][1],$mykeys-&gt;[0][0]); <br>\n} <br>\n# no matching key found <br>\nreturn; <br>\n},\\@keys ]; <br>\nmy $srv = IO::Socket::SSL-&gt;new(..., SSL_ticket_keycb\n=&gt; $keycb);</p>\n\n<p style=\"margin-left:17%;\">SSL_mode_release_buffers\n1|0</p>\n\n<p style=\"margin-left:20%;\">This enables or disables the\n<small>SSL_MODE_RELEASE_BUFFERS</small> option on the\n<small>SSL</small> object. With this option the read buffer\nwill be released after each SSL_read but will need to be\nreallocated for each new SSL_read. If memory usage is a\nconcern this might save lots of memory in the mean time\nthough, about 34k per idle <small>SSL</small> connection\naccording to the documentation in\n<b>SSL_CTX_set_mode</b>(3ssl).</p>\n\n<p style=\"margin-left:11%;\"><b>accept</b></p>\n\n<p style=\"margin-left:17%;\">This behaves similar to the\naccept function of the underlying socket class, but\nadditionally does the initial <small>SSL</small> handshake.\nBut because the underlying socket class does return a\nblocking file handle even when accept is called on a\nnon-blocking socket, the <small>SSL</small> handshake on the\nnew file object will be done in a blocking way. Please see\nthe section about non-blocking I/O for details. If you\ndon&rsquo;t like this behavior you should do accept on the\n<small>TCP</small> socket and then upgrade it with\n&quot;start_SSL&quot; later.</p>\n\n<p style=\"margin-left:11%;\"><b>connect(...)</b></p>\n\n<p style=\"margin-left:17%;\">This behaves similar to the\nconnect function but also does an <small>SSL</small>\nhandshake. Because you cannot give <small>SSL</small>\nspecific arguments to this function, you should better\neither use &quot;new&quot; to create a connect\n<small>SSL</small> socket or &quot;start_SSL&quot; to\nupgrade an established <small>TCP</small> socket to\n<small>SSL.</small></p>\n\n<p style=\"margin-left:11%;\"><b>close(...)</b></p>\n\n<p style=\"margin-left:17%;\">Contrary to a close for a\nsimple <small>INET</small> socket a close in\n<small>SSL</small> also mandates a proper shutdown of the\n<small>SSL</small> part. This is done by sending a close\nnotify message by both peers.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A naive\nimplementation would thus wait until it receives the close\nnotify message from the peer - which conflicts with the\ncommonly expected semantic that a close will not block. The\ndefault behavior is thus to only send a close notify but not\nwait for the close notify of the peer. If this is required\n&quot;SSL_fast_shutdown&quot; need to be explicitly set to\nfalse.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">There are also\ncases where a <small>SSL</small> shutdown should not be done\nat all. This is true for example when forking to let a child\ndeal with the socket and closing the socket in the parent\nprocess. A naive explicit &quot;close&quot; or an implicit\nclose when destroying the socket in the parent would send a\nclose notify to the peer which would make the\n<small>SSL</small> socket in the client process unusable. In\nthis case an explicit &quot;close&quot; with\n&quot;SSL_no_shutdown&quot; set to true should be done in\nthe parent process.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For more\ndetails and other arguments see &quot;stop_SSL&quot; which\ngets called from &quot;close&quot; to shutdown the\n<small>SSL</small> state of the socket.</p>\n\n<p style=\"margin-left:11%;\"><b>sysread( <small>BUF,\nLEN,</small> [ <small>OFFSET</small> ] )</b></p>\n\n<p style=\"margin-left:17%;\">This function behaves from the\noutside the same as <b>sysread</b> in other IO::Socket\nobjects, e.g. it returns at most <small>LEN</small> bytes of\ndata. But in reality it reads not only <small>LEN</small>\nbytes from the underlying socket, but at a single\n<small>SSL</small> frame. It then returns up to\n<small>LEN</small> bytes it decrypted from this\n<small>SSL</small> frame. If the frame contained more data\nthan requested it will return only <small>LEN</small> data,\nbuffer the rest and return it on further read calls. This\nmeans, that it might be possible to read data, even if the\nunderlying socket is not readable, so using poll or select\nmight not be sufficient.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sysread will\nonly return data from a single <small>SSL</small> frame,\ne.g. either the pending data from the already buffered frame\nor it will read a frame from the underlying socket and\nreturn the decrypted data. It will not return data spanning\nseveral <small>SSL</small> frames in a single call.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Also, calls to\nsysread might fail, because it must first finish an\n<small>SSL</small> handshake.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">To understand\nthese behaviors is essential, if you write applications\nwhich use event loops and/or non-blocking sockets. Please\nread the specific sections in this documentation.</p>\n\n<p style=\"margin-left:11%;\"><b>syswrite(\n<small>BUF,</small> [ <small>LEN,</small> [\n<small>OFFSET</small> ]] )</b></p>\n\n<p style=\"margin-left:17%;\">This functions behaves from the\noutside the same as <b>syswrite</b> in other IO::Socket\nobjects, e.g. it will write at most <small>LEN</small> bytes\nto the socket, but there is no guarantee, that all\n<small>LEN</small> bytes are written. It will return the\nnumber of bytes written. Because it basically just calls\nSSL_write from OpenSSL syswrite will write at most a single\n<small>SSL</small> frame. This means, that no more than\n16.384 bytes, which is the maximum size of an\n<small>SSL</small> frame, will be written at once.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\nnon-blocking sockets <small>SSL</small> specific behavior\napplies. Pease read the specific section in this\ndocumentation.</p>\n\n<p style=\"margin-left:11%;\"><b>peek( <small>BUF,\nLEN,</small> [ <small>OFFSET</small> ])</b></p>\n\n<p style=\"margin-left:17%;\">This function has exactly the\nsame syntax as <b>sysread</b>, and performs nearly the same\ntask but will not advance the read position so that\nsuccessive calls to <b>peek()</b> with the same arguments\nwill return the same results. This function requires OpenSSL\n0.9.6a or later to work.</p>\n\n<p style=\"margin-left:11%;\"><b>pending()</b></p>\n\n<p style=\"margin-left:17%;\">This function gives you the\nnumber of bytes available without reading from the\nunderlying socket object. This function is essential if you\nwork with event loops, please see the section about polling\n<small>SSL</small> sockets.</p>\n\n\n<p style=\"margin-left:11%;\"><b>get_fingerprint([algo,certificate,pubkey])</b></p>\n\n<p style=\"margin-left:17%;\">This methods returns the\nfingerprint of the given certificate in the form\n&quot;algo$digest_hex&quot;, where &quot;algo&quot; is the\nused algorithm, default &rsquo;sha256&rsquo;. If no\ncertificate is given the peer certificate of the connection\nis used. If &quot;pubkey&quot; is true it will not return\nthe fingerprint of the certificate but instead the\nfingerprint of the pubkey inside the certificate as\n&quot;algo$pub$digest_hex&quot;.</p>\n\n\n<p style=\"margin-left:11%;\"><b>get_fingerprint_bin([algo,certificate,pubkey])</b></p>\n\n<p style=\"margin-left:17%;\">This methods returns the binary\nfingerprint of the given certificate by using the algorithm\n&quot;algo&quot;, default &rsquo;sha256&rsquo;. If no\ncertificate is given the peer certificate of the connection\nis used. If &quot;pubkey&quot; is true it will not return\nthe fingerprint of the certificate but instead the\nfingerprint of the pubkey inside the certificate.</p>\n\n<p style=\"margin-left:11%;\"><b>get_cipher()</b></p>\n\n<p style=\"margin-left:17%;\">Returns the string form of the\ncipher that the IO::Socket::SSL object is using.</p>\n\n<p style=\"margin-left:11%;\"><b>get_sslversion()</b></p>\n\n<p style=\"margin-left:17%;\">Returns the string\nrepresentation of the <small>SSL</small> version of an\nestablished connection.</p>\n\n\n<p style=\"margin-left:11%;\"><b>get_sslversion_int()</b></p>\n\n<p style=\"margin-left:17%;\">Returns the integer\nrepresentation of the <small>SSL</small> version of an\nestablished connection.</p>\n\n\n<p style=\"margin-left:11%;\"><b>get_session_reused()</b></p>\n\n<p style=\"margin-left:17%;\">This returns true if the\nsession got reused and false otherwise. Note that with a\nreused session no certificates are send within the handshake\nand no ciphers are offered and thus functions which rely on\nthis might not work.</p>\n\n\n<p style=\"margin-left:11%;\"><b>dump_peer_certificate()</b></p>\n\n<p style=\"margin-left:17%;\">Returns a parsable string with\nselect fields from the peer <small>SSL</small> certificate.\nThis method directly returns the result of the\n<b>dump_peer_certificate()</b> method of Net::SSLeay.</p>\n\n\n<p style=\"margin-left:11%;\"><b>peer_certificate($field;[$refresh])</b></p>\n\n<p style=\"margin-left:17%;\">If a peer certificate exists,\nthis function can retrieve values from it. If no field is\ngiven the internal representation of certificate from\nNet::SSLeay is returned. If refresh is true it will not used\na cached version, but check again in case the certificate of\nthe connection has changed due to renegotiation.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The following\nfields can be queried: <br>\nauthority (alias issuer)</p>\n\n<p style=\"margin-left:29%;\">The certificate authority which\nsigned the certificate.</p>\n\n<p style=\"margin-left:17%;\">owner (alias subject)</p>\n\n<p style=\"margin-left:29%;\">The owner of the\ncertificate.</p>\n\n<p style=\"margin-left:17%;\">commonName (alias cn) - only\nfor Net::SSLeay version &gt;=1.30</p>\n\n<p style=\"margin-left:29%;\">The common name, usually the\nserver name for <small>SSL</small> certificates.</p>\n\n<p style=\"margin-left:17%;\">subjectAltNames - only for\nNet::SSLeay version &gt;=1.33</p>\n\n<p style=\"margin-left:29%;\">Alternative names for the\nsubject, usually different names for the same server, like\nexample.org, example.com, *.example.com.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">It returns a\nlist of (typ,value) with typ <small>GEN_DNS,\nGEN_IPADD</small> etc (these constants are exported from\nIO::Socket::SSL). See\nNet::SSLeay::X509_get_subjectAltNames.</p>\n\n\n<p style=\"margin-left:11%;\"><b>sock_certificate($field)</b></p>\n\n<p style=\"margin-left:17%;\">This is similar to\n&quot;peer_certificate&quot; but will return the sites own\ncertificate. The same arguments for <b>$field</b> can be\nused. If no <b>$field</b> is given the certificate handle\nfrom the underlying OpenSSL will be returned. This handle\nwill only be valid as long as the <small>SSL</small>\nconnection exists and if used afterwards it might result in\nstrange crashes of the application.</p>\n\n<p style=\"margin-left:11%;\"><b>peer_certificates</b></p>\n\n<p style=\"margin-left:17%;\">This returns all the\ncertificates send by the peer, e.g. first the peers own\ncertificate and then the rest of the chain. You might use\n<b>CERT_asHash</b> from IO::Socket::SSL::Utils to inspect\neach of the certificates.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This function\ndepends on a version of Net::SSLeay &gt;= 1.58 .</p>\n\n<p style=\"margin-left:11%;\"><b>get_servername</b></p>\n\n<p style=\"margin-left:17%;\">This gives the name requested\nby the client if Server Name Indication ( <small>SNI</small>\n) was used.</p>\n\n\n<p style=\"margin-left:11%;\"><b>verify_hostname($hostname,$scheme,$publicsuffix)</b></p>\n\n<p style=\"margin-left:17%;\">This verifies the given\nhostname against the peer certificate using the given\nscheme. Hostname is usually what you specify within the\nPeerAddr. See the &quot;SSL_verifycn_publicsuffix&quot;\nparameter for an explanation of suffix checking and for the\npossible values.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Verification of\nhostname against a certificate is different between various\napplications and RFCs. Some scheme allow wildcards for\nhostnames, some only in subjectAltNames, and even their\ndifferent wildcard schemes are possible. <small>RFC\n6125</small> provides a good overview.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">To ease the\nverification the following schemes are predefined (both\nprotocol name and rfcXXXX name can be used): <br>\nrfc2818, xmpp (rfc3920), ftp (rfc4217)</p>\n\n<p style=\"margin-left:29%;\">Extended wildcards in\nsubjectAltNames and common name are possible, e.g.\n*.example.org or even www*.example.org. The common name will\nbe only checked if no <small>DNS</small> names are given in\nsubjectAltNames.</p>\n\n<p style=\"margin-left:17%;\">http (alias www)</p>\n\n<p style=\"margin-left:29%;\">While name checking is defined\nin rfc2818 the current browsers usually accept also an\n<small>IP</small> address (w/o wildcards) within the common\nname as long as no subjectAltNames are defined. Thus this is\nrfc2818 extended with this feature.</p>\n\n<p style=\"margin-left:17%;\">smtp (rfc2595), imap, pop3,\nacap (rfc4642), netconf (rfc5538), <br>\nsyslog (rfc5425), snmp (rfc5953)</p>\n\n<p style=\"margin-left:29%;\">Simple wildcards in\nsubjectAltNames are possible, e.g. *.example.org matches\nwww.example.org but not lala.www.example.org. If nothing\nfrom subjectAltNames match it checks against the common\nname, where wildcards are also allowed to match the full\nleftmost label.</p>\n\n<p style=\"margin-left:17%;\">ldap (rfc4513)</p>\n\n<p style=\"margin-left:29%;\">Simple wildcards are allowed in\nsubjectAltNames, but not in common name. Common name will be\nchecked even if subjectAltNames exist.</p>\n\n<p style=\"margin-left:17%;\">sip (rfc5922)</p>\n\n<p style=\"margin-left:29%;\">No wildcards are allowed and\ncommon name is checked even if subjectAltNames exist.</p>\n\n<p style=\"margin-left:17%;\">gist (rfc5971)</p>\n\n<p style=\"margin-left:29%;\">Simple wildcards are allowed in\nsubjectAltNames and common name, but common name will only\nbe checked if their are no <small>DNS</small> names in\nsubjectAltNames.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"11%\">\n\n\n<p>default</p></td>\n<td width=\"1%\"></td>\n<td width=\"71%\">\n\n\n<p>This is a superset of all the rules and is automatically\nused if no scheme is given but a hostname (instead of\n<small>IP</small> ) is known. Extended wildcards are allowed\nin subjectAltNames and common name and common name is\nchecked always.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"11%\">\n\n\n<p>none</p></td>\n<td width=\"1%\"></td>\n<td width=\"71%\">\n\n\n<p>No verification will be done. Actually is does not make\nany sense to call verify_hostname in this case.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The scheme can\nbe given either by specifying the name for one of the above\npredefined schemes, or by using a hash which can have the\nfollowing keys and values: <br>\ncheck_cn: 0|&rsquo;always&rsquo;|&rsquo;when_only&rsquo;</p>\n\n<p style=\"margin-left:29%;\">Determines if the common name\ngets checked. If &rsquo;always&rsquo; it will always be\nchecked (like in ldap), if &rsquo;when_only&rsquo; it will\nonly be checked if no names are given in subjectAltNames\n(like in http), for any other values the common name will\nnot be checked.</p>\n\n<p style=\"margin-left:17%;\">wildcards_in_alt:\n0|&rsquo;full_label&rsquo;|&rsquo;anywhere&rsquo;</p>\n\n<p style=\"margin-left:29%;\">Determines if and where\nwildcards in subjectAltNames are possible. If\n&rsquo;full_label&rsquo; only cases like *.example.org will\nbe possible (like in ldap), for &rsquo;anywhere&rsquo;\nwww*.example.org is possible too (like http), dangerous\nthings like but www.*.org or even &rsquo;*&rsquo; will not\nbe allowed. For compatibility with older versions\n&rsquo;leftmost&rsquo; can be given instead of\n&rsquo;full_label&rsquo;.</p>\n\n<p style=\"margin-left:17%;\">wildcards_in_cn:\n0|&rsquo;full_label&rsquo;|&rsquo;anywhere&rsquo;</p>\n\n<p style=\"margin-left:29%;\">Similar to wildcards_in_alt,\nbut checks the common name. There is no predefined scheme\nwhich allows wildcards in common names.</p>\n\n<p style=\"margin-left:17%;\">ip_in_cn: 0|1|4|6</p>\n\n<p style=\"margin-left:29%;\">Determines if an\n<small>IP</small> address is allowed in the common name (no\nwildcards are allowed). If set to 4 or 6 it only allows IPv4\nor IPv6 addresses, any other true value allows both.</p>\n\n<p style=\"margin-left:17%;\">callback: \\&amp;coderef</p>\n\n<p style=\"margin-left:29%;\">If you give a subroutine for\nverification it will be called with the arguments\n($hostname,$commonName,@subjectAltNames), where hostname is\nthe name given for verification, commonName is the result\nfrom peer_certificate(&rsquo;cn&rsquo;) and subjectAltNames\nis the result from\npeer_certificate(&rsquo;subjectAltNames&rsquo;).</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">All other\narguments for the verification scheme will be ignored in\nthis case.</p>\n\n\n<p style=\"margin-left:11%;\"><b>next_proto_negotiated()</b></p>\n\n<p style=\"margin-left:17%;\">This method returns the name of\nnegotiated protocol - e.g. &rsquo;http/1.1&rsquo;. It works\nfor both client and server side of <small>SSL</small>\nconnection.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>NPN</small>\nsupport is available with Net::SSLeay 1.46+ and\nopenssl-1.0.1+. To check support you might call\n&quot;IO::Socket::SSL-&gt;can_npn()&quot;.</p>\n\n<p style=\"margin-left:11%;\"><b>alpn_selected()</b></p>\n\n<p style=\"margin-left:17%;\">Returns the protocol negotiated\nvia <small>ALPN</small> as a string, e.g.\n&rsquo;http/1.1&rsquo;, &rsquo;http/2.0&rsquo; or\n&rsquo;spdy/3.1&rsquo;.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>ALPN</small>\nsupport is available with Net::SSLeay 1.56+ and\nopenssl-1.0.2+. To check support, use\n&quot;IO::Socket::SSL-&gt;can_alpn()&quot;.</p>\n\n<p style=\"margin-left:11%;\"><b>errstr()</b></p>\n\n<p style=\"margin-left:17%;\">Returns the last error (in\nstring form) that occurred. If you do not have a real object\nto perform this method on, call\n<b>IO::Socket::SSL::errstr()</b> instead.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For read and\nwrite errors on non-blocking sockets, this method may\ninclude the string &quot;SSL wants a read first!&quot; or\n&quot;SSL wants a write first!&quot; meaning that the other\nside is expecting to read from or write to the socket and\nwants to be satisfied before you get to do anything. But\nwith version 0.98 you are better comparing the global\nexported variable $SSL_ERROR against the exported symbols\n<small>SSL_WANT_READ</small> and\n<small>SSL_WANT_WRITE.</small></p>\n\n<p style=\"margin-left:11%;\"><b>opened()</b></p>\n\n<p style=\"margin-left:17%;\">This returns false if the\nsocket could not be opened, 1 if the socket could be opened\nand the <small>SSL</small> handshake was successful done and\n-1 if the underlying IO::Handle is open, but the\n<small>SSL</small> handshake failed.</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL-&gt;start_SSL($socket,\n... )</b></p>\n\n<p style=\"margin-left:17%;\">This will convert a glob\nreference or a socket that you provide to an IO::Socket::SSL\nobject. You may also pass parameters to specify context or\nconnection options as with a call to <b>new()</b>. If you\nare using this function on an <b>accept()</b>ed socket, you\nmust set the parameter &quot;SSL_server&quot; to 1, i.e.\nIO::Socket::SSL-&gt;start_SSL($socket, SSL_server =&gt; 1).\nIf you have a class that inherits from IO::Socket::SSL and\nyou want the $socket to be blessed into your own class\ninstead, use MyClass-&gt;start_SSL($socket) to achieve the\ndesired effect.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that if\n<b>start_SSL()</b> fails in <small>SSL</small> negotiation,\n$socket will remain blessed in its original class. For\nnon-blocking sockets you better just upgrade the socket to\nIO::Socket::SSL and call accept_SSL or connect_SSL and the\nupgraded object. To just upgrade the socket set\n<b>SSL_startHandshake</b> explicitly to 0. If you call\nstart_SSL w/o this parameter it will revert to blocking\nbehavior for accept_SSL and connect_SSL.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If given the\nparameter &quot;Timeout&quot; it will stop if after the\ntimeout no <small>SSL</small> connection was established.\nThis parameter is only used for blocking sockets, if it is\nnot given the default Timeout from the underlying IO::Socket\nwill be used.</p>\n\n<p style=\"margin-left:11%;\"><b>stop_SSL(...)</b></p>\n\n<p style=\"margin-left:17%;\">This is the opposite of\n<b>start_SSL()</b>, <b>connect_SSL()</b> and\n<b>accept_SSL()</b>, e.g. it will shutdown the\n<small>SSL</small> connection and return to the class before\n<b>start_SSL()</b>. It gets the same arguments as\n<b>close()</b>, in fact <b>close()</b> calls\n<b>stop_SSL()</b> (but without downgrading the class).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Will return\ntrue if it succeeded and undef if failed. This might be the\ncase for non-blocking sockets. In this case $! is set to\n<small>EWOULDBLOCK</small> and the ssl error to\n<small>SSL_WANT_READ</small> or\n<small>SSL_WANT_WRITE.</small> In this case the call should\nbe retried again with the same arguments once the socket is\nready.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For calling\nfrom &quot;stop_SSL&quot; &quot;SSL_fast_shutdown&quot;\ndefault to false, e.g. it waits for the close_notify of the\npeer. This is necessary in case you want to downgrade the\nsocket and continue to use it as a plain socket.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">After stop_SSL\nthe socket can again be used to exchange plain data.</p>\n\n<p style=\"margin-left:11%;\"><b>connect_SSL</b>,\n<b>accept_SSL</b></p>\n\n<p style=\"margin-left:17%;\">These functions should be used\nto do the relevant handshake, if the socket got created with\n&quot;new&quot; or upgraded with &quot;start_SSL&quot; and\n&quot;SSL_startHandshake&quot; was set to false. They will\nreturn undef until the handshake succeeded or an error got\nthrown. As long as the function returns undef and $! is set\nto <small>EWOULDBLOCK</small> one could retry the call after\nthe socket got readable ( <small>SSL_WANT_READ</small> ) or\nwriteable ( <small>SSL_WANT_WRITE</small> ).</p>\n\n<p style=\"margin-left:11%;\"><b>ocsp_resolver</b></p>\n\n<p style=\"margin-left:17%;\">This will create an\n<small>OCSP</small> resolver object, which can be used to\ncreate <small>OCSP</small> requests for the certificates of\nthe <small>SSL</small> connection. Which certificates are\nverified depends on the setting of\n&quot;SSL_ocsp_mode&quot;: by default only the leaf\ncertificate will be checked, but with\n<small>SSL_OCSP_FULL_CHAIN</small> all chain certificates\nwill be checked.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Because to\ncreate an <small>OCSP</small> request the certificate and\nits issuer certificate need to be known it is not possible\nto check certificates when the trust chain is incomplete or\nif the certificate is self-signed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n<small>OCSP</small> resolver gets created by calling\n&quot;$ssl-&gt;ocsp_resolver&quot; and provides the\nfollowing methods: <br>\nhard_error</p>\n\n<p style=\"margin-left:29%;\">This returns the hard error\nwhen checking the <small>OCSP</small> response. Hard errors\nare certificate revocations. With the\n&quot;SSL_ocsp_mode&quot; of\n<small>SSL_OCSP_FAIL_HARD</small> any soft error (e.g.\nfailures to get signed information about the certificates)\nwill be considered a hard error too.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">The\n<small>OCSP</small> resolving will stop on the first hard\nerror.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">The method will\nreturn undef as long as no hard errors occurred and still\nrequests to be resolved. If all requests got resolved and no\nhard errors occurred the method will return ''.</p>\n\n<p style=\"margin-left:17%;\">soft_error</p>\n\n<p style=\"margin-left:29%;\">This returns the soft error(s)\nwhich occurred when asking the <small>OCSP</small>\nresponders.</p>\n\n<p style=\"margin-left:17%;\">requests</p>\n\n<p style=\"margin-left:29%;\">This will return a hash\nconsisting of &quot;(url,request)&quot;-tuples, e.g. which\ncontain the <small>OCSP</small> request string and the\n<small>URL</small> where it should be sent too. The usual\nway to send such a request is as <small>HTTP POST</small>\nrequest with a content-type of\n&quot;application/ocsp-request&quot; or as a\n<small>GET</small> request with the base64 and url-encoded\nrequest is added to the path of the <small>URL.</small></p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">After\nyou&rsquo;ve handled all these requests and added the\nresponse with &quot;add_response&quot; you should better\ncall this method again to make sure, that no more requests\nare outstanding. IO::Socket::SSL will combine multiple\n<small>OCSP</small> requests for the same server inside a\nsingle request, but some server don&rsquo;t give a response\nto all these requests, so that one has to ask again with the\nremaining requests.</p>\n\n\n<p style=\"margin-left:17%;\">add_response($uri,$response)</p>\n\n<p style=\"margin-left:29%;\">This method takes the\n<small>HTTP</small> body of the response which got received\nwhen sending the <small>OCSP</small> request to $uri. If no\nresponse was received or an error occurred one should either\nretry or consider $response as empty which will trigger a\nsoft error.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">The method\nreturns the current value of &quot;hard_error&quot;, e.g. a\ndefined value when no more requests need to be done.</p>\n\n<p style=\"margin-left:17%;\">resolve_blocking(%args)</p>\n\n<p style=\"margin-left:29%;\">This combines\n&quot;requests&quot; and &quot;add_response&quot; which\nHTTP::Tiny to do all necessary requests in a blocking way.\n%args will be given to HTTP::Tiny so that you can put proxy\nsettings etc here. HTTP::Tiny will be called with\n&quot;verify_SSL&quot; of false, because the\n<small>OCSP</small> responses have their own signatures so\nno extra <small>SSL</small> verification is needed.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">If you\ndon&rsquo;t want to use blocking requests you need to roll\nyour own user agent with &quot;requests&quot; and\n&quot;add_response&quot;.</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL-&gt;new_from_fd($fd,\n[mode], %sslargs)</b></p>\n\n<p style=\"margin-left:17%;\">This will convert a socket\nidentified via a file descriptor into an <small>SSL</small>\nsocket. Note that the argument list does not include a\n&quot; <small>MODE&quot;</small> argument; if you supply\none, it will be thoughtfully ignored (for compatibility with\nIO::Socket::INET). Instead, a mode of &rsquo;+&lt;&rsquo; is\nassumed, and the file descriptor passed must be able to\nhandle such I/O because the initial <small>SSL</small>\nhandshake requires bidirectional communication.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Internally the\ngiven $fd will be upgraded to a socket object using the\n&quot;new_from_fd&quot; method of the super class\n(IO::Socket::INET or similar) and then &quot;start_SSL&quot;\nwill be called using the given %sslargs. If $fd is already\nan IO::Socket object you should better call\n&quot;start_SSL&quot; directly.</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL::default_ca([\npath|dir| SSL_ca_file =</b> ..., SSL_ca_path <br>\n=&gt; ... ])&gt;</p>\n\n<p style=\"margin-left:17%;\">Determines or sets the default\n<small>CA</small> path. If existing path or dir or a hash is\ngiven it will set the default <small>CA</small> path to this\nvalue and never try to detect it automatically. If\n&quot;undef&quot; is given it will forget any stored\ndefaults and continue with detection of system defaults. If\nno arguments are given it will start detection of system\ndefaults, unless it has already stored user-set or\npreviously detected values.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The detection\nof system defaults works similar to OpenSSL, e.g. it will\ncheck the directory specified in environment variable\n<small>SSL_CERT_DIR</small> or the path OPENSSLDIR/certs (\n<small>SSLCERTS:</small> on <small>VMS</small> ) and the\nfile specified in environment variable\n<small>SSL_CERT_FILE</small> or the path OPENSSLDIR/cert.pem\n(SSLCERTS:cert.pem on <small>VMS</small> ). Contrary to\nOpenSSL it will check if the SSL_ca_path contains\n<small>PEM</small> files with the hash as file name and if\nthe SSL_ca_file looks like <small>PEM.</small> If no usable\nsystem default can be found it will try to load and use\nMozilla::CA and if not available give up detection. The\nresult of the detection will be saved to speed up future\ncalls.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The function\nreturns the saved default <small>CA</small> as hash with\nSSL_ca_file and SSL_ca_path.</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL::set_default_context(...)</b></p>\n\n<p style=\"margin-left:17%;\">You may use this to make\nIO::Socket::SSL automatically re-use a given context (unless\nspecifically overridden in a call to <b>new()</b>). It\naccepts one argument, which should be either an\nIO::Socket::SSL object or an IO::Socket::SSL::SSL_Context\nobject. See the SSL_reuse_ctx option of <b>new()</b> for\nmore details. Note that this sets the default context\nglobally, so use with caution (esp. in mod_perl\nscripts).</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL::set_default_session_cache(...)</b></p>\n\n<p style=\"margin-left:17%;\">You may use this to make\nIO::Socket::SSL automatically re-use a given session cache\n(unless specifically overridden in a call to <b>new()</b>).\nIt accepts one argument, which should be an\nIO::Socket::SSL::Session_Cache object or similar (e.g.\nsomething which implements get_session, add_session and\ndel_session like IO::Socket::SSL::Session_Cache does). See\nthe SSL_session_cache option of <b>new()</b> for more\ndetails. Note that this sets the default cache globally, so\nuse with caution.</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL::set_defaults(%args)</b></p>\n\n<p style=\"margin-left:17%;\">With this function one can set\ndefaults for all SSL_* parameter used for creation of the\ncontext, like the SSL_verify* parameter. Any SSL_* parameter\ncan be given or the following short versions: <br>\nmode - SSL_verify_mode <br>\ncallback - SSL_verify_callback <br>\nscheme - SSL_verifycn_scheme <br>\nname - SSL_verifycn_name</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL::set_client_defaults(%args)</b></p>\n\n<p style=\"margin-left:17%;\">Similar to\n&quot;set_defaults&quot;, but only sets the defaults for\nclient mode.</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL::set_server_defaults(%args)</b></p>\n\n<p style=\"margin-left:17%;\">Similar to\n&quot;set_defaults&quot;, but only sets the defaults for\nserver mode.</p>\n\n\n<p style=\"margin-left:11%;\"><b>IO::Socket::SSL::set_args_filter_hack(\\&amp;code|&rsquo;use_defaults&rsquo;)</b></p>\n\n<p style=\"margin-left:17%;\">Sometimes one has to use code\nwhich uses unwanted or invalid arguments for\n<small>SSL,</small> typically disabling <small>SSL</small>\nverification or setting wrong ciphers or <small>SSL</small>\nversions. With this hack it is possible to override these\nsettings and restore sanity. Example:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">IO::Socket::SSL::set_args_filter_hack(\nsub { <br>\nmy ($is_server,$args) = @_; <br>\nif ( ! $is_server ) { <br>\n# client settings - enable verification with default CA <br>\n# and fallback hostname verification etc <br>\ndelete @{$args}{qw( <br>\nSSL_verify_mode <br>\nSSL_ca_file <br>\nSSL_ca_path <br>\nSSL_verifycn_scheme <br>\nSSL_version <br>\n)}; <br>\n# and add some fingerprints for known certs which are signed\nby <br>\n# unknown CAs or are self-signed <br>\n$args-&gt;{SSL_fingerprint} = ... <br>\n} <br>\n});</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">With the short\nsetting &quot;set_args_filter_hack('use_defaults')&quot; it\nwill prefer the default settings in all cases. These default\nsettings can be modified with &quot;set_defaults&quot;,\n&quot;set_client_defaults&quot; and\n&quot;set_server_defaults&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethods are unsupported (not to mention futile!) and\nIO::Socket::SSL will emit a large <b><small>CROAK</small>\n()</b> if you are silly enough to use them: <br>\ntruncate <br>\nstat <br>\nungetc <br>\nsetbuf <br>\nsetvbuf <br>\nfdopen <br>\nsend/recv</p>\n\n<p style=\"margin-left:17%;\">Note that <b>send()</b> and\n<b>recv()</b> cannot be reliably trapped by a tied\nfilehandle (such as that used by IO::Socket::SSL) and so may\nsend unencrypted data over the socket. Object-oriented calls\nto these functions will fail, telling you to use the\nprint/printf/syswrite and read/sysread families instead.</p>\n\n<h2>DEPRECATIONS\n<a name=\"DEPRECATIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nfunctions are deprecated and are only retained for\ncompatibility: <b><br>\ncontext_init()</b></p>\n\n<p style=\"margin-left:14%;\">use the SSL_reuse_ctx option if\nyou want to re-use a context</p>\n\n<p style=\"margin-left:11%;\"><b>socketToSSL()</b> and\n<b>socket_to_SSL()</b></p>\n\n<p style=\"margin-left:14%;\">use\nIO::Socket::SSL-&gt;<b>start_SSL()</b> instead</p>\n\n<p style=\"margin-left:11%;\"><b>kill_socket()</b></p>\n\n<p style=\"margin-left:14%;\">use <b>close()</b> instead</p>\n\n\n<p style=\"margin-left:11%;\"><b>get_peer_certificate()</b></p>\n\n<p style=\"margin-left:14%;\">use the\n<b>peer_certificate()</b> function instead. Used to return\nX509_Certificate with methods subject_name and issuer_name.\nNow simply returns $self which has these methods (although\ndeprecated).</p>\n\n<p style=\"margin-left:11%;\"><b>issuer_name()</b></p>\n\n<p style=\"margin-left:14%;\">use peer_certificate(\n&rsquo;issuer&rsquo; ) instead</p>\n\n<p style=\"margin-left:11%;\"><b>subject_name()</b></p>\n\n<p style=\"margin-left:14%;\">use peer_certificate(\n&rsquo;subject&rsquo; ) instead</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\n&rsquo;example&rsquo; directory, the tests in\n&rsquo;t&rsquo; and also the tools in\n&rsquo;util&rsquo;.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you use\nIO::Socket::SSL together with threads you should load it\n(e.g. use or require) inside the main thread before creating\nany other threads which use it. This way it is much faster\nbecause it will be initialized only once. Also there are\nreports that it might crash the other way.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Creating an\nIO::Socket::SSL object in one thread and closing it in\nanother thread will not work.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL\ndoes not work together with Storable::fd_retrieve/fd_store.\nSee <small>BUGS</small> file for more information and how to\nwork around the problem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Non-blocking\nand timeouts (which are based on non-blocking) are not\nsupported on Win32, because the underlying IO::Socket::INET\ndoes not support non-blocking on this platform.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you have a\nserver and it looks like you have a memory leak you might\ncheck the size of your session cache. Default for\nNet::SSLeay seems to be 20480, see the example for\nSSL_create_ctx_callback for how to limit it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>TLS\n1.3</small> support regarding session reuse is\nincomplete.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::INET,\nIO::Socket::INET6, IO::Socket::IP, Net::SSLeay.</p>\n\n<h2>THANKS\n<a name=\"THANKS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many thanks to\nall who added patches or reported bugs or helped\nIO::Socket::SSL another way. Please keep reporting bugs and\nhelp with patches, even if they just fix the\ndocumentation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Special thanks\nto the team of Net::SSLeay for the good cooperation.</p>\n\n<h2>AUTHORS\n<a name=\"AUTHORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Steffen\nUllrich, &lt;sullr at cpan.org&gt; is the current\nmaintainer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Peter Behroozi,\n&lt;behrooz at fas.harvard.edu&gt; (Note the lack of an\n&quot;i&quot; at the end of &quot;behrooz&quot;)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Marko Asplund,\n&lt;marko.asplund at kronodoc.fi&gt;, was the original\nauthor of IO::Socket::SSL.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Patches\nincorporated from various people, see file Changes.</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The original\nversions of this module are Copyright (C) 1999-2002 Marko\nAsplund.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The rewrite of\nthis module is Copyright (C) 2002-2005 Peter Behroozi.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Versions 0.98\nand newer are Copyright (C) 2006-2014 Steffen Ullrich.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#Essential Information About SSL/TLS\">Essential Information About SSL/TLS</a>","<a href=\"#Basic SSL Client\">Basic SSL Client</a>","<a href=\"#Basic SSL Server\">Basic SSL Server</a>","<a href=\"#Common Usage Errors\">Common Usage Errors</a>","<a href=\"#Common Problems with SSL\">Common Problems with SSL</a>","<a href=\"#Using Non-Blocking Sockets\">Using Non-Blocking Sockets</a>","<a href=\"#Advanced Usage\">Advanced Usage</a>","<a href=\"#Integration Into Own Modules\">Integration Into Own Modules</a>","<a href=\"#Description Of Methods\">Description Of Methods</a>","<a href=\"#DEPRECATIONS\">DEPRECATIONS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#THANKS\">THANKS</a>","<a href=\"#AUTHORS\">AUTHORS</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":3}