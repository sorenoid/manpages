{"name":"malloc","description":"malloc, free, calloc, realloc, reallocarray - allocate and free dynamic memory","body":"\n\n<h1 align=\"center\">MALLOC</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">malloc, free,\ncalloc, realloc, reallocarray - allocate and free dynamic\nmemory</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;stdlib.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*malloc(size_t</b> <i>size</i><b>); <br>\nvoid free(void</b> <i>*ptr</i><b>); <br>\nvoid *calloc(size_t</b> <i>nmemb</i><b>, size_t</b>\n<i>size</i><b>); <br>\nvoid *realloc(void</b> <i>*ptr</i><b>, size_t</b>\n<i>size</i><b>); <br>\nvoid *reallocarray(void</b> <i>*ptr</i><b>, size_t</b>\n<i>nmemb</i><b>, size_t</b> <i>size</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>reallocarray</b>():\n<br>\nSince glibc 2.29: <br>\n_DEFAULT_SOURCE <br>\nGlibc 2.28 and earlier: <br>\n_GNU_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>malloc</b>() function allocates <i>size</i> bytes and\nreturns a pointer to the allocated memory. <i>The memory is\nnot initialized</i>. If <i>size</i> is 0, then\n<b>malloc</b>() returns either NULL, or a unique pointer\nvalue that can later be successfully passed to\n<b>free</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>free</b>() function frees the memory space pointed to by\n<i>ptr</i>, which must have been returned by a previous call\nto <b>malloc</b>(), <b>calloc</b>(), or <b>realloc</b>().\nOtherwise, or if <i>free(ptr)</i> has already been called\nbefore, undefined behavior occurs. If <i>ptr</i> is NULL, no\noperation is performed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>calloc</b>() function allocates memory for an array of\n<i>nmemb</i> elements of <i>size</i> bytes each and returns\na pointer to the allocated memory. The memory is set to\nzero. If <i>nmemb</i> or <i>size</i> is 0, then\n<b>calloc</b>() returns either NULL, or a unique pointer\nvalue that can later be successfully passed to\n<b>free</b>(). If the multiplication of <i>nmemb</i> and\n<i>size</i> would result in integer overflow, then\n<b>calloc</b>() returns an error. By contrast, an integer\noverflow would not be detected in the following call to\n<b>malloc</b>(), with the result that an incorrectly sized\nblock of memory would be allocated:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">malloc(nmemb *\nsize);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>realloc</b>() function changes the size of the memory\nblock pointed to by <i>ptr</i> to <i>size</i> bytes. The\ncontents will be unchanged in the range from the start of\nthe region up to the minimum of the old and new sizes. If\nthe new size is larger than the old size, the added memory\nwill <i>not</i> be initialized. If <i>ptr</i> is NULL, then\nthe call is equivalent to <i>malloc(size)</i>, for all\nvalues of <i>size</i>; if <i>size</i> is equal to zero, and\n<i>ptr</i> is not NULL, then the call is equivalent to\n<i>free(ptr)</i>. Unless <i>ptr</i> is NULL, it must have\nbeen returned by an earlier call to <b>malloc</b>(),\n<b>calloc</b>(), or <b>realloc</b>(). If the area pointed to\nwas moved, a <i>free(ptr)</i> is done.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>reallocarray</b>() function changes the size of the\nmemory block pointed to by <i>ptr</i> to be large enough for\nan array of <i>nmemb</i> elements, each of which is\n<i>size</i> bytes. It is equivalent to the call</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">realloc(ptr,\nnmemb * size);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, unlike\nthat <b>realloc</b>() call, <b>reallocarray</b>() fails\nsafely in the case where the multiplication would overflow.\nIf such an overflow occurs, <b>reallocarray</b>() returns\nNULL, sets <i>errno</i> to <b>ENOMEM</b>, and leaves the\noriginal block of memory unchanged.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>malloc</b>() and <b>calloc</b>() functions return a\npointer to the allocated memory, which is suitably aligned\nfor any built-in type. On error, these functions return\nNULL. NULL may also be returned by a successful call to\n<b>malloc</b>() with a <i>size</i> of zero, or by a\nsuccessful call to <b>calloc</b>() with <i>nmemb</i> or\n<i>size</i> equal to zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>free</b>() function returns no value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>realloc</b>() function returns a pointer to the newly\nallocated memory, which is suitably aligned for any built-in\ntype, or NULL if the request failed. The returned pointer\nmay be the same as <i>ptr</i> if the allocation was not\nmoved (e.g., there was room to expand the allocation\nin-place), or different from <i>ptr</i> if the allocation\nwas moved to a new address. If <i>size</i> was equal to 0,\neither NULL or a pointer suitable to be passed to\n<b>free</b>() is returned. If <b>realloc</b>() fails, the\noriginal block is left untouched; it is not freed or\nmoved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success, the\n<b>reallocarray</b>() function returns a pointer to the\nnewly allocated memory. On failure, it returns NULL and the\noriginal block of memory is left untouched.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>calloc</b>(),\n<b>malloc</b>(), <b>realloc</b>(), and <b>reallocarray</b>()\ncan fail with the following error:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Out of memory. Possibly, the application hit the\n<b>RLIMIT_AS</b> or <b>RLIMIT_DATA</b> limit described in\n<a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>.</p> </td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>reallocarray</b>()\nfirst appeared in glibc in version 2.26.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3385711.png\" alt=\"Image grohtml-3385711.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>malloc</b>(),\n<b>free</b>(), <b>calloc</b>(), <b>realloc</b>():\nPOSIX.1-2001, POSIX.1-2008, C89, C99.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>reallocarray</b>()\nis a nonstandard extension that first appeared in OpenBSD\n5.6 and FreeBSD 11.0.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nLinux follows an optimistic memory allocation strategy. This\nmeans that when <b>malloc</b>() returns non-NULL there is no\nguarantee that the memory really is available. In case it\nturns out that the system is out of memory, one or more\nprocesses will be killed by the OOM killer. For more\ninformation, see the description of\n<i>/proc/sys/vm/overcommit_memory</i> and\n<i>/proc/sys/vm/oom_adj</i> in <a href=\"https://man.page/5/proc\">proc(5)</a>, and the Linux\nkernel source file\n<i>Documentation/vm/overcommit-accounting.rst</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Normally,\n<b>malloc</b>() allocates memory from the heap, and adjusts\nthe size of the heap as required, using <a href=\"https://man.page/2/sbrk\">sbrk(2)</a>. When\nallocating blocks of memory larger than\n<b>MMAP_THRESHOLD</b> bytes, the glibc <b>malloc</b>()\nimplementation allocates the memory as a private anonymous\nmapping using <a href=\"https://man.page/2/mmap\">mmap(2)</a>. <b>MMAP_THRESHOLD</b> is\n128&nbsp;kB by default, but is adjustable using\n<a href=\"https://man.page/3/mallopt\">mallopt(3)</a>. Prior to Linux 4.7 allocations performed\nusing <a href=\"https://man.page/2/mmap\">mmap(2)</a> were unaffected by the\n<b>RLIMIT_DATA</b> resource limit; since Linux 4.7, this\nlimit is also enforced for allocations performed using\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To avoid\ncorruption in multithreaded applications, mutexes are used\ninternally to protect the memory-management data structures\nemployed by these functions. In a multithreaded application\nin which threads simultaneously allocate and free memory,\nthere could be contention for these mutexes. To scalably\nhandle memory allocation in multithreaded applications,\nglibc creates additional <i>memory allocation arenas</i> if\nmutex contention is detected. Each arena is a large region\nof memory that is internally allocated by the system (using\n<a href=\"https://man.page/2/brk\">brk(2)</a> or <a href=\"https://man.page/2/mmap\">mmap(2)</a>), and managed with its own\nmutexes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">SUSv2 requires\n<b>malloc</b>(), <b>calloc</b>(), and <b>realloc</b>() to\nset <i>errno</i> to <b>ENOMEM</b> upon failure. Glibc\nassumes that this is done (and the glibc versions of these\nroutines do this); if you use a private malloc\nimplementation that does not set <i>errno</i>, then certain\nlibrary routines may fail without having a reason in\n<i>errno</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Crashes in\n<b>malloc</b>(), <b>calloc</b>(), <b>realloc</b>(), or\n<b>free</b>() are almost always related to heap corruption,\nsuch as overflowing an allocated chunk or freeing the same\npointer twice.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>malloc</b>() implementation is tunable via environment\nvariables; see <a href=\"https://man.page/3/mallopt\">mallopt(3)</a> for details.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/valgrind\">valgrind(1)</a>,\n<a href=\"https://man.page/2/brk\">brk(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/3/alloca\">alloca(3)</a>,\n<a href=\"https://man.page/3/malloc_get_state\">malloc_get_state(3)</a>, <a href=\"https://man.page/3/malloc_info\">malloc_info(3)</a>,\n<a href=\"https://man.page/3/malloc_trim\">malloc_trim(3)</a>, <a href=\"https://man.page/3/malloc_usable_size\">malloc_usable_size(3)</a>,\n<a href=\"https://man.page/3/mallopt\">mallopt(3)</a>, <a href=\"https://man.page/3/mcheck\">mcheck(3)</a>, <a href=\"https://man.page/3/mtrace\">mtrace(3)</a>,\n<a href=\"https://man.page/3/posix_memalign\">posix_memalign(3)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For details of\nthe GNU C library implementation, see\n<a href=\"https://sourceware.org/glibc/wiki/MallocInternals\">https://sourceware.org/glibc/wiki/MallocInternals</a>.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}