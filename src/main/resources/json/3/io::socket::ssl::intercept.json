{"name":"io::socket::ssl::intercept","description":"IO::Socket::SSL::Intercept -- SSL interception (man in the middle)","body":"\n\n<h1 align=\"center\">IO::Socket::SSL::Intercept</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL::Intercept\n-- SSL interception (man in the middle)</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIO::Socket::SSL::Intercept; <br>\n# create interceptor with proxy certificates <br>\nmy $mitm = IO::Socket::SSL::Intercept-&gt;new( <br>\nproxy_cert_file =&gt; 'proxy_cert.pem', <br>\nproxy_key_file =&gt; 'proxy_key.pem', <br>\n... <br>\n); <br>\nmy $listen = IO::Socket::INET-&gt;new( LocalAddr =&gt; ..,\nListen =&gt; .. ); <br>\nwhile (1) { <br>\n# TCP accept new client <br>\nmy $client = $listen-&gt;accept or next; <br>\n# SSL connect to server <br>\nmy $server = IO::Socket::SSL-&gt;new( <br>\nPeerAddr =&gt; .., <br>\nSSL_verify_mode =&gt; ..., <br>\n... <br>\n) or die &quot;ssl connect failed: $!,$SSL_ERROR&quot;; <br>\n# clone server certificate <br>\nmy ($cert,$key) = $mitm-&gt;clone_cert(\n$server-&gt;peer_certificate ); <br>\n# and upgrade client side to SSL with cloned certificate\n<br>\nIO::Socket::SSL-&gt;start_SSL($client, <br>\nSSL_server =&gt; 1, <br>\nSSL_cert =&gt; $cert, <br>\nSSL_key =&gt; $key <br>\n) or die &quot;upgrade failed: $SSL_ERROR&quot;; <br>\n# now transfer data between $client and $server and analyze\n<br>\n# the unencrypted data <br>\n... <br>\n}</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\nprovides functionality to clone certificates and sign them\nwith a proxy certificate, thus making it easy to intercept\n<small>SSL</small> connections (man in the middle). It also\nmanages a cache of the generated certificates.</p>\n\n<h2>How Intercepting SSL Works\n<a name=\"How Intercepting SSL Works\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Intercepting\n<small>SSL</small> connections is useful for analyzing\nencrypted traffic for security reasons or for testing. It\ndoes not break the end-to-end security of\n<small>SSL,</small> e.g. a properly written client will\nnotice the interception unless you explicitly configure the\nclient to trust your interceptor. Intercepting\n<small>SSL</small> works the following way:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Create a new <small>CA</small> certificate, which will\nbe used to sign the cloned certificates. This proxy\n<small>CA</small> certificate should be trusted by the\nclient, or (a properly written client) will throw error\nmessages or deny the connections because it detected a man\nin the middle attack. Due to the way the interception works\nthere no support for client side certificates is\npossible.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Using openssl\nsuch a proxy <small>CA</small> certificate and private key\ncan be created with:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">openssl genrsa\n-out proxy_key.pem 1024 <br>\nopenssl req -new -x509 -extensions v3_ca -key proxy_key.pem\n-out proxy_cert.pem <br>\n# export as PKCS12 for import into browser <br>\nopenssl pkcs12 -export -in proxy_cert.pem -inkey\nproxy_key.pem -out proxy_cert.p12</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">Configure client to connect to\nuse intercepting proxy or somehow redirect connections from\nclient to the proxy (e.g. packet filter redirects,\n<small>ARP</small> or <small>DNS</small> spoofing etc).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Accept the <small>TCP</small> connection from the\nclient, e.g. don&rsquo;t do any <small>SSL</small>\nhandshakes with the client yet.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Establish the <small>SSL</small> connection to the\nserver and verify the servers certificate as usually. Then\ncreate a new certificate based on the original servers\ncertificate, but signed by your proxy <small>CA.</small>\nThis is the step where IO::Socket::SSL::Intercept helps.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Upgrade the <small>TCP</small> connection to the client\nto <small>SSL</small> using the cloned certificate from the\nserver. If the client trusts your proxy <small>CA</small> it\nwill accept the upgrade to <small>SSL.</small></p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Transfer data between client and server. While the\nconnections to client and server are both encrypted with\n<small>SSL</small> you will read/write the unencrypted data\nin your proxy application.</p></td></tr>\n</table>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Socket::SSL::Intercept\nhelps creating the cloned certificate with the following\nmethods: <b><br>\n$mitm = IO::Socket::SSL::Intercept-&gt;new(%args)</b></p>\n\n<p style=\"margin-left:17%;\">This creates a new interceptor\nobject. %args should be <br>\nproxy_cert X509 | proxy_cert_file filename</p>\n\n<p style=\"margin-left:29%;\">This is the proxy certificate.\nIt can be either given by an X509 object from Net::SSLeays\ninternal representation, or using a file in\n<small>PEM</small> format.</p>\n\n<p style=\"margin-left:17%;\">proxy_key\n<small>EVP_PKEY</small> | proxy_key_file filename</p>\n\n<p style=\"margin-left:29%;\">This is the key for the proxy\ncertificate. It can be either given by an\n<small>EVP_PKEY</small> object from Net::SSLeays internal\nrepresentation, or using a file in <small>PEM</small>\nformat. The key should not have a passphrase.</p>\n\n<p style=\"margin-left:17%;\">pubkey <small>EVP_PKEY</small>\n| pubkey_file filename</p>\n\n<p style=\"margin-left:29%;\">This optional argument\nspecifies the public key used for the cloned certificate. It\ncan be either given by an <small>EVP_PKEY</small> object\nfrom Net::SSLeays internal representation, or using a file\nin <small>PEM</small> format. If not given it will create a\nnew public key on each call of &quot;new&quot;.</p>\n\n<p style=\"margin-left:17%;\">serial INTEGER|CODE</p>\n\n<p style=\"margin-left:29%;\">This optional argument gives\nthe starting point for the serial numbers of the newly\ncreated certificates. If not set the serial number will be\ncreated based on the digest of the original certificate. If\nthe value is code it will be called with\n&quot;serial(original_cert,CERT_asHash(original_cert))&quot;\nand should return the new serial number.</p>\n\n<p style=\"margin-left:17%;\">cache <small>HASH</small> |\n<small>SUBROUTINE</small></p>\n\n<p style=\"margin-left:29%;\">This optional argument gives a\nway to cache created certificates, so that they don&rsquo;t\nget recreated on future accesses to the same host. If the\nargument ist not given an internal <small>HASH</small> ist\nused.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">If the argument\nis a hash it will store for each generated certificate a\nhash reference with &quot;cert&quot; and &quot;atime&quot;\nin the hash, where &quot;atime&quot; is the time of last\naccess (to expire unused entries) and &quot;cert&quot; is\nthe certificate. Please note, that the certificate is in\nNet::SSLeays internal X509 format and can thus not be simply\ndumped and restored. The key for the hash is an\n&quot;ident&quot; either given to &quot;clone_cert&quot; or\ngenerated from the original certificate.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">If the argument\nis a subroutine it will be called as\n&quot;$cache-&gt;(ident,sub)&quot;. This call should return\neither an existing (cached) &quot;(cert,key)&quot; or call\n&quot;sub&quot; without arguments to create a new\n&quot;(cert,key)&quot;, store it and return it. If called\nwith &quot;$cache-&gt;('type')&quot; the function should\njust return 1 to signal that it supports the current type of\ncache. If it reutrns nothing instead the older cache\ninterface is assumed for compatibility reasons.</p>\n\n<p style=\"margin-left:11%;\"><b>($clone_cert,$key) =\n$mitm-&gt;clone_cert($original_cert,[ $ident ])</b></p>\n\n<p style=\"margin-left:17%;\">This clones the given\ncertificate. An ident as the key into the cache can be given\n(like &quot;host:port&quot;), if not it will be created from\nthe properties of the original certificate. It returns the\ncloned certificate and its key (which is the same for alle\ncreated certificates).</p>\n\n<p style=\"margin-left:11%;\"><b>$string =\n$mitm-&gt;serialize</b></p>\n\n<p style=\"margin-left:17%;\">This creates a serialized\nversion of the object (e.g. a string) which can then be used\nto persistantly store created certificates over restarts of\nthe application. The cache will only be serialized if it is\na <small>HASH.</small> To work together with Storable the\n&quot;STORABLE_freeze&quot; function is defined to call\n&quot;serialize&quot;.</p>\n\n<p style=\"margin-left:11%;\"><b>$mitm =\nIO::Socket::SSL::Intercept-&gt;unserialize($string)</b></p>\n\n<p style=\"margin-left:17%;\">This restores an Intercept\nobject from a serialized string. To work together with\nStorable the &quot;STORABLE_thaw&quot; function is defined\nto call &quot;unserialize&quot;.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Steffen\nUllrich</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#How Intercepting SSL Works\">How Intercepting SSL Works</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#AUTHOR\">AUTHOR</a>"],"level":3}