{"name":"algorithm::diff","description":"Algorithm::Diff\n- Compute &rsquo;intelligent&rsquo; differences between two\nfiles / lists","body":"\n\n<h1 align=\"center\">Algorithm::Diff</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Algorithm::Diff\n- Compute &rsquo;intelligent&rsquo; differences between two\nfiles / lists</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">require\nAlgorithm::Diff; <br>\n# This example produces traditional 'diff' output: <br>\nmy $diff = Algorithm::Diff-&gt;new( \\@seq1, \\@seq2 ); <br>\n$diff-&gt;Base( 1 ); # Return line numbers, not indices <br>\nwhile( $diff-&gt;Next() ) { <br>\nnext if $diff-&gt;Same(); <br>\nmy $sep = ''; <br>\nif( ! $diff-&gt;Items(2) ) { <br>\nprintf &quot;%d,%dd%d\\n&quot;, <br>\n$diff-&gt;Get(qw( Min1 Max1 Max2 )); <br>\n} elsif( ! $diff-&gt;Items(1) ) { <br>\nprintf &quot;%da%d,%d\\n&quot;, <br>\n$diff-&gt;Get(qw( Max1 Min2 Max2 )); <br>\n} else { <br>\n$sep = &quot;---\\n&quot;; <br>\nprintf &quot;%d,%dc%d,%d\\n&quot;, <br>\n$diff-&gt;Get(qw( Min1 Max1 Min2 Max2 )); <br>\n} <br>\nprint &quot;&lt; $_&quot; for $diff-&gt;Items(1); <br>\nprint $sep; <br>\nprint &quot;&gt; $_&quot; for $diff-&gt;Items(2); <br>\n} <br>\n# Alternate interfaces: <br>\nuse Algorithm::Diff qw( <br>\nLCS LCS_length LCSidx <br>\ndiff sdiff compact_diff <br>\ntraverse_sequences traverse_balanced ); <br>\n@lcs = LCS( \\@seq1, \\@seq2 ); <br>\n$lcsref = LCS( \\@seq1, \\@seq2 ); <br>\n$count = LCS_length( \\@seq1, \\@seq2 ); <br>\n( $seq1idxref, $seq2idxref ) = LCSidx( \\@seq1, \\@seq2 );\n<br>\n# Complicated interfaces: <br>\n@diffs = diff( \\@seq1, \\@seq2 ); <br>\n@sdiffs = sdiff( \\@seq1, \\@seq2 ); <br>\n@cdiffs = compact_diff( \\@seq1, \\@seq2 ); <br>\ntraverse_sequences( <br>\n\\@seq1, <br>\n\\@seq2, <br>\n{ MATCH =&gt; \\&amp;callback1, <br>\nDISCARD_A =&gt; \\&amp;callback2, <br>\nDISCARD_B =&gt; \\&amp;callback3, <br>\n}, <br>\n\\&amp;key_generator, <br>\n@extra_args, <br>\n); <br>\ntraverse_balanced( <br>\n\\@seq1, <br>\n\\@seq2, <br>\n{ MATCH =&gt; \\&amp;callback1, <br>\nDISCARD_A =&gt; \\&amp;callback2, <br>\nDISCARD_B =&gt; \\&amp;callback3, <br>\nCHANGE =&gt; \\&amp;callback4, <br>\n}, <br>\n\\&amp;key_generator, <br>\n@extra_args, <br>\n);</p>\n\n<h2>INTRODUCTION\n<a name=\"INTRODUCTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(by Mark-Jason\nDominus)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">I once read an\narticle written by the authors of &quot;diff&quot;; they\nsaid that they worked very hard on the algorithm until they\nfound the right one.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">I think what\nthey ended up using (and I hope someone will correct me,\nbecause I am not very confident about this) was the\n&rsquo;longest common subsequence&rsquo; method. In the\n<small>LCS</small> problem, you have two sequences of\nitems:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a b c d f g h j\nq z <br>\na b c d e f g i j k r x y z</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and you want to\nfind the longest sequence of items that is present in both\noriginal sequences in the same order. That is, you want to\nfind a new sequence <i>S</i> which can be obtained from the\nfirst sequence by deleting some items, and from the second\nsequence by deleting other items. You also want <i>S</i> to\nbe as long as possible. In this case <i>S</i> is</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a b c d f g j\nz</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From there\nit&rsquo;s only a small step to get diff-like output:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">e h i k q r x y\n<br>\n+ - + + - + + +</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\nsolves the <small>LCS</small> problem. It also includes a\ncanned function to generate &quot;diff&quot;-like\noutput.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It might seem\nfrom the example above that the <small>LCS</small> of two\nsequences is always pretty obvious, but that&rsquo;s not\nalways the case, especially when the two sequences have many\nrepeated elements. For example, consider</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a x b y c z p d\nq <br>\na b c a x b y c z</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A naive\napproach might start by matching up the &quot;a&quot; and\n&quot;b&quot; that appear at the beginning of each sequence,\nlike this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a x b y c z p d\nq <br>\na b c a b y c z</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This finds the\ncommon subsequence &quot;a b c z&quot;. But actually, the\n<small>LCS</small> is &quot;a x b y c z&quot;:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a x b y c z p d\nq <br>\na b c a x b y c z</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a x b y c z p d\nq <br>\na b c a x b y c z</p>\n\n<h2>USAGE\n<a name=\"USAGE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(See also the\n<small>README</small> file and several example scripts\ninclude with this module.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module now\nprovides an object-oriented interface that uses less memory\nand is easier to use than most of the previous procedural\ninterfaces. It also still provides several exportable\nfunctions. We&rsquo;ll deal with these in ascending order of\ndifficulty: &quot;LCS&quot;, &quot;LCS_length&quot;,\n&quot;LCSidx&quot;, <small>OO</small> interface,\n&quot;prepare&quot;, &quot;diff&quot;, &quot;sdiff&quot;,\n&quot;traverse_sequences&quot;, and\n&quot;traverse_balanced&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;LCS&quot;</b>\n<br>\nGiven references to two lists of items, <small>LCS</small>\nreturns an array containing their longest common\nsubsequence. In scalar context, it returns a reference to\nsuch a list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@lcs = LCS(\n\\@seq1, \\@seq2 ); <br>\n$lcsref = LCS( \\@seq1, \\@seq2 );</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;LCS&quot;\nmay be passed an optional third parameter; this is a\n<small>CODE</small> reference to a key generation function.\nSee &quot; <small>KEY GENERATION FUNCTIONS&quot;</small>\n.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@lcs = LCS(\n\\@seq1, \\@seq2, \\&amp;keyGen, @args ); <br>\n$lcsref = LCS( \\@seq1, \\@seq2, \\&amp;keyGen, @args );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\nparameters, if any, will be passed to the key generation\nroutine.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;LCS_length&quot;</b>\n<br>\nThis is just like &quot;LCS&quot; except it only returns the\nlength of the longest common subsequence. This provides a\nperformance gain of about 9% compared to\n&quot;LCS&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;LCSidx&quot;</b>\n<br>\nLike &quot;LCS&quot; except it returns references to two\narrays. The first array contains the indices into @seq1\nwhere the <small>LCS</small> items are located. The second\narray contains the indices into @seq2 where the\n<small>LCS</small> items are located.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Therefore, the\nfollowing three lists will contain the same values:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my( $idx1,\n$idx2 ) = LCSidx( \\@seq1, \\@seq2 ); <br>\nmy @list1 = @seq1[ @$idx1 ]; <br>\nmy @list2 = @seq2[ @$idx2 ]; <br>\nmy @list3 = LCS( \\@seq1, \\@seq2 );</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;new&quot;</b>\n<br>\n$diff = Algorithm::Diff-&gt;new( \\@seq1, \\@seq2 ); <br>\n$diff = Algorithm::Diff-&gt;new( \\@seq1, \\@seq2, \\%opts\n);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;new&quot;\ncomputes the smallest set of additions and deletions\nnecessary to turn the first sequence into the second and\ncompactly records them in the object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You use the\nobject to iterate over <i>hunks</i>, where each hunk\nrepresents a contiguous section of items which should be\nadded, deleted, replaced, or left unchanged.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsummary of all of the methods looks a lot like Perl code but\nsome of the symbols have different meanings:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[ ] Encloses\noptional arguments <br>\n: Is followed by the default value for an optional argument\n<br>\n| Separates alternate return results</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Method\nsummary:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$obj =\nAlgorithm::Diff-&gt;new( \\@seq1, \\@seq2, [ \\%opts ] ); <br>\n$pos = $obj-&gt;Next( [ $count : 1 ] ); <br>\n$revPos = $obj-&gt;Prev( [ $count : 1 ] ); <br>\n$obj = $obj-&gt;Reset( [ $pos : 0 ] ); <br>\n$copy = $obj-&gt;Copy( [ $pos, [ $newBase ] ] ); <br>\n$oldBase = $obj-&gt;Base( [ $newBase ] );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that all\nof the following methods &quot;die&quot; if used on an\nobject that is &quot;reset&quot; (not currently pointing at\nany hunk).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$bits =\n$obj-&gt;Diff( ); <br>\n@items|$cnt = $obj-&gt;Same( ); <br>\n@items|$cnt = $obj-&gt;Items( $seqNum ); <br>\n@idxs |$cnt = $obj-&gt;Range( $seqNum, [ $base ] ); <br>\n$minIdx = $obj-&gt;Min( $seqNum, [ $base ] ); <br>\n$maxIdx = $obj-&gt;Max( $seqNum, [ $base ] ); <br>\n@values = $obj-&gt;Get( @names );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Passing in\n&quot;undef&quot; for an optional argument is always treated\nthe same as if no argument were passed in. <br>\n&quot;Next&quot;</p>\n\n<p style=\"margin-left:17%;\">$pos = $diff-&gt;Next(); # Move\nforward 1 hunk <br>\n$pos = $diff-&gt;Next( 2 ); # Move forward 2 hunks <br>\n$pos = $diff-&gt;Next(-5); # Move backward 5 hunks</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Next&quot;\nmoves the object to point at the next hunk. The object\nstarts out &quot;reset&quot;, which means it isn&rsquo;t\npointing at any hunk. If the object is reset, then\n&quot;Next()&quot; moves to the first hunk.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Next&quot;\nreturns a true value iff the move didn&rsquo;t go past the\nlast hunk. So Next(0) will return true iff the object is not\nreset.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Actually,\n&quot;Next&quot; returns the object&rsquo;s new position,\nwhich is a number between 1 and the number of hunks\n(inclusive), or returns a false value.</p>\n\n<p style=\"margin-left:11%;\">&quot;Prev&quot;</p>\n\n<p style=\"margin-left:17%;\">&quot;Prev($N)&quot; is almost\nidentical to &quot;Next(-$N)&quot;; it moves to the $Nth\nprevious hunk. On a &rsquo;reset&rsquo; object,\n&quot;Prev()&quot; [and &quot;Next(-1)&quot;] move to the\nlast hunk.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The position\nreturned by &quot;Prev&quot; is relative to the <i>end</i>\nof the hunks; -1 for the last hunk, -2 for the\nsecond-to-last, etc.</p>\n\n<p style=\"margin-left:11%;\">&quot;Reset&quot;</p>\n\n<p style=\"margin-left:17%;\">$diff-&gt;Reset(); # Reset the\nobject's position <br>\n$diff-&gt;Reset($pos); # Move to the specified hunk <br>\n$diff-&gt;Reset(1); # Move to the first hunk <br>\n$diff-&gt;Reset(-1); # Move to the last hunk</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Reset&quot;\nreturns the object, so, for example, you could use\n&quot;$diff-&gt;Reset()-&gt;Next(-1)&quot; to get the number\nof hunks.</p>\n\n<p style=\"margin-left:11%;\">&quot;Copy&quot;</p>\n\n<p style=\"margin-left:17%;\">$copy = $diff-&gt;Copy(\n$newPos, $newBase );</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Copy&quot;\nreturns a copy of the object. The copy and the original\nobject share most of their data, so making copies takes very\nlittle memory. The copy maintains its own position (separate\nfrom the original), which is the main purpose of copies. It\nalso maintains its own base.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">By default, the\ncopy&rsquo;s position starts out the same as the original\nobject&rsquo;s position. But &quot;Copy&quot; takes an\noptional first argument to set the new position, so the\nfollowing three snippets are equivalent:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$copy =\n$diff-&gt;Copy($pos); <br>\n$copy = $diff-&gt;Copy(); <br>\n$copy-&gt;Reset($pos); <br>\n$copy = $diff-&gt;Copy()-&gt;Reset($pos);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Copy&quot;\ntakes an optional second argument to set the base for the\ncopy. If you wish to change the base of the copy but leave\nthe position the same as in the original, here are two\nequivalent ways:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$copy =\n$diff-&gt;Copy(); <br>\n$copy-&gt;Base( 0 ); <br>\n$copy = $diff-&gt;Copy(undef,0);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Here are two\nequivalent way to get a &quot;reset&quot; copy:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$copy =\n$diff-&gt;Copy(0); <br>\n$copy = $diff-&gt;Copy()-&gt;Reset();</p>\n\n<p style=\"margin-left:11%;\">&quot;Diff&quot;</p>\n\n<p style=\"margin-left:17%;\">$bits = $obj-&gt;Diff();</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Diff&quot;\nreturns a true value iff the current hunk contains items\nthat are different between the two sequences. It actually\nreturns one of the follow 4 values:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>3</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>&quot;3==(1|2)&quot;. This hunk contains items from\n@seq1 and the items from @seq2 that should replace them.\nBoth sequence 1 and 2 contain changed items so both the 1\nand 2 bits are set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>2</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>This hunk only contains items from @seq2 that should be\ninserted (not items from @seq1). Only sequence 2 contains\nchanged items so only the 2 bit is set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>1</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>This hunk only contains items from @seq1 that should be\ndeleted (not items from @seq2). Only sequence 1 contains\nchanged items so only the 1 bit is set.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>0</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>This means that the items in this hunk are the same in\nboth sequences. Neither sequence 1 nor 2 contain changed\nitems so neither the 1 nor the 2 bits are set.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">&quot;Same&quot;</p>\n\n<p style=\"margin-left:17%;\">&quot;Same&quot; returns a true\nvalue iff the current hunk contains items that are the same\nin both sequences. It actually returns the list of items if\nthey are the same or an empty list if they aren&rsquo;t. In\na scalar context, it returns the size of the list.</p>\n\n<p style=\"margin-left:11%;\">&quot;Items&quot;</p>\n\n<p style=\"margin-left:17%;\">$count = $diff-&gt;Items(2);\n<br>\n@items = $diff-&gt;Items($seqNum);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Items&quot;\nreturns the (number of) items from the specified sequence\nthat are part of the current hunk.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the current\nhunk contains only insertions, then\n&quot;$diff-&gt;Items(1)&quot; will return an empty list (0\nin a scalar context). If the current hunk contains only\ndeletions, then &quot;$diff-&gt;Items(2)&quot; will return\nan empty list (0 in a scalar context).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the hunk\ncontains replacements, then both\n&quot;$diff-&gt;Items(1)&quot; and\n&quot;$diff-&gt;Items(2)&quot; will return different,\nnon-empty lists.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Otherwise, the\nhunk contains identical items and all of the following will\nreturn the same lists:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">@items =\n$diff-&gt;Items(1); <br>\n@items = $diff-&gt;Items(2); <br>\n@items = $diff-&gt;Same();</p>\n\n<p style=\"margin-left:11%;\">&quot;Range&quot;</p>\n\n<p style=\"margin-left:17%;\">$count = $diff-&gt;Range(\n$seqNum ); <br>\n@indices = $diff-&gt;Range( $seqNum ); <br>\n@indices = $diff-&gt;Range( $seqNum, $base );</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Range&quot;\nis like &quot;Items&quot; except that it returns a list of\n<i>indices</i> to the items rather than the items\nthemselves. By default, the index of the first item (in each\nsequence) is 0 but this can be changed by calling the\n&quot;Base&quot; method. So, by default, the following two\nsnippets return the same lists:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">@list =\n$diff-&gt;Items(2); <br>\n@list = @seq2[ $diff-&gt;Range(2) ];</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can also\nspecify the base to use as the second argument. So the\nfollowing two snippets <i>always</i> return the same\nlists:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">@list =\n$diff-&gt;Items(1); <br>\n@list = @seq1[ $diff-&gt;Range(1,0) ];</p>\n\n<p style=\"margin-left:11%;\">&quot;Base&quot;</p>\n\n<p style=\"margin-left:17%;\">$curBase = $diff-&gt;Base();\n<br>\n$oldBase = $diff-&gt;Base($newBase);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Base&quot;\nsets and/or returns the current base (usually 0 or 1) that\nis used when you request range information. The base\ndefaults to 0 so that range information is returned as array\nindices. You can set the base to 1 if you want to report\ntraditional line numbers instead.</p>\n\n<p style=\"margin-left:11%;\">&quot;Min&quot;</p>\n\n<p style=\"margin-left:17%;\">$min1 = $diff-&gt;Min(1); <br>\n$min = $diff-&gt;Min( $seqNum, $base );</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Min&quot;\nreturns the first value that &quot;Range&quot; would return\n(given the same arguments) or returns &quot;undef&quot; if\n&quot;Range&quot; would return an empty list.</p>\n\n<p style=\"margin-left:11%;\">&quot;Max&quot;</p>\n\n<p style=\"margin-left:17%;\">&quot;Max&quot; returns the\nlast value that &quot;Range&quot; would return or\n&quot;undef&quot;.</p>\n\n<p style=\"margin-left:11%;\">&quot;Get&quot;</p>\n\n<p style=\"margin-left:17%;\">( $n, $x, $r ) =\n$diff-&gt;Get(qw( min1 max1 range1 )); <br>\n@values = $diff-&gt;Get(qw( 0min2 1max2 range2 same base\n));</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;Get&quot;\nreturns one or more scalar values. You pass in a list of the\nnames of the values you want returned. Each name must match\none of the following regexes:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">/^(-?\\d+)?(min|max)[12]$/i\n<br>\n/^(range[12]|same|diff|base)$/i</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The 1 or 2\nafter a name says which sequence you want the information\nfor (and where allowed, it is required). The optional number\nbefore &quot;min&quot; or &quot;max&quot; is the base to\nuse. So the following equalities hold:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$diff-&gt;Get('min1')\n== $diff-&gt;Min(1) <br>\n$diff-&gt;Get('0min2') == $diff-&gt;Min(2,0)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Using\n&quot;Get&quot; in a scalar context when you&rsquo;ve passed\nin more than one name is a fatal error (&quot;die&quot; is\ncalled).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;prepare&quot;</b>\n<br>\nGiven a reference to a list of items, &quot;prepare&quot;\nreturns a reference to a hash which can be used when\ncomparing this sequence to other sequences with\n&quot;LCS&quot; or &quot;LCS_length&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$prep =\nprepare( \\@seq1 ); <br>\nfor $i ( 0 .. 10_000 ) <br>\n{ <br>\n@lcs = LCS( $prep, $seq[$i] ); <br>\n# do something useful with @lcs <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;prepare&quot;\nmay be passed an optional third parameter; this is a\n<small>CODE</small> reference to a key generation function.\nSee &quot; <small>KEY GENERATION FUNCTIONS&quot;</small>\n.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$prep =\nprepare( \\@seq1, \\&amp;keyGen ); <br>\nfor $i ( 0 .. 10_000 ) <br>\n{ <br>\n@lcs = LCS( $seq[$i], $prep, \\&amp;keyGen ); <br>\n# do something useful with @lcs <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using\n&quot;prepare&quot; provides a performance gain of about 50%\nwhen calling <small>LCS</small> many times compared with not\npreparing.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;diff&quot;</b>\n<br>\n@diffs = diff( \\@seq1, \\@seq2 ); <br>\n$diffs_ref = diff( \\@seq1, \\@seq2 );</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;diff&quot;\ncomputes the smallest set of additions and deletions\nnecessary to turn the first sequence into the second, and\nreturns a description of these changes. The description is a\nlist of <i>hunks</i>; each hunk represents a contiguous\nsection of items which should be added, deleted, or\nreplaced. (Hunks containing unchanged items are not\nincluded.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The return\nvalue of &quot;diff&quot; is a list of hunks, or, in scalar\ncontext, a reference to such a list. If there are no\ndifferences, the list will be empty.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is an\nexample. Calling &quot;diff&quot; for the following two\nsequences:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a b c e h j l m\nn p <br>\nb c d e f j k l m r s t</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">would produce\nthe following list:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">( <br>\n[ [ '-', 0, 'a' ] ], <br>\n[ [ '+', 2, 'd' ] ], <br>\n[ [ '-', 4, 'h' ], <br>\n[ '+', 4, 'f' ] ], <br>\n[ [ '+', 6, 'k' ] ], <br>\n[ [ '-', 8, 'n' ], <br>\n[ '-', 9, 'p' ], <br>\n[ '+', 9, 'r' ], <br>\n[ '+', 10, 's' ], <br>\n[ '+', 11, 't' ] ], <br>\n)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are five\nhunks here. The first hunk says that the &quot;a&quot; at\nposition 0 of the first sequence should be deleted\n(&quot;-&quot;). The second hunk says that the &quot;d&quot;\nat position 2 of the second sequence should be inserted\n(&quot;+&quot;). The third hunk says that the &quot;h&quot;\nat position 4 of the first sequence should be removed and\nreplaced with the &quot;f&quot; from position 4 of the\nsecond sequence. And so on.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;diff&quot;\nmay be passed an optional third parameter; this is a\n<small>CODE</small> reference to a key generation function.\nSee &quot; <small>KEY GENERATION FUNCTIONS&quot;</small>\n.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\nparameters, if any, will be passed to the key generation\nroutine.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;sdiff&quot;</b>\n<br>\n@sdiffs = sdiff( \\@seq1, \\@seq2 ); <br>\n$sdiffs_ref = sdiff( \\@seq1, \\@seq2 );</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;sdiff&quot;\ncomputes all necessary components to show two sequences and\ntheir minimized differences side by side, just like the\nUnix-utility <i>sdiff</i> does:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">same same <br>\nbefore | after <br>\nold &lt; - <br>\n- &gt; new</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It returns a\nlist of array refs, each pointing to an array of display\ninstructions. In scalar context it returns a reference to\nsuch a list. If there are no differences, the list will have\none entry per item, each indicating that the item was\nunchanged.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Display\ninstructions consist of three elements: A modifier indicator\n(&quot;+&quot;: Element added, &quot;-&quot;: Element\nremoved, &quot;u&quot;: Element unmodified, &quot;c&quot;:\nElement changed) and the value of the old and new elements,\nto be displayed side-by-side.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An\n&quot;sdiff&quot; of the following two sequences:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a b c e h j l m\nn p <br>\nb c d e f j k l m r s t</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">results in</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">( [ '-', 'a',\n'' ], <br>\n[ 'u', 'b', 'b' ], <br>\n[ 'u', 'c', 'c' ], <br>\n[ '+', '', 'd' ], <br>\n[ 'u', 'e', 'e' ], <br>\n[ 'c', 'h', 'f' ], <br>\n[ 'u', 'j', 'j' ], <br>\n[ '+', '', 'k' ], <br>\n[ 'u', 'l', 'l' ], <br>\n[ 'u', 'm', 'm' ], <br>\n[ 'c', 'n', 'r' ], <br>\n[ 'c', 'p', 's' ], <br>\n[ '+', '', 't' ], <br>\n)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;sdiff&quot;\nmay be passed an optional third parameter; this is a\n<small>CODE</small> reference to a key generation function.\nSee &quot; <small>KEY GENERATION FUNCTIONS&quot;</small>\n.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\nparameters, if any, will be passed to the key generation\nroutine.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;compact_diff&quot;</b>\n<br>\n&quot;compact_diff&quot; is much like &quot;sdiff&quot;\nexcept it returns a much more compact description consisting\nof just one flat list of indices. An example helps explain\nthe format:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my @a = qw( a b\nc e h j l m n p ); <br>\nmy @b = qw( b c d e f j k l m r s t ); <br>\n@cdiff = compact_diff( \\@a, \\@b ); <br>\n# Returns: <br>\n# @a @b @a @b <br>\n# start start values values <br>\n( 0, 0, # = <br>\n0, 0, # a ! <br>\n1, 0, # b c = b c <br>\n3, 2, # ! d <br>\n3, 3, # e = e <br>\n4, 4, # f ! h <br>\n5, 5, # j = j <br>\n6, 6, # ! k <br>\n6, 7, # l m = l m <br>\n8, 9, # n p ! r s t <br>\n10, 12, # <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The 0th, 2nd,\n4th, etc. entries are all indices into @seq1 (@a in the\nabove example) indicating where a hunk begins. The 1st, 3rd,\n5th, etc. entries are all indices into @seq2 (@b in the\nabove example) indicating where the same hunk begins.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So each pair of\nindices (except the last pair) describes where a hunk begins\n(in each sequence). Since each hunk must end at the item\njust before the item that starts the next hunk, the next\npair of indices can be used to determine where the hunk\nends.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, the first 4\nentries (0..3) describe the first hunk. Entries 0 and 1\ndescribe where the first hunk begins (and so are always both\n0). Entries 2 and 3 describe where the next hunk begins, so\nsubtracting 1 from each tells us where the first hunk ends.\nThat is, the first hunk contains items $diff[0] through\n&quot;$diff[2] - 1&quot; of the first sequence and contains\nitems $diff[1] through &quot;$diff[3] - 1&quot; of the\nsecond sequence.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In other words,\nthe first hunk consists of the following two lists of\nitems:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># 1st pair 2nd\npair <br>\n# of indices of indices <br>\n@list1 = @a[ $cdiff[0] .. $cdiff[2]-1 ]; <br>\n@list2 = @b[ $cdiff[1] .. $cdiff[3]-1 ]; <br>\n# Hunk start Hunk end</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nhunks will always alternate between those that are part of\nthe <small>LCS</small> (those that contain unchanged items)\nand those that contain changes. This means that all we need\nto be told is whether the first hunk is a &rsquo;same&rsquo;\nor &rsquo;diff&rsquo; hunk and we can determine which of the\nother hunks contain &rsquo;same&rsquo; items or\n&rsquo;diff&rsquo; items.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By convention,\nwe always make the first hunk contain unchanged items. So\nthe 1st, 3rd, 5th, etc. hunks (all odd-numbered hunks if you\nstart counting from 1) all contain unchanged items. And the\n2nd, 4th, 6th, etc. hunks (all even-numbered hunks if you\nstart counting from 1) all contain changed items.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since @a and @b\ndon&rsquo;t begin with the same value, the first hunk in our\nexample is empty (otherwise we&rsquo;d violate the above\nconvention). Note that the first 4 index values in our\nexample are all zero. Plug these values into our previous\ncode block and we get:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@hunk1a = @a[ 0\n.. 0-1 ]; <br>\n@hunk1b = @b[ 0 .. 0-1 ];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And\n&quot;0..-1&quot; returns the empty list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Move down one\npair of indices (2..5) and we get the offset ranges for the\nsecond hunk, which contains changed items.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since\n@diff[2..5] contains (0,0,1,0) in our example, the second\nhunk consists of these two lists of items:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@hunk2a = @a[\n$cdiff[2] .. $cdiff[4]-1 ]; <br>\n@hunk2b = @b[ $cdiff[3] .. $cdiff[5]-1 ]; <br>\n# or <br>\n@hunk2a = @a[ 0 .. 1-1 ]; <br>\n@hunk2b = @b[ 0 .. 0-1 ]; <br>\n# or <br>\n@hunk2a = @a[ 0 .. 0 ]; <br>\n@hunk2b = @b[ 0 .. -1 ]; <br>\n# or <br>\n@hunk2a = ( 'a' ); <br>\n@hunk2b = ( );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That is, we\nwould delete item 0 (&rsquo;a&rsquo;) from @a.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since\n@diff[4..7] contains (1,0,3,2) in our example, the third\nhunk consists of these two lists of items:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@hunk3a = @a[\n$cdiff[4] .. $cdiff[6]-1 ]; <br>\n@hunk3a = @b[ $cdiff[5] .. $cdiff[7]-1 ]; <br>\n# or <br>\n@hunk3a = @a[ 1 .. 3-1 ]; <br>\n@hunk3a = @b[ 0 .. 2-1 ]; <br>\n# or <br>\n@hunk3a = @a[ 1 .. 2 ]; <br>\n@hunk3a = @b[ 0 .. 1 ]; <br>\n# or <br>\n@hunk3a = qw( b c ); <br>\n@hunk3a = qw( b c );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that this\nthird hunk contains unchanged items as our convention\ndemands.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can\ncontinue this process until you reach the last two indices,\nwhich will always be the number of items in each sequence.\nThis is required so that subtracting one from each will give\nyou the indices to the last items in each sequence.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;traverse_sequences&quot;</b>\n<br>\n&quot;traverse_sequences&quot; used to be the most general\nfacility provided by this module (the new <small>OO</small>\ninterface is more powerful and much easier to use).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Imagine that\nthere are two arrows. Arrow A points to an element of\nsequence A, and arrow B points to an element of the sequence\nB. Initially, the arrows point to the first elements of the\nrespective sequences. &quot;traverse_sequences&quot; will\nadvance the arrows through the sequences one element at a\ntime, calling an appropriate user-specified callback\nfunction before each advance. It will advance the arrows in\nsuch a way that if there are equal elements $A[$i] and\n$B[$j] which are equal and which are part of the\n<small>LCS,</small> there will be some moment during the\nexecution of &quot;traverse_sequences&quot; when arrow A is\npointing to $A[$i] and arrow B is pointing to $B[$j]. When\nthis happens, &quot;traverse_sequences&quot; will call the\n&quot;MATCH&quot; callback function and then it will advance\nboth arrows.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Otherwise, one\nof the arrows is pointing to an element of its sequence that\nis not part of the <small>LCS.</small>\n&quot;traverse_sequences&quot; will advance that arrow and\nwill call the &quot;DISCARD_A&quot; or the\n&quot;DISCARD_B&quot; callback, depending on which arrow it\nadvanced. If both arrows point to elements that are not part\nof the <small>LCS,</small> then\n&quot;traverse_sequences&quot; will advance one of them and\ncall the appropriate callback, but it is not specified which\nit will call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The arguments\nto &quot;traverse_sequences&quot; are the two sequences to\ntraverse, and a hash which specifies the callback functions,\nlike this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">traverse_sequences(\n<br>\n\\@seq1, \\@seq2, <br>\n{ MATCH =&gt; $callback_1, <br>\nDISCARD_A =&gt; $callback_2, <br>\nDISCARD_B =&gt; $callback_3, <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Callbacks for\n<small>MATCH, DISCARD_A,</small> and\n<small>DISCARD_B</small> are invoked with at least the\nindices of the two arrows as their arguments. They are not\nexpected to return any values. If a callback is omitted from\nthe table, it is not called.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Callbacks for\nA_FINISHED and B_FINISHED are invoked with at least the\ncorresponding index in A or B.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If arrow A\nreaches the end of its sequence, before arrow B does,\n&quot;traverse_sequences&quot; will call the\n&quot;A_FINISHED&quot; callback when it advances arrow B, if\nthere is such a function; if not it will call\n&quot;DISCARD_B&quot; instead. Similarly if arrow B finishes\nfirst. &quot;traverse_sequences&quot; returns when both\narrows are at the ends of their respective sequences. It\nreturns true on success and false on failure. At present\nthere is no way to fail.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;traverse_sequences&quot;\nmay be passed an optional fourth parameter; this is a\n<small>CODE</small> reference to a key generation function.\nSee &quot; <small>KEY GENERATION FUNCTIONS&quot;</small>\n.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\nparameters, if any, will be passed to the key generation\nfunction.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want to\npass additional parameters to your callbacks, but\ndon&rsquo;t need a custom key generation function, you can\nget the default by passing undef:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">traverse_sequences(\n<br>\n\\@seq1, \\@seq2, <br>\n{ MATCH =&gt; $callback_1, <br>\nDISCARD_A =&gt; $callback_2, <br>\nDISCARD_B =&gt; $callback_3, <br>\n}, <br>\nundef, # default key-gen <br>\n$myArgument1, <br>\n$myArgument2, <br>\n$myArgument3, <br>\n);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;traverse_sequences&quot;\ndoes not have a useful return value; you are expected to\nplug in the appropriate behavior with the callback\nfunctions.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>&quot;traverse_balanced&quot;</b>\n<br>\n&quot;traverse_balanced&quot; is an alternative to\n&quot;traverse_sequences&quot;. It uses a different\nalgorithm to iterate through the entries in the computed\n<small>LCS.</small> Instead of sticking to one side and\nshowing element changes as insertions and deletions only, it\nwill jump back and forth between the two sequences and\nreport <i>changes</i> occurring as deletions on one side\nfollowed immediately by an insertion on the other side.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition to\nthe &quot;DISCARD_A&quot;, &quot;DISCARD_B&quot;, and\n&quot;MATCH&quot; callbacks supported by\n&quot;traverse_sequences&quot;,\n&quot;traverse_balanced&quot; supports a &quot;CHANGE&quot;\ncallback indicating that one element got\n&quot;replaced&quot; by another:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">traverse_balanced(\n<br>\n\\@seq1, \\@seq2, <br>\n{ MATCH =&gt; $callback_1, <br>\nDISCARD_A =&gt; $callback_2, <br>\nDISCARD_B =&gt; $callback_3, <br>\nCHANGE =&gt; $callback_4, <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If no\n&quot;CHANGE&quot; callback is specified,\n&quot;traverse_balanced&quot; will map &quot;CHANGE&quot;\nevents to &quot;DISCARD_A&quot; and &quot;DISCARD_B&quot;\nactions, therefore resulting in a similar behaviour as\n&quot;traverse_sequences&quot; with different order of\nevents.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;traverse_balanced&quot;\nmight be a bit slower than &quot;traverse_sequences&quot;,\nnoticeable only while processing huge amounts of data.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;sdiff&quot; function of this module is implemented as\ncall to &quot;traverse_balanced&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;traverse_balanced&quot;\ndoes not have a useful return value; you are expected to\nplug in the appropriate behavior with the callback\nfunctions.</p>\n\n<h2>KEY GENERATION FUNCTIONS\n<a name=\"KEY GENERATION FUNCTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Most of the\nfunctions accept an optional extra parameter. This is a\n<small>CODE</small> reference to a key generating (hashing)\nfunction that should return a string that uniquely\nidentifies a given element. It should be the case that if\ntwo elements are to be considered equal, their keys should\nbe the same (and the other way around). If no key generation\nfunction is provided, the key will be the element as a\nstring.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\ncomparisons will use &quot;eq&quot; and elements will be\nturned into keys using the default stringizing operator\n&rsquo;&quot;&quot;&rsquo;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Where this is\nimportant is when you&rsquo;re comparing something other\nthan strings. If it is the case that you have multiple\ndifferent objects that should be considered to be equal, you\nshould supply a key generation function. Otherwise, you have\nto make sure that your arrays contain unique references.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For instance,\nconsider this example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">package Person;\n<br>\nsub new <br>\n{ <br>\nmy $package = shift; <br>\nreturn bless { name =&gt; '', ssn =&gt; '', @_ }, $package;\n<br>\n} <br>\nsub clone <br>\n{ <br>\nmy $old = shift; <br>\nmy $new = bless { %$old }, ref($old); <br>\n} <br>\nsub hash <br>\n{ <br>\nreturn shift()-&gt;{'ssn'}; <br>\n} <br>\nmy $person1 = Person-&gt;new( name =&gt; 'Joe', ssn =&gt;\n'123-45-6789' ); <br>\nmy $person2 = Person-&gt;new( name =&gt; 'Mary', ssn =&gt;\n'123-47-0000' ); <br>\nmy $person3 = Person-&gt;new( name =&gt; 'Pete', ssn =&gt;\n'999-45-2222' ); <br>\nmy $person4 = Person-&gt;new( name =&gt; 'Peggy', ssn =&gt;\n'123-45-9999' ); <br>\nmy $person5 = Person-&gt;new( name =&gt; 'Frank', ssn =&gt;\n'000-45-9999' );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you did\nthis:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $array1 = [\n$person1, $person2, $person4 ]; <br>\nmy $array2 = [ $person1, $person3, $person4, $person5 ];\n<br>\nAlgorithm::Diff::diff( $array1, $array2 );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">everything\nwould work out <small>OK</small> (each of the objects would\nbe converted into a string like\n&quot;Person=HASH(0x82425b0)&quot; for comparison).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But if you did\nthis:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $array1 = [\n$person1, $person2, $person4 ]; <br>\nmy $array2 = [ $person1, $person3, $person4-&gt;clone(),\n$person5 ]; <br>\nAlgorithm::Diff::diff( $array1, $array2 );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$person4 and\n$person4-&gt;<b>clone()</b> (which have the same name and\n<small>SSN</small> ) would be seen as different objects. If\nyou wanted them to be considered equivalent, you would have\nto pass in a key generation function:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $array1 = [\n$person1, $person2, $person4 ]; <br>\nmy $array2 = [ $person1, $person3, $person4-&gt;clone(),\n$person5 ]; <br>\nAlgorithm::Diff::diff( $array1, $array2, \\&amp;Person::hash\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This would use\nthe &rsquo;ssn&rsquo; field in each Person as a comparison\nkey, and so would consider $person4 and\n$person4-&gt;<b>clone()</b> as equal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You may also\npass additional parameters to the key generation function if\nyou wish.</p>\n\n<h2>ERROR CHECKING\n<a name=\"ERROR CHECKING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you pass\nthese routines a non-reference and they expect a reference,\nthey will die with a message.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This version\nreleased by Tye McQueen\n(http://perlmonks.org/?node=tye).</p>\n\n<h2>LICENSE\n<a name=\"LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Parts Copyright\n(c) 2000-2004 Ned Konz. All rights reserved. Parts by Tye\nMcQueen.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This program is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl.</p>\n\n<h2>MAILING LIST\n<a name=\"MAILING LIST\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Mark-Jason\nstill maintains a mailing list. To join a low-volume mailing\nlist for announcements related to diff and Algorithm::Diff,\nsend an empty mail message to\nmjd-perl-diff-request@plover.com.</p>\n\n<h2>CREDITS\n<a name=\"CREDITS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Versions\nthrough 0.59 (and much of this documentation) were written\nby:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Mark-Jason\nDominus</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This version\nborrows some documentation and routine names from\nMark-Jason&rsquo;s, but Diff.pm&rsquo;s code was completely\nreplaced.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This code was\nadapted from the Smalltalk code of Mario Wolczko\n&lt;mario@wolczko.com&gt;, which is available at\nftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;sdiff&quot;\nand &quot;traverse_balanced&quot; were written by Mike\nSchilli &lt;m@perlmeister.com&gt;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The algorithm\nis that described in <i>A Fast Algorithm for Computing\nLongest Common Subsequences</i>, <small>CACM,</small>\nvol.20, no.5, pp.350-353, May 1977, with a few minor\nimprovements to improve the speed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Much work was\ndone by Ned Konz (perl@bike-nomad.com).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<small>OO</small> interface and some other changes are by\nTye McQueen.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#INTRODUCTION\">INTRODUCTION</a>","<a href=\"#USAGE\">USAGE</a>","<a href=\"#KEY GENERATION FUNCTIONS\">KEY GENERATION FUNCTIONS</a>","<a href=\"#ERROR CHECKING\">ERROR CHECKING</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#LICENSE\">LICENSE</a>","<a href=\"#MAILING LIST\">MAILING LIST</a>","<a href=\"#CREDITS\">CREDITS</a>"],"level":3}