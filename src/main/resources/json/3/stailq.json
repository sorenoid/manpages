{"name":"stailq","description":"STAILQ_CONCAT,\nSTAILQ_EMPTY, STAILQ_ENTRY, STAILQ_FIRST, STAILQ_FOREACH,\nSTAILQ_HEAD, STAILQ_HEAD_INITIALIZER, STAILQ_INIT,\nSTAILQ_INSERT_AFTER, STAILQ_INSERT_HEAD, STAILQ_INSERT_TAIL,\nSTAILQ_NEXT, STAILQ_REMOVE, STAILQ_REMOVE_HEAD, -\nimplementation of a singly linked tail queue","body":"\n\n<h1 align=\"center\">STAILQ</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">STAILQ_CONCAT,\nSTAILQ_EMPTY, STAILQ_ENTRY, STAILQ_FIRST, STAILQ_FOREACH,\nSTAILQ_HEAD, STAILQ_HEAD_INITIALIZER, STAILQ_INIT,\nSTAILQ_INSERT_AFTER, STAILQ_INSERT_HEAD, STAILQ_INSERT_TAIL,\nSTAILQ_NEXT, STAILQ_REMOVE, STAILQ_REMOVE_HEAD, -\nimplementation of a singly linked tail queue</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/queue.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSTAILQ_CONCAT(STAILQ_HEAD *</b><i>head1</i><b>, STAILQ_HEAD\n*</b><i>head2</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nSTAILQ_EMPTY(STAILQ_HEAD *</b><i>head</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STAILQ_ENTRY(TYPE);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct TYPE\n*STAILQ_FIRST(STAILQ_HEAD *</b><i>head</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STAILQ_FOREACH(struct\nTYPE *</b><i>var</i><b>, STAILQ_HEAD *</b><i>head</i><b>,\nSTAILQ_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STAILQ_HEAD(HEADNAME,\nTYPE);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STAILQ_HEAD\nSTAILQ_HEAD_INITIALIZER(STAILQ_HEAD</b>\n<i>head</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSTAILQ_INIT(STAILQ_HEAD *</b><i>head</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSTAILQ_INSERT_AFTER(STAILQ_HEAD *</b><i>head</i><b>, struct\nTYPE *</b><i>listelm</i><b>, <br>\nstruct TYPE *</b><i>elm</i><b>, STAILQ_ENTRY</b>\n<i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSTAILQ_INSERT_HEAD(STAILQ_HEAD *</b><i>head</i><b>, struct\nTYPE *</b><i>elm</i><b>, <br>\nSTAILQ_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSTAILQ_INSERT_TAIL(STAILQ_HEAD *</b><i>head</i><b>, struct\nTYPE *</b><i>elm</i><b>, <br>\nSTAILQ_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct TYPE\n*STAILQ_NEXT(struct TYPE *</b><i>elm</i><b>,\nSTAILQ_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSTAILQ_REMOVE(STAILQ_HEAD *</b><i>head</i><b>, struct TYPE\n*</b><i>elm</i><b>, TYPE, <br>\nSTAILQ_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSTAILQ_REMOVE_HEAD(STAILQ_HEAD *</b><i>head</i><b>,\nSTAILQ_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These macros\ndefine and operate on singly linked tail queues.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the macro\ndefinitions, <i>TYPE</i> is the name of a user-defined\nstructure, that must contain a field of type\n<i>STAILQ_ENTRY</i>, named <i>NAME</i>. The argument\n<i>HEADNAME</i> is the name of a user-defined structure that\nmust be declared using the macro <b>STAILQ_HEAD</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A singly linked\ntail queue is headed by a structure defined by the\n<b>STAILQ_HEAD</b>() macro. This structure contains a pair\nof pointers, one to the first element in the tail queue and\nthe other to the last element in the tail queue. The\nelements are singly linked for minimum space and pointer\nmanipulation overhead at the expense of O(n) removal for\narbitrary elements. New elements can be added to the tail\nqueue after an existing element, at the head of the tail\nqueue, or at the end of the tail queue. A <i>STAILQ_HEAD</i>\nstructure is declared as follows:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">STAILQ_HEAD(HEADNAME,\nTYPE) head;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where <i>struct\nHEADNAME</i> is the structure to be defined, and <i>struct\nTYPE</i> is the type of the elements to be linked into the\ntail queue. A pointer to the head of the tail queue can\nlater be declared as:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct HEADNAME\n*headp;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(The names\n<i>head</i> and <i>headp</i> are user selectable.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_HEAD_INITIALIZER</b>() evaluates to an initializer\nfor the tail queue <i>head</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_CONCAT</b>() concatenates the tail queue headed by\n<i>head2</i> onto the end of the one headed by <i>head1</i>\nremoving all entries from the former.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_EMPTY</b>() evaluates to true if there are no\nitems on the tail queue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_ENTRY</b>() declares a structure that connects the\nelements in the tail queue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_FIRST</b>() returns the first item on the tail\nqueue or NULL if the tail queue is empty.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_FOREACH</b>() traverses the tail queue referenced\nby <i>head</i> in the forward direction, assigning each\nelement in turn to <i>var</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_INIT</b>() initializes the tail queue referenced\nby <i>head</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_INSERT_HEAD</b>() inserts the new element\n<i>elm</i> at the head of the tail queue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_INSERT_TAIL</b>() inserts the new element\n<i>elm</i> at the end of the tail queue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_INSERT_AFTER</b>() inserts the new element\n<i>elm</i> after the element <i>listelm</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_NEXT</b>() returns the next item on the tail\nqueue, or NULL this item is the last.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_REMOVE_HEAD</b>() removes the element at the head\nof the tail queue. For optimum efficiency, elements being\nremoved from the head of the tail queue should use this\nmacro explicitly rather than the generic\n<b>STAILQ_REMOVE</b>() macro.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_REMOVE</b>() removes the element <i>elm</i> from\nthe tail queue.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STAILQ_EMPTY</b>()\nreturns nonzero if the queue is empty, and zero if the queue\ncontains at least one entry.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STAILQ_FIRST</b>(),\nand <b>STAILQ_NEXT</b>() return a pointer to the first or\nnext <i>TYPE</i> structure, respectively.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STAILQ_HEAD_INITIALIZER</b>()\nreturns an initializer that can be assigned to the queue\n<i>head</i>.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Not in POSIX.1,\nPOSIX.1-2001 or POSIX.1-2008. Present on the BSDs (STAILQ\nmacros first appeared in 4.4BSD).</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>STAILQ_FOREACH</b>() doesn&rsquo;t allow <i>var</i> to be\nremoved or freed within the loop, as it would interfere with\nthe traversal. The macro <b>STAILQ_FOREACH_SAFE</b>(), which\nis present on the BSDs but is not present in glibc, fixes\nthis limitation by allowing <i>var</i> to safely be removed\nfrom the list and freed from within the loop without\ninterfering with the traversal.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stddef.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/queue.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct entry {\n<br>\nint data; <br>\nSTAILQ_ENTRY(entry) entries; /* Singly linked tail queue. */\n<br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">STAILQ_HEAD(stailhead,\nentry);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(void) <br>\n{ <br>\nstruct entry *n1, *n2, *n3, *np; <br>\nstruct stailhead head; /* Singly linked tail queue <br>\nhead. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">STAILQ_INIT(&amp;head);\n/* Initialize the queue. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n1 =\nmalloc(sizeof(struct entry)); /* Insert at the head. */ <br>\nSTAILQ_INSERT_HEAD(&amp;head, n1, entries);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n1 =\nmalloc(sizeof(struct entry)); /* Insert at the tail. */ <br>\nSTAILQ_INSERT_TAIL(&amp;head, n1, entries);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n2 =\nmalloc(sizeof(struct entry)); /* Insert after. */ <br>\nSTAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">STAILQ_REMOVE(&amp;head,\nn2, entry, entries);/* Deletion. */ <br>\nfree(n2);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n3 =\nSTAILQ_FIRST(&amp;head); <br>\nSTAILQ_REMOVE_HEAD(&amp;head, entries); /* Deletion from the\nhead. */ <br>\nfree(n3);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n1 =\nSTAILQ_FIRST(&amp;head); <br>\nn1-&gt;data = 0; <br>\nfor (int i = 1; i &lt; 5; i++) { <br>\nn1 = malloc(sizeof(struct entry)); <br>\nSTAILQ_INSERT_HEAD(&amp;head, n1, entries); <br>\nn1-&gt;data = i; <br>\n} <br>\n/* Forward traversal. */ <br>\nSTAILQ_FOREACH(np, &amp;head, entries) <br>\nprintf(&quot;%i\\n&quot;, np-&gt;data); <br>\n/* TailQ Deletion. */ <br>\nn1 = STAILQ_FIRST(&amp;head); <br>\nwhile (n1 != NULL) { <br>\nn2 = STAILQ_NEXT(n1, entries); <br>\nfree(n1); <br>\nn1 = n2; <br>\n} <br>\nSTAILQ_INIT(&amp;head);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/insque\">insque(3)</a>,\n<a href=\"https://man.page/7/queue\">queue(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}