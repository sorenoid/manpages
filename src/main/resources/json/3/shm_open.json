{"name":"shm_open","body":"\n\n<h1 align=\"center\">SHM_OPEN</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">shm_open,\nshm_unlink - create/open or unlink POSIX shared memory\nobjects</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/mman.h&gt; <br>\n#include &lt;sys/stat.h&gt;</b> /* For mode constants */\n<b><br>\n#include &lt;fcntl.h&gt;</b> /* For O_* constants */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nshm_open(const char *</b><i>name</i><b>, int</b>\n<i>oflag</i><b>, mode_t</b> <i>mode</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nshm_unlink(const char *</b><i>name</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Link with\n<i>-lrt</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>shm_open</b>()\ncreates and opens a new, or opens an existing, POSIX shared\nmemory object. A POSIX shared memory object is in effect a\nhandle which can be used by unrelated processes to\n<a href=\"https://man.page/2/mmap\">mmap(2)</a> the same region of shared memory. The\n<b>shm_unlink</b>() function performs the converse\noperation, removing an object previously created by\n<b>shm_open</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The operation\nof <b>shm_open</b>() is analogous to that of <a href=\"https://man.page/2/open\">open(2)</a>.\n<i>name</i> specifies the shared memory object to be created\nor opened. For portable use, a shared memory object should\nbe identified by a name of the form <i>/somename</i>; that\nis, a null-terminated string of up to <b>NAME_MAX</b> (i.e.,\n255) characters consisting of an initial slash, followed by\none or more characters, none of which are slashes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>oflag</i> is\na bit mask created by ORing together exactly one of\n<b>O_RDONLY</b> or <b>O_RDWR</b> and any of the other flags\nlisted here: <b><br>\nO_RDONLY</b></p>\n\n<p style=\"margin-left:22%;\">Open the object for read\naccess. A shared memory object opened in this way can be\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>ed only for read (<b>PROT_READ</b>)\naccess.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>O_RDWR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"58%\">\n\n\n<p>Open the object for read-write access.</p></td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>O_CREAT</b></p>\n\n<p style=\"margin-left:22%;\">Create the shared memory object\nif it does not exist. The user and group ownership of the\nobject are taken from the corresponding effective IDs of the\ncalling process, and the object&rsquo;s permission bits are\nset according to the low-order 9 bits of <i>mode</i>, except\nthat those bits set in the process file mode creation mask\n(see <a href=\"https://man.page/2/umask\">umask(2)</a>) are cleared for the new object. A set\nof macro constants which can be used to define <i>mode</i>\nis listed in <a href=\"https://man.page/2/open\">open(2)</a>. (Symbolic definitions of these\nconstants can be obtained by including\n<i>&lt;sys/stat.h&gt;</i>.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A new shared\nmemory object initially has zero length&mdash;the size of\nthe object can be set using <a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>. The newly\nallocated bytes of a shared memory object are automatically\ninitialized to 0.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>O_EXCL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>If <b>O_CREAT</b> was also specified, and a shared\nmemory object with the given <i>name</i> already exists,\nreturn an error. The check for the existence of the object,\nand its creation if it does not exist, are performed\natomically.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>O_TRUNC</b></p>\n\n<p style=\"margin-left:22%;\">If the shared memory object\nalready exists, truncate it to zero bytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Definitions of\nthese flag values can be obtained by including\n<i>&lt;fcntl.h&gt;</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On successful\ncompletion <b>shm_open</b>() returns a new file descriptor\nreferring to the shared memory object. This file descriptor\nis guaranteed to be the lowest-numbered file descriptor not\npreviously opened within the process. The <b>FD_CLOEXEC</b>\nflag (see <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>) is set for the file\ndescriptor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The file\ndescriptor is normally used in subsequent calls to\n<a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a> (for a newly created object) and\n<a href=\"https://man.page/2/mmap\">mmap(2)</a>. After a call to <a href=\"https://man.page/2/mmap\">mmap(2)</a> the file\ndescriptor may be closed without affecting the memory\nmapping.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The operation\nof <b>shm_unlink</b>() is analogous to <a href=\"https://man.page/2/unlink\">unlink(2)</a>: it\nremoves a shared memory object name, and, once all processes\nhave unmapped the object, de-allocates and destroys the\ncontents of the associated memory region. After a successful\n<b>shm_unlink</b>(), attempts to <b>shm_open</b>() an object\nwith the same <i>name</i> fail (unless <b>O_CREAT</b> was\nspecified, in which case a new, distinct object is\ncreated).</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>shm_open</b>() returns a file descriptor (a nonnegative\ninteger). On failure, <b>shm_open</b>() returns -1.\n<b>shm_unlink</b>() returns 0 on success, or -1 on\nerror.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On failure,\n<i>errno</i> is set to indicate the cause of the error.\nValues which may appear in <i>errno</i> include the\nfollowing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Permission to <b>shm_unlink</b>() the shared memory\nobject was denied.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Permission was denied to <b>shm_open</b>() <i>name</i>\nin the specified <i>mode</i>, or <b>O_TRUNC</b> was\nspecified and the caller does not have write permission on\nthe object.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EEXIST</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Both <b>O_CREAT</b> and <b>O_EXCL</b> were specified to\n<b>shm_open</b>() and the shared memory object specified by\n<i>name</i> already exists.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The <i>name</i> argument to <b>shm_open</b>() was\ninvalid.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EMFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The per-process limit on the number of open file\ndescriptors has been reached.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>ENAMETOOLONG</b></p>\n\n<p style=\"margin-left:22%;\">The length of <i>name</i>\nexceeds <b>PATH_MAX</b>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENFILE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The system-wide limit on the total number of open files\nhas been reached.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An attempt was made to <b>shm_open</b>() a <i>name</i>\nthat did not exist, and <b>O_CREAT</b> was not\nspecified.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOENT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An attempt was to made to <b>shm_unlink</b>() a\n<i>name</i> that does not exist.</p></td></tr>\n</table>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nare provided in glibc 2.2 and later.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3320851.png\" alt=\"Image grohtml-3320851.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001\nsays that the group ownership of a newly created shared\nmemory object is set to either the calling process&rsquo;s\neffective group ID or &quot;a system default group ID&quot;.\nPOSIX.1-2008 says that the group ownership may be set to\neither the calling process&rsquo;s effective group ID or, if\nthe object is visible in the filesystem, the group ID of the\nparent directory.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX leaves\nthe behavior of the combination of <b>O_RDONLY</b> and\n<b>O_TRUNC</b> unspecified. On Linux, this will successfully\ntruncate an existing shared memory object&mdash;this may not\nbe so on other UNIX systems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The POSIX\nshared memory object implementation on Linux makes use of a\ndedicated <a href=\"https://man.page/5/tmpfs\">tmpfs(5)</a> filesystem that is normally\nmounted under <i>/dev/shm</i>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The programs\nbelow employ POSIX shared memory and POSIX unnamed\nsemaphores to exchange a piece of data. The\n&quot;bounce&quot; program (which must be run first) raises\nthe case of a string that is placed into the shared memory\nby the &quot;send&quot; program. Once the data has been\nmodified, the &quot;send&quot; program then prints the\ncontents of the modified shared memory. An example execution\nof the two programs is the following:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./pshm_ucase_bounce /myshm &amp;</b> <br>\n[1] 270171 <br>\n$ <b>./pshm_ucase_send /myshm hello</b> <br>\nHELLO</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Further detail\nabout these programs is provided below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: pshm_ucase.h</b> <br>\nThe following header file is included by both programs\nbelow. Its primary purpose is to define a structure that\nwill be imposed on the memory object that is shared between\nthe two programs.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#include\n&lt;sys/mman.h&gt; <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;semaphore.h&gt; <br>\n#include &lt;sys/stat.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define\nBUF_SIZE 1024 /* Maximum size for exchanged string */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Define a\nstructure that will be imposed on the shared <br>\nmemory object */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct shmbuf {\n<br>\nsem_t sem1; /* POSIX unnamed semaphore */ <br>\nsem_t sem2; /* POSIX unnamed semaphore */ <br>\nsize_t cnt; /* Number of bytes used in 'buf' */ <br>\nchar buf[BUF_SIZE]; /* Data being transferred */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: pshm_ucase_bounce.c</b> <br>\nThe &quot;bounce&quot; program creates a new shared memory\nobject with the name given in its command-line argument and\nsizes the object to match the size of the <i>shmbuf</i>\nstructure defined in the header file. It then maps the\nobject into the process&rsquo;s address space, and\ninitializes two POSIX semaphores inside the object to 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After the\n&quot;send&quot; program has posted the first of the\nsemaphores, the &quot;bounce&quot; program upper cases the\ndata that has been placed in the memory by the\n&quot;send&quot; program and then posts the second semaphore\nto tell the &quot;send&quot; program that it may now access\nthe shared memory.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/*\npshm_ucase_bounce.c</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Licensed under\nGNU General Public License v2 or later. <br>\n*/ <br>\n#include &lt;ctype.h&gt; <br>\n#include &quot;pshm_ucase.h&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nif (argc != 2) { <br>\nfprintf(stderr, &quot;Usage: %s /shm-path\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">char *shmpath =\nargv[1];</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Create\nshared memory object and set its size to the size <br>\nof our structure */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int fd =\nshm_open(shmpath, O_CREAT | O_EXCL | O_RDWR, <br>\nS_IRUSR | S_IWUSR); <br>\nif (fd == -1) <br>\nerrExit(&quot;shm_open&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(ftruncate(fd, sizeof(struct shmbuf)) == -1) <br>\nerrExit(&quot;ftruncate&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Map the\nobject into the caller's address space */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct shmbuf\n*shmp = mmap(NULL, sizeof(*shmp), <br>\nPROT_READ | PROT_WRITE, <br>\nMAP_SHARED, fd, 0); <br>\nif (shmp == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Initialize\nsemaphores as process-shared, with value 0 */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(sem_init(&amp;shmp-&gt;sem1, 1, 0) == -1) <br>\nerrExit(&quot;sem_init-sem1&quot;); <br>\nif (sem_init(&amp;shmp-&gt;sem2, 1, 0) == -1) <br>\nerrExit(&quot;sem_init-sem2&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Wait for\n'sem1' to be posted by peer before touching <br>\nshared memory */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(sem_wait(&amp;shmp-&gt;sem1) == -1) <br>\nerrExit(&quot;sem_wait&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Convert data\nin shared memory into upper case */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for (int j = 0;\nj &lt; shmp-&gt;cnt; j++) <br>\nshmp-&gt;buf[j] = toupper((unsigned char)\nshmp-&gt;buf[j]);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Post 'sem2'\nto tell the to tell peer that it can now <br>\naccess the modified data in shared memory */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(sem_post(&amp;shmp-&gt;sem2) == -1) <br>\nerrExit(&quot;sem_post&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Unlink the\nshared memory object. Even if the peer process <br>\nis still using the object, this is okay. The object will\n<br>\nbe removed only after all open references are closed. */</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">shm_unlink(shmpath);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource: pshm_ucase_send.c</b> <br>\nThe &quot;send&quot; program takes two command-line\narguments: the pathname of a shared memory object previously\ncreated by the &quot;bounce&quot; program and a string that\nis to be copied into that object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nopens the shared memory object and maps the object into its\naddress space. It then copies the data specified in its\nsecond argument into the shared memory, and posts the first\nsemaphore, which tells the &quot;bounce&quot; program that\nit can now access that data. After the &quot;bounce&quot;\nprogram posts the second semaphore, the &quot;send&quot;\nprogram prints the contents of the shared memory on standard\noutput.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/*\npshm_ucase_send.c</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Licensed under\nGNU General Public License v2 or later. <br>\n*/ <br>\n#include &lt;string.h&gt; <br>\n#include &quot;pshm_ucase.h&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nif (argc != 3) { <br>\nfprintf(stderr, &quot;Usage: %s /shm-path string\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">char *shmpath =\nargv[1]; <br>\nchar *string = argv[2]; <br>\nsize_t len = strlen(string);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (len &gt;\nBUF_SIZE) { <br>\nfprintf(stderr, &quot;String is too long\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Open the\nexisting shared memory object and map it <br>\ninto the caller's address space */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">int fd =\nshm_open(shmpath, O_RDWR, 0); <br>\nif (fd == -1) <br>\nerrExit(&quot;shm_open&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct shmbuf\n*shmp = mmap(NULL, sizeof(*shmp), <br>\nPROT_READ | PROT_WRITE, <br>\nMAP_SHARED, fd, 0); <br>\nif (shmp == MAP_FAILED) <br>\nerrExit(&quot;mmap&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Copy data\ninto the shared memory object */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">shmp-&gt;cnt =\nlen; <br>\nmemcpy(&amp;shmp-&gt;buf, string, len);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Tell peer\nthat it can now access shared memory */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(sem_post(&amp;shmp-&gt;sem1) == -1) <br>\nerrExit(&quot;sem_post&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Wait until\npeer says that it has finished accessing <br>\nthe shared memory */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\n(sem_wait(&amp;shmp-&gt;sem2) == -1) <br>\nerrExit(&quot;sem_wait&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Write\nmodified data in shared memory to standard output */</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">write(STDOUT_FILENO,\n&amp;shmp-&gt;buf, len); <br>\nwrite(STDOUT_FILENO, &quot;\\n&quot;, 1);</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/close\">close(2)</a>,\n<a href=\"https://man.page/2/fchmod\">fchmod(2)</a>, <a href=\"https://man.page/2/fchown\">fchown(2)</a>, <a href=\"https://man.page/2/fcntl\">fcntl(2)</a>,\n<a href=\"https://man.page/2/fstat\">fstat(2)</a>, <a href=\"https://man.page/2/ftruncate\">ftruncate(2)</a>,\n<a href=\"https://man.page/2/memfd_create\">memfd_create(2)</a>, <a href=\"https://man.page/2/mmap\">mmap(2)</a>, <a href=\"https://man.page/2/open\">open(2)</a>,\n<a href=\"https://man.page/2/umask\">umask(2)</a>, <a href=\"https://man.page/7/shm_overview\">shm_overview(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}