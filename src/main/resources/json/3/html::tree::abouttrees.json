{"name":"html::tree::abouttrees","body":"\n\n<h1 align=\"center\">HTML::Tree::AboutTrees</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Tree::AboutTrees\n-- article on tree-shaped data structures in Perl</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"># This an\narticle, not a module.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\narticle by Sean M. Burke first appeared in <i>The Perl\nJournal</i> #18 and is copyright 2000 The Perl Journal. It\nappears courtesy of Jon Orwant and The Perl Journal. This\ndocument may be distributed under the same terms as Perl\nitself.</p>\n\n<h2>Trees\n<a name=\"Trees\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- Sean M.\nBurke</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;AaaAAAaauugh!\nWatch out for that tree!&quot; <br>\n-- <i>George of the Jungle theme</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl&rsquo;s\nfacility with references, combined with its automatic\nmanagement of memory allocation, makes it straightforward to\nwrite programs that store data in structures of arbitrary\nform and complexity.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But I&rsquo;ve\nnoticed that many programmers, especially those who started\nout with more restrictive languages, seem at home with\ncomplex but uniform data structures -- N-dimensional arrays,\nor more struct-like things like\nhashes-of-arrays(-of-hashes(-of-hashes), etc.) -- but\nthey&rsquo;re often uneasy with building more freeform, less\ntabular structures, like tree-shaped data structures.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But trees are\neasy to build and manage in Perl, as I&rsquo;ll demonstrate\nby showing off how the HTML::Element class manages elements\nin an <small>HTML</small> document tree, and by walking you\nthrough a from-scratch implementation of game trees. But\nfirst we need to nail down what we mean by a\n&quot;tree&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Socratic\nDialogues: &quot;What is a Tree?&quot;</b> <br>\nMy first brush with tree-shaped structures was in\nlinguistics classes, where tree diagrams are used to\ndescribe the syntax underlying natural language sentences.\nAfter learning my way around <i>those</i> trees, I started\nto wonder -- are what I&rsquo;m used to calling\n&quot;trees&quot; the same as what programmers call\n&quot;trees&quot;? So I asked lots of helpful and patient\nprogrammers how they would define a tree. Many replied with\na answer in jargon that they could not really explain\n(understandable, since explaining things, especially\ndefining things, is harder than people think):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">-- So what\n<i>is</i> a &quot;tree&quot;, a tree-shaped data\nstructure?</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">-- A tree is a\nspecial case of an acyclic directed graph!</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">-- What&rsquo;s\na &quot;graph&quot;?</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">-- Um...\nlines... and... you draw it... with... arcs! nodes!\num...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The most\nhelpful were folks who couldn&rsquo;t explain directly, but\nwith whom I could get into a rather Socratic dialog (where\n<i>I</i> asked the half-dim half-earnest questions), often\nwith much doodling of illustrations...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Question: so\nwhat&rsquo;s a tree?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Answer: A tree\nis a collection of nodes that are linked together in a,\nwell, tree-like way! Like this <i>[drawing on a\nnapkin]:</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A <br>\n/ \\ <br>\nB C <br>\n/ | \\ <br>\nD E F</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: So what do\nthese letters represent?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Each is a\ndifferent node, a bunch of data. Maybe C is a bunch of data\nthat stores a number, maybe a hash table, maybe nothing at\nall besides the fact that it links to D, E, and F (which are\nother nodes).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: So\nwhat&rsquo;re the lines between the nodes?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Links. Also\ncalled &quot;arcs&quot;. They just symbolize the fact that\neach node holds a list of nodes it links to.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: So what if I\ndraw nodes and links, like this...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">B -- E <br>\n/ \\ / \\ <br>\nA C <br>\n\\ / <br>\nE</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Is that still a\ntree?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: No, not at\nall. There&rsquo;s a lot of un-treelike things about that.\nFirst off, E has a link coming off of it going into nowhere.\nYou can&rsquo;t have a link to nothing -- you can only link\nto another node. Second off, I don&rsquo;t know what that\nsideways link between B and E means...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: Okay,\nlet&rsquo;s work our way up from something simpler. Is this\na tree...?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Yes, I\nsuppose. It&rsquo;s a tree of just one node.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: And how\nabout...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A <br>\nB</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: No, you\ncan&rsquo;t just have nodes floating there, unattached.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: Okay,\nI&rsquo;ll link A and B. How&rsquo;s this?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A <br>\n| <br>\nB</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Yup,\nthat&rsquo;s a tree. There&rsquo;s a node A, and a node B,\nand they&rsquo;re linked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: How is that\ntree any different from this one...?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">B <br>\n| <br>\nA</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Well, in\nboth cases A and B are linked. But it&rsquo;s in a different\ndirection.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: Direction?\nWhat does the direction mean?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Well, it\ndepends what the tree represents. If it represents a\ncategorization, like this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">citrus <br>\n/ | \\ <br>\norange lemon kumquat ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then you mean\nto say that oranges, lemons, kumquats, etc., are a kind of\ncitrus. But if you drew it upside down, you&rsquo;d be\nsaying, falsely, that citrus is a kind of kumquat, a kind of\nlemon, and a kind of orange. If the tree represented\ncause-and-effect (or at least what situations could follow\nothers), or represented what&rsquo;s a part of what, you\nwouldn&rsquo;t want to get those backwards, either. So with\nthe nodes you draw together on paper, one has to be over the\nother, so you can tell which way the relationship in the\ntree works.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: So are these\ntwo trees the same?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A A <br>\n/ \\ / \\ <br>\nB C B \\ <br>\nC</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Yes,\nalthough by convention we often try to line up things in the\nsame generation, like it is in the diagram on the left.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q:\n&quot;generation&quot;? This is a family tree?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: No, not\nunless it&rsquo;s a family tree for just yeast cells or\nsomething else that reproduces asexually. But for sake of\nhaving lots of terms to use, we just pretend that links in\nthe tree represent the &quot;is a child of&quot;\nrelationship, instead of &quot;is a kind of&quot; or\n&quot;is a part of&quot;, or &quot;could result from&quot;,\nor whatever the real relationship is. So we get to borrow a\nlot of kinship words for describing trees -- B and C are\n&quot;children&quot; (or &quot;daughters&quot;) of A; A is\nthe &quot;parent&quot; (or &quot;mother&quot;) of B and C.\nNode C is a &quot;sibling&quot; (or &quot;sister&quot;) of\nnode C; and so on, with terms like &quot;descendants&quot;\n(a node&rsquo;s children, children&rsquo;s children, etc.),\nand &quot;generation&quot; (all the nodes at the same\n&quot;level&quot; in the tree, i.e., are either all\ngrandchildren of the top node, or all great-grand-children,\netc.), and &quot;lineage&quot; or &quot;ancestors&quot;\n(parents, and parent&rsquo;s parents, etc., all the way to\nthe topmost node).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So then we get\nto express rules in terms like &quot;<b>A node cannot have\nmore than one parent</b>&quot;, which means that this is not\na valid tree:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A <br>\n/ \\ <br>\nB C <br>\n\\ / <br>\nE</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And: &quot;<b>A\nnode can&rsquo;t be its own parent</b>&quot;, which excludes\nthis looped-up connection:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/\\ <br>\nA | <br>\n\\/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Or, put more\ngenerally: &quot;<b>A node can&rsquo;t be its own\nancestor</b>&quot;, which excludes the above loop, as well\nas the one here:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/\\ <br>\nZ | <br>\n/ | <br>\nA | <br>\n/ \\ | <br>\nB C | <br>\n\\/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That tree is\nexcluded because A is a child of Z, and Z is a child of C,\nand C is a child of A, which means A is its own\ngreat-grandparent. So this whole network can&rsquo;t be a\ntree, because it breaks the sort of meta-rule: <b>once any\nnode in the supposed tree breaks the rules for trees, you\ndon&rsquo;t have a tree anymore.</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: Okay, now,\nare these two trees the same?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A A <br>\n/ | \\ / | \\ <br>\nB C D D C B</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: It depends\nwhether you&rsquo;re basing your concept of trees on each\nnode having a set (unordered list) of children, or an\n(ordered) list of children. It&rsquo;s a question of whether\nordering is important for what you&rsquo;re doing. With my\ndiagram of citrus types, ordering isn&rsquo;t important, so\nthese tree diagrams express the same thing:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">citrus <br>\n/ | \\ <br>\norange lemon kumquat <br>\ncitrus <br>\n/ | \\ <br>\nkumquat orange lemon</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">because it\ndoesn&rsquo;t make sense to say that oranges are\n&quot;before&quot; or &quot;after&quot; kumquats in the\nwhole botanical scheme of things. (Unless, of course, you\n<i>are</i> using ordering to mean something, like a degree\nof genetic similarity.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But consider a\ntree that&rsquo;s a diagram of what steps are comprised in\nan activity, to some degree of specificity:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">make tea <br>\n/ | \\ <br>\npour infuse serve <br>\nhot water / \\ <br>\nin cup/pot / \\ <br>\nadd let <br>\ntea sit <br>\nleaves</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This means that\nmaking tea consists of putting hot water in a cup or put,\ninfusing it (which itself consists of adding tea leaves and\nletting it sit), then serving it -- <i>in that order</i>. If\nyou serve an empty dry pot (sipping from empty cups, etc.),\nlet it sit, add tea leaves, and pour in hot water, then what\nyou&rsquo;re doing is performance art, not tea\npreparation:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">performance\n<br>\nart <br>\n/ | \\ <br>\nserve infuse pour <br>\n/ \\ hot water <br>\n/ \\ in cup/pot <br>\nlet add <br>\nsit tea <br>\nleaves</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Except for my\nhaving renamed the root, this tree is the same as the\nmaking-tea tree as far as what&rsquo;s under what, but it\ndiffers in order, and what the tree means makes the order\nimportant.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: Wait --\n&quot;root&quot;? What&rsquo;s a root?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Besides\nkinship terms like &quot;mother&quot; and\n&quot;daughter&quot;, the jargon for tree parts also has\nterms from real-life tree parts: the part that everything\nelse grows from is called the root; and nodes that\ndon&rsquo;t have nodes attached to them (i.e., childless\nnodes) are called &quot;leaves&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Q: But\nyou&rsquo;ve been drawing all your trees with the root at\nthe top and leaves at the bottom.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A: Yes, but for\nsome reason, that&rsquo;s the way everyone seems to think of\ntrees. They can draw trees as above; or they can draw them\nsort of sideways with indenting representing what nodes are\nchildren of what:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* make tea <br>\n* pour hot water in cup/pot <br>\n* infuse <br>\n* add tea leaves <br>\n* let sit <br>\n* serve</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...but folks\nalmost never seem to draw trees with the root at the bottom.\nSo imagine it&rsquo;s based on spider plant in a hanging\npot. Unfortunately, spider plants <i>aren&rsquo;t</i>\nbotanically trees, they&rsquo;re plants; but &quot;spider\nplant diagram&quot; is rather a mouthful, so let&rsquo;s\njust call them trees.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Trees\nDefined Formally</b> <br>\nIn time, I digested all these assorted facts about\nprogrammers&rsquo; ideas of trees (which turned out to be\njust a more general case of linguistic ideas of trees) into\na single rule:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* A node is an\nitem that contains (&quot;is over&quot;, &quot;is parent\nof&quot;, etc.) zero or more other nodes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From this you\ncan build up formal definitions for useful terms, like\nso:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* A\nnode&rsquo;s <b>descendants</b> are defined as all its\nchildren, and all their children, and so on. Or, stated\nrecursively: a node&rsquo;s descendants are all its\nchildren, and all its children&rsquo;s descendants. (And if\nit has no children, it has no descendants.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* A\nnode&rsquo;s <b>ancestors</b> consist of its parent, and its\nparent&rsquo;s parent, etc, up to the root. Or, recursively:\na node&rsquo;s ancestors consist of its parent and its\nparent&rsquo;s ancestors. (If it has no parent, it has no\nancestors.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* A <b>tree</b>\nis a root node and all the root&rsquo;s descendants.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And you can add\na proviso or two to clarify exactly what I impute to the\nword &quot;other&quot; in &quot;other nodes&quot;:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* A node cannot\ncontain itself, or contain any node that contains it, etc.\nLooking at it the other way: a node cannot be its own parent\nor ancestor.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* A node can be\nroot (i.e., no other node contains it) or can be contained\nby only one parent; no node can be the child of two or more\nparents.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Add to this the\nidea that children are sometimes ordered, and sometimes not,\nand that&rsquo;s about all you need to know about defining\nwhat a tree is. From there it&rsquo;s a matter of using\nthem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Markup\nLanguage Trees: HTML-Tree</b> <br>\nWhile not <i>all</i> markup languages are inherently\ntree-like, the best-known family of markup languages,\n<small>HTML, SGML,</small> and <small>XML,</small> are about\nas tree-like as you can get. In these languages, a document\nconsists of elements and character data in a tree structure\nwhere there is one root element, and elements can contain\neither other elements, or character data.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: For\nsake of simplicity, I&rsquo;m glossing over comments\n(&lt;!-- ... --&gt;), processing instructions (&lt;?xml\nversion=&rsquo;1.0&rsquo;&gt;), and declarations\n(&lt;!ELEMENT ...&gt;, &lt;!DOCTYPE ...&gt;). And I&rsquo;m\nnot bothering to distinguish entity references (&amp;lt;,\n&amp;#64;) or <small>CDATA</small> sections (&lt;![CDATA[\n...]]&gt;) from normal text.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nconsider this <small>HTML</small> document:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;html\nlang=&quot;en-US&quot;&gt; <br>\n&lt;head&gt; <br>\n&lt;title&gt; <br>\nBlank Document! <br>\n&lt;/title&gt; <br>\n&lt;/head&gt; <br>\n&lt;body bgcolor=&quot;#d010ff&quot;&gt; <br>\nI've got <br>\n&lt;em&gt; <br>\nsomething to saaaaay <br>\n&lt;/em&gt; <br>\n! <br>\n&lt;/body&gt; <br>\n&lt;/html&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">I&rsquo;ve\nindented this to point out what nodes (elements or text\nitems) are children of what, with each node on a line of its\nown.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nHTML::TreeBuilder module (in the <small>CPAN</small>\ndistribution HTML-Tree) does the work of taking\n<small>HTML</small> source and building in memory the tree\nthat the document source represents.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: it\nrequires the HTML::Parser module, which tokenizes the source\n-- i.e., identifies each tag, bit of text, comment, etc.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The trees\nstructures that it builds represent bits of text with normal\nPerl scalar string values; but elements are represented with\nobjects -- that is, chunks of data that belong to a class\n(in this case, HTML::Element), a class that provides methods\n(routines) for accessing the pieces of data in each element,\nand otherwise doing things with elements. (See my article in\nTPJ#17 for a quick explanation of objects, the\n<small>POD</small> document &quot;perltoot&quot; for a\nlonger explanation, or Damian Conway&rsquo;s excellent book\n<i>Object-Oriented Perl</i> for the full story.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each\nHTML::Element object contains a number of pieces of\ndata:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* its element\nname (&quot;html&quot;, &quot;h1&quot;, etc., accessed as\n$element-&gt;tag)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* a list of\nelements (or text segments) that it contains, if any\n(accessed as $element-&gt;content_list or\n$element-&gt;content, depending on whether you want a list,\nor an arrayref)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* what element,\nif any, contains it (accessed as $element-&gt;parent)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* and any\n<small>SGML</small> attributes that the element has, such as\n&quot;lang=&quot;en-US&quot;&quot;,\n&quot;align=&quot;center&quot;&quot;, etc. (accessed as\n$element-&gt;attr(&rsquo;lang&rsquo;),\n$element-&gt;attr(&rsquo;center&rsquo;), etc.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, for\nexample, when HTML::TreeBuilder builds the tree for the\nabove <small>HTML</small> document source, the object for\nthe &quot;body&quot; element has these pieces of data:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* element name:\n&quot;body&quot; <br>\n* nodes it contains: <br>\nthe string &quot;I've got &quot; <br>\nthe object for the &quot;em&quot; element <br>\nthe string &quot;!&quot; <br>\n* its parent: <br>\nthe object for the &quot;html&quot; element <br>\n* bgcolor: &quot;#d010ff&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, once you\nhave this tree of objects, almost anything you&rsquo;d want\nto do with it starts with searching the tree for some bit of\ninformation in some element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Accessing a\npiece of information in, say, a hash of hashes of hashes, is\nstraightforward:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$password{'sean'}{'sburke1'}{'hpux'}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">because you\nknow that all data points in that structure are accessible\nwith that syntax, but with just different keys. Now, the\n&quot;em&quot; element in the above <small>HTML</small> tree\ndoes happen to be accessible as the root&rsquo;s child\n#1&rsquo;s child #1:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$root-&gt;content-&gt;[1]-&gt;content-&gt;[1]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But with trees,\nyou typically don&rsquo;t know the exact location (via\nindexes) of the data you&rsquo;re looking for. Instead,\nfinding what you want will typically involve searching\nthrough the tree, seeing if every node is the kind you want.\nSearching the whole tree is simple enough -- look at a given\nnode, and if it&rsquo;s not what you want, look at its\nchildren, and so on. HTML-Tree provides several methods that\ndo this for you, such as &quot;find_by_tag_name&quot;, which\nreturns the elements (or the first element, if called in\nscalar context) under a given node (typically the root)\nwhose tag name is whatever you specify.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nthat &quot;em&quot; node can be found as:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $that_em =\n$root-&gt;find_by_tag_name('em');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or as:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@ems =\n$root-&gt;find_by_tag_name('em'); <br>\n# will only have one element for this particular tree</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, given an\n<small>HTML</small> document of whatever structure and\ncomplexity, if you wanted to do something like change\nevery</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;em&gt;<i>stuff</i>&lt;/em&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">to</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;em\nclass=&quot;funky&quot;&gt; <b>&lt;b&gt;[-&lt;/b&gt;</b>\n<i>stuff</i> <b>&lt;b&gt;-]&lt;/b&gt;</b> &lt;/em&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the first step\nis to frame this operation in terms of what you&rsquo;re\ndoing to the tree. You&rsquo;re changing this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">em <br>\n| <br>\n...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">to this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">em <br>\n/ | \\ <br>\nb ... b <br>\n| | <br>\n&quot;[-&quot; &quot;-]&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In other words,\nyou&rsquo;re finding all elements whose tag name is\n&quot;em&quot;, setting its class attribute to\n&quot;funky&quot;, and adding one child to the start of its\ncontent list -- a new &quot;b&quot; element whose content is\nthe text string &quot;[-&quot; -- and one to the end of its\ncontent list -- a new &quot;b&quot; element whose content is\nthe text string &quot;-]&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once\nyou&rsquo;ve got it in these terms, it&rsquo;s just a matter\nof running to the HTML::Element documentation, and coding\nthis up with calls to the appropriate methods, like so:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTML::Element 1.53; <br>\nuse HTML::TreeBuilder 2.96; <br>\n# Build the tree by parsing the document <br>\nmy $root = HTML::TreeBuilder-&gt;new; <br>\n$root-&gt;parse_file('whatever.html'); # source file <br>\n# Now make new nodes where needed <br>\nforeach my $em ($root-&gt;find_by_tag_name('em')) { <br>\n$em-&gt;attr('class', 'funky'); # Set that attribute <br>\n# Make the two new B nodes <br>\nmy $new1 = HTML::Element-&gt;new('b'); <br>\nmy $new2 = HTML::Element-&gt;new('b'); <br>\n# Give them content (they have none at first) <br>\n$new1-&gt;push_content('[-'); <br>\n$new2-&gt;push_content('-]'); <br>\n# And put 'em in place! <br>\n$em-&gt;unshift_content($new1); <br>\n$em-&gt;push_content($new2); <br>\n} <br>\nprint <br>\n&quot;&lt;!-- Looky see what I did! --&gt;\\n&quot;, <br>\n$root-&gt;as_HTML(), &quot;\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The class\nHTML::Element provides just about every method I can image\nyou needing, for manipulating trees made of HTML::Element\nobjects. (And what it doesn&rsquo;t directly provide, it\nwill give you the components to build it with.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Building\nYour Own Trees</b> <br>\nTheoretically, any tree is pretty much like any other tree,\nso you could use HTML::Element for anything you&rsquo;d ever\nwant to do with tree-arranged objects. However, as its name\nimplies, HTML::Element is basically <i>for</i>\n<small>HTML</small> elements; it has lots of features that\nmake sense only for <small>HTML</small> elements (like the\nidea that every element must have a tag-name). And it lacks\nsome features that might be useful for general applications\n-- such as any sort of checking to make sure that\nyou&rsquo;re not trying to arrange objects in a non-treelike\nway. For a general-purpose tree class that does have such\nfeatures, you can use Tree::DAG_Node, also available from\n<small>CPAN.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if\nyour task is simple enough, you might find it overkill to\nbother using Tree::DAG_Node. And, in any case, I find that\nthe best way to learn how something works is to implement it\n(or something like it, but simpler) yourself. So I&rsquo;ll\nhere discuss how you&rsquo;d implement a tree structure,\n<i>without</i> using any of the existing classes for tree\nnodes.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Implementation:\nGame Trees for Alak</b> <br>\nSuppose that the task at hand is to write a program that can\nplay against a human opponent at a strategic board game (as\nopposed to a board game where there&rsquo;s an element of\nchance). For most such games, a &quot;game tree&quot; is an\nessential part of the program (as I will argue, below), and\nthis will be our test case for implementing a tree structure\nfrom scratch.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For sake of\nsimplicity, our game is not chess or backgammon, but instead\na much simpler game called Alak. Alak was invented by the\nmathematician A. K. Dewdney, and described in his 1984 book\n<i>Planiverse</i>. The rules of Alak are simple:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote:\nActually, I&rsquo;m describing only my interpretation of the\nrules Dewdney describes in <i>Planiverse</i>. Many other\ninterpretations are possible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* Alak is a\ntwo-player game played on a one-dimensional board with\neleven slots on it. Each slot can hold at most one piece at\na time. There&rsquo;s two kinds of pieces, which I represent\nhere as &quot;x&quot; and &quot;o&quot; -- x&rsquo;s belong\nto one player (called X), o&rsquo;s to the other (called\nO).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* The initial\nconfiguration of the board is:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">xxxx___oooo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For sake of the\narticle, the slots are numbered from 1 (on the left) to 11\n(on the right), and X always has the first move.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* The players\ntake turns moving. At each turn, each player can move only\none piece, once. (This unlike checkers, where you move one\npiece per move but get to keep moving it if you jump an your\nopponent&rsquo;s piece.) A player cannot pass up on his\nturn. A player can move any one of his pieces to the next\nunoccupied slot to its right or left, which may involve\njumping over occupied slots. A player cannot move a piece\noff the side of the board.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* If a move\ncreates a pattern where the opponent&rsquo;s pieces are\nsurrounded, on both sides, by two pieces of the\nmover&rsquo;s color (with no intervening unoccupied blank\nslot), then those surrounded pieces are removed from the\nboard.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* The goal of\nthe game is to remove all of your opponent&rsquo;s pieces,\nat which point the game ends. Removing all-but-one ends the\ngame as well, since the opponent can&rsquo;t surround you\nwith one piece, and so will always lose within a few moves\nanyway.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider, then,\nthis rather short game where X starts:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xxxx___oooo\n<br>\n^ Move 1: X moves from 3 (shown with caret) to 5 <br>\n(Note that any of X's pieces could move, but <br>\nthat the only place they could move to is 5.) <br>\nxx_xx__oooo <br>\n^ Move 2: O moves from 9 to 7. <br>\nxx_xx_oo_oo <br>\n^ Move 3: X moves from 4 to 6. <br>\nxx__xxoo_oo <br>\n^ Move 4: O (stupidly) moves from 10 to 9. <br>\nxx__xxooo_o <br>\n^ Move 5: X moves from 5 to 10, making the board <br>\n&quot;xx___xoooxo&quot;. The three o's that X just <br>\nsurrounded are removed. <br>\nxx___x___xo <br>\nO has only one piece, so has lost.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, move 4\ncould have gone quite the other way:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xx__xxoo_oo\n<br>\nMove 4: O moves from 8 to 4, making the board <br>\n&quot;xx_oxxo__oo&quot;. The surrounded x's are removed.\n<br>\nxx_o__o__oo <br>\n^ Move 5: X moves from 1 to 2. <br>\n_xxo__o__oo <br>\n^ Move 6: O moves from 7 to 6. <br>\n_xxo_o___oo <br>\n^ Move 7: X moves from 2 to 5, removing the o at 4. <br>\n__x_xo___oo <br>\n...and so on.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To teach a\ncomputer program to play Alak (as player X, say), it needs\nto be able to look at the configuration of the board, figure\nout what moves it can make, and weigh the benefit or costs,\nimmediate or eventual, of those moves.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So consider the\nboard from just before move 3, and figure all the possible\nmoves X could make. X has pieces in slots 1, 2, 4, and 5.\nThe leftmost two x&rsquo;s (at 1 and 2) are up against the\nend of the board, so they can move only right. The other two\nx&rsquo;s (at 4 and 5) can move either right or left:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting board:\nxx_xx_oo_oo <br>\nmoving 1 to 3 gives _xxxx_oo_oo <br>\nmoving 2 to 3 gives x_xxx_oo_oo <br>\nmoving 4 to 3 gives xxx_x_oo_oo <br>\nmoving 5 to 3 gives xxxx__oo_oo <br>\nmoving 4 to 6 gives xx__xxoo_oo <br>\nmoving 5 to 6 gives xx_x_xoo_oo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For the\ncomputer to decide which of these is the best move to make,\nit needs to quantify the benefit of these moves as a number\n-- call that the &quot;payoff&quot;. The payoff of a move\ncan be figured as just the number of x pieces removed by the\nmost recent move, minus the number of o pieces removed by\nthe most recent move. (It so happens that the rules of the\ngame mean that no move can delete both o&rsquo;s and\nx&rsquo;s, but the formula still applies.) Since none of\nthese moves removed any pieces, all these moves have the\nsame immediate payoff: 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, we could\nrace ahead and write an Alak-playing program that could use\nthe immediate payoff to decide which is the best move to\nmake. And when there&rsquo;s more than one best move (as\nhere, where all the moves are equally good), it could choose\nrandomly between the good alternatives. This strategy is\nsimple to implement; but it makes for a very dumb program.\nConsider what O&rsquo;s response to each of the potential\nmoves (above) could be. Nothing immediately suggests itself\nfor the first four possibilities (X having moved something\nto position 3), but either of the last two (illustrated\nbelow) are pretty perilous, because in either case O has the\nobvious option (which he would be foolish to pass up) of\nremoving x&rsquo;s from the board:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xx_xx_oo_oo\n<br>\n^ X moves 4 to 6. <br>\nxx__xxoo_oo <br>\n^ O moves 8 to 4, giving &quot;xx_oxxo__oo&quot;. The two\n<br>\nsurrounded x's are removed. <br>\nxx_o__o__oo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xx_xx_oo_oo\n<br>\n^ X moves 5 to 6. <br>\nxx_x_xoo_oo <br>\n^ O moves 8 to 5, giving &quot;xx_xoxo__oo&quot;. The one\n<br>\nsurrounded x is removed. <br>\nxx_xo_o__oo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Both\ncontingencies are quite bad for X -- but this is not\ncaptured by the fact that they start out with X thinking his\nmove will be harmless, having a payoff of zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So what&rsquo;s\nneeded is for X to think <i>more</i> than one step ahead --\nto consider not merely what it can do in this move, and what\nthe payoff is, but to consider what O might do in response,\nand the payoff of those potential moves, and so on with\nX&rsquo;s possible responses to those cases could be. All\nthese possibilities form a game tree -- a tree where each\nnode is a board, and its children are successors of that\nnode -- i.e., the boards that could result from every move\npossible, given the parent&rsquo;s board.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But how to\nrepresent the tree, and how to represent the nodes?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Well, consider\nthat a node holds several pieces of data:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">1) the\nconfiguration of the board, which, being nice and simple and\none-dimensional, can be stored as just a string, like\n&quot;xx_xx_oo_oo&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">2) whose turn\nit is, X or O. (Or: who moved last, from which we can figure\nwhose turn it is).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">3) the\nsuccessors (child nodes).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">4) the\nimmediate payoff of having moved to this board position from\nits predecessor (parent node).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">5) and what\nmove gets us from our predecessor node to here. (Granted,\nknowing the board configuration before and after the move,\nit&rsquo;s easy to figure out the move; but it&rsquo;s\neasier still to store it as one is figuring out a\nnode&rsquo;s successors.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">6) whatever\nelse we might want to add later.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These could be\nstored equally well in an array or in a hash, but it&rsquo;s\nmy experience that hashes are best for cases where you have\nmore than just two or three bits of data, or especially when\nyou might need to add new bits of data. Moreover, hash key\nnames are mnemonic --\n$node-&gt;{&rsquo;last_move_payoff&rsquo;} is plain as day,\nwhereas it&rsquo;s not so easy having to remember with an\narray that $node-&gt;[3] is where you decided to keep the\npayoff.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: Of\ncourse, there are ways around that problem: just swear\nyou&rsquo;ll never use a real numeric index to access data\nin the array, and instead use constants with mnemonic\nnames:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">use strict;\n<br>\nuse constant idx_PAYOFF =&gt; 3; <br>\n... <br>\n$n-&gt;[idx_PAYOFF]</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Or use a\npseudohash. But I prefer to keep it simple, and use a\nhash.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">These are,\nincidentally, the same arguments that people weigh when\ntrying to decide whether their object-oriented modules\nshould be based on blessed hashes, blessed arrays, or what.\nEssentially the only difference here is that we&rsquo;re not\nblessing our nodes or talking in terms of classes and\nmethods.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">[end\nfootnote]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, we might as\nwell represent nodes like so:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$node = { #\nhashref <br>\n'board' =&gt; ...board string, e.g., &quot;xx_x_xoo_oo&quot;\n<br>\n'last_move_payoff' =&gt; ...payoff of the move <br>\nthat got us here. <br>\n'last_move_from' =&gt; ...the start... <br>\n'last_move_to' =&gt; ...and end point of the move <br>\nthat got us here. E.g., 5 and 6, <br>\nrepresenting a move from 5 to 6. <br>\n'whose_turn' =&gt; ...whose move it then becomes. <br>\njust an 'x' or 'o'. <br>\n'successors' =&gt; ...the successors <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that we\ncould have a field called something like\n&rsquo;last_move_who&rsquo; to denote who last moved, but\nsince turns in Alak always alternate (and no-one can pass),\nstoring whose move it is now <i>and</i> who last moved is\nredundant -- if X last moved, it&rsquo;s O turn now, and\nvice versa. I chose to have a &rsquo;whose_turn&rsquo; field\ninstead of a &rsquo;last_move_who&rsquo;, but it\ndoesn&rsquo;t really matter. Either way, we&rsquo;ll end up\ninferring one from the other at several points in the\nprogram.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When we want to\nstore the successors of a node, should we use an array or a\nhash? On the one hand, the successors to $node aren&rsquo;t\nessentially ordered, so there&rsquo;s no reason to use an\narray per se; on the other hand, if we used a hash, with\nsuccessor nodes as values, we don&rsquo;t have anything\nparticularly meaningful to use as keys. (And we can&rsquo;t\nuse the successors themselves as keys, since the nodes are\nreferred to by hash references, and you can&rsquo;t use a\nreference as a hash key.) Given no particularly compelling\nreason to do otherwise, I choose to just use an array to\nstore all a node&rsquo;s successors, although the order is\nnever actually used for anything:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$node = { <br>\n... <br>\n'successors' =&gt; [ ...nodes... ], <br>\n... <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In any case,\nnow that we&rsquo;ve settled on what should be in a node,\nlet&rsquo;s make a little sample tree out of a few nodes and\nsee what we can do with it:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># Board just\nbefore move 3 in above game <br>\nmy $n0 = { <br>\n'board' =&gt; 'xx_xx_oo_oo', <br>\n'last_move_payoff' =&gt; 0, <br>\n'last_move_from' =&gt; 9, <br>\n'last_move_to' =&gt; 7, <br>\n'whose_turn' =&gt; 'x', <br>\n'successors' =&gt; [], <br>\n}; <br>\n# And, for now, just two of the successors: <br>\n# X moves 4 to 6, giving xx__xxoo_oo <br>\nmy $n1 = { <br>\n'board' =&gt; 'xx__xxoo_oo', <br>\n'last_move_payoff' =&gt; 0, <br>\n'last_move_from' =&gt; 4, <br>\n'last_move_to' =&gt; 6, <br>\n'whose_turn' =&gt; 'o', <br>\n'successors' =&gt; [], <br>\n}; <br>\n# or X moves 5 to 6, giving xx_x_xoo_oo <br>\nmy $n2 = { <br>\n'board' =&gt; 'xx_x_xoo_oo', <br>\n'last_move_payoff' =&gt; 0, <br>\n'last_move_from' =&gt; 5, <br>\n'last_move_to' =&gt; 6, <br>\n'whose_turn' =&gt; 'o', <br>\n'successors' =&gt; [], <br>\n}; <br>\n# Now connect them... <br>\npush @{$n0-&gt;{'successors'}}, $n1, $n2;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Digression:\nLinks to Parents</b> <br>\nIn comparing what we store in an Alak game tree node to what\nHTML::Element stores in <small>HTML</small> element nodes,\nyou&rsquo;ll note one big difference: every HTML::Element\nnode contains a link to its parent, whereas we don&rsquo;t\nhave our Alak nodes keeping a link to theirs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The reason this\ncan be an important difference is because it can affect how\nPerl knows when you&rsquo;re not using pieces of memory\nanymore. Consider the tree we just built, above:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">node 0 <br>\n/ \\ <br>\nnode 1 node 2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There&rsquo;s\ntwo ways Perl knows you&rsquo;re using a piece of memory: 1)\nit&rsquo;s memory that belongs directly to a variable (i.e.,\nis necessary to hold that variable&rsquo;s value, or\nvalue<i>s</i> in the case of a hash or array), or 2)\nit&rsquo;s a piece of memory that something holds a\nreference to. In the above code, Perl knows that the hash\nfor node 0 (for board &quot;xx_xx_oo_oo&quot;) is in use\nbecause something (namely, the variable $n0) holds a\nreference to it. Now, even if you followed the above code\nwith this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$n1 = $n2 =\n'whatever';</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">to make your\nvariables $n1 and $n2 stop holding references to the hashes\nfor the two successors of node 0, Perl would still know that\nthose hashes are still in use, because node 0&rsquo;s\nsuccessors array holds a reference to those hashes. And Perl\nknows that node 0 is still in use because something still\nholds a reference to it. Now, if you added:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $root =\n$n0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This would\nchange nothing -- there&rsquo;s just be <i>two</i> things\nholding a reference to the node 0 hash, which in turn holds\na reference to the node 1 and node 2 hashes. And if you then\nadded:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$n0 =\n'stuff';</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">still nothing\nwould change, because something ($root) still holds a\nreference to the node 0 hash. But once <i>nothing</i> holds\na reference to the node 0 hash, Perl will know it can\ndestroy that hash (and reclaim the memory for later use,\nsay), and once it does that, nothing will hold a reference\nto the node 1 or the node 2 hashes, and those will be\ndestroyed too.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But consider if\nthe node 1 and node 2 hashes each had an attribute\n&quot;parent&quot; (or &quot;predecessor&quot;) that held a\nreference to node 0. If your program stopped holding a\nreference to the node 0 hash, Perl could <i>not</i> then say\nthat <i>nothing</i> holds a reference to node 0 -- because\nnode 1 and node 2 still do. So, the memory for nodes 0, 1,\nand 2 would never get reclaimed (until your program ended,\nat which point Perl destroys <i>everything</i>). If your\nprogram grew and discarded lots of nodes in the game tree,\nbut didn&rsquo;t let Perl know it could reclaim their\nmemory, your program could grow to use immense amounts of\nmemory -- never a nice thing to have happen. There&rsquo;s\nthree ways around this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">1) When\nyou&rsquo;re finished with a node, delete the reference each\nof its children have to it (in this case, deleting\n$n1-&gt;{&rsquo;parent&rsquo;}, say). When you&rsquo;re\nfinished with a whole tree, just go through the whole tree\nerasing links that children have to their children.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">2) Reconsider\nwhether you really need to have each node hold a reference\nto its parent. Just not having those links will avoid the\nwhole problem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">3) use the\nWeakRef module with Perl 5.6 or later. This allows you to\n&quot;weaken&quot; some references (like the references that\nnode 1 and 2 could hold to their parent) so that they\ndon&rsquo;t count when Perl goes asking whether anything\nholds a reference to a given piece of memory. This wonderful\nnew module eliminates the headaches that can often crop up\nwith either of the two previous methods.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It so happens\nthat our Alak program is simple enough that we don&rsquo;t\nneed for our nodes to have links to their parents, so the\nsecond solution is fine. But in a more advanced program, the\nfirst or third solutions might be unavoidable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Recursively\nPrinting the Tree</b> <br>\nI don&rsquo;t like working blind -- if I have any kind of a\ncomplex data structure in memory for a program I&rsquo;m\nworking on, the first thing I do is write something that can\ndump that structure to the screen so I can make sure that\nwhat I <i>think</i> is in memory really <i>is</i>\nwhat&rsquo;s in memory. Now, I could just use the\n&quot;x&quot; pretty-printer command in Perl&rsquo;s\ninteractive debugger, or I could have the program use the\n&quot;Data::Dumper&quot; module. But in this case, I think\nthe output from those is rather too verbose. Once we have\ntrees with dozens of nodes in them, we&rsquo;ll really want\na dump of the tree to be as concise as possible, hopefully\njust one line per node. What I&rsquo;d like is something\nthat can print $n0 and its successors (see above) as\nsomething like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xx_xx_oo_oo (O\nmoved 9 to 7, 0 payoff) <br>\nxx__xxoo_oo (X moved 4 to 6, 0 payoff) <br>\nxx_x_xoo_oo (X moved 5 to 6, 0 payoff)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A subroutine to\nprint a line for a given node, and then do that again for\neach successor, would look something like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub dump_tree {\n<br>\nmy $n = $_[0]; # &quot;n&quot; is for node <br>\nprint <br>\n...something expressing $n'n content... <br>\nforeach my $s (@{$n-&gt;{'successors'}}) { <br>\n# &quot;s for successor <br>\ndump($s); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And we could\njust start that out with a call to\n&quot;dump_tree($n0)&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since this\nroutine...</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: I\nfirst wrote this routine starting out with &quot;sub dump\n{&quot;. But when I tried actually calling\n&quot;dump($n0)&quot;, Perl would dump core! Imagine my\nshock when I discovered that this is absolutely to be\nexpected -- Perl provides a built-in function called\n&quot;dump&quot;, the purpose of which is to, yes, make Perl\ndump core. Calling our routine &quot;dump_tree&quot; instead\nof &quot;dump&quot; neatly avoids that problem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...does its\nwork (dumping the subtree at and under the given node) by\ncalling itself, it&rsquo;s <b>recursive</b>. However,\nthere&rsquo;s a special term for this kind of recursion\nacross a tree: traversal. To <b>traverse</b> a tree means to\ndo something to a node, and to traverse its children.\nThere&rsquo;s two prototypical ways to do this, depending on\nwhat happens when:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">traversing X in\npre-order: <br>\n* do something to X <br>\n* then traverse X's children <br>\ntraversing X in post-order: <br>\n* traverse X's children <br>\n* then do something to X</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Dumping the\ntree to the screen the way we want it happens to be a matter\nof pre-order traversal, since the thing we do (print a\ndescription of the node) happens before we recurse into the\nsuccessors.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When we try\nwriting the &quot;print&quot; statement for our above\n&quot;dump_tree&quot;, we can get something like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub dump_tree {\n<br>\nmy $n = $_[0]; <br>\n# &quot;xx_xx_oo_oo (O moved 9 to 7, 0 payoff)&quot; <br>\nprint <br>\n$n-&gt;{'board'}, &quot; (&quot;, <br>\n($n-&gt;{'whose_turn'} eq 'o' ? 'X' : 'O'), <br>\n# Infer who last moved from whose turn it is now. <br>\n&quot; moved &quot;, $n-&gt;{'last_move_from'}, <br>\n&quot; to &quot;, $n-&gt;{'last_move_to'}, <br>\n&quot;, &quot;, $n-&gt;{'last_move_payoff'}, <br>\n&quot; payoff)\\n&quot;, <br>\n; <br>\nforeach my $s (@{$n-&gt;{'successors'}}) { <br>\ndump_tree($s); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If we run this\non $n0 from above, we get this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xx_xx_oo_oo (O\nmoved 9 to 7, 0 payoff) <br>\nxx__xxoo_oo (X moved 4 to 6, 0 payoff) <br>\nxx_x_xoo_oo (X moved 5 to 6, 0 payoff)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each line on\nits own is fine, but we forget to allow for indenting, and\nwithout that we can&rsquo;t tell what&rsquo;s a child of\nwhat. (Imagine if the first successor had successors of its\nown -- you wouldn&rsquo;t be able to tell if it were a\nchild, or a sibling.) To get indenting, we&rsquo;ll need to\nhave the instances of the &quot;dump_tree&quot; routine know\nhow far down in the tree they&rsquo;re being called, by\npassing a depth parameter between them:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub dump_tree {\n<br>\nmy $n = $_[0]; <br>\nmy $depth = $_[1]; <br>\n$depth = 0 unless defined $depth; <br>\nprint <br>\n&quot; &quot; x $depth, <br>\n...stuff... <br>\nforeach my $s (@{$n-&gt;{'successors'}}) { <br>\ndump_tree($s, $depth + 1); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When we call\n&quot;dump_tree($n0)&quot;, $depth (from $_[1]) is\nundefined, so gets set to 0, which translates into an\nindenting of no spaces. But when &quot;dump_tree&quot;\ninvokes itself on $n0&rsquo;s children, those instances see\n$depth + 1 as their $_[1], giving appropriate indenting.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote:\nPassing values around between different invocations of a\nrecursive routine, as shown, is a decent way to share the\ndata. Another way to share the data is by keeping it in a\nglobal variable, like $Depth, initially set to 0. Each time\n&quot;dump_tree&quot; is about to recurse, it must\n&quot;++$Depth&quot;, and when it&rsquo;s back, it must\n&quot;--$Depth&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Or, if the\nreader is familiar with closures, consider this\napproach:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sub dump_tree {\n<br>\n# A wrapper around calls to a recursive closure: <br>\nmy $start_node = $_[0]; <br>\nmy $depth = 0; <br>\n# to be shared across calls to $recursor. <br>\nmy $recursor; <br>\n$recursor = sub { <br>\nmy $n = $_[0]; <br>\nprint &quot; &quot; x $depth, <br>\n...stuff... <br>\n++$depth; <br>\nforeach my $s (@{$n-&gt;{'successors'}}) { <br>\n$recursor-&gt;($s); <br>\n} <br>\n--$depth; <br>\n} <br>\n$recursor-&gt;($start_node); # start recursing <br>\nundef $recursor; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The reader with\nan advanced understanding of Perl&rsquo;s\nreference-count-based garbage collection is invited to\nconsider why it is currently necessary to undef $recursor\n(or otherwise change its value) after all recursion is\ndone.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The reader\nwhose mind is perverse in other ways is invited to consider\nhow (or when!) passing a depth parameter around is\nunnecessary because of information that Perl&rsquo;s\ncaller(N) function reports!</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">[end\nfootnote]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Growing the\nTree</b> <br>\nOur &quot;dump_tree&quot; routine works fine for the sample\ntree we&rsquo;ve got, so now we should get the program\nworking on making its own trees, starting from a given\nboard.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In\n&quot;Games::Alak&quot; (the CPAN-released version of Alak\nthat uses essentially the same code that we&rsquo;re\ncurrently discussing the tree-related parts of), there is a\nroutine called &quot;figure_successors&quot; that, given one\nchildless node, will figure out all its possible successors.\nThat is, it looks at the current board, looks at every piece\nbelonging to the player whose turn it is, and considers the\neffect of moving each piece every possible way -- notably,\nit figures out the immediate payoff, and if that move would\nend the game, it notes that by setting an\n&quot;endgame&quot; entry in that node&rsquo;s hash. (That\nway, we know that that&rsquo;s a node that\n<i>can&rsquo;t</i> have successors.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the code for\n&quot;Games::Alak&quot;, &quot;figure_successors&quot; does\nall these things, in a rather straightforward way. I\nwon&rsquo;t walk you through the details of the\n&quot;figure_successors&quot; code I&rsquo;ve written, since\nthe code has nothing much to do with trees, and is all just\nimplementation of the Alak rules for what can move where,\nwith what result. Especially interested readers can puzzle\nover that part of code in the source listing in the archive\nfrom <small>CPAN,</small> but others can just assume that it\nworks as described above.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But consider\nthat &quot;figure_successors&quot;, regardless of its inner\nworkings, does not grow the <i>tree</i>; it only makes one\nset of successors for one node at a time. It has to be up to\na different routine to call &quot;figure_successors&quot;,\nand to keep applying it as needed, in order to make a nice\nbig tree that our game-playing program can base its\ndecisions on.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, we could\ndo this by just starting from one node, applying\n&quot;figure_successors&quot; to it, then applying\n&quot;figure_successors&quot; on all the resulting children,\nand so on:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub grow { #\nJust a first attempt at this! <br>\nmy $n = $_[0]; <br>\nfigure_successors($n); <br>\nunless <br>\n@{$n-&gt;{'successors'}} <br>\n# already has successors. <br>\nor $n-&gt;{'endgame'} <br>\n# can't have successors. <br>\n} <br>\nforeach my $s (@{$n-&gt;{'successors'}}) { <br>\ngrow($s); # recurse <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you have a\ngame tree for tic-tac-toe, and you grow it without\nlimitation (as above), you will soon enough have a fully\n&quot;solved&quot; tree, where every node that <i>can</i>\nhave successors <i>does</i>, and all the leaves of the tree\nare <i>all</i> the possible endgames (where, in each case,\nthe board is filled). But a game of Alak is different from\ntic-tac-toe, because it can, in theory, go on forever. For\nexample, the following sequence of moves is quite\npossible:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xxxx___oooo\n<br>\nxxx_x__oooo <br>\nxxx_x_o_ooo <br>\nxxxx__o_ooo (x moved back) <br>\nxxxx___oooo (o moved back) <br>\n...repeat forever...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So if you tried\nusing our above attempt at a &quot;grow&quot; routine, Perl\nwould happily start trying to construct an infinitely deep\ntree, containing an infinite number of nodes, consuming an\ninfinite amount of memory, and requiring an infinite amount\nof time. As the old saying goes: &quot;You can&rsquo;t have\neverything -- where would you put it?&quot; So we have to\nplace limits on how much we&rsquo;ll grow the tree.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There&rsquo;s\nmore than one way to do this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">1. We could\ngrow the tree until we hit some limit on the number of nodes\nwe&rsquo;ll allow in the tree.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">2. We could\ngrow the tree until we hit some limit on the amount of time\nwe&rsquo;re willing to spend.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">3. Or we could\ngrow the tree until it is fully fleshed out to a certain\ndepth.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since we\nalready know to track depth (as we did in writing\n&quot;dump_tree&quot;), we&rsquo;ll do it that way, the\nthird way. The implementation for that third approach is\nalso pretty straightforward:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$Max_depth = 3;\n<br>\nsub grow { <br>\nmy $n = $_[0]; <br>\nmy $depth = $_[1] || 0; <br>\nfigure_successors($n) <br>\nunless <br>\n$depth &gt;= $Max_depth <br>\nor @{$n-&gt;{'successors'}} <br>\nor $n-&gt;{'endgame'} <br>\n} <br>\nforeach my $s (@{$n-&gt;{'successors'}}) { <br>\ngrow($s, $depth + 1); <br>\n} <br>\n# If we're at $Max_depth, then figure_successors <br>\n# didn't get called, so there's no successors <br>\n# to recurse under -- that's what stops recursion. <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If we start\nfrom a single node (whether it&rsquo;s a node for the\nstarting board &quot;xxxx___oooo&quot;, or for whatever\nboard the computer is faced with), set $Max_depth to 4, and\napply &quot;grow&quot; to it, it will grow the tree to\ninclude several hundred nodes.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: If at\neach move there are four pieces that can move, and they can\neach move right or left, the &quot;branching factor&quot; of\nthe tree is eight, giving a tree with 1 (depth 0) + 8 (depth\n1) + 8 ** 2 + 8 ** 3 + 8 ** 4 = 4681 nodes in it. But, in\npractice, not all pieces can move in both directions (none\nof the x pieces in &quot;xxxx___oooo&quot; can move left,\nfor example), and there may be fewer than four pieces, if\nsome were lost. For example, there are 801 nodes in a tree\nof depth four starting from &quot;xxxx___oooo&quot;,\nsuggesting an average branching factor of about five (801 **\n(1/4) is about 5.3), not eight.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">What we need to\nderive from that tree is the information about what are the\nbest moves for X. The simplest way to consider the payoff of\ndifferent successors is to just average them -- but what we\naverage isn&rsquo;t always their immediate payoffs (because\nthat&rsquo;d leave us using only one generation of\ninformation), but the average payoff of <i>their</i>\nsuccessors, if any. We can formalize this as:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To figure a\nnode's average payoff: <br>\nIf the node has successors: <br>\nFigure each successor's average payoff. <br>\nMy average payoff is the average of theirs. <br>\nOtherwise: <br>\nMy average payoff is my immediate payoff.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since this\ninvolves recursing into the successors <i>before</i> doing\nanything with the current node, this will traverse the tree\n<i>in post-order</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">We could work\nthat up as a routine of its own, and apply that to the tree\nafter we&rsquo;ve applied &quot;grow&quot; to it. But since\nwe&rsquo;d never grow the tree without also figuring the\naverage benefit, we might as well make that figuring part of\nthe &quot;grow&quot; routine itself:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$Max_depth = 3;\n<br>\nsub grow { <br>\nmy $n = $_[0]; <br>\nmy $depth = $_[1] || 0; <br>\nfigure_successors($n); <br>\nunless <br>\n$depth &gt;= $Max_depth <br>\nor @{$n-&gt;{'successors'}} <br>\nor $n-&gt;{'endgame'} <br>\n} <br>\nif(@{$n-&gt;{'successors'}}) { <br>\nmy $a_payoff_sum = 0; <br>\nforeach my $s (@{$n-&gt;{'successors'}}) { <br>\ngrow($s, $depth + 1); # RECURSE <br>\n$a_payoff_sum += $s-&gt;{'average_payoff'}; <br>\n} <br>\n$n-&gt;{'average_payoff'} <br>\n= $a_payoff_sum / @{$n-&gt;{'successors'}}; <br>\n} else { <br>\n$n-&gt;{'average_payoff'} <br>\n= $n-&gt;{'last_move_payoff'}; <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, by time\n&quot;grow&quot; has applied to a node (wherever in the tree\nit is), it will have figured successors if possible (which,\nin turn, sets &quot;last_move_payoff&quot; for each node it\ncreates), and will have set &quot;average_benefit&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Beyond this,\nall that&rsquo;s needed is to start the board out with a\nroot note of &quot;xxxx___oooo&quot;, and have the computer\n(X) take turns with the user (O) until someone wins.\nWhenever it&rsquo;s O&rsquo;s turn, &quot;Games::Alak&quot;\npresents a prompt to the user, letting him know the state of\nthe current board, and asking what move he selects. When\nit&rsquo;s X&rsquo;s turn, the computer grows the game tree\nas necessary (using just the &quot;grow&quot; routine from\nabove), then selects the move with the highest average\npayoff (or one of the highest, in case of a tie).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In either case,\n&quot;selecting&quot; a move means just setting that\nmove&rsquo;s node as the new root of the program&rsquo;s\ngame tree. Its sibling nodes and their descendants (the\nboards that <i>didn&rsquo;t</i> get selected) and its parent\nnode will be erased from memory, since they will no longer\nbe in use (as Perl can tell by the fact that nothing holds\nreferences to them anymore).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The interface\ncode in &quot;Games::Alak&quot; (the code that prompts the\nuser for his move) actually supports quite a few options\nbesides just moving -- including dumping the game tree to a\nspecified depth (using a slightly fancier version of\n&quot;dump_tree&quot;, above), resetting the game, changing\n$Max_depth in the middle of the game, and quitting the game.\nLike &quot;figure_successors&quot;, it&rsquo;s a bit too\nlong to print here, but interested users are welcome to\nperuse (and freely modify) the code, as well as to enjoy\njust playing the game.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, in\npractice, there&rsquo;s more to game trees than this: for\ngames with a larger branching factor than Alak has (which is\nmost!), game trees of depth four or larger would contain too\nmany nodes to be manageable, most of those nodes being\nstrategically quite uninteresting for either player; dealing\nwith game trees specifically is therefore a matter of\nrecognizing uninteresting contingencies and not bothering to\ngrow the tree under them.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: For\nexample, to choose a straightforward case: if O has a choice\nbetween moves that put him in immediate danger of X winning\nand moves that don&rsquo;t, then O won&rsquo;t ever choose\nthe dangerous moves (and if he does, the computer will know\nenough to end the game), so there&rsquo;s no point in\ngrowing the tree any further beneath those nodes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But this sample\nimplementation should illustrate the basics of how to build\nand manipulate a simple tree structure in memory. And once\nyou&rsquo;ve understood the basics of tree storage here, you\nshould be ready to better understand the complexities and\npeculiarities of other systems for creating, accessing, and\nchanging trees, including Tree::DAG_Node, HTML::Element,\n<small>XML::DOM,</small> or related formalisms like XPath\nand <small>XSL.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>[end body of\narticle]</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>[Author\nCredit]</b> <br>\nSean M. Burke (&quot;sburke@cpan.org&quot;) is a\ntree-dwelling hominid.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>References</b>\n<br>\nDewdney, A[lexander] K[eewatin]. 1984. <i>Planiverse:\nComputer Contact with a Two-Dimensional World.</i> Poseidon\nPress, New York.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Knuth, Donald\nErvin. 1997. <i>Art of Computer Programming, Volume 1, Third\nEdition: Fundamental Algorithms</i>. Addison-Wesley,\nReading, <small>MA.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Wirth, Niklaus.\n1976. <i>Algorithms + Data Structures = Programs</i>\nPrentice-Hall, Englewood Cliffs, <small>NJ.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Worth, Stan and\nAllman Sheldon. Circa 1967. <i>George of the Jungle</i>\ntheme. [music by Jay Ward.]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Wirth&rsquo;s\nclassic, currently and lamentably out of print, has a good\nsection on trees. I find it clearer than Knuth&rsquo;s (if\nnot quite as encyclopedic), probably because Wirth&rsquo;s\nexample code is in a block-structured high-level language\n(basically Pascal), instead of in assembler (\n<small>MIX</small> ). I believe the book was re-issued in\nthe 1980s under the titles <i>Algorithms and Data\nStructures</i> and, in a German edition, <i>Algorithmen und\nDatenstrukturen</i>. Cheap copies of these editions should\nbe available through used book services such as\n&quot;abebooks.com&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Worth&rsquo;s\nclassic, however, is available on the soundtrack to the 1997\n<i>George of the Jungle</i> movie, as performed by The\nPresidents of the United States of America.</p>\n\n<h2>BACK\n<a name=\"BACK\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Return to the\nHTML::Tree docs.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#Trees\">Trees</a>","<a href=\"#BACK\">BACK</a>"],"level":3}