{"name":"io::wraptie","description":"IO::WrapTie -\nwrap tieable objects in IO::Handle interface\n\nThis is\ncurrently Alpha code, released for comments. <br>\nPlease give me your feedback!","body":"\n\n<h1 align=\"center\">IO::WrapTie</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::WrapTie -\nwrap tieable objects in IO::Handle interface</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is\ncurrently Alpha code, released for comments. <br>\nPlease give me your feedback!</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">First of all,\nyou&rsquo;ll need <b>tie()</b>, so:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">require\n5.004;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Function\ninterface (experimental).</i> Use this with any existing\nclass...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIO::WrapTie; <br>\nuse FooHandle; ### implements TIEHANDLE interface <br>\n### Suppose we want a &quot;FooHandle-&gt;new(&amp;FOO_RDWR,\n2)&quot;. <br>\n### We can instead say... <br>\n$FH = wraptie('FooHandle', &amp;FOO_RDWR, 2); <br>\n### Now we can use... <br>\nprint $FH &quot;Hello, &quot;; ### traditional operator\nsyntax... <br>\n$FH-&gt;print(&quot;world!\\n&quot;); ### ...and OO syntax as\nwell!</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i><small>OO</small>\ninterface (preferred).</i> You can inherit from the\nIO::WrapTie::Slave mixin to get a nifty\n&quot;new_tie()&quot; constructor...</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#------------------------------\n<br>\npackage FooHandle; ### a class which can TIEHANDLE <br>\nuse IO::WrapTie; <br>\n@ISA = qw(IO::WrapTie::Slave); ### inherit new_tie() <br>\n... <br>\n#------------------------------ <br>\npackage main; <br>\n$FH = FooHandle-&gt;new_tie(&amp;FOO_RDWR, 2); ### $FH is an\nIO::WrapTie::Master <br>\nprint $FH &quot;Hello, &quot;; ### traditional operator\nsyntax <br>\n$FH-&gt;print(&quot;world!\\n&quot;); ### OO syntax</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See IO::Scalar\nas an example. It also shows you how to create classes which\nwork both with and without 5.004.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose you\nhave a class &quot;FooHandle&quot;, where...</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p><b>FooHandle does not inherit from IO::Handle;</b> that\nis, it performs filehandle-like I/O, but to something other\nthan an underlying file descriptor. Good examples are\nIO::Scalar (for printing to a string) and IO::Lines (for\nprinting to an array of lines).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p><b>FooHandle implements the <small>TIEHANDLE</small>\ninterface</b> (see perltie); that is, it provides methods\n<small>TIEHANDLE, GETC, PRINT, PRINTF, READ,</small> and\n<small>READLINE.</small></p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p><b>FooHandle implements the traditional\n<small>OO</small> interface</b> of FileHandle and\nIO::Handle; i.e., it contains methods like <b>getline()</b>,\n<b>read()</b>, <b>print()</b>, <b>seek()</b>, <b>tell()</b>,\n<b>eof()</b>, etc.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Normally, users\nof your class would have two options:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\"><b>Use only <small>OO</small>\nsyntax,</b> and forsake named I/O operators like\n&rsquo;print&rsquo;.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p><b>Use with tie,</b> and forsake treating it as a\nfirst-class object (i.e., class-specific methods can only be\ninvoked through the underlying object via <b>tied()</b>...\ngiving the object a &quot;split personality&quot;).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But now with\nIO::WrapTie, you can say:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$WT =\nwraptie('FooHandle', &amp;FOO_RDWR, 2); <br>\n$WT-&gt;print(&quot;Hello, world\\n&quot;); ### OO syntax\n<br>\nprint $WT &quot;Yes!\\n&quot;; ### Named operator syntax too!\n<br>\n$WT-&gt;weird_stuff; ### Other methods!</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And if\nyou&rsquo;re authoring a class like FooHandle, just have it\ninherit from &quot;IO::WrapTie::Slave&quot; and that first\nline becomes even prettier:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$WT =\nFooHandle-&gt;new_tie(&amp;FOO_RDWR, 2);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The bottom\nline:</b> now, almost any class can look and work exactly\nlike an IO::Handle... and be used both with\n<small>OO</small> and non-OO filehandle syntax.</p>\n\n<h2>HOW IT ALL WORKS\n<a name=\"HOW IT ALL WORKS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The data\nstructures</b> <br>\nConsider this example code, using classes in this\ndistribution:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use IO::Scalar;\n<br>\nuse IO::WrapTie; <br>\n$WT = wraptie('IO::Scalar',\\$s); <br>\nprint $WT &quot;Hello, &quot;; <br>\n$WT-&gt;print(&quot;world!\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In it, the\n<b>wraptie()</b> function creates a data structure as\nfollows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* $WT is a\nblessed reference to a tied filehandle <br>\n$WT glob; that glob is tied to the &quot;Slave&quot; object.\n<br>\n| * You would do all your i/o with $WT directly. <br>\n| <br>\n| <br>\n| ,---isa--&gt; IO::WrapTie::Master &gt;--isa--&gt;\nIO::Handle <br>\nV / <br>\n.-------------. <br>\n| | <br>\n| | * Perl i/o operators work on the tied object, <br>\n| &quot;Master&quot; | invoking the TIEHANDLE methods. <br>\n| | * Method invocations are delegated to the tied <br>\n| | slave. <br>\n`-------------' <br>\n| <br>\ntied(*$WT) | .---isa--&gt; IO::WrapTie::Slave <br>\nV / <br>\n.-------------. <br>\n| | <br>\n| &quot;Slave&quot; | * Instance of FileHandle-like class\nwhich doesn't <br>\n| | actually use file descriptors, like IO::Scalar. <br>\n| IO::Scalar | * The slave can be any kind of object. <br>\n| | * Must implement the TIEHANDLE interface. <br>\n`-------------'</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i><small>NOTE:</small></i>\njust as an IO::Handle is really just a blessed reference to\na <i>traditional</i> filehandle glob... so also, an\nIO::WrapTie::Master is really just a blessed reference to a\nfilehandle glob <i>which has been tied to some\n&quot;slave&quot; class.</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>How\nwraptie() works</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">The call to function\n&quot;wraptie(SLAVECLASS, TIEARGS...)&quot; is passed onto\n&quot;IO::WrapTie::Master::new()&quot;. Note that class\nIO::WrapTie::Master is a subclass of IO::Handle.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>The &quot;IO::WrapTie::Master::new&quot; method creates\na new IO::Handle object, reblessed into class\nIO::WrapTie::Master. This object is the <i>master</i>, which\nwill be returned from the constructor. At the same\ntime...</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>The &quot;new&quot; method also creates the\n<i>slave</i>: this is an instance of\n<small>SLAVECLASS</small> which is created by tying the\nmaster&rsquo;s IO::Handle to <small>SLAVECLASS</small> via\n&quot;tie(HANDLE, SLAVECLASS, TIEARGS...)&quot;. This call\nto &quot;tie()&quot; creates the slave in the following\nmanner:</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Class <small>SLAVECLASS</small> is sent the message\n&quot;TIEHANDLE(TIEARGS...)&quot;; it will usually delegate\nthis to &quot;SLAVECLASS::new(TIEARGS...)&quot;, resulting\nin a new instance of <small>SLAVECLASS</small> being created\nand returned.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Once both master and slave have been created, the master\nis returned to the caller.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>How I/O\noperators work (on the master)</b> <br>\nConsider using an i/o operator on the master:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">print $WT\n&quot;Hello, world!\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since the\nmaster ($WT) is really a [blessed] reference to a glob, the\nnormal Perl i/o operators like &quot;print&quot; may be used\non it. They will just operate on the symbol part of the\nglob.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since the glob\nis tied to the slave, the slave&rsquo;s <small>PRINT</small>\nmethod (part of the <small>TIEHANDLE</small> interface) will\nbe automatically invoked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the slave is\nan IO::Scalar, that means IO::Scalar::PRINT will be invoked,\nand that method happens to delegate to the\n&quot;print()&quot; method of the same class. So the\n<i>real</i> work is ultimately done by\n<b>IO::Scalar::print()</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>How methods\nwork (on the master)</b> <br>\nConsider using a method on the master:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$WT-&gt;print(&quot;Hello,\nworld!\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since the\nmaster ($WT) is blessed into the class IO::WrapTie::Master,\nPerl first attempts to find a &quot;print()&quot; method\nthere. Failing that, Perl next attempts to find a\n&quot;print()&quot; method in the superclass, IO::Handle. It\njust so happens that there <i>is</i> such a method; that\nmethod merely invokes the &quot;print&quot; i/o operator on\nthe self object... and for that, see above!</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But let&rsquo;s\nsuppose we&rsquo;re dealing with a method which\n<i>isn&rsquo;t</i> part of IO::Handle... for example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $sref =\n$WT-&gt;sref;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In this case,\nthe intuitive behavior is to have the master delegate the\nmethod invocation to the slave (now do you see where the\ndesignations come from?). This is indeed what happens:\nIO::WrapTie::Master contains an <small>AUTOLOAD</small>\nmethod which performs the delegation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So: when\n&quot;sref()&quot; can&rsquo;t be found in IO::Handle, the\n<small>AUTOLOAD</small> method of IO::WrapTie::Master is\ninvoked, and the standard behavior of delegating the method\nto the underlying slave (here, an IO::Scalar) is done.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sometimes, to\nget this to work properly, you may need to create a subclass\nof IO::WrapTie::Master which is an effective master for\n<i>your</i> class, and do the delegation there.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Why not\nsimply use the object&rsquo;s <small>OO</small>\ninterface?</b> <br>\nBecause that means forsaking the use of named operators like\n<b>print()</b>, and you may need to pass the object to a\nsubroutine which will attempt to use those operators:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$O =\nFooHandle-&gt;new(&amp;FOO_RDWR, 2); <br>\n$O-&gt;print(&quot;Hello, world\\n&quot;); ### OO syntax is\nokay, BUT.... <br>\nsub nope { print $_[0] &quot;Nope!\\n&quot; } <br>\nX nope($O); ### ERROR!!! (not a glob ref)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Why not\nsimply use tie()?</b> <br>\nBecause (1) you have to use <b>tied()</b> to invoke methods\nin the object&rsquo;s public interface (yuck), and (2) you\nmay need to pass the tied symbol to another subroutine which\nwill attempt to treat it in an OO-way... and that will break\nit:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">tie *T,\n'FooHandle', &amp;FOO_RDWR, 2; <br>\nprint T &quot;Hello, world\\n&quot;; ### Operator is okay,\nBUT... <br>\ntied(*T)-&gt;other_stuff; ### yuck! AND... <br>\nsub nope { shift-&gt;print(&quot;Nope!\\n&quot;) } <br>\nX nope(\\*T); ### ERROR!!! (method &quot;print&quot; on\nunblessed ref)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Why a master\nand slave? <br>\nWhy not simply write FooHandle to inherit from\nIO::Handle?</b> <br>\nI tried this, with an implementation similar to that of\nIO::Socket. The problem is that <i>the whole point is to use\nthis with objects that don&rsquo;t have an underlying\nfile/socket descriptor.</i>. Subclassing IO::Handle will\nwork fine for the <small>OO</small> stuff, and fine with\nnamed operators <i>if</i> you <b>tie()</b>... but if you\njust attempt to say:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$IO =\nFooHandle-&gt;new(&amp;FOO_RDWR, 2); <br>\nprint $IO &quot;Hello!\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">you get a\nwarning from Perl like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Filehandle\nGEN001 never opened</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">because\nit&rsquo;s trying to do system-level i/o on an (unopened)\nfile descriptor. To avoid this, you apparently have to\n<b>tie()</b> the handle... which brings us right back to\nwhere we started! At least the IO::WrapTie mixin lets us\nsay:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$IO =\nFooHandle-&gt;new_tie(&amp;FOO_RDWR, 2); <br>\nprint $IO &quot;Hello!\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and so is not\n<i>too</i> bad. &quot;:-)&quot;</p>\n\n<h2>WARNINGS\n<a name=\"WARNINGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Remember: this\nstuff is for doing FileHandle-like i/o on things <i>without\nunderlying file descriptors</i>. If you have an underlying\nfile descriptor, you&rsquo;re better off just inheriting\nfrom IO::Handle.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Be aware\nthat new_tie() always returns an instance of a kind of\nIO::WrapTie::Master...</b> it does <b>not</b> return an\ninstance of the i/o class you&rsquo;re tying to!</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Invoking some\nmethods on the master object causes <small>AUTOLOAD</small>\nto delegate them to the slave object... so it <i>looks</i>\nlike you&rsquo;re manipulating a &quot;FooHandle&quot;\nobject directly, but you&rsquo;re not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">I have not\nexplored all the ramifications of this use of <b>tie()</b>.\n<i>Here there be dragons</i>.</p>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$Id:\nWrapTie.pm,v 1.2 2005/02/10 21:21:53 dfs Exp $</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Primary\nMaintainer</p>\n\n<p style=\"margin-left:17%;\">Dianne Skoll\n(<i>dfs@roaringpenguin.com</i>).</p>\n\n<p style=\"margin-left:11%;\">Original Author</p>\n\n<p style=\"margin-left:17%;\">Eryq (<i>eryq@zeegee.com</i>).\nPresident, ZeeGee Software Inc\n(<i>http://www.zeegee.com</i>).</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#HOW IT ALL WORKS\">HOW IT ALL WORKS</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#WARNINGS\">WARNINGS</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#AUTHOR\">AUTHOR</a>"],"level":3}