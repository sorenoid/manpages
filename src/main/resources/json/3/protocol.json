{"name":"protocol","body":"\n\n<h1 align=\"center\">Protocol</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">X11::Protocol -\nPerl module for the X Window System Protocol, version 11</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nX11::Protocol; <br>\n$x = X11::Protocol-&gt;new(); <br>\n$win = $x-&gt;new_rsrc; <br>\n$x-&gt;CreateWindow($win, $x-&gt;root, 'InputOutput', <br>\n$x-&gt;root_depth, 'CopyFromParent', <br>\n($x_coord, $y_coord), $width, <br>\n$height, $border_w); <br>\n...</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">X11::Protocol\nis a client-side interface to the X11 Protocol (see X(1) for\ninformation about X11), allowing perl programs to display\nwindows and graphics on X11 servers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A full\ndescription of the protocol is beyond the scope of this\ndocumentation; for complete information, see the <i>X Window\nSystem Protocol, X Version 11</i>, available as Postscript\nor *roff source from &quot;ftp://ftp.x.org&quot;, or\n<i>Volume 0: X Protocol Reference Manual</i> of\nO&rsquo;Reilly &amp; Associates&rsquo;s series of books\nabout X ( <small>ISBN 1-56592-083-X,</small>\n&quot;http://www.oreilly.com&quot;), which contains most of\nthe same information.</p>\n\n<h2>DISCLAIMER\n<a name=\"DISCLAIMER\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&rsquo;&rsquo;The\nprotocol contains many management mechanisms that are not\nintended for normal applications. Not all mechanisms are\nneeded to build a particular user interface. It is important\nto keep in mind that the protocol is intended to provide\nmechanism, not policy.&rsquo;&rsquo; -- Robert W.\nScheifler</p>\n\n<h2>BASIC METHODS\n<a name=\"BASIC METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>new</b> <br>\n$x = X11::Protocol-&gt;new(); <br>\n$x = X11::Protocol-&gt;new($display_name); <br>\n$x = X11::Protocol-&gt;new($connection); <br>\n$x = X11::Protocol-&gt;new($display_name, [$auth_type,\n$auth_data]); <br>\n$x = X11::Protocol-&gt;new($connection, [$auth_type,\n$auth_data]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Open a\nconnection to a server. $display_name should be an X display\nname, of the form &rsquo;host:display_num.screen_num&rsquo;;\nif no arguments are supplied, the contents of the\n<small>DISPLAY</small> environment variable are used.\nAlternatively, a pre-opened connection, of one of the\nX11::Protocol::Connection classes (see\nX11::Protocol::Connection,\nX11::Protocol::Connection::FileHandle,\nX11::Protocol::Connection::Socket,\nX11::Protocol::Connection::UNIXFH,\nX11::Protocol::Connection::INETFH,\nX11::Protocol::Connection::UNIXSocket,\nX11::Protocol::Connection::INETSocket) can be given. The\nauthorization data is obtained using X11::Auth or the second\nargument. If the display is specified by $display_name,\nrather than $connection, a <b>choose_screen()</b> is also\nperformed, defaulting to screen 0 if the\n&rsquo;.screen_num&rsquo; of the display name is not\npresent. Returns the new protocol object.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>new_rsrc</b>\n<br>\n$x-&gt;new_rsrc;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a new\nresource identifier. A unique resource <small>ID</small> is\nrequired for every object that the server creates on behalf\nof the client: windows, fonts, cursors, etc. (IDs are chosen\nby the client instead of the server for efficiency -- the\nclient doesn&rsquo;t have to wait for the server to\nacknowledge the creation before starting to use the\nobject).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\ntotal number of available resource IDs, while large, is\nfinite. Beginning from the establishment of a connection,\nresource IDs are allocated sequentially from a range whose\nsize is server dependent (commonly 2**21, about 2 million).\nIf this limit is reached and the server does not support the\n<small>XC_MISC</small> extension, subsequent calls to\nnew_rsrc will croak. If the server does support this\nextension, the module will attempt to request a new range of\nfree IDs from the server. This should allow the program to\ncontinue, but it is an imperfect solution, as over time the\nset of available IDs may fragment, requiring increasingly\nfrequent round-trip range requests from the server. For\nlong-running programs, the best approach may be to keep\ntrack of free IDs as resources are destroyed. In the current\nversion, however, no special support is provided for\nthis.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>handle_input</b>\n<br>\n$x-&gt;handle_input;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get one chunk\nof information from the server, and do something with it. If\nit&rsquo;s an error, handle it using the protocol\nobject&rsquo;s handler (&rsquo;error_handler&rsquo; --\ndefault is kill the program with an explanatory message). If\nit&rsquo;s an event, pass it to the chosen event handler, or\nput it in a queue if the handler is &rsquo;queue&rsquo;. If\nit&rsquo;s a reply to a request, save using the\nobject&rsquo;s &rsquo;replies&rsquo; hash for further\nprocessing.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>atom_name</b>\n<br>\n$name = $x-&gt;atom_name($atom);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Return the\nstring corresponding to the atom $atom. This is similar to\nthe GetAtomName request, but caches the result for\nefficiency.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>atom</b>\n<br>\n$atom = $x-&gt;atom($name);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inverse\noperation; Return the (numeric) atom corresponding to $name.\nThis is similar to the InternAtom request, but caches the\nresult.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>choose_screen</b>\n<br>\n$x-&gt;choose_screen($screen_num);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Indicate that\nyou prefer to use a particular screen of the display.\nPer-screen information, such as &rsquo;root&rsquo;,\n&rsquo;width_in_pixels&rsquo;, and &rsquo;white_pixel&rsquo;\nwill be made available as</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'root'}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">instead of</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'screens'}[$screen_num]{'root'}</p>\n\n<h2>SYMBOLIC CONSTANTS\n<a name=\"SYMBOLIC CONSTANTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Generally,\nsymbolic constants used by the protocol, like\n&rsquo;CopyFromParent&rsquo; or &rsquo;PieSlice&rsquo; are\npassed to methods as strings, and converted into numbers by\nthe module. Their names are the same as those in the\nprotocol specification, including capitalization, but with\nhyphens (&rsquo;-&rsquo;) changed to underscores\n(&rsquo;_&rsquo;) to look more perl-ish. If you want to do\nthe conversion yourself for some reason, the following\nmethods are available:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>num</b> <br>\n$num = $x-&gt;num($type, $str)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given a string\nrepresenting a constant and a string specifying what type of\nconstant it is, return the corresponding number. $type\nshould be a name like &rsquo;VisualClass&rsquo; or\n&rsquo;GCLineStyle&rsquo;. If the name is not recognized, it\nis returned intact.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>interp</b>\n<br>\n$name = $x-&gt;interp($type, $num)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inverse\noperation; given a number and string specifying its type,\nreturn a string representing the constant.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can disable\n<b>interp()</b> and the module&rsquo;s internal\ninterpretation of numbers by setting\n$x-&gt;{&rsquo;do_interp&rsquo;} to zero. Of course, this\nisn&rsquo;t very useful, unless you have you own definitions\nfor all the constants.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is a list\nof available constant types:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">AccessMode,\nAllowEventsMode, AutoRepeatMode, BackingStore, <br>\nBitGravity, Bool, ChangePropertyMode, CirculateDirection,\n<br>\nCirculatePlace, Class, ClipRectangleOrdering, CloseDownMode,\n<br>\nColormapNotifyState, CoordinateMode, CrossingNotifyDetail,\n<br>\nCrossingNotifyMode, DeviceEvent, DrawDirection, Error,\nEventMask, <br>\nEvents, FocusDetail, FocusMode, GCArcMode, GCCapStyle,\nGCFillRule, <br>\nGCFillStyle, GCFunction, GCJoinStyle, GCLineStyle,\nGCSubwindowMode, <br>\nGrabStatus, HostChangeMode, HostFamily, ImageFormat, <br>\nInputFocusRevertTo, KeyMask, LedMode, MapState,\nMappingChangeStatus, <br>\nMappingNotifyRequest, PointerEvent, PolyShape,\nPropertyNotifyState, <br>\nRequest, ScreenSaver, ScreenSaverAction, Significance,\nSizeClass, <br>\nStackMode, SyncMode, VisibilityState, VisualClass,\nWinGravity</p>\n\n<h2>SERVER INFORMATION\n<a name=\"SERVER INFORMATION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">At connection\ntime, the server sends a large amount of information about\nitself to the client. This information is stored in the\nprotocol object for future reference. It can be read\ndirectly, like</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'release_number'}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or, for object\noriented True Believers, using a method:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;release_number</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The method\nmethod also has a one argument form for setting variables,\nbut it isn&rsquo;t really useful for some of the more\ncomplex structures.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is an\nexample of what the object&rsquo;s information might look\nlike:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">'connection'\n=&gt; X11::Connection::UNIXSocket(0x814526fd), <br>\n'byte_order' =&gt; 'l', <br>\n'protocol_major_version' =&gt; 11, <br>\n'protocol_minor_version' =&gt; 0, <br>\n'authorization_protocol_name' =&gt; 'MIT-MAGIC-COOKIE-1',\n<br>\n'release_number' =&gt; 3110, <br>\n'resource_id_base' =&gt; 0x1c000002, <br>\n'motion_buffer_size' =&gt; 0, <br>\n'maximum_request_length' =&gt; 65535, # units of 4 bytes\n<br>\n'image_byte_order' =&gt; 'LeastSiginificant', <br>\n'bitmap_bit_order' =&gt; 'LeastSiginificant', <br>\n'bitmap_scanline_unit' =&gt; 32, <br>\n'bitmap_scanline_pad' =&gt; 32, <br>\n'min_keycode' =&gt; 8, <br>\n'max_keycode' =&gt; 134, <br>\n'vendor' =&gt; 'The XFree86 Project, Inc', <br>\n'pixmap_formats' =&gt; {1 =&gt; {'bits_per_pixel' =&gt; 1,\n<br>\n'scanline_pad' =&gt; 32}, <br>\n8 =&gt; {'bits_per_pixel' =&gt; 8, <br>\n'scanline_pad' =&gt; 32}}, <br>\n'screens' =&gt; [{'root' =&gt; 43, 'width_in_pixels' =&gt;\n800, <br>\n'height_in_pixels' =&gt; 600, <br>\n'width_in_millimeters' =&gt; 271, <br>\n'height_in_millimeters' =&gt; 203, <br>\n'root_depth' =&gt; 8, <br>\n'root_visual' =&gt; 34, <br>\n'default_colormap' =&gt; 33, <br>\n'white_pixel' =&gt; 0, 'black_pixel' =&gt; 1, <br>\n'min_installed_maps' =&gt; 1, <br>\n'max_installed_maps' =&gt; 1, <br>\n'backing_stores' =&gt; 'Always', <br>\n'save_unders' =&gt; 1, <br>\n'current_input_masks' =&gt; 0x58003d, <br>\n'allowed_depths' =&gt; <br>\n[{'depth' =&gt; 1, 'visuals' =&gt; []}, <br>\n{'depth' =&gt; 8, 'visuals' =&gt; [ <br>\n{'visual_id' =&gt; 34, 'blue_mask' =&gt; 0, <br>\n'green_mask' =&gt; 0, 'red_mask' =&gt; 0, <br>\n'class' =&gt; 'PseudoColor', <br>\n'bits_per_rgb_value' =&gt; 6, <br>\n'colormap_entries' =&gt; 256}, <br>\n{'visual_id' =&gt; 35, 'blue_mask' =&gt; 0xc0, <br>\n'green_mask' =&gt; 0x38, 'red_mask' =&gt; 0x7, <br>\n'class' =&gt; 'DirectColor', <br>\n'bits_per_rgb_value' =&gt; 6, <br>\n'colormap_entries' =&gt; 8}, ...]}]], <br>\n'visuals' =&gt; {34 =&gt; {'depth' =&gt; 8, 'class' =&gt;\n'PseudoColor', <br>\n'red_mask' =&gt; 0, 'green_mask' =&gt; 0, <br>\n'blue_mask'=&gt; 0, 'bits_per_rgb_value' =&gt; 6, <br>\n'colormap_entries' =&gt; 256}, <br>\n35 =&gt; {'depth' =&gt; 8, 'class' =&gt; 'DirectColor', <br>\n'red_mask' =&gt; 0x7, 'green_mask' =&gt; 0x38, <br>\n'blue_mask'=&gt; 0xc0, 'bits_per_rgb_value' =&gt; 6, <br>\n'colormap_entries' =&gt; 8}, ...} <br>\n'error_handler' =&gt;\n&amp;\\X11::Protocol::default_error_handler, <br>\n'event_handler' =&gt; sub {}, <br>\n'do_interp' =&gt; 1</p>\n\n<h2>REQUESTS\n<a name=\"REQUESTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>request</b>\n<br>\n$x-&gt;request('CreateWindow', ...); <br>\n$x-&gt;req('CreateWindow', ...); <br>\n$x-&gt;CreateWindow(...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Send a protocol\nrequest to the server, and get the reply, if any. For names\nof and information about individual requests, see below\nand/or the protocol reference manual.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>robust_req</b>\n<br>\n$x-&gt;robust_req('CreateWindow', ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Like\n<b>request()</b>, but if the server returns an error, return\nthe error information rather than calling the error handler\n(which by default just croaks). If the request succeeds,\nreturns an array reference containing whatever\n<b>request()</b> would have. Otherwise, returns the error\ntype, the major and minor opcodes of the failed request, and\nthe extra error information, if any. Note that even if the\nrequest normally wouldn&rsquo;t have a reply, this method\nstill has to wait for a round-trip time to see whether an\nerror occurred. If you&rsquo;re concerned about performance,\nyou should design your error handling to be\nasynchronous.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>add_reply</b>\n<br>\n$x-&gt;add_reply($sequence_num, \\$var);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Add a stub for\nan expected reply to the object&rsquo;s\n&rsquo;replies&rsquo; hash. When a reply numbered\n$sequence_num comes, it will be stored in $var.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>delete_reply</b>\n<br>\n$x-&gt;delete_reply($sequence_num);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Delete the\nentry in &rsquo;replies&rsquo; for the specified reply.\n(This should be done after the reply is received).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>send</b>\n<br>\n$x-&gt;send('CreateWindow', ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Send a request,\nbut do not wait for a reply. You must handle the reply, if\nany, yourself, using <b>add_reply()</b>,\n<b>handle_input()</b>, <b>delete_reply()</b>, and\n<b>unpack_reply()</b>, generally in that order.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>unpack_reply</b>\n<br>\n$x-&gt;unpack_reply('GetWindowAttributes', $data);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Interpret the\nraw reply data $data, according to the reply format for the\nnamed request. Returns data in the same format as\n&quot;request($request_name, ...)&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This section\nincludes only a short calling summary for each request; for\nfull descriptions, see the protocol standard. Argument order\nis usually the same as listed in the spec, but you generally\ndon&rsquo;t have to pass lengths of strings or arrays, since\nperl keeps track. Symbolic constants are generally passed as\nstrings. Most replies are returned as lists, but when there\nare many values, a hash is used. Lists usually come last;\nwhen there is more than one, each is passed by reference. In\nlists of multi-part structures, each element is a list ref.\nParenthesis are inserted in arg lists for clarity, but are\noptional. Requests are listed in order by major opcode, so\nrelated requests are usually close together. Replies follow\nthe &rsquo;=&gt;&rsquo;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;CreateWindow($wid,\n$parent, $class, $depth, $visual, ($x, $y), <br>\n$width, $height, $border_width, <br>\n'attribute' =&gt; $value, ...) <br>\n$x-&gt;ChangeWindowAttributes($window, 'attribute' =&gt;\n$value, ...) <br>\n$x-&gt;GetWindowAttributes($window) <br>\n=&gt; <br>\n('backing_store' =&gt; $backing_store, ...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is an\nexample of a return value that is meant to be assigned to a\nhash.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;DestroyWindow($win)\n<br>\n$x-&gt;DestroySubwindows($win) <br>\n$x-&gt;ChangeSaveSet($window, $mode) <br>\n$x-&gt;ReparentWindow($win, $parent, ($x, $y)) <br>\n$x-&gt;MapWindow($win) <br>\n$x-&gt;MapSubwindows($win) <br>\n$x-&gt;UnmapWindow($win) <br>\n$x-&gt;UnmapSubwindows($win) <br>\n$x-&gt;ConfigureWindow($win, 'attribute' =&gt; $value, ...)\n<br>\n$x-&gt;CirculateWindow($win, $direction)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that this\nrequest actually circulates the subwindows of $win, not the\nwindow itself.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;GetGeometry($drawable)\n<br>\n=&gt; <br>\n('root' =&gt; $root, ...) <br>\n$x-&gt;QueryTree($win) <br>\n=&gt; <br>\n($root, $parent, @kids) <br>\n$x-&gt;InternAtom($name, $only_if_exists) <br>\n=&gt; <br>\n$atom <br>\n$x-&gt;GetAtomName($atom) <br>\n=&gt; <br>\n$name <br>\n$x-&gt;ChangeProperty($window, $property, $type, $format,\n$mode, $data) <br>\n$x-&gt;DeleteProperty($win, $atom) <br>\n$x-&gt;GetProperty($window, $property, $type, $offset,\n$length, $delete) <br>\n=&gt; <br>\n($value, $type, $format, $bytes_after)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notice that the\nvalue comes first, so you can easily ignore the rest.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;ListProperties($window)\n<br>\n=&gt; <br>\n(@atoms) <br>\n$x-&gt;SetSelectionOwner($selection, $owner, $time) <br>\n$x-&gt;GetSelectionOwner($selection) <br>\n=&gt; <br>\n$owner <br>\n$x-&gt;ConvertSelection($selection, $target, $property,\n$requestor, $time) <br>\n$x-&gt;SendEvent($destination, $propagate, $event_mask,\n$event)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The $event\nargument should be the result of a <b>pack_event()</b> (see\n&quot; <small>EVENTS&quot;</small> )</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;GrabPointer($grab_window,\n$owner_events, $event_mask, <br>\n$pointer_mode, $keyboard_mode, $confine_to, <br>\n$cursor, $time) <br>\n=&gt; <br>\n$status <br>\n$x-&gt;UngrabPointer($time) <br>\n$x-&gt;GrabButton($modifiers, $button, $grab_window,\n$owner_events, <br>\n$event_mask, $pointer_mode, $keyboard_mode, <br>\n$confine_to, $cursor) <br>\n$x-&gt;UngrabButton($modifiers, $button, $grab_window) <br>\n$x-&gt;ChangeActivePointerGrab($event_mask, $cursor, $time)\n<br>\n$x-&gt;GrabKeyboard($grab_window, $owner_events,\n$pointer_mode, <br>\n$keyboard_mode, $time) <br>\n=&gt; <br>\n$status <br>\n$x-&gt;UngrabKeyboard($time) <br>\n$x-&gt;GrabKey($key, $modifiers, $grab_window,\n$owner_events, <br>\n$pointer_mode, $keyboard_mode) <br>\n$x-&gt;UngrabKey($key, $modifiers, $grab_window) <br>\n$x-&gt;AllowEvents($mode, $time) <br>\n$x-&gt;GrabServer <br>\n$x-&gt;UngrabServer <br>\n$x-&gt;QueryPointer($window) <br>\n=&gt; <br>\n('root' =&gt; $root, ...) <br>\n$x-&gt;GetMotionEvents($start, $stop, $window) <br>\n=&gt; <br>\n([$time, ($x, $y)], [$time, ($x, $y)], ...) <br>\n$x-&gt;TranslateCoordinates($src_window, $dst_window,\n$src_x, $src_y) <br>\n=&gt; <br>\n($same_screen, $child, $dst_x, $dst_y) <br>\n$x-&gt;WarpPointer($src_window, $dst_window, $src_x, $src_y,\n$src_width, <br>\n$src_height, $dst_x, $dst_y) <br>\n$x-&gt;SetInputFocus($focus, $revert_to, $time) <br>\n$x-&gt;GetInputFocus <br>\n=&gt; <br>\n($focus, $revert_to) <br>\n$x-&gt;QueryKeymap <br>\n=&gt; <br>\n$keys</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$keys is a bit\nvector, so you should use <b>vec()</b> to read it.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;OpenFont($fid,\n$name) <br>\n$x-&gt;CloseFont($font) <br>\n$x-&gt;QueryFont($font) <br>\n=&gt; <br>\n('min_char_or_byte2' =&gt; $min_char_or_byte2, <br>\n..., <br>\n'min_bounds' =&gt; <br>\n[$left_side_bearing, $right_side_bearing, $character_width,\n$ascent, <br>\n$descent, $attributes], <br>\n..., <br>\n'char_infos' =&gt; <br>\n[[$left_side_bearing, $right_side_bearing, $character_width,\n$ascent, <br>\n$descent, $attributes], <br>\n...], <br>\n'properties' =&gt; {$prop =&gt; $value, ...} <br>\n) <br>\n$x-&gt;QueryTextExtents($font, $string) <br>\n=&gt; <br>\n('draw_direction' =&gt; $draw_direction, ...) <br>\n$x-&gt;ListFonts($pattern, $max_names) <br>\n=&gt; <br>\n@names <br>\n$x-&gt;ListFontsWithInfo($pattern, $max_names) <br>\n=&gt; <br>\n({'name' =&gt; $name, ...}, {'name' =&gt; $name, ...},\n...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The information\nin each hash is the same as the the information returned by\nQueryFont, but without per-character size information. This\nrequest is special in that it is the only request that can\nhave more than one reply. This means you should probably\nonly use <b>request()</b> with it, not <b>send()</b>, as the\nreply counting is complicated. Luckily, you never need this\nrequest anyway, as its function is completely duplicated by\nother requests.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;SetFontPath(@strings)\n<br>\n$x-&gt;GetFontPath <br>\n=&gt; <br>\n@strings <br>\n$x-&gt;CreatePixmap($pixmap, $drawable, $depth, $width,\n$height) <br>\n$x-&gt;FreePixmap($pixmap) <br>\n$x-&gt;CreateGC($cid, $drawable, 'attribute' =&gt; $value,\n...) <br>\n$x-&gt;ChangeGC($gc, 'attribute' =&gt; $value, ...) <br>\n$x-&gt;CopyGC($src, $dest, 'attribute', 'attribute', ...)\n<br>\n$x-&gt;SetDashes($gc, $dash_offset, (@dashes)) <br>\n$x-&gt;SetClipRectangles($gc, ($clip_x_origin,\n$clip_y_origin), <br>\n$ordering, [$x, $y, $width, $height], ...) <br>\n$x-&gt;ClearArea($window, ($x, $y), $width, $height,\n$exposures) <br>\n$x-&gt;CopyArea($src_drawable, $dst_drawable, $gc, ($src_x,\n$src_y), <br>\n$width, $height, ($dst_x, $dst_y)) <br>\n$x-&gt;CopyPlane($src_drawable, $dst_drawable, $gc, ($src_x,\n$src_y), <br>\n$width, $height, ($dst_x, $dst_y), $bit_plane) <br>\n$x-&gt;PolyPoint($drawable, $gc, $coordinate_mode, <br>\n($x, $y), ($x, $y), ...) <br>\n$x-&gt;PolyLine($drawable, $gc, $coordinate_mode, <br>\n($x, $y), ($x, $y), ...) <br>\n$x-&gt;PolySegment($drawable, $gc, ($x, $y) =&gt; ($x, $y),\n<br>\n($x, $y) =&gt; ($x, $y), ...) <br>\n$x-&gt;PolyRectangle($drawable, $gc, <br>\n[($x, $y), $width, $height], ...) <br>\n$x-&gt;PolyArc($drawable, $gc, <br>\n[($x, $y), $width, $height, $angle1, $angle2], ...) <br>\n$x-&gt;FillPoly($drawable, $gc, $shape, $coordinate_mode,\n<br>\n($x, $y), ...) <br>\n$x-&gt;PolyFillRectangle($drawable, $gc, <br>\n[($x, $y), $width, $height], ...) <br>\n$x-&gt;PolyFillArc($drawable, $gc, <br>\n[($x, $y), $width, $height, $angle1, $angle2], ...) <br>\n$x-&gt;PutImage($drawable, $gc, $depth, $width, $height,\n<br>\n($dst_x, $dst_y), $left_pad, $format, $data)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Currently, the\nmodule has no code to handle the various bitmap formats that\nthe server might specify. Therefore, this request will not\nwork portably without a lot of work.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;GetImage($drawable,\n($x, $y), $width, $height, $plane_mask, <br>\n$format) <br>\n$x-&gt;PolyText8($drawable, $gc, ($x, $y), <br>\n($font OR [$delta, $string]), ...) <br>\n$x-&gt;PolyText16($drawable, $gc, ($x, $y), <br>\n($font OR [$delta, $string]), ...) <br>\n$x-&gt;ImageText8($drawable, $gc, ($x, $y), $string) <br>\n$x-&gt;ImageText16($drawable, $gc, ($x, $y), $string) <br>\n$x-&gt;CreateColormap($mid, $visual, $window, $alloc) <br>\n$x-&gt;FreeColormap($cmap) <br>\n$x-&gt;CopyColormapAndFree($mid, $src_cmap) <br>\n$x-&gt;InstallColormap($cmap) <br>\n$x-&gt;UninstallColormap($cmap) <br>\n$x-&gt;ListInstalledColormaps($window) <br>\n=&gt; <br>\n@cmaps <br>\n$x-&gt;AllocColor($cmap, ($red, $green, $blue)) <br>\n=&gt; <br>\n($pixel, ($red, $green, $blue)) <br>\n$x-&gt;AllocNamedColor($cmap, $name) <br>\n=&gt; <br>\n($pixel, ($exact_red, $exact_green, $exact_blue), <br>\n($visual_red, $visual_green, $visual_blue)) <br>\n$x-&gt;AllocColorCells($cmap, $colors, $planes, $contiguous)\n<br>\n=&gt; <br>\n([@pixels], [@masks]) <br>\n$x-&gt;AllocColorPlanes($cmap, $colors, ($reds, $greens,\n$blues), <br>\n$contiguous) <br>\n=&gt; <br>\n(($red_mask, $green_mask, $blue_mask), @pixels) <br>\n$x-&gt;FreeColors($cmap, $plane_mask, @pixels) <br>\n$x-&gt;StoreColors($cmap, [$pixel, $red, $green, $blue,\n$do_mask], ...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The 1, 2, and 4\nbits in $do_mask are do-red, do-green, and do-blue. $do_mask\ncan be omitted, defaulting to 7, the usual case -- change\nthe whole color.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;StoreNamedColor($cmap,\n$pixel, $name, $do_mask)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$do_mask has\nthe same interpretation as above, but is mandatory.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;QueryColors($cmap,\n@pixels) <br>\n=&gt; <br>\n([$red, $green, $blue], ...) <br>\n$x-&gt;LookupColor($cmap, $name) <br>\n=&gt; <br>\n(($exact_red, $exact_green, $exact_blue), <br>\n($visual_red, $visual_green, $visual_blue)) <br>\n$x-&gt;CreateCursor($cid, $source, $mask, <br>\n($fore_red, $fore_green, $fore_blue), <br>\n($back_red, $back_green, $back_blue), <br>\n($x, $y)) <br>\n$x-&gt;CreateGlyphCursor($cid, $source_font, $mask_font,\n<br>\n$source_char, $mask_char, <br>\n($fore_red, $fore_green, $fore_blue), <br>\n($back_red, $back_green, $back_blue)) <br>\n$x-&gt;FreeCursor($cursor) <br>\n$x-&gt;RecolorCursor($cursor, ($fore_red, $fore_green,\n$fore_blue), <br>\n($back_red, $back_green, $back_blue)) <br>\n$x-&gt;QueryBestSize($class, $drawable, $width, $height)\n<br>\n=&gt; <br>\n($width, $height) <br>\n$x-&gt;QueryExtension($name) <br>\n=&gt; <br>\n($major_opcode, $first_event, $first_error)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nextension is not present, an empty list is returned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;ListExtensions\n<br>\n=&gt; <br>\n(@names) <br>\n$x-&gt;ChangeKeyboardMapping($first_keycode,\n$keysysms_per_keycode, <br>\n@keysyms) <br>\n$x-&gt;GetKeyboardMapping($first_keycode, $count) <br>\n=&gt; <br>\n($keysysms_per_keycode, [$keysym, ...], [$keysym, ...], ...)\n<br>\n$x-&gt;ChangeKeyboardControl('attribute' =&gt; $value, ...)\n<br>\n$x-&gt;GetKeyboardControl <br>\n=&gt; <br>\n('global_auto_repeat' =&gt; $global_auto_repeat, ...) <br>\n$x-&gt;Bell($percent) <br>\n$x-&gt;ChangePointerControl($do_acceleration, $do_threshold,\n<br>\n$acceleration_numerator, <br>\n$acceleration_denominator, $threshold) <br>\n$x-&gt;GetPointerControl <br>\n=&gt; <br>\n($acceleration_numerator, $acceleration_denominator,\n$threshold) <br>\n$x-&gt;SetScreenSaver($timeout, $interval, $prefer_blanking,\n<br>\n$allow_exposures) <br>\n$x-&gt;GetScreenSaver <br>\n=&gt; <br>\n($timeout, $interval, $prefer_blanking, $allow_exposures)\n<br>\n$x-&gt;ChangeHosts($mode, $host_family, $host_address) <br>\n$x-&gt;ListHosts <br>\n=&gt; <br>\n($mode, [$family, $host], ...) <br>\n$x-&gt;SetAccessControl($mode) <br>\n$x-&gt;SetCloseDownMode($mode) <br>\n$x-&gt;KillClient($resource) <br>\n$x-&gt;RotateProperties($win, $delta, @props) <br>\n$x-&gt;ForceScreenSaver($mode) <br>\n$x-&gt;SetPointerMapping(@map) <br>\n=&gt; <br>\n$status <br>\n$x-&gt;GetPointerMapping <br>\n=&gt; <br>\n@map <br>\n$x-&gt;SetModifierMapping(@keycodes) <br>\n=&gt; <br>\n$status <br>\n$x-&gt;GetModiferMapping <br>\n=&gt; <br>\n@keycodes <br>\n$x-&gt;NoOperation($length)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$length\nspecifies the length of the entire useless request, in four\nbyte units, and is optional.</p>\n\n<h2>EVENTS\n<a name=\"EVENTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">To receive\nevents, first set the &rsquo;event_mask&rsquo; attribute on\na window to indicate what types of events you desire (see\n&quot;pack_event_mask&quot;). Then, set the protocol\nobject&rsquo;s &rsquo;event_handler&rsquo; to a subroutine\nreference that will handle the events. Alternatively, set\n&rsquo;event_handler&rsquo; to &rsquo;queue&rsquo;, and\nretrieve events using <b>dequeue_event()</b> or\n<b>next_event()</b>. In both cases, events are returned as a\nhash. For instance, a typical MotionNotify event might look\nlike this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">%event =\n('name' =&gt; 'MotionNotify', 'sequence_number' =&gt; 12,\n<br>\n'state' =&gt; 0, 'event' =&gt; 58720256, 'root' =&gt; 43,\n<br>\n'child' =&gt; None, 'same_screen' =&gt; 1, 'time' =&gt;\n966080746, <br>\n'detail' =&gt; 'Normal', 'event_x' =&gt; 10, 'event_y' =&gt;\n3, <br>\n'code' =&gt; 6, 'root_x' =&gt; 319, 'root_y' =&gt; 235)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pack_event_mask</b>\n<br>\n$mask = $x-&gt;pack_event_mask('ButtonPress', 'KeyPress',\n'Exposure');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Make an event\nmask (suitable as the &rsquo;event_mask&rsquo; of a window)\nfrom a list of strings specifying event types.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>unpack_event_mask</b>\n<br>\n@event_types = $x-&gt;unpack_event_mask($mask);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inverse\noperation; convert an event mask obtained from the server\ninto a list of names of event categories.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dequeue_event</b>\n<br>\n%event = $x-&gt;dequeue_event;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If there is an\nevent waiting in the queue, return it.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>next_event</b>\n<br>\n%event = $x-&gt;next_event;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Like\nXlib&rsquo;s <b>XNextEvent()</b>, this function is\nequivalent to</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;handle_input\nuntil %event = dequeue_event;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pack_event</b>\n<br>\n$data = $x-&gt;pack_event(%event);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given an event\nin hash form, pack it into a string. This is only useful as\nan argument to <b>SendEvent()</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>unpack_event</b>\n<br>\n%event = $x-&gt;unpack_event($data);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The inverse\noperation; given the raw data for an event (32 bytes),\nunpack it into hash form. Normally, this is done\nautomatically.</p>\n\n<h2>EXTENSIONS\n<a name=\"EXTENSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Protocol\nextensions add new requests, event types, and error types to\nthe protocol. Support for them is compartmentalized in\nmodules in the X11::Protocol::Ext:: hierarchy. For an\nexample, see X11::Protocol::Ext::SHAPE. You can tell if the\nmodule has loaded an extension by looking at</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'ext'}{$extension_name}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nextension has been initialized, this value will be an array\nreference, [$major_request_number, $first_event_number,\n$first_error_number, $obj], where $obj is an object\ncontaining information private to the extension.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>init_extension</b>\n<br>\n$x-&gt;init_extension($name);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Initialize an\nextension: query the server to find the extension&rsquo;s\nrequest number, then load the corresponding module. Returns\n0 if the server does not support the named extension, or if\nno module to interface with it exists.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>init_extensions</b>\n<br>\n$x-&gt;init_extensions;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Initialize\nprotocol extensions. This does a ListExtensions request,\nthen calls <b>init_extension()</b> for each extension that\nthe server supports.</p>\n\n<h2>WRITING EXTENSIONS\n<a name=\"WRITING EXTENSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Internally, the\nX11::Protocol module is table driven. All an extension has\nto do is to add new add entries to the protocol\nobject&rsquo;s tables. An extension module should &quot;use\nX11::Protocol&quot;, and should define an <b>new()</b>\nmethod</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">X11::Protocol::Ext::NAME\n<br>\n-&gt;new($x, $request_num, $event_num, $error_num)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where $x is the\nprotocol object and $request_num, $event_num and $error_num\nare the values returned by <b>QueryExtension()</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>new()</b> method should add new types of constant\nlike</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'ext_const'}{'ConstantType'}\n= ['Constant', 'Constant', ...]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and set up the\ncorresponding name to number translation hashes like</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'ext_const_num'}{'ConstantType'}\n= <br>\n{make_num_hash($x-&gt;{'ext_const'}{'ConstantType'})}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Event names go\nin</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'ext_const'}{'Events'}[$event_number]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while\nspecifications for event contents go in</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'ext_event'}[$event_number]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">each element of\nwhich is either &quot;[\\&amp;unpack_sub,\n\\&amp;pack_sub]&quot; or &quot;[$pack_format, $field,\n$field, ...]&quot;, where each $field is 'name',\n&quot;['name', 'const_type']&quot;, or &quot;['name',\n['special_name_for_zero', 'special_name_for_one']]&quot;,\nwhere 'special_name_for_one' is optional.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Finally,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'ext_request'}{$major_request_number}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">should be an\narray of arrays, with each array either &quot;[$name,\n\\&amp;packit]&quot; or &quot;[$name, \\&amp;packit,\n\\&amp;unpackit]&quot;, and</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x-&gt;{'ext_request_num'}{$request_name}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">should be\ninitialized with &quot;[$minor_num, $major_num]&quot; for\neach request the extension defines. For examples of code\nthat does all of this, look at\nX11::Protocol::Ext::SHAPE.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">X11::Protocol\nexports several functions that might be useful in extensions\n(note that these are <i>not</i> methods).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>padding</b>\n<br>\n$p = padding $x;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given an\ninteger, compute the number need to round it up to a\nmultiple of 4. For instance, padding(5) is 3.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pad</b> <br>\n$p = pad $str;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given a string,\nreturn the number of extra bytes needed to make a multiple\nof 4. Equivalent to &quot;padding(length($str))&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>padded</b>\n<br>\n$data = pack(padded($str), $str);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Return a format\nstring, suitable for <b>pack()</b>, for a string padded to a\nmultiple of 4 bytes. For instance,\n&quot;pack(padded('Hello'), 'Hello')&quot; gives\n&quot;Hello\\0\\0\\0&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>hexi</b>\n<br>\n$str = hexi $n;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Format a number\nin hexidecimal, and add a &quot;0x&quot; to the front.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>make_num_hash</b>\n<br>\n%hash = make_num_hash(['A', 'B', 'C']);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given a\nreference to a list of strings, return a hash mapping the\nstrings onto numbers representing their position in the\nlist, as used by &quot;$x-&gt;{'ext_const_num'}&quot;.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module is\ntoo big (~2500 lines), too slow (10 sec to load on a slow\nmachine), too inefficient (request args are copied several\ntimes), and takes up too much memory (3000K for\nbasicwin).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you have\nmore than 65535 replies outstanding at once, sequence\nnumbers can collide.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The protocol is\ntoo complex.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Stephen\nMcCamant &lt;SMCCAM@cpan.org&gt;.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/perl\">perl(1)</a>,\nX(1), X11::Keysyms, X11::Protocol::Ext::SHAPE,\nX11::Protocol::Ext::BIG_REQUESTS,\nX11::Protocol::Ext::XC_MISC, X11::Protocol::Ext::DPMS,\nX11::Protocol::Ext::XFree86_Misc, X11::Auth, <i>X Window\nSystem Protocol (X Version 11)</i>, <i>Inter-Client\nCommunications Conventions Manual</i>, <i>X Logical Font\nDescription Conventions</i>.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#DISCLAIMER\">DISCLAIMER</a>","<a href=\"#BASIC METHODS\">BASIC METHODS</a>","<a href=\"#SYMBOLIC CONSTANTS\">SYMBOLIC CONSTANTS</a>","<a href=\"#SERVER INFORMATION\">SERVER INFORMATION</a>","<a href=\"#REQUESTS\">REQUESTS</a>","<a href=\"#EVENTS\">EVENTS</a>","<a href=\"#EXTENSIONS\">EXTENSIONS</a>","<a href=\"#WRITING EXTENSIONS\">WRITING EXTENSIONS</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>"],"level":3}