{"name":"cmsg","description":"CMSG_ALIGN, CMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - access ancillary data","body":"\n\n<h1 align=\"center\">CMSG</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">CMSG_ALIGN,\nCMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - access ancillary\ndata</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/socket.h&gt; <br>\nstruct cmsghdr *CMSG_FIRSTHDR(struct msghdr\n*</b><i>msgh</i><b>); <br>\nstruct cmsghdr *CMSG_NXTHDR(struct msghdr\n*</b><i>msgh</i><b>, <br>\nstruct cmsghdr *</b>cmsg<b>); <br>\nsize_t CMSG_ALIGN(size_t</b> <i>length</i><b>); <br>\nsize_t CMSG_SPACE(size_t</b> <i>length</i><b>); <br>\nsize_t CMSG_LEN(size_t</b> <i>length</i><b>); <br>\nunsigned char *CMSG_DATA(struct cmsghdr\n*</b><i>cmsg</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These macros\nare used to create and access control messages (also called\nancillary data) that are not a part of the socket payload.\nThis control information may include the interface the\npacket was received on, various rarely used header fields,\nan extended error description, a set of file descriptors, or\nUNIX credentials. For instance, control messages can be used\nto send additional header fields such as IP options.\nAncillary data is sent by calling <a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a> and\nreceived by calling <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>. See their manual\npages for more information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Ancillary data\nis a sequence of <i>cmsghdr</i> structures with appended\ndata. See the specific protocol man pages for the available\ncontrol message types. The maximum ancillary buffer size\nallowed per socket can be set using\n<i>/proc/sys/net/core/optmem_max</i>; see\n<a href=\"https://man.page/7/socket\">socket(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cmsghdr</i> structure is defined as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct cmsghdr\n{ <br>\nsize_t cmsg_len; /* Data byte count, including header <br>\n(type is socklen_t in POSIX) */ <br>\nint cmsg_level; /* Originating protocol */ <br>\nint cmsg_type; /* Protocol-specific type */ <br>\n/* followed by <br>\nunsigned char cmsg_data[]; */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sequence of\n<i>cmsghdr</i> structures should never be accessed directly.\nInstead, use only the following macros:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><b>CMSG_FIRSTHDR</b>() returns a pointer to the first\n<i>cmsghdr</i> in the ancillary data buffer associated with\nthe passed <i>msghdr</i>. It returns NULL if there\nisn&rsquo;t enough space for a <i>cmsghdr</i> in the\nbuffer.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><b>CMSG_NXTHDR</b>() returns the next valid\n<i>cmsghdr</i> after the passed <i>cmsghdr</i>. It returns\nNULL when there isn&rsquo;t enough space left in the\nbuffer.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:15%; margin-top: 1em\">When\ninitializing a buffer that will contain a series of\n<i>cmsghdr</i> structures (e.g., to be sent with\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a>), that buffer should first be\nzero-initialized to ensure the correct operation of\n<b>CMSG_NXTHDR</b>().</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\"><b>CMSG_ALIGN</b>(), given a\nlength, returns it including the required alignment. This is\na constant expression.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><b>CMSG_SPACE</b>() returns the number of bytes an\nancillary element with payload of the passed data length\noccupies. This is a constant expression.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><b>CMSG_DATA</b>() returns a pointer to the data portion\nof a <i>cmsghdr</i>. The pointer returned cannot be assumed\nto be suitably aligned for accessing arbitrary payload data\ntypes. Applications should not cast it to a pointer type\nmatching the payload, but should instead use\n<a href=\"https://man.page/3/memcpy\">memcpy(3)</a> to copy data to or from a suitably declared\nobject.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p><b>CMSG_LEN</b>() returns the value to store in the\n<i>cmsg_len</i> member of the <i>cmsghdr</i> structure,\ntaking into account any necessary alignment. It takes the\ndata length as an argument. This is a constant\nexpression.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To create\nancillary data, first initialize the <i>msg_controllen</i>\nmember of the <i>msghdr</i> with the length of the control\nmessage buffer. Use <b>CMSG_FIRSTHDR</b>() on the\n<i>msghdr</i> to get the first control message and\n<b>CMSG_NXTHDR</b>() to get all subsequent ones. In each\ncontrol message, initialize <i>cmsg_len</i> (with\n<b>CMSG_LEN</b>()), the other <i>cmsghdr</i> header fields,\nand the data portion using <b>CMSG_DATA</b>(). Finally, the\n<i>msg_controllen</i> field of the <i>msghdr</i> should be\nset to the sum of the <b>CMSG_SPACE</b>() of the length of\nall control messages in the buffer. For more information on\nthe <i>msghdr</i>, see <a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This ancillary\ndata model conforms to the POSIX.1g draft, 4.4BSD-Lite, the\nIPv6 advanced API described in RFC&nbsp;2292 and SUSv2.\n<b>CMSG_FIRSTHDR</b>(), <b>CMSG_NXTHDR</b>(), and\n<b>CMSG_DATA</b>() are specified in POSIX.1-2008.\n<b>CMSG_SPACE</b>() and <b>CMSG_LEN</b>() will be included\nin the next POSIX release (Issue 8).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CMSG_ALIGN</b>()\nis a Linux extension.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\nportability, ancillary data should be accessed using only\nthe macros described here. <b>CMSG_ALIGN</b>() is a Linux\nextension and should not be used in portable programs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Linux,\n<b>CMSG_LEN</b>(), <b>CMSG_DATA</b>(), and\n<b>CMSG_ALIGN</b>() are constant expressions (assuming their\nargument is constant), meaning that these values can be used\nto declare the size of global variables. This may not be\nportable, however.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This code looks\nfor the <b>IP_TTL</b> option in a received ancillary\nbuffer:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct msghdr\nmsgh; <br>\nstruct cmsghdr *cmsg; <br>\nint received_ttl;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Receive\nauxiliary data in msgh */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for (cmsg =\nCMSG_FIRSTHDR(&amp;msgh); cmsg != NULL; <br>\ncmsg = CMSG_NXTHDR(&amp;msgh, cmsg)) { <br>\nif (cmsg-&gt;cmsg_level == IPPROTO_IP <br>\n&amp;&amp; cmsg-&gt;cmsg_type == IP_TTL) { <br>\nmemcpy(&amp;receive_ttl, CMSG_DATA(cmsg),\nsizeof(received_ttl)); <br>\nbreak; <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if (cmsg ==\nNULL) { <br>\n/* Error: IP_TTL not enabled or small buffer or I/O error */\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The code below\npasses an array of file descriptors over a UNIX domain\nsocket using <b>SCM_RIGHTS</b>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct msghdr\nmsg = { 0 }; <br>\nstruct cmsghdr *cmsg; <br>\nint myfds[NUM_FD]; /* Contains the file descriptors to pass\n*/ <br>\nchar iobuf[1]; <br>\nstruct iovec io = { <br>\n.iov_base = iobuf, <br>\n.iov_len = sizeof(iobuf) <br>\n}; <br>\nunion { /* Ancillary data buffer, wrapped in a union <br>\nin order to ensure it is suitably aligned */ <br>\nchar buf[CMSG_SPACE(sizeof(myfds))]; <br>\nstruct cmsghdr align; <br>\n} u;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">msg.msg_iov =\n&amp;io; <br>\nmsg.msg_iovlen = 1; <br>\nmsg.msg_control = u.buf; <br>\nmsg.msg_controllen = sizeof(u.buf); <br>\ncmsg = CMSG_FIRSTHDR(&amp;msg); <br>\ncmsg-&gt;cmsg_level = SOL_SOCKET; <br>\ncmsg-&gt;cmsg_type = SCM_RIGHTS; <br>\ncmsg-&gt;cmsg_len = CMSG_LEN(sizeof(myfds)); <br>\nmemcpy(CMSG_DATA(cmsg), myfds, sizeof(myfds));</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/recvmsg\">recvmsg(2)</a>,\n<a href=\"https://man.page/2/sendmsg\">sendmsg(2)</a></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">RFC&nbsp;2292</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}