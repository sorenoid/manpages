{"name":"html::element::traverse","description":"HTML::Element::traverse - discussion of HTML::Element&rsquo;s traverse method","body":"\n\n<h1 align=\"center\">HTML::Element::traverse</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Element::traverse\n- discussion of HTML::Element&rsquo;s traverse method</p>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This document\ndescribes version 5.07 of HTML::Element::traverse, released\nAugust 31, 2017 as part of HTML-Tree.</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#\n$element-&gt;traverse is unnecessary and obscure. <br>\n# Don't use it in new code.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;HTML::Element&quot;\nprovides a method &quot;traverse&quot; that traverses the\ntree and calls user-specified callbacks for each node, in\npre- or post-order. However, use of the method is quite\nsuperfluous: if you want to recursively visit every node in\nthe tree, it&rsquo;s almost always simpler to write a\nsubroutine does just that, than it is to bundle up the pre-\nand/or post-order code in callbacks for the\n&quot;traverse&quot; method.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Suppose you\nwant to traverse at/under a node $tree and give elements an\n&rsquo;id&rsquo; attribute unless they already have one.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can use the\n&quot;traverse&quot; method:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">{ <br>\nmy $counter = 'x0000'; <br>\n$start_node-&gt;traverse( <br>\n[ # Callbacks; <br>\n# pre-order callback: <br>\nsub { <br>\nmy $x = $_[0]; <br>\n$x-&gt;attr('id', $counter++) unless defined\n$x-&gt;attr('id'); <br>\nreturn HTML::Element::OK; # keep traversing <br>\n}, <br>\n# post-order callback: <br>\nundef <br>\n], <br>\n1, # don't call the callbacks for text nodes <br>\n); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or you can just\nbe simple and clear (and not have to understand the calling\nformat for &quot;traverse&quot;) by writing a sub that\ntraverses the tree by just calling itself:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">{ <br>\nmy $counter = 'x0000'; <br>\nsub give_id { <br>\nmy $x = $_[0]; <br>\n$x-&gt;attr('id', $counter++) unless defined\n$x-&gt;attr('id'); <br>\nforeach my $c ($x-&gt;content_list) { <br>\ngive_id($c) if ref $c; # ignore text nodes <br>\n} <br>\n}; <br>\ngive_id($start_node); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See,\nisn&rsquo;t that nice and clear?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But, if you\nreally need to know:</p>\n\n<h2>THE TRAVERSE METHOD\n<a name=\"THE TRAVERSE METHOD\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;traverse()&quot; method is a general object-method for\ntraversing a tree or subtree and calling user-specified\ncallbacks. It accepts the following syntaxes: <br>\n$h-&gt;traverse(\\&amp;callback) <br>\nor $h-&gt;traverse(\\&amp;callback, $ignore_text) <br>\nor $h-&gt;traverse( [\\&amp;pre_callback,\\&amp;post_callback]\n, $ignore_text)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These all mean\nto traverse the element and all of its children. That is,\nthis method starts at node $h, &quot;pre-order visits&quot;\n$h, traverses its children, and then will &quot;post-order\nvisit&quot; $h. &quot;Visiting&quot; means that the callback\nroutine is called, with these arguments:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$_[0] : the\nnode (element or text segment), <br>\n$_[1] : a startflag, and <br>\n$_[2] : the depth</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n$ignore_text parameter is given and true, then the pre-order\ncall <i>will not</i> be happen for text content.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The startflag\nis 1 when we enter a node (i.e., in pre-order calls) and 0\nwhen we leave the node (in post-order calls).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note, however,\nthat post-order calls don&rsquo;t happen for nodes that are\ntext segments or are elements that are prototypically empty\n(like &quot;br&quot;, &quot;hr&quot;, etc.).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If we visit\ntext nodes (i.e., unless $ignore_text is given and true),\nthen when text nodes are visited, we will also pass two\nextra arguments to the callback:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$_[3] : the\nelement that's the parent <br>\nof this text node <br>\n$_[4] : the index of this text node <br>\nin its parent's content list</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that you\ncan specify that the pre-order routine can be a different\nroutine from the post-order one:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;traverse(\n[\\&amp;pre_callback,\\&amp;post_callback], ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can also\nspecify that no post-order calls are to be made, by\nproviding a false value as the post-order routine:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;traverse([\n\\&amp;pre_callback,0 ], ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And similarly\nfor suppressing pre-order callbacks:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;traverse([\n0,\\&amp;post_callback ], ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that these\ntwo syntaxes specify the same operation:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;traverse([\\&amp;foo,\\&amp;foo],\n...); <br>\n$h-&gt;traverse( \\&amp;foo , ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The return\nvalues from calls to your pre- or post-order routines are\nsignificant, and are used to control recursion into the\ntree.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These are the\nvalues you can return, listed in descending order of my\nestimation of their usefulness: <br>\nHTML::Element::OK, 1, or any other true value</p>\n\n<p style=\"margin-left:17%;\">...to keep on traversing.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\n&quot;HTML::Element::OK&quot; et al are constants. So if\nyou&rsquo;re running under &quot;use strict&quot; (as I hope\nyou are), and you say: &quot;return\nHTML::Element::PRUEN&quot; the compiler will flag this as an\nerror (an unallowable bareword, specifically), whereas if\nyou spell <small>PRUNE</small> correctly, the compiler will\nnot complain.</p>\n\n<p style=\"margin-left:11%;\">undef, 0, &rsquo;0&rsquo;,\n&rsquo;&rsquo;, or HTML::Element::PRUNE</p>\n\n<p style=\"margin-left:17%;\">...to block traversing under\nthe current element&rsquo;s content. (This is ignored if\nreceived from a post-order callback, since by then the\nrecursion has already happened.) If this is returned by a\npre-order callback, no post-order callback for the current\nnode will happen. (Recall that if your callback exits with\njust &quot;return;&quot;, it is returning undef -- at least\nin scalar context, and &quot;traverse&quot; always calls\nyour callbacks in scalar context.)</p>\n\n<p style=\"margin-left:11%;\">HTML::Element::ABORT</p>\n\n<p style=\"margin-left:17%;\">...to abort the whole traversal\nimmediately. This is often useful when you&rsquo;re looking\nfor just the first node in the tree that meets some\ncriterion of yours.</p>\n\n<p style=\"margin-left:11%;\">HTML::Element::PRUNE_UP</p>\n\n<p style=\"margin-left:17%;\">...to abort continued traversal\ninto this node and its parent node. No post-order callback\nfor the current or parent node will happen.</p>\n\n\n<p style=\"margin-left:11%;\">HTML::Element::PRUNE_SOFTLY</p>\n\n<p style=\"margin-left:17%;\">Like <small>PRUNE,</small>\nexcept that the post-order call for the current node is not\nblocked.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Almost every\ntask to do with extracting information from a tree can be\nexpressed in terms of traverse operations (usually in only\none pass, and usually paying attention to only pre-order, or\nto only post-order), or operations based on traversing. (In\nfact, many of the other methods in this class are basically\ncalls to <b>traverse()</b> with particular arguments.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The source code\nfor HTML::Element and HTML::TreeBuilder contain several\nexamples of the use of the &quot;traverse&quot; method to\ngather information about the content of trees and\nsubtrees.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(Note: you\nshould not change the structure of a tree <i>while</i> you\nare traversing it.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[End of\ndocumentation for the &quot;traverse()&quot; method]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Traversing\nwith Recursive Anonymous Routines</b> <br>\nNow, if you&rsquo;ve been reading <i>Structure and\nInterpretation of Computer Programs</i> too much, maybe you\neven want a recursive lambda. Go ahead:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">{ <br>\nmy $counter = 'x0000'; <br>\nmy $give_id; <br>\n$give_id = sub { <br>\nmy $x = $_[0]; <br>\n$x-&gt;attr('id', $counter++) unless defined\n$x-&gt;attr('id'); <br>\nforeach my $c ($x-&gt;content_list) { <br>\n$give_id-&gt;($c) if ref $c; # ignore text nodes <br>\n} <br>\n}; <br>\n$give_id-&gt;($start_node); <br>\nundef $give_id; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It&rsquo;s a\nbit nutty, and it&rsquo;s <i>still</i> more concise than a\ncall to the &quot;traverse&quot; method!</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is left as\nan exercise to the reader to figure out how to do the same\nthing without using a $give_id symbol at all.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is also left\nas an exercise to the reader to figure out why I undefine\n$give_id, above; and why I could achieved the same effect\nwith any of:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$give_id = 'I\nlike pie!'; <br>\n# or... <br>\n$give_id = []; <br>\n# or even; <br>\n$give_id = sub { print &quot;Mmmm pie!\\n&quot; };</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But not:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$give_id = sub\n{ print &quot;I'm $give_id and I like pie!\\n&quot; }; <br>\n# nor... <br>\n$give_id = \\$give_id; <br>\n# nor... <br>\n$give_id = { 'pie' =&gt; \\$give_id, 'mode' =&gt; 'a la'\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Doing\nRecursive Things Iteratively</b> <br>\nNote that you may at times see an iterative implementation\nof pre-order traversal, like so:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">{ <br>\nmy @to_do = ($tree); # start-node <br>\nwhile(@to_do) { <br>\nmy $this = shift @to_do; <br>\n# &quot;Visit&quot; the node: <br>\n$this-&gt;attr('id', $counter++) <br>\nunless defined $this-&gt;attr('id'); <br>\nunshift @to_do, grep ref $_, $this-&gt;content_list; <br>\n# Put children on the stack -- they'll be visited next <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This can\n<i>under certain circumstances</i> be more efficient than\njust a normal recursive routine, but at the cost of being\nrather obscure. It gains efficiency by avoiding the overhead\nof function-calling, but since there are several method\ndispatches however you do it (to &quot;attr&quot; and\n&quot;content_list&quot;), the overhead for a simple\nfunction call is insignificant.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Pruning and\nWhatnot</b> <br>\nThe &quot;traverse&quot; method does have the fairly neat\nfeatures of the &quot;ABORT&quot;, &quot;PRUNE_UP&quot; and\n&quot;PRUNE_SOFTLY&quot; signals. None of these can be\nimplemented <i>totally</i> straightforwardly with recursive\nroutines, but it is quite possible. &quot;ABORT&quot;-like\nbehavior can be implemented either with using non-local\nreturning with &quot;eval&quot;/&quot;die&quot;:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $died_on; #\nif you need to know where... <br>\nsub thing { <br>\n... visits $_[0]... <br>\n... maybe set $died_on to $_[0] and die\n&quot;ABORT_TRAV&quot; ... <br>\n... else call thing($child) for each child... <br>\n...any post-order visiting $_[0]... <br>\n} <br>\neval { thing($node) }; <br>\nif($@) { <br>\nif($@ =~ m&lt;^ABORT_TRAV&gt;) { <br>\n...it died (aborted) on $died_on... <br>\n} else { <br>\ndie $@; # some REAL error happened <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or you can just\ndo it with flags:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">my($abort_flag,\n$died_on); <br>\nsub thing { <br>\n... visits $_[0]... <br>\n... maybe set $abort_flag = 1; $died_on = $_[0]; return;\n<br>\nforeach my $c ($_[0]-&gt;content_list) { <br>\nthing($c); <br>\nreturn if $abort_flag; <br>\n} <br>\n...any post-order visiting $_[0]... <br>\nreturn; <br>\n} <br>\n$abort_flag = $died_on = undef; <br>\nthing($node); <br>\n...if defined $abort_flag, it died on $died_on</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Element</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Current\nmaintainers:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"68%\">\n\n\n<p>Christopher J. Madsen\n&quot;&lt;perl&nbsp;AT&nbsp;cjmweb.net&gt;&quot;</p> </td>\n<td width=\"15%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"68%\">\n\n\n<p>Jeff Fearn\n&quot;&lt;jfearn&nbsp;AT&nbsp;cpan.org&gt;&quot;</p> </td>\n<td width=\"15%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Original\nHTML-Tree author:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"14%\">\n\n\n<p style=\"margin-top: 1em\">Gisle Aas</p></td>\n<td width=\"69%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Former\nmaintainers:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"54%\">\n\n\n<p style=\"margin-top: 1em\">Sean M. Burke</p></td>\n<td width=\"29%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"54%\">\n\n\n<p>Andy Lester</p></td>\n<td width=\"29%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"54%\">\n\n\n<p>Pete Krawczyk\n&quot;&lt;petek&nbsp;AT&nbsp;cpan.org&gt;&quot;</p> </td>\n<td width=\"29%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can follow\nor contribute to HTML-Tree&rsquo;s development at\n&lt;https://github.com/kentfredric/HTML-Tree&gt;.</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n2000,2001 Sean M. Burke</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#THE TRAVERSE METHOD\">THE TRAVERSE METHOD</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":3}