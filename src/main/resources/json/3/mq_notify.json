{"name":"mq_notify","body":"\n\n<h1 align=\"center\">MQ_NOTIFY</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">mq_notify -\nregister for notification when a message is available</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;mqueue.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nmq_notify(mqd_t</b> <i>mqdes</i><b>, const struct sigevent\n*</b><i>sevp</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Link with\n<i>-lrt</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mq_notify</b>()\nallows the calling process to register or unregister for\ndelivery of an asynchronous notification when a new message\narrives on the empty message queue referred to by the\nmessage queue descriptor <i>mqdes</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>sevp</i>\nargument is a pointer to a <i>sigevent</i> structure. For\nthe definition and general details of this structure, see\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>sevp</i>\nis a non-null pointer, then <b>mq_notify</b>() registers the\ncalling process to receive message notification. The\n<i>sigev_notify</i> field of the <i>sigevent</i> structure\nto which <i>sevp</i> points specifies how notification is to\nbe performed. This field has one of the following values:\n<b><br>\nSIGEV_NONE</b></p>\n\n<p style=\"margin-left:22%;\">A &quot;null&quot;\nnotification: the calling process is registered as the\ntarget for notification, but when a message arrives, no\nnotification is sent.</p>\n\n<p style=\"margin-left:11%;\"><b>SIGEV_SIGNAL</b></p>\n\n<p style=\"margin-left:22%;\">Notify the process by sending\nthe signal specified in <i>sigev_signo</i>. See\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for general details. The <i>si_code</i>\nfield of the <i>siginfo_t</i> structure will be set to\n<b>SI_MESGQ</b>. In addition, <i>si_pid</i> will be set to\nthe PID of the process that sent the message, and\n<i>si_uid</i> will be set to the real user ID of the sending\nprocess.</p>\n\n<p style=\"margin-left:11%;\"><b>SIGEV_THREAD</b></p>\n\n<p style=\"margin-left:22%;\">Upon message delivery, invoke\n<i>sigev_notify_function</i> as if it were the start\nfunction of a new thread. See <a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Only one\nprocess can be registered to receive notification from a\nmessage queue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>sevp</i>\nis NULL, and the calling process is currently registered to\nreceive notifications for this message queue, then the\nregistration is removed; another process can then register\nto receive a message notification for this queue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Message\nnotification occurs only when a new message arrives and the\nqueue was previously empty. If the queue was not empty at\nthe time <b>mq_notify</b>() was called, then a notification\nwill occur only after the queue is emptied and a new message\narrives.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If another\nprocess or thread is waiting to read a message from an empty\nqueue using <a href=\"https://man.page/3/mq_receive\">mq_receive(3)</a>, then any message\nnotification registration is ignored: the message is\ndelivered to the process or thread calling\n<a href=\"https://man.page/3/mq_receive\">mq_receive(3)</a>, and the message notification\nregistration remains in effect.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notification\noccurs once: after a notification is delivered, the\nnotification registration is removed, and another process\ncan register for message notification. If the notified\nprocess wishes to receive the next notification, it can use\n<b>mq_notify</b>() to request a further notification. This\nshould be done before emptying all unread messages from the\nqueue. (Placing the queue in nonblocking mode is useful for\nemptying the queue of messages without blocking once it is\nempty.)</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success\n<b>mq_notify</b>() returns 0; on error, -1 is returned, with\n<i>errno</i> set to indicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The message queue descriptor\nspecified in <i>mqdes</i> is invalid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Another process has already registered to receive\nnotification for this message queue.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p><i>sevp-&gt;sigev_notify</i> is not one of the permitted\nvalues; or <i>sevp-&gt;sigev_notify</i> is\n<b>SIGEV_SIGNAL</b> and <i>sevp-&gt;sigev_signo</i> is not a\nvalid signal number.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Insufficient memory.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2008\nsays that an implementation <i>may</i> generate an\n<b>EINVAL</b> error if <i>sevp</i> is NULL, and the caller\nis not currently registered to receive notifications for the\nqueue <i>mqdes</i>.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3398251.png\" alt=\"Image grohtml-3398251.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>C\nlibrary/kernel differences</b> <br>\nIn the glibc implementation, the <b>mq_notify</b>() library\nfunction is implemented on top of the system call of the\nsame name. When <i>sevp</i> is NULL, or specifies a\nnotification mechanism other than <b>SIGEV_THREAD</b>, the\nlibrary function directly invokes the system call. For\n<b>SIGEV_THREAD</b>, much of the implementation resides\nwithin the library, rather than the kernel. (This is\nnecessarily so, since the thread involved in handling the\nnotification is one that must be managed by the C library\nPOSIX threads implementation.) The implementation involves\nthe use of a raw <a href=\"https://man.page/7/netlink\">netlink(7)</a> socket and creates a new\nthread for each notification that is delivered to the\nprocess.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram registers a notification request for the message\nqueue named in its command-line argument. Notification is\nperformed by creating a thread. The thread executes a\nfunction which reads one message from the queue and then\nterminates the process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;pthread.h&gt; <br>\n#include &lt;mqueue.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error(msg) \\ <br>\ndo { perror(msg); exit(EXIT_FAILURE); } while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void /*\nThread start function */ <br>\ntfunc(union sigval sv) <br>\n{ <br>\nstruct mq_attr attr; <br>\nssize_t nr; <br>\nvoid *buf; <br>\nmqd_t mqdes = *((mqd_t *) sv.sival_ptr);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Determine\nmax. msg size; allocate buffer to receive msg */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(mq_getattr(mqdes, &amp;attr) == -1) <br>\nhandle_error(&quot;mq_getattr&quot;); <br>\nbuf = malloc(attr.mq_msgsize); <br>\nif (buf == NULL) <br>\nhandle_error(&quot;malloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">nr =\nmq_receive(mqdes, buf, attr.mq_msgsize, NULL); <br>\nif (nr == -1) <br>\nhandle_error(&quot;mq_receive&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Read\n%zd bytes from MQ\\n&quot;, nr); <br>\nfree(buf); <br>\nexit(EXIT_SUCCESS); /* Terminate the process */ <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nmqd_t mqdes; <br>\nstruct sigevent sev;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Usage: %s &lt;mq-name&gt;\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">mqdes =\nmq_open(argv[1], O_RDONLY); <br>\nif (mqdes == (mqd_t) -1) <br>\nhandle_error(&quot;mq_open&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sev.sigev_notify\n= SIGEV_THREAD; <br>\nsev.sigev_notify_function = tfunc; <br>\nsev.sigev_notify_attributes = NULL; <br>\nsev.sigev_value.sival_ptr = &amp;mqdes; /* Arg. to thread\nfunc. */ <br>\nif (mq_notify(mqdes, &amp;sev) == -1) <br>\nhandle_error(&quot;mq_notify&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pause(); /*\nProcess will be terminated by thread function */ <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/mq_close\">mq_close(3)</a>,\n<a href=\"https://man.page/3/mq_getattr\">mq_getattr(3)</a>, <a href=\"https://man.page/3/mq_open\">mq_open(3)</a>,\n<a href=\"https://man.page/3/mq_receive\">mq_receive(3)</a>, <a href=\"https://man.page/3/mq_send\">mq_send(3)</a>,\n<a href=\"https://man.page/3/mq_unlink\">mq_unlink(3)</a>, <a href=\"https://man.page/7/mq_overview\">mq_overview(7)</a>,\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}