{"name":"net::http","description":"Net::HTTP - Low-level HTTP connection (client)","body":"\n\n<h1 align=\"center\">Net::HTTP</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::HTTP -\nLow-level HTTP connection (client)</p>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">version\n6.22</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use Net::HTTP;\n<br>\nmy $s = Net::HTTP-&gt;new(Host =&gt;\n&quot;www.perl.com&quot;) || die $@; <br>\n$s-&gt;write_request(GET =&gt; &quot;/&quot;, 'User-Agent'\n=&gt; &quot;Mozilla/5.0&quot;); <br>\nmy($code, $mess, %h) = $s-&gt;read_response_headers; <br>\nwhile (1) { <br>\nmy $buf; <br>\nmy $n = $s-&gt;read_entity_body($buf, 1024); <br>\ndie &quot;read failed: $!&quot; unless defined $n; <br>\nlast unless $n; <br>\nprint $buf; <br>\n}</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;Net::HTTP&quot; class is a low-level\n<small>HTTP</small> client. An instance of the\n&quot;Net::HTTP&quot; class represents a connection to an\n<small>HTTP</small> server. The <small>HTTP</small> protocol\nis described in <small>RFC 2616.</small> The\n&quot;Net::HTTP&quot; class supports &quot;HTTP/1.0&quot;\nand &quot;HTTP/1.1&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;Net::HTTP&quot;\nis a sub-class of one of &quot;IO::Socket::IP&quot;\n(IPv6+IPv4), &quot;IO::Socket::INET6&quot; (IPv6+IPv4), or\n&quot;IO::Socket::INET&quot; (IPv4 only). You can mix the\nmethods described below with reading and writing from the\nsocket directly. This is not necessary a good idea, unless\nyou know what you are doing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethods are provided (in addition to those of\n&quot;IO::Socket::INET&quot;): <br>\n&quot;$s = Net::HTTP-&gt;new( %options )&quot;</p>\n\n<p style=\"margin-left:17%;\">The &quot;Net::HTTP&quot;\nconstructor method takes the same options as\n&quot;IO::Socket::INET&quot;&rsquo;s as well as these:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Host: Initial\nhost attribute value <br>\nKeepAlive: Initial keep_alive attribute value <br>\nSendTE: Initial send_te attribute_value <br>\nHTTPVersion: Initial http_version attribute value <br>\nPeerHTTPVersion: Initial peer_http_version attribute value\n<br>\nMaxLineLength: Initial max_line_length attribute value <br>\nMaxHeaderLines: Initial max_header_lines attribute value</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;Host&quot; option is also the default for\n&quot;IO::Socket::INET&quot;&rsquo;s &quot;PeerAddr&quot;.\nThe &quot;PeerPort&quot; defaults to 80 if not provided. The\n&quot;PeerPort&quot; specification can also be embedded in\nthe &quot;PeerAddr&quot; by preceding it with a\n&quot;:&quot;, and closing the IPv6 address on brackets\n&quot;[]&quot; if necessary:\n&quot;192.0.2.1:80&quot;,&quot;[2001:db8::1]:80&quot;,&quot;any.example.com:80&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;Listen&quot; option provided by\n&quot;IO::Socket::INET&quot;&rsquo;s constructor method is\nnot allowed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If unable to\nconnect to the given <small>HTTP</small> server then the\nconstructor returns &quot;undef&quot; and $@ contains the\nreason. After a successful connect, a &quot;Net:HTTP&quot;\nobject is returned.</p>\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;host&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set the default value of\nthe &quot;Host&quot; header to send. The $host must not be\nset to an empty string (or &quot;undef&quot;) for\n<small>HTTP/1.1.</small></p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;keep_alive&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set the <i>keep-alive</i>\nvalue. If this value is <small>TRUE</small> then the request\nwill be sent with headers indicating that the server should\ntry to keep the connection open so that multiple requests\ncan be sent.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The actual\nheaders set will depend on the value of the\n&quot;http_version&quot; and &quot;peer_http_version&quot;\nattributes.</p>\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;send_te&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set the a value indicating\nif the request will be sent with a &quot;\n<small>TE&quot;</small> header to indicate the transfer\nencodings that the server can choose to use. The list of\nencodings announced as accepted by this client depends on\navailability of the following modules:\n&quot;Compress::Raw::Zlib&quot; for <i>deflate</i>, and\n&quot;IO::Compress::Gunzip&quot; for <i>gzip</i>.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;http_version&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set the <small>HTTP</small>\nversion number that this client should announce. This value\ncan only be set to &quot;1.0&quot; or &quot;1.1&quot;. The\ndefault is &quot;1.1&quot;.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;peer_http_version&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set the protocol version\nnumber of our peer. This value will initially be\n&quot;1.0&quot;, but will be updated by a successful\n<b>read_response_headers()</b> method call.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;max_line_length&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set a limit on the length\nof response line and response header lines. The default is\n8192. A value of 0 means no limit.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;max_header_length&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set a limit on the number\nof header lines that a response can have. The default is\n128. A value of 0 means no limit.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;format_request($method,\n$uri, %headers, [$content])&quot;</p>\n\n<p style=\"margin-left:17%;\">Format a request message and\nreturn it as a string. If the headers do not include a\n&quot;Host&quot; header, then a header is inserted with the\nvalue of the &quot;host&quot; attribute. Headers like\n&quot;Connection&quot; and &quot;Keep-Alive&quot; might also\nbe added depending on the status of the\n&quot;keep_alive&quot; attribute.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If $content is\ngiven (and it is non-empty), then a\n&quot;Content-Length&quot; header is automatically added\nunless it was already present.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;write_request($method,\n$uri, %headers, [$content])&quot;</p>\n\n<p style=\"margin-left:17%;\">Format and send a request\nmessage. Arguments are the same as for\n<b>format_request()</b>. Returns true if successful.</p>\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;format_chunk(\n$data )&quot;</p>\n\n<p style=\"margin-left:17%;\">Returns the string to be\nwritten for the given chunk of data.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;write_chunk($data)&quot;</p>\n\n<p style=\"margin-left:17%;\">Will write a new chunk of\nrequest entity body data. This method should only be used if\nthe &quot;Transfer-Encoding&quot; header with a value of\n&quot;chunked&quot; was sent in the request. Note, writing\nzero-length data is a no-op. Use the\n<b>write_chunk_eof()</b> method to signal end of entity body\ndata.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Returns true if\nsuccessful.</p>\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;format_chunk_eof(\n%trailers )&quot;</p>\n\n<p style=\"margin-left:17%;\">Returns the string to be\nwritten for signaling <small>EOF</small> when a\n&quot;Transfer-Encoding&quot; of &quot;chunked&quot; is\nused.</p>\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;write_chunk_eof(\n%trailers )&quot;</p>\n\n<p style=\"margin-left:17%;\">Will write eof marker for\nchunked data and optional trailers. Note that trailers\nshould not really be used unless is was signaled with a\n&quot;Trailer&quot; header.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Returns true if\nsuccessful.</p>\n\n<p style=\"margin-left:11%;\">&quot;($code, $mess, %headers)\n= $s-&gt;read_response_headers( %opts )&quot;</p>\n\n<p style=\"margin-left:17%;\">Read response headers from\nserver and return it. The $code is the 3 digit\n<small>HTTP</small> status code (see HTTP::Status) and $mess\nis the textual message that came with it. Headers are then\nreturned as key/value pairs. Since key letter casing is not\nnormalized and the same key can even occur multiple times,\nassigning these values directly to a hash is not wise. Only\nthe $code is returned if this method is called in scalar\ncontext.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">As a side\neffect this method updates the\n&rsquo;peer_http_version&rsquo; attribute.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Options might\nbe passed in as key/value pairs. There are currently only\ntwo options supported; &quot;laxed&quot; and\n&quot;junk_out&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;laxed&quot; option will make\n<b>read_response_headers()</b> more forgiving towards\nservers that have not learned how to speak\n<small>HTTP</small> properly. The &quot;laxed&quot; option\nis a boolean flag, and is enabled by passing in a\n<small>TRUE</small> value. The &quot;junk_out&quot; option\ncan be used to capture bad header lines when\n&quot;laxed&quot; is enabled. The value should be an array\nreference. Bad header lines will be pushed onto the\narray.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;laxed&quot; option must be specified in order to\ncommunicate with pre-HTTP/1.0 servers that don&rsquo;t\ndescribe the response outcome or the data they send back\nwith a header block. For these servers peer_http_version is\nset to &quot;0.9&quot; and this method returns (200,\n&quot;Assumed <small>OK&quot;</small> ).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The method will\nraise an exception (die) if the server does not speak proper\n<small>HTTP</small> or if the &quot;max_line_length&quot; or\n&quot;max_header_length&quot; limits are reached. If the\n&quot;laxed&quot; option is turned on and\n&quot;max_line_length&quot; and\n&quot;max_header_length&quot; checks are turned off, then no\nexception will be raised and this method will always return\na response code.</p>\n\n<p style=\"margin-left:11%;\">&quot;$n =\n$s-&gt;read_entity_body($buf, $size);&quot;</p>\n\n<p style=\"margin-left:17%;\">Reads chunks of the entity body\ncontent. Basically the same interface as for <b>read()</b>\nand <b>sysread()</b>, but the buffer offset argument is not\nsupported yet. This method should only be called after a\nsuccessful <b>read_response_headers()</b> call.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The return\nvalue will be &quot;undef&quot; on read errors, 0 on\n<small>EOF,</small> -1 if no data could be returned this\ntime, otherwise the number of bytes assigned to $buf. The\n$buf is set to &quot;&quot; when the return value is -1.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You normally\nwant to retry this call if this function returns either -1\nor &quot;undef&quot; with $! as <small>EINTR</small> or\n<small>EAGAIN</small> (see Errno). <small>EINTR</small> can\nhappen if the application catches signals and\n<small>EAGAIN</small> can happen if you made the socket\nnon-blocking.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This method\nwill raise exceptions (die) if the server does not speak\nproper <small>HTTP.</small> This can only happen when\nreading chunked data.</p>\n\n<p style=\"margin-left:11%;\">&quot;%headers =\n$s-&gt;get_trailers&quot;</p>\n\n<p style=\"margin-left:17%;\">After <b>read_entity_body()</b>\nhas returned 0 to indicate end of the entity body, you might\ncall this method to pick up any trailers.</p>\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;_rbuf&quot;</p>\n\n<p style=\"margin-left:17%;\">Get/set the read buffer\ncontent. The <b>read_response_headers()</b> and\n<b>read_entity_body()</b> methods use an internal buffer\nwhich they will look for data before they actually sysread\nmore from the socket itself. If they read too much, the\nremaining data will be left in this buffer.</p>\n\n\n<p style=\"margin-left:11%;\">&quot;$s-&gt;_rbuf_length&quot;</p>\n\n<p style=\"margin-left:17%;\">Returns the number of bytes in\nthe read buffer. This should always be the same as:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">length($s-&gt;_rbuf)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">but might be\nmore efficient.</p>\n\n<h2>SUBCLASSING\n<a name=\"SUBCLASSING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>read_response_headers()</b> and <b>read_entity_body()</b>\nwill invoke the <b>sysread()</b> method when they need more\ndata. Subclasses might want to override this method to\ncontrol how reading takes place.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The object\nitself is a glob. Subclasses should avoid using hash key\nnames prefixed with &quot;http_&quot; and\n&quot;io_&quot;.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>LWP</small>\n, IO::Socket::INET, Net::HTTP::NB</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Gisle Aas\n&lt;gisle@activestate.com&gt;</p>\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This software\nis copyright (c) 2001 by Gisle Aas.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is free\nsoftware; you can redistribute it and/or modify it under the\nsame terms as the Perl 5 programming language system\nitself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SUBCLASSING\">SUBCLASSING</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT AND LICENSE\">COPYRIGHT AND LICENSE</a>"],"level":3}