{"name":"net::dbus::exporter","body":"\n\n<h1 align=\"center\">Net::DBus::Exporter</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus::Exporter\n- Export object methods and signals to the bus</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"># Define a new\npackage for the object we're going <br>\n# to export <br>\npackage Demo::HelloWorld; <br>\n# Specify the main interface provided by our object <br>\nuse Net::DBus::Exporter qw(org.example.demo.Greeter); <br>\n# We're going to be a DBus object <br>\nuse base qw(Net::DBus::Object); <br>\n# Ensure only explicitly exported methods can be invoked\n<br>\ndbus_strict_exports; <br>\n# Export a 'Greeting' signal taking a stringl string\nparameter <br>\ndbus_signal(&quot;Greeting&quot;, [&quot;string&quot;]);\n<br>\n# Export 'Hello' as a method accepting a single string <br>\n# parameter, and returning a single string value <br>\ndbus_method(&quot;Hello&quot;, [&quot;string&quot;],\n[&quot;string&quot;]); <br>\n# Export 'Goodbye' as a method accepting a single string\n<br>\n# parameter, and returning a single string, but put it <br>\n# in the 'org.exaple.demo.Farewell' interface <br>\ndbus_method(&quot;Goodbye&quot;, [&quot;string&quot;],\n[&quot;string&quot;],\n&quot;org.example.demo.Farewell&quot;);</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;Net::DBus::Exporter&quot; module is used to export\nmethods and signals defined in an object to the message bus.\nSince Perl is a loosely typed language it is not possible to\nautomatically determine correct type information for methods\nto be exported. Thus when sub-classing Net::DBus::Object,\nthis package will provide the type information for methods\nand signals.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When importing\nthis package, an optional argument can be supplied to\nspecify the default interface name to associate with methods\nand signals, for which an explicit interface is not\nspecified. Thus in the common case of objects only providing\na single interface, this removes the need to repeat the\ninterface name against each method exported.</p>\n\n<h2>SCALAR TYPES\n<a name=\"SCALAR TYPES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When specifying\nscalar data types for parameters and return values, the\nfollowing string constants must be used to denote the data\ntype. When values corresponding to these types are\n(un)marshalled they are represented as the Perl\n<small>SCALAR</small> data type (see perldata). <br>\n&quot;string&quot;</p>\n\n<p style=\"margin-left:17%;\">A <small>UTF-8</small> string\nof characters</p>\n\n<p style=\"margin-left:11%;\">&quot;int16&quot;</p>\n\n<p style=\"margin-left:17%;\">A 16-bit signed integer</p>\n\n<p style=\"margin-left:11%;\">&quot;uint16&quot;</p>\n\n<p style=\"margin-left:17%;\">A 16-bit unsigned integer</p>\n\n<p style=\"margin-left:11%;\">&quot;int32&quot;</p>\n\n<p style=\"margin-left:17%;\">A 32-bit signed integer</p>\n\n<p style=\"margin-left:11%;\">&quot;uint32&quot;</p>\n\n<p style=\"margin-left:17%;\">A 32-bit unsigned integer</p>\n\n<p style=\"margin-left:11%;\">&quot;int64&quot;</p>\n\n<p style=\"margin-left:17%;\">A 64-bit signed integer.\n<small>NB,</small> this type is not supported by many builds\nof Perl on 32-bit platforms, so if used, your data is liable\nto be truncated at 32-bits.</p>\n\n<p style=\"margin-left:11%;\">&quot;uint64&quot;</p>\n\n<p style=\"margin-left:17%;\">A 64-bit unsigned integer.\n<small>NB,</small> this type is not supported by many builds\nof Perl on 32-bit platforms, so if used, your data is liable\nto be truncated at 32-bits.</p>\n\n<p style=\"margin-left:11%;\">&quot;byte&quot;</p>\n\n<p style=\"margin-left:17%;\">A single 8-bit byte</p>\n\n<p style=\"margin-left:11%;\">&quot;bool&quot;</p>\n\n<p style=\"margin-left:17%;\">A boolean value</p>\n\n<p style=\"margin-left:11%;\">&quot;double&quot;</p>\n\n<p style=\"margin-left:17%;\">An <small>IEEE</small>\ndouble-precision floating point</p>\n\n<h2>COMPOUND TYPES\n<a name=\"COMPOUND TYPES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When specifying\ncompound data types for parameters and return values, an\narray reference must be used, with the first element being\nthe name of the compound type. <br>\n[&quot;array&quot;, <small>ARRAY-TYPE</small> ]</p>\n\n<p style=\"margin-left:17%;\">An array of values, whose type\nos &quot;ARRAY-TYPE&quot;. The &quot;ARRAY-TYPE&quot; can be\neither a scalar type name, or a nested compound type. When\nvalues corresponding to the array type are (un)marshalled,\nthey are represented as the Perl <small>ARRAY</small> data\ntype (see perldata). If, for example, a method was declared\nto have a single parameter with the type,\n[&quot;array&quot;, &quot;string&quot;], then when calling\nthe method one would provide a array reference of\nstrings:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$object-&gt;hello([&quot;John&quot;,\n&quot;Doe&quot;])</p>\n\n<p style=\"margin-left:11%;\">[&quot;dict&quot;, KEY-TYPE,\n<small>VALUE-TYPE</small> ]</p>\n\n<p style=\"margin-left:17%;\">A dictionary of values, more\ncommonly known as a hash table. The &quot;KEY-TYPE&quot; is\nthe name of the scalar data type used for the dictionary\nkeys. The &quot;VALUE-TYPE&quot; is the name of the scalar,\nor compound data type used for the dictionary values. When\nvalues corresponding to the dict type are (un)marshalled,\nthey are represented as the Perl <small>HASH</small> data\ntype (see perldata). If, for example, a method was declared\nto have a single parameter with the type [&quot;dict&quot;,\n&quot;string&quot;, &quot;string&quot;], then when calling\nthe method one would provide a hash reference of\nstrings,</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$object-&gt;hello({forename\n=&gt; &quot;John&quot;, surname =&gt; &quot;Doe&quot;});</p>\n\n<p style=\"margin-left:11%;\">[&quot;struct&quot;,\n<small>VALUE-TYPE-1, VALUE-TYPE-2</small> ]</p>\n\n<p style=\"margin-left:17%;\">A structure of values, best\nthought of as a variation on the array type where the\nelements can vary. Many languages have an explicit name\nassociated with each value, but since Perl does not have a\nnative representation of structures, they are represented by\nthe <small>LIST</small> data type. If, for exaple, a method\nwas declared to have a single parameter with the type\n[&quot;struct&quot;, &quot;string&quot;,\n&quot;string&quot;], corresponding to the C structure</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct { <br>\nchar *forename; <br>\nchar *surname; <br>\n} name;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">then, when\ncalling the method one would provide an array reference with\nthe values orded to match the structure</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$object-&gt;hello([&quot;John&quot;,\n&quot;Doe&quot;]);</p>\n\n<h2>MAGIC TYPES\n<a name=\"MAGIC TYPES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When specifying\nintrospection data for an exported service, there are a\ncouple of so called &quot;magic&quot; types. Parameters\ndeclared as magic types are not visible to clients, but\ninstead their values are provided automatically by the\nserver side bindings. One use of magic types is to get an\nextra parameter passed with the unique name of the caller\ninvoking the method. <br>\n&quot;caller&quot;</p>\n\n<p style=\"margin-left:17%;\">The value passed in is the\nunique name of the caller of the method. Unique names are\nstrings automatically assigned to client connections by the\nbus daemon, for example &rsquo;:1.15&rsquo;</p>\n\n<p style=\"margin-left:11%;\">&quot;serial&quot;</p>\n\n<p style=\"margin-left:17%;\">The value passed in is an\ninteger within the scope of a caller, which increments on\nevery method call.</p>\n\n<h2>ANNOTATIONS\n<a name=\"ANNOTATIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When exporting\nmethods, signals &amp; properties, in addition to the core\ndata typing information, a number of metadata annotations\nare possible. These are specified by passing a hash\nreference with the desired keys as the last parameter when\ndefining the export. The following annotations are currently\nsupported <br>\nno_return</p>\n\n<p style=\"margin-left:17%;\">Indicate that this method does\nnot return any value, and thus no reply message should be\nsent over the wire, likewise informing the clients not to\nexpect / wait for a reply message</p>\n\n<p style=\"margin-left:11%;\">deprecated</p>\n\n<p style=\"margin-left:17%;\">Indicate that use of this\nmethod/signal/property is discouraged, and it may disappear\naltogether in a future release. Clients will typically print\nout a warning message when a deprecated\nmethod/signal/property is used.</p>\n\n<p style=\"margin-left:11%;\">param_names</p>\n\n<p style=\"margin-left:17%;\">An array of strings specifying\nnames for the input parameters of the method or signal. If\nomitted, no names will be assigned.</p>\n\n<p style=\"margin-left:11%;\">return_names</p>\n\n<p style=\"margin-left:17%;\">An array of strings specifying\nnames for the return parameters of the method. If omitted,\nno names will be assigned.</p>\n\n<p style=\"margin-left:11%;\">strict_exceptions</p>\n\n<p style=\"margin-left:17%;\">Exceptions thrown by this\nmethod which are not of type Net::DBus::Error will not be\ncaught and converted to D-Bus errors. They will be rethrown\nand continue up the stack until something else catches them\n(or the process dies).</p>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">dbus_method($name,\n$params, $returns, [\\%annotations]); <br>\ndbus_method($name, $params, $returns, $interface,\n[\\%annotations]);</p>\n\n<p style=\"margin-left:17%;\">Exports a method called $name,\nhaving parameters whose types are defined by $params, and\nreturning values whose types are defined by $returns. If the\n$interface parameter is provided, then the method is\nassociated with that interface, otherwise the default\ninterface for the calling package is used. The value for the\n$params parameter should be an array reference with each\nelement defining the data type of a parameter to the method.\nLikewise, the $returns parameter should be an array\nreference with each element defining the data type of a\nreturn value. If it not possible to export a method which\naccepts a variable number of parameters, or returns a\nvariable number of values.</p>\n\n\n<p style=\"margin-left:11%;\"><b>dbus_no_strict_exports()</b>;</p>\n\n<p style=\"margin-left:17%;\">If a object is using the\nExporter to generate DBus introspection data, the default\nbehaviour is to only allow invocation of methods which have\nbeen explicitly exported.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">To allow\nclients to access methods which have not been explicitly\nexported, call &quot;dbus_no_strict_exports&quot;.\n<small>NB,</small> doing this may be a security risk if you\nhave methods considered to be &quot;private&quot; for\ninternal use only. As such this method should not normally\nbe used. It is here only to allow switching export behaviour\nto match earlier releases.</p>\n\n<p style=\"margin-left:11%;\">dbus_property($name, $type,\n$access, [\\%attributes]); <br>\ndbus_property($name, $type, $access, $interface,\n[\\%attributes]);</p>\n\n<p style=\"margin-left:17%;\">Exports a property called\n$name, whose data type is $type. If the $interface parameter\nis provided, then the property is associated with that\ninterface, otherwise the default interface for the calling\npackage is used.</p>\n\n<p style=\"margin-left:11%;\">dbus_signal($name, $params,\n[\\%attributes]); <br>\ndbus_signal($name, $params, $interface, [\\%attributes]);</p>\n\n<p style=\"margin-left:17%;\">Exports a signal called $name,\nhaving parameters whose types are defined by $params. If the\n$interface parameter is provided, then the signal is\nassociated with that interface, otherwise the default\ninterface for the calling package is used. The value for the\n$params parameter should be an array reference with each\nelement defining the data type of a parameter to the signal.\nSignals do not have return values. It not possible to export\na signal which has a variable number of parameters.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">No parameters,\nno return values</p>\n\n<p style=\"margin-left:17%;\">A method which simply prints\n&quot;Hello World&quot; each time its called</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sub Hello {\n<br>\nmy $self = shift; <br>\nprint &quot;Hello World\\n&quot;; <br>\n} <br>\ndbus_method(&quot;Hello&quot;, [], []);</p>\n\n<p style=\"margin-left:11%;\">One string parameter, returning\nan boolean value</p>\n\n<p style=\"margin-left:17%;\">A method which accepts a\nprocess name, issues the killall command on it, and returns\na boolean value to indicate whether it was successful.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sub KillAll {\n<br>\nmy $self = shift; <br>\nmy $processname = shift; <br>\nmy $ret = system(&quot;killall $processname&quot;); <br>\nreturn $ret == 0 ? 1 : 0; <br>\n} <br>\ndbus_method(&quot;KillAll&quot;, [&quot;string&quot;],\n[&quot;bool&quot;]);</p>\n\n<p style=\"margin-left:11%;\">One list of strings parameter,\nreturning a dictionary</p>\n\n<p style=\"margin-left:17%;\">A method which accepts a list\nof files names, stats them, and returns a dictionary\ncontaining the last modification times.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sub\nLastModified { <br>\nmy $self = shift; <br>\nmy $files = shift; <br>\nmy %mods; <br>\nforeach my $file (@{$files}) { <br>\n$mods{$file} = (stat $file)[9]; <br>\n} <br>\nreturn \\%mods; <br>\n} <br>\ndbus_method(&quot;LastModified&quot;, [&quot;array&quot;,\n&quot;string&quot;], [&quot;dict&quot;, &quot;string&quot;,\n&quot;int32&quot;]);</p>\n\n<p style=\"margin-left:11%;\">Annotating methods with\nmetdata</p>\n\n<p style=\"margin-left:17%;\">A method which is targeted for\nremoval, and also does not return any value</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sub PlayMP3 {\n<br>\nmy $self = shift; <br>\nmy $track = shift; <br>\nsystem &quot;mpg123 $track &amp;&quot;; <br>\n} <br>\ndbus_method(&quot;PlayMP3&quot;, [&quot;string&quot;], [], {\ndeprecated =&gt; 1, no_return =&gt; 1 });</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Or giving names\nto input parameters:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sub PlayMP3 {\n<br>\nmy $self = shift; <br>\nmy $track = shift; <br>\nsystem &quot;mpg123 $track &amp;&quot;; <br>\n} <br>\ndbus_method(&quot;PlayMP3&quot;, [&quot;string&quot;], [], {\nparam_names =&gt; [&quot;track&quot;] });</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Daniel P.\nBerrange &lt;dan@berrange.com&gt;</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copright (C)\n2004-2011, Daniel Berrange.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus::Object,\nNet::DBus::Binding::Introspector</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SCALAR TYPES\">SCALAR TYPES</a>","<a href=\"#COMPOUND TYPES\">COMPOUND TYPES</a>","<a href=\"#MAGIC TYPES\">MAGIC TYPES</a>","<a href=\"#ANNOTATIONS\">ANNOTATIONS</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>"],"level":3}