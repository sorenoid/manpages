{"name":"uri::escape","body":"\n\n<h1 align=\"center\">URI::Escape</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">URI::Escape -\nPercent-encode and percent-decode unsafe characters</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nURI::Escape; <br>\n$safe = uri_escape(&quot;10% is enough\\n&quot;); <br>\n$verysafe = uri_escape(&quot;foo&quot;,\n&quot;\\0-\\377&quot;); <br>\n$str = uri_unescape($safe);</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\nprovides functions to percent-encode and percent-decode\n<small>URI</small> strings as defined by <small>RFC\n3986.</small> Percent-encoding <small>URI</small> &rsquo;s\nis informally called &quot; <small>URI</small>\nescaping&quot;. This is the terminology used by this module,\nwhich predates the formalization of the terms by the\n<small>RFC</small> by several years.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n<small>URI</small> consists of a restricted set of\ncharacters. The restricted set of characters consists of\ndigits, letters, and a few graphic symbols chosen from those\ncommon to most of the character encodings and input\nfacilities available to Internet users. They are made up of\nthe &quot;unreserved&quot; and &quot;reserved&quot;\ncharacter sets as defined in <small>RFC 3986.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">unreserved =\nALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; /\n&quot;_&quot; / &quot;~&quot; <br>\nreserved = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; /\n&quot;#&quot; / &quot;[&quot; / &quot;]&quot; /\n&quot;@&quot; <br>\n&quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; /\n&quot;'&quot; / &quot;(&quot; / &quot;)&quot; <br>\n/ &quot;*&quot; / &quot;+&quot; / &quot;,&quot; /\n&quot;;&quot; / &quot;=&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nany byte (octet) can be represented in a <small>URI</small>\nby an escape sequence: a triplet consisting of the character\n&quot;%&quot; followed by two hexadecimal digits. A byte can\nalso be represented directly by a character, using the\nUS-ASCII character for that octet.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some of the\ncharacters are <i>reserved</i> for use as delimiters or as\npart of certain <small>URI</small> components. These must be\nescaped if they are to be treated as ordinary data. Read\n<small>RFC 3986</small> for further details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\nprovided (and exported by default) from this module are:\n<br>\nuri_escape( $string ) <br>\nuri_escape( $string, $unsafe )</p>\n\n<p style=\"margin-left:17%;\">Replaces each unsafe character\nin the $string with the corresponding escape sequence and\nreturns the result. The $string argument should be a string\nof bytes. The <b>uri_escape()</b> function will croak if\ngiven a characters with code above 255. Use\n<b>uri_escape_utf8()</b> if you know you have such chars\nor/and want chars in the 128 .. 255 range treated as\n<small>UTF-8.</small></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n<b>uri_escape()</b> function takes an optional second\nargument that overrides the set of characters that are to be\nescaped. The set is specified as a string that can be used\nin a regular expression character class (between [ ]).\nE.g.:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;\\x00-\\x1f\\x7f-\\xff&quot;\n# all control and hi-bit characters <br>\n&quot;a-z&quot; # all lower case characters <br>\n&quot;^A-Za-z&quot; # everything not a letter</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The default set\nof characters to be escaped is all those which are\n<i>not</i> part of the &quot;unreserved&quot; character\nclass shown above as well as the reserved characters. I.e.\nthe default is:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;^A-Za-z0-9\\-\\._~&quot;</p>\n\n<p style=\"margin-left:11%;\">uri_escape_utf8( $string ) <br>\nuri_escape_utf8( $string, $unsafe )</p>\n\n<p style=\"margin-left:17%;\">Works like <b>uri_escape()</b>,\nbut will encode chars as <small>UTF-8</small> before\nescaping them. This makes this function able to deal with\ncharacters with code above 255 in $string. Note that chars\nin the 128 .. 255 range will be escaped differently by this\nfunction compared to what <b>uri_escape()</b> would. For\nchars in the 0 .. 127 range there is no difference.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Equivalent\nto:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">utf8::encode($string);\n<br>\nmy $uri = uri_escape($string);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note:\nJavaScript has a function called <b>escape()</b> that\nproduces the sequence &quot;%uXXXX&quot; for chars in the\n256 .. 65535 range. This function has really nothing to do\nwith <small>URI</small> escaping but some folks got confused\nsince it &quot;does the right thing&quot; in the 0 .. 255\nrange. Because of this you sometimes see &quot;URIs&quot;\nwith these kind of escapes. The JavaScript\n<b>encodeURIComponent()</b> function is similar to\n<b>uri_escape_utf8()</b>.</p>\n\n<p style=\"margin-left:11%;\">uri_unescape($string,...)</p>\n\n<p style=\"margin-left:17%;\">Returns a string with each %XX\nsequence replaced with the actual byte (octet).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This does the\nsame as:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$string =~\ns/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">but does not\nmodify the string in-place as this <small>RE</small> would.\nUsing the <b>uri_unescape()</b> function instead of the\n<small>RE</small> might make the code look cleaner and is a\nfew characters less to type.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In a simple\nbenchmark test I did, calling the function (instead of the\ninline <small>RE</small> above) if a few chars were\nunescaped was something like 40% slower, and something like\n700% slower if none were. If you are going to unescape a lot\nof times it might be a good idea to inline the\n<small>RE.</small></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the\n<b>uri_unescape()</b> function is passed multiple strings,\nthen each one is returned unescaped.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The module can\nalso export the %escapes hash, which contains the mapping\nfrom all 256 bytes to the corresponding escape codes. Lookup\nin this hash is faster than evaluating\n&quot;sprintf(&quot;%%%02X&quot;, ord($byte))&quot; each\ntime.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>URI</small></p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n1995-2004 Gisle Aas.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This program is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":3}