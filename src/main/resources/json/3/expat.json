{"name":"expat","description":"XML::Parser::Expat - Lowlevel access to James Clark&rsquo;s expat XML parser","body":"\n\n<h1 align=\"center\">Expat</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Parser::Expat\n- Lowlevel access to James Clark&rsquo;s expat XML\nparser</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nXML::Parser::Expat; <br>\n$parser = XML::Parser::Expat-&gt;new; <br>\n$parser-&gt;setHandlers('Start' =&gt; \\&amp;sh, <br>\n'End' =&gt; \\&amp;eh, <br>\n'Char' =&gt; \\&amp;ch); <br>\nopen(my $fh, '&lt;', 'info.xml') or die &quot;Couldn't\nopen&quot;; <br>\n$parser-&gt;parse($fh); <br>\nclose($fh); <br>\n# $parser-&gt;parse('&lt;foo id=&quot;me&quot;&gt; here\n&lt;em&gt;we&lt;/em&gt; go &lt;/foo&gt;'); <br>\nsub sh <br>\n{ <br>\nmy ($p, $el, %atts) = @_; <br>\n$p-&gt;setHandlers('Char' =&gt; \\&amp;spec) <br>\nif ($el eq 'special'); <br>\n... <br>\n} <br>\nsub eh <br>\n{ <br>\nmy ($p, $el) = @_; <br>\n$p-&gt;setHandlers('Char' =&gt; \\&amp;ch) # Special elements\nwon't contain <br>\nif ($el eq 'special'); # other special elements <br>\n... <br>\n}</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\nprovides an interface to James Clark&rsquo;s\n<small>XML</small> parser, expat. As in expat, a single\ninstance of the parser can only parse one document. Calls to\nparsestring after the first for a given instance will\ndie.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Expat (and\nXML::Parser::Expat) are event based. As the parser\nrecognizes parts of the document (say the start or end of an\n<small>XML</small> element), then any handlers registered\nfor that type of an event are called with suitable\nparameters.</p>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">new</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">This is a class method, the\nconstructor for XML::Parser::Expat. Options are passed as\nkeyword value pairs. The recognized options are:</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%;\">&bull;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"23%\"></td>\n<td width=\"25%\">\n\n\n<p style=\"margin-top: 1em\">ProtocolEncoding</p></td>\n<td width=\"52%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The protocol\nencoding name. The default is none. The expat built-in\nencodings are: &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;,\n&quot;UTF-16&quot;, and &quot;US-ASCII&quot;. Other\nencodings may be used if they have encoding maps in one of\nthe directories in the @Encoding_Path list. Setting the\nprotocol encoding overrides any encoding in the\n<small>XML</small> declaration.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"15%\">\n\n\n<p style=\"margin-top: 1em\">Namespaces</p></td>\n<td width=\"62%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">When this\noption is given with a true value, then the parser does\nnamespace processing. By default, namespace processing is\nturned off. When it is turned on, the parser consumes\n<i>xmlns</i> attributes and strips off prefixes from element\nand attributes names where those prefixes have a defined\nnamespace. A name&rsquo;s namespace can be found using the\n&quot;namespace&quot; method and two names can be checked\nfor absolute equality with the &quot;eq_name&quot;\nmethod.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">NoExpand</p></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Normally, the\nparser will try to expand references to entities defined in\nthe internal subset. If this option is set to a true value,\nand a default handler is also set, then the default handler\nwill be called when an entity reference is seen in text.\nThis has no effect if a default handler has not been\nregistered, and it has no effect on the expansion of entity\nreferences inside attribute values.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"25%\">\n\n\n<p style=\"margin-top: 1em\">Stream_Delimiter</p></td>\n<td width=\"52%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This option\ntakes a string value. When this string is found alone on a\nline while parsing from a stream, then the parse is ended as\nif it saw an end of file. The intended use is with a stream\nof xml documents in a <small>MIME</small> multipart format.\nThe string should not contain a trailing newline.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"19%\">\n\n\n<p style=\"margin-top: 1em\">ErrorContext</p></td>\n<td width=\"58%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">When this\noption is defined, errors are reported in context. The value\nof ErrorContext should be the number of lines to show on\neither side of the line in which the error occurred.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"20%\">\n\n\n<p style=\"margin-top: 1em\">ParseParamEnt</p></td>\n<td width=\"57%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Unless\nstandalone is set to &quot;yes&quot; in the\n<small>XML</small> declaration, setting this to a true value\nallows the external <small>DTD</small> to be read, and\nparameter entities to be parsed and expanded.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"6%\">\n\n\n<p style=\"margin-top: 1em\">Base</p></td>\n<td width=\"71%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The base to use\nfor relative pathnames or URLs. This can also be done by\nusing the base method.</p>\n\n<p style=\"margin-left:11%;\">setHandlers( <small>TYPE,\nHANDLER</small> [, <small>TYPE, HANDLER</small> [...]])</p>\n\n<p style=\"margin-left:17%;\">This method registers handlers\nfor the various events. If no handlers are registered, then\na call to parsestring or parsefile will only determine if\nthe corresponding <small>XML</small> document is well formed\n(by returning without error.) This may be called from within\na handler, after the parse has started.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Setting a\nhandler to something that evaluates to false unsets that\nhandler.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This method\nreturns a list of type, handler pairs corresponding to the\ninput. The handlers returned are the ones that were in\neffect before the call to setHandlers.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The recognized\nevents and the parameters passed to the corresponding\nhandlers are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p>Start (Parser, Element [, Attr, Val [,...]])</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This event is\ngenerated when an <small>XML</small> start tag is\nrecognized. Parser is an XML::Parser::Expat instance.\nElement is the name of the <small>XML</small> element that\nis opened with the start tag. The Attr &amp; Val pairs are\ngenerated for each attribute in the start tag.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"54%\">\n\n\n<p style=\"margin-top: 1em\">End (Parser, Element)</p></td>\n<td width=\"23%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This event is\ngenerated when an <small>XML</small> end tag is recognized.\nNote that an <small>XML</small> empty tag (&lt;foo/&gt;)\ngenerates both a start and an end event.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">There is always\na lower level start and end handler installed that wrap the\ncorresponding callbacks. This is to handle the context\nmechanism. A consequence of this is that the default handler\n(see below) will not see a start tag or end tag unless the\ndefault_current method is called.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"52%\">\n\n\n<p style=\"margin-top: 1em\">Char (Parser, String)</p></td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This event is\ngenerated when non-markup is recognized. The non-markup\nsequence of characters is in String. A single non-markup\nsequence of characters may generate multiple calls to this\nhandler. Whatever the encoding of the string in the original\ndocument, this is given to the handler in\n<small>UTF-8.</small></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"62%\">\n\n\n<p style=\"margin-top: 1em\">Proc (Parser, Target, Data)</p></td>\n<td width=\"15%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This event is\ngenerated when a processing instruction is recognized.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"52%\">\n\n\n<p style=\"margin-top: 1em\">Comment (Parser, String)</p></td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This event is\ngenerated when a comment is recognized.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"40%\">\n\n\n<p style=\"margin-top: 1em\">CdataStart (Parser)</p></td>\n<td width=\"37%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nat the start of a <small>CDATA</small> section.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"40%\">\n\n\n<p style=\"margin-top: 1em\">CdataEnd (Parser)</p></td>\n<td width=\"37%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nat the end of a <small>CDATA</small> section.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"52%\">\n\n\n<p style=\"margin-top: 1em\">Default (Parser, String)</p></td>\n<td width=\"25%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nfor any characters that don&rsquo;t have a registered\nhandler. This includes both characters that are part of\nmarkup for which no events are generated (markup\ndeclarations) and characters that could generate events, but\nfor which no handler has been registered.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Whatever the\nencoding in the original document, the string is returned to\nthe handler in <small>UTF-8.</small></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">Unparsed (Parser, Entity, Base,\nSysid, Pubid, Notation)</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nfor a declaration of an unparsed entity. Entity is the name\nof the entity. Base is the base to be used for resolving a\nrelative <small>URI.</small> Sysid is the system id. Pubid\nis the public id. Notation is the notation name. Base and\nPubid may be undefined.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">Notation (Parser, Notation,\nBase, Sysid, Pubid)</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nfor a declaration of notation. Notation is the notation\nname. Base is the base to be used for resolving a relative\n<small>URI.</small> Sysid is the system id. Pubid is the\npublic id. Base, Sysid, and Pubid may all be undefined.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"71%\">\n\n\n<p style=\"margin-top: 1em\">ExternEnt (Parser, Base, Sysid,\nPubid)</p> </td>\n<td width=\"6%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nwhen an external entity is referenced. Base is the base to\nbe used for resolving a relative <small>URI.</small> Sysid\nis the system id. Pubid is the public id. Base, and Pubid\nmay be undefined.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This handler\nshould either return a string, which represents the contents\nof the external entity, or return an open filehandle that\ncan be read to obtain the contents of the external entity,\nor return undef, which indicates the external entity\ncouldn&rsquo;t be found and will generate a parse error.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If an open\nfilehandle is returned, it must be returned as either a glob\n(*FOO) or as a reference to a glob (e.g. an instance of\nIO::Handle).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"40%\">\n\n\n<p style=\"margin-top: 1em\">ExternEntFin (Parser)</p></td>\n<td width=\"37%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nafter an external entity has been parsed. It allows\napplications to perform cleanup on actions performed in the\nabove ExternEnt handler.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">Entity (Parser, Name, Val,\nSysid, Pubid, Ndata, IsParam)</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is called\nwhen an entity is declared. For internal entities, the Val\nparameter will contain the value and the remaining three\nparameters will be undefined. For external entities, the Val\nparameter will be undefined, the Sysid parameter will have\nthe system id, the Pubid parameter will have the public id\nif it was provided (it will be undefined otherwise), the\nNdata parameter will contain the notation for unparsed\nentities. If this is a parameter entity declaration, then\nthe IsParam parameter is true.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note that this\nhandler and the Unparsed handler above overlap. If both are\nset, then this handler will not be called for unparsed\nentities.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"60%\">\n\n\n<p style=\"margin-top: 1em\">Element (Parser, Name,\nModel)</p> </td>\n<td width=\"17%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The element\nhandler is called when an element declaration is found. Name\nis the element name, and Model is the content model as an\nXML::Parser::ContentModel object. See\n&quot;XML::Parser::ContentModel Methods&quot; for methods\navailable for this class.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">Attlist (Parser, Elname,\nAttname, Type, Default, Fixed)</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This handler is\ncalled for each attribute in an <small>ATTLIST</small>\ndeclaration. So an <small>ATTLIST</small> declaration that\nhas multiple attributes will generate multiple calls to this\nhandler. The Elname parameter is the name of the element\nwith which the attribute is being associated. The Attname\nparameter is the name of the attribute. Type is the\nattribute type, given as a string. Default is the default\nvalue, which will either be &quot;#REQUIRED&quot;,\n&quot;#IMPLIED&quot; or a quoted string (i.e. the returned\nstring will begin and end with a quote character). If Fixed\nis true, then this is a fixed attribute.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">Doctype (Parser, Name, Sysid,\nPubid, Internal)</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This handler is\ncalled for <small>DOCTYPE</small> declarations. Name is the\ndocument type name. Sysid is the system id of the document\ntype, if it was provided, otherwise it&rsquo;s undefined.\nPubid is the public id of the document type, which will be\nundefined if no public id was given. Internal will be true\nor false, indicating whether or not the doctype declaration\ncontains an internal subset.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"40%\">\n\n\n<p style=\"margin-top: 1em\">DoctypeFin (Parser)</p></td>\n<td width=\"37%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This handler is\ncalled after parsing of the <small>DOCTYPE</small>\ndeclaration has finished, including any internal or external\n<small>DTD</small> declarations.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p style=\"margin-top: 1em\">XMLDecl (Parser, Version,\nEncoding, Standalone)</p></td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This handler is\ncalled for <small>XML</small> declarations. Version is a\nstring containing the version. Encoding is either undefined\nor contains an encoding string. Standalone is either\nundefined, or true or false. Undefined indicates that no\nstandalone parameter was given in the <small>XML</small>\ndeclaration. True or false indicates &quot;yes&quot; or\n&quot;no&quot; respectively.</p>\n\n<p style=\"margin-left:11%;\">namespace(name)</p>\n\n<p style=\"margin-left:17%;\">Return the <small>URI</small>\nof the namespace that the name belongs to. If the name\ndoesn&rsquo;t belong to any namespace, an undef is returned.\nThis is only valid on names received through the Start or\nEnd handlers from a single document, or through a call to\nthe generate_ns_name method. In other words, don&rsquo;t use\nnames generated from one instance of XML::Parser::Expat with\nother instances.</p>\n\n<p style=\"margin-left:11%;\">eq_name(name1, name2)</p>\n\n<p style=\"margin-left:17%;\">Return true if name1 and name2\nare identical (i.e. same name and from the same namespace.)\nThis is only meaningful if both names were obtained through\nthe Start or End handlers from a single document, or through\na call to the generate_ns_name method.</p>\n\n<p style=\"margin-left:11%;\">generate_ns_name(name,\nnamespace)</p>\n\n<p style=\"margin-left:17%;\">Return a name, associated with\na given namespace, good for using with the above 2 methods.\nThe namespace argument should be the namespace\n<small>URI,</small> not a prefix.</p>\n\n<p style=\"margin-left:11%;\">new_ns_prefixes</p>\n\n<p style=\"margin-left:17%;\">When called from a start tag\nhandler, returns namespace prefixes declared with this start\ntag. If called elsewhere (or if there were no namespace\nprefixes declared), it returns an empty list. Setting of the\ndefault namespace is indicated with &rsquo;#default&rsquo;\nas a prefix.</p>\n\n<p style=\"margin-left:11%;\">expand_ns_prefix(prefix)</p>\n\n<p style=\"margin-left:17%;\">Return the uri to which the\ngiven prefix is currently bound. Returns undef if the prefix\nisn&rsquo;t currently bound. Use &rsquo;#default&rsquo; to\nfind the current binding of the default namespace (if\nany).</p>\n\n<p style=\"margin-left:11%;\">current_ns_prefixes</p>\n\n<p style=\"margin-left:17%;\">Return a list of currently\nbound namespace prefixes. The order of the the prefixes in\nthe list has no meaning. If the default namespace is\ncurrently bound, &rsquo;#default&rsquo; appears in the\nlist.</p>\n\n<p style=\"margin-left:11%;\">recognized_string</p>\n\n<p style=\"margin-left:17%;\">Returns the string from the\ndocument that was recognized in order to call the current\nhandler. For instance, when called from a start handler, it\nwill give us the start-tag string. The string is encoded in\n<small>UTF-8.</small> This method doesn&rsquo;t return a\nmeaningful string inside declaration handlers.</p>\n\n<p style=\"margin-left:11%;\">original_string</p>\n\n<p style=\"margin-left:17%;\">Returns the verbatim string\nfrom the document that was recognized in order to call the\ncurrent handler. The string is in the original document\nencoding. This method doesn&rsquo;t return a meaningful\nstring inside declaration handlers.</p>\n\n<p style=\"margin-left:11%;\">default_current</p>\n\n<p style=\"margin-left:17%;\">When called from a handler,\ncauses the sequence of characters that generated the\ncorresponding event to be sent to the default handler (if\none is registered). Use of this method is deprecated in\nfavor the recognized_string method, which you can use\nwithout installing a default handler. This method\ndoesn&rsquo;t deliver a meaningful string to the default\nhandler when called from inside declaration handlers.</p>\n\n<p style=\"margin-left:11%;\">xpcroak(message)</p>\n\n<p style=\"margin-left:17%;\">Concatenate onto the given\nmessage the current line number within the\n<small>XML</small> document plus the message implied by\nErrorContext. Then croak with the formed message.</p>\n\n<p style=\"margin-left:11%;\">xpcarp(message)</p>\n\n<p style=\"margin-left:17%;\">Concatenate onto the given\nmessage the current line number within the\n<small>XML</small> document plus the message implied by\nErrorContext. Then carp with the formed message.</p>\n\n<p style=\"margin-left:11%;\">current_line</p>\n\n<p style=\"margin-left:17%;\">Returns the line number of the\ncurrent position of the parse.</p>\n\n<p style=\"margin-left:11%;\">current_column</p>\n\n<p style=\"margin-left:17%;\">Returns the column number of\nthe current position of the parse.</p>\n\n<p style=\"margin-left:11%;\">current_byte</p>\n\n<p style=\"margin-left:17%;\">Returns the current position of\nthe parse.</p>\n\n<p style=\"margin-left:11%;\">base([ <small>NEWBASE</small>\n]);</p>\n\n<p style=\"margin-left:17%;\">Returns the current value of\nthe base for resolving relative URIs. If\n<small>NEWBASE</small> is supplied, changes the base to that\nvalue.</p>\n\n<p style=\"margin-left:11%;\">context</p>\n\n<p style=\"margin-left:17%;\">Returns a list of element names\nthat represent open elements, with the last one being the\ninnermost. Inside start and end tag handlers, this will be\nthe tag of the parent element.</p>\n\n<p style=\"margin-left:11%;\">current_element</p>\n\n<p style=\"margin-left:17%;\">Returns the name of the\ninnermost currently opened element. Inside start or end\nhandlers, returns the parent of the element associated with\nthose tags.</p>\n\n<p style=\"margin-left:11%;\">in_element( <small>NAME</small>\n)</p>\n\n<p style=\"margin-left:17%;\">Returns true if\n<small>NAME</small> is equal to the name of the innermost\ncurrently opened element. If namespace processing is being\nused and you want to check against a name that may be in a\nnamespace, then use the generate_ns_name method to create\nthe <small>NAME</small> argument.</p>\n\n<p style=\"margin-left:11%;\">within_element(\n<small>NAME</small> )</p>\n\n<p style=\"margin-left:17%;\">Returns the number of times the\ngiven name appears in the context list. If namespace\nprocessing is being used and you want to check against a\nname that may be in a namespace, then use the\ngenerate_ns_name method to create the <small>NAME</small>\nargument.</p>\n\n<p style=\"margin-left:11%;\">depth</p>\n\n<p style=\"margin-left:17%;\">Returns the size of the context\nlist.</p>\n\n<p style=\"margin-left:11%;\">element_index</p>\n\n<p style=\"margin-left:17%;\">Returns an integer that is the\ndepth-first visit order of the current element. This will be\nzero outside of the root element. For example, this will\nreturn 1 when called from the start handler for the root\nelement start tag.</p>\n\n<p style=\"margin-left:11%;\">skip_until(\n<small>INDEX</small> )</p>\n\n<p style=\"margin-left:17%;\"><small>INDEX</small> is an\ninteger that represents an element index. When this method\nis called, all handlers are suspended until the start tag\nfor an element that has an index number equal to\n<small>INDEX</small> is seen. If a start handler has been\nset, then this is the first tag that the start handler will\nsee after skip_until has been called.</p>\n\n<p style=\"margin-left:11%;\">position_in_context(\n<small>LINES</small> )</p>\n\n<p style=\"margin-left:17%;\">Returns a string that shows the\ncurrent parse position. <small>LINES</small> should be an\ninteger &gt;= 0 that represents the number of lines on\neither side of the current parse line to place into the\nreturned string.</p>\n\n<p style=\"margin-left:11%;\">xml_escape( <small>TEXT</small>\n[, <small>CHAR</small> [, <small>CHAR ...</small> ]])</p>\n\n<p style=\"margin-left:17%;\">Returns <small>TEXT</small>\nwith markup characters turned into character entities. Any\nadditional characters provided as arguments are also turned\ninto character references where found in\n<small>TEXT.</small></p>\n\n<p style=\"margin-left:11%;\">parse ( <small>SOURCE</small>\n)</p>\n\n<p style=\"margin-left:17%;\">The <small>SOURCE</small>\nparameter should either be a string containing the whole\n<small>XML</small> document, or it should be an open\nIO::Handle. Only a single document may be parsed for a given\ninstance of XML::Parser::Expat, so this will croak if\nit&rsquo;s been called previously for this instance.</p>\n\n<p style=\"margin-left:11%;\">parsestring(\n<small>XML_DOC_STRING</small> )</p>\n\n<p style=\"margin-left:17%;\">Parses the given string as an\n<small>XML</small> document. Only a single document may be\nparsed for a given instance of XML::Parser::Expat, so this\nwill die if either parsestring or parsefile has been called\nfor this instance previously.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This method is\ndeprecated in favor of the parse method.</p>\n\n<p style=\"margin-left:11%;\">parsefile(\n<small>FILENAME</small> )</p>\n\n<p style=\"margin-left:17%;\">Parses the <small>XML</small>\ndocument in the given file. Will die if parsestring or\nparsefile has been called previously for this instance.</p>\n\n<p style=\"margin-left:11%;\">is_defaulted(\n<small>ATTNAME</small> )</p>\n\n<p style=\"margin-left:17%;\"><small>NO LONGER WORKS.</small>\nTo find out if an attribute is defaulted please use the\nspecified_attr method.</p>\n\n<p style=\"margin-left:11%;\">specified_attr</p>\n\n<p style=\"margin-left:17%;\">When the start handler receives\nlists of attributes and values, the non-defaulted (i.e.\nexplicitly specified) attributes occur in the list first.\nThis method returns the number of specified items in the\nlist. So if this number is equal to the length of the list,\nthere were no defaulted values. Otherwise the number points\nto the index of the first defaulted attribute name.</p>\n\n<p style=\"margin-left:11%;\">finish</p>\n\n<p style=\"margin-left:17%;\">Unsets all handlers (including\ninternal ones that set context), but expat continues parsing\nto the end of the document or until it finds an error. It\nshould finish up a lot faster than with the handlers\nset.</p>\n\n<p style=\"margin-left:11%;\">release</p>\n\n<p style=\"margin-left:17%;\">There are data structures used\nby XML::Parser::Expat that have circular references. This\nmeans that these structures will never be garbage collected\nunless these references are explicitly broken. Calling this\nmethod breaks those references (and makes the instance\nunusable.)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Normally,\nhigher level calls handle this for you, but if you are using\nXML::Parser::Expat directly, then it&rsquo;s your\nresponsibility to call it.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Parser::ContentModel\nMethods</b> <br>\nThe element declaration handlers are passed objects of this\nclass as the content model of the element declaration. They\nalso represent content particles, components of a content\nmodel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When referred\nto as a string, these objects are automagicly converted to a\nstring representation of the model (or content particle).\n<br>\nisempty</p>\n\n<p style=\"margin-left:17%;\">This method returns true if the\nobject is &quot; <small>EMPTY&quot;,</small> false\notherwise.</p>\n\n<p style=\"margin-left:11%;\">isany</p>\n\n<p style=\"margin-left:17%;\">This method returns true if the\nobject is &quot; <small>ANY&quot;,</small> false\notherwise.</p>\n\n<p style=\"margin-left:11%;\">ismixed</p>\n\n<p style=\"margin-left:17%;\">This method returns true if the\nobject is &quot;(#PCDATA)&quot; or\n&quot;(#PCDATA|...)*&quot;, false otherwise.</p>\n\n<p style=\"margin-left:11%;\">isname</p>\n\n<p style=\"margin-left:17%;\">This method returns if the\nobject is an element name.</p>\n\n<p style=\"margin-left:11%;\">ischoice</p>\n\n<p style=\"margin-left:17%;\">This method returns true if the\nobject is a choice of content particles.</p>\n\n<p style=\"margin-left:11%;\">isseq</p>\n\n<p style=\"margin-left:17%;\">This method returns true if the\nobject is a sequence of content particles.</p>\n\n<p style=\"margin-left:11%;\">quant</p>\n\n<p style=\"margin-left:17%;\">This method returns undef or a\nstring representing the quantifier (&rsquo;?&rsquo;,\n&rsquo;*&rsquo;, &rsquo;+&rsquo;) associated with the model\nor particle.</p>\n\n<p style=\"margin-left:11%;\">children</p>\n\n<p style=\"margin-left:17%;\">This method returns undef or\n(for mixed, choice, and sequence types) an array of\ncomponent content particles. There will always be at least\none component for choices and sequences, but for a mixed\ncontent model of pure <small>PCDATA, &quot;</small>\n(#PCDATA)&quot;, then an undef is returned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Parser::ExpatNB\nMethods</b> <br>\nThe class XML::Parser::ExpatNB is a subclass of\nXML::Parser::Expat used for non-blocking access to the expat\nlibrary. It does not support the parse, parsestring, or\nparsefile methods, but it does have these additional\nmethods: <br>\nparse_more( <small>DATA</small> )</p>\n\n<p style=\"margin-left:17%;\">Feed expat more text to munch\non.</p>\n\n<p style=\"margin-left:11%;\">parse_done</p>\n\n<p style=\"margin-left:17%;\">Tell expat that it&rsquo;s\ngotten the whole document.</p>\n\n<h2>FUNCTIONS\n<a name=\"FUNCTIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Parser::Expat::load_encoding(\n<small>ENCODING</small> )</p>\n\n<p style=\"margin-left:17%;\">Load an external encoding.\n<small>ENCODING</small> is either the name of an encoding or\nthe name of a file. The basename is converted to lowercase\nand a &rsquo;.enc&rsquo; extension is appended unless\nthere&rsquo;s one already there. Then, unless it&rsquo;s an\nabsolute pathname (i.e. begins with &rsquo;/&rsquo;), the\nfirst file by that name discovered in the @Encoding_Path\npath list is used.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The encoding in\nthe file is loaded and kept in the %Encoding_Table table.\nEarlier encodings of the same name are replaced.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This function\nis automatically called by expat when it encounters an\nencoding it doesn&rsquo;t know about. Expat shouldn&rsquo;t\ncall this twice for the same encoding name. The only reason\nusers should use this function is to explicitly load an\nencoding not contained in the @Encoding_Path list.</p>\n\n<h2>AUTHORS\n<a name=\"AUTHORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Larry Wall\n&lt;<i>larry@wall.org</i>&gt; wrote version 1.0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Clark Cooper\n&lt;<i>coopercc@netheaven.com</i>&gt; picked up support,\nchanged the <small>API</small> for this version (2.x),\nprovided documentation, and added some standard package\nfeatures.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#FUNCTIONS\">FUNCTIONS</a>","<a href=\"#AUTHORS\">AUTHORS</a>"],"level":3}