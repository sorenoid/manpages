{"name":"fopencookie","body":"\n\n<h1 align=\"center\">FOPENCOOKIE</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fopencookie -\nopening a custom stream</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;stdio.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>FILE\n*fopencookie(void *</b><i>cookie</i><b>, const char\n*</b><i>mode</i><b>, <br>\ncookie_io_functions_t</b> <i>io_funcs</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>fopencookie</b>() function allows the programmer to\ncreate a custom implementation for a standard I/O stream.\nThis implementation can store the stream&rsquo;s data at a\nlocation of its own choosing; for example,\n<b>fopencookie</b>() is used to implement\n<a href=\"https://man.page/3/fmemopen\">fmemopen(3)</a>, which provides a stream interface to\ndata that is stored in a buffer in memory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to\ncreate a custom stream the programmer must:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Implement four &quot;hook&quot; functions that are used\ninternally by the standard I/O library when performing I/O\non the stream.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Define a &quot;cookie&quot; data type, a structure that\nprovides bookkeeping information (e.g., where to store data)\nused by the aforementioned hook functions. The standard I/O\npackage knows nothing about the contents of this cookie\n(thus it is typed as <i>void&nbsp;*</i> when passed to\n<b>fopencookie</b>()), but automatically supplies the cookie\nas the first argument when calling the hook functions.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Call <b>fopencookie</b>() to open a new stream and\nassociate the cookie and hook functions with that\nstream.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>fopencookie</b>() function serves a purpose similar to\n<a href=\"https://man.page/3/fopen\">fopen(3)</a>: it opens a new stream and returns a pointer\nto a <i>FILE</i> object that is used to operate on that\nstream.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>cookie</i> argument is a pointer to the caller&rsquo;s\ncookie structure that is to be associated with the new\nstream. This pointer is supplied as the first argument when\nthe standard I/O library invokes any of the hook functions\ndescribed below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>mode</i>\nargument serves the same purpose as for <a href=\"https://man.page/3/fopen\">fopen(3)</a>. The\nfollowing modes are supported: <i>r</i>, <i>w</i>, <i>a</i>,\n<i>r+</i>, <i>w+</i>, and <i>a+</i>. See <a href=\"https://man.page/3/fopen\">fopen(3)</a> for\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>io_funcs</i> argument is a structure that contains four\nfields pointing to the programmer-defined hook functions\nthat are used to implement this stream. The structure is\ndefined as follows</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">typedef struct\n{ <br>\ncookie_read_function_t *read; <br>\ncookie_write_function_t *write; <br>\ncookie_seek_function_t *seek; <br>\ncookie_close_function_t *close; <br>\n} cookie_io_functions_t;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The four fields\nare as follows: <i><br>\ncookie_read_function_t *read</i></p>\n\n<p style=\"margin-left:22%;\">This function implements read\noperations for the stream. When called, it receives three\narguments:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">ssize_t\nread(void *cookie, char *buf, size_t size);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>buf</i>\nand <i>size</i> arguments are, respectively, a buffer into\nwhich input data can be placed and the size of that buffer.\nAs its function result, the <i>read</i> function should\nreturn the number of bytes copied into <i>buf</i>, 0 on end\nof file, or -1 on error. The <i>read</i> function should\nupdate the stream offset appropriately.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>*read</i>\nis a null pointer, then reads from the custom stream always\nreturn end of file.</p>\n\n<p style=\"margin-left:11%;\"><i>cookie_write_function_t\n*write</i></p>\n\n<p style=\"margin-left:22%;\">This function implements write\noperations for the stream. When called, it receives three\narguments:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">ssize_t\nwrite(void *cookie, const char *buf, size_t size);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>buf</i>\nand <i>size</i> arguments are, respectively, a buffer of\ndata to be output to the stream and the size of that buffer.\nAs its function result, the <i>write</i> function should\nreturn the number of bytes copied from <i>buf</i>, or 0 on\nerror. (The function must not return a negative value.) The\n<i>write</i> function should update the stream offset\nappropriately.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>*write</i> is a null pointer, then output to the stream\nis discarded.</p>\n\n<p style=\"margin-left:11%;\"><i>cookie_seek_function_t\n*seek</i></p>\n\n<p style=\"margin-left:22%;\">This function implements seek\noperations on the stream. When called, it receives three\narguments:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">int seek(void\n*cookie, off64_t *offset, int whence);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>*offset</i> argument specifies the new file offset\ndepending on which of the following three values is supplied\nin <i>whence</i>: <b><br>\nSEEK_SET</b></p>\n\n<p style=\"margin-left:32%;\">The stream offset should be set\n<i>*offset</i> bytes from the start of the stream.</p>\n\n<p style=\"margin-left:22%;\"><b>SEEK_CUR</b></p>\n\n<p style=\"margin-left:32%;\"><i>*offset</i> should be added\nto the current stream offset.</p>\n\n<p style=\"margin-left:22%;\"><b>SEEK_END</b></p>\n\n<p style=\"margin-left:32%;\">The stream offset should be set\nto the size of the stream plus <i>*offset</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Before\nreturning, the <i>seek</i> function should update\n<i>*offset</i> to indicate the new stream offset.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">As its function\nresult, the <i>seek</i> function should return 0 on success,\nand -1 on error.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If <i>*seek</i>\nis a null pointer, then it is not possible to perform seek\noperations on the stream.</p>\n\n<p style=\"margin-left:11%;\"><i>cookie_close_function_t\n*close</i></p>\n\n<p style=\"margin-left:22%;\">This function closes the\nstream. The hook function can do things such as freeing\nbuffers allocated for the stream. When called, it receives\none argument:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">int close(void\n*cookie);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>cookie</i> argument is the cookie that the programmer\nsupplied when calling <b>fopencookie</b>().</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">As its function\nresult, the <i>close</i> function should return 0 on\nsuccess, and <b>EOF</b> on error.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If\n<i>*close</i> is NULL, then no special action is performed\nwhen the stream is closed.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success\n<b>fopencookie</b>() returns a pointer to the new stream. On\nerror, NULL is returned.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\">\n</td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n</table>\n\n\n<p align=\"center\"><img src=\"grohtml-3281981.png\" alt=\"Image grohtml-3281981.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\nis a nonstandard GNU extension.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow implements a custom stream whose functionality is\nsimilar (but not identical) to that available via\n<a href=\"https://man.page/3/fmemopen\">fmemopen(3)</a>. It implements a stream whose data is\nstored in a memory buffer. The program writes its\ncommand-line arguments to the stream, and then seeks through\nthe stream reading two out of every five characters and\nwriting them to standard output. The following shell session\ndemonstrates the use of the program:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out\n'hello world'</b> <br>\n/he/ <br>\n/ w/ <br>\n/d/ <br>\nReached end of file</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that a\nmore general version of the program below could be improved\nto more robustly handle various error situations (e.g.,\nopening a stream with a cookie that already has an open\nstream; closing a stream that has already been closed).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;sys/types.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nINIT_BUF_SIZE 4</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct\nmemfile_cookie { <br>\nchar *buf; /* Dynamically sized buffer for data */ <br>\nsize_t allocated; /* Size of buf */ <br>\nsize_t endpos; /* Number of characters in buf */ <br>\noff_t offset; /* Current file offset in buf */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ssize_t <br>\nmemfile_write(void *c, const char *buf, size_t size) <br>\n{ <br>\nchar *new_buff; <br>\nstruct memfile_cookie *cookie = c;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Buffer too\nsmall? Keep doubling size until big enough */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while (size +\ncookie-&gt;offset &gt; cookie-&gt;allocated) { <br>\nnew_buff = realloc(cookie-&gt;buf, cookie-&gt;allocated *\n2); <br>\nif (new_buff == NULL) { <br>\nreturn -1; <br>\n} else { <br>\ncookie-&gt;allocated *= 2; <br>\ncookie-&gt;buf = new_buff; <br>\n} <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">memcpy(cookie-&gt;buf\n+ cookie-&gt;offset, buf, size);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cookie-&gt;offset\n+= size; <br>\nif (cookie-&gt;offset &gt; cookie-&gt;endpos) <br>\ncookie-&gt;endpos = cookie-&gt;offset;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return size;\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ssize_t <br>\nmemfile_read(void *c, char *buf, size_t size) <br>\n{ <br>\nssize_t xbytes; <br>\nstruct memfile_cookie *cookie = c;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Fetch\nminimum of bytes requested and bytes available */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">xbytes = size;\n<br>\nif (cookie-&gt;offset + size &gt; cookie-&gt;endpos) <br>\nxbytes = cookie-&gt;endpos - cookie-&gt;offset; <br>\nif (xbytes &lt; 0) /* offset may be past endpos */ <br>\nxbytes = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">memcpy(buf,\ncookie-&gt;buf + cookie-&gt;offset, xbytes);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cookie-&gt;offset\n+= xbytes; <br>\nreturn xbytes; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmemfile_seek(void *c, off64_t *offset, int whence) <br>\n{ <br>\noff64_t new_offset; <br>\nstruct memfile_cookie *cookie = c;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (whence ==\nSEEK_SET) <br>\nnew_offset = *offset; <br>\nelse if (whence == SEEK_END) <br>\nnew_offset = cookie-&gt;endpos + *offset; <br>\nelse if (whence == SEEK_CUR) <br>\nnew_offset = cookie-&gt;offset + *offset; <br>\nelse <br>\nreturn -1;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (new_offset\n&lt; 0) <br>\nreturn -1;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cookie-&gt;offset\n= new_offset; <br>\n*offset = new_offset; <br>\nreturn 0; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmemfile_close(void *c) <br>\n{ <br>\nstruct memfile_cookie *cookie = c;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">free(cookie-&gt;buf);\n<br>\ncookie-&gt;allocated = 0; <br>\ncookie-&gt;buf = NULL;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return 0; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\ncookie_io_functions_t memfile_func = { <br>\n.read = memfile_read, <br>\n.write = memfile_write, <br>\n.seek = memfile_seek, <br>\n.close = memfile_close <br>\n}; <br>\nFILE *stream; <br>\nstruct memfile_cookie mycookie; <br>\nsize_t nread; <br>\nchar buf[1000];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Set up the\ncookie before calling fopencookie() */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">mycookie.buf =\nmalloc(INIT_BUF_SIZE); <br>\nif (mycookie.buf == NULL) { <br>\nperror(&quot;malloc&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">mycookie.allocated\n= INIT_BUF_SIZE; <br>\nmycookie.offset = 0; <br>\nmycookie.endpos = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">stream =\nfopencookie(&amp;mycookie,&quot;w+&quot;, memfile_func);\n<br>\nif (stream == NULL) { <br>\nperror(&quot;fopencookie&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Write\ncommand-line arguments to our file */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 1;\nj &lt; argc; j++) <br>\nif (fputs(argv[j], stream) == EOF) { <br>\nperror(&quot;fputs&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Read two\nbytes out of every five, until EOF */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (long p =\n0; ; p += 5) { <br>\nif (fseek(stream, p, SEEK_SET) == -1) { <br>\nperror(&quot;fseek&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nnread = fread(buf, 1, 2, stream); <br>\nif (nread == 0) { <br>\nif (ferror(stream) != 0) { <br>\nfprintf(stderr, &quot;fread failed\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nprintf(&quot;Reached end of file\\n&quot;); <br>\nbreak; <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;/%.*s/\\n&quot;,\n(int) nread, buf); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/fclose\">fclose(3)</a>,\n<a href=\"https://man.page/3/fmemopen\">fmemopen(3)</a>, <a href=\"https://man.page/3/fopen\">fopen(3)</a>, <a href=\"https://man.page/3/fseek\">fseek(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}