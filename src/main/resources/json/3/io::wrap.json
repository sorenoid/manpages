{"name":"io::wrap","body":"\n\n<h1 align=\"center\">IO::Wrap</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::Wrap - wrap\nraw filehandles in IO::Handle interface</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use IO::Wrap;\n<br>\n### Do stuff with any kind of filehandle (including a bare\nglobref), or <br>\n### any kind of blessed object that responds to a print()\nmessage. <br>\n### <br>\nsub do_stuff { <br>\nmy $fh = shift; <br>\n### At this point, we have no idea what the user gave us...\n<br>\n### a globref? a FileHandle? a scalar filehandle name? <br>\n$fh = wraphandle($fh); <br>\n### At this point, we know we have an IO::Handle-like\nobject! <br>\n$fh-&gt;print(&quot;Hey there!&quot;); <br>\n... <br>\n}</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Let&rsquo;s say\nyou want to write some code which does I/O, but you\ndon&rsquo;t want to force the caller to provide you with a\nFileHandle or IO::Handle object. You want them to be able to\nsay:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">do_stuff(\\*STDOUT);\n<br>\ndo_stuff('STDERR'); <br>\ndo_stuff($some_FileHandle_object); <br>\ndo_stuff($some_IO_Handle_object);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And even:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">do_stuff($any_object_with_a_print_method);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sure, one way\nto do it is to force the caller to use <b>tiehandle()</b>.\nBut that puts the burden on them. Another way to do it is to\nuse <b>IO::Wrap</b>, which provides you with the following\nfunctions: <br>\nwraphandle <small>SCALAR</small></p>\n\n<p style=\"margin-left:17%;\">This function will take a\nsingle argument, and &quot;wrap&quot; it based on what it\nseems to be...</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p><b>A raw scalar filehandle name,</b> like\n&quot;STDOUT&quot; or &quot;Class::HANDLE&quot;. In this\ncase, the filehandle name is wrapped in an IO::Wrap object,\nwhich is returned.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p><b>A raw filehandle glob,</b> like &quot;\\*STDOUT&quot;.\nIn this case, the filehandle glob is wrapped in an IO::Wrap\nobject, which is returned.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p><b>A blessed FileHandle object.</b> In this case, the\nFileHandle is wrapped in an IO::Wrap object if and only if\nyour FileHandle class does not support the\n&quot;read()&quot; method.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"77%\">\n\n\n<p><b>Any other kind of blessed object,</b> which is\nassumed to be already conformant to the IO::Handle\ninterface. In this case, you just get back that object.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you get back\nan IO::Wrap object, it will obey a basic subset of the\n<small>IO::</small> interface. That is, the following\nmethods (note: I said <i>methods</i>, not named operators)\nshould work on the thing you get back:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">close <br>\ngetline <br>\ngetlines <br>\nprint ARGS... <br>\nread BUFFER,NBYTES <br>\nseek POS,WHENCE <br>\ntell</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Clearly, when\nwrapping a raw external filehandle (like \\*STDOUT), I\ndidn&rsquo;t want to close the file descriptor when the\n&quot;wrapper&quot; object is destroyed... since the user\nmight not appreciate that! Hence, there&rsquo;s no\n<small>DESTROY</small> method in this class.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When wrapping a\nFileHandle object, however, I believe that Perl will invoke\nthe FileHandle::DESTROY when the last reference goes away,\nso in that case, the filehandle is closed if the wrapped\nFileHandle really was the last reference to it.</p>\n\n<h2>WARNINGS\n<a name=\"WARNINGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\ndoes not allow you to wrap filehandle names which are given\nas strings that lack the package they were opened in. That\nis, if a user opens <small>FOO</small> in package Foo, they\nmust pass it to you either as &quot;\\*FOO&quot; or as\n&quot;Foo::FOO&quot;. However, &quot;STDIN&quot; and friends\nwill work just fine.</p>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$Id: Wrap.pm,v\n1.2 2005/02/10 21:21:53 dfs Exp $</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Primary\nMaintainer</p>\n\n<p style=\"margin-left:17%;\">Dianne Skoll\n(<i>dfs@roaringpenguin.com</i>).</p>\n\n<p style=\"margin-left:11%;\">Original Author</p>\n\n<p style=\"margin-left:17%;\">Eryq (<i>eryq@zeegee.com</i>).\nPresident, ZeeGee Software Inc\n(<i>http://www.zeegee.com</i>).</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#WARNINGS\">WARNINGS</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#AUTHOR\">AUTHOR</a>"],"level":3}