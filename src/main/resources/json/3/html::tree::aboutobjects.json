{"name":"html::tree::aboutobjects","description":"HTML::Tree::AboutObjects -- article: &quot;User&rsquo;s View of Object-Oriented Modules&quot;","body":"\n\n<h1 align=\"center\">HTML::Tree::AboutObjects</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Tree::AboutObjects\n-- article: &quot;User&rsquo;s View of Object-Oriented\nModules&quot;</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"># This an\narticle, not a module.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\narticle by Sean M. Burke first appeared in <i>The Perl\nJournal</i> #17 and is copyright 2000 The Perl Journal. It\nappears courtesy of Jon Orwant and The Perl Journal. This\ndocument may be distributed under the same terms as Perl\nitself.</p>\n\n<h2>A User&rsquo;s View of Object-Oriented Modules\n<a name=\"A User&rsquo;s View of Object-Oriented Modules\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- Sean M.\nBurke</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first time\nthat most Perl programmers run into object-oriented\nprogramming when they need to use a module whose interface\nis object-oriented. This is often a mystifying experience,\nsince talk of &quot;methods&quot; and\n&quot;constructors&quot; is unintelligible to programmers\nwho thought that functions and variables was all there was\nto worry about.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Articles and\nbooks that explain object-oriented programming (\n<small>OOP</small> ), do so in terms of how to program that\nway. That&rsquo;s understandable, and if you learn to write\nobject-oriented code of your own, you&rsquo;d find it easy\nto use object-oriented code that others write. But this\napproach is the <i>long</i> way around for people whose\nimmediate goal is just to use existing object-oriented\nmodules, but who don&rsquo;t yet want to know all the gory\ndetails of having to write such modules for themselves.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This article is\nfor those programmers -- programmers who want to know about\nobjects from the perspective of using object-oriented\nmodules.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Modules and\nTheir Functional Interfaces</b> <br>\nModules are the main way that Perl provides for bundling up\ncode for later use by yourself or others. As I&rsquo;m sure\nyou can&rsquo;t help noticing from reading <i>The Perl\nJournal</i>, <small>CPAN</small> (the Comprehensive Perl\nArchive Network) is the repository for modules (or groups of\nmodules) that others have written, to do anything from\ncomposing music to accessing Web pages. A good deal of those\nmodules even come with every installation of Perl.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One module that\nyou may have used before, and which is fairly typical in its\ninterface, is Text::Wrap. It comes with Perl, so you\ndon&rsquo;t even need to install it from\n<small>CPAN.</small> You use it in a program of yours, by\nhaving your program code say early on:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nText::Wrap;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and after that,\nyou can access a function called &quot;wrap&quot;, which\ninserts line-breaks in text that you feed it, so that the\ntext will be wrapped to seventy-two (or however many)\ncolumns.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The way this\n&quot;use Text::Wrap&quot; business works is that the module\nText::Wrap exists as a file &quot;Text/Wrap.pm&quot;\nsomewhere in one of your library directories. That file\ncontains Perl code...</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: And\nmixed in with the Perl code, there&rsquo;s documentation,\nwhich is what you read with &quot;perldoc Text::Wrap&quot;.\nThe perldoc program simply ignores the code and formats the\ndocumentation text, whereas &quot;use Text::Wrap&quot; loads\nand runs the code while ignoring the documentation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...which, among\nother things, defines a function called\n&quot;Text::Wrap::wrap&quot;, and then &quot;exports&quot;\nthat function, which means that when you say\n&quot;wrap&quot; after having said &quot;use\nText::Wrap&quot;, you&rsquo;ll be actually calling the\n&quot;Text::Wrap::wrap&quot; function. Some modules\ndon&rsquo;t export their functions, so you have to call them\nby their full name, like\n&quot;Text::Wrap::wrap(...parameters...)&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Regardless of\nwhether the typical module exports the functions it\nprovides, a module is basically just a container for chunks\nof code that do useful things. The way the module allows for\nyou to interact with it, is its <i>interface</i>. And when,\nlike with Text::Wrap, its interface consists of functions,\nthe module is said to have a <b>functional\ninterface</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: the\nterm &quot;function&quot; (and therefore\n&quot;function<i>al</i>&quot;) has various senses. I&rsquo;m\nusing the term here in its broadest sense, to refer to\nroutines -- bits of code that are called by some name and\nwhich take parameters and return some value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using modules\nwith functional interfaces is straightforward -- instead of\ndefining your own &quot;wrap&quot; function with &quot;sub\nwrap { ... }&quot;, you entrust &quot;use Text::Wrap&quot;\nto do that for you, along with whatever other functions its\ndefines and exports, according to the module&rsquo;s\ndocumentation. Without too much bother, you can even write\nyour own modules to contain your frequently used functions;\nI suggest having a look at the &quot;perlmod&quot; man page\nfor more leads on doing this.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Modules with\nObject-Oriented Interfaces</b> <br>\nSo suppose that one day you want to write a program that\nwill automate the process of &quot;ftp&quot;ing a bunch of\nfiles from one server down to your local machine, and then\noff to another server.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A quick browse\nthrough search.cpan.org turns up the module\n&quot;Net::FTP&quot;, which you can download and install it\nusing normal installation instructions (unless your sysadmin\nhas already installed it, as many have).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Like Text::Wrap\nor any other module with a familiarly functional interface,\nyou start off using Net::FTP in your program by saying:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nNet::FTP;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However,\nthat&rsquo;s where the similarity ends. The first hint of\ndifference is that the documentation for Net::FTP refers to\nit as a <b>class</b>. A class is a kind of module, but one\nthat has an object-oriented interface.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Whereas modules\nlike Text::Wrap provide bits of useful code as\n<i>functions</i>, to be called like\n&quot;function(...parameters...)&quot; or like\n&quot;PackageName::function(...parameters...)&quot;,\nNet::FTP and other modules with object-oriented interfaces\nprovide <b>methods</b>. Methods are sort of like functions\nin that they have a name and parameters; but methods look\ndifferent, and are different, because you have to call them\nwith a syntax that has a class name or an object as a\nspecial argument. I&rsquo;ll explain the syntax for method\ncalls, and then later explain what they all mean.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some methods\nare meant to be called as <b>class methods</b>, with the\nclass name (same as the module name) as a special argument.\nClass methods look like this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ClassName-&gt;methodname(parameter1,\nparameter2, ...) <br>\nClassName-&gt;methodname() # if no parameters <br>\nClassName-&gt;methodname # same as above</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">which you will\nsometimes see written:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">methodname\nClassName (parameter1, parameter2, ...) <br>\nmethodname ClassName # if no parameters</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Basically all\nclass methods are for making new objects, and methods that\nmake objects are called &quot;<b>constructors</b>&quot; (and\nthe process of making them is called\n&quot;constructing&quot; or &quot;instantiating&quot;).\nConstructor methods typically have the name &quot;new&quot;,\nor something including &quot;new&quot;\n(&quot;new_from_file&quot;, etc.); but they can conceivably\nbe named anything -- <small>DBI</small> &rsquo;s constructor\nmethod is named &quot;connect&quot;, for example.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The object that\na constructor method returns is typically captured in a\nscalar variable:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$object =\nClassName-&gt;new(param1, param2...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once you have\nan object (more later on exactly what that is), you can use\nthe other kind of method call syntax, the syntax for\n<b>object method</b> calls. Calling object methods is just\nlike class methods, except that instead of the ClassName as\nthe special argument, you use an expression that yields an\n&quot;object&quot;. Usually this is just a scalar variable\nthat you earlier captured the output of the constructor in.\nObject method calls look like this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$object-&gt;methodname(parameter1,\nparameter2, ...); <br>\n$object-&gt;methodname() # if no parameters <br>\n$object-&gt;methodname # same as above</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">which is\noccasionally written as:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">methodname\n$object (parameter1, parameter2, ...) <br>\nmethodname $object # if no parameters</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Examples of\nmethod calls are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $session1 =\nNet::FTP-&gt;new(&quot;ftp.myhost.com&quot;); <br>\n# Calls a class method &quot;new&quot;, from class Net::FTP,\n<br>\n# with the single parameter &quot;ftp.myhost.com&quot;, <br>\n# and saves the return value (which is, as usual, <br>\n# an object), in $session1. <br>\n# Could also be written: <br>\n# new Net::FTP('ftp.myhost.com') <br>\n\n$session1-&gt;login(&quot;sburke&quot;,&quot;aoeuaoeu&quot;)\n<br>\n|| die &quot;failed to login!\\n&quot;; <br>\n# calling the object method &quot;login&quot; <br>\nprint &quot;Dir:\\n&quot;, $session1-&gt;dir(),\n&quot;\\n&quot;; <br>\n$session1-&gt;quit; <br>\n# same as $session1-&gt;quit() <br>\nprint &quot;Done\\n&quot;; <br>\nexit;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Incidentally, I\nsuggest always using the syntaxes with parentheses and\n&quot;-&gt;&quot; in them,</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: the\ncharacter-pair &quot;-&gt;&quot; is supposed to look like an\narrow, not &quot;negative greater-than&quot;!</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and avoiding\nthe syntaxes that start out &quot;methodname $object&quot;\nor &quot;methodname ModuleName&quot;. When\neverything&rsquo;s going right, they all mean the same thing\nas the &quot;-&gt;&quot; variants, but the syntax with\n&quot;-&gt;&quot; is more visually distinct from function\ncalls, as well as being immune to some kinds of rare but\npuzzling ambiguities that can arise when you&rsquo;re trying\nto call methods that have the same name as subroutines\nyou&rsquo;ve defined.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But, syntactic\nalternatives aside, all this talk of constructing objects\nand object methods begs the question -- what <i>is</i> an\nobject? There are several angles to this question that the\nrest of this article will answer in turn: what can you do\nwith objects? what&rsquo;s in an object? what&rsquo;s an\nobject value? and why do some modules use objects at\nall?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>What Can You\nDo with Objects?</b> <br>\nYou&rsquo;ve seen that you can make objects, and call object\nmethods with them. But what are object methods for? The\nanswer depends on the class:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A Net::FTP\nobject represents a session between your computer and an\n<small>FTP</small> server. So the methods you call on a\nNet::FTP object are for doing whatever you&rsquo;d need to\ndo across an <small>FTP</small> connection. You make the\nsession and log in:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $session =\nNet::FTP-&gt;new('ftp.aol.com'); <br>\ndie &quot;Couldn't connect!&quot; unless defined $session;\n<br>\n# The class method call to &quot;new&quot; will return <br>\n# the new object if it goes OK, otherwise it <br>\n# will return undef. <br>\n$session-&gt;login('sburke', 'p@ssw3rD') <br>\n|| die &quot;Did I change my password again?&quot;; <br>\n# The object method &quot;login&quot; will give a true <br>\n# return value if actually logs in, otherwise <br>\n# it'll return false.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can use the\nsession object to change directory on that session:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$session-&gt;cwd(&quot;/home/sburke/public_html&quot;)\n<br>\n|| die &quot;Hey, that was REALLY supposed to work!&quot;;\n<br>\n# if the cwd fails, it'll return false</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...get files\nfrom the machine at the other end of the session...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">foreach my $f\n('log_report_ua.txt', 'log_report_dom.txt', <br>\n'log_report_browsers.txt') <br>\n{ <br>\n$session-&gt;get($f) || warn &quot;Getting $f failed!&quot;\n<br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...and plenty\nelse, ending finally with closing the connection:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$session-&gt;quit();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In short,\nobject methods are for doing things related to (or with)\nwhatever the object represents. For <small>FTP</small>\nsessions, it&rsquo;s about sending commands to the server at\nthe other end of the connection, and that&rsquo;s about it\n-- there, methods are for doing something to the world\noutside the object, and the objects is just something that\nspecifies what bit of the world (well, what\n<small>FTP</small> session) to act upon.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With most other\nclasses, however, the object itself stores some kind of\ninformation, and it typically makes no sense to do things\nwith such an object without considering the data\nthat&rsquo;s in the object.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>What&rsquo;s</b>\n<i>in</i> <b>an Object?</b> <br>\nAn object is (with rare exceptions) a data structure\ncontaining a bunch of attributes, each of which has a value,\nas well as a name that you use when you read or set the\nattribute&rsquo;s value. Some of the object&rsquo;s\nattributes are private, meaning you&rsquo;ll never see them\ndocumented because they&rsquo;re not for you to read or\nwrite; but most of the object&rsquo;s documented attributes\nare at least readable, and usually writeable, by you.\nNet::FTP objects are a bit thin on attributes, so\nwe&rsquo;ll use objects from the class Business::US_Amort\nfor this example. Business::US_Amort is a very simple class\n(available from <small>CPAN</small> ) that I wrote for\nmaking calculations to do with loans (specifically,\namortization, using US-style algorithms).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An object of\nthe class Business::US_Amort represents a loan with\nparticular parameters, i.e., attributes. The most basic\nattributes of a &quot;loan object&quot; are its interest\nrate, its principal (how much money it&rsquo;s for), and\nit&rsquo;s term (how long it&rsquo;ll take to repay). You\nneed to set these attributes before anything else can be\ndone with the object. The way to get at those attributes for\nloan objects is just like the way to get at attributes for\nany class&rsquo;s objects: through accessors. An\n<b>accessor</b> is simply any method that accesses (whether\nreading or writing, <small>AKA</small> getting or putting)\nsome attribute in the given object. Moreover, accessors are\nthe <b>only</b> way that you can change an object&rsquo;s\nattributes. (If a module&rsquo;s documentation wants you to\nknow about any other way, it&rsquo;ll tell you.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Usually, for\nsimplicity&rsquo;s sake, an accessor is named after the\nattribute it reads or writes. With Business::US_Amort\nobjects, the accessors you need to use first are\n&quot;principal&quot;, &quot;interest_rate&quot;, and\n&quot;term&quot;. Then, with at least those attributes set,\nyou can call the &quot;run&quot; method to figure out\nseveral things about the loan. Then you can call various\naccessors, like &quot;total_paid_toward_interest&quot;, to\nread the results:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nBusiness::US_Amort; <br>\nmy $loan = Business::US_Amort-&gt;new; <br>\n# Set the necessary attributes: <br>\n$loan-&gt;principal(123654); <br>\n$loan-&gt;interest_rate(9.25); <br>\n$loan-&gt;term(20); # twenty years <br>\n# NOW we know enough to calculate: <br>\n$loan-&gt;run; <br>\n# And see what came of that: <br>\nprint <br>\n&quot;Total paid toward interest: A WHOPPING &quot;, <br>\n$loan-&gt;total_paid_interest, &quot;!!\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This\nillustrates a convention that&rsquo;s common with accessors:\ncalling the accessor with no arguments (as with\n$loan-&gt;total_paid_interest) usually means to read the\nvalue of that attribute, but providing a value (as with\n$loan-&gt;term(20)) means you want that attribute to be set\nto that value. This stands to reason: why would you be\nproviding a value, if not to set the attribute to that\nvalue?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Although a\nloan&rsquo;s term, principal, and interest rates are all\nsingle numeric values, an objects values can any kind of\nscalar, or an array, or even a hash. Moreover, an\nattribute&rsquo;s value(s) can be objects themselves. For\nexample, consider <small>MIDI</small> files (as I wrote\nabout in TPJ#13): a <small>MIDI</small> file usually\nconsists of several tracks. A <small>MIDI</small> file is\ncomplex enough to merit being an object with attributes like\nits overall tempo, the file-format variant it&rsquo;s in,\nand the list of instrument tracks in the file. But tracks\nthemselves are complex enough to be objects too, with\nattributes like their track-type, a list of\n<small>MIDI</small> commands if they&rsquo;re a\n<small>MIDI</small> track, or raw data if they&rsquo;re not.\nSo I ended up writing the <small>MIDI</small> modules so\nthat the &quot;tracks&quot; attribute of a MIDI::Opus object\nis an array of objects from the class MIDI::Track. This may\nseem like a runaround -- you ask what&rsquo;s in one object,\nand get <i>another</i> object, or several! But in this case,\nit exactly reflects what the module is for --\n<small>MIDI</small> files contain <small>MIDI</small>\ntracks, which then contain data.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>What is an\nObject Value?</b> <br>\nWhen you call a constructor like\nNet::FTP-&gt;new(<i>hostname</i>), you get back an object\nvalue, a value you can later use, in combination with a\nmethod name, to call object methods.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, so far\nwe&rsquo;ve been pretending, in the above examples, that the\nvariables $session or $loan <i>are</i> the objects\nyou&rsquo;re dealing with. This idea is innocuous up to a\npoint, but it&rsquo;s really a misconception that will, at\nbest, limit you in what you know how to do. The reality is\nnot that the variables $session or $query are objects;\nit&rsquo;s a little more indirect -- they <i>hold</i> values\nthat symbolize objects. The kind of value that $session or\n$query hold is what I&rsquo;m calling an object value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To understand\nwhat kind of value this is, first think about the other\nkinds of scalar values you know about: The first two scalar\nvalues you probably ever ran into in Perl are <b>numbers</b>\nand <b>strings</b>, which you learned (or just assumed) will\nusually turn into each other on demand; that is, the\nthree-character string &quot;2.5&quot; can become the\nquantity two and a half, and vice versa. Then, especially if\nyou started using &quot;perl -w&quot; early on, you learned\nabout the <b>undefined value</b>, which can turn into 0 if\nyou treat it as a number, or the empty-string if you treat\nit as a string.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: You\nmay <i>also</i> have been learning about references, in\nwhich case you&rsquo;re ready to hear that object values are\njust a kind of reference, except that they reflect the class\nthat created thing they point to, instead of merely being a\nplain old array reference, hash reference, etc. <i>If</i>\nthis makes makes sense to you, and you want to know more\nabout how objects are implemented in Perl, have a look at\nthe &quot;perltoot&quot; man page.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And now\nyou&rsquo;re learning about <b>object values</b>. An object\nvalue is a value that points to a data structure somewhere\nin memory, which is where all the attributes for this object\nare stored. That data structure as a whole belongs to a\nclass (probably the one you named in the constructor method,\nlike ClassName-&gt;new), so that the object value can be\nused as part of object method calls.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want to\nactually <i>see</i> what an object value is, you might try\njust saying &quot;print $object&quot;. That&rsquo;ll get you\nsomething like this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::FTP=GLOB(0x20154240)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Business::US_Amort=HASH(0x15424020)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That&rsquo;s\nnot very helpful if you wanted to really get at the\nobject&rsquo;s insides, but that&rsquo;s because the object\nvalue is only a symbol for the object. This may all sound\nvery abstruse and metaphysical, so a real-world allegory\nmight be very helpful:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You get an\nadvertisement in the mail saying that you have been\n(im)personally selected to have the rare privilege of\napplying for a credit card. For whatever reason, <i>this</i>\noffer sounds good to you, so you fill out the form and mail\nit back to the credit card company. They gleefully approve\nthe application and create your account, and send you a card\nwith a number on it.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Now, you can do\nthings with the number on that card -- clerks at stores can\nring up things you want to buy, and charge your account by\nkeying in the number on the card. You can pay for things you\norder online by punching in the card number as part of your\nonline order. You can pay off part of the account by sending\nthe credit card people some of your money (well, a check)\nwith some note (usually the pre-printed slip) that has the\ncard number for the account you want to pay toward. And you\nshould be able to call the credit card company&rsquo;s\ncomputer and ask it things about the card, like its balance,\nits credit limit, its <small>APR,</small> and maybe an\nitemization of recent purchases ad payments.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Now, what\nyou&rsquo;re <i>really</i> doing is manipulating a credit\ncard <i>account</i>, a completely abstract entity with some\ndata attached to it (balance, <small>APR,</small> etc). But\nfor ease of access, you have a credit card <i>number</i>\nthat is a symbol for that account. Now, that symbol is just\na bunch of digits, and the number is effectively meaningless\nand useless in and of itself -- but in the appropriate\ncontext, it&rsquo;s understood to <i>mean</i> the credit\ncard account you&rsquo;re accessing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is exactly\nthe relationship between objects and object values, and from\nthis analogy, several facts about object values are a bit\nmore explicable:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* An object\nvalue does nothing in and of itself, but it&rsquo;s useful\nwhen you use it in the context of an $object-&gt;method\ncall, the same way that a card number is useful in the\ncontext of some operation dealing with a card account.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Moreover,\nseveral copies of the same object value all refer to the\nsame object, the same way that making several copies of your\ncard number won&rsquo;t change the fact that they all still\nrefer to the same single account (this is true whether\nyou&rsquo;re &quot;copying&quot; the number by just writing\nit down on different slips of paper, or whether you go to\nthe trouble of forging exact replicas of your own plastic\ncredit card). That&rsquo;s why this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x =\nNet::FTP-&gt;new(&quot;ftp.aol.com&quot;); <br>\n$x-&gt;login(&quot;sburke&quot;, &quot;aoeuaoeu&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">does the same\nthing as this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x =\nNet::FTP-&gt;new(&quot;ftp.aol.com&quot;); <br>\n$y = $x; <br>\n$z = $y; <br>\n$z-&gt;login(&quot;sburke&quot;, &quot;aoeuaoeu&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That is, $z and\n$y and $x are three different <i>slots</i> for values, but\nwhat&rsquo;s in those slots are all object values pointing\nto the same object -- you don&rsquo;t have three different\n<small>FTP</small> connections, just three variables with\nvalues pointing to the some single <small>FTP</small>\nconnection.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* You\ncan&rsquo;t tell much of anything about the object just by\nlooking at the object value, any more than you can see your\ncredit account balance by holding the plastic card up to the\nlight, or by adding up the digits in your credit card\nnumber.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* You\ncan&rsquo;t just make up your own object values and have\nthem work -- they can come only from constructor methods of\nthe appropriate class. Similarly, you get a credit card\nnumber <i>only</i> by having a bank approve your application\nfor a credit card account -- at which point <i>they</i> let\n<i>you</i> know what the number of your new card is.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now,\nthere&rsquo;s even more to the fact that you can&rsquo;t\njust make up your own object value: even though you can\nprint an object value and get a string like\n&quot;Net::FTP=GLOB(0x20154240)&quot;, that string is just a\n<i>representation</i> of an object value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Internally, an\nobject value has a basically different type from a string,\nor a number, or the undefined value -- if $x holds a real\nstring, then that value&rsquo;s slot in memory says\n&quot;this is a value of type <i>string</i>, and its\ncharacters are...&quot;, whereas if it&rsquo;s an object\nvalue, the value&rsquo;s slot in memory says, &quot;this is\na value of type <i>reference</i>, and the location in memory\nthat it points to is...&quot; (and by looking at\nwhat&rsquo;s at that location, Perl can tell the class of\nwhat&rsquo;s there).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl\nprogrammers typically don&rsquo;t have to think about all\nthese details of Perl&rsquo;s internals. Many other\nlanguages force you to be more conscious of the differences\nbetween all of these (and also between types of numbers,\nwhich are stored differently depending on their size and\nwhether they have fractional parts). But Perl does its best\nto hide the different types of scalars from you -- it turns\nnumbers into strings and back as needed, and takes the\nstring or number representation of undef or of object values\nas needed. However, you can&rsquo;t go from a string\nrepresentation of an object value, back to an object value.\nAnd that&rsquo;s why this doesn&rsquo;t work:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$x =\nNet::FTP-&gt;new('ftp.aol.com'); <br>\n$y = Net::FTP-&gt;new('ftp.netcom.com'); <br>\n$z = Net::FTP-&gt;new('ftp.qualcomm.com'); <br>\n$all = join(' ', $x,$y,$z); # !!! <br>\n...later... <br>\n($aol, $netcom, $qualcomm) = split(' ', $all); # !!! <br>\n$aol-&gt;login(&quot;sburke&quot;, &quot;aoeuaoeu&quot;);\n<br>\n$netcom-&gt;login(&quot;sburke&quot;, &quot;qjkxqjkx&quot;);\n<br>\n$qualcomm-&gt;login(&quot;smb&quot;,\n&quot;dhtndhtn&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This fails\nbecause $aol ends up holding merely the <b>string\nrepresentation</b> of the object value from $x, not the\nobject value itself -- when &quot;join&quot; tried to join\nthe characters of the &quot;strings&quot; $x, $y, and $z,\nPerl saw that they weren&rsquo;t strings at all, so it gave\n&quot;join&quot; their string representations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Unfortunately,\nthis distinction between object values and their string\nrepresentations doesn&rsquo;t really fit into the analogy of\ncredit card numbers, because credit card numbers really\n<i>are</i> numbers -- even thought they don&rsquo;t express\nany meaningful quantity, if you stored them in a database as\na quantity (as opposed to just an <small>ASCII</small>\nstring), that wouldn&rsquo;t stop them from being valid as\ncredit card numbers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This may seem\nrather academic, but there&rsquo;s there&rsquo;s two common\nmistakes programmers new to objects often make, which make\nsense only in terms of the distinction between object values\nand their string representations:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first\ncommon error involves forgetting (or never having known in\nthe first place) that when you go to use a value as a hash\nkey, Perl uses the string representation of that value. When\nyou want to use the numeric value two and a half as a key,\nPerl turns it into the three-character string\n&quot;2.5&quot;. But if you then want to use that string as\na number, Perl will treat it as meaning two and a half, so\nyou&rsquo;re usually none the wiser that Perl converted the\nnumber to a string and back. But recall that Perl\ncan&rsquo;t turn strings back into objects -- so if you\ntried to use a Net::FTP object value as a hash key, Perl\nactually used its string representation, like\n&quot;Net::FTP=GLOB(0x20154240)&quot;, but that string is\nunusable as an object value. (Incidentally, there&rsquo;s a\nmodule Tie::RefHash that implements hashes that <i>do</i>\nlet you use real object-values as keys.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second\ncommon error with object values is in trying to save an\nobject value to disk (whether printing it to a file, or\nstoring it in a conventional database file). All\nyou&rsquo;ll get is the string, which will be useless.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When you want\nto save an object and restore it later, you may find that\nthe object&rsquo;s class already provides a method\nspecifically for this. For example, MIDI::Opus provides\nmethods for writing an object to disk as a standard\n<small>MIDI</small> file. The file can later be read back\ninto memory by a MIDI::Opus constructor method, which will\nreturn a new MIDI::Opus object representing whatever file\nyou tell it to read into memory. Similar methods are\navailable with, for example, classes that manipulate graphic\nimages and can save them to files, which can be read back\nlater.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But some\nclasses, like Business::US_Amort, provide no such methods\nfor storing an object in a file. When this is the case, you\ncan try using any of the Data::Dumper, Storable, or\nFreezeThaw modules. Using these will be unproblematic for\nobjects of most classes, but it may run into limitations\nwith others. For example, a Business::US_Amort object can be\nturned into a string with Data::Dumper, and that string\nwritten to a file. When it&rsquo;s restored later, its\nattributes will be accessible as normal. But in the unlikely\ncase that the loan object was saved in mid-calculation, the\ncalculation may not be resumable. This is because of the way\nthat that <i>particular</i> class does its calculations, but\nsimilar limitations may occur with objects from other\nclasses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But often, even\n<i>wanting</i> to save an object is basically wrong -- what\nwould saving an ftp <i>session</i> even mean? Saving the\nhostname, username, and password? current directory on both\nmachines? the local <small>TCP/IP</small> port number? In\nthe case of &quot;saving&quot; a Net::FTP object,\nyou&rsquo;re better off just saving whatever details you\nactually need for your own purposes, so that you can make a\nnew object later and just set those values for it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>So Why Do\nSome Modules Use Objects?</b> <br>\nAll these details of using objects are definitely enough to\nmake you wonder -- is it worth the bother? If you&rsquo;re a\nmodule author, writing your module with an object-oriented\ninterface restricts the audience of potential users to those\nwho understand the basic concepts of objects and object\nvalues, as well as Perl&rsquo;s syntax for calling methods.\nWhy complicate things by having an object-oriented\ninterface?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A somewhat\nesoteric answer is that a module has an object-oriented\ninterface because the module&rsquo;s insides are written in\nan object-oriented style. This article is about the basics\nof object-oriented <i>interfaces</i>, and it&rsquo;d be\ngoing far afield to explain what object-oriented\n<i>design</i> is. But the short story is that\nobject-oriented design is just one way of attacking messy\nproblems. It&rsquo;s a way that many programmers find very\nhelpful (and which others happen to find to be far more of a\nhassle than it&rsquo;s worth, incidentally), and it just\nhappens to show up for you, the module user, as merely the\nstyle of interface.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But a simpler\nanswer is that a functional interface is sometimes a\nhindrance, because it limits the number of things you can do\nat once -- limiting it, in fact, to one. For many problems\nthat some modules are meant to solve, doing without an\nobject-oriented interface would be like wishing that Perl\ndidn&rsquo;t use filehandles. The ideas are rather simpler\n-- just imagine that Perl let you access files, but\n<i>only</i> one at a time, with code like:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">open(&quot;foo.txt&quot;)\n|| die &quot;Can't open foo.txt: $!&quot;; <br>\nwhile(readline) { <br>\nprint $_ if /bar/; <br>\n} <br>\nclose;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That\nhypothetical kind of Perl would be simpler, by doing without\nfilehandles. But you&rsquo;d be out of luck if you wanted to\nread from one file while reading from another, or read from\ntwo and print to a third.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the same\nway, a functional <small>FTP</small> module would be fine\nfor just uploading files to one server at a time, but it\nwouldn&rsquo;t allow you to easily write programs that make\nneed to use <i>several</i> simultaneous sessions (like\n&quot;look at server A and server B, and if A has a file\ncalled X.dat, then download it locally and then upload it to\nserver B -- except if B has a file called Y.dat, in which\ncase do it the other way around&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some kinds of\nproblems that modules solve just lend themselves to an\nobject-oriented interface. For those kinds of tasks, a\nfunctional interface would be more familiar, but less\npowerful. Learning to use object-oriented modules&rsquo;\ninterfaces does require becoming comfortable with the\nconcepts from this article. But in the end it will allow you\nto use a broader range of modules and, with them, to write\nprograms that can do more.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>[end body of\narticle]</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>[Author\nCredit]</b> <br>\nSean M. Burke has contributed several modules to\n<small>CPAN,</small> about half of them object-oriented.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[The next\nsection should be in a greybox:]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The Gory\nDetails</b> <br>\nFor sake of clarity of explanation, I had to oversimplify\nsome of the facts about objects. Here&rsquo;s a few of the\ngorier details:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* Every example\nI gave of a constructor was a class method. But object\nmethods can be constructors, too, if the class was written\nto work that way: $new = $old-&gt;copy, $node_y =\n$node_x-&gt;new_subnode, or the like.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* I&rsquo;ve\ngiven the impression that there&rsquo;s two kinds of\nmethods: object methods and class methods. In fact, the same\nmethod can be both, because it&rsquo;s not the kind of\nmethod it is, but the kind of calls it&rsquo;s written to\naccept -- calls that pass an object, or calls that pass a\nclass-name.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* The term\n&quot;object value&quot; isn&rsquo;t something you&rsquo;ll\nfind used much anywhere else. It&rsquo;s just my shorthand\nfor what would properly be called an &quot;object\nreference&quot; or &quot;reference to a blessed item&quot;.\nIn fact, people usually say &quot;object&quot; when they\nproperly mean a reference to that object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* I mentioned\ncreating objects with <i>con</i>structors, but I\ndidn&rsquo;t mention destroying them with <i>de</i>structor\n-- a destructor is a kind of method that you call to tidy up\nthe object once you&rsquo;re done with it, and want it to\nneatly go away (close connections, delete temporary files,\nfree up memory, etc). But because of the way Perl handles\nmemory, most modules won&rsquo;t require the user to know\nabout destructors.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* I said that\nclass method syntax has to have the class name, as in\n$session = <b>Net::FTP</b>-&gt;new($host). Actually, you can\ninstead use any expression that returns a class name:\n$ftp_class = &rsquo;Net::FTP&rsquo;; $session =\n<b>$ftp_class</b>-&gt;new($host). Moreover, instead of the\nmethod name for object- or class-method calls, you can use a\nscalar holding the method name:\n$foo-&gt;<b>$method</b>($host). But, in practice, these\nsyntaxes are rarely useful.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And finally, to\nlearn about objects from the perspective of writing your own\nclasses, see the &quot;perltoot&quot; documentation, or\nDamian Conway&rsquo;s exhaustive and clear book <i>Object\nOriented Perl</i> (Manning Publications 1999, <small>ISBN\n1-884777-79-1</small> ).</p>\n\n<h2>BACK\n<a name=\"BACK\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Return to the\nHTML::Tree docs.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#A User&rsquo;s View of Object-Oriented Modules\">A User&rsquo;s View of Object-Oriented Modules</a>","<a href=\"#BACK\">BACK</a>"],"level":3}