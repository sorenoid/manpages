{"name":"pthread_create","description":"pthread_create\n- create a new thread","body":"\n\n<h1 align=\"center\">PTHREAD_CREATE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pthread_create\n- create a new thread</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;pthread.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\npthread_create(pthread_t *</b><i>thread</i><b>, const\npthread_attr_t *</b><i>attr</i><b>, <br>\nvoid *(*</b><i>start_routine</i><b>) (void *), void\n*</b><i>arg</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Compile and\nlink with <i>-pthread</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>pthread_create</b>() function starts a new thread in the\ncalling process. The new thread starts execution by invoking\n<i>start_routine</i>(); <i>arg</i> is passed as the sole\nargument of <i>start_routine</i>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The new thread\nterminates in one of the following ways:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>It calls <a href=\"https://man.page/3/pthread_exit\">pthread_exit(3)</a>, specifying an exit\nstatus value that is available to another thread in the same\nprocess that calls <a href=\"https://man.page/3/pthread_join\">pthread_join(3)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>It returns from <i>start_routine</i>(). This is\nequivalent to calling <a href=\"https://man.page/3/pthread_exit\">pthread_exit(3)</a> with the value\nsupplied in the <i>return</i> statement.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>It is canceled (see <a href=\"https://man.page/3/pthread_cancel\">pthread_cancel(3)</a>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>Any of the threads in the process calls <a href=\"https://man.page/3/exit\">exit(3)</a>,\nor the main thread performs a return from <i>main</i>().\nThis causes the termination of all threads in the\nprocess.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>attr</i>\nargument points to a <i>pthread_attr_t</i> structure whose\ncontents are used at thread creation time to determine\nattributes for the new thread; this structure is initialized\nusing <a href=\"https://man.page/3/pthread_attr_init\">pthread_attr_init(3)</a> and related functions. If\n<i>attr</i> is NULL, then the thread is created with default\nattributes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before\nreturning, a successful call to <b>pthread_create</b>()\nstores the ID of the new thread in the buffer pointed to by\n<i>thread</i>; this identifier is used to refer to the\nthread in subsequent calls to other pthreads functions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The new thread\ninherits a copy of the creating thread&rsquo;s signal mask\n(<a href=\"https://man.page/3/pthread_sigmask\">pthread_sigmask(3)</a>). The set of pending signals for\nthe new thread is empty (<a href=\"https://man.page/2/sigpending\">sigpending(2)</a>). The new\nthread does not inherit the creating thread&rsquo;s\nalternate signal stack (<a href=\"https://man.page/2/sigaltstack\">sigaltstack(2)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The new thread\ninherits the calling thread&rsquo;s floating-point\nenvironment (<a href=\"https://man.page/3/fenv\">fenv(3)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The initial\nvalue of the new thread&rsquo;s CPU-time clock is 0 (see\n<a href=\"https://man.page/3/pthread_getcpuclockid\">pthread_getcpuclockid(3)</a>).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Linux-specific\ndetails</b> <br>\nThe new thread inherits copies of the calling thread&rsquo;s\ncapability sets (see <a href=\"https://man.page/7/capabilities\">capabilities(7)</a>) and CPU\naffinity mask (see <a href=\"https://man.page/2/sched_setaffinity\">sched_setaffinity(2)</a>).</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>pthread_create</b>() returns 0; on error, it returns an\nerror number, and the contents of <i>*thread</i> are\nundefined.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Insufficient resources to create\nanother thread.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A system-imposed limit on the number of threads was\nencountered. There are a number of limits that may trigger\nthis error: the <b>RLIMIT_NPROC</b> soft resource limit (set\nvia <a href=\"https://man.page/2/setrlimit\">setrlimit(2)</a>), which limits the number of\nprocesses and threads for a real user ID, was reached; the\nkernel&rsquo;s system-wide limit on the number of processes\nand threads, <i>/proc/sys/kernel/threads-max</i>, was\nreached (see <a href=\"https://man.page/5/proc\">proc(5)</a>); or the maximum number of PIDs,\n<i>/proc/sys/kernel/pid_max</i>, was reached (see\n<a href=\"https://man.page/5/proc\">proc(5)</a>).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Invalid settings in <i>attr</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EPERM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>No permission to set the scheduling policy and\nparameters specified in <i>attr</i>.</p></td></tr>\n</table>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3286341.png\" alt=\"Image grohtml-3286341.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001,\nPOSIX.1-2008.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<a href=\"https://man.page/3/pthread_self\">pthread_self(3)</a> for further information on the thread\nID returned in <i>*thread</i> by <b>pthread_create</b>().\nUnless real-time scheduling policies are being employed,\nafter a call to <b>pthread_create</b>(), it is indeterminate\nwhich thread&mdash;the caller or the new thread&mdash;will\nnext execute.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A thread may\neither be <i>joinable</i> or <i>detached</i>. If a thread is\njoinable, then another thread can call\n<a href=\"https://man.page/3/pthread_join\">pthread_join(3)</a> to wait for the thread to terminate\nand fetch its exit status. Only when a terminated joinable\nthread has been joined are the last of its resources\nreleased back to the system. When a detached thread\nterminates, its resources are automatically released back to\nthe system: it is not possible to join with the thread in\norder to obtain its exit status. Making a thread detached is\nuseful for some types of daemon threads whose exit status\nthe application does not need to care about. By default, a\nnew thread is created in a joinable state, unless\n<i>attr</i> was set to create the thread in a detached state\n(using <a href=\"https://man.page/3/pthread_attr_setdetachstate\">pthread_attr_setdetachstate(3)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Under the NPTL\nthreading implementation, if the <b>RLIMIT_STACK</b> soft\nresource limit <i>at the time the program started</i> has\nany value other than &quot;unlimited&quot;, then it\ndetermines the default stack size of new threads. Using\n<a href=\"https://man.page/3/pthread_attr_setstacksize\">pthread_attr_setstacksize(3)</a>, the stack size\nattribute can be explicitly set in the <i>attr</i> argument\nused to create a thread, in order to obtain a stack size\nother than the default. If the <b>RLIMIT_STACK</b> resource\nlimit is set to &quot;unlimited&quot;, a per-architecture\nvalue is used for the stack size. Here is the value for a\nfew architectures:</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3286342.png\" alt=\"Image grohtml-3286342.png\"></p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the obsolete\nLinuxThreads implementation, each of the threads in a\nprocess has a different process ID. This is in violation of\nthe POSIX threads specification, and is the source of many\nother nonconformances to the standard; see\n<a href=\"https://man.page/7/pthreads\">pthreads(7)</a>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow demonstrates the use of <b>pthread_create</b>(), as\nwell as a number of other functions in the pthreads API.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the\nfollowing run, on a system providing the NPTL threading\nimplementation, the stack size defaults to the value given\nby the &quot;stack size&quot; resource limit:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>ulimit\n-s</b> <br>\n8192 # The stack size limit is 8 MB (0x800000 bytes) <br>\n$ <b>./a.out hola salut servus</b> <br>\nThread 1: top of stack near 0xb7dd03b8; argv_string=hola\n<br>\nThread 2: top of stack near 0xb75cf3b8; argv_string=salut\n<br>\nThread 3: top of stack near 0xb6dce3b8; argv_string=servus\n<br>\nJoined with thread 1; returned value was HOLA <br>\nJoined with thread 2; returned value was SALUT <br>\nJoined with thread 3; returned value was SERVUS</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the next\nrun, the program explicitly sets a stack size of 1&nbsp;MB\n(using <a href=\"https://man.page/3/pthread_attr_setstacksize\">pthread_attr_setstacksize(3)</a>) for the created\nthreads:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out -s\n0x100000 hola salut servus</b> <br>\nThread 1: top of stack near 0xb7d723b8; argv_string=hola\n<br>\nThread 2: top of stack near 0xb7c713b8; argv_string=salut\n<br>\nThread 3: top of stack near 0xb7b703b8; argv_string=servus\n<br>\nJoined with thread 1; returned value was HOLA <br>\nJoined with thread 2; returned value was SALUT <br>\nJoined with thread 3; returned value was SERVUS</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;pthread.h&gt; <br>\n#include &lt;string.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;errno.h&gt; <br>\n#include &lt;ctype.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error_en(en, msg) \\ <br>\ndo { errno = en; perror(msg); exit(EXIT_FAILURE); } while\n(0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error(msg) \\ <br>\ndo { perror(msg); exit(EXIT_FAILURE); } while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct\nthread_info { /* Used as argument to thread_start() */ <br>\npthread_t thread_id; /* ID returned by pthread_create() */\n<br>\nint thread_num; /* Application-defined thread # */ <br>\nchar *argv_string; /* From command-line argument */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Thread start\nfunction: display address near top of our stack, <br>\nand return upper-cased copy of argv_string */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void *\n<br>\nthread_start(void *arg) <br>\n{ <br>\nstruct thread_info *tinfo = arg; <br>\nchar *uargv;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Thread\n%d: top of stack near %p; argv_string=%s\\n&quot;, <br>\ntinfo-&gt;thread_num, &amp;p, tinfo-&gt;argv_string);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">uargv =\nstrdup(tinfo-&gt;argv_string); <br>\nif (uargv == NULL) <br>\nhandle_error(&quot;strdup&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (char *p =\nuargv; *p != '\\0'; p++) <br>\n*p = toupper(*p);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return uargv;\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint s, opt, num_threads; <br>\npthread_attr_t attr; <br>\nsize_t stack_size; <br>\nvoid *res;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* The\n&quot;-s&quot; option specifies a stack size for our threads\n*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">stack_size =\n-1; <br>\nwhile ((opt = getopt(argc, argv, &quot;s:&quot;)) != -1) {\n<br>\nswitch (opt) { <br>\ncase 's': <br>\nstack_size = strtoul(optarg, NULL, 0); <br>\nbreak;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">default: <br>\nfprintf(stderr, &quot;Usage: %s [-s stack-size]\narg...\\n&quot;, <br>\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">num_threads =\nargc - optind;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Initialize\nthread creation attributes */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_attr_init(&amp;attr); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_init&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (stack_size\n&gt; 0) { <br>\ns = pthread_attr_setstacksize(&amp;attr, stack_size); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_setstacksize&quot;);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Allocate\nmemory for pthread_create() arguments */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct\nthread_info *tinfo = calloc(num_threads, sizeof(*tinfo));\n<br>\nif (tinfo == NULL) <br>\nhandle_error(&quot;calloc&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Create one\nthread for each command-line argument */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int tnum =\n0; tnum &lt; num_threads; tnum++) { <br>\ntinfo[tnum].thread_num = tnum + 1; <br>\ntinfo[tnum].argv_string = argv[optind + tnum];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* The\npthread_create() call stores the thread ID into <br>\ncorresponding element of tinfo[] */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_create(&amp;tinfo[tnum].thread_id, &amp;attr, <br>\n&amp;thread_start, &amp;tinfo[tnum]); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_create&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Destroy the\nthread attributes object, since it is no <br>\nlonger needed */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_attr_destroy(&amp;attr); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_destroy&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Now join\nwith each thread, and display its returned value */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int tnum =\n0; tnum &lt; num_threads; tnum++) { <br>\ns = pthread_join(tinfo[tnum].thread_id, &amp;res); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_join&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Joined\nwith thread %d; returned value was %s\\n&quot;, <br>\ntinfo[tnum].thread_num, (char *) res); <br>\nfree(res); /* Free memory allocated by thread */ <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">free(tinfo);\n<br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>,\n<a href=\"https://man.page/3/pthread_attr_init\">pthread_attr_init(3)</a>, <a href=\"https://man.page/3/pthread_cancel\">pthread_cancel(3)</a>,\n<a href=\"https://man.page/3/pthread_detach\">pthread_detach(3)</a>, <a href=\"https://man.page/3/pthread_equal\">pthread_equal(3)</a>,\n<a href=\"https://man.page/3/pthread_exit\">pthread_exit(3)</a>, <a href=\"https://man.page/3/pthread_getattr_np\">pthread_getattr_np(3)</a>,\n<a href=\"https://man.page/3/pthread_join\">pthread_join(3)</a>, <a href=\"https://man.page/3/pthread_self\">pthread_self(3)</a>,\n<a href=\"https://man.page/3/pthread_setattr_default_np\">pthread_setattr_default_np(3)</a>, <a href=\"https://man.page/7/pthreads\">pthreads(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}