{"name":"dl_iterate_phdr","description":"dl_iterate_phdr\n- walk through list of shared objects","body":"\n\n<h1 align=\"center\">DL_ITERATE_PHDR</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">dl_iterate_phdr\n- walk through list of shared objects</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;link.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ndl_iterate_phdr( <br>\nint (*</b><i>callback</i><b>) (struct dl_phdr_info\n*</b><i>info</i><b>, <br>\nsize_t</b> <i>size</i><b>, void *</b><i>data</i><b>), <br>\nvoid *</b><i>data</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>dl_iterate_phdr</b>() function allows an application to\ninquire at run time to find out which shared objects it has\nloaded, and the order in which they were loaded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>dl_iterate_phdr</b>() function walks through the list of\nan application&rsquo;s shared objects and calls the function\n<i>callback</i> once for each object, until either all\nshared objects have been processed or <i>callback</i>\nreturns a nonzero value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each call to\n<i>callback</i> receives three arguments: <i>info</i>, which\nis a pointer to a structure containing information about the\nshared object; <i>size</i>, which is the size of the\nstructure pointed to by <i>info</i>; and <i>data</i>, which\nis a copy of whatever value was passed by the calling\nprogram as the second argument (also named <i>data</i>) in\nthe call to <b>dl_iterate_phdr</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>info</i>\nargument is a structure of the following type:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\ndl_phdr_info { <br>\nElfW(Addr) dlpi_addr; /* Base address of object */ <br>\nconst char *dlpi_name; /* (Null-terminated) name of <br>\nobject */ <br>\nconst ElfW(Phdr) *dlpi_phdr; /* Pointer to array of <br>\nELF program headers <br>\nfor this object */ <br>\nElfW(Half) dlpi_phnum; /* # of items in <i>dlpi_phdr</i>\n*/</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* The\nfollowing fields were added in glibc 2.4, after the first\n<br>\nversion of this structure was available. Check the\n<i>size</i> <br>\nargument passed to the dl_iterate_phdr callback to determine\n<br>\nwhether or not each later member is available. */</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">unsigned long\nlong dlpi_adds; <br>\n/* Incremented when a new object may <br>\nhave been added */ <br>\nunsigned long long dlpi_subs; <br>\n/* Incremented when an object may <br>\nhave been removed */ <br>\nsize_t dlpi_tls_modid; <br>\n/* If there is a PT_TLS segment, its module <br>\nID as used in TLS relocations, else zero */ <br>\nvoid *dlpi_tls_data; <br>\n/* The address of the calling thread's instance <br>\nof this module's PT_TLS segment, if it has <br>\none and it has been allocated in the calling <br>\nthread, otherwise a null pointer */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(The\n<i>ElfW</i>() macro definition turns its argument into the\nname of an ELF data type suitable for the hardware\narchitecture. For example, on a 32-bit platform,\n<i>ElfW(Addr)</i> yields the data type name\n<i>Elf32_Addr</i>. Further information on these types can be\nfound in the <i>&lt;elf.h&gt;</i> and <i>&lt;link.h&gt;</i>\nheader files.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>dlpi_addr</i> field indicates the base address of the\nshared object (i.e., the difference between the virtual\nmemory address of the shared object and the offset of that\nobject in the file from which it was loaded). The\n<i>dlpi_name</i> field is a null-terminated string giving\nthe pathname from which the shared object was loaded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To understand\nthe meaning of the <i>dlpi_phdr</i> and <i>dlpi_phnum</i>\nfields, we need to be aware that an ELF shared object\nconsists of a number of segments, each of which has a\ncorresponding program header describing the segment. The\n<i>dlpi_phdr</i> field is a pointer to an array of the\nprogram headers for this shared object. The\n<i>dlpi_phnum</i> field indicates the size of this\narray.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These program\nheaders are structures of the following form:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">typedef struct\n{ <br>\nElf32_Word p_type; /* Segment type */ <br>\nElf32_Off p_offset; /* Segment file offset */ <br>\nElf32_Addr p_vaddr; /* Segment virtual address */ <br>\nElf32_Addr p_paddr; /* Segment physical address */ <br>\nElf32_Word p_filesz; /* Segment size in file */ <br>\nElf32_Word p_memsz; /* Segment size in memory */ <br>\nElf32_Word p_flags; /* Segment flags */ <br>\nElf32_Word p_align; /* Segment alignment */ <br>\n} Elf32_Phdr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that we\ncan calculate the location of a particular program header,\n<i>x</i>, in virtual memory using the formula:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">addr ==\ninfo-&gt;dlpi_addr + info-&gt;dlpi_phdr[x].p_vaddr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Possible values\nfor <i>p_type</i> include the following (see\n<i>&lt;elf.h&gt;</i> for further details):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">#define PT_LOAD\n1 /* Loadable program segment */ <br>\n#define PT_DYNAMIC 2 /* Dynamic linking information */ <br>\n#define PT_INTERP 3 /* Program interpreter */ <br>\n#define PT_NOTE 4 /* Auxiliary information */ <br>\n#define PT_SHLIB 5 /* Reserved */ <br>\n#define PT_PHDR 6 /* Entry for header table itself */ <br>\n#define PT_TLS 7 /* Thread-local storage segment */ <br>\n#define PT_GNU_EH_FRAME 0x6474e550 /* GCC .eh_frame_hdr\nsegment */ <br>\n#define PT_GNU_STACK 0x6474e551 /* Indicates stack\nexecutability */ <br>\n#define PT_GNU_RELRO 0x6474e552 /* Read-only after\nrelocation */</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>dl_iterate_phdr</b>() function returns whatever value was\nreturned by the last call to <i>callback</i>.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dl_iterate_phdr</b>()\nhas been supported in glibc since version 2.2.4.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\">\n</td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n</table>\n\n\n<p align=\"center\"><img src=\"grohtml-3313921.png\" alt=\"Image grohtml-3313921.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>dl_iterate_phdr</b>() function is not specified in any\nstandard. Various other systems provide a version of this\nfunction, although details of the returned\n<i>dl_phdr_info</i> structure differ. On the BSDs and\nSolaris, the structure includes the fields <i>dlpi_addr</i>,\n<i>dlpi_name</i>, <i>dlpi_phdr</i>, and <i>dlpi_phnum</i> in\naddition to other implementation-specific fields.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Future versions\nof the C library may add further fields to the\n<i>dl_phdr_info</i> structure; in that event, the\n<i>size</i> argument provides a mechanism for the callback\nfunction to discover whether it is running on a system with\nadded fields.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first\nobject visited by <i>callback</i> is the main program. For\nthe main program, the <i>dlpi_name</i> field will be an\nempty string.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nprogram displays a list of pathnames of the shared objects\nit has loaded. For each shared object, the program lists\nsome information (virtual address, size, flags, and type)\nfor each of the objects ELF segments.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nshell session demonstrates the output produced by the\nprogram on an x86-64 system. The first shared object for\nwhich output is displayed (where the name is an empty\nstring) is the main program.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./a.out</b> <br>\nName: &quot;&quot; (9 segments) <br>\n0: [ 0x400040; memsz: 1f8] flags: 0x5; PT_PHDR <br>\n1: [ 0x400238; memsz: 1c] flags: 0x4; PT_INTERP <br>\n2: [ 0x400000; memsz: ac4] flags: 0x5; PT_LOAD <br>\n3: [ 0x600e10; memsz: 240] flags: 0x6; PT_LOAD <br>\n4: [ 0x600e28; memsz: 1d0] flags: 0x6; PT_DYNAMIC <br>\n5: [ 0x400254; memsz: 44] flags: 0x4; PT_NOTE <br>\n6: [ 0x400970; memsz: 3c] flags: 0x4; PT_GNU_EH_FRAME <br>\n7: [ (nil); memsz: 0] flags: 0x6; PT_GNU_STACK <br>\n8: [ 0x600e10; memsz: 1f0] flags: 0x4; PT_GNU_RELRO <br>\nName: &quot;linux-vdso.so.1&quot; (4 segments) <br>\n0: [0x7ffc6edd1000; memsz: e89] flags: 0x5; PT_LOAD <br>\n1: [0x7ffc6edd1360; memsz: 110] flags: 0x4; PT_DYNAMIC <br>\n2: [0x7ffc6edd17b0; memsz: 3c] flags: 0x4; PT_NOTE <br>\n3: [0x7ffc6edd17ec; memsz: 3c] flags: 0x4; PT_GNU_EH_FRAME\n<br>\nName: &quot;/lib64/libc.so.6&quot; (10 segments) <br>\n0: [0x7f55712ce040; memsz: 230] flags: 0x5; PT_PHDR <br>\n1: [0x7f557145b980; memsz: 1c] flags: 0x4; PT_INTERP <br>\n2: [0x7f55712ce000; memsz: 1b6a5c] flags: 0x5; PT_LOAD <br>\n3: [0x7f55716857a0; memsz: 9240] flags: 0x6; PT_LOAD <br>\n4: [0x7f5571688b80; memsz: 1f0] flags: 0x6; PT_DYNAMIC <br>\n5: [0x7f55712ce270; memsz: 44] flags: 0x4; PT_NOTE <br>\n6: [0x7f55716857a0; memsz: 78] flags: 0x4; PT_TLS <br>\n7: [0x7f557145b99c; memsz: 544c] flags: 0x4; PT_GNU_EH_FRAME\n<br>\n8: [0x7f55712ce000; memsz: 0] flags: 0x6; PT_GNU_STACK <br>\n9: [0x7f55716857a0; memsz: 3860] flags: 0x4; PT_GNU_RELRO\n<br>\nName: &quot;/lib64/ld-linux-x86-64.so.2&quot; (7 segments)\n<br>\n0: [0x7f557168f000; memsz: 20828] flags: 0x5; PT_LOAD <br>\n1: [0x7f55718afba0; memsz: 15a8] flags: 0x6; PT_LOAD <br>\n2: [0x7f55718afe10; memsz: 190] flags: 0x6; PT_DYNAMIC <br>\n3: [0x7f557168f1c8; memsz: 24] flags: 0x4; PT_NOTE <br>\n4: [0x7f55716acec4; memsz: 604] flags: 0x4; PT_GNU_EH_FRAME\n<br>\n5: [0x7f557168f000; memsz: 0] flags: 0x6; PT_GNU_STACK <br>\n6: [0x7f55718afba0; memsz: 460] flags: 0x4; PT_GNU_RELRO</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;link.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdint.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static int <br>\ncallback(struct dl_phdr_info *info, size_t size, void *data)\n<br>\n{ <br>\nchar *type; <br>\nint p_type;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;Name:\n\\&quot;%s\\&quot; (%d segments)\\n&quot;, info-&gt;dlpi_name,\n<br>\ninfo-&gt;dlpi_phnum);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int j = 0;\nj &lt; info-&gt;dlpi_phnum; j++) { <br>\np_type = info-&gt;dlpi_phdr[j].p_type; <br>\ntype = (p_type == PT_LOAD) ? &quot;PT_LOAD&quot; : <br>\n(p_type == PT_DYNAMIC) ? &quot;PT_DYNAMIC&quot; : <br>\n(p_type == PT_INTERP) ? &quot;PT_INTERP&quot; : <br>\n(p_type == PT_NOTE) ? &quot;PT_NOTE&quot; : <br>\n(p_type == PT_INTERP) ? &quot;PT_INTERP&quot; : <br>\n(p_type == PT_PHDR) ? &quot;PT_PHDR&quot; : <br>\n(p_type == PT_TLS) ? &quot;PT_TLS&quot; : <br>\n(p_type == PT_GNU_EH_FRAME) ? &quot;PT_GNU_EH_FRAME&quot; :\n<br>\n(p_type == PT_GNU_STACK) ? &quot;PT_GNU_STACK&quot; : <br>\n(p_type == PT_GNU_RELRO) ? &quot;PT_GNU_RELRO&quot; :\nNULL;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;\n%2d: [%14p; memsz:%7jx] flags: %#jx; &quot;, j, <br>\n(void *) (info-&gt;dlpi_addr +\ninfo-&gt;dlpi_phdr[j].p_vaddr), <br>\n(uintmax_t) info-&gt;dlpi_phdr[j].p_memsz, <br>\n(uintmax_t) info-&gt;dlpi_phdr[j].p_flags); <br>\nif (type != NULL) <br>\nprintf(&quot;%s\\n&quot;, type); <br>\nelse <br>\nprintf(&quot;[other (%#x)]\\n&quot;, p_type); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return 0; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\ndl_iterate_phdr(callback, NULL);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/ldd\">ldd(1)</a>,\n<a href=\"https://man.page/1/objdump\">objdump(1)</a>, <a href=\"https://man.page/1/readelf\">readelf(1)</a>, <a href=\"https://man.page/3/dladdr\">dladdr(3)</a>,\n<a href=\"https://man.page/3/dlopen\">dlopen(3)</a>, <a href=\"https://man.page/5/elf\">elf(5)</a>, <b>ld.so</b>(8)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Executable\nand Linking Format Specification</i>, available at various\nlocations online.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}