{"name":"html::tree::scanning","description":"HTML::Tree::Scanning -- article: &quot;Scanning HTML&quot;","body":"\n\n<h1 align=\"center\">HTML::Tree::Scanning</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Tree::Scanning\n-- article: &quot;Scanning HTML&quot;</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"># This an\narticle, not a module.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\narticle by Sean M. Burke first appeared in <i>The Perl\nJournal</i> #19 and is copyright 2000 The Perl Journal. It\nappears courtesy of Jon Orwant and The Perl Journal. This\ndocument may be distributed under the same terms as Perl\nitself.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(Note that this\nis discussed in chapters 6 through 10 of the book <i>Perl\nand <small>LWP</small></i>\n&lt;http://lwp.interglacial.com/&gt; which was written after\nthe following documentation, and which is available free\nonline.)</p>\n\n<h2>Scanning HTML\n<a name=\"Scanning HTML\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- Sean M.\nBurke</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In <i>The Perl\nJournal</i> issue 17, Ken MacFarlane&rsquo;s article\n&quot;Parsing <small>HTML</small> with HTML::Parser&quot;\ndescribes how the HTML::Parser module scans\n<small>HTML</small> source as a stream of start-tags,\nend-tags, text, comments, etc. In <small>TPJ</small> #18, my\n&quot;Trees&quot; article kicked around the idea of\ntree-shaped data structures. Now I&rsquo;ll try to tie it\ntogether, in a discussion of <small>HTML</small> trees.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<small>CPAN</small> module HTML::TreeBuilder takes the tags\nthat HTML::Parser picks out, and builds a parse tree -- a\ntree-shaped network of objects...</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: And\nif you need a quick explanation of objects, see my\n<small>TPJ17</small> article &quot;A User&rsquo;s View of\nObject-Oriented Modules&quot;; or go whole hog and get\nDamian Conway&rsquo;s excellent book <i>Object-Oriented\nPerl</i>, from Manning Publications.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">...representing\nthe structured content of the <small>HTML</small> document.\nAnd once the document is parsed as a tree, you&rsquo;ll find\nthe common tasks of extracting data from that\n<small>HTML</small> document/tree to be quite\nstraightforward.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>HTML::Parser,\nHTML::TreeBuilder, and HTML::Element</b> <br>\nYou use HTML::TreeBuilder to make a parse tree out of an\n<small>HTML</small> source file, by simply saying:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTML::TreeBuilder; <br>\nmy $tree = HTML::TreeBuilder-&gt;new(); <br>\n$tree-&gt;parse_file('foo.html');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and then $tree\ncontains a parse tree built from the <small>HTML</small>\nsource from the file &quot;foo.html&quot;. The way this\nparse tree is represented is with a network of objects --\n$tree is the root, an element with tag-name\n&quot;html&quot;, and its children typically include a\n&quot;head&quot; and &quot;body&quot; element, and so on.\nElements in the tree are objects of the class\nHTML::Element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, if you take\nthis source:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;html&gt;&lt;head&gt;&lt;title&gt;Doc\n1&lt;/title&gt;&lt;/head&gt; <br>\n&lt;body&gt; <br>\nStuff &lt;hr&gt; 2000-08-17 <br>\n&lt;/body&gt;&lt;/html&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and feed it to\nHTML::TreeBuilder, it&rsquo;ll return a tree of objects that\nlooks like this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">html <br>\n/ \\ <br>\nhead body <br>\n/ / | \\ <br>\ntitle &quot;Stuff&quot; hr &quot;2000-08-17&quot; <br>\n| <br>\n&quot;Doc 1&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is a\npretty simple document, but if it were any more complex,\nit&rsquo;d be a bit hard to draw in that style, since\nit&rsquo;s sprawl left and right. The same tree can be\nrepresented a bit more easily sideways, with indenting:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">. html <br>\n. head <br>\n. title <br>\n. &quot;Doc 1&quot; <br>\n. body <br>\n. &quot;Stuff&quot; <br>\n. hr <br>\n. &quot;2000-08-17&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Either way\nexpresses the same structure. In that structure, the root\nnode is an object of the class HTML::Element</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: Well\nactually, the root is of the class HTML::TreeBuilder, but\nthat&rsquo;s just a subclass of HTML::Element, plus the few\nextra methods like &quot;parse_file&quot; that elaborate the\ntree</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">, with the tag\nname &quot;html&quot;, and with two children: an\nHTML::Element object whose tag names are &quot;head&quot;\nand &quot;body&quot;. And each of those elements have\nchildren, and so on down. Not all elements (as we&rsquo;ll\ncall the objects of class HTML::Element) have children --\nthe &quot;hr&quot; element doesn&rsquo;t. And note all nodes\nin the tree are elements -- the text nodes (&quot;Doc\n1&quot;, &quot;Stuff&quot;, and &quot;2000-08-17&quot;) are\njust strings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Objects of the\nclass HTML::Element each have three noteworthy attributes:\n<br>\n&quot;_tag&quot; -- (best accessed as\n&quot;$e-&gt;tag&quot;) this element&rsquo;s tag-name, <br>\nlowercased (e.g., &quot;em&quot; for an &quot;em&quot;\nelement).</p>\n\n<p style=\"margin-left:23%;\">Footnote: Yes, this is\nmisnamed. In proper <small>SGML</small> terminology, this is\ninstead called a &quot; <small>GI&quot;,</small> short for\n&quot;generic identifier&quot;; and the term &quot;tag&quot;\nis used for a token of <small>SGML</small> source that\nrepresents either the start of an element (a start-tag like\n&quot;&lt;em lang=&rsquo;fr&rsquo;&gt;&quot;) or the end of\nan element (an end-tag like &quot;&lt;/em&gt;&quot;.\nHowever, since more people claim to have been abducted by\naliens than to have ever seen the <small>SGML</small>\nstandard, and since both encounters typically involve a\nfeeling of &quot;missing time&quot;, it&rsquo;s not\nsurprising that the terminology of the <small>SGML</small>\nstandard is not closely followed.</p>\n\n<p style=\"margin-left:11%;\">&quot;_parent&quot; -- (best\naccessed as &quot;$e-&gt;parent&quot;) the element that is\n$obj&rsquo;s <br>\nparent, or undef if this element is the root of its tree.\n<br>\n&quot;_content&quot; -- (best accessed as\n&quot;$e-&gt;content_list&quot;) the list of nodes <br>\n(i.e., elements or text segments) that are $e&rsquo;s\nchildren.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Moreover, if an\nelement object has any attributes in the <small>SGML</small>\nsense of the word, then those are readable as\n&quot;$e-&gt;attr('name')&quot; -- for example, with the\nobject built from having parsed &quot;&lt;a\n<b>id=&rsquo;foo&rsquo;</b>&gt;bar&lt;/a&gt;&quot;,\n&quot;$e-&gt;attr('id')&quot; will return the string\n&quot;foo&quot;. Moreover, &quot;$e-&gt;tag&quot; on that\nobject returns the string &quot;a&quot;,\n&quot;$e-&gt;content_list&quot; returns a list consisting of\njust the single scalar &quot;bar&quot;, and\n&quot;$e-&gt;parent&quot; returns the object that&rsquo;s\nthis node&rsquo;s parent -- which may be, for example, a\n&quot;p&quot; element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And\nthat&rsquo;s all that there is to it -- you throw\n<small>HTML</small> source at TreeBuilder, and it returns a\ntree built of HTML::Element objects and some text\nstrings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, what\ndo you <i>do</i> with a tree of objects? People code\ninformation into <small>HTML</small> trees not for the fun\nof arranging elements, but to represent the structure of\nspecific text and images -- some text is in this\n&quot;li&quot; element, some other text is in that heading,\nsome images are in that other table cell that has those\nattributes, and so on.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, it may\nhappen that you&rsquo;re rendering that whole\n<small>HTML</small> tree into some layout format. Or you\ncould be trying to make some systematic change to the\n<small>HTML</small> tree before dumping it out as\n<small>HTML</small> source again. But, in my experience, by\nfar the most common programming task that Perl programmers\nface with <small>HTML</small> is in trying to extract some\npiece of information from a larger document. Since\nthat&rsquo;s so common (and also since it involves concepts\nthat are basic to more complex tasks), that is what the rest\nof this article will be about.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Scanning\n<small>HTML</small> trees</b> <br>\nSuppose you have a thousand <small>HTML</small> documents,\neach of them a press release. They all start out:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[...lots of\nleading images and junk...] <br>\n&lt;h1&gt;ConGlomCo to Open New Corporate Office in\nOugadougou&lt;/h1&gt; <br>\nBAKERSFIELD, CA, 2000-04-24 -- ConGlomCo's vice president in\ncharge <br>\nof world conquest, Rock Feldspar, announced today the\nopening of a <br>\nnew office in Ougadougou, the capital city of Burkino Faso,\ngateway <br>\nto the bustling &quot;Silicon Sahara&quot; of Africa... <br>\n[...etc...]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...and what\nyou&rsquo;ve got to do is, for each document, copy whatever\ntext is in the &quot;h1&quot; element, so that you can, for\nexample, make a table of contents of it. Now, there are\nthree ways to do this:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>You can just use a regexp to scan the file for a text\npattern.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For many very\nsimple tasks, this will do fine. Many <small>HTML</small>\ndocuments are, in practice, very consistently formatted as\nfar as placement of linebreaks and whitespace, so you could\njust get away with scanning the file like so:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">sub get_heading\n{ <br>\nmy $filename = $_[0]; <br>\nlocal *HTML; <br>\nopen(HTML, $filename) <br>\nor die &quot;Couldn't open $filename); <br>\nmy $heading; <br>\nLine: <br>\nwhile(&lt;HTML&gt;) { <br>\nif( m{&lt;h1&gt;(.*?)&lt;/h1&gt;}i ) { # match it! <br>\n$heading = $1; <br>\nlast Line; <br>\n} <br>\n} <br>\nclose(HTML); <br>\nwarn &quot;No heading in $filename?&quot; <br>\nunless defined $heading; <br>\nreturn $heading; <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This is quick\nand fast, but awfully fragile -- if there&rsquo;s a newline\nin the middle of a heading&rsquo;s text, it won&rsquo;t\nmatch the above regexp, and you&rsquo;ll get an error. The\nregexp will also fail if the &quot;h1&quot; element&rsquo;s\nstart-tag has any attributes. If you have to adapt your code\nto fit more kinds of start-tags, you&rsquo;ll end up\nbasically reinventing part of HTML::Parser, at which point\nyou should probably just stop, and use HTML::Parser\nitself:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">You can use HTML::Parser to scan\nthe file for an &quot;h1&quot; start-tag token, then capture\nall the text tokens until the &quot;h1&quot; close-tag. This\napproach is extensively covered in the Ken\nMacFarlane&rsquo;s <small>TPJ17</small> article\n&quot;Parsing <small>HTML</small> with HTML::Parser&quot;.\n(A variant of this approach is to use HTML::TokeParser,\nwhich presents a different and rather handier interface to\nthe tokens that HTML::Parser picks out.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Using\nHTML::Parser is less fragile than our first approach, since\nit&rsquo;s not sensitive to the exact internal formatting of\nthe start-tag (much less whether it&rsquo;s split across two\nlines). However, when you need more information about the\ncontext of the &quot;h1&quot; element, or if you&rsquo;re\nhaving to deal with any of the tricky bits of\n<small>HTML,</small> such as parsing of tables, you&rsquo;ll\nfind out the flat list of tokens that HTML::Parser returns\nisn&rsquo;t immediately useful. To get something useful out\nof those tokens, you&rsquo;ll need to write code that knows\nsome things about what elements take no content (as with\n&quot;hr&quot; elements), and that a &quot;&lt;/p&gt;&quot;\nend-tags are omissible, so a &quot;&lt;p&gt;&quot; will end\nany currently open paragraph -- and you&rsquo;re well on\nyour way to pointlessly reinventing much of the code in\nHTML::TreeBuilder</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Footnote: And,\nas the person who last rewrote that module, I can attest\nthat it wasn&rsquo;t terribly easy to get right! Never\nunderestimate the perversity of people coding\n<small>HTML.</small></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">, at which\npoint you should probably just stop, and use\nHTML::TreeBuilder itself:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">You can use HTML::Treebuilder,\nand scan the tree of element objects that you get back.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The last\napproach, using HTML::TreeBuilder, is the diametric opposite\nof first approach: The first approach involves just\nelementary Perl and one regexp, whereas the TreeBuilder\napproach involves being at home with the concept of\ntree-shaped data structures and modules with object-oriented\ninterfaces, as well as with the particular interfaces that\nHTML::TreeBuilder and HTML::Element provide.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, what\nthe TreeBuilder approach has going for it is that it&rsquo;s\nthe most robust, because it involves dealing with\n<small>HTML</small> in its &quot;native&quot; format -- it\ndeals with the tree structure that <small>HTML</small> code\nrepresents, without any consideration of how the source is\ncoded and with what tags omitted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, to extract\nthe text from the &quot;h1&quot; elements of an\n<small>HTML</small> document:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub get_heading\n{ <br>\nmy $tree = HTML::TreeBuilder-&gt;new; <br>\n$tree-&gt;parse_file($_[0]); # ! <br>\nmy $heading; <br>\nmy $h1 = $tree-&gt;look_down('_tag', 'h1'); # ! <br>\nif($h1) { <br>\n$heading = $h1-&gt;as_text; # ! <br>\n} else { <br>\nwarn &quot;No heading in $_[0]?&quot;; <br>\n} <br>\n$tree-&gt;delete; # clear memory! <br>\nreturn $heading; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This uses some\nunfamiliar methods that need explaining. The\n&quot;parse_file&quot; method that we&rsquo;ve seen before,\nbuilds a tree based on source from the file given. The\n&quot;delete&quot; method is for marking a tree&rsquo;s\ncontents as available for garbage collection, when\nyou&rsquo;re done with the tree. The &quot;as_text&quot;\nmethod returns a string that contains all the text bits that\nare children (or otherwise descendants) of the given node --\nto get the text content of the $h1 object, we could just\nsay:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$heading = join\n'', $h1-&gt;content_list;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">but that will\nwork only if we&rsquo;re sure that the &quot;h1&quot;\nelement&rsquo;s children will be only text bits -- if the\ndocument contained:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;h1&gt;Local\nMan Sees &lt;cite&gt;Blade&lt;/cite&gt; Again&lt;/h1&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then the\nsub-tree would be:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">. h1 <br>\n. &quot;Local Man Sees &quot; <br>\n. cite <br>\n. &quot;Blade&quot; <br>\n. &quot; Again'</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">so &quot;join\n'', $h1-&gt;content_list&quot; will be something like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Local Man Sees\nHTML::Element=HASH(0x15424040) Again</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">whereas\n&quot;$h1-&gt;as_text&quot; would yield:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Local Man Sees\nBlade Again</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and depending\non what you&rsquo;re doing with the heading text, you might\nwant the &quot;as_HTML&quot; method instead. It returns the\n(sub)tree represented as <small>HTML</small> source.\n&quot;$h1-&gt;as_HTML&quot; would yield:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;h1&gt;Local\nMan Sees &lt;cite&gt;Blade&lt;/cite&gt; Again&lt;/h1&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if you\nwanted the contents of $h1 as <small>HTML,</small> but not\nthe $h1 itself, you could say:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">join '', <br>\nmap( <br>\nref($_) ? $_-&gt;as_HTML : $_, <br>\n$h1-&gt;content_list <br>\n)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This\n&quot;map&quot; iterates over the nodes in $h1&rsquo;s list\nof children; and for each node that&rsquo;s just a text bit\n(as &quot;Local Man Sees &quot; is), it just passes through\nthat string value, and for each node that&rsquo;s an actual\nobject (causing &quot;ref&quot; to be true),\n&quot;as_HTML&quot; will used instead of the string value of\nthe object itself (which would be something quite useless,\nas most object values are). So that &quot;as_HTML&quot; for\nthe &quot;cite&quot; element will be the string\n&quot;&lt;cite&gt;Blade&lt;/cite&gt;&quot;. And then,\nfinally, &quot;join&quot; just puts into one string all the\nstrings that the &quot;map&quot; returns.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Last but not\nleast, the most important method in our\n&quot;get_heading&quot; sub is the &quot;look_down&quot;\nmethod. This method looks down at the subtree starting at\nthe given object ($h1), looking for elements that meet\ncriteria you provide.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The criteria\nare specified in the method&rsquo;s argument list. Each\ncriterion can consist of two scalars, a key and a value,\nwhich express that you want elements that have that\nattribute (like &quot;_tag&quot;, or &quot;src&quot;) with\nthe given value (&quot;h1&quot;); or the criterion can be a\nreference to a subroutine that, when called on the given\nelement, returns true if that is a node you&rsquo;re looking\nfor. If you specify several criteria, then that&rsquo;s\ntaken to mean that you want all the elements that each\nsatisfy <i>all</i> the criteria. (In other words,\nthere&rsquo;s an &quot;implicit <small>AND&quot;.</small>\n)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And finally,\nthere&rsquo;s a bit of an optimization -- if you call the\n&quot;look_down&quot; method in a scalar context, you get\njust the <i>first</i> node (or undef if none) -- and, in\nfact, once &quot;look_down&quot; finds that first matching\nelement, it doesn&rsquo;t bother looking any further.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So the\nexample:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h1 =\n$tree-&gt;look_down('_tag', 'h1');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">returns the\nfirst element at-or-under $tree whose &quot;_tag&quot;\nattribute has the value &quot;h1&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Complex\nCriteria in Tree Scanning</b> <br>\nNow, the above &quot;look_down&quot; code looks like a lot\nof bother, with barely more benefit than just grepping the\nfile! But consider if your criteria were more complicated --\nsuppose you found that some of the press releases that you\nwere scanning had several &quot;h1&quot; elements, possibly\nbefore or after the one you actually want. For example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;h1&gt;&lt;center&gt;Visit\nOur Corporate Partner <br>\n&lt;br&gt;&lt;a href=&quot;/dyna/clickthru&quot; <br>\n&gt;&lt;img src=&quot;/dyna/vend_ad&quot;&gt;&lt;/a&gt; <br>\n&lt;/center&gt;&lt;/h1&gt; <br>\n&lt;h1&gt;&lt;center&gt;ConGlomCo President Schreck to Visit\nRegional HQ <br>\n&lt;br&gt;&lt;a\nhref=&quot;/photos/Schreck_visit_large.jpg&quot; <br>\n&gt;&lt;img\nsrc=&quot;/photos/Schreck_visit.jpg&quot;&gt;&lt;/a&gt; <br>\n&lt;/center&gt;&lt;/h1&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here, you want\nto ignore the first &quot;h1&quot; element because it\ncontains an ad, and you want the text from the second\n&quot;h1&quot;. The problem is in formalizing the way you\nknow that it&rsquo;s an ad. Since ad banners are always\nentreating you to &quot;visit&quot; the sponsoring site, you\ncould exclude &quot;h1&quot; elements that contain the word\n&quot;visit&quot; under them:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $real_h1 =\n$tree-&gt;look_down( <br>\n'_tag', 'h1', <br>\nsub { <br>\n$_[0]-&gt;as_text !~ m/\\bvisit/i <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first\ncriterion looks for &quot;h1&quot; elements, and the second\ncriterion limits those to only the ones whose text content\ndoesn&rsquo;t match &quot;m/\\bvisit/&quot;. But\nunfortunately, that won&rsquo;t work for our example, since\nthe second &quot;h1&quot; mentions &quot;ConGlomCo President\nSchreck to <i>Visit</i> Regional\n<small>HQ&quot;.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Instead you\ncould try looking for the first &quot;h1&quot; element that\ndoesn&rsquo;t contain an image:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $real_h1 =\n$tree-&gt;look_down( <br>\n'_tag', 'h1', <br>\nsub { <br>\nnot $_[0]-&gt;look_down('_tag', 'img') <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This criterion\nsub might seem a bit odd, since it calls\n&quot;look_down&quot; as part of a larger\n&quot;look_down&quot; operation, but that&rsquo;s fine. Note\nthat when considered as a boolean value, a\n&quot;look_down&quot; in a scalar context value returns\nfalse (specifically, undef) if there&rsquo;s no matching\nelement at or under the given element; and it returns the\nfirst matching element (which, being a reference and object,\nis always a true value), if any matches. So, here,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub { <br>\nnot $_[0]-&gt;look_down('_tag', 'img') <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">means\n&quot;return true only if this element has no\n&rsquo;img&rsquo; element as descendants (and isn&rsquo;t an\n&rsquo;img&rsquo; element itself).&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This correctly\nfilters out the first &quot;h1&quot; that contains the ad,\nbut it also incorrectly filters out the second\n&quot;h1&quot; that contains a non-advertisement photo\nbesides the headline text you want.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There clearly\nare detectable differences between the first and second\n&quot;h1&quot; elements -- the only second one contains the\nstring &quot;Schreck&quot;, and we could just test for\nthat:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $real_h1 =\n$tree-&gt;look_down( <br>\n'_tag', 'h1', <br>\nsub { <br>\n$_[0]-&gt;as_text =~ m{Schreck} <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And that works\nfine for this one example, but unless all thousand of your\npress releases have &quot;Schreck&quot; in the headline,\nthat&rsquo;s just not a general solution. However, if all\nthe ads-in-&quot;h1&quot;s that you want to exclude involve\na link whose <small>URL</small> involves &quot;/dyna/&quot;,\nthen you can use that:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $real_h1 =\n$tree-&gt;look_down( <br>\n'_tag', 'h1', <br>\nsub { <br>\nmy $link = $_[0]-&gt;look_down('_tag','a'); <br>\nreturn 1 unless $link; <br>\n# no link means it's fine <br>\nreturn 0 if $link-&gt;attr('href') =~ m{/dyna/}; <br>\n# a link to there is bad <br>\nreturn 1; # otherwise okay <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Or you can look\nat it another way and say that you want the first\n&quot;h1&quot; element that either contains no images, or\nelse whose image has a &quot;src&quot; attribute whose value\ncontains &quot;/photos/&quot;:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $real_h1 =\n$tree-&gt;look_down( <br>\n'_tag', 'h1', <br>\nsub { <br>\nmy $img = $_[0]-&gt;look_down('_tag','img'); <br>\nreturn 1 unless $img; <br>\n# no image means it's fine <br>\nreturn 1 if $img-&gt;attr('src') =~ m{/photos/}; <br>\n# good if a photo <br>\nreturn 0; # otherwise bad <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Recall that\nthis use of &quot;look_down&quot; in a scalar context means\nto return the first element at or under $tree that matches\nall the criteria. But if you notice that you can formulate\ncriteria that&rsquo;ll match several possible &quot;h1&quot;\nelements, some of which may be bogus but the <i>last</i> one\nof which is always the one you want, then you can use\n&quot;look_down&quot; in a list context, and just use the\nlast element of that list:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my @h1s =\n$tree-&gt;look_down( <br>\n'_tag', 'h1', <br>\n...maybe more criteria... <br>\n); <br>\ndie &quot;What, no h1s here?&quot; unless @h1s; <br>\nmy $real_h1 = $h1s[-1]; # last or only</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>A Case\nStudy: Scanning Yahoo News&rsquo;s <small>HTML</small></b>\n<br>\nThe above (somewhat contrived) case involves extracting data\nfrom a bunch of pre-existing <small>HTML</small> files. In\nthat sort of situation, if your code works for all the\nfiles, then you know that the code <i>works</i> -- since the\ndata it&rsquo;s meant to handle won&rsquo;t go changing or\ngrowing; and, typically, once you&rsquo;ve used the program,\nyou&rsquo;ll never need to use it again.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The other kind\nof situation faced in many data extraction tasks is where\nthe program is used recurringly to handle new data -- such\nas from ever-changing Web pages. As a real-world example of\nthis, consider a program that you could use (suppose\nit&rsquo;s crontabbed) to extract headline-links from\nsubsections of Yahoo News\n(&quot;http://dailynews.yahoo.com/&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Yahoo News has\nseveral subsections: <br>\nhttp://dailynews.yahoo.com/h/tc/ for technology news <br>\nhttp://dailynews.yahoo.com/h/sc/ for science news <br>\nhttp://dailynews.yahoo.com/h/hl/ for health news <br>\nhttp://dailynews.yahoo.com/h/wl/ for world news <br>\nhttp://dailynews.yahoo.com/h/en/ for entertainment news</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and others. All\nof them are built on the same basic <small>HTML</small>\ntemplate -- and a scarily complicated template it is,\nespecially when you look at it with an eye toward making up\nrules that will select where the real headline-links are,\nwhile screening out all the links to other parts of Yahoo,\nother news services, etc. You will need to puzzle over the\n<small>HTML</small> source, and scrutinize the output of\n&quot;$tree-&gt;dump&quot; on the parse tree of that\n<small>HTML.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sometimes the\nonly way to pin down what you&rsquo;re after is by position\nin the tree. For example, headlines of interest may be in\nthe third column of the second row of the second table\nelement in a page:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $table = (\n$tree-&gt;look_down('_tag','table') )[1]; <br>\nmy $row2 = ( $table-&gt;look_down('_tag', 'tr' ) )[1]; <br>\nmy $col3 = ( $row2-&gt;look-down('_tag', 'td') )[2]; <br>\n...then do things with $col3...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Or they may be\nall the links in a &quot;p&quot; element that has at least\nthree &quot;br&quot; elements as children:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $p =\n$tree-&gt;look_down( <br>\n'_tag', 'p', <br>\nsub { <br>\n2 &lt; grep { ref($_) and $_-&gt;tag eq 'br' } <br>\n$_[0]-&gt;content_list <br>\n} <br>\n); <br>\n@links = $p-&gt;look_down('_tag', 'a');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But almost\nalways, you can get away with looking for properties of the\nof the thing itself, rather than just looking for contexts.\nNow, if you&rsquo;re lucky, the document you&rsquo;re\nlooking through has clear semantic tagging, such is as\nuseful in <small>CSS</small> -- note the\nclass=&quot;headlinelink&quot; bit here:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;a\nhref=&quot;...long_news_url...&quot;\nclass=&quot;headlinelink&quot;&gt;Elvis <br>\nseen in tortilla&lt;/a&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you find\nanything like that, you could leap right in and select links\nwith:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@links =\n$tree-&gt;look_down('class','headlinelink');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Regrettably,\nyour chances of seeing any sort of semantic markup\nprinciples really being followed with actual\n<small>HTML</small> are pretty thin.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Footnote: In\nfact, your chances of finding a page that is simply free of\n<small>HTML</small> errors are even thinner. And\nsurprisingly, sites like Amazon or Yahoo are typically worse\nas far as quality of code than personal sites whose entire\nproduction cycle involves simply being saved and uploaded\nfrom Netscape Composer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The code may be\nsort of &quot;accidentally semantic&quot;, however -- for\nexample, in a set of pages I was scanning recently, I found\nthat looking for &quot;td&quot; elements with a\n&quot;width&quot; attribute value of &quot;375&quot; got me\nexactly what I wanted. No-one designing that page ever\nconceived of &quot;width=375&quot; as <i>meaning</i>\n&quot;this is a headline&quot;, but if you impute it to mean\nthat, it works.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An approach\nlike this happens to work for the Yahoo News code, because\nthe headline-links are distinguished by the fact that they\n(and they alone) contain a &quot;b&quot; element:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;a\nhref=&quot;...long_news_url...&quot;&gt;&lt;b&gt;Elvis seen\nin tortilla&lt;/b&gt;&lt;/a&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">or, diagrammed\nas a part of the parse tree:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">. a\n[href=&quot;...long_news_url...&quot;] <br>\n. b <br>\n. &quot;Elvis seen in tortilla&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A rule that\nmatches these can be formalized as &quot;look for any\n&rsquo;a&rsquo; element that has only one daughter node,\nwhich must be a &rsquo;b&rsquo; element&quot;. And this is\nwhat it looks like when cooked up as a &quot;look_down&quot;\nexpression and prefaced with a bit of code that retrieves\nthe text of the given Yahoo News page and feeds it to\nTreeBuilder:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use strict;\n<br>\nuse HTML::TreeBuilder 2.97; <br>\nuse LWP::UserAgent; <br>\nsub get_headlines { <br>\nmy $url = $_[0] || die &quot;What URL?&quot;; <br>\nmy $response = LWP::UserAgent-&gt;new-&gt;request( <br>\nHTTP::Request-&gt;new( GET =&gt; $url ) <br>\n); <br>\nunless($response-&gt;is_success) { <br>\nwarn &quot;Couldn't get $url: &quot;,\n$response-&gt;status_line, &quot;\\n&quot;; <br>\nreturn; <br>\n} <br>\nmy $tree = HTML::TreeBuilder-&gt;new(); <br>\n$tree-&gt;parse($response-&gt;content); <br>\n$tree-&gt;eof; <br>\nmy @out; <br>\nforeach my $link ( <br>\n$tree-&gt;look_down( # ! <br>\n'_tag', 'a', <br>\nsub { <br>\nreturn unless $_[0]-&gt;attr('href'); <br>\nmy @c = $_[0]-&gt;content_list; <br>\n@c == 1 and ref $c[0] and $c[0]-&gt;tag eq 'b'; <br>\n} <br>\n) <br>\n) { <br>\npush @out, [ $link-&gt;attr('href'), $link-&gt;as_text ];\n<br>\n} <br>\nwarn &quot;Odd, fewer than 6 stories in $url!&quot; if @out\n&lt; 6; <br>\n$tree-&gt;delete; <br>\nreturn @out; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...and add a\nbit of code to actually call that routine and display the\nresults...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">foreach my\n$section (qw[tc sc hl wl en]) { <br>\nmy @links = get_headlines( <br>\n&quot;http://dailynews.yahoo.com/h/$section/&quot; <br>\n); <br>\nprint <br>\n$section, &quot;: &quot;, scalar(@links), &quot;\nstories\\n&quot;, <br>\nmap((&quot; &quot;, $_-&gt;[0], &quot; : &quot;, $_-&gt;[1],\n&quot;\\n&quot;), @links), <br>\n&quot;\\n&quot;; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And we&rsquo;ve\ngot our own headline-extractor service! This in and of\nitself isn&rsquo;t no amazingly useful (since if you want to\nsee the headlines, you <i>can</i> just look at the Yahoo\nNews pages), but it could easily be the basis for quite\nuseful features like filtering the headlines for matching\ncertain keywords of interest to you.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, one of\nthese days, Yahoo News will decide to change its\n<small>HTML</small> template. When this happens, this will\nappear to the above program as there being no links that\nmeet the given criteria; or, less likely, dozens of\nerroneous links will meet the criteria. In either case, the\ncriteria will have to be changed for the new template; they\nmay just need adjustment, or you may need to scrap them and\nstart over.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Regardez,\nduvet!</i> <br>\nIt&rsquo;s often quite a challenge to write criteria to\nmatch the desired parts of an <small>HTML</small> parse\ntree. Very often you <i>can</i> pull it off with a simple\n&quot;$tree-&gt;look_down('_tag', 'h1')&quot;, but sometimes\nyou do have to keep adding and refining criteria, until you\nmight end up with complex filters like what I&rsquo;ve shown\nin this article. The benefit to learning how to deal with\n<small>HTML</small> parse trees is that one main search\ntool, the &quot;look_down&quot; method, can do most of the\nwork, making simple things easy, while still making hard\nthings possible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>[end body of\narticle]</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>[Author\nCredit]</b> <br>\nSean M. Burke (&quot;sburke@cpan.org&quot;) is the current\nmaintainer of &quot;HTML::TreeBuilder&quot; and\n&quot;HTML::Element&quot;, both originally by Gisle Aas.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sean adds:\n&quot;I&rsquo;d like to thank the folks who listened to me\nramble incessantly about HTML::TreeBuilder and HTML::Element\nat this year&rsquo;s Yet Another Perl Conference and\nO&rsquo;Reilly Open Source Software Convention.&quot;</p>\n\n<h2>BACK\n<a name=\"BACK\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Return to the\nHTML::Tree docs.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#Scanning HTML\">Scanning HTML</a>","<a href=\"#BACK\">BACK</a>"],"level":3}