{"name":"fmemopen","description":"fmemopen - open memory as stream","body":"\n\n<h1 align=\"center\">FMEMOPEN</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fmemopen - open\nmemory as stream</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;stdio.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>FILE\n*fmemopen(void *</b><i>buf</i><b>, size_t</b>\n<i>size</i><b>, const char *</b><i>mode</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>fmemopen</b>():</p>\n\n<p style=\"margin-left:17%;\">Since glibc 2.10:</p>\n\n\n<p style=\"margin-left:23%;\">_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200809L</p>\n\n<p style=\"margin-left:17%;\">Before glibc 2.10:</p>\n\n<p style=\"margin-left:23%;\">_GNU_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>fmemopen</b>() function opens a stream that permits the\naccess specified by <i>mode</i>. The stream allows I/O to be\nperformed on the string or memory buffer pointed to by\n<i>buf</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>mode</i>\nargument specifies the semantics of I/O on the stream, and\nis one of the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>r</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>The stream is opened for reading.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>w</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>The stream is opened for writing.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>a</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>Append; open the stream for writing, with the initial\nbuffer position set to the first null byte.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>r+</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>Open the stream for reading and writing.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>w+</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>Open the stream for reading and writing. The buffer\ncontents are truncated (i.e., '\\0' is placed in the first\nbyte of the buffer).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><i>a+</i></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>Append; open the stream for reading and writing, with\nthe initial buffer position set to the first null byte.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The stream\nmaintains the notion of a current position, the location\nwhere the next I/O operation will be performed. The current\nposition is implicitly updated by I/O operations. It can be\nexplicitly updated using <a href=\"https://man.page/3/fseek\">fseek(3)</a>, and determined\nusing <a href=\"https://man.page/3/ftell\">ftell(3)</a>. In all modes other than append, the\ninitial position is set to the start of the buffer. In\nappend mode, if no null byte is found within the buffer,\nthen the initial position is <i>size+1</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>buf</i>\nis specified as NULL, then <b>fmemopen</b>() allocates a\nbuffer of <i>size</i> bytes. This is useful for an\napplication that wants to write data to a temporary buffer\nand then read it back again. The initial position is set to\nthe start of the buffer. The buffer is automatically freed\nwhen the stream is closed. Note that the caller has no way\nto obtain a pointer to the temporary buffer allocated by\nthis call (but see <a href=\"https://man.page/3/open_memstream\">open_memstream(3)</a>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <i>buf</i>\nis not NULL, then it should point to a buffer of at least\n<i>len</i> bytes allocated by the caller.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a stream\nthat has been opened for writing is flushed\n(<a href=\"https://man.page/3/fflush\">fflush(3)</a>) or closed (<a href=\"https://man.page/3/fclose\">fclose(3)</a>), a null byte\nis written at the end of the buffer if there is space. The\ncaller should ensure that an extra byte is available in the\nbuffer (and that <i>size</i> counts that byte) to allow for\nthis.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a stream\nopened for reading, null bytes ('\\0') in the buffer do not\ncause read operations to return an end-of-file indication. A\nread from the buffer will indicate end-of-file only when the\ncurrent buffer position advances <i>size</i> bytes past the\nstart of the buffer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Write\noperations take place either at the current position (for\nmodes other than append), or at the current size of the\nstream (for append modes).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Attempts to\nwrite more than <i>size</i> bytes to the buffer result in an\nerror. By default, such errors will be visible (by the\nabsence of data) only when the <i>stdio</i> buffer is\nflushed. Disabling buffering with the following call may be\nuseful to detect errors at the time of an output\noperation:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">setbuf(stream,\nNULL);</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Upon successful\ncompletion, <b>fmemopen</b>() returns a <i>FILE</i> pointer.\nOtherwise, NULL is returned and <i>errno</i> is set to\nindicate the error.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>fmemopen</b>()\nwas already available in glibc 1.0.x.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3398041.png\" alt=\"Image grohtml-3398041.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2008.\nThis function is not specified in POSIX.1-2001, and is not\nwidely available on other systems.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2008\nspecifies that 'b' in <i>mode</i> shall be ignored. However,\nTechnical Corrigendum 1 adjusts the standard to allow\nimplementation-specific treatment for this case, thus\npermitting the glibc treatment of 'b'.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is no\nfile descriptor associated with the file stream returned by\nthis function (i.e., <a href=\"https://man.page/3/fileno\">fileno(3)</a> will return an error\nif called on the returned stream).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With version\n2.22, binary mode (see below) was removed, many longstanding\nbugs in the implementation of <b>fmemopen</b>() were fixed,\nand a new versioned symbol was created for this\ninterface.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Binary\nmode</b> <br>\nFrom version 2.9 to 2.21, the glibc implementation of\n<b>fmemopen</b>() supported a &quot;binary&quot; mode,\nenabled by specifying the letter 'b' as the second character\nin <i>mode</i>. In this mode, writes don&rsquo;t implicitly\nadd a terminating null byte, and <a href=\"https://man.page/3/fseek\">fseek(3)</a>\n<b>SEEK_END</b> is relative to the end of the buffer (i.e.,\nthe value specified by the <i>size</i> argument), rather\nthan the current string length.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An API bug\nafflicted the implementation of binary mode: to specify\nbinary mode, the 'b' must be the <i>second</i> character in\n<i>mode</i>. Thus, for example, &quot;wb+&quot; has the\ndesired effect, but &quot;w+b&quot; does not. This is\ninconsistent with the treatment of <i>mode</i> by\n<a href=\"https://man.page/3/fopen\">fopen(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Binary mode was\nremoved in glibc 2.22; a 'b' specified in <i>mode</i> has no\neffect.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In versions of\nglibc before 2.22, if <i>size</i> is specified as zero,\n<b>fmemopen</b>() fails with the error <b>EINVAL</b>. It\nwould be more consistent if this case successfully created a\nstream that then returned end-of-file on the first attempt\nat reading; since version 2.22, the glibc implementation\nprovides that behavior.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In versions of\nglibc before 2.22, specifying append mode (&quot;a&quot; or\n&quot;a+&quot;) for <b>fmemopen</b>() sets the initial\nbuffer position to the first null byte, but (if the current\nposition is reset to a location other than the end of the\nstream) does not force subsequent writes to append at the\nend of the stream. This bug is fixed in glibc 2.22.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In versions of\nglibc before 2.22, if the <i>mode</i> argument to\n<b>fmemopen</b>() specifies append (&quot;a&quot; or\n&quot;a+&quot;), and the <i>size</i> argument does not cover\na null byte in <i>buf</i>, then, according to POSIX.1-2008,\nthe initial buffer position should be set to the next byte\nafter the end of the buffer. However, in this case the glibc\n<b>fmemopen</b>() sets the buffer position to -1. This bug\nis fixed in glibc 2.22.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In versions of\nglibc before 2.22, when a call to <a href=\"https://man.page/3/fseek\">fseek(3)</a> with a\n<i>whence</i> value of <b>SEEK_END</b> was performed on a\nstream created by <b>fmemopen</b>(), the <i>offset</i> was\n<i>subtracted</i> from the end-of-stream position, instead\nof being added. This bug is fixed in glibc 2.22.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The glibc 2.9\naddition of &quot;binary&quot; mode for <b>fmemopen</b>()\nsilently changed the ABI: previously, <b>fmemopen</b>()\nignored 'b' in <i>mode</i>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow uses <b>fmemopen</b>() to open an input buffer, and\n<a href=\"https://man.page/3/open_memstream\">open_memstream(3)</a> to open a dynamically sized output\nbuffer. The program scans its input string (taken from the\nprogram&rsquo;s first command-line argument) reading\nintegers, and writes the squares of these integers to the\noutput buffer. An example of the output produced by this\nprogram is the following:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out '1\n23 43'</b> <br>\nsize=11; ptr=1 529 1849</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE <br>\n#include &lt;string.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error(msg) \\ <br>\ndo { perror(msg); exit(EXIT_FAILURE); } while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nFILE *out, *in; <br>\nint v, s; <br>\nsize_t size; <br>\nchar *ptr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Usage: %s '&lt;num&gt;...'\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">in =\nfmemopen(argv[1], strlen(argv[1]), &quot;r&quot;); <br>\nif (in == NULL) <br>\nhandle_error(&quot;fmemopen&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">out =\nopen_memstream(&amp;ptr, &amp;size); <br>\nif (out == NULL) <br>\nhandle_error(&quot;open_memstream&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (;;) { <br>\ns = fscanf(in, &quot;%d&quot;, &amp;v); <br>\nif (s &lt;= 0) <br>\nbreak;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\nfprintf(out, &quot;%d &quot;, v * v); <br>\nif (s == -1) <br>\nhandle_error(&quot;fprintf&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fclose(in);\n<br>\nfclose(out);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;size=%zu;\nptr=%s\\n&quot;, size, ptr);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">free(ptr); <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/fopen\">fopen(3)</a>,\n<a href=\"https://man.page/3/fopencookie\">fopencookie(3)</a>, <a href=\"https://man.page/3/open_memstream\">open_memstream(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}