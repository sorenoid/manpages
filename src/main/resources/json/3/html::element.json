{"name":"html::element","body":"\n\n<h1 align=\"center\">HTML::Element</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Element -\nClass for objects that represent HTML elements</p>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This document\ndescribes version 5.07 of HTML::Element, released August 31,\n2017 as part of HTML-Tree.</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTML::Element; <br>\n$a = HTML::Element-&gt;new('a', href =&gt;\n'http://www.perl.com/'); <br>\n$a-&gt;push_content(&quot;The Perl Homepage&quot;); <br>\n$tag = $a-&gt;tag; <br>\nprint &quot;$tag starts out as:&quot;, $a-&gt;starttag,\n&quot;\\n&quot;; <br>\nprint &quot;$tag ends as:&quot;, $a-&gt;endtag,\n&quot;\\n&quot;; <br>\nprint &quot;$tag\\'s href attribute is: &quot;,\n$a-&gt;attr('href'), &quot;\\n&quot;; <br>\n$links_r = $a-&gt;extract_links(); <br>\nprint &quot;Hey, I found &quot;, scalar(@$links_r), &quot;\nlinks.\\n&quot;; <br>\nprint &quot;And that, as HTML, is: &quot;, $a-&gt;as_HTML,\n&quot;\\n&quot;; <br>\n$a = $a-&gt;delete;</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(This class is\npart of the HTML::Tree dist.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Objects of the\nHTML::Element class can be used to represent elements of\n<small>HTML</small> document trees. These objects have\nattributes, notably attributes that designates each\nelement&rsquo;s parent and content. The content is an array\nof text segments and other HTML::Element objects. A tree\nwith HTML::Element objects as nodes can represent the syntax\ntree for a <small>HTML</small> document.</p>\n\n<h2>HOW WE REPRESENT TREES\n<a name=\"HOW WE REPRESENT TREES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider this\n<small>HTML</small> document:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;html\nlang='en-US'&gt; <br>\n&lt;head&gt; <br>\n&lt;title&gt;Stuff&lt;/title&gt; <br>\n&lt;meta name='author' content='Jojo'&gt; <br>\n&lt;/head&gt; <br>\n&lt;body&gt; <br>\n&lt;h1&gt;I like potatoes!&lt;/h1&gt; <br>\n&lt;/body&gt; <br>\n&lt;/html&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Building a\nsyntax tree out of it makes a tree-structure in memory that\ncould be diagrammed as:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">html\n(lang='en-US') <br>\n/ \\ <br>\n/ \\ <br>\n/ \\ <br>\nhead body <br>\n/\\ \\ <br>\n/ \\ \\ <br>\n/ \\ \\ <br>\ntitle meta h1 <br>\n| (name='author', | <br>\n&quot;Stuff&quot; content='Jojo') &quot;I like\npotatoes&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is the\ntraditional way to diagram a tree, with the &quot;root&quot;\nat the top, and it&rsquo;s this kind of diagram that people\nhave in mind when they say, for example, that &quot;the meta\nelement is under the head element instead of under the body\nelement&quot;. (The same is also said with\n&quot;inside&quot; instead of &quot;under&quot; -- the use\nof &quot;inside&quot; makes more sense when you&rsquo;re\nlooking at the <small>HTML</small> source.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another way to\nrepresent the above tree is with indenting:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">html\n(attributes: lang='en-US') <br>\nhead <br>\ntitle <br>\n&quot;Stuff&quot; <br>\nmeta (attributes: name='author' content='Jojo') <br>\nbody <br>\nh1 <br>\n&quot;I like potatoes&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Incidentally,\ndiagramming with indenting works much better for very large\ntrees, and is easier for a program to generate. The\n&quot;$tree-&gt;dump&quot; method uses indentation just that\nway.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However you\ndiagram the tree, it&rsquo;s stored the same in memory --\nit&rsquo;s a network of objects, each of which has\nattributes like so:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">element #1:\n_tag: 'html' <br>\n_parent: none <br>\n_content: [element #2, element #5] <br>\nlang: 'en-US' <br>\nelement #2: _tag: 'head' <br>\n_parent: element #1 <br>\n_content: [element #3, element #4] <br>\nelement #3: _tag: 'title' <br>\n_parent: element #2 <br>\n_content: [text segment &quot;Stuff&quot;] <br>\nelement #4 _tag: 'meta' <br>\n_parent: element #2 <br>\n_content: none <br>\nname: author <br>\ncontent: Jojo <br>\nelement #5 _tag: 'body' <br>\n_parent: element #1 <br>\n_content: [element #6] <br>\nelement #6 _tag: 'h1' <br>\n_parent: element #5 <br>\n_content: [text segment &quot;I like potatoes&quot;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;treeness&quot; of the tree-structure that these\nelements comprise is not an aspect of any particular object,\nbut is emergent from the relatedness attributes (_parent and\n_content) of these element-objects and from how you use them\nto get from element to element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">While you could\naccess the content of a tree by writing code that says\n&quot;access the &rsquo;src&rsquo; attribute of the\nroot&rsquo;s <i>first</i> child&rsquo;s <i>seventh</i>\nchild&rsquo;s <i>third</i> child&quot;, you&rsquo;re more\nlikely to have to scan the contents of a tree, looking for\nwhatever nodes, or kinds of nodes, you want to do something\nwith. The most straightforward way to look over a tree is to\n&quot;traverse&quot; it; an HTML::Element method\n(&quot;$h-&gt;traverse&quot;) is provided for this purpose;\nand several other HTML::Element methods are based on it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(For everything\nyou ever wanted to know about trees, and then some, see\nNiklaus Wirth&rsquo;s <i>Algorithms + Data Structures =\nPrograms</i> or Donald Knuth&rsquo;s <i>The Art of Computer\nProgramming, Volume 1</i>.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Weak\nReferences</b> <small><br>\nTL</small> ;DR summary:\n&quot;use&nbsp;HTML::TreeBuilder&nbsp;5&nbsp;-weak;&quot;\nand forget about the &quot;delete&quot; method (except for\npruning a node from a tree).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because\nHTML::Element stores a reference to the parent element,\nPerl&rsquo;s reference-count garbage collection\ndoesn&rsquo;t work properly with HTML::Element trees.\nStarting with version 5.00, HTML::Element uses weak\nreferences (if available) to prevent that problem. Weak\nreferences were introduced in Perl 5.6.0, but you also need\na version of Scalar::Util that provides the\n&quot;weaken&quot; function.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Weak references\nare enabled by default. If you want to be certain\nthey&rsquo;re in use, you can say\n&quot;use&nbsp;HTML::Element&nbsp;5&nbsp;-weak;&quot;. You\nmust include the version number; previous versions of\nHTML::Element ignored the import list entirely.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To disable weak\nreferences, you can say\n&quot;use&nbsp;HTML::Element&nbsp;-noweak;&quot;. This is a\nglobal setting. <b>This feature is deprecated</b> and is\nprovided only as a quick fix for broken code. If your code\ndoes not work properly with weak references, you should fix\nit immediately, as weak references may become mandatory in a\nfuture version. Generally, all you need to do is keep a\nreference to the root of the tree until you&rsquo;re done\nworking with it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because\nHTML::TreeBuilder is a subclass of HTML::Element, you can\nalso import &quot;-weak&quot; or &quot;-noweak&quot; from\nHTML::TreeBuilder: e.g.\n&quot;use&nbsp;HTML::TreeBuilder:&nbsp;5&nbsp;-weak;&quot;.</p>\n\n<h2>BASIC METHODS\n<a name=\"BASIC METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>new</b> <br>\n$h = HTML::Element-&gt;new('tag', 'attrname' =&gt; 'value',\n... );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This\nconstructor method returns a new HTML::Element object. The\ntag name is a required argument; it will be forced to\nlowercase. Optionally, you can specify other initial\nattributes at object creation time.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>attr</b>\n<br>\n$value = $h-&gt;attr('attr'); <br>\n$old_value = $h-&gt;attr('attr', $new_value);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns\n(optionally sets) the value of the given attribute of $h.\nThe attribute name (but not the value, if provided) is\nforced to lowercase. If trying to read the value of an\nattribute not present for this element, the return value is\nundef. If setting a new value, the old value of that\nattribute is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If methods are\nprovided for accessing an attribute (like\n&quot;$h-&gt;tag&quot; for &quot;_tag&quot;,\n&quot;$h-&gt;content_list&quot;, etc. below), use those\ninstead of calling attr &quot;$h-&gt;attr&quot;, whether for\nreading or setting.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\nsetting an attribute to &quot;undef&quot; (as opposed to\n&quot;&quot;, the empty string) actually deletes the\nattribute.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>tag</b> <br>\n$tagname = $h-&gt;tag(); <br>\n$h-&gt;tag('tagname');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns\n(optionally sets) the tag name (also known as the generic\nidentifier) for the element $h. In setting, the tag name is\nalways converted to lower case.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are four\nkinds of &quot;pseudo-elements&quot; that show up as\nHTML::Element objects: <br>\nComment pseudo-elements</p>\n\n<p style=\"margin-left:17%;\">These are element objects with\na &quot;$h-&gt;tag&quot; value of &quot;~comment&quot;, and\nthe content of the comment is stored in the &quot;text&quot;\nattribute (&quot;$h-&gt;attr(&quot;text&quot;)&quot;). For\nexample, parsing this code with HTML::TreeBuilder...</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;!-- I like\nPie. <br>\nPie is good <br>\n--&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">produces an\nHTML::Element object with these attributes:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;_tag&quot;,\n<br>\n&quot;~comment&quot;, <br>\n&quot;text&quot;, <br>\n&quot; I like Pie.\\n Pie is good\\n &quot;</p>\n\n<p style=\"margin-left:11%;\">Declaration pseudo-elements</p>\n\n<p style=\"margin-left:17%;\">Declarations (rarely\nencountered) are represented as HTML::Element objects with a\ntag name of &quot;~declaration&quot;, and content in the\n&quot;text&quot; attribute. For example, this:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;!DOCTYPE\nfoo&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">produces an\nelement whose attributes include:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;_tag&quot;,\n&quot;~declaration&quot;, &quot;text&quot;, &quot;DOCTYPE\nfoo&quot;</p>\n\n<p style=\"margin-left:11%;\">Processing instruction\npseudo-elements</p>\n\n<p style=\"margin-left:17%;\">PIs (rarely encountered) are\nrepresented as HTML::Element objects with a tag name of\n&quot;~pi&quot;, and content in the &quot;text&quot;\nattribute. For example, this:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;?stuff\nfoo?&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">produces an\nelement whose attributes include:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;_tag&quot;,\n&quot;~pi&quot;, &quot;text&quot;, &quot;stuff\nfoo?&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">(assuming a\nrecent version of HTML::Parser)</p>\n\n<p style=\"margin-left:11%;\">~literal pseudo-elements</p>\n\n<p style=\"margin-left:17%;\">These objects are not currently\nproduced by HTML::TreeBuilder, but can be used to represent\na &quot;super-literal&quot; -- i.e., a literal you want to\nbe immune from escaping. (Yes, I just made that term\nup.)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">That is, this\nis useful if you want to insert code into a tree that you\nplan to dump out with &quot;as_HTML&quot;, where you want,\nfor some reason, to suppress &quot;as_HTML&quot;&rsquo;s\nnormal behavior of amp-quoting text segments.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For example,\nthis:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $literal =\nHTML::Element-&gt;new('~literal', <br>\n'text' =&gt; 'x &lt; 4 &amp; y &gt; 7' <br>\n); <br>\nmy $span = HTML::Element-&gt;new('span'); <br>\n$span-&gt;push_content($literal); <br>\nprint $span-&gt;as_HTML;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">prints\nthis:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;span&gt;x\n&lt; 4 &amp; y &gt; 7&lt;/span&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Whereas\nthis:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $span =\nHTML::Element-&gt;new('span'); <br>\n$span-&gt;push_content('x &lt; 4 &amp; y &gt; 7'); <br>\n# normal text segment <br>\nprint $span-&gt;as_HTML;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">prints\nthis:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;span&gt;x\n&amp;lt; 4 &amp;amp; y &amp;gt; 7&lt;/span&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Unless\nyou&rsquo;re inserting lots of pre-cooked code into existing\ntrees, and dumping them out again, it&rsquo;s not likely\nthat you&rsquo;ll find &quot;~literal&quot; pseudo-elements\nuseful.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>parent</b>\n<br>\n$parent = $h-&gt;parent(); <br>\n$h-&gt;parent($new_parent);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns\n(optionally sets) the parent (aka &quot;container&quot;) for\nthis element. The parent should either be undef, or should\nbe another element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You <b>should\nnot</b> use this to directly set the parent of an element.\nInstead use any of the other methods under\n&quot;Structure-Modifying Methods&quot;, below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\n&quot;not($h-&gt;parent)&quot; is a simple test for whether\n$h is the root of its subtree.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>content_list</b>\n<br>\n@content = $h-&gt;content_list(); <br>\n$num_children = $h-&gt;content_list();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a list\nof the child nodes of this element -- i.e., what nodes\n(elements or text segments) are inside/under this element.\n(Note that this may be an empty list.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a scalar\ncontext, this returns the count of the items, as you may\nexpect.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>content</b>\n<br>\n$content_array_ref = $h-&gt;content(); # may return\nundef</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This somewhat\ndeprecated method returns the content of this element; but\nunlike content_list, this returns either undef (which you\nshould understand to mean no content), or a <i>reference to\nthe array</i> of content items, each of which is either a\ntext segment (a string, i.e., a defined non-reference scalar\nvalue), or an HTML::Element object. Note that even if an\narrayref is returned, it may be a reference to an empty\narray.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">While older\ncode should feel free to continue to use\n&quot;$h-&gt;content&quot;, new code should use\n&quot;$h-&gt;content_list&quot; in almost all conceivable\ncases. It is my experience that in most cases this leads to\nsimpler code anyway, since it means one can say:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@children =\n$h-&gt;content_list;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">instead of the\ninelegant:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@children =\n@{$h-&gt;content || []};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you do use\n&quot;$h-&gt;content&quot; (or\n&quot;$h-&gt;content_array_ref&quot;), you should not use\nthe reference returned by it (assuming it returned a\nreference, and not undef) to directly set or change the\ncontent of an element or text segment! Instead use\ncontent_refs_list or any of the other methods under\n&quot;Structure-Modifying Methods&quot;, below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>content_array_ref</b>\n<br>\n$content_array_ref = $h-&gt;content_array_ref(); # never\nundef</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is like\n&quot;content&quot; (with all its caveats and deprecations)\nexcept that it is guaranteed to return an array reference.\nThat is, if the given node has no &quot;_content&quot;\nattribute, the &quot;content&quot; method would return that\nundef, but &quot;content_array_ref&quot; would set the given\nnode&rsquo;s &quot;_content&quot; value to &quot;[]&quot; (a\nreference to a new, empty array), and return that.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>content_refs_list</b>\n<br>\n@content_refs = $h-&gt;content_refs_list;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This returns a\nlist of scalar references to each element of $h&rsquo;s\ncontent list. This is useful in case you want to in-place\nedit any large text segments without having to get a copy of\nthe current value of that segment value, modify that copy,\nthen use the &quot;splice_content&quot; to replace the old\nwith the new. Instead, here you can in-place edit:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">foreach my\n$item_r ($h-&gt;content_refs_list) { <br>\nnext if ref $$item_r; <br>\n$$item_r =~ s/honour/honor/g; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You\n<i>could</i> currently achieve the same affect with:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">foreach my\n$item (@{ $h-&gt;content_array_ref }) { <br>\n# deprecated! <br>\nnext if ref $item; <br>\n$item =~ s/honour/honor/g; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...except that\nusing the return value of &quot;$h-&gt;content&quot; or\n&quot;$h-&gt;content_array_ref&quot; to do that is\ndeprecated, and just might stop working in the future.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>implicit</b>\n<br>\n$is_implicit = $h-&gt;implicit(); <br>\n$h-&gt;implicit($make_implicit);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns\n(optionally sets) the &quot;_implicit&quot; attribute. This\nattribute is a flag that&rsquo;s used for indicating that\nthe element was not originally present in the source, but\nwas added to the parse tree (by HTML::TreeBuilder, for\nexample) in order to conform to the rules of\n<small>HTML</small> structure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pos</b> <br>\n$pos = $h-&gt;pos(); <br>\n$h-&gt;pos($element);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns (and\noptionally sets) the &quot;_pos&quot; (for &quot;current\n<i>pos</i>ition&quot;) pointer of $h. This attribute is a\npointer used during some parsing operations, whose value is\nwhatever HTML::Element element at or under $h is currently\n&quot;open&quot;, where\n&quot;$h-&gt;insert_element(NEW)&quot; will actually insert\na new element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(This has\nnothing to do with the Perl function called &quot;pos&quot;,\nfor controlling where regular expression matching\nstarts.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you set\n&quot;$h-&gt;pos($element)&quot;, be sure that $element is\neither $h, or an element under $h.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you&rsquo;ve\nbeen modifying the tree under $h and are no longer sure\n&quot;$h-&gt;pos&quot; is valid, you can enforce validity\nwith:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;pos(undef)\nunless $h-&gt;pos-&gt;is_inside($h);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>all_attr</b>\n<br>\n%attr = $h-&gt;all_attr();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns all\nthis element&rsquo;s attributes and values, as key-value\npairs. This will include any &quot;internal&quot; attributes\n(i.e., ones not present in the original element, and which\nwill not be represented if/when you call\n&quot;$h-&gt;as_HTML&quot;). Internal attributes are\ndistinguished by the fact that the first character of their\nkey (not value! key!) is an underscore (&quot;_&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Example output\nof &quot;$h-&gt;all_attr()&quot; : &quot;'_parent',\n&quot;<i>[object_value]</i>&quot; , '_tag', 'em', 'lang',\n'en-US', '_content', &quot;<i>[array-ref value]</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>all_attr_names</b>\n<br>\n@names = $h-&gt;all_attr_names(); <br>\n$num_attrs = $h-&gt;all_attr_names();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Like\n&quot;all_attr&quot;, but only returns the names of the\nattributes. In scalar context, returns the number of\nattributes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Example output\nof &quot;$h-&gt;all_attr_names()&quot; : &quot;'_parent',\n'_tag', 'lang', '_content', &quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>all_external_attr</b>\n<br>\n%attr = $h-&gt;all_external_attr();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Like\n&quot;all_attr&quot;, except that internal attributes are\nnot present.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>all_external_attr_names</b>\n<br>\n@names = $h-&gt;all_external_attr_names(); <br>\n$num_attrs = $h-&gt;all_external_attr_names();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Like\n&quot;all_attr_names&quot;, except that internal\nattributes&rsquo; names are not present (or counted).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>id</b> <br>\n$id = $h-&gt;id(); <br>\n$h-&gt;id($string);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns\n(optionally sets to $string) the &quot;id&quot; attribute.\n&quot;$h-&gt;id(undef)&quot; deletes the &quot;id&quot;\nattribute.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;$h-&gt;id(...)&quot;\nis basically equivalent to &quot;$h-&gt;attr('id',\n...)&quot;, except that when setting the attribute, this\nmethod returns the new value, not the old value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>idf</b> <br>\n$id = $h-&gt;idf(); <br>\n$h-&gt;idf($string);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Just like the\n&quot;id&quot; method, except that if you call\n&quot;$h-&gt;idf()&quot; and no &quot;id&quot; attribute is\ndefined for this element, then it&rsquo;s set to a\nlikely-to-be-unique value, and returned. (The &quot;f&quot;\nis for &quot;force&quot;.)</p>\n\n<h2>STRUCTURE-MODIFYING METHODS\n<a name=\"STRUCTURE-MODIFYING METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These methods\nare provided for modifying the content of trees by adding or\nchanging nodes as parents or children of other nodes.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>push_content</b>\n<br>\n$h-&gt;push_content($element_or_text, ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Adds the\nspecified items to the <i>end</i> of the content list of the\nelement $h. The items of content to be added should each be\neither a text segment (a string), an HTML::Element object,\nor an arrayref. Arrayrefs are fed thru\n&quot;$h-&gt;new_from_lol(that_arrayref)&quot; to convert\nthem into elements, before being added to the content list\nof $h. This means you can say things concise things\nlike:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$body-&gt;push_content(\n<br>\n['br'], <br>\n['ul', <br>\nmap ['li', $_], qw(Peaches Apples Pears Mangos) <br>\n] <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\n&quot;new_from_lol&quot; method&rsquo;s documentation, far\nbelow, for more explanation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns $h (the\nelement itself).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\npush_content method will try to consolidate adjacent text\nsegments while adding to the content list. That&rsquo;s to\nsay, if $h&rsquo;s &quot;content_list&quot; is</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">('foo bar ',\n$some_node, 'baz!')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and you\ncall</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;push_content('quack?');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then the\nresulting content list will be this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">('foo bar ',\n$some_node, 'baz!quack?')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and not\nthis:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">('foo bar ',\n$some_node, 'baz!', 'quack?')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If that latter\nis what you want, you&rsquo;ll have to override the feature\nof consolidating text by using splice_content, as in:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;splice_content(scalar($h-&gt;content_list),0,'quack?');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Similarly, if\nyou wanted to add &rsquo;Skronk&rsquo; to the beginning of\nthe content list, calling this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;unshift_content('Skronk');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then the\nresulting content list will be this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">('Skronkfoo bar\n', $some_node, 'baz!')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and not\nthis:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">('Skronk', 'foo\nbar ', $some_node, 'baz!')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">What\nyou&rsquo;d to do get the latter is:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;splice_content(0,0,'Skronk');</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>unshift_content</b>\n<br>\n$h-&gt;unshift_content($element_or_text, ...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Just like\n&quot;push_content&quot;, but adds to the <i>beginning</i>\nof the $h element&rsquo;s content list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The items of\ncontent to be added should each be either a text segment (a\nstring), an HTML::Element object, or an arrayref (which is\nfed thru &quot;new_from_lol&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nunshift_content method will try to consolidate adjacent text\nsegments while adding to the content list. See above for a\ndiscussion of this.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns $h (the\nelement itself).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>splice_content</b>\n<br>\n@removed = $h-&gt;splice_content($offset, $length, <br>\n$element_or_text, ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Detaches the\nelements from $h&rsquo;s list of content-nodes, starting at\n$offset and continuing for $length items, replacing them\nwith the elements of the following list, if any. Returns the\nelements (if any) removed from the content-list. If $offset\nis negative, then it starts that far from the end of the\narray, just like Perl&rsquo;s normal &quot;splice&quot;\nfunction. If $length and the following list is omitted,\nremoves everything from $offset onward.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The items of\ncontent to be added (if any) should each be either a text\nsegment (a string), an arrayref (which is fed thru\n&quot;new_from_lol&quot;), or an HTML::Element object\nthat&rsquo;s not already a child of $h.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>detach</b>\n<br>\n$old_parent = $h-&gt;detach();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This unlinks $h\nfrom its parent, by setting its &rsquo;parent&rsquo;\nattribute to undef, and by removing it from the content list\nof its parent (if it had one). The return value is the\nparent that was detached from (or undef, if $h had no parent\nto start with). Note that neither $h nor its parent are\nexplicitly destroyed.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>detach_content</b>\n<br>\n@old_content = $h-&gt;detach_content();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This unlinks\nall of $h&rsquo;s children from $h, and returns them. Note\nthat these are not explicitly destroyed; for that, you can\njust use &quot;$h-&gt;delete_content&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>replace_with</b>\n<br>\n$h-&gt;replace_with( $element_or_text, ... )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This replaces\n$h in its parent&rsquo;s content list with the nodes\nspecified. The element $h (which by then may have no parent)\nis returned. This causes a fatal error if $h has no parent.\nThe list of nodes to insert may contain $h, but at most\nonce. Aside from that possible exception, the nodes to\ninsert should not already be children of $h&rsquo;s\nparent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also, note that\nthis method does not destroy $h if weak references are\nturned off -- use\n&quot;$h-&gt;replace_with(...)-&gt;delete&quot; if you need\nthat.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>preinsert</b>\n<br>\n$h-&gt;preinsert($element_or_text...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inserts the\ngiven nodes right <small>BEFORE</small> $h in $h&rsquo;s\nparent&rsquo;s content list. This causes a fatal error if $h\nhas no parent. None of the given nodes should be $h or other\nchildren of $h. Returns $h.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>postinsert</b>\n<br>\n$h-&gt;postinsert($element_or_text...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inserts the\ngiven nodes right <small>AFTER</small> $h in $h&rsquo;s\nparent&rsquo;s content list. This causes a fatal error if $h\nhas no parent. None of the given nodes should be $h or other\nchildren of $h. Returns $h.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>replace_with_content</b>\n<br>\n$h-&gt;replace_with_content();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This replaces\n$h in its parent&rsquo;s content list with its own content.\nThe element $h (which by then has no parent or content of\nits own) is returned. This causes a fatal error if $h has no\nparent. Also, note that this does not destroy $h if weak\nreferences are turned off -- use\n&quot;$h-&gt;replace_with_content-&gt;delete&quot; if you\nneed that.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>delete_content</b>\n<br>\n$h-&gt;delete_content(); <br>\n$h-&gt;destroy_content(); # alias</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Clears the\ncontent of $h, calling &quot;$h-&gt;delete&quot; for each\ncontent element. Compare with\n&quot;$h-&gt;detach_content&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns $h.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;destroy_content&quot;\nis an alias for this method.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>delete</b>\n<br>\n$h-&gt;delete(); <br>\n$h-&gt;destroy(); # alias</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Detaches this\nelement from its parent (if it has one) and explicitly\ndestroys the element and all its descendants. The return\nvalue is the empty list (or &quot;undef&quot; in scalar\ncontext).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Before version\n5.00 of HTML::Element, you had to call &quot;delete&quot;\nwhen you were finished with the tree, or your program would\nleak memory. This is no longer necessary if weak references\nare enabled, see &quot;Weak References&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>destroy</b>\n<br>\nAn alias for &quot;delete&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>destroy_content</b>\n<br>\nAn alias for &quot;delete_content&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clone</b>\n<br>\n$copy = $h-&gt;clone();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a copy\nof the element (whose children are clones (recursively) of\nthe original&rsquo;s children, if any).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The returned\nelement is parentless. Any &rsquo;_pos&rsquo; attributes\npresent in the source element/tree will be absent in the\ncopy. For that and other reasons, the clone of an\nHTML::TreeBuilder object that&rsquo;s in mid-parse (i.e, the\nhead of a tree that HTML::TreeBuilder is elaborating) cannot\n(currently) be used to continue the parse.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You are free to\nclone HTML::TreeBuilder trees, just as long as: 1)\nthey&rsquo;re done being parsed, or 2) you don&rsquo;t\nexpect to resume parsing into the clone. (You can continue\nparsing into the original; it is never affected.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clone_list</b>\n<br>\n@copies = HTML::Element-&gt;clone_list(...nodes...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a list\nconsisting of a copy of each node given. Text segments are\nsimply copied; elements are cloned by calling\n&quot;$it-&gt;clone&quot; on each of them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that this\nmust be called as a class method, not as an instance method.\n&quot;clone_list&quot; will croak if called as an instance\nmethod. You can also call it like so:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">ref($h)-&gt;clone_list(...nodes...)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>normalize_content</b>\n<br>\n$h-&gt;normalize_content</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Normalizes the\ncontent of $h -- i.e., concatenates any adjacent text nodes.\n(Any undefined text segments are turned into empty-strings.)\nNote that this does not recurse into $h&rsquo;s\ndescendants.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>delete_ignorable_whitespace</b>\n<br>\n$h-&gt;delete_ignorable_whitespace()</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This traverses\nunder $h and deletes any text segments that are ignorable\nwhitespace. You should not use this if $h is under a\n&quot;&lt;pre&gt;&quot; element.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>insert_element</b>\n<br>\n$h-&gt;insert_element($element, $implicit);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inserts (via\npush_content) a new element under the element at\n&quot;$h-&gt;pos()&quot;. Then updates\n&quot;$h-&gt;pos()&quot; to point to the inserted element,\nunless $element is a prototypically empty element like\n&quot;&lt;br&gt;&quot;, &quot;&lt;hr&gt;&quot;,\n&quot;&lt;img&gt;&quot;, etc. The new\n&quot;$h-&gt;pos()&quot; is returned. This method is useful\nonly if your particular tree task involves setting\n&quot;$h-&gt;pos()&quot;.</p>\n\n<h2>DUMPING METHODS\n<a name=\"DUMPING METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dump</b>\n<br>\n$h-&gt;dump() <br>\n$h-&gt;dump(*FH) ; # or *FH{IO} or $fh_obj</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Prints the\nelement and all its children to <small>STDOUT</small> (or to\na specified filehandle), in a format useful only for\ndebugging. The structure of the document is shown by\nindentation (no end tags).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>as_HTML</b>\n<br>\n$s = $h-&gt;as_HTML(); <br>\n$s = $h-&gt;as_HTML($entities); <br>\n$s = $h-&gt;as_HTML($entities, $indent_char); <br>\n$s = $h-&gt;as_HTML($entities, $indent_char,\n\\%optional_end_tags);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring representing in <small>HTML</small> the element and\nits descendants. The optional argument $entities specifies a\nstring of the entities to encode. For compatibility with\nprevious versions, specify '&lt;&gt;&amp;' here. If omitted\nor undef, <i>all</i> unsafe characters are encoded as\n<small>HTML</small> entities. See HTML::Entities for\ndetails. If passed an empty string, no entities are\nencoded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If $indent_char\nis specified and defined, the <small>HTML</small> to be\noutput is intented, using the string you specify (which you\nprobably should set to &quot;\\t&quot;, or some number of\nspaces, if you specify it).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n&quot;\\%optional_end_tags&quot; is specified and defined, it\nshould be a reference to a hash that holds a true value for\nevery tag name whose end tag is optional. Defaults to\n&quot;\\%HTML::Element::optionalEndTag&quot;, which is an\nalias to %HTML::Tagset::optionalEndTag, which, at time of\nwriting, contains true values for &quot;p, li, dt, dd&quot;.\nA useful value to pass is an empty hashref, &quot;{}&quot;,\nwhich means that no end-tags are optional for this dump.\nOtherwise, possibly consider copying\n%HTML::Tagset::optionalEndTag to a hash of your own, adding\nor deleting values as you like, and passing a reference to\nthat hash.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>as_text</b>\n<br>\n$s = $h-&gt;as_text(); <br>\n$s = $h-&gt;as_text(skip_dels =&gt; 1);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring consisting of only the text parts of the\nelement&rsquo;s descendants. Any whitespace inside the\nelement is included unchanged, but whitespace not in the\ntree is never added. But remember that whitespace may be\nignored or compacted by HTML::TreeBuilder during parsing\n(depending on the value of the\n&quot;ignore_ignorable_whitespace&quot; and\n&quot;no_space_compacting&quot; attributes). Also, since\nwhitespace is never added during parsing,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::TreeBuilder-&gt;new_from_content(&quot;&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;&quot;)\n<br>\n-&gt;as_text;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">returns\n&quot;ab&quot;, not &quot;a b&quot; or &quot;a\\nb&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Text under\n&quot;&lt;script&gt;&quot; or &quot;&lt;style&gt;&quot;\nelements is never included in what&rsquo;s returned. If\n&quot;skip_dels&quot; is true, then text content under\n&quot;&lt;del&gt;&quot; nodes is not included in\nwhat&rsquo;s returned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>as_trimmed_text</b>\n<br>\n$s = $h-&gt;as_trimmed_text(...); <br>\n$s = $h-&gt;as_trimmed_text(extra_chars =&gt; '\\xA0'); #\nremove &amp;nbsp; <br>\n$s = $h-&gt;as_text_trimmed(...); # alias</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is just\nlike &quot;as_text(...)&quot; except that leading and\ntrailing whitespace is deleted, and any internal whitespace\nis collapsed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This will not\nremove non-breaking spaces, Unicode spaces, or any other\nnon-ASCII whitespace unless you supply the extra characters\nas a string argument (e.g.\n&quot;$h-&gt;as_trimmed_text(extra_chars =&gt;\n'\\xA0')&quot;). &quot;extra_chars&quot; may be any string\nthat can appear inside a character class, including ranges\nlike &quot;a-z&quot;, <small>POSIX</small> character classes\nlike &quot;[:alpha:]&quot;, and character class escapes like\n&quot;\\p{Zs}&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>as_XML</b>\n<br>\n$s = $h-&gt;as_XML()</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring representing in <small>XML</small> the element and\nits descendants.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<small>XML</small> is not indented.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>as_Lisp_form</b>\n<br>\n$s = $h-&gt;as_Lisp_form();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring representing the element and its descendants as a\nLisp form. Unsafe characters are encoded as octal\nescapes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Lisp form\nis indented, and contains external (&quot;href&quot;, etc.)\nas well as internal attributes (&quot;_tag&quot;,\n&quot;_content&quot;, &quot;_implicit&quot;, etc.), except\nfor &quot;_parent&quot;, which is omitted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Current example\noutput for a given element:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(&quot;_tag&quot;\n&quot;img&quot; &quot;border&quot; &quot;0&quot;\n&quot;src&quot; &quot;pie.png&quot; &quot;usemap&quot;\n&quot;#main.map&quot;)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>format</b>\n<br>\n$s = $h-&gt;format; # use HTML::FormatText <br>\n$s = $h-&gt;format($formatter);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Formats text\noutput. Defaults to HTML::FormatText.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Takes a second\nargument that is a reference to a formatter.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>starttag</b>\n<br>\n$start = $h-&gt;starttag(); <br>\n$start = $h-&gt;starttag($entities);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring representing the complete start tag for the element.\nI.e., leading &quot;&lt;&quot;, tag name, attributes, and\ntrailing &quot;&gt;&quot;. All values are surrounded with\ndouble-quotes, and appropriate characters are encoded. If\n$entities is omitted or undef, <i>all</i> unsafe characters\nare encoded as <small>HTML</small> entities. See\nHTML::Entities for details. If you specify some value for\n$entities, remember to include the double-quote character in\nit. (Previous versions of this module would basically behave\nas if '&amp;&quot;&gt;' were specified for $entities.) If\n$entities is an empty string, no entity is escaped.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>starttag_XML</b>\n<br>\n$start = $h-&gt;starttag_XML();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring representing the complete start tag for the\nelement.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>endtag</b>\n<br>\n$end = $h-&gt;endtag();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring representing the complete end tag for this element.\nI.e., &quot;&lt;/&quot;, tag name, and &quot;&gt;&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>endtag_XML</b>\n<br>\n$end = $h-&gt;endtag_XML();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nstring representing the complete end tag for this element.\nI.e., &quot;&lt;/&quot;, tag name, and &quot;&gt;&quot;.</p>\n\n<h2>SECONDARY STRUCTURAL METHODS\n<a name=\"SECONDARY STRUCTURAL METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These methods\nall involve some structural aspect of the tree; either they\nreport some aspect of the tree&rsquo;s structure, or they\ninvolve traversal down the tree, or walking up the tree.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>is_inside</b>\n<br>\n$inside = $h-&gt;is_inside('tag', $element, ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns true if\nthe $h element is, or is contained anywhere inside an\nelement that is any of the ones listed, or whose tag name is\nany of the tag names listed. You can use any mix of elements\nand tag names.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>is_empty</b>\n<br>\n$empty = $h-&gt;is_empty();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns true if\n$h has no content, i.e., has no elements or text segments\nunder it. In other words, this returns true if $h is a leaf\nnode, <small>AKA</small> a terminal node. Do not confuse\nthis sense of &quot;empty&quot; with another sense that it\ncan have in <small>SGML/HTML/XML</small> terminology, which\nmeans that the element in question is of the type (like\n<small>HTML</small> &rsquo;s &quot;&lt;hr&gt;&quot;,\n&quot;&lt;br&gt;&quot;, &quot;&lt;img&gt;&quot;, etc.) that\n<i>can&rsquo;t</i> have any content.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That is, a\nparticular &quot;&lt;p&gt;&quot; element may happen to have\nno content, so $that_p_element-&gt;is_empty will be true --\neven though the prototypical &quot;&lt;p&gt;&quot; element\nisn&rsquo;t &quot;empty&quot; (not in the way that the\nprototypical &quot;&lt;hr&gt;&quot; element is).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you think\nthis might make for potentially confusing code, consider\nsimply using the clearer exact equivalent:\n&quot;not($h-&gt;content_list)&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>pindex</b>\n<br>\n$index = $h-&gt;pindex();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Return the\nindex of the element in its parent&rsquo;s contents array,\nsuch that $h would equal</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;parent-&gt;content-&gt;[$h-&gt;pindex]\n<br>\n# or <br>\n($h-&gt;parent-&gt;content_list)[$h-&gt;pindex]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">assuming $h\nisn&rsquo;t root. If the element $h is root, then\n&quot;$h-&gt;pindex&quot; returns &quot;undef&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>left</b>\n<br>\n$element = $h-&gt;left(); <br>\n@elements = $h-&gt;left();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In scalar\ncontext: returns the node that&rsquo;s the immediate left\nsibling of $h. If $h is the leftmost (or only) child of its\nparent (or has no parent), then this returns undef.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In list\ncontext: returns all the nodes that&rsquo;re the left\nsiblings of $h (starting with the leftmost). If $h is the\nleftmost (or only) child of its parent (or has no parent),\nthen this returns an empty list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(See also\n&quot;$h-&gt;preinsert(LIST)&quot;.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>right</b>\n<br>\n$element = $h-&gt;right(); <br>\n@elements = $h-&gt;right();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In scalar\ncontext: returns the node that&rsquo;s the immediate right\nsibling of $h. If $h is the rightmost (or only) child of its\nparent (or has no parent), then this returns\n&quot;undef&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In list\ncontext: returns all the nodes that&rsquo;re the right\nsiblings of $h, starting with the leftmost. If $h is the\nrightmost (or only) child of its parent (or has no parent),\nthen this returns an empty list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(See also\n&quot;$h-&gt;postinsert(LIST)&quot;.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>address</b>\n<br>\n$address = $h-&gt;address(); <br>\n$element_or_text = $h-&gt;address($address);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first form\n(with no parameter) returns a string representing the\nlocation of $h in the tree it is a member of. The address\nconsists of numbers joined by a &rsquo;.&rsquo;, starting\nwith &rsquo;0&rsquo;, and followed by the pindexes of the\nnodes in the tree that are ancestors of $h, starting from\nthe top.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So if the way\nto get to a node starting at the root is to go to child 2 of\nthe root, then child 10 of that, and then child 0 of that,\nand then you&rsquo;re there -- then that node&rsquo;s\naddress is &quot;0.2.10.0&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As a bit of a\nspecial case, the address of the root is simply\n&quot;0&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">I forsee this\nbeing used mainly for debugging, but you may find your own\nuses for it.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$element_or_text\n= $h-&gt;address($address);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This form\nreturns the node (whether element or text-segment) at the\ngiven address in the tree that $h is a part of. (That is,\nthe address is resolved starting from\n&quot;$h-&gt;root&quot;.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If there is no\nnode at the given address, this returns\n&quot;undef&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can specify\n&quot;relative addressing&quot; (i.e., that indexing is\nsupposed to start from $h and not from\n&quot;$h-&gt;root&quot;) by having the address start with a\nperiod -- e.g., &quot;$h-&gt;address(&quot;.3.2&quot;)&quot;\nwill look at child 3 of $h, and child 2 of that.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>depth</b>\n<br>\n$depth = $h-&gt;depth();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a\nnumber expressing $h&rsquo;s depth within its tree, i.e.,\nhow many steps away it is from the root. If $h has no parent\n(i.e., is root), its depth is 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>root</b>\n<br>\n$root = $h-&gt;root();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns the\nelement that&rsquo;s the top of $h&rsquo;s tree. If $h is\nroot, this just returns $h. (If you want to test whether $h\n<i>is</i> the root, instead of asking what its root is, just\ntest &quot;not($h-&gt;parent)&quot;.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>lineage</b>\n<br>\n@lineage = $h-&gt;lineage();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns the\nlist of $h&rsquo;s ancestors, starting with its parent, and\nthen that parent&rsquo;s parent, and so on, up to the root.\nIf $h is root, this returns an empty list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you simply\nwant a count of the number of elements in $h&rsquo;s\nlineage, use &quot;$h-&gt;depth&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>lineage_tag_names</b>\n<br>\n@names = $h-&gt;lineage_tag_names();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns the\nlist of the tag names of $h&rsquo;s ancestors, starting with\nits parent, and that parent&rsquo;s parent, and so on, up to\nthe root. If $h is root, this returns an empty list. Example\noutput: &quot;('em', 'td', 'tr', 'table', 'body',\n'html')&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Equivalent\nto:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">map {\n$_-&gt;tag } $h-&gt;lineage;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>descendants</b>\n<br>\n@descendants = $h-&gt;descendants();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In list\ncontext, returns the list of all $h&rsquo;s descendant\nelements, listed in pre-order (i.e., an element appears\nbefore its content-elements). Text segments <small>DO\nNOT</small> appear in the list. In scalar context, returns a\ncount of all such elements.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>descendents</b>\n<br>\nThis is just an alias to the &quot;descendants&quot; method,\nfor people who can&rsquo;t spell.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>find_by_tag_name</b>\n<br>\n@elements = $h-&gt;find_by_tag_name('tag', ...); <br>\n$first_match = $h-&gt;find_by_tag_name('tag', ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In list\ncontext, returns a list of elements at or under $h that have\nany of the specified tag names. In scalar context, returns\nthe first (in pre-order traversal of the tree) such element\nfound, or undef if none.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>find</b>\n<br>\nThis is just an alias to &quot;find_by_tag_name&quot;.\n(There was once going to be a whole find_* family of\nmethods, but then &quot;look_down&quot; filled that niche,\nso there turned out not to be much reason for the\nverboseness of the name &quot;find_by_tag_name&quot;.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>find_by_attribute</b>\n<br>\n@elements = $h-&gt;find_by_attribute('attribute', 'value');\n<br>\n$first_match = $h-&gt;find_by_attribute('attribute',\n'value');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a list\ncontext, returns a list of elements at or under $h that have\nthe specified attribute, and have the given value for that\nattribute. In a scalar context, returns the first (in\npre-order traversal of the tree) such element found, or\nundef if none.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method is\n<b>deprecated</b> in favor of the more expressive\n&quot;look_down&quot; method, which new code should use\ninstead.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>look_down</b>\n<br>\n@elements = $h-&gt;look_down( ...criteria... ); <br>\n$first_match = $h-&gt;look_down( ...criteria... );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This starts at\n$h and looks thru its element descendants (in pre-order),\nlooking for elements matching the criteria you specify. In\nlist context, returns all elements that match all the given\ncriteria; in scalar context, returns the first such element\n(or undef, if nothing matched).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are three\nkinds of criteria you can specify: <br>\n(attr_name, attr_value)</p>\n\n<p style=\"margin-left:17%;\">This means you&rsquo;re looking\nfor an element with that value for that attribute. Example:\n&quot;alt&quot;, &quot;pix!&quot;. Consider that you can\nsearch on internal attribute values too: &quot;_tag&quot;,\n&quot;p&quot;.</p>\n\n<p style=\"margin-left:11%;\">(attr_name, qr/.../)</p>\n\n<p style=\"margin-left:17%;\">This means you&rsquo;re looking\nfor an element whose value for that attribute matches the\nspecified Regexp object.</p>\n\n<p style=\"margin-left:11%;\">a coderef</p>\n\n<p style=\"margin-left:17%;\">This means you&rsquo;re looking\nfor elements where coderef-&gt;(each_element) returns true.\nExample:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my\n@wide_pix_images = $h-&gt;look_down( <br>\n_tag =&gt; &quot;img&quot;, <br>\nalt =&gt; &quot;pix!&quot;, <br>\nsub { $_[0]-&gt;attr('width') &gt; 350 } <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\n&quot;(attr_name, attr_value)&quot; and &quot;(attr_name,\nqr/.../)&quot; criteria are almost always faster than\ncoderef criteria, so should presumably be put before them in\nyour list of criteria. That is, in the example above, the\nsub ref is called only for elements that have already passed\nthe criteria of having a &quot;_tag&quot; attribute with\nvalue &quot;img&quot;, and an &quot;alt&quot; attribute with\nvalue &quot;pix!&quot;. If the coderef were first, it would\nbe called on every element, and <i>then</i> what elements\npass that criterion (i.e., elements for which the coderef\nreturned true) would be checked for their &quot;_tag&quot;\nand &quot;alt&quot; attributes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\ncomparison of string attribute-values against the string\nvalue in &quot;(attr_name, attr_value)&quot; is\ncase-INsensitive! A criterion of &quot;('align',\n'right')&quot; <i>will</i> match an element whose\n&quot;align&quot; value is &quot;\n<small>RIGHT&quot;,</small> or &quot;right&quot; or\n&quot;rIGhT&quot;, etc.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note also that\n&quot;look_down&quot; considers &quot;&quot; (empty-string)\nand undef to be different things, in attribute values. So\nthis:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;look_down(&quot;alt&quot;,\n&quot;&quot;)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">will find\nelements <i>with</i> an &quot;alt&quot; attribute, but where\nthe value for the &quot;alt&quot; attribute is &quot;&quot;.\nBut this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;look_down(&quot;alt&quot;,\nundef)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is the same\nas:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;look_down(sub\n{ !defined($_[0]-&gt;attr('alt')) } )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That is, it\nfinds elements that do not have an &quot;alt&quot; attribute\nat all (or that do have an &quot;alt&quot; attribute, but\nwith a value of undef -- which is not normally\npossible).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that when\nyou give several criteria, this is taken to mean\nyou&rsquo;re looking for elements that match <i>all</i> your\ncriterion, not just <i>any</i> of them. In other words,\nthere is an implicit &quot;and&quot;, not an &quot;or&quot;.\nSo if you wanted to express that you wanted to find elements\nwith a &quot;name&quot; attribute with the value\n&quot;foo&quot; <i>or</i> with an &quot;id&quot; attribute\nwith the value &quot;baz&quot;, you&rsquo;d have to do it\nlike:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@them =\n$h-&gt;look_down( <br>\nsub { <br>\n# the lcs are to fold case <br>\nlc($_[0]-&gt;attr('name')) eq 'foo' <br>\nor lc($_[0]-&gt;attr('id')) eq 'baz' <br>\n} <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Coderef\ncriteria are more expressive than &quot;(attr_name,\nattr_value)&quot; and &quot;(attr_name, qr/.../)&quot;\ncriteria, and all &quot;(attr_name, attr_value)&quot; and\n&quot;(attr_name, qr/.../)&quot; criteria could be expressed\nin terms of coderefs. However, &quot;(attr_name,\nattr_value)&quot; and &quot;(attr_name, qr/.../)&quot;\ncriteria are a convenient shorthand. (In fact,\n&quot;look_down&quot; itself is basically\n&quot;shorthand&quot; too, since anything you can do with\n&quot;look_down&quot; you could do by traversing the tree,\neither with the &quot;traverse&quot; method or with a\nroutine of your own. However, &quot;look_down&quot; often\nmakes for very concise and clear code.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>look_up</b>\n<br>\n@elements = $h-&gt;look_up( ...criteria... ); <br>\n$first_match = $h-&gt;look_up( ...criteria... );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is\nidentical to &quot;$h-&gt;look_down&quot;, except that\nwhereas &quot;$h-&gt;look_down&quot; basically scans over\nthe list:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">($h,\n$h-&gt;descendants)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;$h-&gt;look_up&quot;\ninstead scans over the list</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">($h,\n$h-&gt;lineage)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, for\nexample, this returns all ancestors of $h (possibly\nincluding $h itself) that are &quot;&lt;td&gt;&quot;\nelements with an &quot;align&quot; attribute with a value of\n&quot;right&quot; (or &quot; <small>RIGHT&quot;,</small>\netc.):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;look_up(&quot;_tag&quot;,\n&quot;td&quot;, &quot;align&quot;, &quot;right&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>traverse</b>\n<br>\n$h-&gt;traverse(...options...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Lengthy\ndiscussion of HTML::Element&rsquo;s unnecessary and\nconfusing &quot;traverse&quot; method has been moved to a\nseparate file: HTML::Element::traverse</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>attr_get_i</b>\n<br>\n@values = $h-&gt;attr_get_i('attribute'); <br>\n$first_value = $h-&gt;attr_get_i('attribute');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In list\ncontext, returns a list consisting of the values of the\ngiven attribute for $h and for all its ancestors starting\nfrom $h and working its way up. Nodes with no such attribute\nare skipped. (&quot;attr_get_i&quot; stands for\n&quot;attribute get, with inheritance&quot;.) In scalar\ncontext, returns the first such value, or undef if none.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider a\ndocument consisting of:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;html\nlang='i-klingon'&gt; <br>\n&lt;head&gt;&lt;title&gt;Pati\nPata&lt;/title&gt;&lt;/head&gt; <br>\n&lt;body&gt; <br>\n&lt;h1 lang='la'&gt;Stuff&lt;/h1&gt; <br>\n&lt;p lang='es-MX' align='center'&gt; <br>\nFoo bar baz &lt;cite&gt;Quux&lt;/cite&gt;. <br>\n&lt;/p&gt; <br>\n&lt;p&gt;Hooboy.&lt;/p&gt; <br>\n&lt;/body&gt; <br>\n&lt;/html&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If $h is the\n&quot;&lt;cite&gt;&quot; element,\n&quot;$h-&gt;attr_get_i(&quot;lang&quot;)&quot; in list\ncontext will return the list &quot;('es-MX',\n'i-klingon')&quot;. In scalar context, it will return the\nvalue 'es-MX'.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you call\nwith multiple attribute names...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@values =\n$h-&gt;attr_get_i('a1', 'a2', 'a3'); <br>\n$first_value = $h-&gt;attr_get_i('a1', 'a2', 'a3');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...in list\ncontext, this will return a list consisting of the values of\nthese attributes which exist in $h and its ancestors. In\nscalar context, this returns the first value (i.e., the\nvalue of the first existing attribute from the first element\nthat has any of the attributes listed). So, in the above\nexample,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;attr_get_i('lang',\n'align');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">will\nreturn:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">('es-MX',\n'center', 'i-klingon') # in list context <br>\nor <br>\n'es-MX' # in scalar context.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But note that\nthis:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$h-&gt;attr_get_i('align',\n'lang');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">will\nreturn:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">('center',\n'es-MX', 'i-klingon') # in list context <br>\nor <br>\n'center' # in scalar context.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>tagname_map</b>\n<br>\n$hash_ref = $h-&gt;tagname_map();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Scans across $h\nand all its descendants, and makes a hash (a reference to\nwhich is returned) where each entry consists of a key\nthat&rsquo;s a tag name, and a value that&rsquo;s a\nreference to a list to all elements that have that tag name.\nI.e., this method returns:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">{ <br>\n# Across $h and all descendants... <br>\n'a' =&gt; [ ...list of all &lt;a&gt; elements... ], <br>\n'em' =&gt; [ ...list of all &lt;em&gt; elements... ], <br>\n'img' =&gt; [ ...list of all &lt;img&gt; elements... ], <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(There are\nentries in the hash for only those tagnames that occur\nat/under $h -- so if there&rsquo;s no\n&quot;&lt;img&gt;&quot; elements, there&rsquo;ll be no\n&quot;img&quot; entry in the returned hashref.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Example\nusage:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $map_r =\n$h-&gt;tagname_map(); <br>\nmy @heading_tags = sort grep m/^h\\d$/s, keys %$map_r; <br>\nif(@heading_tags) { <br>\nprint &quot;Heading levels used: @heading_tags\\n&quot;; <br>\n} else { <br>\nprint &quot;No headings.\\n&quot; <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>extract_links</b>\n<br>\n$links_array_ref = $h-&gt;extract_links(); <br>\n$links_array_ref = $h-&gt;extract_links(@wantedTypes);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns links\nfound by traversing the element and all of its children and\nlooking for attributes (like &quot;href&quot; in an\n&quot;&lt;a&gt;&quot; element, or &quot;src&quot; in an\n&quot;&lt;img&gt;&quot; element) whose values represent\nlinks. The return value is a <i>reference</i> to an array.\nEach element of the array is reference to an array with\n<i>four</i> items: the link-value, the element that has the\nattribute with that link-value, and the name of that\nattribute, and the tagname of that element. (Example:\n&quot;['http://www.suck.com/',&quot; <i>$elem_obj</i>\n&quot;, 'href', 'a']&quot;.) You may or may not end up using\nthe element itself -- for some purposes, you may use only\nthe link value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You might\nspecify that you want to extract links from just some kinds\nof elements (instead of the default, which is to extract\nlinks from <i>all</i> the kinds of elements known to have\nattributes whose values represent links). For instance, if\nyou want to extract links from only &quot;&lt;a&gt;&quot;\nand &quot;&lt;img&gt;&quot; elements, you could code it like\nthis:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (@{\n$e-&gt;extract_links('a', 'img') }) { <br>\nmy($link, $element, $attr, $tag) = @$_; <br>\nprint <br>\n&quot;Hey, there's a $tag that links to &quot;, <br>\n$link, &quot;, in its $attr attribute, at &quot;, <br>\n$element-&gt;address(), &quot;.\\n&quot;; <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>simplify_pres</b>\n<br>\n$h-&gt;simplify_pres();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In text bits\nunder <small>PRE</small> elements that are at/under $h, this\nroutine nativizes all newlines, and expands all tabs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That is, if you\nread a file with lines delimited by\n&quot;\\cm\\cj&quot;&rsquo;s, the text under\n<small>PRE</small> areas will have\n&quot;\\cm\\cj&quot;&rsquo;s instead of\n&quot;\\n&quot;&rsquo;s. Calling\n&quot;$h-&gt;simplify_pres&quot; on such a tree will turn\n&quot;\\cm\\cj&quot;&rsquo;s into &quot;\\n&quot;&rsquo;s.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Tabs are\nexpanded to however many spaces it takes to get to the next\n8th column -- the usual way of expanding them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>same_as</b>\n<br>\n$equal = $h-&gt;same_as($i)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns true if\n$h and $i are both elements representing the same tree of\nelements, each with the same tag name, with the same\nexplicit attributes (i.e., not counting attributes whose\nnames start with &quot;_&quot;), and with the same content\n(textual, comments, etc.).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sameness of\ndescendant elements is tested, recursively, with\n&quot;$child1-&gt;same_as($child_2)&quot;, and sameness of\ntext segments is tested with &quot;$segment1 eq\n$segment2&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>new_from_lol</b>\n<br>\n$h = HTML::Element-&gt;new_from_lol($array_ref); <br>\n@elements = HTML::Element-&gt;new_from_lol($array_ref,\n...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Recursively\nconstructs a tree of nodes, based on the (non-cyclic) data\nstructure represented by each $array_ref, where that is a\nreference to an array of arrays (of arrays (of arrays\n(etc.))).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In each\narrayref in that structure, different kinds of values are\ntreated as follows:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"14%\">\n\n\n<p>Arrayrefs</p></td>\n<td width=\"69%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Arrayrefs are\nconsidered to designate a sub-tree representing children for\nthe node constructed from the current arrayref.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">Hashrefs</p></td>\n<td width=\"71%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Hashrefs are\nconsidered to contain attribute-value pairs to add to the\nelement to be constructed from the current arrayref</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"20%\">\n\n\n<p style=\"margin-top: 1em\">Text segments</p></td>\n<td width=\"63%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Text segments\nat the start of any arrayref will be considered to specify\nthe name of the element to be constructed from the current\narrayref; all other text segments will be considered to\nspecify text segments as children for the current\narrayref.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">Elements</p></td>\n<td width=\"71%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Existing\nelement objects are either inserted into the treelet\nconstructed, or clones of them are. That is, when the\nlol-tree is being traversed and elements constructed based\nwhat&rsquo;s in it, if an existing element object is found,\nif it has no parent, then it is added directly to the\ntreelet constructed; but if it has a parent, then\n&quot;$that_node-&gt;clone&quot; is added to the treelet at\nthe appropriate place.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An example will\nhopefully make this more obvious:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $h =\nHTML::Element-&gt;new_from_lol( <br>\n['html', <br>\n['head', <br>\n[ 'title', 'I like stuff!' ], <br>\n], <br>\n['body', <br>\n{'lang', 'en-JP', _implicit =&gt; 1}, <br>\n'stuff', <br>\n['p', 'um, p &lt; 4!', {'class' =&gt; 'par123'}], <br>\n['div', {foo =&gt; 'bar'}, '123'], <br>\n] <br>\n] <br>\n); <br>\n$h-&gt;dump;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Will print\nthis:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;html&gt; @0\n<br>\n&lt;head&gt; @0.0 <br>\n&lt;title&gt; @0.0.0 <br>\n&quot;I like stuff!&quot; <br>\n&lt;body lang=&quot;en-JP&quot;&gt; @0.1 (IMPLICIT) <br>\n&quot;stuff&quot; <br>\n&lt;p class=&quot;par123&quot;&gt; @0.1.1 <br>\n&quot;um, p &lt; 4!&quot; <br>\n&lt;div foo=&quot;bar&quot;&gt; @0.1.2 <br>\n&quot;123&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And printing\n$h-&gt;as_HTML will give something like:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;html&gt;&lt;head&gt;&lt;title&gt;I\nlike stuff!&lt;/title&gt;&lt;/head&gt; <br>\n&lt;body lang=&quot;en-JP&quot;&gt;stuff&lt;p\nclass=&quot;par123&quot;&gt;um, p &amp;lt; 4! <br>\n&lt;div\nfoo=&quot;bar&quot;&gt;123&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can even do\nfancy things with &quot;map&quot;:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$body-&gt;push_content(\n<br>\n# push_content implicitly calls new_from_lol on arrayrefs...\n<br>\n['br'], <br>\n['blockquote', <br>\n['h2', 'Pictures!'], <br>\nmap ['p', $_], <br>\n$body2-&gt;look_down(&quot;_tag&quot;, &quot;img&quot;),\n<br>\n# images, to be copied from that other tree. <br>\n], <br>\n# and more stuff: <br>\n['ul', <br>\nmap ['li', ['a', {'href'=&gt;&quot;$_.png&quot;}, $_ ] ],\n<br>\nqw(Peaches Apples Pears Mangos) <br>\n], <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In scalar\ncontext, you must supply exactly one arrayref. In list\ncontext, you can pass a list of arrayrefs, and new_from_lol\nwill return a list of elements, one for each arrayref.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">@elements =\nHTML::Element-&gt;new_from_lol( <br>\n['hr'], <br>\n['p', 'And there, on the door, was a hook!'], <br>\n); <br>\n# constructs two elements.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>objectify_text</b>\n<br>\n$h-&gt;objectify_text();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This turns any\ntext nodes under $h from mere text segments (strings) into\nreal objects, pseudo-elements with a tag-name of\n&quot;~text&quot;, and the actual text content in an\nattribute called &quot;text&quot;. (For a discussion of\npseudo-elements, see the &quot;tag&quot; method, far above.)\nThis method is provided because, for some purposes, it is\nconvenient or necessary to be able, for a given text node,\nto ask what element is its parent; and clearly this is not\npossible if a node is just a text string.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that these\n&quot;~text&quot; objects are not recognized as text nodes\nby methods like &quot;as_text&quot;. Presumably you will\nwant to call &quot;$h-&gt;objectify_text&quot;, perform\nwhatever task that you needed that for, and then call\n&quot;$h-&gt;deobjectify_text&quot; before calling anything\nlike &quot;$h-&gt;as_text&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>deobjectify_text</b>\n<br>\n$h-&gt;deobjectify_text();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This undoes the\neffect of &quot;$h-&gt;objectify_text&quot;. That is, it\ntakes any &quot;~text&quot; pseudo-elements in the tree\nat/under $h, and deletes each one, replacing each with the\ncontent of its &quot;text&quot; attribute.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that if $h\nitself is a &quot;~text&quot; pseudo-element, it will be\ndestroyed -- a condition you may need to treat specially in\nyour calling code (since it means you can&rsquo;t very well\ndo anything with $h after that). So that you can detect that\ncondition, if $h is itself a &quot;~text&quot;\npseudo-element, then this method returns the value of the\n&quot;text&quot; attribute, which should be a defined value;\nin all other cases, it returns undef.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(This method\nassumes that no &quot;~text&quot; pseudo-element has any\nchildren.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>number_lists</b>\n<br>\n$h-&gt;number_lists();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For every\n<small>UL, OL, DIR,</small> and <small>MENU</small> element\nat/under $h, this sets a &quot;_bullet&quot; attribute for\nevery child <small>LI</small> element. For <small>LI</small>\nchildren of an <small>OL,</small> the &quot;_bullet&quot;\nattribute&rsquo;s value will be something like\n&quot;4.&quot;, &quot;d.&quot;, &quot;D.&quot;, &quot;\n<small>IV.&quot;,</small> or &quot;iv.&quot;, depending on\nthe <small>OL</small> element&rsquo;s &quot;type&quot;\nattribute. <small>LI</small> children of a <small>UL,\nDIR,</small> or <small>MENU</small> get their\n&quot;_bullet&quot; attribute set to &quot;*&quot;. There\nshould be no other LIs (i.e., except as children of\n<small>OL, UL, DIR,</small> or <small>MENU</small>\nelements), and if there are, they are unaffected.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>has_insane_linkage</b>\n<br>\n$h-&gt;has_insane_linkage</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method is\nfor testing whether this element or the elements under it\nhave linkage attributes (_parent and _content) whose values\nare deeply aberrant: if there are undefs in a content list;\nif an element appears in the content lists of more than one\nelement; if the _parent attribute of an element\ndoesn&rsquo;t match its actual parent; or if an element\nappears as its own descendant (i.e., if there is a cyclicity\nin the tree).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This returns\nempty list (or false, in scalar context) if the\nsubtree&rsquo;s linkage methods are sane; otherwise it\nreturns two items (or true, in scalar context): the element\nwhere the error occurred, and a string describing the\nerror.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method is\nprovided is mainly for debugging and troubleshooting -- it\nshould be <i>quite impossible</i> for any document\nconstructed via HTML::TreeBuilder to parse into a non-sane\ntree (since it&rsquo;s not the content of the tree per se\nthat&rsquo;s in question, but whether the tree in memory was\nproperly constructed); and it <i>should</i> be impossible\nfor you to produce an insane tree just thru reasonable use\nof normal documented structure-modifying methods. But if\nyou&rsquo;re constructing your own trees, and your program\nis going into infinite loops as during calls to\n<b>traverse()</b> or any of the secondary structural\nmethods, as part of debugging, consider calling\n&quot;has_insane_linkage&quot; on the tree.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>element_class</b>\n<br>\n$classname = $h-&gt;element_class();</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nreturns the class which will be used for new elements. It\ndefaults to HTML::Element, but can be overridden by\nsubclassing or esoteric means best left to those will will\nread the source and then not complain when those esoteric\nmeans change. (Just subclass.)</p>\n\n<h2>CLASS METHODS\n<a name=\"CLASS METHODS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Use_Weak_Refs</b>\n<br>\n$enabled = HTML::Element-&gt;Use_Weak_Refs; <br>\nHTML::Element-&gt;Use_Weak_Refs( $enabled );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nallows you to check whether weak reference support is\nenabled, and to enable or disable it. For details, see\n&quot;Weak References&quot;. $enabled is true if weak\nreferences are enabled.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You should not\nswitch this in the middle of your program, and you probably\nshouldn&rsquo;t use it at all. Existing trees are not\naffected by this method (until you start modifying nodes in\nthem).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Throws an\nexception if you attempt to enable weak references and your\nPerl or Scalar::Util does not support them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Disabling weak\nreference support is deprecated.</p>\n\n<h2>SUBROUTINES\n<a name=\"SUBROUTINES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Version</b>\n<br>\nThis subroutine is deprecated. Please use the standard\n<small>VERSION</small> method (e.g.\n&quot;HTML::Element-&gt;VERSION&quot;) instead.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>ABORT\nOK PRUNE PRUNE_SOFTLY PRUNE_UP</small></b> <br>\nConstants for signalling back to the traverser</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">* If you want\nto free the memory associated with a tree built of\nHTML::Element nodes, and you have disabled weak references,\nthen you will have to delete it explicitly using the\n&quot;delete&quot; method. See &quot;Weak\nReferences&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* There&rsquo;s\nalmost nothing to stop you from making a &quot;tree&quot;\nwith cyclicities (loops) in it, which could, for example,\nmake the traverse method go into an infinite loop. So\ndon&rsquo;t make cyclicities! (If all you&rsquo;re doing is\nparsing <small>HTML</small> files, and looking at the\nresulting trees, this will never be a problem for you.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* There&rsquo;s\nno way to represent comments or processing directives in a\ntree with HTML::Elements. Not yet, at least.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* There&rsquo;s\n(currently) nothing to stop you from using an undefined\nvalue as a text segment. If you&rsquo;re running under\n&quot;perl -w&quot;, however, this may make\nHTML::Element&rsquo;s code produce a slew of warnings.</p>\n\n<h2>NOTES ON SUBCLASSING\n<a name=\"NOTES ON SUBCLASSING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">You are welcome\nto derive subclasses from HTML::Element, but you should be\naware that the code in HTML::Element makes certain\nassumptions about elements (and I&rsquo;m using\n&quot;element&quot; to mean <small>ONLY</small> an object of\nclass HTML::Element, or of a subclass of HTML::Element):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* The value of\nan element&rsquo;s _parent attribute must either be undef or\notherwise false, or must be an element.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* The value of\nan element&rsquo;s _content attribute must either be undef\nor otherwise false, or a reference to an (unblessed) array.\nThe array may be empty; but if it has items, they must\n<small>ALL</small> be either mere strings (text segments),\nor elements.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* The value of\nan element&rsquo;s _tag attribute should, at least, be a\nstring of printable characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Moreover, bear\nthese rules in mind:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* Do not break\nencapsulation on objects. That is, access their contents\nonly thru $obj-&gt;attr or more specific methods.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* You should\nthink twice before completely overriding any of the methods\nthat HTML::Element provides. (Overriding with a method that\ncalls the superclass method is not so bad, though.)</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::Tree;\nHTML::TreeBuilder; HTML::AsSubs; HTML::Tagset; and, for the\nmorbidly curious, HTML::Element::traverse.</p>\n\n<h2>ACKNOWLEDGEMENTS\n<a name=\"ACKNOWLEDGEMENTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Thanks to\nMark-Jason Dominus for a <small>POD</small> suggestion.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Current\nmaintainers:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"68%\">\n\n\n<p style=\"margin-top: 1em\">Christopher J. Madsen\n&quot;&lt;perl&nbsp;AT&nbsp;cjmweb.net&gt;&quot;</p> </td>\n<td width=\"15%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"68%\">\n\n\n<p>Jeff Fearn\n&quot;&lt;jfearn&nbsp;AT&nbsp;cpan.org&gt;&quot;</p> </td>\n<td width=\"15%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Original\nHTML-Tree author:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"14%\">\n\n\n<p style=\"margin-top: 1em\">Gisle Aas</p></td>\n<td width=\"69%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Former\nmaintainers:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"54%\">\n\n\n<p style=\"margin-top: 1em\">Sean M. Burke</p></td>\n<td width=\"29%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"54%\">\n\n\n<p>Andy Lester</p></td>\n<td width=\"29%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"54%\">\n\n\n<p>Pete Krawczyk\n&quot;&lt;petek&nbsp;AT&nbsp;cpan.org&gt;&quot;</p> </td>\n<td width=\"29%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can follow\nor contribute to HTML-Tree&rsquo;s development at\n&lt;https://github.com/kentfredric/HTML-Tree&gt;.</p>\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n1995-1998 Gisle Aas, 1999-2004 Sean M. Burke, 2005 Andy\nLester, 2006 Pete Krawczyk, 2010 Jeff Fearn, 2012\nChristopher J. Madsen.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The programs in\nthis library are distributed in the hope that they will be\nuseful, but without any warranty; without even the implied\nwarranty of merchantability or fitness for a particular\npurpose.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#HOW WE REPRESENT TREES\">HOW WE REPRESENT TREES</a>","<a href=\"#BASIC METHODS\">BASIC METHODS</a>","<a href=\"#STRUCTURE-MODIFYING METHODS\">STRUCTURE-MODIFYING METHODS</a>","<a href=\"#DUMPING METHODS\">DUMPING METHODS</a>","<a href=\"#SECONDARY STRUCTURAL METHODS\">SECONDARY STRUCTURAL METHODS</a>","<a href=\"#CLASS METHODS\">CLASS METHODS</a>","<a href=\"#SUBROUTINES\">SUBROUTINES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#NOTES ON SUBCLASSING\">NOTES ON SUBCLASSING</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#ACKNOWLEDGEMENTS\">ACKNOWLEDGEMENTS</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT AND LICENSE\">COPYRIGHT AND LICENSE</a>"],"level":3}