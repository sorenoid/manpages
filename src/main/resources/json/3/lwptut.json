{"name":"lwptut","body":"\n\n<h1 align=\"center\">lwptut</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">lwptut -- An\nLWP Tutorial</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>LWP</small>\n(short for &quot;Library for <small>WWW</small> in\nPerl&quot;) is a very popular group of Perl modules for\naccessing data on the Web. Like most Perl\nmodule-distributions, each of <small>LWP</small> &rsquo;s\ncomponent modules comes with documentation that is a\ncomplete reference to its interface. However, there are so\nmany modules in <small>LWP</small> that it&rsquo;s hard to\nknow where to start looking for information on how to do\neven the simplest most common things.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Really\nintroducing you to using <small>LWP</small> would require a\nwhole book -- a book that just happens to exist, called\n<i>Perl &amp; <small>LWP</small></i> . But this article\nshould give you a taste of how you can go about some common\ntasks with <small>LWP.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Getting\ndocuments with LWP::Simple</b> <br>\nIf you just want to get what&rsquo;s at a particular\n<small>URL,</small> the simplest way to do it is\nLWP::Simple&rsquo;s functions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a Perl\nprogram, you can call its &quot;get($url)&quot; function. It\nwill try getting that <small>URL</small> &rsquo;s content.\nIf it works, then it&rsquo;ll return the content; but if\nthere&rsquo;s some error, it&rsquo;ll return undef.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $url =\n'http://www.npr.org/programs/fa/?todayDate=current'; <br>\n# Just an example: the URL for the most recent /Fresh Air/\nshow <br>\nuse LWP::Simple; <br>\nmy $content = get $url; <br>\ndie &quot;Couldn't get $url&quot; unless defined $content;\n<br>\n# Then go do things with $content, like this: <br>\nif($content =~ m/jazz/i) { <br>\nprint &quot;They're talking about jazz today on Fresh\nAir!\\n&quot;; <br>\n} <br>\nelse { <br>\nprint &quot;Fresh Air is apparently jazzless today.\\n&quot;;\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The handiest\nvariant on &quot;get&quot; is &quot;getprint&quot;, which is\nuseful in Perl one-liners. If it can get the page whose\n<small>URL</small> you provide, it sends it to\n<small>STDOUT</small> ; otherwise it complains to\n<small>STDERR.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">% perl\n-MLWP::Simple -e &quot;getprint\n'http://www.cpan.org/RECENT'&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That is the\n<small>URL</small> of a plain text file that lists new files\nin <small>CPAN</small> in the past two weeks. You can easily\nmake it part of a tidy little shell command, like this one\nthat mails you the list of new &quot;Acme::&quot;\nmodules:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">% perl\n-MLWP::Simple -e &quot;getprint\n'http://www.cpan.org/RECENT'&quot; \\ <br>\n| grep &quot;/by-module/Acme&quot; | mail -s &quot;New Acme\nmodules! Joy!&quot; $USER</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are other\nuseful functions in LWP::Simple, including one function for\nrunning a <small>HEAD</small> request on a\n<small>URL</small> (useful for checking links, or getting\nthe last-revised time of a <small>URL</small> ), and two\nfunctions for saving/mirroring a <small>URL</small> to a\nlocal file. See the LWP::Simple documentation for the full\ndetails, or chapter 2 of <i>Perl &amp;\n<small>LWP</small></i> for more examples.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The Basics\nof the <small>LWP</small> Class Model</b> <br>\nLWP::Simple&rsquo;s functions are handy for simple cases,\nbut its functions don&rsquo;t support cookies or\nauthorization, don&rsquo;t support setting header lines in\nthe <small>HTTP</small> request, generally don&rsquo;t\nsupport reading header lines in the <small>HTTP</small>\nresponse (notably the full <small>HTTP</small> error\nmessage, in case of an error). To get at all those features,\nyou&rsquo;ll have to use the full <small>LWP</small> class\nmodel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">While\n<small>LWP</small> consists of dozens of classes, the main\ntwo that you have to understand are LWP::UserAgent and\nHTTP::Response. LWP::UserAgent is a class for &quot;virtual\nbrowsers&quot; which you use for performing requests, and\nHTTP::Response is a class for the responses (or error\nmessages) that you get back from those requests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The basic idiom\nis &quot;$response = $browser-&gt;get($url)&quot;, or more\nfully illustrated:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># Early in your\nprogram: <br>\nuse LWP 5.64; # Loads all important LWP classes, and makes\n<br>\n# sure your version is reasonably recent. <br>\nmy $browser = LWP::UserAgent-&gt;new; <br>\n... <br>\n# Then later, whenever you need to make a get request: <br>\nmy $url =\n'http://www.npr.org/programs/fa/?todayDate=current'; <br>\nmy $response = $browser-&gt;get( $url ); <br>\ndie &quot;Can't get $url -- &quot;,\n$response-&gt;status_line <br>\nunless $response-&gt;is_success; <br>\ndie &quot;Hey, I was expecting HTML, not &quot;,\n$response-&gt;content_type <br>\nunless $response-&gt;content_type eq 'text/html'; <br>\n# or whatever content-type you're equipped to deal with <br>\n# Otherwise, process the content somehow: <br>\nif($response-&gt;decoded_content =~ m/jazz/i) { <br>\nprint &quot;They're talking about jazz today on Fresh\nAir!\\n&quot;; <br>\n} <br>\nelse { <br>\nprint &quot;Fresh Air is apparently jazzless today.\\n&quot;;\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\nobjects involved: $browser, which holds an object of class\nLWP::UserAgent, and then the $response object, which is of\nclass HTTP::Response. You really need only one browser\nobject per program; but every time you make a request, you\nget back a new HTTP::Response object, which will have some\ninteresting attributes:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>A status code indicating success or failure (which you\ncan test with &quot;$response-&gt;is_success&quot;).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>An <small>HTTP</small> status line that is hopefully\ninformative if there&rsquo;s failure (which you can see with\n&quot;$response-&gt;status_line&quot;, returning something\nlike &quot;404 Not Found&quot;).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>A <small>MIME</small> content-type like\n&quot;text/html&quot;, &quot;image/gif&quot;,\n&quot;application/xml&quot;, etc., which you can see with\n&quot;$response-&gt;content_type&quot;</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>The actual content of the response, in\n&quot;$response-&gt;decoded_content&quot;. If the response\nis <small>HTML,</small> that&rsquo;s where the\n<small>HTML</small> source will be; if it&rsquo;s a\n<small>GIF,</small> then\n&quot;$response-&gt;decoded_content&quot; will be the binary\n<small>GIF</small> data.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>And dozens of other convenient and more specific methods\nthat are documented in the docs for HTTP::Response, and its\nsuperclasses HTTP::Message and HTTP::Headers.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Adding Other\n<small>HTTP</small> Request Headers</b> <br>\nThe most commonly used syntax for requests is\n&quot;$response = $browser-&gt;get($url)&quot;, but in\ntruth, you can add extra <small>HTTP</small> header lines to\nthe request by adding a list of key-value pairs after the\n<small>URL,</small> like so:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$response =\n$browser-&gt;get( $url, $key1, $value1, $key2, $value2, ...\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nhere&rsquo;s how to send some commonly used headers, in case\nyou&rsquo;re dealing with a site that would otherwise reject\nyour request:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my @ns_headers\n= ( <br>\n'User-Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)', <br>\n'Accept' =&gt; 'image/gif, image/x-xbitmap, image/jpeg,\nimage/pjpeg, image/png, */*', <br>\n'Accept-Charset' =&gt; 'iso-8859-1,*,utf-8', <br>\n'Accept-Language' =&gt; 'en-US', <br>\n); <br>\n... <br>\n$response = $browser-&gt;get($url, @ns_headers);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you\nweren&rsquo;t reusing that array, you could just go ahead\nand do this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$response =\n$browser-&gt;get($url, <br>\n'User-Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)', <br>\n'Accept' =&gt; 'image/gif, image/x-xbitmap, image/jpeg,\nimage/pjpeg, image/png, */*', <br>\n'Accept-Charset' =&gt; 'iso-8859-1,*,utf-8', <br>\n'Accept-Language' =&gt; 'en-US', <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you were\nonly ever changing the &rsquo;User-Agent&rsquo; line, you\ncould just change the $browser object&rsquo;s default line\nfrom &quot;libwww-perl/5.65&quot; (or the like) to whatever\nyou like, using the LWP::UserAgent &quot;agent&quot;\nmethod:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$browser-&gt;agent('Mozilla/4.76\n[en] (Win98; U)');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Enabling\nCookies</b> <br>\nA default LWP::UserAgent object acts like a browser with its\ncookies support turned off. There are various ways of\nturning it on, by setting its &quot;cookie_jar&quot;\nattribute. A &quot;cookie jar&quot; is an object\nrepresenting a little database of all the\n<small>HTTP</small> cookies that a browser knows about. It\ncan correspond to a file on disk or an in-memory object that\nstarts out empty, and whose collection of cookies will\ndisappear once the program is finished running.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To give a\nbrowser an in-memory empty cookie jar, you set its\n&quot;cookie_jar&quot; attribute like so:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTTP::CookieJar::LWP; <br>\n$browser-&gt;cookie_jar( HTTP::CookieJar::LWP-&gt;new );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To save a\ncookie jar to disk, see &quot;dump_cookies&quot; in\nHTTP::CookieJar. To load cookies from disk into a jar, see\n&quot;load_cookies&quot; in HTTP::CookieJar.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Posting Form\nData</b> <br>\nMany <small>HTML</small> forms send data to their server\nusing an <small>HTTP POST</small> request, which you can\nsend with this syntax:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$response =\n$browser-&gt;post( $url, <br>\n[ <br>\nformkey1 =&gt; value1, <br>\nformkey2 =&gt; value2, <br>\n... <br>\n], <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Or if you need\nto send <small>HTTP</small> headers:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$response =\n$browser-&gt;post( $url, <br>\n[ <br>\nformkey1 =&gt; value1, <br>\nformkey2 =&gt; value2, <br>\n... <br>\n], <br>\nheaderkey1 =&gt; value1, <br>\nheaderkey2 =&gt; value2, <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nthe following program makes a search request to AltaVista\n(by sending some form data via an <small>HTTP POST</small>\nrequest), and extracts from the <small>HTML</small> the\nreport of the number of matches:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use strict;\n<br>\nuse warnings; <br>\nuse LWP 5.64; <br>\nmy $browser = LWP::UserAgent-&gt;new; <br>\nmy $word = 'tarragon'; <br>\nmy $url = 'http://search.yahoo.com/yhs/search'; <br>\nmy $response = $browser-&gt;post( $url, <br>\n[ 'q' =&gt; $word, # the Altavista query string <br>\n'fr' =&gt; 'altavista', 'pg' =&gt; 'q', 'avkw' =&gt; 'tgz',\n'kl' =&gt; 'XX', <br>\n] <br>\n); <br>\ndie &quot;$url error: &quot;, $response-&gt;status_line <br>\nunless $response-&gt;is_success; <br>\ndie &quot;Weird content type at $url -- &quot;,\n$response-&gt;content_type <br>\nunless $response-&gt;content_is_html; <br>\nif( $response-&gt;decoded_content =~\nm{([0-9,]+)(?:&lt;.*?&gt;)? results for} ) { <br>\n# The substring will be like &quot;996,000&lt;/strong&gt;\nresults for&quot; <br>\nprint &quot;$word: $1\\n&quot;; <br>\n} <br>\nelse { <br>\nprint &quot;Couldn't find the match-string in the\nresponse\\n&quot;; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Sending\n<small>GET</small> Form Data</b> <br>\nSome <small>HTML</small> forms convey their form data not by\nsending the data in an <small>HTTP POST</small> request, but\nby making a normal <small>GET</small> request with the data\nstuck on the end of the <small>URL.</small> For example, if\nyou went to &quot;www.imdb.com&quot; and ran a search on\n&quot;Blade Runner&quot;, the <small>URL</small> you&rsquo;d\nsee in your browser window would be:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">http://www.imdb.com/find?s=all&amp;q=Blade+Runner</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To run the same\nsearch with <small>LWP,</small> you&rsquo;d use this idiom,\nwhich involves the <small>URI</small> class:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use URI; <br>\nmy $url = URI-&gt;new( 'http://www.imdb.com/find' ); <br>\n# makes an object representing the URL <br>\n$url-&gt;query_form( # And here the form data pairs: <br>\n'q' =&gt; 'Blade Runner', <br>\n's' =&gt; 'all', <br>\n); <br>\nmy $response = $browser-&gt;get($url);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See chapter 5\nof <i>Perl &amp; <small>LWP</small></i> for a longer\ndiscussion of <small>HTML</small> forms and of form data,\nand chapters 6 through 9 for a longer discussion of\nextracting data from <small>HTML.</small></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Absolutizing\nURLs</b> <br>\nThe <small>URI</small> class that we just mentioned above\nprovides all sorts of methods for accessing and modifying\nparts of URLs (such as asking sort of <small>URL</small> it\nis with &quot;$url-&gt;scheme&quot;, and asking what host it\nrefers to with &quot;$url-&gt;host&quot;, and so on, as\ndescribed in the docs for the <small>URI</small> class.\nHowever, the methods of most immediate interest are the\n&quot;query_form&quot; method seen above, and now the\n&quot;new_abs&quot; method for taking a probably-relative\n<small>URL</small> string (like &quot;../foo.html&quot;) and\ngetting back an absolute <small>URL</small> (like\n&quot;http://www.perl.com/stuff/foo.html&quot;), as shown\nhere:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use URI; <br>\n$abs = URI-&gt;new_abs($maybe_relative, $base);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nconsider this program that matches URLs in the\n<small>HTML</small> list of new modules in\n<small>CPAN:</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use strict;\n<br>\nuse warnings; <br>\nuse LWP; <br>\nmy $browser = LWP::UserAgent-&gt;new; <br>\nmy $url = 'http://www.cpan.org/RECENT.html'; <br>\nmy $response = $browser-&gt;get($url); <br>\ndie &quot;Can't get $url -- &quot;,\n$response-&gt;status_line <br>\nunless $response-&gt;is_success; <br>\nmy $html = $response-&gt;decoded_content; <br>\nwhile( $html =~ m/&lt;A HREF=\\&quot;(.*?)\\&quot;/g ) { <br>\nprint &quot;$1\\n&quot;; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When run, it\nemits output that starts out something like this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">MIRRORING.FROM\n<br>\nRECENT <br>\nRECENT.html <br>\nauthors/00whois.html <br>\nauthors/01mailrc.txt.gz <br>\nauthors/id/A/AA/AASSAD/CHECKSUMS <br>\n...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if you\nactually want to have those be absolute URLs, you can use\nthe <small>URI</small> module&rsquo;s &quot;new_abs&quot;\nmethod, by changing the &quot;while&quot; loop to this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while( $html =~\nm/&lt;A HREF=\\&quot;(.*?)\\&quot;/g ) { <br>\nprint URI-&gt;new_abs( $1, $response-&gt;base )\n,&quot;\\n&quot;; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(The\n&quot;$response-&gt;base&quot; method from HTTP::Message is\nfor returning what <small>URL</small> should be used for\nresolving relative URLs -- it&rsquo;s usually just the same\nas the <small>URL</small> that you requested.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That program\nthen emits nicely absolute URLs:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">http://www.cpan.org/MIRRORING.FROM\n<br>\nhttp://www.cpan.org/RECENT <br>\nhttp://www.cpan.org/RECENT.html <br>\nhttp://www.cpan.org/authors/00whois.html <br>\nhttp://www.cpan.org/authors/01mailrc.txt.gz <br>\nhttp://www.cpan.org/authors/id/A/AA/AASSAD/CHECKSUMS <br>\n...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See chapter 4\nof <i>Perl &amp; <small>LWP</small></i> for a longer\ndiscussion of <small>URI</small> objects.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Of course,\nusing a regexp to match hrefs is a bit simplistic, and for\nmore robust programs, you&rsquo;ll probably want to use an\nHTML-parsing module like HTML::LinkExtor or HTML::TokeParser\nor even maybe HTML::TreeBuilder.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Other\nBrowser Attributes</b> <br>\nLWP::UserAgent objects have many attributes for controlling\nhow they work. Here are a few notable ones:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"37%\">\n\n\n\n<p style=\"margin-top: 1em\">&quot;$browser-&gt;timeout(15);&quot;</p> </td>\n<td width=\"46%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This sets this\nbrowser object to give up on requests that don&rsquo;t\nanswer within 15 seconds.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"81%\">\n\n\n\n<p style=\"margin-top: 1em\">&quot;$browser-&gt;protocols_allowed(\n[ 'http', 'gopher'] );&quot;</p></td>\n<td width=\"2%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This sets this\nbrowser object to not speak any protocols other than\n<small>HTTP</small> and gopher. If it tries accessing any\nother kind of <small>URL</small> (like an &quot;ftp:&quot;\nor &quot;mailto:&quot; or &quot;news:&quot;\n<small>URL</small> ), then it won&rsquo;t actually try\nconnecting, but instead will immediately return an error\ncode 500, with a message like &quot;Access to\n&rsquo;ftp&rsquo; URIs has been disabled&quot;.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">&quot;use LWP::ConnCache;\n$browser-&gt;conn_cache(LWP::ConnCache-&gt;new());&quot;</p> </td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This tells the\nbrowser object to try using the <small>HTTP/1.1</small>\n&quot;Keep-Alive&quot; feature, which speeds up requests by\nreusing the same socket connection for multiple requests to\nthe same server.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">&quot;$browser-&gt;agent(\n'SomeName/1.23 (more info here maybe)' )&quot;</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This changes\nhow the browser object will identify itself in the default\n&quot;User-Agent&quot; line is its <small>HTTP</small>\nrequests. By default, it&rsquo;ll send\n&quot;libwww-perl/<i>versionnumber</i>&quot;, like\n&quot;libwww-perl/5.65&quot;. You can change that to\nsomething more descriptive like this:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$browser-&gt;agent(\n'SomeName/3.14 (contact@robotplexus.int)' );</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Or if need be,\nyou can go in disguise, like this:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$browser-&gt;agent(\n'Mozilla/4.0 (compatible; MSIE 5.12; Mac_PowerPC)' );</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"72%\">\n\n\n<p style=\"margin-top: 1em\">&quot;push @{\n$ua-&gt;requests_redirectable }, 'POST';&quot;</p></td>\n<td width=\"11%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This tells this\nbrowser to obey redirection responses to <small>POST</small>\nrequests (like most modern interactive browsers), even\nthough the <small>HTTP RFC</small> says that should not\nnormally be done.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For more\noptions and information, see the full documentation for\nLWP::UserAgent.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Writing\nPolite Robots</b> <br>\nIf you want to make sure that your LWP-based program\nrespects <i>robots.txt</i> files and doesn&rsquo;t make too\nmany requests too fast, you can use the LWP::RobotUA class\ninstead of the LWP::UserAgent class.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">LWP::RobotUA\nclass is just like LWP::UserAgent, and you can use it like\nso:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nLWP::RobotUA; <br>\nmy $browser = LWP::RobotUA-&gt;new('YourSuperBot/1.34',\n'you@yoursite.com'); <br>\n# Your bot's name and your email address <br>\nmy $response = $browser-&gt;get($url);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But\nHTTP::RobotUA adds these features:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">If the <i>robots.txt</i> on\n$url&rsquo;s server forbids you from accessing $url, then\nthe $browser object (assuming it&rsquo;s of class\nLWP::RobotUA) won&rsquo;t actually request it, but instead\nwill give you back (in $response) a 403 error with a message\n&quot;Forbidden by robots.txt&quot;. That is, if you have\nthis line:</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">die &quot;$url\n-- &quot;, $response-&gt;status_line, &quot;\\nAborted&quot;\n<br>\nunless $response-&gt;is_success;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">then the\nprogram would die with an error message like this:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">http://whatever.site.int/pith/x.html\n-- 403 Forbidden by robots.txt <br>\nAborted at whateverprogram.pl line 1234</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">If this $browser object sees\nthat the last time it talked to $url&rsquo;s server was too\nrecently, then it will pause (via &quot;sleep&quot;) to\navoid making too many requests too often. How long it will\npause for, is by default one minute -- but you can control\nit with the &quot;$browser-&gt;delay( <i>minutes</i> )&quot;\nattribute.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For example,\nthis code:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$browser-&gt;delay(\n7/60 );</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">...means that\nthis browser will pause when it needs to avoid talking to\nany given server more than once every 7 seconds.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For more\noptions and information, see the full documentation for\nLWP::RobotUA.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Using\nProxies</b> <br>\nIn some cases, you will want to (or will have to) use\nproxies for accessing certain sites and/or using certain\nprotocols. This is most commonly the case when your\n<small>LWP</small> program is running (or could be running)\non a machine that is behind a firewall.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To make a\nbrowser object use proxies that are defined in the usual\nenvironment variables (&quot;HTTP_PROXY&quot;, etc.), just\ncall the &quot;env_proxy&quot; on a user-agent object before\nyou go making any requests on it. Specifically:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nLWP::UserAgent; <br>\nmy $browser = LWP::UserAgent-&gt;new; <br>\n# And before you go making any requests: <br>\n$browser-&gt;env_proxy;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For more\ninformation on proxy parameters, see the LWP::UserAgent\ndocumentation, specifically the &quot;proxy&quot;,\n&quot;env_proxy&quot;, and &quot;no_proxy&quot; methods.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>HTTP</small>\nAuthentication</b> <br>\nMany web sites restrict access to documents by using &quot;\n<small>HTTP</small> Authentication&quot;. This isn&rsquo;t\njust any form of &quot;enter your password&quot;\nrestriction, but is a specific mechanism where the\n<small>HTTP</small> server sends the browser an\n<small>HTTP</small> code that says &quot;That document is\npart of a protected &rsquo;realm&rsquo;, and you can access\nit only if you re-request it and add some special\nauthorization headers to your request&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nthe Unicode.org admins stop email-harvesting bots from\nharvesting the contents of their mailing list archives, by\nprotecting them with <small>HTTP</small> Authentication, and\nthen publicly stating the username and password (at\n&quot;http://www.unicode.org/mail-arch/&quot;) -- namely\nusername &quot;unicode-ml&quot; and password\n&quot;unicode&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nconsider this <small>URL,</small> which is part of the\nprotected area of the web site:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you access\nthat with a browser, you&rsquo;ll get a prompt like\n&quot;Enter username and password for\n&rsquo;Unicode-MailList-Archives&rsquo; at server\n&rsquo;www.unicode.org&rsquo;&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In\n<small>LWP,</small> if you just request that\n<small>URL,</small> like this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use LWP; <br>\nmy $browser = LWP::UserAgent-&gt;new; <br>\nmy $url = <br>\n\n'http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html';\n<br>\nmy $response = $browser-&gt;get($url); <br>\ndie &quot;Error: &quot;,\n$response-&gt;header('WWW-Authenticate') || 'Error\naccessing', <br>\n# ('WWW-Authenticate' is the realm-name) <br>\n&quot;\\n &quot;, $response-&gt;status_line, &quot;\\n at\n$url\\n Aborting&quot; <br>\nunless $response-&gt;is_success;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then\nyou&rsquo;ll get this error:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Error: Basic\nrealm=&quot;Unicode-MailList-Archives&quot; <br>\n401 Authorization Required <br>\nat\nhttp://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html\n<br>\nAborting at auth1.pl line 9. [or wherever]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...because the\n$browser doesn&rsquo;t know any the username and password\nfor that realm (&quot;Unicode-MailList-Archives&quot;) at\nthat host (&quot;www.unicode.org&quot;). The simplest way to\nlet the browser know about this is to use the\n&quot;credentials&quot; method to let it know about a\nusername and password that it can try using for that realm\nat that host. The syntax is:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$browser-&gt;credentials(\n<br>\n'servername:portnumber', <br>\n'realm-name', <br>\n'username' =&gt; 'password' <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In most cases,\nthe port number is 80, the default <small>TCP/IP</small>\nport for <small>HTTP</small> ; and you usually call the\n&quot;credentials&quot; method before you make any requests.\nFor example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$browser-&gt;credentials(\n<br>\n'reports.mybazouki.com:80', <br>\n'web_server_usage_reports', <br>\n'plinky' =&gt; 'banjo123' <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So if we add\nthe following to the program above, right after the\n&quot;$browser = LWP::UserAgent-&gt;new;&quot; line...</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$browser-&gt;credentials(\n# add this to our $browser 's &quot;key ring&quot; <br>\n'www.unicode.org:80', <br>\n'Unicode-MailList-Archives', <br>\n'unicode-ml' =&gt; 'unicode' <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...then when we\nrun it, the request succeeds, instead of causing the\n&quot;die&quot; to be called.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Accessing\n<small>HTTPS</small> URLs</b> <br>\nWhen you access an <small>HTTPS URL,</small> it&rsquo;ll\nwork for you just like an <small>HTTP URL</small> would --\nif your <small>LWP</small> installation has\n<small>HTTPS</small> support (via an appropriate Secure\nSockets Layer library). For example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use LWP; <br>\nmy $url = 'https://www.paypal.com/'; # Yes, HTTPS! <br>\nmy $browser = LWP::UserAgent-&gt;new; <br>\nmy $response = $browser-&gt;get($url); <br>\ndie &quot;Error at $url\\n &quot;, $response-&gt;status_line,\n&quot;\\n Aborting&quot; <br>\nunless $response-&gt;is_success; <br>\nprint &quot;Whee, it worked! I got that &quot;, <br>\n$response-&gt;content_type, &quot; document!\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If your\n<small>LWP</small> installation doesn&rsquo;t have\n<small>HTTPS</small> support set up, then the response will\nbe unsuccessful, and you&rsquo;ll get this error\nmessage:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Error at\nhttps://www.paypal.com/ <br>\n501 Protocol scheme 'https' is not supported <br>\nAborting at paypal.pl line 7. [or whatever program and\nline]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If your\n<small>LWP</small> installation <i>does</i> have\n<small>HTTPS</small> support installed, then the response\nshould be successful, and you should be able to consult\n$response just like with any normal <small>HTTP</small>\nresponse.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For information\nabout installing <small>HTTPS</small> support for your\n<small>LWP</small> installation, see the helpful\n<i><small>README.SSL</small></i> file that comes in the\nlibwww-perl distribution.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Getting\nLarge Documents</b> <br>\nWhen you&rsquo;re requesting a large (or at least\npotentially large) document, a problem with the normal way\nof using the request methods (like &quot;$response =\n$browser-&gt;get($url)&quot;) is that the response object in\nmemory will have to hold the whole document -- <i>in\nmemory</i>. If the response is a thirty megabyte file, this\nis likely to be quite an imposition on this process&rsquo;s\nmemory usage.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A notable\nalternative is to have <small>LWP</small> save the content\nto a file on disk, instead of saving it up in memory. This\nis the syntax to use:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$response =\n$ua-&gt;get($url, <br>\n':content_file' =&gt; $filespec, <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\nexample,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$response =\n$ua-&gt;get('http://search.cpan.org/', <br>\n':content_file' =&gt; '/tmp/sco.html' <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When you use\nthis &quot;:content_file&quot; option, the $response will\nhave all the normal header lines, but\n&quot;$response-&gt;content&quot; will be empty. Errors\nwriting to the content file (for example due to permission\ndenied or the filesystem being full) will be reported via\nthe &quot;Client-Aborted&quot; or &quot;X-Died&quot;\nresponse headers, and not the &quot;is_success&quot;\nmethod:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n($response-&gt;header('Client-Aborted') eq 'die') { <br>\n# handle error ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that this\n&quot;:content_file&quot; option isn&rsquo;t supported under\nolder versions of <small>LWP,</small> so you should consider\nadding &quot;use LWP 5.66;&quot; to check the\n<small>LWP</small> version, if you think your program might\nrun on systems with older versions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you need to\nbe compatible with older <small>LWP</small> versions, then\nuse this syntax, which does the same thing:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTTP::Request::Common; <br>\n$response = $ua-&gt;request( GET($url), $filespec );</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Remember, this\narticle is just the most rudimentary introduction to\n<small>LWP</small> -- to learn more about <small>LWP</small>\nand LWP-related tasks, you really must read from the\nfollowing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">LWP::Simple -- simple functions\nfor getting/heading/mirroring URLs</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p><small>LWP</small> -- overview of the libwww-perl\nmodules</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>LWP::UserAgent -- the class for objects that represent\n&quot;virtual browsers&quot;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>HTTP::Response -- the class for objects that represent\nthe response to a <small>LWP</small> response, as in\n&quot;$response = $browser-&gt;get(...)&quot;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>HTTP::Message and HTTP::Headers -- classes that provide\nmore methods to HTTP::Response.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p><small>URI</small> -- class for objects that represent\nabsolute or relative URLs</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>URI::Escape -- functions for URL-escaping and\nURL-unescaping strings (like turning &quot;this &amp;\nthat&quot; to and from &quot;this%20%26%20that&quot;).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>HTML::Entities -- functions for HTML-escaping and\nHTML-unescaping strings (like turning &quot;C. &amp; E.\nBront&Atilde;&laquo;&quot; to and from &quot;C. &amp;amp; E.\nBront&amp;euml;&quot;)</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>HTML::TokeParser and HTML::TreeBuilder -- classes for\nparsing <small>HTML</small></p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>HTML::LinkExtor -- class for finding links in\n<small>HTML</small> documents</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>The book <i>Perl &amp; <small>LWP</small></i> by Sean M.\nBurke. O&rsquo;Reilly &amp; Associates, 2002. <small>ISBN:\n0-596-00178-9,</small>\n&lt;http://oreilly.com/catalog/perllwp/&gt;. The whole book\nis also available free online:\n&lt;http://lwp.interglacial.com&gt;.</p> </td></tr>\n</table>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright 2002,\nSean M. Burke. You can redistribute this document and/or\nmodify it, but only under the same terms as Perl itself.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sean M. Burke\n&quot;sburke@cpan.org&quot;</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>","<a href=\"#AUTHOR\">AUTHOR</a>"],"level":3}