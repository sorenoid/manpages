{"name":"getaddrinfo_a","description":"getaddrinfo_a,\ngai_suspend, gai_error, gai_cancel - asynchronous network\naddress and service translation","body":"\n\n<h1 align=\"center\">GETADDRINFO_A</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">getaddrinfo_a,\ngai_suspend, gai_error, gai_cancel - asynchronous network\naddress and service translation</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;netdb.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ngetaddrinfo_a(int</b> <i>mode</i><b>, struct gaicb\n*</b><i>list[]</i><b>, <br>\nint</b> <i>nitems</i><b>, struct sigevent\n*</b><i>sevp</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ngai_suspend(const struct gaicb * const</b> <i>list[]</i><b>,\nint</b> <i>nitems</i><b>, <br>\nconst struct timespec *</b><i>timeout</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ngai_error(struct gaicb *</b><i>req</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ngai_cancel(struct gaicb *</b><i>req</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Link with\n<i>-lanl</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>getaddrinfo_a</b>() function performs the same task as\n<a href=\"https://man.page/3/getaddrinfo\">getaddrinfo(3)</a>, but allows multiple name look-ups to\nbe performed asynchronously, with optional notification on\ncompletion of look-up operations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>mode</i>\nargument has one of the following values: <b><br>\nGAI_WAIT</b></p>\n\n<p style=\"margin-left:22%;\">Perform the look-ups\nsynchronously. The call blocks until the look-ups have\ncompleted.</p>\n\n<p style=\"margin-left:11%;\"><b>GAI_NOWAIT</b></p>\n\n<p style=\"margin-left:22%;\">Perform the look-ups\nasynchronously. The call returns immediately, and the\nrequests are resolved in the background. See the discussion\nof the <i>sevp</i> argument below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The array\n<i>list</i> specifies the look-up requests to process. The\n<i>nitems</i> argument specifies the number of elements in\n<i>list</i>. The requested look-up operations are started in\nparallel. NULL elements in <i>list</i> are ignored. Each\nrequest is described by a <i>gaicb</i> structure, defined as\nfollows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct gaicb {\n<br>\nconst char *ar_name; <br>\nconst char *ar_service; <br>\nconst struct addrinfo *ar_request; <br>\nstruct addrinfo *ar_result; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The elements of\nthis structure correspond to the arguments of\n<a href=\"https://man.page/3/getaddrinfo\">getaddrinfo(3)</a>. Thus, <i>ar_name</i> corresponds to\nthe <i>node</i> argument and <i>ar_service</i> to the\n<i>service</i> argument, identifying an Internet host and a\nservice. The <i>ar_request</i> element corresponds to the\n<i>hints</i> argument, specifying the criteria for selecting\nthe returned socket address structures. Finally,\n<i>ar_result</i> corresponds to the <i>res</i> argument; you\ndo not need to initialize this element, it will be\nautomatically set when the request is resolved. The\n<i>addrinfo</i> structure referenced by the last two\nelements is described in <a href=\"https://man.page/3/getaddrinfo\">getaddrinfo(3)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<i>mode</i> is specified as <b>GAI_NOWAIT</b>, notifications\nabout resolved requests can be obtained by employing the\n<i>sigevent</i> structure pointed to by the <i>sevp</i>\nargument. For the definition and general details of this\nstructure, see <a href=\"https://man.page/7/sigevent\">sigevent(7)</a>. The\n<i>sevp-&gt;sigev_notify</i> field can have the following\nvalues: <b><br>\nSIGEV_NONE</b></p>\n\n<p style=\"margin-left:22%;\">Don&rsquo;t provide any\nnotification.</p>\n\n<p style=\"margin-left:11%;\"><b>SIGEV_SIGNAL</b></p>\n\n<p style=\"margin-left:22%;\">When a look-up completes,\ngenerate the signal <i>sigev_signo</i> for the process. See\n<a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for general details. The <i>si_code</i>\nfield of the <i>siginfo_t</i> structure will be set to\n<b>SI_ASYNCNL</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>SIGEV_THREAD</b></p>\n\n<p style=\"margin-left:22%;\">When a look-up completes,\ninvoke <i>sigev_notify_function</i> as if it were the start\nfunction of a new thread. See <a href=\"https://man.page/7/sigevent\">sigevent(7)</a> for\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\n<b>SIGEV_SIGNAL</b> and <b>SIGEV_THREAD</b>, it may be\nuseful to point <i>sevp-&gt;sigev_value.sival_ptr</i> to\n<i>list</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>gai_suspend</b>() function suspends execution of the\ncalling thread, waiting for the completion of one or more\nrequests in the array <i>list</i>. The <i>nitems</i>\nargument specifies the size of the array <i>list</i>. The\ncall blocks until one of the following occurs:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>One or more of the operations in <i>list</i>\ncompletes.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The call is interrupted by a signal that is caught.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>The time interval specified in <i>timeout</i> elapses.\nThis argument specifies a timeout in seconds plus\nnanoseconds (see <a href=\"https://man.page/2/nanosleep\">nanosleep(2)</a> for details of the\n<i>timespec</i> structure). If <i>timeout</i> is NULL, then\nthe call blocks indefinitely (until one of the events above\noccurs).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">No explicit\nindication of which request was completed is given; you must\ndetermine which request(s) have completed by iterating with\n<b>gai_error</b>() over the list of requests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>gai_error</b>() function returns the status of the\nrequest <i>req</i>: either <b>EAI_INPROGRESS</b> if the\nrequest was not completed yet, 0 if it was handled\nsuccessfully, or an error code if the request could not be\nresolved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>gai_cancel</b>() function cancels the request <i>req</i>.\nIf the request has been canceled successfully, the error\nstatus of the request will be set to <b>EAI_CANCELED</b> and\nnormal asynchronous notification will be performed. The\nrequest cannot be canceled if it is currently being\nprocessed; in that case, it will be handled as if\n<b>gai_cancel</b>() has never been called. If <i>req</i> is\nNULL, an attempt is made to cancel all outstanding requests\nthat the process has made.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>getaddrinfo_a</b>() function returns 0 if all of the\nrequests have been enqueued successfully, or one of the\nfollowing nonzero error codes: <b><br>\nEAI_AGAIN</b></p>\n\n<p style=\"margin-left:22%;\">The resources necessary to\nenqueue the look-up requests were not available. The\napplication may check the error status of each request to\ndetermine which ones failed.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_MEMORY</b></p>\n\n<p style=\"margin-left:22%;\">Out of memory.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_SYSTEM</b></p>\n\n<p style=\"margin-left:22%;\"><i>mode</i> is invalid.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>gai_suspend</b>() function returns 0 if at least one of\nthe listed requests has been completed. Otherwise, it\nreturns one of the following nonzero error codes: <b><br>\nEAI_AGAIN</b></p>\n\n<p style=\"margin-left:22%;\">The given timeout expired\nbefore any of the requests could be completed.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_ALLDONE</b></p>\n\n<p style=\"margin-left:22%;\">There were no actual requests\ngiven to the function.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_INTR</b></p>\n\n<p style=\"margin-left:22%;\">A signal has interrupted the\nfunction. Note that this interruption might have been caused\nby signal notification of some completed look-up\nrequest.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>gai_error</b>() function can return <b>EAI_INPROGRESS</b>\nfor an unfinished look-up request, 0 for a successfully\ncompleted look-up (as described above), one of the error\ncodes that could be returned by <a href=\"https://man.page/3/getaddrinfo\">getaddrinfo(3)</a>, or\nthe error code <b>EAI_CANCELED</b> if the request has been\ncanceled explicitly before it could be finished.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>gai_cancel</b>() function can return one of these values:\n<b><br>\nEAI_CANCELED</b></p>\n\n<p style=\"margin-left:22%;\">The request has been canceled\nsuccessfully.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_NOTCANCELED</b></p>\n\n<p style=\"margin-left:22%;\">The request has not been\ncanceled.</p>\n\n<p style=\"margin-left:11%;\"><b>EAI_ALLDONE</b></p>\n\n<p style=\"margin-left:22%;\">The request has already\ncompleted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<a href=\"https://man.page/3/gai_strerror\">gai_strerror(3)</a> function translates these error codes\nto a human readable string, suitable for error\nreporting.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3299581.png\" alt=\"Image grohtml-3299581.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nare GNU extensions; they first appeared in glibc in version\n2.2.3.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The interface\nof <b>getaddrinfo_a</b>() was modeled after the\n<a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a> interface.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Two examples\nare provided: a simple example that resolves several\nrequests in parallel synchronously, and a complex example\nshowing some of the asynchronous capabilities.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Synchronous\nexample</b> <br>\nThe program below simply resolves several hostnames in\nparallel, giving a speed-up compared to resolving the\nhostnames sequentially using <a href=\"https://man.page/3/getaddrinfo\">getaddrinfo(3)</a>. The\nprogram might be used like this:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out\nftp.us.kernel.org enoent.linuxfoundation.org gnu.cz</b> <br>\nftp.us.kernel.org: 128.30.2.36 <br>\nenoent.linuxfoundation.org: Name or service not known <br>\ngnu.cz: 87.236.197.13</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is the\nprogram source code</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\n_GNU_SOURCE <br>\n#include &lt;netdb.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint ret; <br>\nstruct gaicb *reqs[argc - 1]; <br>\nchar host[NI_MAXHOST]; <br>\nstruct addrinfo *res;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &lt;\n2) { <br>\nfprintf(stderr, &quot;Usage: %s HOST...\\n&quot;, argv[0]);\n<br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int i = 0;\ni &lt; argc - 1; i++) { <br>\nreqs[i] = malloc(sizeof(*reqs[0])); <br>\nif (reqs[i] == NULL) { <br>\nperror(&quot;malloc&quot;); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nmemset(reqs[i], 0, sizeof(*reqs[0])); <br>\nreqs[i]-&gt;ar_name = argv[i + 1]; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\ngetaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL); <br>\nif (ret != 0) { <br>\nfprintf(stderr, &quot;getaddrinfo_a() failed: %s\\n&quot;,\n<br>\ngai_strerror(ret)); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int i = 0;\ni &lt; argc - 1; i++) { <br>\nprintf(&quot;%s: &quot;, reqs[i]-&gt;ar_name); <br>\nret = gai_error(reqs[i]); <br>\nif (ret == 0) { <br>\nres = reqs[i]-&gt;ar_result;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\ngetnameinfo(res-&gt;ai_addr, res-&gt;ai_addrlen, <br>\nhost, sizeof(host), <br>\nNULL, 0, NI_NUMERICHOST); <br>\nif (ret != 0) { <br>\nfprintf(stderr, &quot;getnameinfo() failed: %s\\n&quot;, <br>\ngai_strerror(ret)); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nputs(host);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">} else { <br>\nputs(gai_strerror(ret)); <br>\n} <br>\n} <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Asynchronous\nexample</b> <br>\nThis example shows a simple interactive\n<b>getaddrinfo_a</b>() front-end. The notification facility\nis not demonstrated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An example\nsession might look like this:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./a.out</b> <br>\n&gt; a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n<br>\n&gt; c 2 <br>\n[2] gnu.cz: Request not canceled <br>\n&gt; w 0 1 <br>\n[00] ftp.us.kernel.org: Finished <br>\n&gt; l <br>\n[00] ftp.us.kernel.org: 216.165.129.139 <br>\n[01] enoent.linuxfoundation.org: Processing request in\nprogress <br>\n[02] gnu.cz: 87.236.197.13 <br>\n&gt; l <br>\n[00] ftp.us.kernel.org: 216.165.129.139 <br>\n[01] enoent.linuxfoundation.org: Name or service not known\n<br>\n[02] gnu.cz: 87.236.197.13</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nsource is as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\n_GNU_SOURCE <br>\n#include &lt;netdb.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;string.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static struct\ngaicb **reqs = NULL; <br>\nstatic int nreqs = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static char *\n<br>\ngetcmd(void) <br>\n{ <br>\nstatic char buf[256];</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fputs(&quot;&gt;\n&quot;, stdout); fflush(stdout); <br>\nif (fgets(buf, sizeof(buf), stdin) == NULL) <br>\nreturn NULL;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(buf[strlen(buf) - 1] == '\\n') <br>\nbuf[strlen(buf) - 1] = 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return buf;\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Add requests\nfor specified hostnames */ <br>\nstatic void <br>\nadd_requests(void) <br>\n{ <br>\nint nreqs_base = nreqs; <br>\nchar *host; <br>\nint ret;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while ((host =\nstrtok(NULL, &quot; &quot;))) { <br>\nnreqs++; <br>\nreqs = realloc(reqs, sizeof(reqs[0]) * nreqs);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">reqs[nreqs - 1]\n= calloc(1, sizeof(*reqs[0])); <br>\nreqs[nreqs - 1]-&gt;ar_name = strdup(host); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Queue\nnreqs_base..nreqs requests. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\ngetaddrinfo_a(GAI_NOWAIT, &amp;reqs[nreqs_base], <br>\nnreqs - nreqs_base, NULL); <br>\nif (ret) { <br>\nfprintf(stderr, &quot;getaddrinfo_a() failed: %s\\n&quot;,\n<br>\ngai_strerror(ret)); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Wait until\nat least one of specified requests completes */ <br>\nstatic void <br>\nwait_requests(void) <br>\n{ <br>\nchar *id; <br>\nint ret, n; <br>\nstruct gaicb const **wait_reqs = calloc(nreqs,\nsizeof(*wait_reqs)); <br>\n/* NULL elements are ignored by gai_suspend(). */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while ((id =\nstrtok(NULL, &quot; &quot;)) != NULL) { <br>\nn = atoi(id);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (n &gt;=\nnreqs) { <br>\nprintf(&quot;Bad request number: %s\\n&quot;, id); <br>\nreturn; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">wait_reqs[n] =\nreqs[n]; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\ngai_suspend(wait_reqs, nreqs, NULL); <br>\nif (ret) { <br>\nprintf(&quot;gai_suspend(): %s\\n&quot;, gai_strerror(ret));\n<br>\nreturn; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int i = 0;\ni &lt; nreqs; i++) { <br>\nif (wait_reqs[i] == NULL) <br>\ncontinue;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\ngai_error(reqs[i]); <br>\nif (ret == EAI_INPROGRESS) <br>\ncontinue;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;[%02d]\n%s: %s\\n&quot;, i, reqs[i]-&gt;ar_name, <br>\nret == 0 ? &quot;Finished&quot; : gai_strerror(ret)); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Cancel\nspecified requests */ <br>\nstatic void <br>\ncancel_requests(void) <br>\n{ <br>\nchar *id; <br>\nint ret, n;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while ((id =\nstrtok(NULL, &quot; &quot;)) != NULL) { <br>\nn = atoi(id);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (n &gt;=\nnreqs) { <br>\nprintf(&quot;Bad request number: %s\\n&quot;, id); <br>\nreturn; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\ngai_cancel(reqs[n]); <br>\nprintf(&quot;[%s] %s: %s\\n&quot;, id,\nreqs[atoi(id)]-&gt;ar_name, <br>\ngai_strerror(ret)); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* List all\nrequests */ <br>\nstatic void <br>\nlist_requests(void) <br>\n{ <br>\nint ret; <br>\nchar host[NI_MAXHOST]; <br>\nstruct addrinfo *res;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int i = 0;\ni &lt; nreqs; i++) { <br>\nprintf(&quot;[%02d] %s: &quot;, i, reqs[i]-&gt;ar_name);\n<br>\nret = gai_error(reqs[i]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (!ret) {\n<br>\nres = reqs[i]-&gt;ar_result;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">ret =\ngetnameinfo(res-&gt;ai_addr, res-&gt;ai_addrlen, <br>\nhost, sizeof(host), <br>\nNULL, 0, NI_NUMERICHOST); <br>\nif (ret) { <br>\nfprintf(stderr, &quot;getnameinfo() failed: %s\\n&quot;, <br>\ngai_strerror(ret)); <br>\nexit(EXIT_FAILURE); <br>\n} <br>\nputs(host); <br>\n} else { <br>\nputs(gai_strerror(ret)); <br>\n} <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nchar *cmdline; <br>\nchar *cmd;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while ((cmdline\n= getcmd()) != NULL) { <br>\ncmd = strtok(cmdline, &quot; &quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (cmd ==\nNULL) { <br>\nlist_requests(); <br>\n} else { <br>\nswitch (cmd[0]) { <br>\ncase 'a': <br>\nadd_requests(); <br>\nbreak; <br>\ncase 'w': <br>\nwait_requests(); <br>\nbreak; <br>\ncase 'c': <br>\ncancel_requests(); <br>\nbreak; <br>\ncase 'l': <br>\nlist_requests(); <br>\nbreak; <br>\ndefault: <br>\nfprintf(stderr, &quot;Bad command: %c\\n&quot;, cmd[0]); <br>\nbreak; <br>\n} <br>\n} <br>\n} <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/getaddrinfo\">getaddrinfo(3)</a>,\n<a href=\"https://man.page/3/inet\">inet(3)</a>, <a href=\"https://man.page/3/lio_listio\">lio_listio(3)</a>, <a href=\"https://man.page/7/hostname\">hostname(7)</a>,\n<a href=\"https://man.page/7/ip\">ip(7)</a>, <a href=\"https://man.page/7/sigevent\">sigevent(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}