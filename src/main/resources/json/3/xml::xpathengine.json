{"name":"xml::xpathengine","description":"XML::XPathEngine - a re-usable XPath engine for DOM-like trees","body":"\n\n<h1 align=\"center\">XML::XPathEngine</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::XPathEngine\n- a re-usable XPath engine for DOM-like trees</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\nprovides an XPath engine, that can be re-used by other\nmodule/classes that implement trees.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to use\nthe XPath engine, nodes in the user module need to mimic\n<small>DOM</small> nodes. The degree of similitude between\nthe user tree and a <small>DOM</small> dictates how much of\nthe XPath features can be used. A module implementing all of\nthe <small>DOM</small> should be able to use this module\nvery easily (you might need to add the cmp method on nodes\nin order to get ordered result sets).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This code is a\nmore or less direct copy of the XML::XPath module by Matt\nSergeant. I only removed the <small>XML</small> processing\npart to remove the dependency on XML::Parser, applied a\ncouple of patches, renamed a whole lot of methods to make\nPod::Coverage happy, and changed the docs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The article\neXtending <small>XML</small> XPath,\nhttp://www.xmltwig.com/article/extending_xml_xpath/ should\ngive authors who want to use this module enough background\nto do so.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Otherwise, my\nemail is below ;--)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>WARNING</small></b>\n: while the underlying code is rather solid, this module\nmostly lacks docs. As they say, &quot;patches\nwelcome&quot;...</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nXML::XPathEngine; <br>\nmy $tree= my_tree-&gt;new( ...); <br>\nmy $xp = XML::XPathEngine-&gt;new(); <br>\nmy @nodeset = $xp-&gt;find('/root/kid/grandkid[1]', $tree);\n# find all first grankids <br>\npackage XML::MyTree; <br>\n# needs to provide DOM methods</p>\n\n<h2>DETAILS\n<a name=\"DETAILS\"></a>\n</h2>\n\n\n<h2>API\n<a name=\"API\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::XPathEngine\nwill provide the following methods:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>new <br>\nfindnodes ($path, $context)</b> <br>\nReturns a list of nodes found by $path, optionally in\ncontext $context. In scalar context returns an\nXML::XPathEngine::NodeSet object.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>findnodes_as_string\n($path, $context)</b> <br>\nReturns the nodes found as a single string. The result is\nnot guaranteed to be valid <small>XML</small> though (it\ncould for example be just text if the query returns\nattribute values).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>findnodes_as_strings\n($path, $context)</b> <br>\nReturns the nodes found as a list of strings, one per node\nfound.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>findvalue\n($path, $context)</b> <br>\nReturns the result as a string (the concatenation of the\nvalues of the result nodes).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>findvalues($path,\n$context)</b> <br>\nReturns the values of the result nodes as a list of\nstrings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>exists\n($path, $context)</b> <br>\nReturns true if the given path exists.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>matches($node,\n$path, $context)</b> <br>\nReturns true if the node matches the path.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>find ($path,\n$context)</b> <br>\nThe find function takes an XPath expression (a string) and\nreturns either a XML::XPathEngine::NodeSet object containing\nthe nodes it found (or empty if no nodes matched the path),\nor one of XML::XPathEngine::Literal (a string),\nXML::XPathEngine::Number, or XML::XPathEngine::Boolean. It\nshould always return something - and you can use\n-&gt;<i>isa()</i> to find out what it returned. If you need\nto check how many nodes it found you should check\n$nodeset-&gt;size. See XML::XPathEngine::NodeSet.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>getNodeText\n($path)</b> <br>\nReturns the text string for a particular node. Returns a\nstring, or undef if the node doesn&rsquo;t exist.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>set_namespace\n($prefix, $uri)</b> <br>\nSets the namespace prefix mapping to the uri.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Normally in\nXML::XPathEngine the prefixes in XPath node tests take their\ncontext from the current node. This means that foo:bar will\nalways match an element &lt;foo:bar&gt; regardless of the\nnamespace that the prefix foo is mapped to (which might even\nchange within the document, resulting in unexpected\nresults). In order to make prefixes in XPath node tests\nactually map to a real <small>URI,</small> you need to\nenable that via a call to the set_namespace method of your\nXML::XPathEngine object.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clear_namespaces\n()</b> <br>\nClears all previously set namespace mappings.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>get_namespace\n($prefix, $node)</b> <br>\nReturns the uri associated to the prefix for the node\n(mostly for internal usage)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>set_strict_namespaces\n($strict)</b> <br>\nBy default, for historical as well as convenience reasons,\nXML::XPathEngine has a slightly non-standard way of dealing\nwith the default namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you search\nfor &quot;//tag&quot; it will return elements\n&quot;tag&quot;. As far as I understand it, if the document\nhas a default namespace, this should not return anything.\nYou would have to first do a &quot;set_namespace&quot;, and\nthen search using the namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Passing a true\nvalue to &quot;set_strict_namespaces&quot; will activate\nthis behaviour, passing a false value will return it to its\ndefault behaviour.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>set_var\n($var. $val)</b> <br>\nSets an XPath variable (that can be used in queries as\n$var)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>get_var\n($var)</b> <br>\nReturns the value of the XPath variable (mostly for internal\nusage)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>$XML::XPathEngine::Namespaces</b>\n<br>\nSet this to 0 if you <i>don&rsquo;t</i> want namespace\nprocessing to occur. This will make everything a little\n(tiny) bit faster, but you&rsquo;ll suffer for it,\nprobably.</p>\n\n<h2>Node Object Model\n<a name=\"Node Object Model\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Nodes need to\nprovide the same <small>API</small> as nodes in XML::XPath\n(at least the access <small>API,</small> not the tree\nmanipulation one).</p>\n\n<h2>Example\n<a name=\"Example\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Please see the\ntest files in t/ for examples on how to use XPath.</p>\n\n<h2>XPath extension\n<a name=\"XPath extension\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The module\nsupports the XPath recommendation to the same extend as\nXML::XPath (that is, rather completely).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It includes a\nperl-specific extension: direct support for regular\nexpressions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can use the\nusual (in Perl!) &quot;=~&quot; and &quot;!~&quot;\noperators. Regular expressions are / delimited (no other\ndelimiter is accepted, \\ inside regexp must be backslashed),\nthe &quot;imsx&quot; modifiers can be used.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$xp-&gt;findnodes(\n'//@att[.=~ /^v.$/]'); # returns the list of attributes att\n<br>\n# whose value matches ^v.$</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::XPath</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTML::TreeBuilder::XPath,\nXML::Twig::XPath for examples of using this module</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Tree::XPathEngine\nfor a similar module for non-XML trees.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;http://www.xmltwig.com/article/extending_xml_xpath/&gt;\nfor background information. The last section of the article\nsummarizes how to reuse XML::XPath. As XML::XPathEngine\noffers the same <small>API</small> it should help you</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Michel\nRodriguez, &quot;&lt;mirod@cpan.org&gt;&quot; Most code\ncomes directly from XML::XPath, by Matt Sergeant.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Please report\nany bugs or feature requests to\n&quot;bug-tree-xpathengine@rt.cpan.org&quot;, or through the\nweb interface at\n&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=XML-XPathEngine&gt;.\nI will be notified, and then you&rsquo;ll automatically be\nnotified of progress on your bug as I make changes.</p>\n\n<h2>ACKNOWLEDGEMENTS\n<a name=\"ACKNOWLEDGEMENTS\"></a>\n</h2>\n\n\n<h2>COPYRIGHT &amp; LICENSE\n<a name=\"COPYRIGHT &amp; LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::XPath\nCopyright 2000 AxKit.com Ltd. Copyright 2006 Michel\nRodriguez, All Rights Reserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This program is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DETAILS\">DETAILS</a>","<a href=\"#API\">API</a>","<a href=\"#Node Object Model\">Node Object Model</a>","<a href=\"#Example\">Example</a>","<a href=\"#XPath extension\">XPath extension</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#ACKNOWLEDGEMENTS\">ACKNOWLEDGEMENTS</a>","<a href=\"#COPYRIGHT &amp; LICENSE\">COPYRIGHT &amp; LICENSE</a>"],"level":3}