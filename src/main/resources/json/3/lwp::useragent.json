{"name":"lwp::useragent","description":"LWP::UserAgent - Web user agent class","body":"\n\n<h1 align=\"center\">LWP::UserAgent</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">LWP::UserAgent\n- Web user agent class</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use strict;\n<br>\nuse warnings; <br>\nuse LWP::UserAgent (); <br>\nmy $ua = LWP::UserAgent-&gt;new(timeout =&gt; 10); <br>\n$ua-&gt;env_proxy; <br>\nmy $response = $ua-&gt;get('http://example.com'); <br>\nif ($response-&gt;is_success) { <br>\nprint $response-&gt;decoded_content; <br>\n} <br>\nelse { <br>\ndie $response-&gt;status_line; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Extra layers of\nsecurity (note the &quot;cookie_jar&quot; and\n&quot;protocols_allowed&quot;):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use strict;\n<br>\nuse warnings; <br>\nuse HTTP::CookieJar::LWP (); <br>\nuse LWP::UserAgent (); <br>\nmy $jar = HTTP::CookieJar::LWP-&gt;new; <br>\nmy $ua = LWP::UserAgent-&gt;new( <br>\ncookie_jar =&gt; $jar, <br>\nprotocols_allowed =&gt; ['http', 'https'], <br>\ntimeout =&gt; 10, <br>\n); <br>\n$ua-&gt;env_proxy; <br>\nmy $response = $ua-&gt;get('http://example.com'); <br>\nif ($response-&gt;is_success) { <br>\nprint $response-&gt;decoded_content; <br>\n} <br>\nelse { <br>\ndie $response-&gt;status_line; <br>\n}</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nLWP::UserAgent is a class implementing a web user agent.\nLWP::UserAgent objects can be used to dispatch web\nrequests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In normal use\nthe application creates an LWP::UserAgent object, and then\nconfigures it with values for timeouts, proxies, name, etc.\nIt then creates an instance of HTTP::Request for the request\nthat needs to be performed. This request is then passed to\none of the request method the UserAgent, which dispatches it\nusing the relevant protocol, and returns a HTTP::Response\nobject. There are convenience methods for sending the most\ncommon request types: &quot;get&quot; in LWP::UserAgent,\n&quot;head&quot; in LWP::UserAgent, &quot;post&quot; in\nLWP::UserAgent, &quot;put&quot; in LWP::UserAgent and\n&quot;delete&quot; in LWP::UserAgent. When using these\nmethods, the creation of the request object is hidden as\nshown in the synopsis above.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The basic\napproach of the library is to use HTTP-style communication\nfor all protocol schemes. This means that you will construct\nHTTP::Request objects and receive HTTP::Response objects\neven for non-HTTP resources like <i>gopher</i> and\n<i>ftp</i>. In order to achieve even more similarity to\nHTTP-style communications, <i>gopher</i> menus and file\ndirectories are converted to <small>HTML</small>\ndocuments.</p>\n\n<h2>CONSTRUCTOR METHODS\n<a name=\"CONSTRUCTOR METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nconstructor methods are available:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clone</b>\n<br>\nmy $ua2 = $ua-&gt;clone;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns a copy\nof the LWP::UserAgent object.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>CAVEAT</small></b>\n: Please be aware that the clone method does not copy or\nclone your &quot;cookie_jar&quot; attribute. Due to the\nlimited restrictions on what can be used for your cookie\njar, there is no way to clone the attribute. The\n&quot;cookie_jar&quot; attribute will be &quot;undef&quot;\nin the new object instance.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>new</b> <br>\nmy $ua = LWP::UserAgent-&gt;new( %options )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nconstructs a new LWP::UserAgent object and returns it.\nKey/value pair arguments may be provided to set up the\ninitial state. The following options correspond to attribute\nmethods described below:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">KEY DEFAULT\n<br>\n----------- -------------------- <br>\nagent &quot;libwww-perl/#.###&quot; <br>\nconn_cache undef <br>\ncookie_jar undef <br>\ndefault_headers HTTP::Headers-&gt;new <br>\nfrom undef <br>\nlocal_address undef <br>\nmax_redirect 7 <br>\nmax_size undef <br>\nno_proxy [] <br>\nparse_head 1 <br>\nprotocols_allowed undef <br>\nprotocols_forbidden undef <br>\nproxy undef <br>\nrequests_redirectable ['GET', 'HEAD'] <br>\nssl_opts { verify_hostname =&gt; 1 } <br>\ntimeout 180</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nadditional options are also accepted: If the\n&quot;env_proxy&quot; option is passed in with a true value,\nthen proxy settings are read from environment variables (see\n&quot;env_proxy&quot; in LWP::UserAgent). If\n&quot;env_proxy&quot; isn&rsquo;t provided, the\n&quot;PERL_LWP_ENV_PROXY&quot; environment variable controls\nif &quot;env_proxy&quot; in LWP::UserAgent is called during\ninitialization. If the &quot;keep_alive&quot; option value\nis defined and non-zero, then an &quot;LWP::ConnCache&quot;\nis set up (see &quot;conn_cache&quot; in LWP::UserAgent).\nThe &quot;keep_alive&quot; value is passed on as the\n&quot;total_capacity&quot; for the connection cache.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;proxy&quot;\nmust be set as an arrayref of key/value pairs.\n&quot;no_proxy&quot; takes an arrayref of domains.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The settings of\nthe configuration attributes modify the behaviour of the\nLWP::UserAgent when it dispatches requests. Most of these\ncan also be initialized by options passed to the constructor\nmethod.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nattribute methods are provided. The attribute value is left\nunchanged if no argument is given. The return value from\neach method is the old attribute value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>agent</b>\n<br>\nmy $agent = $ua-&gt;agent; <br>\n$ua-&gt;agent('Checkbot/0.4 '); # append the default to the\nend <br>\n$ua-&gt;agent('Mozilla/5.0'); <br>\n$ua-&gt;agent(&quot;&quot;); # don't identify</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\nproduct token that is used to identify the user agent on the\nnetwork. The agent value is sent as the\n&quot;User-Agent&quot; header in the requests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default is\na string of the form &quot;libwww-perl/#.###&quot;, where\n&quot;#.###&quot; is substituted with the version number of\nthis library.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the provided\nstring ends with space, the default\n&quot;libwww-perl/#.###&quot; string is appended to it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The user agent\nstring should be one or more simple product identifiers with\nan optional version number separated by the &quot;/&quot;\ncharacter.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>conn_cache</b>\n<br>\nmy $cache_obj = $ua-&gt;conn_cache; <br>\n$ua-&gt;conn_cache( $cache_obj );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\nLWP::ConnCache object to use. See LWP::ConnCache for\ndetails.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>cookie_jar</b>\n<br>\nmy $jar = $ua-&gt;cookie_jar; <br>\n$ua-&gt;cookie_jar( $cookie_jar_obj );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\ncookie jar object to use. The only requirement is that the\ncookie jar object must implement the\n&quot;extract_cookies($response)&quot; and\n&quot;add_cookie_header($request)&quot; methods. These\nmethods will then be invoked by the user agent as requests\nare sent and responses are received. Normally this will be a\nHTTP::Cookies object or some subclass. You are, however,\nencouraged to use HTTP::CookieJar::LWP instead. See &quot;\n<small>BEST PRACTICES&quot;</small> for more\ninformation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTTP::CookieJar::LWP (); <br>\nmy $jar = HTTP::CookieJar::LWP-&gt;new; <br>\nmy $ua = LWP::UserAgent-&gt;new( cookie_jar =&gt; $jar );\n<br>\n# or after object creation <br>\n$ua-&gt;cookie_jar( $cookie_jar );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default is\nto have no cookie jar, i.e. never automatically add\n&quot;Cookie&quot; headers to the requests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Shortcut: If a\nreference to a plain hash is passed in, it is replaced with\nan instance of HTTP::Cookies that is initialized based on\nthe hash. This form also automatically loads the\nHTTP::Cookies module. It means that:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$ua-&gt;cookie_jar({\nfile =&gt; &quot;$ENV{HOME}/.cookies.txt&quot; });</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is really just\na shortcut for:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">require\nHTTP::Cookies; <br>\n$ua-&gt;cookie_jar(HTTP::Cookies-&gt;new(file =&gt;\n&quot;$ENV{HOME}/.cookies.txt&quot;));</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>credentials</b>\n<br>\nmy $creds = $ua-&gt;credentials(); <br>\n$ua-&gt;credentials( $netloc, $realm ); <br>\n$ua-&gt;credentials( $netloc, $realm, $uname, $pass ); <br>\n$ua-&gt;credentials(&quot;www.example.com:80&quot;,\n&quot;Some Realm&quot;, &quot;foo&quot;,\n&quot;secret&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\nuser name and password to be used for a realm.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The $netloc is\na string of the form &quot;&lt;host&gt;:&lt;port&gt;&quot;.\nThe username and password will only be passed to this\nserver.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>default_header</b>\n<br>\n$ua-&gt;default_header( $field ); <br>\n$ua-&gt;default_header( $field =&gt; $value ); <br>\n$ua-&gt;default_header('Accept-Encoding' =&gt; scalar\nHTTP::Message::decodable()); <br>\n$ua-&gt;default_header('Accept-Language' =&gt; &quot;no,\nen&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is just a\nshortcut for &quot;$ua-&gt;default_headers-&gt;header(\n$field =&gt; $value )&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>default_headers</b>\n<br>\nmy $headers = $ua-&gt;default_headers; <br>\n$ua-&gt;default_headers( $headers_obj );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\nheaders object that will provide default header values for\nany requests sent. By default this will be an empty\nHTTP::Headers object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>from</b>\n<br>\nmy $from = $ua-&gt;from; <br>\n$ua-&gt;from('foo@bar.com');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\nemail address for the human user who controls the requesting\nuser agent. The address should be machine-usable, as defined\nin <small>RFC2822</small>\n&lt;https://tools.ietf.org/html/rfc2822&gt;. The\n&quot;from&quot; value is sent as the &quot;From&quot;\nheader in the requests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default is\nto not send a &quot;From&quot; header. See\n&quot;default_headers&quot; in LWP::UserAgent for the more\ngeneral interface that allow any header to be defaulted.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>local_address</b>\n<br>\nmy $address = $ua-&gt;local_address; <br>\n$ua-&gt;local_address( $address );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\nlocal interface to bind to for network connections. The\ninterface can be specified as a hostname or an\n<small>IP</small> address. This value is passed as the\n&quot;LocalAddr&quot; argument to IO::Socket::INET.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>max_redirect</b>\n<br>\nmy $max = $ua-&gt;max_redirect; <br>\n$ua-&gt;max_redirect( $n );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This reads or\nsets the object&rsquo;s limit of how many times it will obey\nredirection responses in a given request cycle.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default, the\nvalue is 7. This means that if you call &quot;request&quot;\nin LWP::UserAgent and the response is a redirect elsewhere\nwhich is in turn a redirect, and so on seven times, then\n<small>LWP</small> gives up after that seventh request.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>max_size</b>\n<br>\nmy $size = $ua-&gt;max_size; <br>\n$ua-&gt;max_size( $bytes );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\nsize limit for response content. The default is\n&quot;undef&quot;, which means that there is no limit. If\nthe returned response content is only partial, because the\nsize limit was exceeded, then a &quot;Client-Aborted&quot;\nheader will be added to the response. The content might end\nup longer than &quot;max_size&quot; as we abort once\nappending a chunk of data makes the length exceed the limit.\nThe &quot;Content-Length&quot; header, if present, will\nindicate the length of the full content and will normally\nnot be the same as &quot;length($res-&gt;content)&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>parse_head</b>\n<br>\nmy $bool = $ua-&gt;parse_head; <br>\n$ua-&gt;parse_head( $boolean );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set a value\nindicating whether we should initialize response headers\nfrom the &lt;head&gt; section of <small>HTML</small>\ndocuments. The default is true. <i>Do not turn this off</i>\nunless you know what you are doing.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>protocols_allowed</b>\n<br>\nmy $aref = $ua-&gt;protocols_allowed; # get allowed\nprotocols <br>\n$ua-&gt;protocols_allowed( \\@protocols ); # allow ONLY these\n<br>\n$ua-&gt;protocols_allowed(undef); # delete the list <br>\n$ua-&gt;protocols_allowed(['http',]); # ONLY allow http</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default, an\nobject has neither a &quot;protocols_allowed&quot; list, nor\na &quot;protocols_forbidden&quot; in LWP::UserAgent\nlist.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This reads (or\nsets) this user agent&rsquo;s list of protocols that the\nrequest methods will exclusively allow. The protocol names\nare case insensitive.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example:\n&quot;$ua-&gt;protocols_allowed( [ 'http', 'https'] );&quot;\nmeans that this user agent will <i>allow only</i> those\nprotocols, and attempts to use this user agent to access\nURLs with any other schemes (like &quot;ftp://...&quot;)\nwill result in a 500 error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\nhaving a &quot;protocols_allowed&quot; list causes any\n&quot;protocols_forbidden&quot; in LWP::UserAgent list to be\nignored.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>protocols_forbidden</b>\n<br>\nmy $aref = $ua-&gt;protocols_forbidden; # get the forbidden\nlist <br>\n$ua-&gt;protocols_forbidden(\\@protocols); # do not allow\nthese <br>\n$ua-&gt;protocols_forbidden(['http',]); # All http reqs get\na 500 <br>\n$ua-&gt;protocols_forbidden(undef); # delete the list</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This reads (or\nsets) this user agent&rsquo;s list of protocols that the\nrequest method will <i>not</i> allow. The protocol names are\ncase insensitive.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example:\n&quot;$ua-&gt;protocols_forbidden( [ 'file', 'mailto']\n);&quot; means that this user agent will <i>not</i> allow\nthose protocols, and attempts to use this user agent to\naccess URLs with those schemes will result in a 500\nerror.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>requests_redirectable</b>\n<br>\nmy $aref = $ua-&gt;requests_redirectable; <br>\n$ua-&gt;requests_redirectable( \\@requests ); <br>\n$ua-&gt;requests_redirectable(['GET', 'HEAD',]); # the\ndefault</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This reads or\nsets the object&rsquo;s list of request names that\n&quot;redirect_ok&quot; in LWP::UserAgent will allow\nredirection for. By default, this is &quot;['GET',\n'HEAD']&quot;, as per <small>RFC 2616</small>\n&lt;https://tools.ietf.org/html/rfc2616&gt;. To change to\ninclude &quot;POST&quot;, consider:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">push @{\n$ua-&gt;requests_redirectable }, 'POST';</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>send_te</b>\n<br>\nmy $bool = $ua-&gt;send_te; <br>\n$ua-&gt;send_te( $boolean );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If true, will\nsend a &quot;TE&quot; header along with the request. The\ndefault is true. Set it to false to disable the\n&quot;TE&quot; header for systems who can&rsquo;t handle\nit.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>show_progress</b>\n<br>\nmy $bool = $ua-&gt;show_progress; <br>\n$ua-&gt;show_progress( $boolean );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set a value\nindicating whether a progress bar should be displayed on the\nterminal as requests are processed. The default is\nfalse.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ssl_opts</b>\n<br>\nmy @keys = $ua-&gt;ssl_opts; <br>\nmy $val = $ua-&gt;ssl_opts( $key ); <br>\n$ua-&gt;ssl_opts( $key =&gt; $value );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\noptions for <small>SSL</small> connections. Without argument\nreturn the list of options keys currently set. With a single\nargument return the current value for the given option. With\n2 arguments set the option value and return the old. Setting\nan option to the value &quot;undef&quot; removes this\noption.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The options\nthat <small>LWP</small> relates to are: <br>\n&quot;verify_hostname&quot; =&gt; $bool</p>\n\n<p style=\"margin-left:17%;\">When <small>TRUE LWP</small>\nwill for secure protocol schemes ensure it connects to\nservers that have a valid certificate matching the expected\nhostname. If <small>FALSE</small> no checks are made and you\ncan&rsquo;t be sure that you communicate with the expected\npeer. The no checks behaviour was the default for\nlibwww-perl-5.837 and earlier releases.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This option is\ninitialized from the\n&quot;PERL_LWP_SSL_VERIFY_HOSTNAME&quot; environment\nvariable. If this environment variable isn&rsquo;t set; then\n&quot;verify_hostname&quot; defaults to 1.</p>\n\n<p style=\"margin-left:11%;\">&quot;SSL_ca_file&quot; =&gt;\n$path</p>\n\n<p style=\"margin-left:17%;\">The path to a file containing\nCertificate Authority certificates. A default setting for\nthis option is provided by checking the environment\nvariables &quot;PERL_LWP_SSL_CA_FILE&quot; and\n&quot;HTTPS_CA_FILE&quot; in order.</p>\n\n<p style=\"margin-left:11%;\">&quot;SSL_ca_path&quot; =&gt;\n$path</p>\n\n<p style=\"margin-left:17%;\">The path to a directory\ncontaining files containing Certificate Authority\ncertificates. A default setting for this option is provided\nby checking the environment variables\n&quot;PERL_LWP_SSL_CA_PATH&quot; and\n&quot;HTTPS_CA_DIR&quot; in order.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other options\ncan be set and are processed directly by the\n<small>SSL</small> Socket implementation in use. See\nIO::Socket::SSL or Net::SSL for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The libwww-perl\ncore no longer bundles protocol plugins for\n<small>SSL.</small> You will need to install\nLWP::Protocol::https separately to enable support for\nprocessing https-URLs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>timeout</b>\n<br>\nmy $secs = $ua-&gt;timeout; <br>\n$ua-&gt;timeout( $secs );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Get/set the\ntimeout value in seconds. The default value is 180 seconds,\ni.e. 3 minutes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The request is\naborted if no activity on the connection to the server is\nobserved for &quot;timeout&quot; seconds. This means that\nthe time it takes for the complete transaction and the\n&quot;request&quot; in LWP::UserAgent method to actually\nreturn might be longer.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a request\ntimes out, a response object is still returned. The response\nwill have a standard <small>HTTP</small> Status Code (500).\nThis response will have the &quot;Client-Warning&quot;\nheader set to the value of &quot;Internal response&quot;.\nSee the &quot;get&quot; in LWP::UserAgent method description\nbelow for further details.</p>\n\n<h2>PROXY ATTRIBUTES\n<a name=\"PROXY ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethods set up when requests should be passed via a proxy\nserver.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>env_proxy</b>\n<br>\n$ua-&gt;env_proxy;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Load proxy\nsettings from *_proxy environment variables. You might\nspecify proxies like this (sh-syntax):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">gopher_proxy=http://proxy.my.place/\n<br>\nwais_proxy=http://proxy.my.place/ <br>\nno_proxy=&quot;localhost,example.com&quot; <br>\nexport gopher_proxy wais_proxy no_proxy</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">csh or tcsh\nusers should use the &quot;setenv&quot; command to define\nthese environment variables.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On systems with\ncase insensitive environment variables there exists a name\nclash between the <small>CGI</small> environment variables\nand the &quot;HTTP_PROXY&quot; environment variable normally\npicked up by &quot;env_proxy&quot;. Because of this\n&quot;HTTP_PROXY&quot; is not honored for <small>CGI</small>\nscripts. The &quot;CGI_HTTP_PROXY&quot; environment variable\ncan be used instead.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>no_proxy</b>\n<br>\n$ua-&gt;no_proxy( @domains ); <br>\n$ua-&gt;no_proxy('localhost', 'example.com'); <br>\n$ua-&gt;no_proxy(); # clear the list</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Do not proxy\nrequests to the given domains. Calling &quot;no_proxy&quot;\nwithout any domains clears the list of domains.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>proxy</b>\n<br>\n$ua-&gt;proxy(\\@schemes, $proxy_url) <br>\n$ua-&gt;proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');\n<br>\n# For a single scheme: <br>\n$ua-&gt;proxy($scheme, $proxy_url) <br>\n$ua-&gt;proxy('gopher', 'http://proxy.sn.no:8001/'); <br>\n# To set multiple proxies at once: <br>\n$ua-&gt;proxy([ <br>\nftp =&gt; 'http://ftp.example.com:8001/', <br>\n[ 'http', 'https' ] =&gt; 'http://http.example.com:8001/',\n<br>\n]);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Set/retrieve\nproxy <small>URL</small> for a scheme.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first form\nspecifies that the <small>URL</small> is to be used as a\nproxy for access methods listed in the list in the first\nmethod argument, i.e. &quot;http&quot; and\n&quot;ftp&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second form\nshows a shorthand form for specifying proxy\n<small>URL</small> for a single access scheme.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The third form\ndemonstrates setting multiple proxies at once. This is also\nthe only form accepted by the constructor.</p>\n\n<h2>HANDLERS\n<a name=\"HANDLERS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Handlers are\ncode that injected at various phases during the processing\nof requests. The following methods are provided to manage\nthe active handlers:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>add_handler</b>\n<br>\n$ua-&gt;add_handler( $phase =&gt; \\&amp;cb, %matchspec )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Add handler to\nbe invoked in the given processing phase. For how to specify\n%matchspec see &quot;Matching&quot; in HTTP::Config.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The possible\nvalues $phase and the corresponding callback signatures are\nas follows. Note that the handlers are documented in the\norder in which they will be run, which is:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">request_preprepare\n<br>\nrequest_prepare <br>\nrequest_send <br>\nresponse_header <br>\nresponse_data <br>\nresponse_done <br>\nresponse_redirect <br>\nrequest_preprepare =&gt; sub { my($request, $ua, $handler) =\n@_; ... }</p>\n\n<p style=\"margin-left:17%;\">The handler is called before\nthe &quot;request_prepare&quot; and other standard\ninitialization of the request. This can be used to set up\nheaders and attributes that the &quot;request_prepare&quot;\nhandler depends on. Proxy initialization should take place\nhere; but in general don&rsquo;t register handlers for this\nphase.</p>\n\n<p style=\"margin-left:11%;\">request_prepare =&gt; sub {\nmy($request, $ua, $handler) = @_; ... }</p>\n\n<p style=\"margin-left:17%;\">The handler is called before\nthe request is sent and can modify the request any way it\nsee fit. This can for instance be used to add certain\nheaders to specific requests.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The method can\nassign a new request object to $_[0] to replace the request\nthat is sent fully.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The return\nvalue from the callback is ignored. If an exception is\nraised it will abort the request and make the request method\nreturn a &quot;400 Bad request&quot; response.</p>\n\n<p style=\"margin-left:11%;\">request_send =&gt; sub {\nmy($request, $ua, $handler) = @_; ... }</p>\n\n<p style=\"margin-left:17%;\">This handler gets a chance of\nhandling requests before they&rsquo;re sent to the protocol\nhandlers. It should return an HTTP::Response object if it\nwishes to terminate the processing; otherwise it should\nreturn nothing.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;response_header&quot; and &quot;response_data&quot;\nhandlers will not be invoked for this response, but the\n&quot;response_done&quot; will be.</p>\n\n<p style=\"margin-left:11%;\">response_header =&gt; sub {\nmy($response, $ua, $handler) = @_; ... }</p>\n\n<p style=\"margin-left:17%;\">This handler is called right\nafter the response headers have been received, but before\nany content data. The handler might set up handlers for data\nand might croak to abort the request.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The handler\nmight set the\n&quot;$response-&gt;{default_add_content}&quot; value to\ncontrol if any received data should be added to the response\nobject directly. This will initially be false if the\n&quot;$ua-&gt;request()&quot; method was called with a\n$content_file or &quot;$content_cb argument&quot;; otherwise\ntrue.</p>\n\n<p style=\"margin-left:11%;\">response_data =&gt; sub {\nmy($response, $ua, $handler, $data) = @_; ... }</p>\n\n<p style=\"margin-left:17%;\">This handler is called for each\nchunk of data received for the response. The handler might\ncroak to abort the request.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This handler\nneeds to return a <small>TRUE</small> value to be called\nagain for subsequent chunks for the same request.</p>\n\n<p style=\"margin-left:11%;\">response_done =&gt; sub {\nmy($response, $ua, $handler) = @_; ... }</p>\n\n<p style=\"margin-left:17%;\">The handler is called after the\nresponse has been fully received, but before any redirect\nhandling is attempted. The handler can be used to extract\ninformation or modify the response.</p>\n\n<p style=\"margin-left:11%;\">response_redirect =&gt; sub {\nmy($response, $ua, $handler) = @_; ... }</p>\n\n<p style=\"margin-left:17%;\">The handler is called in\n&quot;$ua-&gt;request&quot; after &quot;response_done&quot;.\nIf the handler returns an HTTP::Request object we&rsquo;ll\nstart over with processing this request instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For all of\nthese, $handler is a code reference to the handler that is\ncurrently being run.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>get_my_handler</b>\n<br>\n$ua-&gt;get_my_handler( $phase, %matchspec ); <br>\n$ua-&gt;get_my_handler( $phase, %matchspec, $init );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Will retrieve\nthe matching handler as hash ref.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If $init is\npassed as a true value, create and add the handler if\nit&rsquo;s not found. If $init is a subroutine reference,\nthen it&rsquo;s called with the created handler hash as\nargument. This sub might populate the hash with extra\nfields; especially the callback. If $init is a hash\nreference, merge the hashes.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>handlers</b>\n<br>\n$ua-&gt;handlers( $phase, $request ) <br>\n$ua-&gt;handlers( $phase, $response )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Returns the\nhandlers that apply to the given request or response at the\ngiven processing phase.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>remove_handler</b>\n<br>\n$ua-&gt;remove_handler( undef, %matchspec ); <br>\n$ua-&gt;remove_handler( $phase, %matchspec ); <br>\n$ua-&gt;remove_handler(); # REMOVE ALL HANDLERS IN ALL\nPHASES</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Remove handlers\nthat match the given %matchspec. If $phase is not provided,\nremove handlers from all phases.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Be careful as\ncalling this function with %matchspec that is not specific\nenough can remove handlers not owned by you. It&rsquo;s\nprobably better to use the &quot;set_my_handler&quot; in\nLWP::UserAgent method instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The removed\nhandlers are returned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>set_my_handler</b>\n<br>\n$ua-&gt;set_my_handler( $phase, $cb, %matchspec ); <br>\n$ua-&gt;set_my_handler($phase, undef); # remove handler for\nphase</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Set handlers\nprivate to the executing subroutine. Works by defaulting an\n&quot;owner&quot; field to the %matchspec that holds the\nname of the called subroutine. You might pass an explicit\n&quot;owner&quot; to override this.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If $cb is\npassed as &quot;undef&quot;, remove the handler.</p>\n\n<h2>REQUEST METHODS\n<a name=\"REQUEST METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The methods\ndescribed in this section are used to dispatch requests via\nthe user agent. The following request methods are\nprovided:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>delete</b>\n<br>\nmy $res = $ua-&gt;delete( $url ); <br>\nmy $res = $ua-&gt;delete( $url, $field_name =&gt; $value,\n... );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill dispatch a &quot;DELETE&quot; request on the given\n<small>URL.</small> Additional headers and content options\nare the same as for the &quot;get&quot; in LWP::UserAgent\nmethod.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill use the &quot;DELETE()&quot; function from\nHTTP::Request::Common to build the request. See\nHTTP::Request::Common for a details on how to pass form\ncontent and other advanced features.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>get</b> <br>\nmy $res = $ua-&gt;get( $url ); <br>\nmy $res = $ua-&gt;get( $url , $field_name =&gt; $value, ...\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill dispatch a &quot;GET&quot; request on the given\n<small>URL.</small> Further arguments can be given to\ninitialize the headers of the request. These are given as\nseparate name/value pairs. The return value is a response\nobject. See HTTP::Response for a description of the\ninterface it provides.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There will\nstill be a response object returned when <small>LWP</small>\ncan&rsquo;t connect to the server specified in the\n<small>URL</small> or when other failures in protocol\nhandlers occur. These internal responses use the standard\n<small>HTTP</small> status codes, so the responses\ncan&rsquo;t be differentiated by testing the response status\ncode alone. Error responses that <small>LWP</small>\ngenerates internally will have the\n&quot;Client-Warning&quot; header set to the value\n&quot;Internal response&quot;. If you need to differentiate\nthese internal responses from responses that a remote server\nactually generates, you need to test this header value.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Fields names\nthat start with &quot;:&quot; are special. These will not\ninitialize headers of the request but will determine how the\nresponse content is treated. The following special field\nnames are recognized:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">':content_file'\n=&gt; $filename <br>\n':content_cb' =&gt; \\&amp;callback <br>\n':read_size_hint' =&gt; $bytes</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a $filename\nis provided with the &quot;:content_file&quot; option, then\nthe response content will be saved here instead of in the\nresponse object. If a callback is provided with the\n&quot;:content_cb&quot; option then this function will be\ncalled for each chunk of the response content as it is\nreceived from the server. If neither of these options are\ngiven, then the response content will accumulate in the\nresponse object itself. This might not be suitable for very\nlarge response bodies. Only one of &quot;:content_file&quot;\nor &quot;:content_cb&quot; can be specified. The content of\nunsuccessful responses will always accumulate in the\nresponse object itself, regardless of the\n&quot;:content_file&quot; or &quot;:content_cb&quot; options\npassed in. Note that errors writing to the content file (for\nexample due to permission denied or the filesystem being\nfull) will be reported via the &quot;Client-Aborted&quot; or\n&quot;X-Died&quot; response headers, and not the\n&quot;is_success&quot; method.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;:read_size_hint&quot; option is passed to the protocol\nmodule which will try to read data from the server in chunks\nof this size. A smaller value for the\n&quot;:read_size_hint&quot; will result in a higher number\nof callback invocations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The callback\nfunction is called with 3 arguments: a chunk of data, a\nreference to the response object, and a reference to the\nprotocol object. The callback can abort the request by\ninvoking &quot;die()&quot;. The exception message will show\nup as the &quot;X-Died&quot; header field in the response\nreturned by the &quot;$ua-&gt;get()&quot; method.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>head</b>\n<br>\nmy $res = $ua-&gt;head( $url ); <br>\nmy $res = $ua-&gt;head( $url , $field_name =&gt; $value, ...\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill dispatch a &quot;HEAD&quot; request on the given\n<small>URL.</small> Otherwise it works like the\n&quot;get&quot; in LWP::UserAgent method described\nabove.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>is_protocol_supported</b>\n<br>\nmy $bool = $ua-&gt;is_protocol_supported( $scheme );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can use\nthis method to test whether this user agent object supports\nthe specified &quot;scheme&quot;. (The &quot;scheme&quot;\nmight be a string (like &quot;http&quot; or &quot;ftp&quot;)\nor it might be an <small>URI</small> object reference.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Whether a\nscheme is supported is determined by the user agent&rsquo;s\n&quot;protocols_allowed&quot; or\n&quot;protocols_forbidden&quot; lists (if any), and by the\ncapabilities of <small>LWP.</small> I.e., this will return\ntrue only if <small>LWP</small> supports this protocol\n<i>and</i> it&rsquo;s permitted for this particular\nobject.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>is_online</b>\n<br>\nmy $bool = $ua-&gt;is_online;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Tries to\ndetermine if you have access to the Internet. Returns 1\n(true) if the built-in heuristics determine that the user\nagent is able to access the Internet (over\n<small>HTTP</small> ) or 0 (false).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See also\nLWP::Online.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>mirror</b>\n<br>\nmy $res = $ua-&gt;mirror( $url, $filename );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill get the document identified by <small>URL</small> and\nstore it in file called $filename. If the file already\nexists, then the request will contain an\n&quot;If-Modified-Since&quot; header matching the\nmodification time of the file. If the document on the server\nhas not changed since this time, then nothing happens. If\nthe document has been updated, it will be downloaded again.\nThe modification time of the file will be forced to match\nthat of the server.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Uses\n&quot;move&quot; in File::Copy to attempt to atomically\nreplace the $filename.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The return\nvalue is an HTTP::Response object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>patch</b>\n<br>\n# Any version of HTTP::Message works with this form: <br>\nmy $res = $ua-&gt;patch( $url, $field_name =&gt; $value,\nContent =&gt; $content ); <br>\n# Using hash or array references requires HTTP::Message\n&gt;= 6.12 <br>\nuse HTTP::Request 6.12; <br>\nmy $res = $ua-&gt;patch( $url, \\%form ); <br>\nmy $res = $ua-&gt;patch( $url, \\@form ); <br>\nmy $res = $ua-&gt;patch( $url, \\%form, $field_name =&gt;\n$value, ... ); <br>\nmy $res = $ua-&gt;patch( $url, $field_name =&gt; $value,\nContent =&gt; \\%form ); <br>\nmy $res = $ua-&gt;patch( $url, $field_name =&gt; $value,\nContent =&gt; \\@form );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill dispatch a &quot;PATCH&quot; request on the given\n<small>URL,</small> with %form or @form providing the\nkey/value pairs for the fill-in form content. Additional\nheaders and content options are the same as for the\n&quot;get&quot; in LWP::UserAgent method.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>CAVEAT:</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method can\nonly accept content that is in key-value pairs when using\nHTTP::Request::Common prior to version 6.12. Any use of hash\nor array references will result in an error prior to version\n6.12.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill use the &quot;PATCH&quot; function from\nHTTP::Request::Common to build the request. See\nHTTP::Request::Common for a details on how to pass form\ncontent and other advanced features.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>post</b>\n<br>\nmy $res = $ua-&gt;post( $url, \\%form ); <br>\nmy $res = $ua-&gt;post( $url, \\@form ); <br>\nmy $res = $ua-&gt;post( $url, \\%form, $field_name =&gt;\n$value, ... ); <br>\nmy $res = $ua-&gt;post( $url, $field_name =&gt; $value,\nContent =&gt; \\%form ); <br>\nmy $res = $ua-&gt;post( $url, $field_name =&gt; $value,\nContent =&gt; \\@form ); <br>\nmy $res = $ua-&gt;post( $url, $field_name =&gt; $value,\nContent =&gt; $content );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill dispatch a &quot;POST&quot; request on the given\n<small>URL,</small> with %form or @form providing the\nkey/value pairs for the fill-in form content. Additional\nheaders and content options are the same as for the\n&quot;get&quot; in LWP::UserAgent method.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill use the &quot;POST&quot; function from\nHTTP::Request::Common to build the request. See\nHTTP::Request::Common for a details on how to pass form\ncontent and other advanced features.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>put</b> <br>\n# Any version of HTTP::Message works with this form: <br>\nmy $res = $ua-&gt;put( $url, $field_name =&gt; $value,\nContent =&gt; $content ); <br>\n# Using hash or array references requires HTTP::Message\n&gt;= 6.07 <br>\nuse HTTP::Request 6.07; <br>\nmy $res = $ua-&gt;put( $url, \\%form ); <br>\nmy $res = $ua-&gt;put( $url, \\@form ); <br>\nmy $res = $ua-&gt;put( $url, \\%form, $field_name =&gt;\n$value, ... ); <br>\nmy $res = $ua-&gt;put( $url, $field_name =&gt; $value,\nContent =&gt; \\%form ); <br>\nmy $res = $ua-&gt;put( $url, $field_name =&gt; $value,\nContent =&gt; \\@form );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill dispatch a &quot;PUT&quot; request on the given\n<small>URL,</small> with %form or @form providing the\nkey/value pairs for the fill-in form content. Additional\nheaders and content options are the same as for the\n&quot;get&quot; in LWP::UserAgent method.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>CAVEAT:</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method can\nonly accept content that is in key-value pairs when using\nHTTP::Request::Common prior to version 6.07. Any use of hash\nor array references will result in an error prior to version\n6.07.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill use the &quot;PUT&quot; function from\nHTTP::Request::Common to build the request. See\nHTTP::Request::Common for a details on how to pass form\ncontent and other advanced features.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>request</b>\n<br>\nmy $res = $ua-&gt;request( $request ); <br>\nmy $res = $ua-&gt;request( $request, $content_file ); <br>\nmy $res = $ua-&gt;request( $request, $content_cb ); <br>\nmy $res = $ua-&gt;request( $request, $content_cb,\n$read_size_hint );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\nwill dispatch the given $request object. Normally this will\nbe an instance of the HTTP::Request class, but any object\nwith a similar interface will do. The return value is an\nHTTP::Response object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;request&quot; method will process redirects and\nauthentication responses transparently. This means that it\nmay actually send several simple requests via the\n&quot;simple_request&quot; in LWP::UserAgent method\ndescribed below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The request\nmethods described above; &quot;get&quot; in LWP::UserAgent,\n&quot;head&quot; in LWP::UserAgent, &quot;post&quot; in\nLWP::UserAgent and &quot;mirror&quot; in LWP::UserAgent will\nall dispatch the request they build via this method. They\nare convenience methods that simply hide the creation of the\nrequest object for you.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n$content_file, $content_cb and $read_size_hint all\ncorrespond to options described with the &quot;get&quot; in\nLWP::UserAgent method above. Note that errors writing to the\ncontent file (for example due to permission denied or the\nfilesystem being full) will be reported via the\n&quot;Client-Aborted&quot; or &quot;X-Died&quot; response\nheaders, and not the &quot;is_success&quot; method.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You are allowed\nto use a <small>CODE</small> reference as\n&quot;content&quot; in the request object passed in. The\n&quot;content&quot; function should return the content when\ncalled. The content can be returned in chunks. The content\nfunction will be invoked repeatedly until it return an empty\nstring to signal that there is no more content.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>simple_request</b>\n<br>\nmy $request = HTTP::Request-&gt;new( ... ); <br>\nmy $res = $ua-&gt;simple_request( $request ); <br>\nmy $res = $ua-&gt;simple_request( $request, $content_file );\n<br>\nmy $res = $ua-&gt;simple_request( $request, $content_cb );\n<br>\nmy $res = $ua-&gt;simple_request( $request, $content_cb,\n$read_size_hint );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method\ndispatches a single request and returns the response\nreceived. Arguments are the same as for the\n&quot;request&quot; in LWP::UserAgent described above.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The difference\nfrom &quot;request&quot; in LWP::UserAgent is that\n&quot;simple_request&quot; will not try to handle redirects\nor authentication responses. The &quot;request&quot; in\nLWP::UserAgent method will, in fact, invoke this method for\neach simple request it sends.</p>\n\n<h2>CALLBACK METHODS\n<a name=\"CALLBACK METHODS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmethods will be invoked as requests are processed. These\nmethods are documented here because subclasses of\nLWP::UserAgent might want to override their behaviour.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>get_basic_credentials</b>\n<br>\n# This checks wantarray and can either return an array: <br>\nmy ($user, $pass) = $ua-&gt;get_basic_credentials( $realm,\n$uri, $isproxy ); <br>\n# or a string that looks like &quot;user:pass&quot; <br>\nmy $creds = $ua-&gt;get_basic_credentials($realm, $uri,\n$isproxy);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is called\nby &quot;request&quot; in LWP::UserAgent to retrieve\ncredentials for documents protected by Basic or Digest\nAuthentication. The arguments passed in is the $realm\nprovided by the server, the $uri requested and a\n&quot;boolean flag&quot; to indicate if this is\nauthentication against a proxy server.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The method\nshould return a username and password. It should return an\nempty list to abort the authentication resolution attempt.\nSubclasses can override this method to prompt the user for\nthe information. An example of this can be found in\n&quot;lwp-request&quot; program distributed with this\nlibrary.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The base\nimplementation simply checks a set of pre-stored member\nvariables, set up with the &quot;credentials&quot; in\nLWP::UserAgent method.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>prepare_request</b>\n<br>\n$request = $ua-&gt;prepare_request( $request );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method is\ninvoked by &quot;simple_request&quot; in LWP::UserAgent. Its\ntask is to modify the given $request object by setting up\nvarious headers based on the attributes of the user agent.\nThe return value should normally be the $request object\npassed in. If a different request object is returned it will\nbe the one actually processed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The headers\naffected by the base implementation are;\n&quot;User-Agent&quot;, &quot;From&quot;, &quot;Range&quot;\nand &quot;Cookie&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>progress</b>\n<br>\nmy $prog = $ua-&gt;progress( $status, $request_or_response\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is called\nfrequently as the response is received regardless of how the\ncontent is processed. The method is called with $status\n&quot;begin&quot; at the start of processing the request and\nwith $state &quot;end&quot; before the request method\nreturns. In between these $status will be the fraction of\nthe response currently received or the string\n&quot;tick&quot; if the fraction can&rsquo;t be\ncalculated.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When $status is\n&quot;begin&quot; the second argument is the HTTP::Request\nobject, otherwise it is the HTTP::Response object.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>redirect_ok</b>\n<br>\nmy $bool = $ua-&gt;redirect_ok( $prospective_request,\n$response );</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This method is\ncalled by &quot;request&quot; in LWP::UserAgent before it\ntries to follow a redirection to the request in $response.\nThis should return a true value if this redirection is\npermissible. The $prospective_request will be the request to\nbe sent if this method returns true.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The base\nimplementation will return false unless the method is in the\nobject&rsquo;s &quot;requests_redirectable&quot; list, false\nif the proposed redirection is to a &quot;file://...&quot;\n<small>URL,</small> and true otherwise.</p>\n\n<h2>BEST PRACTICES\n<a name=\"BEST PRACTICES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\nsettings can get you up and running quickly, but there are\nsettings you can change in order to make your life\neasier.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Handling\nCookies</b> <br>\nYou are encouraged to install Mozilla::PublicSuffix and use\nHTTP::CookieJar::LWP as your cookie jar.\nHTTP::CookieJar::LWP provides a better security model\nmatching that of current Web browsers when\nMozilla::PublicSuffix is installed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nHTTP::CookieJar::LWP (); <br>\nmy $jar = HTTP::CookieJar::LWP-&gt;new; <br>\nmy $ua = LWP::UserAgent-&gt;new( cookie_jar =&gt; $jar\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n&quot;cookie_jar&quot; for more information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Managing\nProtocols</b> <br>\n&quot;protocols_allowed&quot; gives you the ability to allow\narbitrary protocols.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $ua =\nLWP::UserAgent-&gt;new( <br>\nprotocols_allowed =&gt; [ 'http', 'https' ] <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This will\nprevent you from inadvertently following URLs like\n&quot;file:///etc/passwd&quot;. See\n&quot;protocols_allowed&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;protocols_forbidden&quot;\ngives you the ability to deny arbitrary protocols.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $ua =\nLWP::UserAgent-&gt;new( <br>\nprotocols_forbidden =&gt; [ 'file', 'mailto', 'ssh', ] <br>\n);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This can also\nprevent you from inadvertently following URLs like\n&quot;file:///etc/passwd&quot;. See\n&quot;protocols_forbidden&quot;.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<small>LWP</small> for a complete overview of libwww-perl5.\nSee lwpcook and the scripts <i>lwp-request</i> and\n<i>lwp-download</i> for examples of usage.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\nHTTP::Request and HTTP::Response for a description of the\nmessage objects dispatched and received. See\nHTTP::Request::Common and HTML::Form for other ways to build\nrequest objects.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\nWWW::Mechanize and WWW::Search for examples of more\nspecialized user agents based on LWP::UserAgent.</p>\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright\n1995-2009 Gisle Aas.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CONSTRUCTOR METHODS\">CONSTRUCTOR METHODS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#PROXY ATTRIBUTES\">PROXY ATTRIBUTES</a>","<a href=\"#HANDLERS\">HANDLERS</a>","<a href=\"#REQUEST METHODS\">REQUEST METHODS</a>","<a href=\"#CALLBACK METHODS\">CALLBACK METHODS</a>","<a href=\"#BEST PRACTICES\">BEST PRACTICES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COPYRIGHT AND LICENSE\">COPYRIGHT AND LICENSE</a>"],"level":3}