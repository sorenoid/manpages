{"name":"net::dbus::tutorial::exportingobjects","description":"Net::DBus::Tutorial::ExportingObjects\n- tutorials on providing a DBus service\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nThis document\nprovides a tutorial on providing a DBus service using the\nPerl Net::DBus application bindings. This examples in this\ndocument will be based on the code from the Music::Player\ndistribution, which is a simple DBus service providing a\nmusic track player.\n\n<h2>CREATING AN OBJECT\n<a name=\"CREATING AN OBJECT\"></a>\n</h2>\n\n\nThe first step\nin creating an object is to create a new package which\ninherits from Net::DBus::Object. The Music::Player::Manager\nobject provides an <small>API</small> for managing the\ncollection of music player backends for different track\ntypes. To start with, lets create the skeleton of the\npackage &amp; its constructor. The constructor of the super\ntype, Net::DBus::Object expects to be given to parameters, a\nhandle to the Net::DBus::Service owning the object, and a\npath under which the object shall be exported. Since the\nmanager class is intended to be a singleton object, we can\nhard code the path to it within the constructor:\n\npackage\nMusic::Player::Manager; <br>\nuse base qw(Net::DBus::Object); <br>\nsub new { <br>\nmy $class = shift; <br>\nmy $service = shift; <br>\nmy $self = $class-&gt;SUPER::new($service,\n&quot;/music/player/manager&quot;); <br>\nbless $self, $class; <br>\nreturn $self; <br>\n} <br>\n1;\n\nNow, as\nmentioned, the manager with handle a number of different\nplayer backends. So we need to provide methods for\nregistering new backends, and querying for backends capable\nof playing a particular file type. So modifying the above\ncode we add a hash table in the constructor, to store the\nbackends:\n\nsub new { <br>\nmy $class = shift; <br>\nmy $service = shift; <br>\nmy $self = $class-&gt;SUPER::new($service,\n&quot;/music/player/manager&quot;); <br>\n$self-&gt;{backends} = {}; <br>\nbless $self, $class; <br>\nreturn $self; <br>\n}\n\nAnd now a\nmethod to register a new backend. This takes a Perl module\nname and uses it to instantiate a backend. Since the\nbackends are also going to be DBus objects, we need to pass\nin a reference to the service we are attached to, along with\na path under which to register the backend. We use the\n&quot;get_service&quot; method to retreieve a reference to\nthe service the manager is attached to, and attach the\nplayer backend to this same service: When a method on DBus\nobject is invoked, the first parameter is the object\nreference ($self), and the remainder are the parameters\nprovided to the method call. Thus writing a method\nimplementation on a DBUs is really no different to normal\nobject oriented Perl (cf perltoot):\n\nsub\nregister_backend { <br>\nmy $self = shift; <br>\nmy $name = shift; <br>\nmy $module = shift; <br>\neval &quot;use $module&quot;; <br>\nif ($@) { <br>\ndie &quot;cannot load backend $module: $@&quot; ; <br>\n} <br>\n$self-&gt;{backends}-&gt;{$name} =\n$module-&gt;new($self-&gt;get_service, <br>\n&quot;/music/player/backend/$name&quot;); <br>\n}\n\nLooking at this\none might wonder what happens if the &quot;die&quot; method\nis triggered. In such a scenario, rather than terminating\nthe service process, the error will be caught and propagated\nback to the remote caller to deal with.\n\nThe player\nbackends provide a method &quot;get_track_types&quot; which\nreturns an array reference of the music track types they\nsupport. We can use this method to provide an\n<small>API</small> to allow easy retrieval of a backend for\na particular track type. This method will return a path with\nwhich the backend object can be accessed\n\nsub\nfind_backend { <br>\nmy $self = shift; <br>\nmy $extension = shift; <br>\nforeach my $name (keys %{$self-&gt;{backends}}) { <br>\nmy $backend = $self-&gt;{backends}-&gt;{$name}; <br>\nforeach my $type (@{$backend-&gt;get_track_types}) { <br>\nif ($type eq $extension) { <br>\nreturn $backend-&gt;get_object_path; <br>\n} <br>\n} <br>\n} <br>\ndie &quot;no backend for type $extension&quot;; <br>\n}\n\nLets take a\nquick moment to consider how this method would be used to\nplay a music track. If you&rsquo;ve not already done so,\nrefresh your memory from Net::DBus::Tutorial::UsingObjects.\nNow, we have an <small>MP3</small> file which we wish to\nplay, so we search for the path to a backend, then retrieve\nthe object for it, and play the track:\n\n...get the\nmusic player service... <br>\n# Ask for a path to a player for mp3 files <br>\nmy $path = $service-&gt;find_backend(&quot;mp3&quot;); <br>\n# $path now contains '/music/player/backend/mpg123' <br>\n# and we can get the backend object <br>\nmy $backend = $service-&gt;get_object($path); <br>\n# and finally play the track <br>\n\n$backend-&gt;play(&quot;/vol/music/beck/guero/09-scarecrow.mp3&quot;);\n\n<h2>PROVIDING INTROSPECTION DATA\n<a name=\"PROVIDING INTROSPECTION DATA\"></a>\n</h2>\n\n\nThe code above\nis a complete working object, ready to be registered with a\nservice, and since the parameters and return values for the\ntwo methods are both simple strings we could stop there. In\nsome cases, however, one might want to be more specific\nabout data types expected for parameters, for example signed\nvs unsigned integers. Adding explicit data typing also makes\ninteraction with other programming languages more reliable.\nProviding explicit data type definitions for exported method\nis known in the DBus world as &quot;Introspection&quot;, and\nit makes life much more reliable for users of one&rsquo;s\nservice whom may be using a strongly typed language such as\nC.\n\nThe first step\nin providing introspection data for a DBus object in Perl,\nis to specify the name of the interface provided by the\nobject. This is typically a period separated string, by\nconvention containing the domain name of the application as\nits first component. Since most Perl modules end up living\non <small>CPAN,</small> one might use &quot;org.cpan&quot;\nas the first component, followed by the package name of the\nmodule (replacing :: with .), eg\n&quot;org.cpan.music.player.manager&quot;. If it is not\nplanned to host the module on <small>CPAN,</small> a\npersonal/project domain might be used eg\n&quot;com.berrange.music.player.manager&quot;. The interface\nfor an object is defined by loading the Net::DBus::Exporter\nmodule, providing the interface as its first parameter. So\nthe earlier code example would be modified to look like:\n\npackage\nMusic::Player::Manager; <br>\nuse base qw(Net::DBus); <br>\nuse Net::DBus::Exporter\nqw(com.berrange.music.player.manager)\n\nNext up, it is\nnecessary to provide data types for the parameters and\nreturn values of the methods. The Net::DBus::Exporter module\nprovides a method &quot;dbus_method&quot; for this purpose,\nwhich takes three parameter, the name of the method being\nexported, an array reference of parameter types, and an\narray reference of return types (the latter can be omitted\nif there are no return values). This can be called at any\npoint in the module&rsquo;s code, but by convention it is\npreferable to associate calls to &quot;dbus_method&quot;\nwith the actual method implementation, thus:\n\n\ndbus_method(&quot;register_backend&quot;,\n[&quot;string&quot;, &quot;string&quot;]); <br>\nsub register_backend { <br>\nmy $self = shift; <br>\nmy $name = shift; <br>\nmy $module = shift; <br>\n.. snipped rest of method body ... <br>\n}\n\nAnd, thus:\n\n\ndbus_method(&quot;find_backend&quot;,\n[&quot;string&quot;], [&quot;string&quot;]) <br>\nsub find_backend { <br>\nmy $self = shift; <br>\nmy $extension = shift; <br>\n... snip method body... <br>\n}\n\n<h2>DEFINING A SERVICE\n<a name=\"DEFINING A SERVICE\"></a>\n</h2>\n\n\nNow that the\nobjects have been written, it is time to define a service. A\nservice is nothing more than a well known name for a given\n<small>API</small> contract. A contract can be thought of as\na definition of a list of object paths, and the\ncorresponding interfaces they provide. So, someone else\ncould come along a provide an alternate music player\nimplementation using the Python or <small>QT</small>\nbindings for DBus, and if they provided the same set of\nobject paths &amp; interfaces, they could justifiably\nregister the same service on the bus.\n\nThe\nNet::DBus::Service module provides the means to register a\nservice. Its constructor expects a reference to the bus\nobject (an instance of Net::DBus), along with the name of\nthe service. As with interface names, the first component of\na service name is usually derived from a domain name, and\nthen suffixed with the name of the application, in our\nexample forming &quot;org.cpan.Music.Player&quot;. While\nsome objects will be created on the fly during execution of\nthe application, others are created upon initial startup.\nThe music player manager object created earlier in this\ntutorial is an example of the latter. It is typical to\ninstantiate and register these objects in the constructor\nfor the service. Thus a service object for the music player\napplication would look like:\n\npackage\nMusic::Player; <br>\nuse base qw(Net::DBus::Service); <br>\nsub new { <br>\nmy $class = shift; <br>\nmy $bus = shift; <br>\nmy $self = $class-&gt;SUPER::new($bus,\n&quot;org.cpan.music.player&quot;); <br>\nbless $self, $class; <br>\n$self-&gt;{manager} = Music::Player::Manager-&gt;new($self);\n<br>\nreturn $self; <br>\n}\n\nThe\nNet::DBus::Service automatically provides one special object\nto all services, under the path\n&quot;/org/freedesktop/DBus/Exporter&quot;. This object\nimplements the &quot;org.freedesktop.DBus.Exporter&quot;\ninterface which has a method &quot;ListObject&quot;. This\nenables clients to determine a list of all objects exported\nwithin a service. While not functionally necessary for most\napplications, it is none-the-less a useful tool for\ndevelopers debugging applications, or wondering what a\nservice provides.\n\n<h2>CONNECTING TO THE BUS\n<a name=\"CONNECTING TO THE BUS\"></a>\n</h2>\n\n\nThe final step\nin getting our service up and running is to connect it to\nthe bus. This brings up an interesting conundrum, does one\nexport the service on the system bus (shared by all users\n&amp; processes on the machine), or the session bus (one per\nuser logged into a machine). In some cases the answer, with\nonly one of the two buses conceptually making sense. In\nother cases, however, both the session &amp; system bus are\nvalid. In the former one would use the &quot;session&quot;\nor &lt;system&gt; methods on Net::DBus to get a handle to\nthe desired bus, while in the latter case, the\n&quot;find&quot; method would be used. This applies a\nheuristic to determine the correct bus based on execution\nenvironment. In the case of the music player, either bus is\nrelevant, so the code to connect the service to the bus\nwould look like:\n\nuse Net::DBus;\n<br>\nmy $bus = Net::DBus-&gt;find; <br>\nmy $player = Music::Player-&gt;new($bus);\n\nWith the\nservice attached to the bus, it is merely necessary to run\nthe main event processing loop to listen out for &amp;\nhandle incoming DBus messages. So the above code is modified\nto start a simple reactor:\n\nuse Net::DBus;\n<br>\nuse Net::DBus::Reactor; <br>\nmy $bus = Net::DBus-&gt;find; <br>\nmy $player = Music::Player-&gt;new($bus); <br>\nNet::DBus::Reactor-&gt;main-&gt;run; <br>\nexit 0;\n\nSaving this\ncode into a script &quot;/usr/bin/music-player.pl&quot;,\ncoding is complete and the service ready for use by clients\non the bus.\n\n<h2>SERVICE ACTIVATION\n<a name=\"SERVICE ACTIVATION\"></a>\n</h2>\n\n\nOne might now\nwonder how best to start the service, particularly if it is\na service capable of running on both the system and session\nbuses. DBus has the answer in the concept of\n&quot;activation&quot;. What happens is that when a client\non the bus attempts to call a method, or register a signal\nhandler against, a service not currently running, it will\nfirst try and start the service. Service&rsquo;s which wish\nto participate in this process merely need stick a simple\nservice definition file into the directory\n&quot;/usr/share/dbus-1/services&quot;. The file should be\nnamed to match the service name, with the file extension\n&quot;.service&quot; appended. eg,\n&quot;/usr/share/dbus-1/services/org.cpan.music.player.service&quot;\nThe file contains two keys, first the name of the service,\nand second the name of the executable used to run the\nservice, or in this case the Perl script. So, for our simple\nservice the data file would contain:\n\n[D-BUS Service]\n<br>\nName=org.cpan.music.player <br>\nExec=/usr/bin/music-player.pl\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\nNet::DBus::Tutorial\nfor details of other tutorials, and Net::DBus for\n<small>API</small> documentation\n\n<h2>AUTHORS\n<a name=\"AUTHORS\"></a>\n</h2>\n\n\nDaniel Berrange\n&lt;dan@berrange.com&gt;\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\nCopyright (C)\n2005 Daniel P. Berrange","body":"\n\n<h1 align=\"center\">Net::DBus::Tutorial::ExportingObjects</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus::Tutorial::ExportingObjects\n- tutorials on providing a DBus service</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This document\nprovides a tutorial on providing a DBus service using the\nPerl Net::DBus application bindings. This examples in this\ndocument will be based on the code from the Music::Player\ndistribution, which is a simple DBus service providing a\nmusic track player.</p>\n\n<h2>CREATING AN OBJECT\n<a name=\"CREATING AN OBJECT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first step\nin creating an object is to create a new package which\ninherits from Net::DBus::Object. The Music::Player::Manager\nobject provides an <small>API</small> for managing the\ncollection of music player backends for different track\ntypes. To start with, lets create the skeleton of the\npackage &amp; its constructor. The constructor of the super\ntype, Net::DBus::Object expects to be given to parameters, a\nhandle to the Net::DBus::Service owning the object, and a\npath under which the object shall be exported. Since the\nmanager class is intended to be a singleton object, we can\nhard code the path to it within the constructor:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">package\nMusic::Player::Manager; <br>\nuse base qw(Net::DBus::Object); <br>\nsub new { <br>\nmy $class = shift; <br>\nmy $service = shift; <br>\nmy $self = $class-&gt;SUPER::new($service,\n&quot;/music/player/manager&quot;); <br>\nbless $self, $class; <br>\nreturn $self; <br>\n} <br>\n1;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now, as\nmentioned, the manager with handle a number of different\nplayer backends. So we need to provide methods for\nregistering new backends, and querying for backends capable\nof playing a particular file type. So modifying the above\ncode we add a hash table in the constructor, to store the\nbackends:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub new { <br>\nmy $class = shift; <br>\nmy $service = shift; <br>\nmy $self = $class-&gt;SUPER::new($service,\n&quot;/music/player/manager&quot;); <br>\n$self-&gt;{backends} = {}; <br>\nbless $self, $class; <br>\nreturn $self; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And now a\nmethod to register a new backend. This takes a Perl module\nname and uses it to instantiate a backend. Since the\nbackends are also going to be DBus objects, we need to pass\nin a reference to the service we are attached to, along with\na path under which to register the backend. We use the\n&quot;get_service&quot; method to retreieve a reference to\nthe service the manager is attached to, and attach the\nplayer backend to this same service: When a method on DBus\nobject is invoked, the first parameter is the object\nreference ($self), and the remainder are the parameters\nprovided to the method call. Thus writing a method\nimplementation on a DBUs is really no different to normal\nobject oriented Perl (cf perltoot):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub\nregister_backend { <br>\nmy $self = shift; <br>\nmy $name = shift; <br>\nmy $module = shift; <br>\neval &quot;use $module&quot;; <br>\nif ($@) { <br>\ndie &quot;cannot load backend $module: $@&quot; ; <br>\n} <br>\n$self-&gt;{backends}-&gt;{$name} =\n$module-&gt;new($self-&gt;get_service, <br>\n&quot;/music/player/backend/$name&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Looking at this\none might wonder what happens if the &quot;die&quot; method\nis triggered. In such a scenario, rather than terminating\nthe service process, the error will be caught and propagated\nback to the remote caller to deal with.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The player\nbackends provide a method &quot;get_track_types&quot; which\nreturns an array reference of the music track types they\nsupport. We can use this method to provide an\n<small>API</small> to allow easy retrieval of a backend for\na particular track type. This method will return a path with\nwhich the backend object can be accessed</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sub\nfind_backend { <br>\nmy $self = shift; <br>\nmy $extension = shift; <br>\nforeach my $name (keys %{$self-&gt;{backends}}) { <br>\nmy $backend = $self-&gt;{backends}-&gt;{$name}; <br>\nforeach my $type (@{$backend-&gt;get_track_types}) { <br>\nif ($type eq $extension) { <br>\nreturn $backend-&gt;get_object_path; <br>\n} <br>\n} <br>\n} <br>\ndie &quot;no backend for type $extension&quot;; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Lets take a\nquick moment to consider how this method would be used to\nplay a music track. If you&rsquo;ve not already done so,\nrefresh your memory from Net::DBus::Tutorial::UsingObjects.\nNow, we have an <small>MP3</small> file which we wish to\nplay, so we search for the path to a backend, then retrieve\nthe object for it, and play the track:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...get the\nmusic player service... <br>\n# Ask for a path to a player for mp3 files <br>\nmy $path = $service-&gt;find_backend(&quot;mp3&quot;); <br>\n# $path now contains '/music/player/backend/mpg123' <br>\n# and we can get the backend object <br>\nmy $backend = $service-&gt;get_object($path); <br>\n# and finally play the track <br>\n\n$backend-&gt;play(&quot;/vol/music/beck/guero/09-scarecrow.mp3&quot;);</p>\n\n<h2>PROVIDING INTROSPECTION DATA\n<a name=\"PROVIDING INTROSPECTION DATA\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The code above\nis a complete working object, ready to be registered with a\nservice, and since the parameters and return values for the\ntwo methods are both simple strings we could stop there. In\nsome cases, however, one might want to be more specific\nabout data types expected for parameters, for example signed\nvs unsigned integers. Adding explicit data typing also makes\ninteraction with other programming languages more reliable.\nProviding explicit data type definitions for exported method\nis known in the DBus world as &quot;Introspection&quot;, and\nit makes life much more reliable for users of one&rsquo;s\nservice whom may be using a strongly typed language such as\nC.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first step\nin providing introspection data for a DBus object in Perl,\nis to specify the name of the interface provided by the\nobject. This is typically a period separated string, by\nconvention containing the domain name of the application as\nits first component. Since most Perl modules end up living\non <small>CPAN,</small> one might use &quot;org.cpan&quot;\nas the first component, followed by the package name of the\nmodule (replacing :: with .), eg\n&quot;org.cpan.music.player.manager&quot;. If it is not\nplanned to host the module on <small>CPAN,</small> a\npersonal/project domain might be used eg\n&quot;com.berrange.music.player.manager&quot;. The interface\nfor an object is defined by loading the Net::DBus::Exporter\nmodule, providing the interface as its first parameter. So\nthe earlier code example would be modified to look like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">package\nMusic::Player::Manager; <br>\nuse base qw(Net::DBus); <br>\nuse Net::DBus::Exporter\nqw(com.berrange.music.player.manager)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Next up, it is\nnecessary to provide data types for the parameters and\nreturn values of the methods. The Net::DBus::Exporter module\nprovides a method &quot;dbus_method&quot; for this purpose,\nwhich takes three parameter, the name of the method being\nexported, an array reference of parameter types, and an\narray reference of return types (the latter can be omitted\nif there are no return values). This can be called at any\npoint in the module&rsquo;s code, but by convention it is\npreferable to associate calls to &quot;dbus_method&quot;\nwith the actual method implementation, thus:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">dbus_method(&quot;register_backend&quot;,\n[&quot;string&quot;, &quot;string&quot;]); <br>\nsub register_backend { <br>\nmy $self = shift; <br>\nmy $name = shift; <br>\nmy $module = shift; <br>\n.. snipped rest of method body ... <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And, thus:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">dbus_method(&quot;find_backend&quot;,\n[&quot;string&quot;], [&quot;string&quot;]) <br>\nsub find_backend { <br>\nmy $self = shift; <br>\nmy $extension = shift; <br>\n... snip method body... <br>\n}</p>\n\n<h2>DEFINING A SERVICE\n<a name=\"DEFINING A SERVICE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Now that the\nobjects have been written, it is time to define a service. A\nservice is nothing more than a well known name for a given\n<small>API</small> contract. A contract can be thought of as\na definition of a list of object paths, and the\ncorresponding interfaces they provide. So, someone else\ncould come along a provide an alternate music player\nimplementation using the Python or <small>QT</small>\nbindings for DBus, and if they provided the same set of\nobject paths &amp; interfaces, they could justifiably\nregister the same service on the bus.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nNet::DBus::Service module provides the means to register a\nservice. Its constructor expects a reference to the bus\nobject (an instance of Net::DBus), along with the name of\nthe service. As with interface names, the first component of\na service name is usually derived from a domain name, and\nthen suffixed with the name of the application, in our\nexample forming &quot;org.cpan.Music.Player&quot;. While\nsome objects will be created on the fly during execution of\nthe application, others are created upon initial startup.\nThe music player manager object created earlier in this\ntutorial is an example of the latter. It is typical to\ninstantiate and register these objects in the constructor\nfor the service. Thus a service object for the music player\napplication would look like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">package\nMusic::Player; <br>\nuse base qw(Net::DBus::Service); <br>\nsub new { <br>\nmy $class = shift; <br>\nmy $bus = shift; <br>\nmy $self = $class-&gt;SUPER::new($bus,\n&quot;org.cpan.music.player&quot;); <br>\nbless $self, $class; <br>\n$self-&gt;{manager} = Music::Player::Manager-&gt;new($self);\n<br>\nreturn $self; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nNet::DBus::Service automatically provides one special object\nto all services, under the path\n&quot;/org/freedesktop/DBus/Exporter&quot;. This object\nimplements the &quot;org.freedesktop.DBus.Exporter&quot;\ninterface which has a method &quot;ListObject&quot;. This\nenables clients to determine a list of all objects exported\nwithin a service. While not functionally necessary for most\napplications, it is none-the-less a useful tool for\ndevelopers debugging applications, or wondering what a\nservice provides.</p>\n\n<h2>CONNECTING TO THE BUS\n<a name=\"CONNECTING TO THE BUS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The final step\nin getting our service up and running is to connect it to\nthe bus. This brings up an interesting conundrum, does one\nexport the service on the system bus (shared by all users\n&amp; processes on the machine), or the session bus (one per\nuser logged into a machine). In some cases the answer, with\nonly one of the two buses conceptually making sense. In\nother cases, however, both the session &amp; system bus are\nvalid. In the former one would use the &quot;session&quot;\nor &lt;system&gt; methods on Net::DBus to get a handle to\nthe desired bus, while in the latter case, the\n&quot;find&quot; method would be used. This applies a\nheuristic to determine the correct bus based on execution\nenvironment. In the case of the music player, either bus is\nrelevant, so the code to connect the service to the bus\nwould look like:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use Net::DBus;\n<br>\nmy $bus = Net::DBus-&gt;find; <br>\nmy $player = Music::Player-&gt;new($bus);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With the\nservice attached to the bus, it is merely necessary to run\nthe main event processing loop to listen out for &amp;\nhandle incoming DBus messages. So the above code is modified\nto start a simple reactor:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use Net::DBus;\n<br>\nuse Net::DBus::Reactor; <br>\nmy $bus = Net::DBus-&gt;find; <br>\nmy $player = Music::Player-&gt;new($bus); <br>\nNet::DBus::Reactor-&gt;main-&gt;run; <br>\nexit 0;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Saving this\ncode into a script &quot;/usr/bin/music-player.pl&quot;,\ncoding is complete and the service ready for use by clients\non the bus.</p>\n\n<h2>SERVICE ACTIVATION\n<a name=\"SERVICE ACTIVATION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">One might now\nwonder how best to start the service, particularly if it is\na service capable of running on both the system and session\nbuses. DBus has the answer in the concept of\n&quot;activation&quot;. What happens is that when a client\non the bus attempts to call a method, or register a signal\nhandler against, a service not currently running, it will\nfirst try and start the service. Service&rsquo;s which wish\nto participate in this process merely need stick a simple\nservice definition file into the directory\n&quot;/usr/share/dbus-1/services&quot;. The file should be\nnamed to match the service name, with the file extension\n&quot;.service&quot; appended. eg,\n&quot;/usr/share/dbus-1/services/org.cpan.music.player.service&quot;\nThe file contains two keys, first the name of the service,\nand second the name of the executable used to run the\nservice, or in this case the Perl script. So, for our simple\nservice the data file would contain:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[D-BUS Service]\n<br>\nName=org.cpan.music.player <br>\nExec=/usr/bin/music-player.pl</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Net::DBus::Tutorial\nfor details of other tutorials, and Net::DBus for\n<small>API</small> documentation</p>\n\n<h2>AUTHORS\n<a name=\"AUTHORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Daniel Berrange\n&lt;dan@berrange.com&gt;</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright (C)\n2005 Daniel P. Berrange</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#CREATING AN OBJECT\">CREATING AN OBJECT</a>","<a href=\"#PROVIDING INTROSPECTION DATA\">PROVIDING INTROSPECTION DATA</a>","<a href=\"#DEFINING A SERVICE\">DEFINING A SERVICE</a>","<a href=\"#CONNECTING TO THE BUS\">CONNECTING TO THE BUS</a>","<a href=\"#SERVICE ACTIVATION\">SERVICE ACTIVATION</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHORS\">AUTHORS</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":3}