{"name":"devel","description":"Glib::devel -\nBinding developer&rsquo;s overview of Glib&rsquo;s\ninternals\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nDo you need to\nknow how the gtk2-perl language bindings work, or need to\nwrite your own language bindings for a Glib/Gtk2-based\nlibrary? Then you&rsquo;ve come to the right place. If you\nare just a perl developer wanting to write programs with\nGlib or Gtk2, then this is probably way over your head.\n\nThis document\nbegan its life as a post to gtk-perl-list about a redesign\nof the fundamentals of the bindings; today it is the\nreference documentation for the developers of the\nbindings.\n\nTo reduce\nconfusion, refer to GLib, the C library, with a capital L,\nand Glib the perl module with a lower-case l. While the Gtk2\nmodule is the primary client of Glib, it is not necessarily\nthe only one; in fact, the perl bindings for the GStreamer\nlibrary build directly atop Glib. Therefore, this document\ndescribes just the GLib/Glib basics. For details on how Gtk2\nextends upon the concepts presented here, see\nGtk2::devel.\n\nIn various\nplaces, we use the name GPerl to refer to the actual binding\nsubsystem.\n\nIn order to\navoid getting very quickly out of date, this document\ndoesn&rsquo;t go into great detail on APIs. gperl.h is\nrather heavily commented, and should be considered the\ncanonical source of correct <small>API</small>\ninformation.\n\n<h2>Basic Philosophy\n<a name=\"Basic Philosophy\"></a>\n</h2>\n\n\nGLib is a\nportability library for C programs, providing a common set\nof APIs and services on various platforms. Along with that\nyou get libgobject, which provides an inheritance-based type\nsystem and other spiffy things.\n\nGlib, as a perl\nmodule, must decide which portions of GLib&rsquo;s\nfacilities to map to perl and which to abstract and\nencapsulate.\n\nIn the grand\nscheme, the bindings have been designed with a few basic\ntenets in mind:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Stick close to the C <small>API,</small> to allow a perl\ndeveloper to use knowledge from the C <small>API</small> and\n<small>API</small> reference docs with the perl bindings;\nthis is overruled in some places by the remaining\ntenets. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Be perlish. This is the most important. The user of the\nperl bindings should not have to worry about memory\nmanagement, reference counting, freeing objects, and all\nthat stuff, else he might as well go write in C instead.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Leave out deprecated functionality.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Don&rsquo;t add new functionality. The exceptions to\nthis rule are consolidation of methods where default\nparameters may be used, or where the direct analog from C is\nnot practical.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Be lightweight. As little indirection and bloat as\npossible. If possible, implement each toplevel module (e.g.,\nGlib, Gtk2, Gnome2, GtkHTML, etc) as one .pm and one\n.so. </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Be extensible. Export header files and typemaps so that\nother modules can easily chain off of our base. Do not\nrequire the entirely of Gtk2 for someone who needs only to\nbuild atop GObject.</td></tr>\n</table>\n\n<h2>The Glib Module\n<a name=\"The Glib Module\"></a>\n</h2>\n\n\nIn keeping with\nthe tenet of not requiring the entire car for someone who\nonly needs a single wheel, I broke the glib/gobject library\nfamily into its own module and namespace. This has proved to\nbe a godsend, as it has made things very easy to debug;\nthere&rsquo;s a clean separation between the base of the\ntype system and the stuff on top of it.\n\nThe Glib module\ntakes care of all the basic types handled by the GObject\nlibrary --- GEnum, GFlags, GBoxed, GObject, GValue, GClosure\n--- as well has signal marshalling and such in GSignal.\nI&rsquo;ll discuss each of these separately.\n\nIn practice,\nyou will rarely see direct calls to the functions that\nconvert objects in and out of perl. Most code should use the\nC preprocessor to provide easier-to-remember names that\nfollow the perl <small>API</small> style, e.g.,\nnewSVGObject(obj) rather than gperl_new_object(type,obj) and\nSvGObject(sv) instead of gperl_get_gobject(type, sv). The\nconvention used in all of gtk2-perl is described in\nGtk2::devel.\n\n\n<b>Wrappers</b>\n<small><br>\nFIXME</small> maybe this section should be rolled into the\nGBoxed and GObject sections?\n\nIn order to use\nthe C data structures from Perl, we need to wrap those\nobjects up in Perl objects. In general, a Perl object is\nsimply a blessed reference. A typical scheme for\nrepresenting C objects in perl is bless a reference to a\nscalar holding the C pointer value; perl will destroy the\nreference-counted scalar when there are no more references\nto it, and one would normally destroy the underlying data\nstructure at this point. However, GLib is a little more\ncomplex than your typical C library, so this easy, typical\nsetup won&rsquo;t work for us.\n\nGBoxed types\nare opaque wrappers for C structures, providing copy and\nfree functions, to allow the types to be used generically.\nFor the most part we can get away with using the typical\nscheme described above to provide an opaque object, but in\nsome instances an opaque object is very alien in perl. The\nGlib::Boxed section explains how we get around this.\n\nGObject, on the\nother hand, is a type-aware, reference-counted object with\nlifetime semantics that differ somewhat from perl SVs. Thus\nwe need something a bit more sophisticated than a plain old\nopaque wrapper; in fact, we use a blessed hash reference\nwith the pointer to the C object tucked away in attached\nmagic, and a pointer to the <small>SV</small> stored in the\nGObject&rsquo;s user data. The combined perl/C object does\nsome nifty reference-count borrowing to ensure that object\nlifetime is managed correctly.\n\nIf an object is\ncreated by a function that returns directly to perl, then\nthe wrapper returned by that function should &quot;own&quot;\nthe object. If no other code assumes ownership of that\nobject (by ref&rsquo;ing a GObject or copying a GBoxed),\nthen the object should be destroyed when the perl scalar is\ndestroyed (actually, as part of its destruction).\n\nIf a function\nreturns a preexisting object owned by someone else, then the\nbindings should <small>NOT</small> destroy the object with\nthe perl wrapper. How we handle this for the various types\nis described below.\n\n<b>GType to\nPackage Mappings</b> <br>\nGType is the GObject library&rsquo;s unique type identifier;\nthis is a runtime variable, because GLib types may be loaded\ndynamically. The direct analog in perl is the package name,\nwhich uniquely specifies an object&rsquo;s class. Since\nthese do about the same thing, we completely replace the\nGType with the perl package.\n\nFor various\nreasons, mostly to do with robustness and performance, there\nis a one-to-one mapping between GType classes and perl\npackage names. These must be registered, usually as part of\nthe module initialization process.\n\nIn addition,\nthe type system tries as hard as it can to recover when\nthings don&rsquo;t go well, using the GType system to its\nadvantage. If you return a C object of a type that is not\nregistered with Gperl, such as MyCustomTypeFoo,\ngperl_new_object (see below) will warn you that it has\nblessed the unknown MyCustomTypeFoo into the first known\npackage in its ancestry, Gtk2::VBox.\n\nGBoxed and\nGObject have distinct mapping registries to avoid\ncross-pollination and mistakes in the type system. See\nbelow.\n\nTo assist in\nhandling inheritance that isn&rsquo;t specified directly by\nthe GType system, the function gperl_set_isa allows you to\nadd elements to the @ISA for a package.\ngperl_register_object does this for you, but you may need to\nadd additional parents, e.g., for implementing GInterfaces.\n(see Gtk2/xs/GtkEntry.xs for an example)\n\nYou may be\nthinking that we could use substitution rules to map the\nGObject classes to perl packages. In practice, this is a bad\nidea, fraught with problems; the substitution rules are not\neasily extendable and are easily broken by extension\npackages which don&rsquo;t follow the naming\nconventions.\n\n<b>GEnums and\nGFlags</b> <br>\nGLib provides a mechanism for creating runtime type\ninformation about enumeration and flag types. Enumerations\nare lists of specific values, one of which may be used at at\ntime, whereas multiple flag values may be supplied at a\ntime. In C flags are meant to be used with bitfields. A\nGType is associated with the various valid values for a\ngiven GEnum or GFlags type as strings, in both full-name and\nnickname forms.\n\nGPerl uses this\nmechanism to avoid the need to know integer values for enum\nand flag types at the perl level. An enum value is just a\nstring; a bitfield of flag values is represented as a\nreference to an array of strings. These strings are the\nGLib-provided nicknames. For the convenience of a perl\ndeveloper, the bindings treat &rsquo;-&rsquo; and\n&rsquo;_&rsquo; as equivalent when looking up the\ncorresponding integer values during conversion.\n\nA GEnum or\nGFlags type mapping should be registered with\n\nvoid\ngperl_register_fundamental (GType gtype, const char *\npackage);\n\nso that their\npackage names can be used where a GType is required (for\nexample, as GObject property types or GtkTreeModel column\ntypes).\n\nThe basic\nfunctions for converting between C and perl values are\n\n/* croak if val\nis not part of type, otherwise return <br>\n* corresponding value. this is the general case. */ <br>\ngint gperl_convert_enum (GType type, SV * val); <br>\n/* return a scalar which is the nickname of the enum value\n<br>\n* val, or croak if val is not a member of the enum. */ <br>\nSV * gperl_convert_back_enum (GType type, gint val); <br>\n/* collapse a list of strings to an integer with all the\n<br>\n* correct bits set, croak if anything is invalid. */ <br>\ngint gperl_convert_flags (GType type, SV * val); <br>\n/* convert a bitfield to a list of strings, or croak. */\n<br>\nSV * gperl_convert_back_flags (GType type, gint val);\n\nOther utility\nfunctions allow for finer-grained control, such as the\nability to pass unknown values, which can be necessary in\nspecial cases. In general, each of these functions raises an\nexception when something goes wrong. To be helpful, they\ncroak with a message listing the valid values when they\nencounter invalid input.\n\n<b>GBoxed</b>\n<br>\nGBoxed provides a way to register functions that create,\ncopy, and destroy opaque structures. For our purposes,\nwe&rsquo;ll allow any perl package to inherit from\nGlib::Boxed and implement accessors for the struct members,\nbut Glib::Boxed will handle the object and wrapper lifetime\nissues.\n\nThere are two\nfunctions for creating boxed wrappers:\n\nSV *\ngperl_new_boxed (gpointer boxed, GType gtype, gboolean own);\n<br>\nSV * gperl_new_boxed_copy (gpointer boxed, GType gtype);\n\nIf own is\n<small>TRUE,</small> the wrapper returned by gperl_new_boxed\nwill take boxed with it when it dies. In the case of a copy,\nown is implied, so there&rsquo;s a separate function which\ndoesn&rsquo;t need the own option.\n\nTo get a boxed\npointer out of a scalar wrapper, you just call\ngperl_get_boxed_check --- this will croak if the sv is undef\nor not blessed into the specified package.\n\nWhen you\nregister a boxed type you get the option of supplying a\ntable of function pointers describing how the boxed object\nshould be wrapped, unwrapped, and destroyed. This allows you\nto decide in the wrapping function what subclass of the\nboxed type&rsquo;s class the wrapper should actually take (a\ntrick used by Gtk2::Gdk::Event), or represent a boxed type\nas a native perl type (such as using array references for\nGnome2::Canvas::Point objects). All of this happens\nautomagically, behind the scenes, and most types assume the\ndefault wrapper class.\n\nSee the\ncommentary in gperl.h for more information.\n\n<b>GObject</b>\n<br>\nThe GObject knows its own type. Thus, we need only one\nparameter to create a GObject wrapper. In reality, we ask\nfor two:\n\nSV *\ngperl_new_object (GObject * object, gboolean own);\n\nThe wrapper\n<small>SV</small> will be blessed into the package\ncorresponding to the gtype returned by G_OBJECT_TYPE\n(object), that is, the bottommost type in the inheritance\nchain. If that bottommost type is not known, the function\nwalks back up the tree until it finds one that&rsquo;s\nknown, blesses the reference into that package, and spits\nout a warning on stderr. To hush the warning, you need\nmerely call\n\nIn general,\nthis process will claim a reference on the GObject (with\n<b>g_object_ref()</b>), so that the C object stays alive so\nlong as there is a perl wrapper for it. If\n&lt;i&gt;own&lt;/i&gt; is set to <small>TRUE,</small> the\nperl wrapper will claim ownership of the C object by\nremoving that reference; in theory, for a new GObject, fresh\nfrom a constructor, this leaves the object with a single\nreference owned by the perl object. The next question out of\nyour mouth should be, &quot;But what about GObject\nderivatives that require sinking or other strange methods to\nclaim ownership?&quot; For the answer, see the GtkObject\nsection&rsquo;s description of sink functions.\n\nvoid\ngperl_register_object (GType gtype, const char *\npackage);\n\nThis magical\nfunction also sets up the @ISA for the package to point to\nthe package corresponding to g_type_parent (gtype). [Since\nthis requires the parent package to be registered, there is\na simple deferral mechanism, which means your @ISA might not\nbe set until the next call to gperl_register_object.]\n\nThere are two\nways to get an object out of an <small>SV</small> (though I\nthink only one is really needed):\n\nGObject *\ngperl_get_object (SV * sv); <br>\nGObject * gperl_get_object_check (SV * sv, GType gtype);\n\nThe second one\nis like the first, but croaks if the object is not derived\nfrom gtype.\n\nYou can get and\nset object data and object parameters just like you&rsquo;d\nexpect.\n\n<b>GSignal</b>\n<br>\nAll of this GObject stuff wouldn&rsquo;t be very useful if\nyou couldn&rsquo;t connect signals and closures. I got most\nof my handling code from gtk2-perl and pygtk, and it&rsquo;s\npretty straightforward. The data member is optional, and\nmust be a scalar.\n\nTo connect perl\nsubroutines to GSignals I use GClosures, which require the\nhandling of GValues.\n\n\n<b>GPerlClosure</b>\n<br>\nUse a GPerlClosure wherever you could use a GClosure and\nthings should work out great. <i><small>FIXME</small> say\nmore here</i>\n\n\n<b>GPerlCallback</b>\n<br>\nFunction pointers are required in many places throughout\ngtk+, usually for a callback to be used as a\n&quot;foreach&quot; function or for some other purpose.\nUnfortunately, a majority of these spots aren&rsquo;t\ndesigned to work with GClosures (usually by lacking a way to\ndestroy data associated with the callback when it is no\nlonger needed). For this purpose, the GPerlCallback wraps up\nthe gruntwork of using perl&rsquo;s call_sv to use a\ncallback function directly.\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/1/perl\">perl(1)</a>,\n<a href=\"https://man.page/1/perlxs\">perlxs(1)</a>, <a href=\"https://man.page/1/perlguts\">perlguts(1)</a>, <a href=\"https://man.page/1/perlapi\">perlapi(1)</a>,\n<a href=\"https://man.page/1/perlxstut\">perlxstut(1)</a>, ExtUtils::Depends(3pm),\nExtUtils::PkgConfig(3pm) Glib(3pm),\nGlib::Object::Subclass(3pm), Glib::xsapi(3pm)\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\nmuppet\n&lt;scott at asofyet.org&gt;\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\nCopyright (C)\n2003 by the gtk2-perl team (see the file\n<small>AUTHORS</small> for the full list)\n\nThis library is\nfree software; you can redistribute it and/or modify it\nunder the terms of the <small>GNU</small> Library General\nPublic License as published by the Free Software Foundation;\neither version 2.1 of the License, or (at your option) any\nlater version.\n\nThis library is\ndistributed in the hope that it will be useful, but\n<small>WITHOUT ANY WARRANTY</small> ; without even the\nimplied warranty of <small>MERCHANTABILITY</small> or\n<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the\n<small>GNU</small> Library General Public License for more\ndetails.\n\nYou should have\nreceived a copy of the <small>GNU</small> Library General\nPublic License along with this library; if not, write to the\nFree Software Foundation, Inc., 51 Franklin Street, Fifth\nFloor, Boston, <small>MA 02110-1301 USA.</small>","body":"\n\n<h1 align=\"center\">devel</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glib::devel -\nBinding developer&rsquo;s overview of Glib&rsquo;s\ninternals</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Do you need to\nknow how the gtk2-perl language bindings work, or need to\nwrite your own language bindings for a Glib/Gtk2-based\nlibrary? Then you&rsquo;ve come to the right place. If you\nare just a perl developer wanting to write programs with\nGlib or Gtk2, then this is probably way over your head.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This document\nbegan its life as a post to gtk-perl-list about a redesign\nof the fundamentals of the bindings; today it is the\nreference documentation for the developers of the\nbindings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To reduce\nconfusion, refer to GLib, the C library, with a capital L,\nand Glib the perl module with a lower-case l. While the Gtk2\nmodule is the primary client of Glib, it is not necessarily\nthe only one; in fact, the perl bindings for the GStreamer\nlibrary build directly atop Glib. Therefore, this document\ndescribes just the GLib/Glib basics. For details on how Gtk2\nextends upon the concepts presented here, see\nGtk2::devel.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In various\nplaces, we use the name GPerl to refer to the actual binding\nsubsystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to\navoid getting very quickly out of date, this document\ndoesn&rsquo;t go into great detail on APIs. gperl.h is\nrather heavily commented, and should be considered the\ncanonical source of correct <small>API</small>\ninformation.</p>\n\n<h2>Basic Philosophy\n<a name=\"Basic Philosophy\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">GLib is a\nportability library for C programs, providing a common set\nof APIs and services on various platforms. Along with that\nyou get libgobject, which provides an inheritance-based type\nsystem and other spiffy things.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glib, as a perl\nmodule, must decide which portions of GLib&rsquo;s\nfacilities to map to perl and which to abstract and\nencapsulate.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the grand\nscheme, the bindings have been designed with a few basic\ntenets in mind:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Stick close to the C <small>API,</small> to allow a perl\ndeveloper to use knowledge from the C <small>API</small> and\n<small>API</small> reference docs with the perl bindings;\nthis is overruled in some places by the remaining\ntenets.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Be perlish. This is the most important. The user of the\nperl bindings should not have to worry about memory\nmanagement, reference counting, freeing objects, and all\nthat stuff, else he might as well go write in C instead.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Leave out deprecated functionality.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Don&rsquo;t add new functionality. The exceptions to\nthis rule are consolidation of methods where default\nparameters may be used, or where the direct analog from C is\nnot practical.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Be lightweight. As little indirection and bloat as\npossible. If possible, implement each toplevel module (e.g.,\nGlib, Gtk2, Gnome2, GtkHTML, etc) as one .pm and one\n.so.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>-</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Be extensible. Export header files and typemaps so that\nother modules can easily chain off of our base. Do not\nrequire the entirely of Gtk2 for someone who needs only to\nbuild atop GObject.</p></td></tr>\n</table>\n\n<h2>The Glib Module\n<a name=\"The Glib Module\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In keeping with\nthe tenet of not requiring the entire car for someone who\nonly needs a single wheel, I broke the glib/gobject library\nfamily into its own module and namespace. This has proved to\nbe a godsend, as it has made things very easy to debug;\nthere&rsquo;s a clean separation between the base of the\ntype system and the stuff on top of it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Glib module\ntakes care of all the basic types handled by the GObject\nlibrary --- GEnum, GFlags, GBoxed, GObject, GValue, GClosure\n--- as well has signal marshalling and such in GSignal.\nI&rsquo;ll discuss each of these separately.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In practice,\nyou will rarely see direct calls to the functions that\nconvert objects in and out of perl. Most code should use the\nC preprocessor to provide easier-to-remember names that\nfollow the perl <small>API</small> style, e.g.,\nnewSVGObject(obj) rather than gperl_new_object(type,obj) and\nSvGObject(sv) instead of gperl_get_gobject(type, sv). The\nconvention used in all of gtk2-perl is described in\nGtk2::devel.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Wrappers</b>\n<small><br>\nFIXME</small> maybe this section should be rolled into the\nGBoxed and GObject sections?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order to use\nthe C data structures from Perl, we need to wrap those\nobjects up in Perl objects. In general, a Perl object is\nsimply a blessed reference. A typical scheme for\nrepresenting C objects in perl is bless a reference to a\nscalar holding the C pointer value; perl will destroy the\nreference-counted scalar when there are no more references\nto it, and one would normally destroy the underlying data\nstructure at this point. However, GLib is a little more\ncomplex than your typical C library, so this easy, typical\nsetup won&rsquo;t work for us.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">GBoxed types\nare opaque wrappers for C structures, providing copy and\nfree functions, to allow the types to be used generically.\nFor the most part we can get away with using the typical\nscheme described above to provide an opaque object, but in\nsome instances an opaque object is very alien in perl. The\nGlib::Boxed section explains how we get around this.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">GObject, on the\nother hand, is a type-aware, reference-counted object with\nlifetime semantics that differ somewhat from perl SVs. Thus\nwe need something a bit more sophisticated than a plain old\nopaque wrapper; in fact, we use a blessed hash reference\nwith the pointer to the C object tucked away in attached\nmagic, and a pointer to the <small>SV</small> stored in the\nGObject&rsquo;s user data. The combined perl/C object does\nsome nifty reference-count borrowing to ensure that object\nlifetime is managed correctly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If an object is\ncreated by a function that returns directly to perl, then\nthe wrapper returned by that function should &quot;own&quot;\nthe object. If no other code assumes ownership of that\nobject (by ref&rsquo;ing a GObject or copying a GBoxed),\nthen the object should be destroyed when the perl scalar is\ndestroyed (actually, as part of its destruction).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a function\nreturns a preexisting object owned by someone else, then the\nbindings should <small>NOT</small> destroy the object with\nthe perl wrapper. How we handle this for the various types\nis described below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GType to\nPackage Mappings</b> <br>\nGType is the GObject library&rsquo;s unique type identifier;\nthis is a runtime variable, because GLib types may be loaded\ndynamically. The direct analog in perl is the package name,\nwhich uniquely specifies an object&rsquo;s class. Since\nthese do about the same thing, we completely replace the\nGType with the perl package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For various\nreasons, mostly to do with robustness and performance, there\nis a one-to-one mapping between GType classes and perl\npackage names. These must be registered, usually as part of\nthe module initialization process.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition,\nthe type system tries as hard as it can to recover when\nthings don&rsquo;t go well, using the GType system to its\nadvantage. If you return a C object of a type that is not\nregistered with Gperl, such as MyCustomTypeFoo,\ngperl_new_object (see below) will warn you that it has\nblessed the unknown MyCustomTypeFoo into the first known\npackage in its ancestry, Gtk2::VBox.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">GBoxed and\nGObject have distinct mapping registries to avoid\ncross-pollination and mistakes in the type system. See\nbelow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To assist in\nhandling inheritance that isn&rsquo;t specified directly by\nthe GType system, the function gperl_set_isa allows you to\nadd elements to the @ISA for a package.\ngperl_register_object does this for you, but you may need to\nadd additional parents, e.g., for implementing GInterfaces.\n(see Gtk2/xs/GtkEntry.xs for an example)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You may be\nthinking that we could use substitution rules to map the\nGObject classes to perl packages. In practice, this is a bad\nidea, fraught with problems; the substitution rules are not\neasily extendable and are easily broken by extension\npackages which don&rsquo;t follow the naming\nconventions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GEnums and\nGFlags</b> <br>\nGLib provides a mechanism for creating runtime type\ninformation about enumeration and flag types. Enumerations\nare lists of specific values, one of which may be used at at\ntime, whereas multiple flag values may be supplied at a\ntime. In C flags are meant to be used with bitfields. A\nGType is associated with the various valid values for a\ngiven GEnum or GFlags type as strings, in both full-name and\nnickname forms.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">GPerl uses this\nmechanism to avoid the need to know integer values for enum\nand flag types at the perl level. An enum value is just a\nstring; a bitfield of flag values is represented as a\nreference to an array of strings. These strings are the\nGLib-provided nicknames. For the convenience of a perl\ndeveloper, the bindings treat &rsquo;-&rsquo; and\n&rsquo;_&rsquo; as equivalent when looking up the\ncorresponding integer values during conversion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A GEnum or\nGFlags type mapping should be registered with</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">void\ngperl_register_fundamental (GType gtype, const char *\npackage);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">so that their\npackage names can be used where a GType is required (for\nexample, as GObject property types or GtkTreeModel column\ntypes).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The basic\nfunctions for converting between C and perl values are</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* croak if val\nis not part of type, otherwise return <br>\n* corresponding value. this is the general case. */ <br>\ngint gperl_convert_enum (GType type, SV * val); <br>\n/* return a scalar which is the nickname of the enum value\n<br>\n* val, or croak if val is not a member of the enum. */ <br>\nSV * gperl_convert_back_enum (GType type, gint val); <br>\n/* collapse a list of strings to an integer with all the\n<br>\n* correct bits set, croak if anything is invalid. */ <br>\ngint gperl_convert_flags (GType type, SV * val); <br>\n/* convert a bitfield to a list of strings, or croak. */\n<br>\nSV * gperl_convert_back_flags (GType type, gint val);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other utility\nfunctions allow for finer-grained control, such as the\nability to pass unknown values, which can be necessary in\nspecial cases. In general, each of these functions raises an\nexception when something goes wrong. To be helpful, they\ncroak with a message listing the valid values when they\nencounter invalid input.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GBoxed</b>\n<br>\nGBoxed provides a way to register functions that create,\ncopy, and destroy opaque structures. For our purposes,\nwe&rsquo;ll allow any perl package to inherit from\nGlib::Boxed and implement accessors for the struct members,\nbut Glib::Boxed will handle the object and wrapper lifetime\nissues.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\nfunctions for creating boxed wrappers:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">SV *\ngperl_new_boxed (gpointer boxed, GType gtype, gboolean own);\n<br>\nSV * gperl_new_boxed_copy (gpointer boxed, GType gtype);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If own is\n<small>TRUE,</small> the wrapper returned by gperl_new_boxed\nwill take boxed with it when it dies. In the case of a copy,\nown is implied, so there&rsquo;s a separate function which\ndoesn&rsquo;t need the own option.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To get a boxed\npointer out of a scalar wrapper, you just call\ngperl_get_boxed_check --- this will croak if the sv is undef\nor not blessed into the specified package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When you\nregister a boxed type you get the option of supplying a\ntable of function pointers describing how the boxed object\nshould be wrapped, unwrapped, and destroyed. This allows you\nto decide in the wrapping function what subclass of the\nboxed type&rsquo;s class the wrapper should actually take (a\ntrick used by Gtk2::Gdk::Event), or represent a boxed type\nas a native perl type (such as using array references for\nGnome2::Canvas::Point objects). All of this happens\nautomagically, behind the scenes, and most types assume the\ndefault wrapper class.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\ncommentary in gperl.h for more information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GObject</b>\n<br>\nThe GObject knows its own type. Thus, we need only one\nparameter to create a GObject wrapper. In reality, we ask\nfor two:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">SV *\ngperl_new_object (GObject * object, gboolean own);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The wrapper\n<small>SV</small> will be blessed into the package\ncorresponding to the gtype returned by G_OBJECT_TYPE\n(object), that is, the bottommost type in the inheritance\nchain. If that bottommost type is not known, the function\nwalks back up the tree until it finds one that&rsquo;s\nknown, blesses the reference into that package, and spits\nout a warning on stderr. To hush the warning, you need\nmerely call</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In general,\nthis process will claim a reference on the GObject (with\n<b>g_object_ref()</b>), so that the C object stays alive so\nlong as there is a perl wrapper for it. If\n&lt;i&gt;own&lt;/i&gt; is set to <small>TRUE,</small> the\nperl wrapper will claim ownership of the C object by\nremoving that reference; in theory, for a new GObject, fresh\nfrom a constructor, this leaves the object with a single\nreference owned by the perl object. The next question out of\nyour mouth should be, &quot;But what about GObject\nderivatives that require sinking or other strange methods to\nclaim ownership?&quot; For the answer, see the GtkObject\nsection&rsquo;s description of sink functions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">void\ngperl_register_object (GType gtype, const char *\npackage);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This magical\nfunction also sets up the @ISA for the package to point to\nthe package corresponding to g_type_parent (gtype). [Since\nthis requires the parent package to be registered, there is\na simple deferral mechanism, which means your @ISA might not\nbe set until the next call to gperl_register_object.]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\nways to get an object out of an <small>SV</small> (though I\nthink only one is really needed):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">GObject *\ngperl_get_object (SV * sv); <br>\nGObject * gperl_get_object_check (SV * sv, GType gtype);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second one\nis like the first, but croaks if the object is not derived\nfrom gtype.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can get and\nset object data and object parameters just like you&rsquo;d\nexpect.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GSignal</b>\n<br>\nAll of this GObject stuff wouldn&rsquo;t be very useful if\nyou couldn&rsquo;t connect signals and closures. I got most\nof my handling code from gtk2-perl and pygtk, and it&rsquo;s\npretty straightforward. The data member is optional, and\nmust be a scalar.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To connect perl\nsubroutines to GSignals I use GClosures, which require the\nhandling of GValues.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GPerlClosure</b>\n<br>\nUse a GPerlClosure wherever you could use a GClosure and\nthings should work out great. <i><small>FIXME</small> say\nmore here</i></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GPerlCallback</b>\n<br>\nFunction pointers are required in many places throughout\ngtk+, usually for a callback to be used as a\n&quot;foreach&quot; function or for some other purpose.\nUnfortunately, a majority of these spots aren&rsquo;t\ndesigned to work with GClosures (usually by lacking a way to\ndestroy data associated with the callback when it is no\nlonger needed). For this purpose, the GPerlCallback wraps up\nthe gruntwork of using perl&rsquo;s call_sv to use a\ncallback function directly.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/perl\">perl(1)</a>,\n<a href=\"https://man.page/1/perlxs\">perlxs(1)</a>, <a href=\"https://man.page/1/perlguts\">perlguts(1)</a>, <a href=\"https://man.page/1/perlapi\">perlapi(1)</a>,\n<a href=\"https://man.page/1/perlxstut\">perlxstut(1)</a>, ExtUtils::Depends(3pm),\nExtUtils::PkgConfig(3pm) Glib(3pm),\nGlib::Object::Subclass(3pm), Glib::xsapi(3pm)</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">muppet\n&lt;scott at asofyet.org&gt;</p>\n\n<h2>COPYRIGHT\n<a name=\"COPYRIGHT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright (C)\n2003 by the gtk2-perl team (see the file\n<small>AUTHORS</small> for the full list)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the terms of the <small>GNU</small> Library General\nPublic License as published by the Free Software Foundation;\neither version 2.1 of the License, or (at your option) any\nlater version.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\ndistributed in the hope that it will be useful, but\n<small>WITHOUT ANY WARRANTY</small> ; without even the\nimplied warranty of <small>MERCHANTABILITY</small> or\n<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the\n<small>GNU</small> Library General Public License for more\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You should have\nreceived a copy of the <small>GNU</small> Library General\nPublic License along with this library; if not, write to the\nFree Software Foundation, Inc., 51 Franklin Street, Fifth\nFloor, Boston, <small>MA 02110-1301 USA.</small></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#Basic Philosophy\">Basic Philosophy</a>","<a href=\"#The Glib Module\">The Glib Module</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT\">COPYRIGHT</a>"],"level":3}