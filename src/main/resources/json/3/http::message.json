{"name":"http::message","description":"HTTP::Message -\nHTTP style message (base class)\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\nversion\n6.36","body":"\n\n<h1 align=\"center\">HTTP::Message</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">HTTP::Message -\nHTTP style message (base class)</p>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">version\n6.36</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use base\n'HTTP::Message';</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">An\n&quot;HTTP::Message&quot; object contains some headers and a\ncontent body. The following methods are available: <br>\n$mess = HTTP::Message-&gt;new <br>\n$mess = HTTP::Message-&gt;new( $headers ) <br>\n$mess = HTTP::Message-&gt;new( $headers, $content )</p>\n\n<p style=\"margin-left:17%;\">This constructs a new message\nobject. Normally you would want construct\n&quot;HTTP::Request&quot; or &quot;HTTP::Response&quot;\nobjects instead.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The optional\n$header argument should be a reference to an\n&quot;HTTP::Headers&quot; object or a plain array reference\nof key/value pairs. If an &quot;HTTP::Headers&quot; object\nis provided then a copy of it will be embedded into the\nconstructed message, i.e. it will not be owned and can be\nmodified afterwards without affecting the message.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The optional\n$content argument should be a string of bytes.</p>\n\n<p style=\"margin-left:11%;\">$mess =\nHTTP::Message-&gt;parse( $str )</p>\n\n<p style=\"margin-left:17%;\">This constructs a new message\nobject by parsing the given string.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;headers</p>\n\n<p style=\"margin-left:17%;\">Returns the embedded\n&quot;HTTP::Headers&quot; object.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;headers_as_string\n<br>\n$mess-&gt;headers_as_string( $eol )</p>\n\n<p style=\"margin-left:17%;\">Call the <b>as_string()</b>\nmethod for the headers in the message. This will be the same\nas</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$mess-&gt;headers-&gt;as_string</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">but it will\nmake your program a whole character shorter :-)</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;content <br>\n$mess-&gt;content( $bytes )</p>\n\n<p style=\"margin-left:17%;\">The <b>content()</b> method\nsets the raw content if an argument is given. If no argument\nis given the content is not touched. In either case the\noriginal raw content is returned.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the\n&quot;undef&quot; argument is given, the content is reset to\nits default value, which is an empty string.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\ncontent should be a string of bytes. Strings in perl can\ncontain characters outside the range of a byte. The\n&quot;Encode&quot; module can be used to turn such strings\ninto a string of bytes.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;add_content( $bytes\n)</p>\n\n<p style=\"margin-left:17%;\">The <b>add_content()</b>\nmethods appends more data bytes to the end of the current\ncontent buffer.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;add_content_utf8(\n$string )</p>\n\n<p style=\"margin-left:17%;\">The <b>add_content_utf8()</b>\nmethod appends the <small>UTF-8</small> bytes representing\nthe string to the end of the current content buffer.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;content_ref <br>\n$mess-&gt;content_ref( \\$bytes )</p>\n\n<p style=\"margin-left:17%;\">The <b>content_ref()</b> method\nwill return a reference to content buffer string. It can be\nmore efficient to access the content this way if the content\nis huge, and it can even be used for direct manipulation of\nthe content, for instance:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">${$res-&gt;content_ref}\n=~ s/\\bfoo\\b/bar/g;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This example\nwould modify the content buffer in-place.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If an argument\nis passed it will setup the content to reference some\nexternal source. The <b>content()</b> and\n<b>add_content()</b> methods will automatically dereference\nscalar references passed this way. For other references\n<b>content()</b> will return the reference itself and\n<b>add_content()</b> will refuse to do anything.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;content_charset</p>\n\n<p style=\"margin-left:17%;\">This returns the charset used\nby the content in the message. The charset is either found\nas the charset attribute of the &quot;Content-Type&quot;\nheader or by guessing.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See\n&lt;http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding&gt;\nfor details about how charset is determined.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;decoded_content(\n%options )</p>\n\n<p style=\"margin-left:17%;\">Returns the content with any\n&quot;Content-Encoding&quot; undone and, for textual content\n(&quot;Content-Type&quot; values starting with\n&quot;text/&quot;, exactly matching\n&quot;application/xml&quot;, or ending with\n&quot;+xml&quot;), the raw content&rsquo;s character set\ndecoded into Perl&rsquo;s Unicode string format. Note that\nthis does not currently\n&lt;https://github.com/libwww-perl/HTTP-Message/pull/99&gt;\nattempt to decode declared character sets for any other\ncontent types like &quot;application/json&quot; or\n&quot;application/javascript&quot;. If the\n&quot;Content-Encoding&quot; or &quot;charset&quot; of the\nmessage is unknown, this method will fail by returning\n&quot;undef&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The following\noptions can be specified. <br>\n&quot;charset&quot;</p>\n\n<p style=\"margin-left:23%;\">This override the charset\nparameter for text content. The value &quot;none&quot; can\nused to suppress decoding of the charset.</p>\n\n\n<p style=\"margin-left:17%;\">&quot;default_charset&quot;</p>\n\n<p style=\"margin-left:23%;\">This override the default\ncharset guessed by <b>content_charset()</b> or if that fails\n&quot; <small>ISO-8859-1&quot;.</small></p>\n\n<p style=\"margin-left:17%;\">&quot;alt_charset&quot;</p>\n\n<p style=\"margin-left:23%;\">If decoding fails because the\ncharset specified in the Content-Type header isn&rsquo;t\nrecognized by Perl&rsquo;s Encode module, then try decoding\nusing this charset instead of failing. The\n&quot;alt_charset&quot; might be specified as\n&quot;none&quot; to simply return the string without any\ndecoding of charset as alternative.</p>\n\n<p style=\"margin-left:17%;\">&quot;charset_strict&quot;</p>\n\n<p style=\"margin-left:23%;\">Abort decoding if malformed\ncharacters is found in the content. By default you get the\nsubstitution character (&quot;\\x{ <small>FFFD</small>\n}&quot;) in place of malformed characters.</p>\n\n<p style=\"margin-left:17%;\">&quot;raise_error&quot;</p>\n\n<p style=\"margin-left:23%;\">If <small>TRUE</small> then\nraise an exception if not able to decode content. Reason\nmight be that the specified &quot;Content-Encoding&quot; or\n&quot;charset&quot; is not supported. If this option is\n<small>FALSE,</small> then <b>decoded_content()</b> will\nreturn &quot;undef&quot; on errors, but will still set\n$@.</p>\n\n<p style=\"margin-left:17%;\">&quot;ref&quot;</p>\n\n<p style=\"margin-left:23%;\">If <small>TRUE</small> then a\nreference to decoded content is returned. This might be more\nefficient in cases where the decoded content is identical to\nthe raw content as no data copying is required in this\ncase.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;decodable <b><br>\nHTTP::Message::decodable()</b></p>\n\n<p style=\"margin-left:17%;\">This returns the encoding\nidentifiers that <b>decoded_content()</b> can process. In\nscalar context returns a comma separated string of\nidentifiers.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This value is\nsuitable for initializing the &quot;Accept-Encoding&quot;\nrequest header field.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;decode</p>\n\n<p style=\"margin-left:17%;\">This method tries to replace\nthe content of the message with the decoded version and\nremoves the &quot;Content-Encoding&quot; header. Returns\n<small>TRUE</small> if successful and <small>FALSE</small>\nif not.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the message\ndoes not have a &quot;Content-Encoding&quot; header this\nmethod does nothing and returns <small>TRUE.</small></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\ncontent of the message is still bytes after this method has\nbeen called and you still need to call\n<b>decoded_content()</b> if you want to process its content\nas a string.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;encode( $encoding,\n... )</p>\n\n<p style=\"margin-left:17%;\">Apply the given encodings to\nthe content of the message. Returns <small>TRUE</small> if\nsuccessful. The &quot;identity&quot; (non-)encoding is\nalways supported; other currently supported encodings,\nsubject to availability of required additional modules, are\n&quot;gzip&quot;, &quot;deflate&quot;, &quot;x-bzip2&quot;\nand &quot;base64&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A successful\ncall to this function will set the\n&quot;Content-Encoding&quot; header.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\n&quot;multipart/*&quot; or &quot;message/*&quot; messages\ncan&rsquo;t be encoded and this method will croak if you\ntry.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;parts <br>\n$mess-&gt;parts( @parts ) <br>\n$mess-&gt;parts( \\@parts )</p>\n\n<p style=\"margin-left:17%;\">Messages can be composite, i.e.\ncontain other messages. The composite messages have a\ncontent type of &quot;multipart/*&quot; or\n&quot;message/*&quot;. This method give access to the\ncontained messages.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\nargumentless form will return a list of\n&quot;HTTP::Message&quot; objects. If the content type of\n$msg is not &quot;multipart/*&quot; or &quot;message/*&quot;\nthen this will return the empty list. In scalar context only\nthe first object is returned. The returned message parts\nshould be regarded as read-only (future versions of this\nlibrary might make it possible to modify the parent by\nmodifying the parts).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the content\ntype of $msg is &quot;message/*&quot; then there will only\nbe one part returned.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the content\ntype is &quot;message/http&quot;, then the return value will\nbe either an &quot;HTTP::Request&quot; or an\n&quot;HTTP::Response&quot; object.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If a @parts\nargument is given, then the content of the message will be\nmodified. The array reference form is provided so that an\nempty list can be provided. The @parts array should contain\n&quot;HTTP::Message&quot; objects. The @parts objects are\nowned by $mess after this call and should not be modified or\nmade part of other messages.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When updating\nthe message with this method and the old content type of\n$mess is not &quot;multipart/*&quot; or\n&quot;message/*&quot;, then the content type is set to\n&quot;multipart/mixed&quot; and all other content headers\nare cleared.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This method\nwill croak if the content type is &quot;message/*&quot; and\nmore than one part is provided.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;add_part( $part )</p>\n\n<p style=\"margin-left:17%;\">This will add a part to a\nmessage. The $part argument should be another\n&quot;HTTP::Message&quot; object. If the previous content\ntype of $mess is not &quot;multipart/*&quot; then the old\ncontent (together with all content headers) will be made\npart #1 and the content type made\n&quot;multipart/mixed&quot; before the new part is added.\nThe $part object is owned by $mess after this call and\nshould not be modified or made part of other messages.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">There is no\nreturn value.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;clear</p>\n\n<p style=\"margin-left:17%;\">Will clear the headers and set\nthe content to the empty string. There is no return\nvalue</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;protocol <br>\n$mess-&gt;protocol( $proto )</p>\n\n<p style=\"margin-left:17%;\">Sets the <small>HTTP</small>\nprotocol used for the message. The <b>protocol()</b> is a\nstring like &quot;HTTP/1.0&quot; or\n&quot;HTTP/1.1&quot;.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;clone</p>\n\n<p style=\"margin-left:17%;\">Returns a copy of the message\nobject.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;as_string <br>\n$mess-&gt;as_string( $eol )</p>\n\n<p style=\"margin-left:17%;\">Returns the message formatted\nas a single string.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The optional\n$eol parameter specifies the line ending sequence to use.\nThe default is &quot;\\n&quot;. If no $eol is given then\nas_string will ensure that the returned string is newline\nterminated (even when the message content is not). No extra\nnewline is appended if an explicit $eol is passed.</p>\n\n<p style=\"margin-left:11%;\">$mess-&gt;dump( %opt )</p>\n\n<p style=\"margin-left:17%;\">Returns the message formatted\nas a string. In void context print the string.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This differs\nfrom &quot;$mess-&gt;as_string&quot; in that it escapes the\nbytes of the content so that it&rsquo;s safe to print them\nand it limits how much content to print. The escapes syntax\nused is the same as for Perl&rsquo;s double quoted strings.\nIf there is no content the string &quot;(no content)&quot;\nis shown in its place.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Options to\ninfluence the output can be passed as key/value pairs. The\nfollowing options are recognized: <br>\nmaxlength =&gt; $num</p>\n\n<p style=\"margin-left:23%;\">How much of the content to\nshow. The default is 512. Set this to 0 for unlimited.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If the content\nis longer then the string is chopped at the limit and the\nstring &quot;...\\n(### more bytes not shown)&quot;\nappended.</p>\n\n<p style=\"margin-left:17%;\">no_content =&gt; $str</p>\n\n<p style=\"margin-left:23%;\">Replaces the &quot;(no\ncontent)&quot; marker.</p>\n\n<p style=\"margin-left:17%;\">prefix =&gt; $str</p>\n\n<p style=\"margin-left:23%;\">A string that will be prefixed\nto each line of the dump.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All methods\nunknown to &quot;HTTP::Message&quot; itself are delegated to\nthe &quot;HTTP::Headers&quot; object that is part of every\nmessage. This allows convenient access to these methods.\nRefer to HTTP::Headers for details of these methods:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$mess-&gt;header(\n$field =&gt; $val ) <br>\n$mess-&gt;push_header( $field =&gt; $val ) <br>\n$mess-&gt;init_header( $field =&gt; $val ) <br>\n$mess-&gt;remove_header( $field ) <br>\n$mess-&gt;remove_content_headers <br>\n$mess-&gt;header_field_names <br>\n$mess-&gt;scan( \\&amp;doit ) <br>\n$mess-&gt;date <br>\n$mess-&gt;expires <br>\n$mess-&gt;if_modified_since <br>\n$mess-&gt;if_unmodified_since <br>\n$mess-&gt;last_modified <br>\n$mess-&gt;content_type <br>\n$mess-&gt;content_encoding <br>\n$mess-&gt;content_length <br>\n$mess-&gt;content_language <br>\n$mess-&gt;title <br>\n$mess-&gt;user_agent <br>\n$mess-&gt;server <br>\n$mess-&gt;from <br>\n$mess-&gt;referer <br>\n$mess-&gt;www_authenticate <br>\n$mess-&gt;authorization <br>\n$mess-&gt;proxy_authorization <br>\n$mess-&gt;authorization_basic <br>\n$mess-&gt;proxy_authorization_basic</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Gisle Aas\n&lt;gisle@activestate.com&gt;</p>\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This software\nis copyright (c) 1994 by Gisle Aas.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is free\nsoftware; you can redistribute it and/or modify it under the\nsame terms as the Perl 5 programming language system\nitself.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT AND LICENSE\">COPYRIGHT AND LICENSE</a>"],"level":3}