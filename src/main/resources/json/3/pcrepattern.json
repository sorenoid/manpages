{"name":"pcrepattern","description":"PCRE -\nPerl-compatible regular expressions\n\n<h2>PCRE REGULAR EXPRESSION DETAILS\n<a name=\"PCRE REGULAR EXPRESSION DETAILS\"></a>\n</h2>\n\n\nThe syntax and\nsemantics of the regular expressions that are supported by\nPCRE are described in detail below. There is a\nquick-reference syntax summary in the <b>pcresyntax</b>\npage. PCRE tries to match Perl syntax and semantics as\nclosely as it can. PCRE also supports some alternative\nregular expression syntax (which does not conflict with the\nPerl syntax) in order to provide some compatibility with\nregular expressions in Python, .NET, and Oniguruma.\n\nPerl&rsquo;s\nregular expressions are described in its own documentation,\nand regular expressions in general are covered in a number\nof books, some of which have copious examples. Jeffrey\nFriedl&rsquo;s &quot;Mastering Regular Expressions&quot;,\npublished by O&rsquo;Reilly, covers regular expressions in\ngreat detail. This description of PCRE&rsquo;s regular\nexpressions is intended as reference material.\n\nThis document\ndiscusses the patterns that are supported by PCRE when one\nits main matching functions, <b>pcre_exec()</b> (8-bit) or\n<b>pcre[16|32]_exec()</b> (16- or 32-bit), is used. PCRE\nalso has alternative matching functions,\n<b>pcre_dfa_exec()</b> and <b>pcre[16|32_dfa_exec()</b>,\nwhich match using a different algorithm that is not\nPerl-compatible. Some of the features discussed below are\nnot available when DFA matching is used. The advantages and\ndisadvantages of the alternative functions, and how they\ndiffer from the normal functions, are discussed in the\n<b>pcrematching</b> page.\n\n<h2>SPECIAL START-OF-PATTERN ITEMS\n<a name=\"SPECIAL START-OF-PATTERN ITEMS\"></a>\n</h2>\n\n\nA number of\noptions that can be passed to <b>pcre_compile()</b> can also\nbe set by special items at the start of a pattern. These are\nnot Perl-compatible, but are provided to make these options\naccessible to pattern writers who are not able to change the\nprogram that processes the pattern. Any number of these\nitems may appear, but they must all be together right at the\nstart of the pattern string, and the letters must be in\nupper case.\n\n<b>UTF\nsupport</b>\n\nThe original\noperation of PCRE was on strings of one-byte characters.\nHowever, there is now also support for UTF-8 strings in the\noriginal library, an extra library that supports 16-bit and\nUTF-16 character strings, and a third library that supports\n32-bit and UTF-32 character strings. To use these features,\nPCRE must be built to include appropriate support. When\nusing UTF strings you must either call the compiling\nfunction with the PCRE_UTF8, PCRE_UTF16, or PCRE_UTF32\noption, or the pattern must start with one of these special\nsequences:\n\n(*UTF8) <br>\n(*UTF16) <br>\n(*UTF32) <br>\n(*UTF)\n\n(*UTF) is a\ngeneric sequence that can be used with any of the libraries.\nStarting a pattern with such a sequence is equivalent to\nsetting the relevant option. How setting a UTF mode affects\npattern matching is mentioned in several places below. There\nis also a summary of features in the <b>pcreunicode</b>\npage.\n\nSome\napplications that allow their users to supply patterns may\nwish to restrict them to non-UTF data for security reasons.\nIf the PCRE_NEVER_UTF option is set at compile time, (*UTF)\netc. are not allowed, and their appearance causes an\nerror.\n\n<b>Unicode\nproperty support</b>\n\nAnother special\nsequence that may appear at the start of a pattern is\n(*UCP). This has the same effect as setting the PCRE_UCP\noption: it causes sequences such as \\d and \\w to use Unicode\nproperties to determine character types, instead of\nrecognizing only characters with codes less than 128 via a\nlookup table.\n\n<b>Disabling\nauto-possessification</b>\n\nIf a pattern\nstarts with (*NO_AUTO_POSSESS), it has the same effect as\nsetting the PCRE_NO_AUTO_POSSESS option at compile time.\nThis stops PCRE from making quantifiers possessive when what\nfollows cannot match the repeated item. For example, by\ndefault a+b is treated as a++b. For more details, see the\n<b>pcreapi</b> documentation.\n\n<b>Disabling\nstart-up optimizations</b>\n\nIf a pattern\nstarts with (*NO_START_OPT), it has the same effect as\nsetting the PCRE_NO_START_OPTIMIZE option either at compile\nor matching time. This disables several optimizations for\nquickly reaching &quot;no match&quot; results. For more\ndetails, see the <b>pcreapi</b> documentation.\n\n<b>Newline\nconventions</b>\n\nPCRE supports\nfive different conventions for indicating line breaks in\nstrings: a single CR (carriage return) character, a single\nLF (linefeed) character, the two-character sequence CRLF,\nany of the three preceding, or any Unicode newline sequence.\nThe <b>pcreapi</b> page has further discussion about\nnewlines, and shows how to set the newline convention in the\n<i>options</i> arguments for the compiling and matching\nfunctions.\n\nIt is also\npossible to specify a newline convention by starting a\npattern string with one of the following five sequences:\n\n(*CR) carriage\nreturn <br>\n(*LF) linefeed <br>\n(*CRLF) carriage return, followed by linefeed <br>\n(*ANYCRLF) any of the three above <br>\n(*ANY) all Unicode newline sequences\n\nThese override\nthe default and the options given to the compiling function.\nFor example, on a Unix system where LF is the default\nnewline sequence, the pattern\n\n(*CR)a.b\n\nchanges the\nconvention to CR. That pattern matches &quot;a\\nb&quot;\nbecause LF is no longer a newline. If more than one of these\nsettings is present, the last one is used.\n\nThe newline\nconvention affects where the circumflex and dollar\nassertions are true. It also affects the interpretation of\nthe dot metacharacter when PCRE_DOTALL is not set, and the\nbehaviour of \\N. However, it does not affect what the \\R\nescape sequence matches. By default, this is any Unicode\nnewline sequence, for Perl compatibility. However, this can\nbe changed; see the description of \\R in the section\nentitled &quot;Newline sequences&quot; below. A change of \\R\nsetting can be combined with a change of newline\nconvention.\n\n<b>Setting\nmatch and recursion limits</b>\n\nThe caller of\n<b>pcre_exec()</b> can set a limit on the number of times\nthe internal <b>match()</b> function is called and on the\nmaximum depth of recursive calls. These facilities are\nprovided to catch runaway matches that are provoked by\npatterns with huge matching trees (a typical example is a\npattern with nested unlimited repeats) and to avoid running\nout of system stack by too much recursion. When one of these\nlimits is reached, <b>pcre_exec()</b> gives an error return.\nThe limits can also be set by items at the start of the\npattern of the form\n\n\n(*LIMIT_MATCH=d)\n<br>\n(*LIMIT_RECURSION=d)\n\nwhere d is any\nnumber of decimal digits. However, the value of the setting\nmust be less than the value set (or defaulted) by the caller\nof <b>pcre_exec()</b> for it to have any effect. In other\nwords, the pattern writer can lower the limits set by the\nprogrammer, but not raise them. If there is more than one\nsetting of one of these limits, the lower value is used.\n\n<h2>EBCDIC CHARACTER CODES\n<a name=\"EBCDIC CHARACTER CODES\"></a>\n</h2>\n\n\nPCRE can be\ncompiled to run in an environment that uses EBCDIC as its\ncharacter code rather than ASCII or Unicode (typically a\nmainframe system). In the sections below, character code\nvalues are ASCII or Unicode; in an EBCDIC environment these\ncharacters may have different code values, and there are no\ncode points greater than 255.\n\n<h2>CHARACTERS AND METACHARACTERS\n<a name=\"CHARACTERS AND METACHARACTERS\"></a>\n</h2>\n\n\nA regular\nexpression is a pattern that is matched against a subject\nstring from left to right. Most characters stand for\nthemselves in a pattern, and match the corresponding\ncharacters in the subject. As a trivial example, the\npattern\n\nThe quick brown\nfox\n\nmatches a\nportion of a subject string that is identical to itself.\nWhen caseless matching is specified (the PCRE_CASELESS\noption), letters are matched independently of case. In a UTF\nmode, PCRE always understands the concept of case for\ncharacters whose values are less than 128, so caseless\nmatching is always possible. For characters with higher\nvalues, the concept of case is supported if PCRE is compiled\nwith Unicode property support, but not otherwise. If you\nwant to use caseless matching for characters 128 and above,\nyou must ensure that PCRE is compiled with Unicode property\nsupport as well as with UTF support.\n\nThe power of\nregular expressions comes from the ability to include\nalternatives and repetitions in the pattern. These are\nencoded in the pattern by the use of <i>metacharacters</i>,\nwhich do not stand for themselves but instead are\ninterpreted in some special way.\n\nThere are two\ndifferent sets of metacharacters: those that are recognized\nanywhere in the pattern except within square brackets, and\nthose that are recognized within square brackets. Outside\nsquare brackets, the metacharacters are as follows:\n\n\\ general\nescape character with several uses <br>\n^ assert start of string (or line, in multiline mode) <br>\n$ assert end of string (or line, in multiline mode) <br>\n. match any character except newline (by default) <br>\n[ start character class definition <br>\n| start of alternative branch <br>\n( start subpattern <br>\n) end subpattern <br>\n? extends the meaning of ( <br>\nalso 0 or 1 quantifier <br>\nalso quantifier minimizer <br>\n* 0 or more quantifier <br>\n+ 1 or more quantifier <br>\nalso &quot;possessive quantifier&quot; <br>\n{ start min/max quantifier\n\nPart of a\npattern that is in square brackets is called a\n&quot;character class&quot;. In a character class the only\nmetacharacters are:\n\n\\ general\nescape character <br>\n^ negate the class, but only if the first character <br>\n- indicates character range <br>\n[ POSIX character class (only if followed by POSIX <br>\nsyntax) <br>\n] terminates the character class\n\nThe following\nsections describe the use of each of the metacharacters.\n\n<h2>BACKSLASH\n<a name=\"BACKSLASH\"></a>\n</h2>\n\n\nThe backslash\ncharacter has several uses. Firstly, if it is followed by a\ncharacter that is not a number or a letter, it takes away\nany special meaning that character may have. This use of\nbackslash as an escape character applies both inside and\noutside character classes.\n\nFor example, if\nyou want to match a * character, you write \\* in the\npattern. This escaping action applies whether or not the\nfollowing character would otherwise be interpreted as a\nmetacharacter, so it is always safe to precede a\nnon-alphanumeric with backslash to specify that it stands\nfor itself. In particular, if you want to match a backslash,\nyou write \\\\.\n\nIn a UTF mode,\nonly ASCII numbers and letters have any special meaning\nafter a backslash. All other characters (in particular,\nthose whose codepoints are greater than 127) are treated as\nliterals.\n\nIf a pattern is\ncompiled with the PCRE_EXTENDED option, most white space in\nthe pattern (other than in a character class), and\ncharacters between a # outside a character class and the\nnext newline, inclusive, are ignored. An escaping backslash\ncan be used to include a white space or # character as part\nof the pattern.\n\nIf you want to\nremove the special meaning from a sequence of characters,\nyou can do so by putting them between \\Q and \\E. This is\ndifferent from Perl in that $ and @ are handled as literals\nin \\Q...\\E sequences in PCRE, whereas in Perl, $ and @ cause\nvariable interpolation. Note the following examples:\n\nPattern PCRE\nmatches Perl matches\n\n\\Qabc$xyz\\E\nabc$xyz abc followed by the <br>\ncontents of $xyz <br>\n\\Qabc\\$xyz\\E abc\\$xyz abc\\$xyz <br>\n\\Qabc\\E\\$\\Qxyz\\E abc$xyz abc$xyz\n\nThe \\Q...\\E\nsequence is recognized both inside and outside character\nclasses. An isolated \\E that is not preceded by \\Q is\nignored. If \\Q is not followed by \\E later in the pattern,\nthe literal interpretation continues to the end of the\npattern (that is, \\E is assumed at the end). If the isolated\n\\Q is inside a character class, this causes an error,\nbecause the character class is not terminated.\n\n\n<b>Non-printing\ncharacters</b>\n\nA second use of\nbackslash provides a way of encoding non-printing characters\nin patterns in a visible manner. There is no restriction on\nthe appearance of non-printing characters, apart from the\nbinary zero that terminates a pattern, but when a pattern is\nbeing prepared by text editing, it is often easier to use\none of the following escape sequences than the binary\ncharacter it represents. In an ASCII or Unicode environment,\nthese escapes are as follows:\n\n\\a alarm, that\nis, the BEL character (hex 07) <br>\n\\cx &quot;control-x&quot;, where x is any ASCII character\n<br>\n\\e escape (hex 1B) <br>\n\\f form feed (hex 0C) <br>\n\\n linefeed (hex 0A) <br>\n\\r carriage return (hex 0D) <br>\n\\t tab (hex 09) <br>\n\\0dd character with octal code 0dd <br>\n\\ddd character with octal code ddd, or back reference <br>\n\\o{ddd..} character with octal code ddd.. <br>\n\\xhh character with hex code hh <br>\n\\x{hhh..} character with hex code hhh.. (non-JavaScript\nmode) <br>\n\\uhhhh character with hex code hhhh (JavaScript mode\nonly)\n\nThe precise\neffect of \\cx on ASCII characters is as follows: if x is a\nlower case letter, it is converted to upper case. Then bit 6\nof the character (hex 40) is inverted. Thus \\cA to \\cZ\nbecome hex 01 to hex 1A (A is 41, Z is 5A), but \\c{ becomes\nhex 3B ({ is 7B), and \\c; becomes hex 7B (; is 3B). If the\ndata item (byte or 16-bit value) following \\c has a value\ngreater than 127, a compile-time error occurs. This locks\nout non-ASCII characters in all modes.\n\nWhen PCRE is\ncompiled in EBCDIC mode, \\a, \\e, \\f, \\n, \\r, and \\t generate\nthe appropriate EBCDIC code values. The \\c escape is\nprocessed as specified for Perl in the <b>perlebcdic</b>\ndocument. The only characters that are allowed after \\c are\nA-Z, a-z, or one of @, [, \\, ], ^, _, or ?. Any other\ncharacter provokes a compile-time error. The sequence \\@\nencodes character code 0; the letters (in either case)\nencode characters 1-26 (hex 01 to hex 1A); [, \\, ], ^, and _\nencode characters 27-31 (hex 1B to hex 1F), and \\? becomes\neither 255 (hex FF) or 95 (hex 5F).\n\nThus, apart\nfrom \\?, these escapes generate the same character code\nvalues as they do in an ASCII environment, though the\nmeanings of the values mostly differ. For example, \\G always\ngenerates code value 7, which is BEL in ASCII but DEL in\nEBCDIC.\n\nThe sequence \\?\ngenerates DEL (127, hex 7F) in an ASCII environment, but\nbecause 127 is not a control character in EBCDIC, Perl makes\nit generate the APC character. Unfortunately, there are\nseveral variants of EBCDIC. In most of them the APC\ncharacter has the value 255 (hex FF), but in the one Perl\ncalls POSIX-BC its value is 95 (hex 5F). If certain other\ncharacters have POSIX-BC values, PCRE makes \\? generate 95;\notherwise it generates 255.\n\nAfter \\0 up to\ntwo further octal digits are read. If there are fewer than\ntwo digits, just those that are present are used. Thus the\nsequence \\0\\x\\015 specifies two binary zeros followed by a\nCR character (code value 13). Make sure you supply two\ndigits after the initial zero if the pattern character that\nfollows is itself an octal digit.\n\nThe escape \\o\nmust be followed by a sequence of octal digits, enclosed in\nbraces. An error occurs if this is not the case. This escape\nis a recent addition to Perl; it provides way of specifying\ncharacter code points as octal numbers greater than 0777,\nand it also allows octal numbers and back references to be\nunambiguously specified.\n\nFor greater\nclarity and unambiguity, it is best to avoid following \\ by\na digit greater than zero. Instead, use \\o{} or \\x{} to\nspecify character numbers, and \\g{} to specify back\nreferences. The following paragraphs describe the old,\nambiguous syntax.\n\nThe handling of\na backslash followed by a digit other than 0 is complicated,\nand Perl has changed in recent releases, causing PCRE also\nto change. Outside a character class, PCRE reads the digit\nand any following digits as a decimal number. If the number\nis less than 8, or if there have been at least that many\nprevious capturing left parentheses in the expression, the\nentire sequence is taken as a <i>back reference</i>. A\ndescription of how this works is given later, following the\ndiscussion of parenthesized subpatterns.\n\nInside a\ncharacter class, or if the decimal number following \\ is\ngreater than 7 and there have not been that many capturing\nsubpatterns, PCRE handles \\8 and \\9 as the literal\ncharacters &quot;8&quot; and &quot;9&quot;, and otherwise\nre-reads up to three octal digits following the backslash,\nusing them to generate a data character. Any subsequent\ndigits stand for themselves. For example:\n\n\\040 is another\nway of writing an ASCII space <br>\n\\40 is the same, provided there are fewer than 40 <br>\nprevious capturing subpatterns <br>\n\\7 is always a back reference <br>\n\\11 might be a back reference, or another way of <br>\nwriting a tab <br>\n\\011 is always a tab <br>\n\\0113 is a tab followed by the character &quot;3&quot; <br>\n\\113 might be a back reference, otherwise the <br>\ncharacter with octal code 113 <br>\n\\377 might be a back reference, otherwise <br>\nthe value 255 (decimal) <br>\n\\81 is either a back reference, or the two <br>\ncharacters &quot;8&quot; and &quot;1&quot;\n\nNote that octal\nvalues of 100 or greater that are specified using this\nsyntax must not be introduced by a leading zero, because no\nmore than three octal digits are ever read.\n\nBy default,\nafter \\x that is not followed by {, from zero to two\nhexadecimal digits are read (letters can be in upper or\nlower case). Any number of hexadecimal digits may appear\nbetween \\x{ and }. If a character other than a hexadecimal\ndigit appears between \\x{ and }, or if there is no\nterminating }, an error occurs.\n\nIf the\nPCRE_JAVASCRIPT_COMPAT option is set, the interpretation of\n\\x is as just described only when it is followed by two\nhexadecimal digits. Otherwise, it matches a literal\n&quot;x&quot; character. In JavaScript mode, support for\ncode points greater than 256 is provided by \\u, which must\nbe followed by four hexadecimal digits; otherwise it matches\na literal &quot;u&quot; character.\n\nCharacters\nwhose value is less than 256 can be defined by either of the\ntwo syntaxes for \\x (or by \\u in JavaScript mode). There is\nno difference in the way they are handled. For example, \\xdc\nis exactly the same as \\x{dc} (or \\u00dc in JavaScript\nmode).\n\n<b>Constraints\non character values</b>\n\nCharacters that\nare specified using octal or hexadecimal numbers are limited\nto certain values, as follows:\n\n8-bit non-UTF\nmode less than 0x100 <br>\n8-bit UTF-8 mode less than 0x10ffff and a valid codepoint\n<br>\n16-bit non-UTF mode less than 0x10000 <br>\n16-bit UTF-16 mode less than 0x10ffff and a valid codepoint\n<br>\n32-bit non-UTF mode less than 0x100000000 <br>\n32-bit UTF-32 mode less than 0x10ffff and a valid\ncodepoint\n\nInvalid Unicode\ncodepoints are the range 0xd800 to 0xdfff (the so-called\n&quot;surrogate&quot; codepoints), and 0xffef.\n\n<b>Escape\nsequences in character classes</b>\n\nAll the\nsequences that define a single character value can be used\nboth inside and outside character classes. In addition,\ninside a character class, \\b is interpreted as the backspace\ncharacter (hex 08).\n\n\\N is not\nallowed in a character class. \\B, \\R, and \\X are not special\ninside a character class. Like other unrecognized escape\nsequences, they are treated as the literal characters\n&quot;B&quot;, &quot;R&quot;, and &quot;X&quot; by default,\nbut cause an error if the PCRE_EXTRA option is set. Outside\na character class, these sequences have different\nmeanings.\n\n<b>Unsupported\nescape sequences</b>\n\nIn Perl, the\nsequences \\l, \\L, \\u, and \\U are recognized by its string\nhandler and used to modify the case of following characters.\nBy default, PCRE does not support these escape sequences.\nHowever, if the PCRE_JAVASCRIPT_COMPAT option is set, \\U\nmatches a &quot;U&quot; character, and \\u can be used to\ndefine a character by code point, as described in the\nprevious section.\n\n<b>Absolute and\nrelative back references</b>\n\nThe sequence \\g\nfollowed by an unsigned or a negative number, optionally\nenclosed in braces, is an absolute or relative back\nreference. A named back reference can be coded as \\g{name}.\nBack references are discussed later, following the\ndiscussion of parenthesized subpatterns.\n\n<b>Absolute and\nrelative subroutine calls</b>\n\nFor\ncompatibility with Oniguruma, the non-Perl syntax \\g\nfollowed by a name or a number enclosed either in angle\nbrackets or single quotes, is an alternative syntax for\nreferencing a subpattern as a &quot;subroutine&quot;.\nDetails are discussed later. Note that \\g{...} (Perl syntax)\nand \\g&lt;...&gt; (Oniguruma syntax) are <i>not</i>\nsynonymous. The former is a back reference; the latter is a\nsubroutine call.\n\n<b>Generic\ncharacter types</b>\n\nAnother use of\nbackslash is for specifying generic character types:\n\n\\d any decimal\ndigit <br>\n\\D any character that is not a decimal digit <br>\n\\h any horizontal white space character <br>\n\\H any character that is not a horizontal white space\ncharacter <br>\n\\s any white space character <br>\n\\S any character that is not a white space character <br>\n\\v any vertical white space character <br>\n\\V any character that is not a vertical white space\ncharacter <br>\n\\w any &quot;word&quot; character <br>\n\\W any &quot;non-word&quot; character\n\nThere is also\nthe single sequence \\N, which matches a non-newline\ncharacter. This is the same as the &quot;.&quot;\nmetacharacter when PCRE_DOTALL is not set. Perl also uses \\N\nto match characters by name; PCRE does not support this.\n\nEach pair of\nlower and upper case escape sequences partitions the\ncomplete set of characters into two disjoint sets. Any given\ncharacter matches one, and only one, of each pair. The\nsequences can appear both inside and outside character\nclasses. They each match one character of the appropriate\ntype. If the current matching point is at the end of the\nsubject string, all of them fail, because there is no\ncharacter to match.\n\nFor\ncompatibility with Perl, \\s did not used to match the VT\ncharacter (code 11), which made it different from the the\nPOSIX &quot;space&quot; class. However, Perl added VT at\nrelease 5.18, and PCRE followed suit at release 8.34. The\ndefault \\s characters are now HT (9), LF (10), VT (11), FF\n(12), CR (13), and space (32), which are defined as white\nspace in the &quot;C&quot; locale. This list may vary if\nlocale-specific matching is taking place. For example, in\nsome locales the &quot;non-breaking space&quot; character\n(\\xA0) is recognized as white space, and in others the VT\ncharacter is not.\n\nA\n&quot;word&quot; character is an underscore or any character\nthat is a letter or digit. By default, the definition of\nletters and digits is controlled by PCRE&rsquo;s low-valued\ncharacter tables, and may vary if locale-specific matching\nis taking place (see &quot;Locale support&quot; in the\n<b>pcreapi</b> page). For example, in a French locale such\nas &quot;fr_FR&quot; in Unix-like systems, or\n&quot;french&quot; in Windows, some character codes greater\nthan 127 are used for accented letters, and these are then\nmatched by \\w. The use of locales with Unicode is\ndiscouraged.\n\nBy default,\ncharacters whose code points are greater than 127 never\nmatch \\d, \\s, or \\w, and always match \\D, \\S, and \\W,\nalthough this may vary for characters in the range 128-255\nwhen locale-specific matching is happening. These escape\nsequences retain their original meanings from before Unicode\nsupport was available, mainly for efficiency reasons. If\nPCRE is compiled with Unicode property support, and the\nPCRE_UCP option is set, the behaviour is changed so that\nUnicode properties are used to determine character types, as\nfollows:\n\n\\d any\ncharacter that matches \\p{Nd} (decimal digit) <br>\n\\s any character that matches \\p{Z} or \\h or \\v <br>\n\\w any character that matches \\p{L} or \\p{N}, plus\nunderscore\n\nThe upper case\nescapes match the inverse sets of characters. Note that \\d\nmatches only decimal digits, whereas \\w matches any Unicode\ndigit, as well as any Unicode letter, and underscore. Note\nalso that PCRE_UCP affects \\b, and \\B because they are\ndefined in terms of \\w and \\W. Matching these sequences is\nnoticeably slower when PCRE_UCP is set.\n\nThe sequences\n\\h, \\H, \\v, and \\V are features that were added to Perl at\nrelease 5.10. In contrast to the other sequences, which\nmatch only ASCII characters by default, these always match\ncertain high-valued code points, whether or not PCRE_UCP is\nset. The horizontal space characters are:\n\nU+0009\nHorizontal tab (HT) <br>\nU+0020 Space <br>\nU+00A0 Non-break space <br>\nU+1680 Ogham space mark <br>\nU+180E Mongolian vowel separator <br>\nU+2000 En quad <br>\nU+2001 Em quad <br>\nU+2002 En space <br>\nU+2003 Em space <br>\nU+2004 Three-per-em space <br>\nU+2005 Four-per-em space <br>\nU+2006 Six-per-em space <br>\nU+2007 Figure space <br>\nU+2008 Punctuation space <br>\nU+2009 Thin space <br>\nU+200A Hair space <br>\nU+202F Narrow no-break space <br>\nU+205F Medium mathematical space <br>\nU+3000 Ideographic space\n\nThe vertical\nspace characters are:\n\nU+000A Linefeed\n(LF) <br>\nU+000B Vertical tab (VT) <br>\nU+000C Form feed (FF) <br>\nU+000D Carriage return (CR) <br>\nU+0085 Next line (NEL) <br>\nU+2028 Line separator <br>\nU+2029 Paragraph separator\n\nIn 8-bit,\nnon-UTF-8 mode, only the characters with codepoints less\nthan 256 are relevant.\n\n<b>Newline\nsequences</b>\n\nOutside a\ncharacter class, by default, the escape sequence \\R matches\nany Unicode newline sequence. In 8-bit non-UTF-8 mode \\R is\nequivalent to the following:\n\n\n(?&gt;\\r\\n|\\n|\\x0b|\\f|\\r|\\x85)\n\nThis is an\nexample of an &quot;atomic group&quot;, details of which are\ngiven below. This particular group matches either the\ntwo-character sequence CR followed by LF, or one of the\nsingle characters LF (linefeed, U+000A), VT (vertical tab,\nU+000B), FF (form feed, U+000C), CR (carriage return,\nU+000D), or NEL (next line, U+0085). The two-character\nsequence is treated as a single unit that cannot be\nsplit.\n\nIn other modes,\ntwo additional characters whose codepoints are greater than\n255 are added: LS (line separator, U+2028) and PS (paragraph\nseparator, U+2029). Unicode character property support is\nnot needed for these characters to be recognized.\n\nIt is possible\nto restrict \\R to match only CR, LF, or CRLF (instead of the\ncomplete set of Unicode line endings) by setting the option\nPCRE_BSR_ANYCRLF either at compile time or when the pattern\nis matched. (BSR is an abbrevation for &quot;backslash\nR&quot;.) This can be made the default when PCRE is built;\nif this is the case, the other behaviour can be requested\nvia the PCRE_BSR_UNICODE option. It is also possible to\nspecify these settings by starting a pattern string with one\nof the following sequences:\n\n(*BSR_ANYCRLF)\nCR, LF, or CRLF only <br>\n(*BSR_UNICODE) any Unicode newline sequence\n\nThese override\nthe default and the options given to the compiling function,\nbut they can themselves be overridden by options given to a\nmatching function. Note that these special settings, which\nare not Perl-compatible, are recognized only at the very\nstart of a pattern, and that they must be in upper case. If\nmore than one of them is present, the last one is used. They\ncan be combined with a change of newline convention; for\nexample, a pattern can start with:\n\n\n(*ANY)(*BSR_ANYCRLF)\n\nThey can also\nbe combined with the (*UTF8), (*UTF16), (*UTF32), (*UTF) or\n(*UCP) special sequences. Inside a character class, \\R is\ntreated as an unrecognized escape sequence, and so matches\nthe letter &quot;R&quot; by default, but causes an error if\nPCRE_EXTRA is set.\n\n<b>Unicode\ncharacter properties</b>\n\nWhen PCRE is\nbuilt with Unicode character property support, three\nadditional escape sequences that match characters with\nspecific properties are available. When in 8-bit non-UTF-8\nmode, these sequences are of course limited to testing\ncharacters whose codepoints are less than 256, but they do\nwork in this mode. The extra escape sequences are:\n\n\\p{<i>xx</i>} a\ncharacter with the <i>xx</i> property <br>\n\\P{<i>xx</i>} a character without the <i>xx</i> property\n<br>\n\\X a Unicode extended grapheme cluster\n\nThe property\nnames represented by <i>xx</i> above are limited to the\nUnicode script names, the general category properties,\n&quot;Any&quot;, which matches any character (including\nnewline), and some special PCRE properties (described in the\nnext section). Other Perl properties such as\n&quot;InMusicalSymbols&quot; are not currently supported by\nPCRE. Note that \\P{Any} does not match any characters, so\nalways causes a match failure.\n\nSets of Unicode\ncharacters are defined as belonging to certain scripts. A\ncharacter from one of these sets can be matched using a\nscript name. For example:\n\n\\p{Greek} <br>\n\\P{Han}\n\nThose that are\nnot part of an identified script are lumped together as\n&quot;Common&quot;. The current list of scripts is:\n\nArabic,\nArmenian, Avestan, Balinese, Bamum, Bassa_Vah, Batak,\nBengali, Bopomofo, Brahmi, Braille, Buginese, Buhid,\nCanadian_Aboriginal, Carian, Caucasian_Albanian, Chakma,\nCham, Cherokee, Common, Coptic, Cuneiform, Cypriot,\nCyrillic, Deseret, Devanagari, Duployan,\nEgyptian_Hieroglyphs, Elbasan, Ethiopic, Georgian,\nGlagolitic, Gothic, Grantha, Greek, Gujarati, Gurmukhi, Han,\nHangul, Hanunoo, Hebrew, Hiragana, Imperial_Aramaic,\nInherited, Inscriptional_Pahlavi, Inscriptional_Parthian,\nJavanese, Kaithi, Kannada, Katakana, Kayah_Li, Kharoshthi,\nKhmer, Khojki, Khudawadi, Lao, Latin, Lepcha, Limbu,\nLinear_A, Linear_B, Lisu, Lycian, Lydian, Mahajani,\nMalayalam, Mandaic, Manichaean, Meetei_Mayek, Mende_Kikakui,\nMeroitic_Cursive, Meroitic_Hieroglyphs, Miao, Modi,\nMongolian, Mro, Myanmar, Nabataean, New_Tai_Lue, Nko, Ogham,\nOl_Chiki, Old_Italic, Old_North_Arabian, Old_Permic,\nOld_Persian, Old_South_Arabian, Old_Turkic, Oriya, Osmanya,\nPahawh_Hmong, Palmyrene, Pau_Cin_Hau, Phags_Pa, Phoenician,\nPsalter_Pahlavi, Rejang, Runic, Samaritan, Saurashtra,\nSharada, Shavian, Siddham, Sinhala, Sora_Sompeng, Sundanese,\nSyloti_Nagri, Syriac, Tagalog, Tagbanwa, Tai_Le, Tai_Tham,\nTai_Viet, Takri, Tamil, Telugu, Thaana, Thai, Tibetan,\nTifinagh, Tirhuta, Ugaritic, Vai, Warang_Citi, Yi.\n\nEach character\nhas exactly one Unicode general category property, specified\nby a two-letter abbreviation. For compatibility with Perl,\nnegation can be specified by including a circumflex between\nthe opening brace and the property name. For example,\n\\p{^Lu} is the same as \\P{Lu}.\n\nIf only one\nletter is specified with \\p or \\P, it includes all the\ngeneral category properties that start with that letter. In\nthis case, in the absence of negation, the curly brackets in\nthe escape sequence are optional; these two examples have\nthe same effect:\n\n\\p{L} <br>\n\\pL\n\nThe following\ngeneral category property codes are supported:\n\nC Other <br>\nCc Control <br>\nCf Format <br>\nCn Unassigned <br>\nCo Private use <br>\nCs Surrogate\n\nL Letter <br>\nLl Lower case letter <br>\nLm Modifier letter <br>\nLo Other letter <br>\nLt Title case letter <br>\nLu Upper case letter\n\nM Mark <br>\nMc Spacing mark <br>\nMe Enclosing mark <br>\nMn Non-spacing mark\n\nN Number <br>\nNd Decimal number <br>\nNl Letter number <br>\nNo Other number\n\nP Punctuation\n<br>\nPc Connector punctuation <br>\nPd Dash punctuation <br>\nPe Close punctuation <br>\nPf Final punctuation <br>\nPi Initial punctuation <br>\nPo Other punctuation <br>\nPs Open punctuation\n\nS Symbol <br>\nSc Currency symbol <br>\nSk Modifier symbol <br>\nSm Mathematical symbol <br>\nSo Other symbol\n\nZ Separator\n<br>\nZl Line separator <br>\nZp Paragraph separator <br>\nZs Space separator\n\nThe special\nproperty L&amp; is also supported: it matches a character\nthat has the Lu, Ll, or Lt property, in other words, a\nletter that is not classified as a modifier or\n&quot;other&quot;.\n\nThe Cs\n(Surrogate) property applies only to characters in the range\nU+D800 to U+DFFF. Such characters are not valid in Unicode\nstrings and so cannot be tested by PCRE, unless UTF validity\nchecking has been turned off (see the discussion of\nPCRE_NO_UTF8_CHECK, PCRE_NO_UTF16_CHECK and\nPCRE_NO_UTF32_CHECK in the <b>pcreapi</b> page). Perl does\nnot support the Cs property.\n\nThe long\nsynonyms for property names that Perl supports (such as\n\\p{Letter}) are not supported by PCRE, nor is it permitted\nto prefix any of these properties with &quot;Is&quot;.\n\nNo character\nthat is in the Unicode table has the Cn (unassigned)\nproperty. Instead, this property is assumed for any code\npoint that is not in the Unicode table.\n\nSpecifying\ncaseless matching does not affect these escape sequences.\nFor example, \\p{Lu} always matches only upper case letters.\nThis is different from the behaviour of current versions of\nPerl.\n\nMatching\ncharacters by Unicode property is not fast, because PCRE has\nto do a multistage table lookup in order to find a\ncharacter&rsquo;s property. That is why the traditional\nescape sequences such as \\d and \\w do not use Unicode\nproperties in PCRE by default, though you can make them do\nso by setting the PCRE_UCP option or by starting the pattern\nwith (*UCP).\n\n<b>Extended\ngrapheme clusters</b>\n\nThe \\X escape\nmatches any number of Unicode characters that form an\n&quot;extended grapheme cluster&quot;, and treats the\nsequence as an atomic group (see below). Up to and including\nrelease 8.31, PCRE matched an earlier, simpler definition\nthat was equivalent to\n\n\n(?&gt;\\PM\\pM*)\n\nThat is, it\nmatched a character without the &quot;mark&quot; property,\nfollowed by zero or more characters with the\n&quot;mark&quot; property. Characters with the\n&quot;mark&quot; property are typically non-spacing accents\nthat affect the preceding character.\n\nThis simple\ndefinition was extended in Unicode to include more\ncomplicated kinds of composite character by giving each\ncharacter a grapheme breaking property, and creating rules\nthat use these properties to define the boundaries of\nextended grapheme clusters. In releases of PCRE later than\n8.31, \\X matches one of these clusters.\n\n\\X always\nmatches at least one character. Then it decides whether to\nadd additional characters according to the following rules\nfor ending a cluster:\n\n1. End at the\nend of the subject string.\n\n2. Do not end\nbetween CR and LF; otherwise end after any control\ncharacter.\n\n3. Do not break\nHangul (a Korean script) syllable sequences. Hangul\ncharacters are of five types: L, V, T, LV, and LVT. An L\ncharacter may be followed by an L, V, LV, or LVT character;\nan LV or V character may be followed by a V or T character;\nan LVT or T character may be follwed only by a T\ncharacter.\n\n4. Do not end\nbefore extending characters or spacing marks. Characters\nwith the &quot;mark&quot; property always have the\n&quot;extend&quot; grapheme breaking property.\n\n5. Do not end\nafter prepend characters.\n\n6. Otherwise,\nend the cluster.\n\n\n<b>PCRE&rsquo;s\nadditional properties</b>\n\nAs well as the\nstandard Unicode properties described above, PCRE supports\nfour more that make it possible to convert traditional\nescape sequences such as \\w and \\s to use Unicode\nproperties. PCRE uses these non-standard, non-Perl\nproperties internally when PCRE_UCP is set. However, they\nmay also be used explicitly. These properties are:\n\nXan Any\nalphanumeric character <br>\nXps Any POSIX space character <br>\nXsp Any Perl space character <br>\nXwd Any Perl &quot;word&quot; character\n\nXan matches\ncharacters that have either the L (letter) or the N (number)\nproperty. Xps matches the characters tab, linefeed, vertical\ntab, form feed, or carriage return, and any other character\nthat has the Z (separator) property. Xsp is the same as Xps;\nit used to exclude vertical tab, for Perl compatibility, but\nPerl changed, and so PCRE followed at release 8.34. Xwd\nmatches the same characters as Xan, plus underscore.\n\nThere is\nanother non-standard property, Xuc, which matches any\ncharacter that can be represented by a Universal Character\nName in C++ and other programming languages. These are the\ncharacters $, @, &rsquo; (grave accent), and all characters\nwith Unicode code points greater than or equal to U+00A0,\nexcept for the surrogates U+D800 to U+DFFF. Note that most\nbase (ASCII) characters are excluded. (Universal Character\nNames are of the form \\uHHHH or \\UHHHHHHHH where H is a\nhexadecimal digit. Note that the Xuc property does not match\nthese sequences but the characters that they represent.)\n\n<b>Resetting\nthe match start</b>\n\nThe escape\nsequence \\K causes any previously matched characters not to\nbe included in the final matched sequence. For example, the\npattern:\n\nfoo\\Kbar\n\nmatches\n&quot;foobar&quot;, but reports that it has matched\n&quot;bar&quot;. This feature is similar to a lookbehind\nassertion (described below). However, in this case, the part\nof the subject before the real match does not have to be of\nfixed length, as lookbehind assertions do. The use of \\K\ndoes not interfere with the setting of captured substrings.\nFor example, when the pattern\n\n(foo)\\Kbar\n\nmatches\n&quot;foobar&quot;, the first substring is still set to\n&quot;foo&quot;.\n\nPerl documents\nthat the use of \\K within assertions is &quot;not well\ndefined&quot;. In PCRE, \\K is acted upon when it occurs\ninside positive assertions, but is ignored in negative\nassertions. Note that when a pattern such as (?=ab\\K)\nmatches, the reported start of the match can be greater than\nthe end of the match.\n\n<b>Simple\nassertions</b>\n\nThe final use\nof backslash is for certain simple assertions. An assertion\nspecifies a condition that has to be met at a particular\npoint in a match, without consuming any characters from the\nsubject string. The use of subpatterns for more complicated\nassertions is described below. The backslashed assertions\nare:\n\n\\b matches at a\nword boundary <br>\n\\B matches when not at a word boundary <br>\n\\A matches at the start of the subject <br>\n\\Z matches at the end of the subject <br>\nalso matches before a newline at the end of the subject <br>\n\\z matches only at the end of the subject <br>\n\\G matches at the first matching position in the subject\n\nInside a\ncharacter class, \\b has a different meaning; it matches the\nbackspace character. If any other of these assertions\nappears in a character class, by default it matches the\ncorresponding literal character (for example, \\B matches the\nletter B). However, if the PCRE_EXTRA option is set, an\n&quot;invalid escape sequence&quot; error is generated\ninstead.\n\nA word boundary\nis a position in the subject string where the current\ncharacter and the previous character do not both match \\w or\n\\W (i.e. one matches \\w and the other matches \\W), or the\nstart or end of the string if the first or last character\nmatches \\w, respectively. In a UTF mode, the meanings of \\w\nand \\W can be changed by setting the PCRE_UCP option. When\nthis is done, it also affects \\b and \\B. Neither PCRE nor\nPerl has a separate &quot;start of word&quot; or &quot;end\nof word&quot; metasequence. However, whatever follows \\b\nnormally determines which it is. For example, the fragment\n\\ba matches &quot;a&quot; at the start of a word.\n\nThe \\A, \\Z, and\n\\z assertions differ from the traditional circumflex and\ndollar (described in the next section) in that they only\never match at the very start and end of the subject string,\nwhatever options are set. Thus, they are independent of\nmultiline mode. These three assertions are not affected by\nthe PCRE_NOTBOL or PCRE_NOTEOL options, which affect only\nthe behaviour of the circumflex and dollar metacharacters.\nHowever, if the <i>startoffset</i> argument of\n<b>pcre_exec()</b> is non-zero, indicating that matching is\nto start at a point other than the beginning of the subject,\n\\A can never match. The difference between \\Z and \\z is that\n\\Z matches before a newline at the end of the string as well\nas at the very end, whereas \\z matches only at the end.\n\nThe \\G\nassertion is true only when the current matching position is\nat the start point of the match, as specified by the\n<i>startoffset</i> argument of <b>pcre_exec()</b>. It\ndiffers from \\A when the value of <i>startoffset</i> is\nnon-zero. By calling <b>pcre_exec()</b> multiple times with\nappropriate arguments, you can mimic Perl&rsquo;s /g option,\nand it is in this kind of implementation where \\G can be\nuseful.\n\nNote, however,\nthat PCRE&rsquo;s interpretation of \\G, as the start of the\ncurrent match, is subtly different from Perl&rsquo;s, which\ndefines it as the end of the previous match. In Perl, these\ncan be different when the previously matched string was\nempty. Because PCRE does just one match at a time, it cannot\nreproduce this behaviour.\n\nIf all the\nalternatives of a pattern begin with \\G, the expression is\nanchored to the starting match position, and the\n&quot;anchored&quot; flag is set in the compiled regular\nexpression.\n\n<h2>CIRCUMFLEX AND DOLLAR\n<a name=\"CIRCUMFLEX AND DOLLAR\"></a>\n</h2>\n\n\nThe circumflex\nand dollar metacharacters are zero-width assertions. That\nis, they test for a particular condition being true without\nconsuming any characters from the subject string.\n\nOutside a\ncharacter class, in the default matching mode, the\ncircumflex character is an assertion that is true only if\nthe current matching point is at the start of the subject\nstring. If the <i>startoffset</i> argument of\n<b>pcre_exec()</b> is non-zero, circumflex can never match\nif the PCRE_MULTILINE option is unset. Inside a character\nclass, circumflex has an entirely different meaning (see\nbelow).\n\nCircumflex need\nnot be the first character of the pattern if a number of\nalternatives are involved, but it should be the first thing\nin each alternative in which it appears if the pattern is\never to match that branch. If all possible alternatives\nstart with a circumflex, that is, if the pattern is\nconstrained to match only at the start of the subject, it is\nsaid to be an &quot;anchored&quot; pattern. (There are also\nother constructs that can cause a pattern to be\nanchored.)\n\nThe dollar\ncharacter is an assertion that is true only if the current\nmatching point is at the end of the subject string, or\nimmediately before a newline at the end of the string (by\ndefault). Note, however, that it does not actually match the\nnewline. Dollar need not be the last character of the\npattern if a number of alternatives are involved, but it\nshould be the last item in any branch in which it appears.\nDollar has no special meaning in a character class.\n\nThe meaning of\ndollar can be changed so that it matches only at the very\nend of the string, by setting the PCRE_DOLLAR_ENDONLY option\nat compile time. This does not affect the \\Z assertion.\n\nThe meanings of\nthe circumflex and dollar characters are changed if the\nPCRE_MULTILINE option is set. When this is the case, a\ncircumflex matches immediately after internal newlines as\nwell as at the start of the subject string. It does not\nmatch after a newline that ends the string. A dollar matches\nbefore any newlines in the string, as well as at the very\nend, when PCRE_MULTILINE is set. When newline is specified\nas the two-character sequence CRLF, isolated CR and LF\ncharacters do not indicate newlines.\n\nFor example,\nthe pattern /^abc$/ matches the subject string\n&quot;def\\nabc&quot; (where \\n represents a newline) in\nmultiline mode, but not otherwise. Consequently, patterns\nthat are anchored in single line mode because all branches\nstart with ^ are not anchored in multiline mode, and a match\nfor circumflex is possible when the <i>startoffset</i>\nargument of <b>pcre_exec()</b> is non-zero. The\nPCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is\nset.\n\nNote that the\nsequences \\A, \\Z, and \\z can be used to match the start and\nend of the subject in both modes, and if all branches of a\npattern start with \\A it is always anchored, whether or not\nPCRE_MULTILINE is set.\n\n<h2>FULL STOP (PERIOD, DOT) AND \\N\n<a name=\"FULL STOP (PERIOD, DOT) AND \\N\"></a>\n</h2>\n\n\nOutside a\ncharacter class, a dot in the pattern matches any one\ncharacter in the subject string except (by default) a\ncharacter that signifies the end of a line.\n\nWhen a line\nending is defined as a single character, dot never matches\nthat character; when the two-character sequence CRLF is\nused, dot does not match CR if it is immediately followed by\nLF, but otherwise it matches all characters (including\nisolated CRs and LFs). When any Unicode line endings are\nbeing recognized, dot does not match CR or LF or any of the\nother line ending characters.\n\nThe behaviour\nof dot with regard to newlines can be changed. If the\nPCRE_DOTALL option is set, a dot matches any one character,\nwithout exception. If the two-character sequence CRLF is\npresent in the subject string, it takes two dots to match\nit.\n\nThe handling of\ndot is entirely independent of the handling of circumflex\nand dollar, the only relationship being that they both\ninvolve newlines. Dot has no special meaning in a character\nclass.\n\nThe escape\nsequence \\N behaves like a dot, except that it is not\naffected by the PCRE_DOTALL option. In other words, it\nmatches any character except one that signifies the end of a\nline. Perl also uses \\N to match characters by name; PCRE\ndoes not support this.\n\n<h2>MATCHING A SINGLE DATA UNIT\n<a name=\"MATCHING A SINGLE DATA UNIT\"></a>\n</h2>\n\n\nOutside a\ncharacter class, the escape sequence \\C matches any one data\nunit, whether or not a UTF mode is set. In the 8-bit\nlibrary, one data unit is one byte; in the 16-bit library it\nis a 16-bit unit; in the 32-bit library it is a 32-bit unit.\nUnlike a dot, \\C always matches line-ending characters. The\nfeature is provided in Perl in order to match individual\nbytes in UTF-8 mode, but it is unclear how it can usefully\nbe used. Because \\C breaks up characters into individual\ndata units, matching one unit with \\C in a UTF mode means\nthat the rest of the string may start with a malformed UTF\ncharacter. This has undefined results, because PCRE assumes\nthat it is dealing with valid UTF strings (and by default it\nchecks this at the start of processing unless the\nPCRE_NO_UTF8_CHECK, PCRE_NO_UTF16_CHECK or\nPCRE_NO_UTF32_CHECK option is used).\n\nPCRE does not\nallow \\C to appear in lookbehind assertions (described\nbelow) in a UTF mode, because this would make it impossible\nto calculate the length of the lookbehind.\n\nIn general, the\n\\C escape sequence is best avoided. However, one way of\nusing it that avoids the problem of malformed UTF characters\nis to use a lookahead to check the length of the next\ncharacter, as in this pattern, which could be used with a\nUTF-8 string (ignore white space and line breaks):\n\n(?|\n(?=[\\x00-\\x7f])(\\C) | <br>\n(?=[\\x80-\\x{7ff}])(\\C)(\\C) | <br>\n(?=[\\x{800}-\\x{ffff}])(\\C)(\\C)(\\C) | <br>\n(?=[\\x{10000}-\\x{1fffff}])(\\C)(\\C)(\\C)(\\C))\n\nA group that\nstarts with (?| resets the capturing parentheses numbers in\neach alternative (see &quot;Duplicate Subpattern\nNumbers&quot; below). The assertions at the start of each\nbranch check the next UTF-8 character for values whose\nencoding uses 1, 2, 3, or 4 bytes, respectively. The\ncharacter&rsquo;s individual bytes are then captured by the\nappropriate number of groups.\n\n<h2>SQUARE BRACKETS AND CHARACTER CLASSES\n<a name=\"SQUARE BRACKETS AND CHARACTER CLASSES\"></a>\n</h2>\n\n\nAn opening\nsquare bracket introduces a character class, terminated by a\nclosing square bracket. A closing square bracket on its own\nis not special by default. However, if the\nPCRE_JAVASCRIPT_COMPAT option is set, a lone closing square\nbracket causes a compile-time error. If a closing square\nbracket is required as a member of the class, it should be\nthe first data character in the class (after an initial\ncircumflex, if present) or escaped with a backslash.\n\nA character\nclass matches a single character in the subject. In a UTF\nmode, the character may be more than one data unit long. A\nmatched character must be in the set of characters defined\nby the class, unless the first character in the class\ndefinition is a circumflex, in which case the subject\ncharacter must not be in the set defined by the class. If a\ncircumflex is actually required as a member of the class,\nensure it is not the first character, or escape it with a\nbackslash.\n\nFor example,\nthe character class [aeiou] matches any lower case vowel,\nwhile [^aeiou] matches any character that is not a lower\ncase vowel. Note that a circumflex is just a convenient\nnotation for specifying the characters that are in the class\nby enumerating those that are not. A class that starts with\na circumflex is not an assertion; it still consumes a\ncharacter from the subject string, and therefore it fails if\nthe current pointer is at the end of the string.\n\nIn UTF-8\n(UTF-16, UTF-32) mode, characters with values greater than\n255 (0xffff) can be included in a class as a literal string\nof data units, or by using the \\x{ escaping mechanism.\n\nWhen caseless\nmatching is set, any letters in a class represent both their\nupper case and lower case versions, so for example, a\ncaseless [aeiou] matches &quot;A&quot; as well as\n&quot;a&quot;, and a caseless [^aeiou] does not match\n&quot;A&quot;, whereas a caseful version would. In a UTF\nmode, PCRE always understands the concept of case for\ncharacters whose values are less than 128, so caseless\nmatching is always possible. For characters with higher\nvalues, the concept of case is supported if PCRE is compiled\nwith Unicode property support, but not otherwise. If you\nwant to use caseless matching in a UTF mode for characters\n128 and above, you must ensure that PCRE is compiled with\nUnicode property support as well as with UTF support.\n\nCharacters that\nmight indicate line breaks are never treated in any special\nway when matching character classes, whatever line-ending\nsequence is in use, and whatever setting of the PCRE_DOTALL\nand PCRE_MULTILINE options is used. A class such as [^a]\nalways matches one of these characters.\n\nThe minus\n(hyphen) character can be used to specify a range of\ncharacters in a character class. For example, [d-m] matches\nany letter between d and m, inclusive. If a minus character\nis required in a class, it must be escaped with a backslash\nor appear in a position where it cannot be interpreted as\nindicating a range, typically as the first or last character\nin the class, or immediately after a range. For example,\n[b-d-z] matches letters in the range b to d, a hyphen\ncharacter, or z.\n\nIt is not\npossible to have the literal character &quot;]&quot; as the\nend character of a range. A pattern such as [W-]46] is\ninterpreted as a class of two characters (&quot;W&quot; and\n&quot;-&quot;) followed by a literal string &quot;46]&quot;,\nso it would match &quot;W46]&quot; or &quot;-46]&quot;.\nHowever, if the &quot;]&quot; is escaped with a backslash it\nis interpreted as the end of range, so [W-\\]46] is\ninterpreted as a class containing a range followed by two\nother characters. The octal or hexadecimal representation of\n&quot;]&quot; can also be used to end a range.\n\nAn error is\ngenerated if a POSIX character class (see below) or an\nescape sequence other than one that defines a single\ncharacter appears at a point where a range ending character\nis expected. For example, [z-\\xff] is valid, but [A-\\d] and\n[A-[:digit:]] are not.\n\nRanges operate\nin the collating sequence of character values. They can also\nbe used for characters specified numerically, for example\n[\\000-\\037]. Ranges can include any characters that are\nvalid for the current mode.\n\nIf a range that\nincludes letters is used when caseless matching is set, it\nmatches the letters in either case. For example, [W-c] is\nequivalent to [][\\\\^_&rsquo;wxyzabc], matched caselessly,\nand in a non-UTF mode, if character tables for a French\nlocale are in use, [\\xc8-\\xcb] matches accented E characters\nin both cases. In UTF modes, PCRE supports the concept of\ncase for characters with values greater than 128 only when\nit is compiled with Unicode property support.\n\nThe character\nescape sequences \\d, \\D, \\h, \\H, \\p, \\P, \\s, \\S, \\v, \\V, \\w,\nand \\W may appear in a character class, and add the\ncharacters that they match to the class. For example,\n[\\dABCDEF] matches any hexadecimal digit. In UTF modes, the\nPCRE_UCP option affects the meanings of \\d, \\s, \\w and their\nupper case partners, just as it does when they appear\noutside a character class, as described in the section\nentitled &quot;Generic character types&quot; above. The\nescape sequence \\b has a different meaning inside a\ncharacter class; it matches the backspace character. The\nsequences \\B, \\N, \\R, and \\X are not special inside a\ncharacter class. Like any other unrecognized escape\nsequences, they are treated as the literal characters\n&quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and\n&quot;X&quot; by default, but cause an error if the\nPCRE_EXTRA option is set.\n\nA circumflex\ncan conveniently be used with the upper case character types\nto specify a more restricted set of characters than the\nmatching lower case type. For example, the class [^\\W_]\nmatches any letter or digit, but not underscore, whereas\n[\\w] includes underscore. A positive character class should\nbe read as &quot;something OR something OR ...&quot; and a\nnegative class as &quot;NOT something AND NOT something AND\nNOT ...&quot;.\n\nThe only\nmetacharacters that are recognized in character classes are\nbackslash, hyphen (only where it can be interpreted as\nspecifying a range), circumflex (only at the start), opening\nsquare bracket (only when it can be interpreted as\nintroducing a POSIX class name, or for a special\ncompatibility feature - see the next two sections), and the\nterminating closing square bracket. However, escaping other\nnon-alphanumeric characters does no harm.\n\n<h2>POSIX CHARACTER CLASSES\n<a name=\"POSIX CHARACTER CLASSES\"></a>\n</h2>\n\n\nPerl supports\nthe POSIX notation for character classes. This uses names\nenclosed by [: and :] within the enclosing square brackets.\nPCRE also supports this notation. For example,\n\n\n[01[:alpha:]%]\n\nmatches\n&quot;0&quot;, &quot;1&quot;, any alphabetic character, or\n&quot;%&quot;. The supported class names are:\n\nalnum letters\nand digits <br>\nalpha letters <br>\nascii character codes 0 - 127 <br>\nblank space or tab only <br>\ncntrl control characters <br>\ndigit decimal digits (same as \\d) <br>\ngraph printing characters, excluding space <br>\nlower lower case letters <br>\nprint printing characters, including space <br>\npunct printing characters, excluding letters and digits and\nspace <br>\nspace white space (the same as \\s from PCRE 8.34) <br>\nupper upper case letters <br>\nword &quot;word&quot; characters (same as \\w) <br>\nxdigit hexadecimal digits\n\nThe default\n&quot;space&quot; characters are HT (9), LF (10), VT (11),\nFF (12), CR (13), and space (32). If locale-specific\nmatching is taking place, the list of space characters may\nbe different; there may be fewer or more of them.\n&quot;Space&quot; used to be different to \\s, which did not\ninclude VT, for Perl compatibility. However, Perl changed at\nrelease 5.18, and PCRE followed at release 8.34.\n&quot;Space&quot; and \\s now match the same set of\ncharacters.\n\nThe name\n&quot;word&quot; is a Perl extension, and &quot;blank&quot;\nis a GNU extension from Perl 5.8. Another Perl extension is\nnegation, which is indicated by a ^ character after the\ncolon. For example,\n\n\n[12[:^digit:]]\n\nmatches\n&quot;1&quot;, &quot;2&quot;, or any non-digit. PCRE (and\nPerl) also recognize the POSIX syntax [.ch.] and [=ch=]\nwhere &quot;ch&quot; is a &quot;collating element&quot;, but\nthese are not supported, and an error is given if they are\nencountered.\n\nBy default,\ncharacters with values greater than 128 do not match any of\nthe POSIX character classes. However, if the PCRE_UCP option\nis passed to <b>pcre_compile()</b>, some of the classes are\nchanged so that Unicode character properties are used. This\nis achieved by replacing certain POSIX classes by other\nsequences, as follows:\n\n[:alnum:]\nbecomes \\p{Xan} <br>\n[:alpha:] becomes \\p{L} <br>\n[:blank:] becomes \\h <br>\n[:digit:] becomes \\p{Nd} <br>\n[:lower:] becomes \\p{Ll} <br>\n[:space:] becomes \\p{Xps} <br>\n[:upper:] becomes \\p{Lu} <br>\n[:word:] becomes \\p{Xwd}\n\nNegated\nversions, such as [:^alpha:] use \\P instead of \\p. Three\nother POSIX classes are handled specially in UCP mode:\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p>[:graph:]</td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>This matches characters that have glyphs that mark the\npage when printed. In Unicode property terms, it matches all\ncharacters with the L, M, N, P, S, or Cf properties, except\nfor: </td></tr>\n</table>\n\n<p style=\"margin-left:26%; margin-top: 1em\">U+061C Arabic\nLetter Mark <br>\nU+180E Mongolian Vowel Separator <br>\nU+2066 - U+2069 Various &quot;isolate&quot;s\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p style=\"margin-top: 1em\">[:print:]</td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\">This matches the same characters\nas [:graph:] plus space characters that are not controls,\nthat is, characters with the Zs property.</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p>[:punct:]</td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>This matches all characters that have the Unicode P\n(punctuation) property, plus those characters whose code\npoints are less than 128 that have the S (Symbol)\nproperty. </td></tr>\n</table>\n\nThe other POSIX\nclasses are unchanged, and match only characters with code\npoints less than 128.\n\n<h2>COMPATIBILITY FEATURE FOR WORD BOUNDARIES\n<a name=\"COMPATIBILITY FEATURE FOR WORD BOUNDARIES\"></a>\n</h2>\n\n\nIn the POSIX.2\ncompliant library that was included in 4.4BSD Unix, the ugly\nsyntax [[:&lt;:]] and [[:&gt;:]] is used for matching\n&quot;start of word&quot; and &quot;end of word&quot;. PCRE\ntreats these items as follows:\n\n[[:&lt;:]] is\nconverted to \\b(?=\\w) <br>\n[[:&gt;:]] is converted to \\b(?&lt;=\\w)\n\nOnly these\nexact character sequences are recognized. A sequence such as\n[a[:&lt;:]b] provokes error for an unrecognized POSIX class\nname. This support is not compatible with Perl. It is\nprovided to help migrations from other environments, and is\nbest not used in any new patterns. Note that \\b matches at\nthe start and the end of a word (see &quot;Simple\nassertions&quot; above), and in a Perl-style pattern the\npreceding or following character normally shows which is\nwanted, without the need for the assertions that are used\nabove in order to give exactly the POSIX behaviour.\n\n<h2>VERTICAL BAR\n<a name=\"VERTICAL BAR\"></a>\n</h2>\n\n\nVertical bar\ncharacters are used to separate alternative patterns. For\nexample, the pattern\n\n\ngilbert|sullivan\n\nmatches either\n&quot;gilbert&quot; or &quot;sullivan&quot;. Any number of\nalternatives may appear, and an empty alternative is\npermitted (matching the empty string). The matching process\ntries each alternative in turn, from left to right, and the\nfirst one that succeeds is used. If the alternatives are\nwithin a subpattern (defined below), &quot;succeeds&quot;\nmeans matching the rest of the main pattern as well as the\nalternative in the subpattern.\n\n<h2>INTERNAL OPTION SETTING\n<a name=\"INTERNAL OPTION SETTING\"></a>\n</h2>\n\n\nThe settings of\nthe PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and\nPCRE_EXTENDED options (which are Perl-compatible) can be\nchanged from within the pattern by a sequence of Perl option\nletters enclosed between &quot;(?&quot; and &quot;)&quot;.\nThe option letters are\n\ni for\nPCRE_CASELESS <br>\nm for PCRE_MULTILINE <br>\ns for PCRE_DOTALL <br>\nx for PCRE_EXTENDED\n\nFor example,\n(?im) sets caseless, multiline matching. It is also possible\nto unset these options by preceding the letter with a\nhyphen, and a combined setting and unsetting such as\n(?im-sx), which sets PCRE_CASELESS and PCRE_MULTILINE while\nunsetting PCRE_DOTALL and PCRE_EXTENDED, is also permitted.\nIf a letter appears both before and after the hyphen, the\noption is unset.\n\nThe\nPCRE-specific options PCRE_DUPNAMES, PCRE_UNGREEDY, and\nPCRE_EXTRA can be changed in the same way as the\nPerl-compatible options by using the characters J, U and X\nrespectively.\n\nWhen one of\nthese option changes occurs at top level (that is, not\ninside subpattern parentheses), the change applies to the\nremainder of the pattern that follows. If the change is\nplaced right at the start of a pattern, PCRE extracts it\ninto the global options (and it will therefore show up in\ndata extracted by the <b>pcre_fullinfo()</b> function).\n\nAn option\nchange within a subpattern (see below for a description of\nsubpatterns) affects only that part of the subpattern that\nfollows it, so\n\n(a(?i)b)c\n\nmatches abc and\naBc and no other strings (assuming PCRE_CASELESS is not\nused). By this means, options can be made to have different\nsettings in different parts of the pattern. Any changes made\nin one alternative do carry on into subsequent branches\nwithin the same subpattern. For example,\n\n(a(?i)b|c)\n\nmatches\n&quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;, and\n&quot;C&quot;, even though when matching &quot;C&quot; the\nfirst branch is abandoned before the option setting. This is\nbecause the effects of option settings happen at compile\ntime. There would be some very weird behaviour\notherwise.\n\n<b>Note:</b>\nThere are other PCRE-specific options that can be set by the\napplication when the compiling or matching functions are\ncalled. In some cases the pattern can contain special\nleading sequences such as (*CRLF) to override what the\napplication has set or what has been defaulted. Details are\ngiven in the section entitled &quot;Newline sequences&quot;\nabove. There are also the (*UTF8), (*UTF16),(*UTF32), and\n(*UCP) leading sequences that can be used to set UTF and\nUnicode property modes; they are equivalent to setting the\nPCRE_UTF8, PCRE_UTF16, PCRE_UTF32 and the PCRE_UCP options,\nrespectively. The (*UTF) sequence is a generic version that\ncan be used with any of the libraries. However, the\napplication can set the PCRE_NEVER_UTF option, which locks\nout the use of the (*UTF) sequences.\n\n<h2>SUBPATTERNS\n<a name=\"SUBPATTERNS\"></a>\n</h2>\n\n\nSubpatterns are\ndelimited by parentheses (round brackets), which can be\nnested. Turning part of a pattern into a subpattern does two\nthings:\n\n1. It localizes\na set of alternatives. For example, the pattern\n\n\ncat(aract|erpillar|)\n\nmatches\n&quot;cataract&quot;, &quot;caterpillar&quot;, or\n&quot;cat&quot;. Without the parentheses, it would match\n&quot;cataract&quot;, &quot;erpillar&quot; or an empty\nstring.\n\n2. It sets up\nthe subpattern as a capturing subpattern. This means that,\nwhen the whole pattern matches, that portion of the subject\nstring that matched the subpattern is passed back to the\ncaller via the <i>ovector</i> argument of the matching\nfunction. (This applies only to the traditional matching\nfunctions; the DFA matching functions do not support\ncapturing.)\n\nOpening\nparentheses are counted from left to right (starting from 1)\nto obtain numbers for the capturing subpatterns. For\nexample, if the string &quot;the red king&quot; is matched\nagainst the pattern\n\nthe\n((red|white) (king|queen))\n\nthe captured\nsubstrings are &quot;red king&quot;, &quot;red&quot;, and\n&quot;king&quot;, and are numbered 1, 2, and 3,\nrespectively.\n\nThe fact that\nplain parentheses fulfil two functions is not always\nhelpful. There are often times when a grouping subpattern is\nrequired without a capturing requirement. If an opening\nparenthesis is followed by a question mark and a colon, the\nsubpattern does not do any capturing, and is not counted\nwhen computing the number of any subsequent capturing\nsubpatterns. For example, if the string &quot;the white\nqueen&quot; is matched against the pattern\n\nthe\n((?:red|white) (king|queen))\n\nthe captured\nsubstrings are &quot;white queen&quot; and\n&quot;queen&quot;, and are numbered 1 and 2. The maximum\nnumber of capturing subpatterns is 65535.\n\nAs a convenient\nshorthand, if any option settings are required at the start\nof a non-capturing subpattern, the option letters may appear\nbetween the &quot;?&quot; and the &quot;:&quot;. Thus the\ntwo patterns\n\n\n(?i:saturday|sunday)\n<br>\n(?:(?i)saturday|sunday)\n\nmatch exactly\nthe same set of strings. Because alternative branches are\ntried from left to right, and options are not reset until\nthe end of the subpattern is reached, an option setting in\none branch does affect subsequent branches, so the above\npatterns match &quot;SUNDAY&quot; as well as\n&quot;Saturday&quot;.\n\n<h2>DUPLICATE SUBPATTERN NUMBERS\n<a name=\"DUPLICATE SUBPATTERN NUMBERS\"></a>\n</h2>\n\n\nPerl 5.10\nintroduced a feature whereby each alternative in a\nsubpattern uses the same numbers for its capturing\nparentheses. Such a subpattern starts with (?| and is itself\na non-capturing subpattern. For example, consider this\npattern:\n\n\n(?|(Sat)ur|(Sun))day\n\nBecause the two\nalternatives are inside a (?| group, both sets of capturing\nparentheses are numbered one. Thus, when the pattern\nmatches, you can look at captured substring number one,\nwhichever alternative matched. This construct is useful when\nyou want to capture part, but not all, of one of a number of\nalternatives. Inside a (?| group, parentheses are numbered\nas usual, but the number is reset at the start of each\nbranch. The numbers of any capturing parentheses that follow\nthe subpattern start after the highest number used in any\nbranch. The following example is taken from the Perl\ndocumentation. The numbers underneath show in which buffer\nthe captured content will be stored.\n\n# before\n---------------branch-reset----------- after <br>\n/ ( a ) (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x\n<br>\n# 1 2 2 3 2 3 4\n\nA back\nreference to a numbered subpattern uses the most recent\nvalue that is set for that number by any subpattern. The\nfollowing pattern matches &quot;abcabc&quot; or\n&quot;defdef&quot;:\n\n\n/(?|(abc)|(def))\\1/\n\nIn contrast, a\nsubroutine call to a numbered subpattern always refers to\nthe first one in the pattern with the given number. The\nfollowing pattern matches &quot;abcabc&quot; or\n&quot;defabc&quot;:\n\n\n/(?|(abc)|(def))(?1)/\n\nIf a condition\ntest for a subpattern&rsquo;s having matched refers to a\nnon-unique number, the test is true if any of the\nsubpatterns of that number have matched.\n\nAn alternative\napproach to using this &quot;branch reset&quot; feature is\nto use duplicate named subpatterns, as described in the next\nsection.\n\n<h2>NAMED SUBPATTERNS\n<a name=\"NAMED SUBPATTERNS\"></a>\n</h2>\n\n\nIdentifying\ncapturing parentheses by number is simple, but it can be\nvery hard to keep track of the numbers in complicated\nregular expressions. Furthermore, if an expression is\nmodified, the numbers may change. To help with this\ndifficulty, PCRE supports the naming of subpatterns. This\nfeature was not added to Perl until release 5.10. Python had\nthe feature earlier, and PCRE introduced it at release 4.0,\nusing the Python syntax. PCRE now supports both the Perl and\nthe Python syntax. Perl allows identically numbered\nsubpatterns to have different names, but PCRE does not.\n\nIn PCRE, a\nsubpattern can be named in one of three ways:\n(?&lt;name&gt;...) or (?&rsquo;name&rsquo;...) as in Perl,\nor (?P&lt;name&gt;...) as in Python. References to capturing\nparentheses from other parts of the pattern, such as back\nreferences, recursion, and conditions, can be made by name\nas well as by number.\n\nNames consist\nof up to 32 alphanumeric characters and underscores, but\nmust start with a non-digit. Named capturing parentheses are\nstill allocated numbers as well as names, exactly as if the\nnames were not present. The PCRE API provides function calls\nfor extracting the name-to-number translation table from a\ncompiled pattern. There is also a convenience function for\nextracting a captured substring by name.\n\nBy default, a\nname must be unique within a pattern, but it is possible to\nrelax this constraint by setting the PCRE_DUPNAMES option at\ncompile time. (Duplicate names are also always permitted for\nsubpatterns with the same number, set up as described in the\nprevious section.) Duplicate names can be useful for\npatterns where only one instance of the named parentheses\ncan match. Suppose you want to match the name of a weekday,\neither as a 3-letter abbreviation or as the full name, and\nin both cases you want to extract the abbreviation. This\npattern (ignoring the line breaks) does the job:\n\n\n(?&lt;DN&gt;Mon|Fri|Sun)(?:day)?|\n<br>\n(?&lt;DN&gt;Tue)(?:sday)?| <br>\n(?&lt;DN&gt;Wed)(?:nesday)?| <br>\n(?&lt;DN&gt;Thu)(?:rsday)?| <br>\n(?&lt;DN&gt;Sat)(?:urday)?\n\nThere are five\ncapturing substrings, but only one is ever set after a\nmatch. (An alternative way of solving this problem is to use\na &quot;branch reset&quot; subpattern, as described in the\nprevious section.)\n\nThe convenience\nfunction for extracting the data by name returns the\nsubstring for the first (and in this example, the only)\nsubpattern of that name that matched. This saves searching\nto find which numbered subpattern it was.\n\nIf you make a\nback reference to a non-unique named subpattern from\nelsewhere in the pattern, the subpatterns to which the name\nrefers are checked in the order in which they appear in the\noverall pattern. The first one that is set is used for the\nreference. For example, this pattern matches both\n&quot;foofoo&quot; and &quot;barbar&quot; but not\n&quot;foobar&quot; or &quot;barfoo&quot;:\n\n\n(?:(?&lt;n&gt;foo)|(?&lt;n&gt;bar))\\k&lt;n&gt;\n\nIf you make a\nsubroutine call to a non-unique named subpattern, the one\nthat corresponds to the first occurrence of the name is\nused. In the absence of duplicate numbers (see the previous\nsection) this is the one with the lowest number.\n\nIf you use a\nnamed reference in a condition test (see the section about\nconditions below), either to check whether a subpattern has\nmatched, or to check for recursion, all subpatterns with the\nsame name are tested. If the condition is true for any one\nof them, the overall condition is true. This is the same\nbehaviour as testing by number. For further details of the\ninterfaces for handling named subpatterns, see the\n<b>pcreapi</b> documentation.\n\n\n<b>Warning:</b>\nYou cannot use different names to distinguish between two\nsubpatterns with the same number because PCRE uses only the\nnumbers when matching. For this reason, an error is given at\ncompile time if different names are given to subpatterns\nwith the same number. However, you can always give the same\nname to subpatterns with the same number, even when\nPCRE_DUPNAMES is not set.\n\n<h2>REPETITION\n<a name=\"REPETITION\"></a>\n</h2>\n\n\nRepetition is\nspecified by quantifiers, which can follow any of the\nfollowing items:\n\na literal data\ncharacter <br>\nthe dot metacharacter <br>\nthe \\C escape sequence <br>\nthe \\X escape sequence <br>\nthe \\R escape sequence <br>\nan escape such as \\d or \\pL that matches a single character\n<br>\na character class <br>\na back reference (see next section) <br>\na parenthesized subpattern (including assertions) <br>\na subroutine call to a subpattern (recursive or\notherwise)\n\nThe general\nrepetition quantifier specifies a minimum and maximum number\nof permitted matches, by giving the two numbers in curly\nbrackets (braces), separated by a comma. The numbers must be\nless than 65536, and the first must be less than or equal to\nthe second. For example:\n\nz{2,4}\n\nmatches\n&quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;. A\nclosing brace on its own is not a special character. If the\nsecond number is omitted, but the comma is present, there is\nno upper limit; if the second number and the comma are both\nomitted, the quantifier specifies an exact number of\nrequired matches. Thus\n\n\n[aeiou]{3,}\n\nmatches at\nleast 3 successive vowels, but may match many more,\nwhile\n\n\\d{8}\n\nmatches exactly\n8 digits. An opening curly bracket that appears in a\nposition where a quantifier is not allowed, or one that does\nnot match the syntax of a quantifier, is taken as a literal\ncharacter. For example, {,6} is not a quantifier, but a\nliteral string of four characters.\n\nIn UTF modes,\nquantifiers apply to characters rather than to individual\ndata units. Thus, for example, \\x{100}{2} matches two\ncharacters, each of which is represented by a two-byte\nsequence in a UTF-8 string. Similarly, \\X{3} matches three\nUnicode extended grapheme clusters, each of which may be\nseveral data units long (and they may be of different\nlengths).\n\nThe quantifier\n{0} is permitted, causing the expression to behave as if the\nprevious item and the quantifier were not present. This may\nbe useful for subpatterns that are referenced as subroutines\nfrom elsewhere in the pattern (but see also the section\nentitled &quot;Defining subpatterns for use by reference\nonly&quot; below). Items other than subpatterns that have a\n{0} quantifier are omitted from the compiled pattern.\n\nFor\nconvenience, the three most common quantifiers have\nsingle-character abbreviations:\n\n* is equivalent\nto {0,} <br>\n+ is equivalent to {1,} <br>\n? is equivalent to {0,1}\n\nIt is possible\nto construct infinite loops by following a subpattern that\ncan match no characters with a quantifier that has no upper\nlimit, for example:\n\n(a?)*\n\nEarlier\nversions of Perl and PCRE used to give an error at compile\ntime for such patterns. However, because there are cases\nwhere this can be useful, such patterns are now accepted,\nbut if any repetition of the subpattern does in fact match\nno characters, the loop is forcibly broken.\n\nBy default, the\nquantifiers are &quot;greedy&quot;, that is, they match as\nmuch as possible (up to the maximum number of permitted\ntimes), without causing the rest of the pattern to fail. The\nclassic example of where this gives problems is in trying to\nmatch comments in C programs. These appear between /* and */\nand within the comment, individual * and / characters may\nappear. An attempt to match C comments by applying the\npattern\n\n/\\*.*\\*/\n\nto the\nstring\n\n/* first\ncomment */ not comment /* second comment */\n\nfails, because\nit matches the entire string owing to the greediness of the\n.* item.\n\nHowever, if a\nquantifier is followed by a question mark, it ceases to be\ngreedy, and instead matches the minimum number of times\npossible, so the pattern\n\n/\\*.*?\\*/\n\ndoes the right\nthing with the C comments. The meaning of the various\nquantifiers is not otherwise changed, just the preferred\nnumber of matches. Do not confuse this use of question mark\nwith its use as a quantifier in its own right. Because it\nhas two uses, it can sometimes appear doubled, as in\n\n\\d??\\d\n\nwhich matches\none digit by preference, but can match two if that is the\nonly way the rest of the pattern matches.\n\nIf the\nPCRE_UNGREEDY option is set (an option that is not available\nin Perl), the quantifiers are not greedy by default, but\nindividual ones can be made greedy by following them with a\nquestion mark. In other words, it inverts the default\nbehaviour.\n\nWhen a\nparenthesized subpattern is quantified with a minimum repeat\ncount that is greater than 1 or with a limited maximum, more\nmemory is required for the compiled pattern, in proportion\nto the size of the minimum or maximum.\n\nIf a pattern\nstarts with .* or .{0,} and the PCRE_DOTALL option\n(equivalent to Perl&rsquo;s /s) is set, thus allowing the\ndot to match newlines, the pattern is implicitly anchored,\nbecause whatever follows will be tried against every\ncharacter position in the subject string, so there is no\npoint in retrying the overall match at any position after\nthe first. PCRE normally treats such a pattern as though it\nwere preceded by \\A.\n\nIn cases where\nit is known that the subject string contains no newlines, it\nis worth setting PCRE_DOTALL in order to obtain this\noptimization, or alternatively using ^ to indicate anchoring\nexplicitly.\n\nHowever, there\nare some cases where the optimization cannot be used. When\n.* is inside capturing parentheses that are the subject of a\nback reference elsewhere in the pattern, a match at the\nstart may fail where a later one succeeds. Consider, for\nexample:\n\n(.*)abc\\1\n\nIf the subject\nis &quot;xyz123abc123&quot; the match point is the fourth\ncharacter. For this reason, such a pattern is not implicitly\nanchored.\n\nAnother case\nwhere implicit anchoring is not applied is when the leading\n.* is inside an atomic group. Once again, a match at the\nstart may fail where a later one succeeds. Consider this\npattern:\n\n\n(?&gt;.*?a)b\n\nIt matches\n&quot;ab&quot; in the subject &quot;aab&quot;. The use of\nthe backtracking control verbs (*PRUNE) and (*SKIP) also\ndisable this optimization.\n\nWhen a\ncapturing subpattern is repeated, the value captured is the\nsubstring that matched the final iteration. For example,\nafter\n\n\n(tweedle[dume]{3}\\s*)+\n\nhas matched\n&quot;tweedledum tweedledee&quot; the value of the captured\nsubstring is &quot;tweedledee&quot;. However, if there are\nnested capturing subpatterns, the corresponding captured\nvalues may have been set in previous iterations. For\nexample, after\n\n/(a|(b))+/\n\nmatches\n&quot;aba&quot; the value of the second captured substring\nis &quot;b&quot;.\n\n<h2>ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS\n<a name=\"ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS\"></a>\n</h2>\n\n\nWith both\nmaximizing (&quot;greedy&quot;) and minimizing\n(&quot;ungreedy&quot; or &quot;lazy&quot;) repetition,\nfailure of what follows normally causes the repeated item to\nbe re-evaluated to see if a different number of repeats\nallows the rest of the pattern to match. Sometimes it is\nuseful to prevent this, either to change the nature of the\nmatch, or to cause it fail earlier than it otherwise might,\nwhen the author of the pattern knows there is no point in\ncarrying on.\n\nConsider, for\nexample, the pattern \\d+foo when applied to the subject\nline\n\n123456bar\n\nAfter matching\nall 6 digits and then failing to match &quot;foo&quot;, the\nnormal action of the matcher is to try again with only 5\ndigits matching the \\d+ item, and then with 4, and so on,\nbefore ultimately failing. &quot;Atomic grouping&quot; (a\nterm taken from Jeffrey Friedl&rsquo;s book) provides the\nmeans for specifying that once a subpattern has matched, it\nis not to be re-evaluated in this way.\n\nIf we use\natomic grouping for the previous example, the matcher gives\nup immediately on failing to match &quot;foo&quot; the first\ntime. The notation is a kind of special parenthesis,\nstarting with (?&gt; as in this example:\n\n\n(?&gt;\\d+)foo\n\nThis kind of\nparenthesis &quot;locks up&quot; the part of the pattern it\ncontains once it has matched, and a failure further into the\npattern is prevented from backtracking into it. Backtracking\npast it to previous items, however, works as normal.\n\nAn alternative\ndescription is that a subpattern of this type matches the\nstring of characters that an identical standalone pattern\nwould match, if anchored at the current point in the subject\nstring.\n\nAtomic grouping\nsubpatterns are not capturing subpatterns. Simple cases such\nas the above example can be thought of as a maximizing\nrepeat that must swallow everything it can. So, while both\n\\d+ and \\d+? are prepared to adjust the number of digits\nthey match in order to make the rest of the pattern match,\n(?&gt;\\d+) can only match an entire sequence of digits.\n\nAtomic groups\nin general can of course contain arbitrarily complicated\nsubpatterns, and can be nested. However, when the subpattern\nfor an atomic group is just a single repeated item, as in\nthe example above, a simpler notation, called a\n&quot;possessive quantifier&quot; can be used. This consists\nof an additional + character following a quantifier. Using\nthis notation, the previous example can be rewritten as\n\n\\d++foo\n\nNote that a\npossessive quantifier can be used with an entire group, for\nexample:\n\n\n(abc|xyz){2,3}+\n\nPossessive\nquantifiers are always greedy; the setting of the\nPCRE_UNGREEDY option is ignored. They are a convenient\nnotation for the simpler forms of atomic group. However,\nthere is no difference in the meaning of a possessive\nquantifier and the equivalent atomic group, though there may\nbe a performance difference; possessive quantifiers should\nbe slightly faster.\n\nThe possessive\nquantifier syntax is an extension to the Perl 5.8 syntax.\nJeffrey Friedl originated the idea (and the name) in the\nfirst edition of his book. Mike McCloskey liked it, so\nimplemented it when he built Sun&rsquo;s Java package, and\nPCRE copied it from there. It ultimately found its way into\nPerl at release 5.10.\n\nPCRE has an\noptimization that automatically &quot;possessifies&quot;\ncertain simple pattern constructs. For example, the sequence\nA+B is treated as A++B because there is no point in\nbacktracking into a sequence of A&rsquo;s when B must\nfollow.\n\nWhen a pattern\ncontains an unlimited repeat inside a subpattern that can\nitself be repeated an unlimited number of times, the use of\nan atomic group is the only way to avoid some failing\nmatches taking a very long time indeed. The pattern\n\n\n(\\D+|&lt;\\d+&gt;)*[!?]\n\nmatches an\nunlimited number of substrings that either consist of\nnon-digits, or digits enclosed in &lt;&gt;, followed by\neither ! or ?. When it matches, it runs quickly. However, if\nit is applied to\n\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\nit takes a long\ntime before reporting failure. This is because the string\ncan be divided between the internal \\D+ repeat and the\nexternal * repeat in a large number of ways, and all have to\nbe tried. (The example uses [!?] rather than a single\ncharacter at the end, because both PCRE and Perl have an\noptimization that allows for fast failure when a single\ncharacter is used. They remember the last single character\nthat is required for a match, and fail early if it is not\npresent in the string.) If the pattern is changed so that it\nuses an atomic group, like this:\n\n\n((?&gt;\\D+)|&lt;\\d+&gt;)*[!?]\n\nsequences of\nnon-digits cannot be broken, and failure happens\nquickly.\n\n<h2>BACK REFERENCES\n<a name=\"BACK REFERENCES\"></a>\n</h2>\n\n\nOutside a\ncharacter class, a backslash followed by a digit greater\nthan 0 (and possibly further digits) is a back reference to\na capturing subpattern earlier (that is, to its left) in the\npattern, provided there have been that many previous\ncapturing left parentheses.\n\nHowever, if the\ndecimal number following the backslash is less than 10, it\nis always taken as a back reference, and causes an error\nonly if there are not that many capturing left parentheses\nin the entire pattern. In other words, the parentheses that\nare referenced need not be to the left of the reference for\nnumbers less than 10. A &quot;forward back reference&quot;\nof this type can make sense when a repetition is involved\nand the subpattern to the right has participated in an\nearlier iteration.\n\nIt is not\npossible to have a numerical &quot;forward back\nreference&quot; to a subpattern whose number is 10 or more\nusing this syntax because a sequence such as \\50 is\ninterpreted as a character defined in octal. See the\nsubsection entitled &quot;Non-printing characters&quot;\nabove for further details of the handling of digits\nfollowing a backslash. There is no such problem when named\nparentheses are used. A back reference to any subpattern is\npossible using named parentheses (see below).\n\nAnother way of\navoiding the ambiguity inherent in the use of digits\nfollowing a backslash is to use the \\g escape sequence. This\nescape must be followed by an unsigned number or a negative\nnumber, optionally enclosed in braces. These examples are\nall identical:\n\n(ring), \\1 <br>\n(ring), \\g1 <br>\n(ring), \\g{1}\n\nAn unsigned\nnumber specifies an absolute reference without the ambiguity\nthat is present in the older syntax. It is also useful when\nliteral digits follow the reference. A negative number is a\nrelative reference. Consider this example:\n\n\n(abc(def)ghi)\\g{-1}\n\nThe sequence\n\\g{-1} is a reference to the most recently started capturing\nsubpattern before \\g, that is, is it equivalent to \\2 in\nthis example. Similarly, \\g{-2} would be equivalent to \\1.\nThe use of relative references can be helpful in long\npatterns, and also in patterns that are created by joining\ntogether fragments that contain references within\nthemselves.\n\nA back\nreference matches whatever actually matched the capturing\nsubpattern in the current subject string, rather than\nanything matching the subpattern itself (see\n&quot;Subpatterns as subroutines&quot; below for a way of\ndoing that). So the pattern\n\n\n(sens|respons)e\nand \\1ibility\n\nmatches\n&quot;sense and sensibility&quot; and &quot;response and\nresponsibility&quot;, but not &quot;sense and\nresponsibility&quot;. If caseful matching is in force at the\ntime of the back reference, the case of letters is relevant.\nFor example,\n\n\n((?i)rah)\\s+\\1\n\nmatches\n&quot;rah rah&quot; and &quot;RAH RAH&quot;, but not\n&quot;RAH rah&quot;, even though the original capturing\nsubpattern is matched caselessly.\n\nThere are\nseveral different ways of writing back references to named\nsubpatterns. The .NET syntax \\k{name} and the Perl syntax\n\\k&lt;name&gt; or \\k&rsquo;name&rsquo; are supported, as is\nthe Python syntax (?P=name). Perl 5.10&rsquo;s unified back\nreference syntax, in which \\g can be used for both numeric\nand named references, is also supported. We could rewrite\nthe above example in any of the following ways:\n\n\n(?&lt;p1&gt;(?i)rah)\\s+\\k&lt;p1&gt;\n<br>\n(?&rsquo;p1&rsquo;(?i)rah)\\s+\\k{p1} <br>\n(?P&lt;p1&gt;(?i)rah)\\s+(?P=p1) <br>\n(?&lt;p1&gt;(?i)rah)\\s+\\g{p1}\n\nA subpattern\nthat is referenced by name may appear in the pattern before\nor after the reference.\n\nThere may be\nmore than one back reference to the same subpattern. If a\nsubpattern has not actually been used in a particular match,\nany back references to it always fail by default. For\nexample, the pattern\n\n(a|(bc))\\2\n\nalways fails if\nit starts to match &quot;a&quot; rather than &quot;bc&quot;.\nHowever, if the PCRE_JAVASCRIPT_COMPAT option is set at\ncompile time, a back reference to an unset value matches an\nempty string.\n\nBecause there\nmay be many capturing parentheses in a pattern, all digits\nfollowing a backslash are taken as part of a potential back\nreference number. If the pattern continues with a digit\ncharacter, some delimiter must be used to terminate the back\nreference. If the PCRE_EXTENDED option is set, this can be\nwhite space. Otherwise, the \\g{ syntax or an empty comment\n(see &quot;Comments&quot; below) can be used.\n\n<b>Recursive\nback references</b>\n\nA back\nreference that occurs inside the parentheses to which it\nrefers fails when the subpattern is first used, so, for\nexample, (a\\1) never matches. However, such references can\nbe useful inside repeated subpatterns. For example, the\npattern\n\n(a|b\\1)+\n\nmatches any\nnumber of &quot;a&quot;s and also &quot;aba&quot;,\n&quot;ababbaa&quot; etc. At each iteration of the\nsubpattern, the back reference matches the character string\ncorresponding to the previous iteration. In order for this\nto work, the pattern must be such that the first iteration\ndoes not need to match the back reference. This can be done\nusing alternation, as in the example above, or by a\nquantifier with a minimum of zero.\n\nBack references\nof this type cause the group that they reference to be\ntreated as an atomic group. Once the whole group has been\nmatched, a subsequent matching failure cannot cause\nbacktracking into the middle of the group.\n\n<h2>ASSERTIONS\n<a name=\"ASSERTIONS\"></a>\n</h2>\n\n\nAn assertion is\na test on the characters following or preceding the current\nmatching point that does not actually consume any\ncharacters. The simple assertions coded as \\b, \\B, \\A, \\G,\n\\Z, \\z, ^ and $ are described above.\n\nMore\ncomplicated assertions are coded as subpatterns. There are\ntwo kinds: those that look ahead of the current position in\nthe subject string, and those that look behind it. An\nassertion subpattern is matched in the normal way, except\nthat it does not cause the current matching position to be\nchanged.\n\nAssertion\nsubpatterns are not capturing subpatterns. If such an\nassertion contains capturing subpatterns within it, these\nare counted for the purposes of numbering the capturing\nsubpatterns in the whole pattern. However, substring\ncapturing is carried out only for positive assertions. (Perl\nsometimes, but not always, does do capturing in negative\nassertions.)\n\nFor\ncompatibility with Perl, assertion subpatterns may be\nrepeated; though it makes no sense to assert the same thing\nseveral times, the side effect of capturing parentheses may\noccasionally be useful. In practice, there only three\ncases:\n\n(1) If the\nquantifier is {0}, the assertion is never obeyed during\nmatching. However, it may contain internal capturing\nparenthesized groups that are called from elsewhere via the\nsubroutine mechanism.\n\n(2) If\nquantifier is {0,n} where n is greater than zero, it is\ntreated as if it were {0,1}. At run time, the rest of the\npattern match is tried with and without the assertion, the\norder depending on the greediness of the quantifier.\n\n(3) If the\nminimum repetition is greater than zero, the quantifier is\nignored. The assertion is obeyed just once when encountered\nduring matching.\n\n<b>Lookahead\nassertions</b>\n\nLookahead\nassertions start with (?= for positive assertions and (?!\nfor negative assertions. For example,\n\n\\w+(?=;)\n\nmatches a word\nfollowed by a semicolon, but does not include the semicolon\nin the match, and\n\nfoo(?!bar)\n\nmatches any\noccurrence of &quot;foo&quot; that is not followed by\n&quot;bar&quot;. Note that the apparently similar\npattern\n\n(?!foo)bar\n\ndoes not find\nan occurrence of &quot;bar&quot; that is preceded by\nsomething other than &quot;foo&quot;; it finds any\noccurrence of &quot;bar&quot; whatsoever, because the\nassertion (?!foo) is always true when the next three\ncharacters are &quot;bar&quot;. A lookbehind assertion is\nneeded to achieve the other effect.\n\nIf you want to\nforce a matching failure at some point in a pattern, the\nmost convenient way to do it is with (?!) because an empty\nstring always matches, so an assertion that requires there\nnot to be an empty string must always fail. The backtracking\ncontrol verb (*FAIL) or (*F) is a synonym for (?!).\n\n<b>Lookbehind\nassertions</b>\n\nLookbehind\nassertions start with (?&lt;= for positive assertions and\n(?&lt;! for negative assertions. For example,\n\n\n(?&lt;!foo)bar\n\ndoes find an\noccurrence of &quot;bar&quot; that is not preceded by\n&quot;foo&quot;. The contents of a lookbehind assertion are\nrestricted such that all the strings it matches must have a\nfixed length. However, if there are several top-level\nalternatives, they do not all have to have the same fixed\nlength. Thus\n\n\n(?&lt;=bullock|donkey)\n\nis permitted,\nbut\n\n\n(?&lt;!dogs?|cats?)\n\ncauses an error\nat compile time. Branches that match different length\nstrings are permitted only at the top level of a lookbehind\nassertion. This is an extension compared with Perl, which\nrequires all branches to match the same length of string. An\nassertion such as\n\n\n(?&lt;=ab(c|de))\n\nis not\npermitted, because its single top-level branch can match two\ndifferent lengths, but it is acceptable to PCRE if rewritten\nto use two top-level branches:\n\n\n(?&lt;=abc|abde)\n\nIn some cases,\nthe escape sequence \\K (see above) can be used instead of a\nlookbehind assertion to get round the fixed-length\nrestriction.\n\nThe\nimplementation of lookbehind assertions is, for each\nalternative, to temporarily move the current position back\nby the fixed length and then try to match. If there are\ninsufficient characters before the current position, the\nassertion fails.\n\nIn a UTF mode,\nPCRE does not allow the \\C escape (which matches a single\ndata unit even in a UTF mode) to appear in lookbehind\nassertions, because it makes it impossible to calculate the\nlength of the lookbehind. The \\X and \\R escapes, which can\nmatch different numbers of data units, are also not\npermitted.\n\n\n&quot;Subroutine&quot;\ncalls (see below) such as (?2) or (?&amp;X) are permitted in\nlookbehinds, as long as the subpattern matches a\nfixed-length string. Recursion, however, is not\nsupported.\n\nPossessive\nquantifiers can be used in conjunction with lookbehind\nassertions to specify efficient matching of fixed-length\nstrings at the end of subject strings. Consider a simple\npattern such as\n\nabcd$\n\nwhen applied to\na long string that does not match. Because matching proceeds\nfrom left to right, PCRE will look for each &quot;a&quot; in\nthe subject and then see if what follows matches the rest of\nthe pattern. If the pattern is specified as\n\n^.*abcd$\n\nthe initial .*\nmatches the entire string at first, but when this fails\n(because there is no following &quot;a&quot;), it backtracks\nto match all but the last character, then all but the last\ntwo characters, and so on. Once again the search for\n&quot;a&quot; covers the entire string, from right to left,\nso we are no better off. However, if the pattern is written\nas\n\n\n^.*+(?&lt;=abcd)\n\nthere can be no\nbacktracking for the .*+ item; it can match only the entire\nstring. The subsequent lookbehind assertion does a single\ntest on the last four characters. If it fails, the match\nfails immediately. For long strings, this approach makes a\nsignificant difference to the processing time.\n\n<b>Using\nmultiple assertions</b>\n\nSeveral\nassertions (of any sort) may occur in succession. For\nexample,\n\n\n(?&lt;=\\d{3})(?&lt;!999)foo\n\nmatches\n&quot;foo&quot; preceded by three digits that are not\n&quot;999&quot;. Notice that each of the assertions is\napplied independently at the same point in the subject\nstring. First there is a check that the previous three\ncharacters are all digits, and then there is a check that\nthe same three characters are not &quot;999&quot;. This\npattern does <i>not</i> match &quot;foo&quot; preceded by\nsix characters, the first of which are digits and the last\nthree of which are not &quot;999&quot;. For example, it\ndoesn&rsquo;t match &quot;123abcfoo&quot;. A pattern to do\nthat is\n\n\n(?&lt;=\\d{3}...)(?&lt;!999)foo\n\nThis time the\nfirst assertion looks at the preceding six characters,\nchecking that the first three are digits, and then the\nsecond assertion checks that the preceding three characters\nare not &quot;999&quot;.\n\nAssertions can\nbe nested in any combination. For example,\n\n\n(?&lt;=(?&lt;!foo)bar)baz\n\nmatches an\noccurrence of &quot;baz&quot; that is preceded by\n&quot;bar&quot; which in turn is not preceded by\n&quot;foo&quot;, while\n\n\n(?&lt;=\\d{3}(?!999)...)foo\n\nis another\npattern that matches &quot;foo&quot; preceded by three\ndigits and any three characters that are not\n&quot;999&quot;.\n\n<h2>CONDITIONAL SUBPATTERNS\n<a name=\"CONDITIONAL SUBPATTERNS\"></a>\n</h2>\n\n\nIt is possible\nto cause the matching process to obey a subpattern\nconditionally or to choose between two alternative\nsubpatterns, depending on the result of an assertion, or\nwhether a specific capturing subpattern has already been\nmatched. The two possible forms of conditional subpattern\nare:\n\n\n(?(condition)yes-pattern)\n<br>\n(?(condition)yes-pattern|no-pattern)\n\nIf the\ncondition is satisfied, the yes-pattern is used; otherwise\nthe no-pattern (if present) is used. If there are more than\ntwo alternatives in the subpattern, a compile-time error\noccurs. Each of the two alternatives may itself contain\nnested subpatterns of any form, including conditional\nsubpatterns; the restriction to two alternatives applies\nonly at the level of the condition. This pattern fragment is\nan example where the alternatives are complex:\n\n(?(1) (A|B|C) |\n(D | (?(2)E|F) | E) )\n\nThere are four\nkinds of condition: references to subpatterns, references to\nrecursion, a pseudo-condition called DEFINE, and\nassertions.\n\n<b>Checking for\na used subpattern by number</b>\n\nIf the text\nbetween the parentheses consists of a sequence of digits,\nthe condition is true if a capturing subpattern of that\nnumber has previously matched. If there is more than one\ncapturing subpattern with the same number (see the earlier\nsection about duplicate subpattern numbers), the condition\nis true if any of them have matched. An alternative notation\nis to precede the digits with a plus or minus sign. In this\ncase, the subpattern number is relative rather than\nabsolute. The most recently opened parentheses can be\nreferenced by (?(-1), the next most recent by (?(-2), and so\non. Inside loops it can also make sense to refer to\nsubsequent groups. The next parentheses to be opened can be\nreferenced as (?(+1), and so on. (The value zero in any of\nthese forms is not used; it provokes a compile-time\nerror.)\n\nConsider the\nfollowing pattern, which contains non-significant white\nspace to make it more readable (assume the PCRE_EXTENDED\noption) and to divide it into three parts for ease of\ndiscussion:\n\n( \\( )? [^()]+\n(?(1) \\) )\n\nThe first part\nmatches an optional opening parenthesis, and if that\ncharacter is present, sets it as the first captured\nsubstring. The second part matches one or more characters\nthat are not parentheses. The third part is a conditional\nsubpattern that tests whether or not the first set of\nparentheses matched. If they did, that is, if subject\nstarted with an opening parenthesis, the condition is true,\nand so the yes-pattern is executed and a closing parenthesis\nis required. Otherwise, since no-pattern is not present, the\nsubpattern matches nothing. In other words, this pattern\nmatches a sequence of non-parentheses, optionally enclosed\nin parentheses.\n\nIf you were\nembedding this pattern in a larger one, you could use a\nrelative reference:\n\n...other\nstuff... ( \\( )? [^()]+ (?(-1) \\) ) ...\n\nThis makes the\nfragment independent of the parentheses in the larger\npattern.\n\n<b>Checking for\na used subpattern by name</b>\n\nPerl uses the\nsyntax (?(&lt;name&gt;)...) or (?(&rsquo;name&rsquo;)...) to\ntest for a used subpattern by name. For compatibility with\nearlier versions of PCRE, which had this facility before\nPerl, the syntax (?(name)...) is also recognized.\n\nRewriting the\nabove example to use a named subpattern gives this:\n\n(?&lt;OPEN&gt;\n\\( )? [^()]+ (?(&lt;OPEN&gt;) \\) )\n\nIf the name\nused in a condition of this kind is a duplicate, the test is\napplied to all subpatterns of the same name, and is true if\nany one of them has matched.\n\n<b>Checking for\npattern recursion</b>\n\nIf the\ncondition is the string (R), and there is no subpattern with\nthe name R, the condition is true if a recursive call to the\nwhole pattern or any subpattern has been made. If digits or\na name preceded by ampersand follow the letter R, for\nexample:\n\n(?(R3)...) or\n(?(R&amp;name)...)\n\nthe condition\nis true if the most recent recursion is into a subpattern\nwhose number or name is given. This condition does not check\nthe entire recursion stack. If the name used in a condition\nof this kind is a duplicate, the test is applied to all\nsubpatterns of the same name, and is true if any one of them\nis the most recent recursion.\n\nAt &quot;top\nlevel&quot;, all these recursion test conditions are false.\nThe syntax for recursive patterns is described below.\n\n<b>Defining\nsubpatterns for use by reference only</b>\n\nIf the\ncondition is the string (DEFINE), and there is no subpattern\nwith the name DEFINE, the condition is always false. In this\ncase, there may be only one alternative in the subpattern.\nIt is always skipped if control reaches this point in the\npattern; the idea of DEFINE is that it can be used to define\nsubroutines that can be referenced from elsewhere. (The use\nof subroutines is described below.) For example, a pattern\nto match an IPv4 address such as &quot;192.168.23.245&quot;\ncould be written like this (ignore white space and line\nbreaks):\n\n(?(DEFINE)\n(?&lt;byte&gt; 2[0-4]\\d | 25[0-5] | 1\\d\\d | [1-9]?\\d) ) <br>\n\\b (?&amp;byte) (\\.(?&amp;byte)){3} \\b\n\nThe first part\nof the pattern is a DEFINE group inside which a another\ngroup named &quot;byte&quot; is defined. This matches an\nindividual component of an IPv4 address (a number less than\n256). When matching takes place, this part of the pattern is\nskipped because DEFINE acts like a false condition. The rest\nof the pattern uses references to the named group to match\nthe four dot-separated components of an IPv4 address,\ninsisting on a word boundary at each end.\n\n<b>Assertion\nconditions</b>\n\nIf the\ncondition is not in any of the above formats, it must be an\nassertion. This may be a positive or negative lookahead or\nlookbehind assertion. Consider this pattern, again\ncontaining non-significant white space, and with the two\nalternatives on the second line:\n\n\n(?(?=[^a-z]*[a-z])\n<br>\n\\d{2}-[a-z]{3}-\\d{2} | \\d{2}-\\d{2}-\\d{2} )\n\nThe condition\nis a positive lookahead assertion that matches an optional\nsequence of non-letters followed by a letter. In other\nwords, it tests for the presence of at least one letter in\nthe subject. If a letter is found, the subject is matched\nagainst the first alternative; otherwise it is matched\nagainst the second. This pattern matches strings in one of\nthe two forms dd-aaa-dd or dd-dd-dd, where aaa are letters\nand dd are digits.\n\n<h2>COMMENTS\n<a name=\"COMMENTS\"></a>\n</h2>\n\n\nThere are two\nways of including comments in patterns that are processed by\nPCRE. In both cases, the start of the comment must not be in\na character class, nor in the middle of any other sequence\nof related characters such as (?: or a subpattern name or\nnumber. The characters that make up a comment play no part\nin the pattern matching.\n\nThe sequence\n(?# marks the start of a comment that continues up to the\nnext closing parenthesis. Nested parentheses are not\npermitted. If the PCRE_EXTENDED option is set, an unescaped\n# character also introduces a comment, which in this case\ncontinues to immediately after the next newline character or\ncharacter sequence in the pattern. Which characters are\ninterpreted as newlines is controlled by the options passed\nto a compiling function or by a special sequence at the\nstart of the pattern, as described in the section entitled\n&quot;Newline conventions&quot; above. Note that the end of\nthis type of comment is a literal newline sequence in the\npattern; escape sequences that happen to represent a newline\ndo not count. For example, consider this pattern when\nPCRE_EXTENDED is set, and the default newline convention is\nin force:\n\nabc #comment \\n\nstill comment\n\nOn encountering\nthe # character, <b>pcre_compile()</b> skips along, looking\nfor a newline in the pattern. The sequence \\n is still\nliteral at this stage, so it does not terminate the comment.\nOnly an actual character with the code value 0x0a (the\ndefault newline) does so.\n\n<h2>RECURSIVE PATTERNS\n<a name=\"RECURSIVE PATTERNS\"></a>\n</h2>\n\n\nConsider the\nproblem of matching a string in parentheses, allowing for\nunlimited nested parentheses. Without the use of recursion,\nthe best that can be done is to use a pattern that matches\nup to some fixed depth of nesting. It is not possible to\nhandle an arbitrary nesting depth.\n\nFor some time,\nPerl has provided a facility that allows regular expressions\nto recurse (amongst other things). It does this by\ninterpolating Perl code in the expression at run time, and\nthe code can refer to the expression itself. A Perl pattern\nusing code interpolation to solve the parentheses problem\ncan be created like this:\n\n$re = qr{\\( (?:\n(?&gt;[^()]+) | (?p{$re}) )* \\)}x;\n\nThe (?p{...})\nitem interpolates Perl code at run time, and in this case\nrefers recursively to the pattern in which it appears.\n\nObviously, PCRE\ncannot support the interpolation of Perl code. Instead, it\nsupports special syntax for recursion of the entire pattern,\nand also for individual subpattern recursion. After its\nintroduction in PCRE and Python, this kind of recursion was\nsubsequently introduced into Perl at release 5.10.\n\nA special item\nthat consists of (? followed by a number greater than zero\nand a closing parenthesis is a recursive subroutine call of\nthe subpattern of the given number, provided that it occurs\ninside that subpattern. (If not, it is a non-recursive\nsubroutine call, which is described in the next section.)\nThe special item (?R) or (?0) is a recursive call of the\nentire regular expression.\n\nThis PCRE\npattern solves the nested parentheses problem (assume the\nPCRE_EXTENDED option is set so that white space is\nignored):\n\n\\( ( [^()]++ |\n(?R) )* \\)\n\nFirst it\nmatches an opening parenthesis. Then it matches any number\nof substrings which can either be a sequence of\nnon-parentheses, or a recursive match of the pattern itself\n(that is, a correctly parenthesized substring). Finally\nthere is a closing parenthesis. Note the use of a possessive\nquantifier to avoid backtracking into sequences of\nnon-parentheses.\n\nIf this were\npart of a larger pattern, you would not want to recurse the\nentire pattern, so instead you could use this:\n\n( \\( ( [^()]++\n| (?1) )* \\) )\n\nWe have put the\npattern into parentheses, and caused the recursion to refer\nto them instead of the whole pattern.\n\nIn a larger\npattern, keeping track of parenthesis numbers can be tricky.\nThis is made easier by the use of relative references.\nInstead of (?1) in the pattern above you can write (?-2) to\nrefer to the second most recently opened parentheses\npreceding the recursion. In other words, a negative number\ncounts capturing parentheses leftwards from the point at\nwhich it is encountered.\n\nIt is also\npossible to refer to subsequently opened parentheses, by\nwriting references such as (?+2). However, these cannot be\nrecursive because the reference is not inside the\nparentheses that are referenced. They are always\nnon-recursive subroutine calls, as described in the next\nsection.\n\nAn alternative\napproach is to use named parentheses instead. The Perl\nsyntax for this is (?&amp;name); PCRE&rsquo;s earlier syntax\n(?P&gt;name) is also supported. We could rewrite the above\nexample as follows:\n\n(?&lt;pn&gt; \\(\n( [^()]++ | (?&amp;pn) )* \\) )\n\nIf there is\nmore than one subpattern with the same name, the earliest\none is used.\n\nThis particular\nexample pattern that we have been looking at contains nested\nunlimited repeats, and so the use of a possessive quantifier\nfor matching strings of non-parentheses is important when\napplying the pattern to strings that do not match. For\nexample, when this pattern is applied to\n\n\n(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\n\nit yields\n&quot;no match&quot; quickly. However, if a possessive\nquantifier is not used, the match runs for a very long time\nindeed because there are so many different ways the + and *\nrepeats can carve up the subject, and all have to be tested\nbefore failure can be reported.\n\nAt the end of a\nmatch, the values of capturing parentheses are those from\nthe outermost level. If you want to obtain intermediate\nvalues, a callout function can be used (see below and the\n<b>pcrecallout</b> documentation). If the pattern above is\nmatched against\n\n(ab(cd)ef)\n\nthe value for\nthe inner capturing parentheses (numbered 2) is\n&quot;ef&quot;, which is the last value taken on at the top\nlevel. If a capturing subpattern is not matched at the top\nlevel, its final captured value is unset, even if it was\n(temporarily) set at a deeper level during the matching\nprocess.\n\nIf there are\nmore than 15 capturing parentheses in a pattern, PCRE has to\nobtain extra memory to store data during a recursion, which\nit does by using <b>pcre_malloc</b>, freeing it via\n<b>pcre_free</b> afterwards. If no memory can be obtained,\nthe match fails with the PCRE_ERROR_NOMEMORY error.\n\nDo not confuse\nthe (?R) item with the condition (R), which tests for\nrecursion. Consider this pattern, which matches text in\nangle brackets, allowing for arbitrary nesting. Only digits\nare allowed in nested brackets (that is, when recursing),\nwhereas any characters are permitted at the outer level.\n\n&lt; (?: (?(R)\n\\d++ | [^&lt;&gt;]*+) | (?R)) * &gt;\n\nIn this\npattern, (?(R) is the start of a conditional subpattern,\nwith two different alternatives for the recursive and\nnon-recursive cases. The (?R) item is the actual recursive\ncall.\n\n<b>Differences\nin recursion processing between PCRE and Perl</b>\n\nRecursion\nprocessing in PCRE differs from Perl in two important ways.\nIn PCRE (like Python, but unlike Perl), a recursive\nsubpattern call is always treated as an atomic group. That\nis, once it has matched some of the subject string, it is\nnever re-entered, even if it contains untried alternatives\nand there is a subsequent matching failure. This can be\nillustrated by the following pattern, which purports to\nmatch a palindromic string that contains an odd number of\ncharacters (for example, &quot;a&quot;, &quot;aba&quot;,\n&quot;abcba&quot;, &quot;abcdcba&quot;):\n\n\n^(.|(.)(?1)\\2)$\n\nThe idea is\nthat it either matches a single character, or two identical\ncharacters surrounding a sub-palindrome. In Perl, this\npattern works; in PCRE it does not if the pattern is longer\nthan three characters. Consider the subject string\n&quot;abcba&quot;:\n\nAt the top\nlevel, the first character is matched, but as it is not at\nthe end of the string, the first alternative fails; the\nsecond alternative is taken and the recursion kicks in. The\nrecursive call to subpattern 1 successfully matches the next\ncharacter (&quot;b&quot;). (Note that the beginning and end\nof line tests are not part of the recursion).\n\nBack at the top\nlevel, the next character (&quot;c&quot;) is compared with\nwhat subpattern 2 matched, which was &quot;a&quot;. This\nfails. Because the recursion is treated as an atomic group,\nthere are now no backtracking points, and so the entire\nmatch fails. (Perl is able, at this point, to re-enter the\nrecursion and try the second alternative.) However, if the\npattern is written with the alternatives in the other order,\nthings are different:\n\n\n^((.)(?1)\\2|.)$\n\nThis time, the\nrecursing alternative is tried first, and continues to\nrecurse until it runs out of characters, at which point the\nrecursion fails. But this time we do have another\nalternative to try at the higher level. That is the big\ndifference: in the previous case the remaining alternative\nis at a deeper recursion level, which PCRE cannot use.\n\nTo change the\npattern so that it matches all palindromic strings, not just\nthose with an odd number of characters, it is tempting to\nchange the pattern to this:\n\n\n^((.)(?1)\\2|.?)$\n\nAgain, this\nworks in Perl, but not in PCRE, and for the same reason.\nWhen a deeper recursion has matched a single character, it\ncannot be entered again in order to match an empty string.\nThe solution is to separate the two cases, and write out the\nodd and even cases as alternatives at the higher level:\n\n\n^(?:((.)(?1)\\2|)|((.)(?3)\\4|.))\n\nIf you want to\nmatch typical palindromic phrases, the pattern has to ignore\nall non-word characters, which can be done like this:\n\n\n^\\W*+(?:((.)\\W*+(?1)\\W*+\\2|)|((.)\\W*+(?3)\\W*+\\4|\\W*+.\\W*+))\\W*+$\n\nIf run with the\nPCRE_CASELESS option, this pattern matches phrases such as\n&quot;A man, a plan, a canal: Panama!&quot; and it works\nwell in both PCRE and Perl. Note the use of the possessive\nquantifier *+ to avoid backtracking into sequences of\nnon-word characters. Without this, PCRE takes a great deal\nlonger (ten times or more) to match typical phrases, and\nPerl takes so long that you think it has gone into a\nloop.\n\n\n<b>WARNING</b>:\nThe palindrome-matching patterns above work only if the\nsubject string does not start with a palindrome that is\nshorter than the entire string. For example, although\n&quot;abcba&quot; is correctly matched, if the subject is\n&quot;ababa&quot;, PCRE finds the palindrome &quot;aba&quot;\nat the start, then fails at top level because the end of the\nstring does not follow. Once again, it cannot jump back into\nthe recursion to try other alternatives, so the entire match\nfails.\n\nThe second way\nin which PCRE and Perl differ in their recursion processing\nis in the handling of captured values. In Perl, when a\nsubpattern is called recursively or as a subpattern (see the\nnext section), it has no access to any values that were\ncaptured outside the recursion, whereas in PCRE these values\ncan be referenced. Consider this pattern:\n\n\n^(.)(\\1|a(?2))\n\nIn PCRE, this\npattern matches &quot;bab&quot;. The first capturing\nparentheses match &quot;b&quot;, then in the second group,\nwhen the back reference \\1 fails to match &quot;b&quot;, the\nsecond alternative matches &quot;a&quot; and then recurses.\nIn the recursion, \\1 does now match &quot;b&quot; and so the\nwhole match succeeds. In Perl, the pattern fails to match\nbecause inside the recursive call \\1 cannot access the\nexternally set value.\n\n<h2>SUBPATTERNS AS SUBROUTINES\n<a name=\"SUBPATTERNS AS SUBROUTINES\"></a>\n</h2>\n\n\nIf the syntax\nfor a recursive subpattern call (either by number or by\nname) is used outside the parentheses to which it refers, it\noperates like a subroutine in a programming language. The\ncalled subpattern may be defined before or after the\nreference. A numbered reference can be absolute or relative,\nas in these examples:\n\n\n(...(absolute)...)...(?2)...\n<br>\n(...(relative)...)...(?-1)... <br>\n(...(?+1)...(relative)...\n\nAn earlier\nexample pointed out that the pattern\n\n\n(sens|respons)e\nand \\1ibility\n\nmatches\n&quot;sense and sensibility&quot; and &quot;response and\nresponsibility&quot;, but not &quot;sense and\nresponsibility&quot;. If instead the pattern\n\n\n(sens|respons)e\nand (?1)ibility\n\nis used, it\ndoes match &quot;sense and responsibility&quot; as well as\nthe other two strings. Another example is given in the\ndiscussion of DEFINE above.\n\nAll subroutine\ncalls, whether recursive or not, are always treated as\natomic groups. That is, once a subroutine has matched some\nof the subject string, it is never re-entered, even if it\ncontains untried alternatives and there is a subsequent\nmatching failure. Any capturing parentheses that are set\nduring the subroutine call revert to their previous values\nafterwards.\n\nProcessing\noptions such as case-independence are fixed when a\nsubpattern is defined, so if it is used as a subroutine,\nsuch options cannot be changed for different calls. For\nexample, consider this pattern:\n\n\n(abc)(?i:(?-1))\n\nIt matches\n&quot;abcabc&quot;. It does not match &quot;abcABC&quot;\nbecause the change of processing option does not affect the\ncalled subpattern.\n\n<h2>ONIGURUMA SUBROUTINE SYNTAX\n<a name=\"ONIGURUMA SUBROUTINE SYNTAX\"></a>\n</h2>\n\n\nFor\ncompatibility with Oniguruma, the non-Perl syntax \\g\nfollowed by a name or a number enclosed either in angle\nbrackets or single quotes, is an alternative syntax for\nreferencing a subpattern as a subroutine, possibly\nrecursively. Here are two of the examples used above,\nrewritten using this syntax:\n\n(?&lt;pn&gt; \\(\n( (?&gt;[^()]+) | \\g&lt;pn&gt; )* \\) ) <br>\n(sens|respons)e and \\g&rsquo;1&rsquo;ibility\n\nPCRE supports\nan extension to Oniguruma: if a number is preceded by a plus\nor a minus sign it is taken as a relative reference. For\nexample:\n\n\n(abc)(?i:\\g&lt;-1&gt;)\n\nNote that\n\\g{...} (Perl syntax) and \\g&lt;...&gt; (Oniguruma syntax)\nare <i>not</i> synonymous. The former is a back reference;\nthe latter is a subroutine call.\n\n<h2>CALLOUTS\n<a name=\"CALLOUTS\"></a>\n</h2>\n\n\nPerl has a\nfeature whereby using the sequence (?{...}) causes arbitrary\nPerl code to be obeyed in the middle of matching a regular\nexpression. This makes it possible, amongst other things, to\nextract different substrings that match the same pair of\nparentheses when there is a repetition.\n\nPCRE provides a\nsimilar feature, but of course it cannot obey arbitrary Perl\ncode. The feature is called &quot;callout&quot;. The caller\nof PCRE provides an external function by putting its entry\npoint in the global variable <i>pcre_callout</i> (8-bit\nlibrary) or <i>pcre[16|32]_callout</i> (16-bit or 32-bit\nlibrary). By default, this variable contains NULL, which\ndisables all calling out.\n\nWithin a\nregular expression, (?C) indicates the points at which the\nexternal function is to be called. If you want to identify\ndifferent callout points, you can put a number less than 256\nafter the letter C. The default value is zero. For example,\nthis pattern has two callout points:\n\n\n(?C1)abc(?C2)def\n\nIf the\nPCRE_AUTO_CALLOUT flag is passed to a compiling function,\ncallouts are automatically installed before each item in the\npattern. They are all numbered 255. If there is a\nconditional group in the pattern whose condition is an\nassertion, an additional callout is inserted just before the\ncondition. An explicit callout may also be set at this\nposition, as in this example:\n\n\n(?(?C9)(?=a)abc|def)\n\nNote that this\napplies only to assertion conditions, not to other types of\ncondition.\n\nDuring\nmatching, when PCRE reaches a callout point, the external\nfunction is called. It is provided with the number of the\ncallout, the position in the pattern, and, optionally, one\nitem of data originally supplied by the caller of the\nmatching function. The callout function may cause matching\nto proceed, to backtrack, or to fail altogether.\n\nBy default,\nPCRE implements a number of optimizations at compile time\nand matching time, and one side-effect is that sometimes\ncallouts are skipped. If you need all possible callouts to\nhappen, you need to set options that disable the relevant\noptimizations. More details, and a complete description of\nthe interface to the callout function, are given in the\n<b>pcrecallout</b> documentation.\n\n<h2>BACKTRACKING CONTROL\n<a name=\"BACKTRACKING CONTROL\"></a>\n</h2>\n\n\nPerl 5.10\nintroduced a number of &quot;Special Backtracking Control\nVerbs&quot;, which are still described in the Perl\ndocumentation as &quot;experimental and subject to change or\nremoval in a future version of Perl&quot;. It goes on to\nsay: &quot;Their usage in production code should be noted to\navoid problems during upgrades.&quot; The same remarks apply\nto the PCRE features described in this section.\n\nThe new verbs\nmake use of what was previously invalid syntax: an opening\nparenthesis followed by an asterisk. They are generally of\nthe form (*VERB) or (*VERB:NAME). Some may take either form,\npossibly behaving differently depending on whether or not a\nname is present. A name is any sequence of characters that\ndoes not include a closing parenthesis. The maximum length\nof name is 255 in the 8-bit library and 65535 in the 16-bit\nand 32-bit libraries. If the name is empty, that is, if the\nclosing parenthesis immediately follows the colon, the\neffect is as if the colon were not there. Any number of\nthese verbs may occur in a pattern.\n\nSince these\nverbs are specifically related to backtracking, most of them\ncan be used only when the pattern is to be matched using one\nof the traditional matching functions, because these use a\nbacktracking algorithm. With the exception of (*FAIL), which\nbehaves like a failing negative assertion, the backtracking\ncontrol verbs cause an error if encountered by a DFA\nmatching function.\n\nThe behaviour\nof these verbs in repeated groups, assertions, and in\nsubpatterns called as subroutines (whether or not\nrecursively) is documented below.\n\n\n<b>Optimizations\nthat affect backtracking verbs</b>\n\nPCRE contains\nsome optimizations that are used to speed up matching by\nrunning some checks at the start of each match attempt. For\nexample, it may know the minimum length of matching subject,\nor that a particular character must be present. When one of\nthese optimizations bypasses the running of a match, any\nincluded backtracking verbs will not, of course, be\nprocessed. You can suppress the start-of-match optimizations\nby setting the PCRE_NO_START_OPTIMIZE option when calling\n<b>pcre_compile()</b> or <b>pcre_exec()</b>, or by starting\nthe pattern with (*NO_START_OPT). There is more discussion\nof this option in the section entitled &quot;Option bits for\n<b>pcre_exec()</b>&quot; in the <b>pcreapi</b>\ndocumentation.\n\nExperiments\nwith Perl suggest that it too has similar optimizations,\nsometimes leading to anomalous results.\n\n<b>Verbs that\nact immediately</b>\n\nThe following\nverbs act as soon as they are encountered. They may not be\nfollowed by a name.\n\n(*ACCEPT)\n\nThis verb\ncauses the match to end successfully, skipping the remainder\nof the pattern. However, when it is inside a subpattern that\nis called as a subroutine, only that subpattern is ended\nsuccessfully. Matching then continues at the outer level. If\n(*ACCEPT) in triggered in a positive assertion, the\nassertion succeeds; in a negative assertion, the assertion\nfails.\n\nIf (*ACCEPT) is\ninside capturing parentheses, the data so far is captured.\nFor example:\n\n\nA((?:A|B(*ACCEPT)|C)D)\n\nThis matches\n&quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;; when it\nmatches &quot;AB&quot;, &quot;B&quot; is captured by the\nouter parentheses.\n\n(*FAIL) or\n(*F)\n\nThis verb\ncauses a matching failure, forcing backtracking to occur. It\nis equivalent to (?!) but easier to read. The Perl\ndocumentation notes that it is probably useful only when\ncombined with (?{}) or (??{}). Those are, of course, Perl\nfeatures that are not present in PCRE. The nearest\nequivalent is the callout feature, as for example in this\npattern:\n\n\na+(?C)(*FAIL)\n\nA match with\nthe string &quot;aaaa&quot; always fails, but the callout is\ntaken before each backtrack happens (in this example, 10\ntimes).\n\n<b>Recording\nwhich path was taken</b>\n\nThere is one\nverb whose main purpose is to track how a match was arrived\nat, though it also has a secondary use in conjunction with\nadvancing the match starting point (see (*SKIP) below).\n\n(*MARK:NAME) or\n(*:NAME)\n\nA name is\nalways required with this verb. There may be as many\ninstances of (*MARK) as you like in a pattern, and their\nnames do not have to be unique.\n\nWhen a match\nsucceeds, the name of the last-encountered (*MARK:NAME),\n(*PRUNE:NAME), or (*THEN:NAME) on the matching path is\npassed back to the caller as described in the section\nentitled &quot;Extra data for <b>pcre_exec()</b>&quot; in\nthe <b>pcreapi</b> documentation. Here is an example of\n<b>pcretest</b> output, where the /K modifier requests the\nretrieval and outputting of (*MARK) data:\n\nre&gt;\n/X(*MARK:A)Y|X(*MARK:B)Z/K <br>\ndata&gt; XY <br>\n0: XY <br>\nMK: A <br>\nXZ <br>\n0: XZ <br>\nMK: B\n\nThe (*MARK)\nname is tagged with &quot;MK:&quot; in this output, and in\nthis example it indicates which of the two alternatives\nmatched. This is a more efficient way of obtaining this\ninformation than putting each alternative in its own\ncapturing parentheses.\n\nIf a verb with\na name is encountered in a positive assertion that is true,\nthe name is recorded and passed back if it is the\nlast-encountered. This does not happen for negative\nassertions or failing positive assertions.\n\nAfter a partial\nmatch or a failed match, the last encountered name in the\nentire match process is returned. For example:\n\nre&gt;\n/X(*MARK:A)Y|X(*MARK:B)Z/K <br>\ndata&gt; XP <br>\nNo match, mark = B\n\nNote that in\nthis unanchored example the mark is retained from the match\nattempt that started at the letter &quot;X&quot; in the\nsubject. Subsequent match attempts starting at &quot;P&quot;\nand then with an empty string do not get as far as the\n(*MARK) item, but nevertheless do not reset it.\n\nIf you are\ninterested in (*MARK) values after failed matches, you\nshould probably set the PCRE_NO_START_OPTIMIZE option (see\nabove) to ensure that the match is always attempted.\n\n<b>Verbs that\nact after backtracking</b>\n\nThe following\nverbs do nothing when they are encountered. Matching\ncontinues with what follows, but if there is no subsequent\nmatch, causing a backtrack to the verb, a failure is forced.\nThat is, backtracking cannot pass to the left of the verb.\nHowever, when one of these verbs appears inside an atomic\ngroup or an assertion that is true, its effect is confined\nto that group, because once the group has been matched,\nthere is never any backtracking into it. In this situation,\nbacktracking can &quot;jump back&quot; to the left of the\nentire atomic group or assertion. (Remember also, as stated\nabove, that this localization also applies in subroutine\ncalls.)\n\nThese verbs\ndiffer in exactly what kind of failure occurs when\nbacktracking reaches them. The behaviour described below is\nwhat happens when the verb is not in a subroutine or an\nassertion. Subsequent sections cover these special\ncases.\n\n(*COMMIT)\n\nThis verb,\nwhich may not be followed by a name, causes the whole match\nto fail outright if there is a later matching failure that\ncauses backtracking to reach it. Even if the pattern is\nunanchored, no further attempts to find a match by advancing\nthe starting point take place. If (*COMMIT) is the only\nbacktracking verb that is encountered, once it has been\npassed <b>pcre_exec()</b> is committed to finding a match at\nthe current starting point, or not at all. For example:\n\n\na+(*COMMIT)b\n\nThis matches\n&quot;xxaab&quot; but not &quot;aacaab&quot;. It can be\nthought of as a kind of dynamic anchor, or &quot;I&rsquo;ve\nstarted, so I must finish.&quot; The name of the most\nrecently passed (*MARK) in the path is passed back when\n(*COMMIT) forces a match failure.\n\nIf there is\nmore than one backtracking verb in a pattern, a different\none that follows (*COMMIT) may be triggered first, so merely\npassing (*COMMIT) during a match does not always guarantee\nthat a match must be at this starting point.\n\nNote that\n(*COMMIT) at the start of a pattern is not the same as an\nanchor, unless PCRE&rsquo;s start-of-match optimizations are\nturned off, as shown in this output from\n<b>pcretest</b>:\n\nre&gt;\n/(*COMMIT)abc/ <br>\ndata&gt; xyzabc <br>\n0: abc <br>\ndata&gt; xyzabc\\Y <br>\nNo match\n\nFor this\npattern, PCRE knows that any match must start with\n&quot;a&quot;, so the optimization skips along the subject\nto &quot;a&quot; before applying the pattern to the first\nset of data. The match attempt then succeeds. In the second\nset of data, the escape sequence \\Y is interpreted by the\n<b>pcretest</b> program. It causes the\nPCRE_NO_START_OPTIMIZE option to be set when\n<b>pcre_exec()</b> is called. This disables the optimization\nthat skips along to the first character. The pattern is now\napplied starting at &quot;x&quot;, and so the (*COMMIT)\ncauses the match to fail without trying any other starting\npoints.\n\n(*PRUNE) or\n(*PRUNE:NAME)\n\nThis verb\ncauses the match to fail at the current starting position in\nthe subject if there is a later matching failure that causes\nbacktracking to reach it. If the pattern is unanchored, the\nnormal &quot;bumpalong&quot; advance to the next starting\ncharacter then happens. Backtracking can occur as usual to\nthe left of (*PRUNE), before it is reached, or when matching\nto the right of (*PRUNE), but if there is no match to the\nright, backtracking cannot cross (*PRUNE). In simple cases,\nthe use of (*PRUNE) is just an alternative to an atomic\ngroup or possessive quantifier, but there are some uses of\n(*PRUNE) that cannot be expressed in any other way. In an\nanchored pattern (*PRUNE) has the same effect as\n(*COMMIT).\n\nThe behaviour\nof (*PRUNE:NAME) is the not the same as\n(*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the\nname is remembered for passing back to the caller. However,\n(*SKIP:NAME) searches only for names set with (*MARK).\n\n(*SKIP)\n\nThis verb, when\ngiven without a name, is like (*PRUNE), except that if the\npattern is unanchored, the &quot;bumpalong&quot; advance is\nnot to the next character, but to the position in the\nsubject where (*SKIP) was encountered. (*SKIP) signifies\nthat whatever text was matched leading up to it cannot be\npart of a successful match. Consider:\n\na+(*SKIP)b\n\nIf the subject\nis &quot;aaaac...&quot;, after the first match attempt fails\n(starting at the first character in the string), the\nstarting point skips on to start the next attempt at\n&quot;c&quot;. Note that a possessive quantifer does not\nhave the same effect as this example; although it would\nsuppress backtracking during the first match attempt, the\nsecond attempt would start at the second character instead\nof skipping on to &quot;c&quot;.\n\n\n(*SKIP:NAME)\n\nWhen (*SKIP)\nhas an associated name, its behaviour is modified. When it\nis triggered, the previous path through the pattern is\nsearched for the most recent (*MARK) that has the same name.\nIf one is found, the &quot;bumpalong&quot; advance is to the\nsubject position that corresponds to that (*MARK) instead of\nto where (*SKIP) was encountered. If no (*MARK) with a\nmatching name is found, the (*SKIP) is ignored.\n\nNote that\n(*SKIP:NAME) searches only for names set by (*MARK:NAME). It\nignores names that are set by (*PRUNE:NAME) or\n(*THEN:NAME).\n\n(*THEN) or\n(*THEN:NAME)\n\nThis verb\ncauses a skip to the next innermost alternative when\nbacktracking reaches it. That is, it cancels any further\nbacktracking within the current alternative. Its name comes\nfrom the observation that it can be used for a pattern-based\nif-then-else block:\n\n( COND1 (*THEN)\nFOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...\n\nIf the COND1\npattern matches, FOO is tried (and possibly further items\nafter the end of the group if FOO succeeds); on failure, the\nmatcher skips to the second alternative and tries COND2,\nwithout backtracking into COND1. If that succeeds and BAR\nfails, COND3 is tried. If subsequently BAZ fails, there are\nno more alternatives, so there is a backtrack to whatever\ncame before the entire group. If (*THEN) is not inside an\nalternation, it acts like (*PRUNE).\n\nThe behaviour\nof (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN).\nIt is like (*MARK:NAME) in that the name is remembered for\npassing back to the caller. However, (*SKIP:NAME) searches\nonly for names set with (*MARK).\n\nA subpattern\nthat does not contain a | character is just a part of the\nenclosing alternative; it is not a nested alternation with\nonly one alternative. The effect of (*THEN) extends beyond\nsuch a subpattern to the enclosing alternative. Consider\nthis pattern, where A, B, etc. are complex pattern fragments\nthat do not contain any | characters at this level:\n\nA (B(*THEN)C) |\nD\n\nIf A and B are\nmatched, but there is a failure in C, matching does not\nbacktrack into A; instead it moves to the next alternative,\nthat is, D. However, if the subpattern containing (*THEN) is\ngiven an alternative, it behaves differently:\n\nA (B(*THEN)C |\n(*FAIL)) | D\n\nThe effect of\n(*THEN) is now confined to the inner subpattern. After a\nfailure in C, matching moves to (*FAIL), which causes the\nwhole subpattern to fail because there are no more\nalternatives to try. In this case, matching does now\nbacktrack into A.\n\nNote that a\nconditional subpattern is not considered as having two\nalternatives, because only one is ever used. In other words,\nthe | character in a conditional subpattern has a different\nmeaning. Ignoring white space, consider:\n\n^.*? (?(?=a) a\n| b(*THEN)c )\n\nIf the subject\nis &quot;ba&quot;, this pattern does not match. Because .*?\nis ungreedy, it initially matches zero characters. The\ncondition (?=a) then fails, the character &quot;b&quot; is\nmatched, but &quot;c&quot; is not. At this point, matching\ndoes not backtrack to .*? as might perhaps be expected from\nthe presence of the | character. The conditional subpattern\nis part of the single alternative that comprises the whole\npattern, and so the match fails. (If there was a backtrack\ninto .*?, allowing it to match &quot;b&quot;, the match\nwould succeed.)\n\nThe verbs just\ndescribed provide four different &quot;strengths&quot; of\ncontrol when subsequent matching fails. (*THEN) is the\nweakest, carrying on the match at the next alternative.\n(*PRUNE) comes next, failing the match at the current\nstarting position, but allowing an advance to the next\ncharacter (for an unanchored pattern). (*SKIP) is similar,\nexcept that the advance may be more than one character.\n(*COMMIT) is the strongest, causing the entire match to\nfail.\n\n<b>More than\none backtracking verb</b>\n\nIf more than\none backtracking verb is present in a pattern, the one that\nis backtracked onto first acts. For example, consider this\npattern, where A, B, etc. are complex pattern fragments:\n\n\n(A(*COMMIT)B(*THEN)C|ABD)\n\nIf A matches\nbut B fails, the backtrack to (*COMMIT) causes the entire\nmatch to fail. However, if A and B match, but C fails, the\nbacktrack to (*THEN) causes the next alternative (ABD) to be\ntried. This behaviour is consistent, but is not always the\nsame as Perl&rsquo;s. It means that if two or more\nbacktracking verbs appear in succession, all the the last of\nthem has no effect. Consider this example:\n\n\n...(*COMMIT)(*PRUNE)...\n\nIf there is a\nmatching failure to the right, backtracking onto (*PRUNE)\ncauses it to be triggered, and its action is taken. There\ncan never be a backtrack onto (*COMMIT).\n\n\n<b>Backtracking\nverbs in repeated groups</b>\n\nPCRE differs\nfrom Perl in its handling of backtracking verbs in repeated\ngroups. For example, consider:\n\n\n/(a(*COMMIT)b)+ac/\n\nIf the subject\nis &quot;abac&quot;, Perl matches, but PCRE fails because\nthe (*COMMIT) in the second repeat of the group acts.\n\n\n<b>Backtracking\nverbs in assertions</b>\n\n(*FAIL) in an\nassertion has its normal effect: it forces an immediate\nbacktrack.\n\n(*ACCEPT) in a\npositive assertion causes the assertion to succeed without\nany further processing. In a negative assertion, (*ACCEPT)\ncauses the assertion to fail without any further\nprocessing.\n\nThe other\nbacktracking verbs are not treated specially if they appear\nin a positive assertion. In particular, (*THEN) skips to the\nnext alternative in the innermost enclosing group that has\nalternations, whether or not this is within the\nassertion.\n\nNegative\nassertions are, however, different, in order to ensure that\nchanging a positive assertion into a negative assertion\nchanges its result. Backtracking into (*COMMIT), (*SKIP), or\n(*PRUNE) causes a negative assertion to be true, without\nconsidering any further alternative branches in the\nassertion. Backtracking into (*THEN) causes it to skip to\nthe next enclosing alternative within the assertion (the\nnormal behaviour), but if the assertion does not have such\nan alternative, (*THEN) behaves like (*PRUNE).\n\n\n<b>Backtracking\nverbs in subroutines</b>\n\nThese\nbehaviours occur whether or not the subpattern is called\nrecursively. Perl&rsquo;s treatment of subroutines is\ndifferent in some cases.\n\n(*FAIL) in a\nsubpattern called as a subroutine has its normal effect: it\nforces an immediate backtrack.\n\n(*ACCEPT) in a\nsubpattern called as a subroutine causes the subroutine\nmatch to succeed without any further processing. Matching\nthen continues after the subroutine call.\n\n(*COMMIT),\n(*SKIP), and (*PRUNE) in a subpattern called as a subroutine\ncause the subroutine match to fail.\n\n(*THEN) skips\nto the next alternative in the innermost enclosing group\nwithin the subpattern that has alternatives. If there is no\nsuch group within the subpattern, (*THEN) causes the\nsubroutine match to fail.\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<a href=\"https://man.page/3/pcreapi\">pcreapi(3)</a>,\n<a href=\"https://man.page/3/pcrecallout\">pcrecallout(3)</a>, <a href=\"https://man.page/3/pcrematching\">pcrematching(3)</a>,\n<a href=\"https://man.page/3/pcresyntax\">pcresyntax(3)</a>, <a href=\"https://man.page/3/pcre\">pcre(3)</a>, <b>pcre16(3)</b>,\n<b>pcre32(3)</b>.\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\nPhilip Hazel\n<br>\nUniversity Computing Service <br>\nCambridge CB2 3QH, England.\n\n<h2>REVISION\n<a name=\"REVISION\"></a>\n</h2>\n\n\nLast updated:\n14 June 2015 <br>\nCopyright (c) 1997-2015 University of Cambridge.","body":"\n\n<h1 align=\"center\">PCREPATTERN</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE -\nPerl-compatible regular expressions</p>\n\n<h2>PCRE REGULAR EXPRESSION DETAILS\n<a name=\"PCRE REGULAR EXPRESSION DETAILS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The syntax and\nsemantics of the regular expressions that are supported by\nPCRE are described in detail below. There is a\nquick-reference syntax summary in the <b>pcresyntax</b>\npage. PCRE tries to match Perl syntax and semantics as\nclosely as it can. PCRE also supports some alternative\nregular expression syntax (which does not conflict with the\nPerl syntax) in order to provide some compatibility with\nregular expressions in Python, .NET, and Oniguruma.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl&rsquo;s\nregular expressions are described in its own documentation,\nand regular expressions in general are covered in a number\nof books, some of which have copious examples. Jeffrey\nFriedl&rsquo;s &quot;Mastering Regular Expressions&quot;,\npublished by O&rsquo;Reilly, covers regular expressions in\ngreat detail. This description of PCRE&rsquo;s regular\nexpressions is intended as reference material.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This document\ndiscusses the patterns that are supported by PCRE when one\nits main matching functions, <b>pcre_exec()</b> (8-bit) or\n<b>pcre[16|32]_exec()</b> (16- or 32-bit), is used. PCRE\nalso has alternative matching functions,\n<b>pcre_dfa_exec()</b> and <b>pcre[16|32_dfa_exec()</b>,\nwhich match using a different algorithm that is not\nPerl-compatible. Some of the features discussed below are\nnot available when DFA matching is used. The advantages and\ndisadvantages of the alternative functions, and how they\ndiffer from the normal functions, are discussed in the\n<b>pcrematching</b> page.</p>\n\n<h2>SPECIAL START-OF-PATTERN ITEMS\n<a name=\"SPECIAL START-OF-PATTERN ITEMS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A number of\noptions that can be passed to <b>pcre_compile()</b> can also\nbe set by special items at the start of a pattern. These are\nnot Perl-compatible, but are provided to make these options\naccessible to pattern writers who are not able to change the\nprogram that processes the pattern. Any number of these\nitems may appear, but they must all be together right at the\nstart of the pattern string, and the letters must be in\nupper case.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>UTF\nsupport</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The original\noperation of PCRE was on strings of one-byte characters.\nHowever, there is now also support for UTF-8 strings in the\noriginal library, an extra library that supports 16-bit and\nUTF-16 character strings, and a third library that supports\n32-bit and UTF-32 character strings. To use these features,\nPCRE must be built to include appropriate support. When\nusing UTF strings you must either call the compiling\nfunction with the PCRE_UTF8, PCRE_UTF16, or PCRE_UTF32\noption, or the pattern must start with one of these special\nsequences:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*UTF8) <br>\n(*UTF16) <br>\n(*UTF32) <br>\n(*UTF)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*UTF) is a\ngeneric sequence that can be used with any of the libraries.\nStarting a pattern with such a sequence is equivalent to\nsetting the relevant option. How setting a UTF mode affects\npattern matching is mentioned in several places below. There\nis also a summary of features in the <b>pcreunicode</b>\npage.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some\napplications that allow their users to supply patterns may\nwish to restrict them to non-UTF data for security reasons.\nIf the PCRE_NEVER_UTF option is set at compile time, (*UTF)\netc. are not allowed, and their appearance causes an\nerror.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Unicode\nproperty support</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another special\nsequence that may appear at the start of a pattern is\n(*UCP). This has the same effect as setting the PCRE_UCP\noption: it causes sequences such as \\d and \\w to use Unicode\nproperties to determine character types, instead of\nrecognizing only characters with codes less than 128 via a\nlookup table.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Disabling\nauto-possessification</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a pattern\nstarts with (*NO_AUTO_POSSESS), it has the same effect as\nsetting the PCRE_NO_AUTO_POSSESS option at compile time.\nThis stops PCRE from making quantifiers possessive when what\nfollows cannot match the repeated item. For example, by\ndefault a+b is treated as a++b. For more details, see the\n<b>pcreapi</b> documentation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Disabling\nstart-up optimizations</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a pattern\nstarts with (*NO_START_OPT), it has the same effect as\nsetting the PCRE_NO_START_OPTIMIZE option either at compile\nor matching time. This disables several optimizations for\nquickly reaching &quot;no match&quot; results. For more\ndetails, see the <b>pcreapi</b> documentation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Newline\nconventions</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE supports\nfive different conventions for indicating line breaks in\nstrings: a single CR (carriage return) character, a single\nLF (linefeed) character, the two-character sequence CRLF,\nany of the three preceding, or any Unicode newline sequence.\nThe <b>pcreapi</b> page has further discussion about\nnewlines, and shows how to set the newline convention in the\n<i>options</i> arguments for the compiling and matching\nfunctions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is also\npossible to specify a newline convention by starting a\npattern string with one of the following five sequences:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*CR) carriage\nreturn <br>\n(*LF) linefeed <br>\n(*CRLF) carriage return, followed by linefeed <br>\n(*ANYCRLF) any of the three above <br>\n(*ANY) all Unicode newline sequences</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These override\nthe default and the options given to the compiling function.\nFor example, on a Unix system where LF is the default\nnewline sequence, the pattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*CR)a.b</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">changes the\nconvention to CR. That pattern matches &quot;a\\nb&quot;\nbecause LF is no longer a newline. If more than one of these\nsettings is present, the last one is used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The newline\nconvention affects where the circumflex and dollar\nassertions are true. It also affects the interpretation of\nthe dot metacharacter when PCRE_DOTALL is not set, and the\nbehaviour of \\N. However, it does not affect what the \\R\nescape sequence matches. By default, this is any Unicode\nnewline sequence, for Perl compatibility. However, this can\nbe changed; see the description of \\R in the section\nentitled &quot;Newline sequences&quot; below. A change of \\R\nsetting can be combined with a change of newline\nconvention.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Setting\nmatch and recursion limits</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The caller of\n<b>pcre_exec()</b> can set a limit on the number of times\nthe internal <b>match()</b> function is called and on the\nmaximum depth of recursive calls. These facilities are\nprovided to catch runaway matches that are provoked by\npatterns with huge matching trees (a typical example is a\npattern with nested unlimited repeats) and to avoid running\nout of system stack by too much recursion. When one of these\nlimits is reached, <b>pcre_exec()</b> gives an error return.\nThe limits can also be set by items at the start of the\npattern of the form</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*LIMIT_MATCH=d)\n<br>\n(*LIMIT_RECURSION=d)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where d is any\nnumber of decimal digits. However, the value of the setting\nmust be less than the value set (or defaulted) by the caller\nof <b>pcre_exec()</b> for it to have any effect. In other\nwords, the pattern writer can lower the limits set by the\nprogrammer, but not raise them. If there is more than one\nsetting of one of these limits, the lower value is used.</p>\n\n<h2>EBCDIC CHARACTER CODES\n<a name=\"EBCDIC CHARACTER CODES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE can be\ncompiled to run in an environment that uses EBCDIC as its\ncharacter code rather than ASCII or Unicode (typically a\nmainframe system). In the sections below, character code\nvalues are ASCII or Unicode; in an EBCDIC environment these\ncharacters may have different code values, and there are no\ncode points greater than 255.</p>\n\n<h2>CHARACTERS AND METACHARACTERS\n<a name=\"CHARACTERS AND METACHARACTERS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A regular\nexpression is a pattern that is matched against a subject\nstring from left to right. Most characters stand for\nthemselves in a pattern, and match the corresponding\ncharacters in the subject. As a trivial example, the\npattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The quick brown\nfox</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches a\nportion of a subject string that is identical to itself.\nWhen caseless matching is specified (the PCRE_CASELESS\noption), letters are matched independently of case. In a UTF\nmode, PCRE always understands the concept of case for\ncharacters whose values are less than 128, so caseless\nmatching is always possible. For characters with higher\nvalues, the concept of case is supported if PCRE is compiled\nwith Unicode property support, but not otherwise. If you\nwant to use caseless matching for characters 128 and above,\nyou must ensure that PCRE is compiled with Unicode property\nsupport as well as with UTF support.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The power of\nregular expressions comes from the ability to include\nalternatives and repetitions in the pattern. These are\nencoded in the pattern by the use of <i>metacharacters</i>,\nwhich do not stand for themselves but instead are\ninterpreted in some special way.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\ndifferent sets of metacharacters: those that are recognized\nanywhere in the pattern except within square brackets, and\nthose that are recognized within square brackets. Outside\nsquare brackets, the metacharacters are as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\ general\nescape character with several uses <br>\n^ assert start of string (or line, in multiline mode) <br>\n$ assert end of string (or line, in multiline mode) <br>\n. match any character except newline (by default) <br>\n[ start character class definition <br>\n| start of alternative branch <br>\n( start subpattern <br>\n) end subpattern <br>\n? extends the meaning of ( <br>\nalso 0 or 1 quantifier <br>\nalso quantifier minimizer <br>\n* 0 or more quantifier <br>\n+ 1 or more quantifier <br>\nalso &quot;possessive quantifier&quot; <br>\n{ start min/max quantifier</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Part of a\npattern that is in square brackets is called a\n&quot;character class&quot;. In a character class the only\nmetacharacters are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\ general\nescape character <br>\n^ negate the class, but only if the first character <br>\n- indicates character range <br>\n[ POSIX character class (only if followed by POSIX <br>\nsyntax) <br>\n] terminates the character class</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nsections describe the use of each of the metacharacters.</p>\n\n<h2>BACKSLASH\n<a name=\"BACKSLASH\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The backslash\ncharacter has several uses. Firstly, if it is followed by a\ncharacter that is not a number or a letter, it takes away\nany special meaning that character may have. This use of\nbackslash as an escape character applies both inside and\noutside character classes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example, if\nyou want to match a * character, you write \\* in the\npattern. This escaping action applies whether or not the\nfollowing character would otherwise be interpreted as a\nmetacharacter, so it is always safe to precede a\nnon-alphanumeric with backslash to specify that it stands\nfor itself. In particular, if you want to match a backslash,\nyou write \\\\.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a UTF mode,\nonly ASCII numbers and letters have any special meaning\nafter a backslash. All other characters (in particular,\nthose whose codepoints are greater than 127) are treated as\nliterals.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a pattern is\ncompiled with the PCRE_EXTENDED option, most white space in\nthe pattern (other than in a character class), and\ncharacters between a # outside a character class and the\nnext newline, inclusive, are ignored. An escaping backslash\ncan be used to include a white space or # character as part\nof the pattern.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want to\nremove the special meaning from a sequence of characters,\nyou can do so by putting them between \\Q and \\E. This is\ndifferent from Perl in that $ and @ are handled as literals\nin \\Q...\\E sequences in PCRE, whereas in Perl, $ and @ cause\nvariable interpolation. Note the following examples:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Pattern PCRE\nmatches Perl matches</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\Qabc$xyz\\E\nabc$xyz abc followed by the <br>\ncontents of $xyz <br>\n\\Qabc\\$xyz\\E abc\\$xyz abc\\$xyz <br>\n\\Qabc\\E\\$\\Qxyz\\E abc$xyz abc$xyz</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The \\Q...\\E\nsequence is recognized both inside and outside character\nclasses. An isolated \\E that is not preceded by \\Q is\nignored. If \\Q is not followed by \\E later in the pattern,\nthe literal interpretation continues to the end of the\npattern (that is, \\E is assumed at the end). If the isolated\n\\Q is inside a character class, this causes an error,\nbecause the character class is not terminated.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Non-printing\ncharacters</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A second use of\nbackslash provides a way of encoding non-printing characters\nin patterns in a visible manner. There is no restriction on\nthe appearance of non-printing characters, apart from the\nbinary zero that terminates a pattern, but when a pattern is\nbeing prepared by text editing, it is often easier to use\none of the following escape sequences than the binary\ncharacter it represents. In an ASCII or Unicode environment,\nthese escapes are as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\a alarm, that\nis, the BEL character (hex 07) <br>\n\\cx &quot;control-x&quot;, where x is any ASCII character\n<br>\n\\e escape (hex 1B) <br>\n\\f form feed (hex 0C) <br>\n\\n linefeed (hex 0A) <br>\n\\r carriage return (hex 0D) <br>\n\\t tab (hex 09) <br>\n\\0dd character with octal code 0dd <br>\n\\ddd character with octal code ddd, or back reference <br>\n\\o{ddd..} character with octal code ddd.. <br>\n\\xhh character with hex code hh <br>\n\\x{hhh..} character with hex code hhh.. (non-JavaScript\nmode) <br>\n\\uhhhh character with hex code hhhh (JavaScript mode\nonly)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The precise\neffect of \\cx on ASCII characters is as follows: if x is a\nlower case letter, it is converted to upper case. Then bit 6\nof the character (hex 40) is inverted. Thus \\cA to \\cZ\nbecome hex 01 to hex 1A (A is 41, Z is 5A), but \\c{ becomes\nhex 3B ({ is 7B), and \\c; becomes hex 7B (; is 3B). If the\ndata item (byte or 16-bit value) following \\c has a value\ngreater than 127, a compile-time error occurs. This locks\nout non-ASCII characters in all modes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When PCRE is\ncompiled in EBCDIC mode, \\a, \\e, \\f, \\n, \\r, and \\t generate\nthe appropriate EBCDIC code values. The \\c escape is\nprocessed as specified for Perl in the <b>perlebcdic</b>\ndocument. The only characters that are allowed after \\c are\nA-Z, a-z, or one of @, [, \\, ], ^, _, or ?. Any other\ncharacter provokes a compile-time error. The sequence \\@\nencodes character code 0; the letters (in either case)\nencode characters 1-26 (hex 01 to hex 1A); [, \\, ], ^, and _\nencode characters 27-31 (hex 1B to hex 1F), and \\? becomes\neither 255 (hex FF) or 95 (hex 5F).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Thus, apart\nfrom \\?, these escapes generate the same character code\nvalues as they do in an ASCII environment, though the\nmeanings of the values mostly differ. For example, \\G always\ngenerates code value 7, which is BEL in ASCII but DEL in\nEBCDIC.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sequence \\?\ngenerates DEL (127, hex 7F) in an ASCII environment, but\nbecause 127 is not a control character in EBCDIC, Perl makes\nit generate the APC character. Unfortunately, there are\nseveral variants of EBCDIC. In most of them the APC\ncharacter has the value 255 (hex FF), but in the one Perl\ncalls POSIX-BC its value is 95 (hex 5F). If certain other\ncharacters have POSIX-BC values, PCRE makes \\? generate 95;\notherwise it generates 255.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After \\0 up to\ntwo further octal digits are read. If there are fewer than\ntwo digits, just those that are present are used. Thus the\nsequence \\0\\x\\015 specifies two binary zeros followed by a\nCR character (code value 13). Make sure you supply two\ndigits after the initial zero if the pattern character that\nfollows is itself an octal digit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The escape \\o\nmust be followed by a sequence of octal digits, enclosed in\nbraces. An error occurs if this is not the case. This escape\nis a recent addition to Perl; it provides way of specifying\ncharacter code points as octal numbers greater than 0777,\nand it also allows octal numbers and back references to be\nunambiguously specified.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For greater\nclarity and unambiguity, it is best to avoid following \\ by\na digit greater than zero. Instead, use \\o{} or \\x{} to\nspecify character numbers, and \\g{} to specify back\nreferences. The following paragraphs describe the old,\nambiguous syntax.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The handling of\na backslash followed by a digit other than 0 is complicated,\nand Perl has changed in recent releases, causing PCRE also\nto change. Outside a character class, PCRE reads the digit\nand any following digits as a decimal number. If the number\nis less than 8, or if there have been at least that many\nprevious capturing left parentheses in the expression, the\nentire sequence is taken as a <i>back reference</i>. A\ndescription of how this works is given later, following the\ndiscussion of parenthesized subpatterns.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inside a\ncharacter class, or if the decimal number following \\ is\ngreater than 7 and there have not been that many capturing\nsubpatterns, PCRE handles \\8 and \\9 as the literal\ncharacters &quot;8&quot; and &quot;9&quot;, and otherwise\nre-reads up to three octal digits following the backslash,\nusing them to generate a data character. Any subsequent\ndigits stand for themselves. For example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\040 is another\nway of writing an ASCII space <br>\n\\40 is the same, provided there are fewer than 40 <br>\nprevious capturing subpatterns <br>\n\\7 is always a back reference <br>\n\\11 might be a back reference, or another way of <br>\nwriting a tab <br>\n\\011 is always a tab <br>\n\\0113 is a tab followed by the character &quot;3&quot; <br>\n\\113 might be a back reference, otherwise the <br>\ncharacter with octal code 113 <br>\n\\377 might be a back reference, otherwise <br>\nthe value 255 (decimal) <br>\n\\81 is either a back reference, or the two <br>\ncharacters &quot;8&quot; and &quot;1&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that octal\nvalues of 100 or greater that are specified using this\nsyntax must not be introduced by a leading zero, because no\nmore than three octal digits are ever read.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nafter \\x that is not followed by {, from zero to two\nhexadecimal digits are read (letters can be in upper or\nlower case). Any number of hexadecimal digits may appear\nbetween \\x{ and }. If a character other than a hexadecimal\ndigit appears between \\x{ and }, or if there is no\nterminating }, an error occurs.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nPCRE_JAVASCRIPT_COMPAT option is set, the interpretation of\n\\x is as just described only when it is followed by two\nhexadecimal digits. Otherwise, it matches a literal\n&quot;x&quot; character. In JavaScript mode, support for\ncode points greater than 256 is provided by \\u, which must\nbe followed by four hexadecimal digits; otherwise it matches\na literal &quot;u&quot; character.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Characters\nwhose value is less than 256 can be defined by either of the\ntwo syntaxes for \\x (or by \\u in JavaScript mode). There is\nno difference in the way they are handled. For example, \\xdc\nis exactly the same as \\x{dc} (or \\u00dc in JavaScript\nmode).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Constraints\non character values</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Characters that\nare specified using octal or hexadecimal numbers are limited\nto certain values, as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">8-bit non-UTF\nmode less than 0x100 <br>\n8-bit UTF-8 mode less than 0x10ffff and a valid codepoint\n<br>\n16-bit non-UTF mode less than 0x10000 <br>\n16-bit UTF-16 mode less than 0x10ffff and a valid codepoint\n<br>\n32-bit non-UTF mode less than 0x100000000 <br>\n32-bit UTF-32 mode less than 0x10ffff and a valid\ncodepoint</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Invalid Unicode\ncodepoints are the range 0xd800 to 0xdfff (the so-called\n&quot;surrogate&quot; codepoints), and 0xffef.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Escape\nsequences in character classes</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All the\nsequences that define a single character value can be used\nboth inside and outside character classes. In addition,\ninside a character class, \\b is interpreted as the backspace\ncharacter (hex 08).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\N is not\nallowed in a character class. \\B, \\R, and \\X are not special\ninside a character class. Like other unrecognized escape\nsequences, they are treated as the literal characters\n&quot;B&quot;, &quot;R&quot;, and &quot;X&quot; by default,\nbut cause an error if the PCRE_EXTRA option is set. Outside\na character class, these sequences have different\nmeanings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Unsupported\nescape sequences</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In Perl, the\nsequences \\l, \\L, \\u, and \\U are recognized by its string\nhandler and used to modify the case of following characters.\nBy default, PCRE does not support these escape sequences.\nHowever, if the PCRE_JAVASCRIPT_COMPAT option is set, \\U\nmatches a &quot;U&quot; character, and \\u can be used to\ndefine a character by code point, as described in the\nprevious section.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Absolute and\nrelative back references</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sequence \\g\nfollowed by an unsigned or a negative number, optionally\nenclosed in braces, is an absolute or relative back\nreference. A named back reference can be coded as \\g{name}.\nBack references are discussed later, following the\ndiscussion of parenthesized subpatterns.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Absolute and\nrelative subroutine calls</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\ncompatibility with Oniguruma, the non-Perl syntax \\g\nfollowed by a name or a number enclosed either in angle\nbrackets or single quotes, is an alternative syntax for\nreferencing a subpattern as a &quot;subroutine&quot;.\nDetails are discussed later. Note that \\g{...} (Perl syntax)\nand \\g&lt;...&gt; (Oniguruma syntax) are <i>not</i>\nsynonymous. The former is a back reference; the latter is a\nsubroutine call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Generic\ncharacter types</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another use of\nbackslash is for specifying generic character types:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\d any decimal\ndigit <br>\n\\D any character that is not a decimal digit <br>\n\\h any horizontal white space character <br>\n\\H any character that is not a horizontal white space\ncharacter <br>\n\\s any white space character <br>\n\\S any character that is not a white space character <br>\n\\v any vertical white space character <br>\n\\V any character that is not a vertical white space\ncharacter <br>\n\\w any &quot;word&quot; character <br>\n\\W any &quot;non-word&quot; character</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is also\nthe single sequence \\N, which matches a non-newline\ncharacter. This is the same as the &quot;.&quot;\nmetacharacter when PCRE_DOTALL is not set. Perl also uses \\N\nto match characters by name; PCRE does not support this.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each pair of\nlower and upper case escape sequences partitions the\ncomplete set of characters into two disjoint sets. Any given\ncharacter matches one, and only one, of each pair. The\nsequences can appear both inside and outside character\nclasses. They each match one character of the appropriate\ntype. If the current matching point is at the end of the\nsubject string, all of them fail, because there is no\ncharacter to match.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\ncompatibility with Perl, \\s did not used to match the VT\ncharacter (code 11), which made it different from the the\nPOSIX &quot;space&quot; class. However, Perl added VT at\nrelease 5.18, and PCRE followed suit at release 8.34. The\ndefault \\s characters are now HT (9), LF (10), VT (11), FF\n(12), CR (13), and space (32), which are defined as white\nspace in the &quot;C&quot; locale. This list may vary if\nlocale-specific matching is taking place. For example, in\nsome locales the &quot;non-breaking space&quot; character\n(\\xA0) is recognized as white space, and in others the VT\ncharacter is not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A\n&quot;word&quot; character is an underscore or any character\nthat is a letter or digit. By default, the definition of\nletters and digits is controlled by PCRE&rsquo;s low-valued\ncharacter tables, and may vary if locale-specific matching\nis taking place (see &quot;Locale support&quot; in the\n<b>pcreapi</b> page). For example, in a French locale such\nas &quot;fr_FR&quot; in Unix-like systems, or\n&quot;french&quot; in Windows, some character codes greater\nthan 127 are used for accented letters, and these are then\nmatched by \\w. The use of locales with Unicode is\ndiscouraged.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\ncharacters whose code points are greater than 127 never\nmatch \\d, \\s, or \\w, and always match \\D, \\S, and \\W,\nalthough this may vary for characters in the range 128-255\nwhen locale-specific matching is happening. These escape\nsequences retain their original meanings from before Unicode\nsupport was available, mainly for efficiency reasons. If\nPCRE is compiled with Unicode property support, and the\nPCRE_UCP option is set, the behaviour is changed so that\nUnicode properties are used to determine character types, as\nfollows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\d any\ncharacter that matches \\p{Nd} (decimal digit) <br>\n\\s any character that matches \\p{Z} or \\h or \\v <br>\n\\w any character that matches \\p{L} or \\p{N}, plus\nunderscore</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The upper case\nescapes match the inverse sets of characters. Note that \\d\nmatches only decimal digits, whereas \\w matches any Unicode\ndigit, as well as any Unicode letter, and underscore. Note\nalso that PCRE_UCP affects \\b, and \\B because they are\ndefined in terms of \\w and \\W. Matching these sequences is\nnoticeably slower when PCRE_UCP is set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sequences\n\\h, \\H, \\v, and \\V are features that were added to Perl at\nrelease 5.10. In contrast to the other sequences, which\nmatch only ASCII characters by default, these always match\ncertain high-valued code points, whether or not PCRE_UCP is\nset. The horizontal space characters are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">U+0009\nHorizontal tab (HT) <br>\nU+0020 Space <br>\nU+00A0 Non-break space <br>\nU+1680 Ogham space mark <br>\nU+180E Mongolian vowel separator <br>\nU+2000 En quad <br>\nU+2001 Em quad <br>\nU+2002 En space <br>\nU+2003 Em space <br>\nU+2004 Three-per-em space <br>\nU+2005 Four-per-em space <br>\nU+2006 Six-per-em space <br>\nU+2007 Figure space <br>\nU+2008 Punctuation space <br>\nU+2009 Thin space <br>\nU+200A Hair space <br>\nU+202F Narrow no-break space <br>\nU+205F Medium mathematical space <br>\nU+3000 Ideographic space</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The vertical\nspace characters are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">U+000A Linefeed\n(LF) <br>\nU+000B Vertical tab (VT) <br>\nU+000C Form feed (FF) <br>\nU+000D Carriage return (CR) <br>\nU+0085 Next line (NEL) <br>\nU+2028 Line separator <br>\nU+2029 Paragraph separator</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In 8-bit,\nnon-UTF-8 mode, only the characters with codepoints less\nthan 256 are relevant.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Newline\nsequences</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Outside a\ncharacter class, by default, the escape sequence \\R matches\nany Unicode newline sequence. In 8-bit non-UTF-8 mode \\R is\nequivalent to the following:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&gt;\\r\\n|\\n|\\x0b|\\f|\\r|\\x85)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is an\nexample of an &quot;atomic group&quot;, details of which are\ngiven below. This particular group matches either the\ntwo-character sequence CR followed by LF, or one of the\nsingle characters LF (linefeed, U+000A), VT (vertical tab,\nU+000B), FF (form feed, U+000C), CR (carriage return,\nU+000D), or NEL (next line, U+0085). The two-character\nsequence is treated as a single unit that cannot be\nsplit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In other modes,\ntwo additional characters whose codepoints are greater than\n255 are added: LS (line separator, U+2028) and PS (paragraph\nseparator, U+2029). Unicode character property support is\nnot needed for these characters to be recognized.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is possible\nto restrict \\R to match only CR, LF, or CRLF (instead of the\ncomplete set of Unicode line endings) by setting the option\nPCRE_BSR_ANYCRLF either at compile time or when the pattern\nis matched. (BSR is an abbrevation for &quot;backslash\nR&quot;.) This can be made the default when PCRE is built;\nif this is the case, the other behaviour can be requested\nvia the PCRE_BSR_UNICODE option. It is also possible to\nspecify these settings by starting a pattern string with one\nof the following sequences:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*BSR_ANYCRLF)\nCR, LF, or CRLF only <br>\n(*BSR_UNICODE) any Unicode newline sequence</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These override\nthe default and the options given to the compiling function,\nbut they can themselves be overridden by options given to a\nmatching function. Note that these special settings, which\nare not Perl-compatible, are recognized only at the very\nstart of a pattern, and that they must be in upper case. If\nmore than one of them is present, the last one is used. They\ncan be combined with a change of newline convention; for\nexample, a pattern can start with:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*ANY)(*BSR_ANYCRLF)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">They can also\nbe combined with the (*UTF8), (*UTF16), (*UTF32), (*UTF) or\n(*UCP) special sequences. Inside a character class, \\R is\ntreated as an unrecognized escape sequence, and so matches\nthe letter &quot;R&quot; by default, but causes an error if\nPCRE_EXTRA is set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Unicode\ncharacter properties</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When PCRE is\nbuilt with Unicode character property support, three\nadditional escape sequences that match characters with\nspecific properties are available. When in 8-bit non-UTF-8\nmode, these sequences are of course limited to testing\ncharacters whose codepoints are less than 256, but they do\nwork in this mode. The extra escape sequences are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\p{<i>xx</i>} a\ncharacter with the <i>xx</i> property <br>\n\\P{<i>xx</i>} a character without the <i>xx</i> property\n<br>\n\\X a Unicode extended grapheme cluster</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The property\nnames represented by <i>xx</i> above are limited to the\nUnicode script names, the general category properties,\n&quot;Any&quot;, which matches any character (including\nnewline), and some special PCRE properties (described in the\nnext section). Other Perl properties such as\n&quot;InMusicalSymbols&quot; are not currently supported by\nPCRE. Note that \\P{Any} does not match any characters, so\nalways causes a match failure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Sets of Unicode\ncharacters are defined as belonging to certain scripts. A\ncharacter from one of these sets can be matched using a\nscript name. For example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\p{Greek} <br>\n\\P{Han}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Those that are\nnot part of an identified script are lumped together as\n&quot;Common&quot;. The current list of scripts is:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Arabic,\nArmenian, Avestan, Balinese, Bamum, Bassa_Vah, Batak,\nBengali, Bopomofo, Brahmi, Braille, Buginese, Buhid,\nCanadian_Aboriginal, Carian, Caucasian_Albanian, Chakma,\nCham, Cherokee, Common, Coptic, Cuneiform, Cypriot,\nCyrillic, Deseret, Devanagari, Duployan,\nEgyptian_Hieroglyphs, Elbasan, Ethiopic, Georgian,\nGlagolitic, Gothic, Grantha, Greek, Gujarati, Gurmukhi, Han,\nHangul, Hanunoo, Hebrew, Hiragana, Imperial_Aramaic,\nInherited, Inscriptional_Pahlavi, Inscriptional_Parthian,\nJavanese, Kaithi, Kannada, Katakana, Kayah_Li, Kharoshthi,\nKhmer, Khojki, Khudawadi, Lao, Latin, Lepcha, Limbu,\nLinear_A, Linear_B, Lisu, Lycian, Lydian, Mahajani,\nMalayalam, Mandaic, Manichaean, Meetei_Mayek, Mende_Kikakui,\nMeroitic_Cursive, Meroitic_Hieroglyphs, Miao, Modi,\nMongolian, Mro, Myanmar, Nabataean, New_Tai_Lue, Nko, Ogham,\nOl_Chiki, Old_Italic, Old_North_Arabian, Old_Permic,\nOld_Persian, Old_South_Arabian, Old_Turkic, Oriya, Osmanya,\nPahawh_Hmong, Palmyrene, Pau_Cin_Hau, Phags_Pa, Phoenician,\nPsalter_Pahlavi, Rejang, Runic, Samaritan, Saurashtra,\nSharada, Shavian, Siddham, Sinhala, Sora_Sompeng, Sundanese,\nSyloti_Nagri, Syriac, Tagalog, Tagbanwa, Tai_Le, Tai_Tham,\nTai_Viet, Takri, Tamil, Telugu, Thaana, Thai, Tibetan,\nTifinagh, Tirhuta, Ugaritic, Vai, Warang_Citi, Yi.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each character\nhas exactly one Unicode general category property, specified\nby a two-letter abbreviation. For compatibility with Perl,\nnegation can be specified by including a circumflex between\nthe opening brace and the property name. For example,\n\\p{^Lu} is the same as \\P{Lu}.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If only one\nletter is specified with \\p or \\P, it includes all the\ngeneral category properties that start with that letter. In\nthis case, in the absence of negation, the curly brackets in\nthe escape sequence are optional; these two examples have\nthe same effect:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\p{L} <br>\n\\pL</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\ngeneral category property codes are supported:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">C Other <br>\nCc Control <br>\nCf Format <br>\nCn Unassigned <br>\nCo Private use <br>\nCs Surrogate</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">L Letter <br>\nLl Lower case letter <br>\nLm Modifier letter <br>\nLo Other letter <br>\nLt Title case letter <br>\nLu Upper case letter</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">M Mark <br>\nMc Spacing mark <br>\nMe Enclosing mark <br>\nMn Non-spacing mark</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">N Number <br>\nNd Decimal number <br>\nNl Letter number <br>\nNo Other number</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">P Punctuation\n<br>\nPc Connector punctuation <br>\nPd Dash punctuation <br>\nPe Close punctuation <br>\nPf Final punctuation <br>\nPi Initial punctuation <br>\nPo Other punctuation <br>\nPs Open punctuation</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">S Symbol <br>\nSc Currency symbol <br>\nSk Modifier symbol <br>\nSm Mathematical symbol <br>\nSo Other symbol</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Z Separator\n<br>\nZl Line separator <br>\nZp Paragraph separator <br>\nZs Space separator</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The special\nproperty L&amp; is also supported: it matches a character\nthat has the Lu, Ll, or Lt property, in other words, a\nletter that is not classified as a modifier or\n&quot;other&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Cs\n(Surrogate) property applies only to characters in the range\nU+D800 to U+DFFF. Such characters are not valid in Unicode\nstrings and so cannot be tested by PCRE, unless UTF validity\nchecking has been turned off (see the discussion of\nPCRE_NO_UTF8_CHECK, PCRE_NO_UTF16_CHECK and\nPCRE_NO_UTF32_CHECK in the <b>pcreapi</b> page). Perl does\nnot support the Cs property.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The long\nsynonyms for property names that Perl supports (such as\n\\p{Letter}) are not supported by PCRE, nor is it permitted\nto prefix any of these properties with &quot;Is&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">No character\nthat is in the Unicode table has the Cn (unassigned)\nproperty. Instead, this property is assumed for any code\npoint that is not in the Unicode table.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Specifying\ncaseless matching does not affect these escape sequences.\nFor example, \\p{Lu} always matches only upper case letters.\nThis is different from the behaviour of current versions of\nPerl.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Matching\ncharacters by Unicode property is not fast, because PCRE has\nto do a multistage table lookup in order to find a\ncharacter&rsquo;s property. That is why the traditional\nescape sequences such as \\d and \\w do not use Unicode\nproperties in PCRE by default, though you can make them do\nso by setting the PCRE_UCP option or by starting the pattern\nwith (*UCP).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Extended\ngrapheme clusters</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The \\X escape\nmatches any number of Unicode characters that form an\n&quot;extended grapheme cluster&quot;, and treats the\nsequence as an atomic group (see below). Up to and including\nrelease 8.31, PCRE matched an earlier, simpler definition\nthat was equivalent to</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&gt;\\PM\\pM*)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That is, it\nmatched a character without the &quot;mark&quot; property,\nfollowed by zero or more characters with the\n&quot;mark&quot; property. Characters with the\n&quot;mark&quot; property are typically non-spacing accents\nthat affect the preceding character.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This simple\ndefinition was extended in Unicode to include more\ncomplicated kinds of composite character by giving each\ncharacter a grapheme breaking property, and creating rules\nthat use these properties to define the boundaries of\nextended grapheme clusters. In releases of PCRE later than\n8.31, \\X matches one of these clusters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\X always\nmatches at least one character. Then it decides whether to\nadd additional characters according to the following rules\nfor ending a cluster:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">1. End at the\nend of the subject string.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">2. Do not end\nbetween CR and LF; otherwise end after any control\ncharacter.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">3. Do not break\nHangul (a Korean script) syllable sequences. Hangul\ncharacters are of five types: L, V, T, LV, and LVT. An L\ncharacter may be followed by an L, V, LV, or LVT character;\nan LV or V character may be followed by a V or T character;\nan LVT or T character may be follwed only by a T\ncharacter.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">4. Do not end\nbefore extending characters or spacing marks. Characters\nwith the &quot;mark&quot; property always have the\n&quot;extend&quot; grapheme breaking property.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">5. Do not end\nafter prepend characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">6. Otherwise,\nend the cluster.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>PCRE&rsquo;s\nadditional properties</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As well as the\nstandard Unicode properties described above, PCRE supports\nfour more that make it possible to convert traditional\nescape sequences such as \\w and \\s to use Unicode\nproperties. PCRE uses these non-standard, non-Perl\nproperties internally when PCRE_UCP is set. However, they\nmay also be used explicitly. These properties are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Xan Any\nalphanumeric character <br>\nXps Any POSIX space character <br>\nXsp Any Perl space character <br>\nXwd Any Perl &quot;word&quot; character</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Xan matches\ncharacters that have either the L (letter) or the N (number)\nproperty. Xps matches the characters tab, linefeed, vertical\ntab, form feed, or carriage return, and any other character\nthat has the Z (separator) property. Xsp is the same as Xps;\nit used to exclude vertical tab, for Perl compatibility, but\nPerl changed, and so PCRE followed at release 8.34. Xwd\nmatches the same characters as Xan, plus underscore.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is\nanother non-standard property, Xuc, which matches any\ncharacter that can be represented by a Universal Character\nName in C++ and other programming languages. These are the\ncharacters $, @, &rsquo; (grave accent), and all characters\nwith Unicode code points greater than or equal to U+00A0,\nexcept for the surrogates U+D800 to U+DFFF. Note that most\nbase (ASCII) characters are excluded. (Universal Character\nNames are of the form \\uHHHH or \\UHHHHHHHH where H is a\nhexadecimal digit. Note that the Xuc property does not match\nthese sequences but the characters that they represent.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Resetting\nthe match start</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The escape\nsequence \\K causes any previously matched characters not to\nbe included in the final matched sequence. For example, the\npattern:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">foo\\Kbar</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;foobar&quot;, but reports that it has matched\n&quot;bar&quot;. This feature is similar to a lookbehind\nassertion (described below). However, in this case, the part\nof the subject before the real match does not have to be of\nfixed length, as lookbehind assertions do. The use of \\K\ndoes not interfere with the setting of captured substrings.\nFor example, when the pattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(foo)\\Kbar</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;foobar&quot;, the first substring is still set to\n&quot;foo&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl documents\nthat the use of \\K within assertions is &quot;not well\ndefined&quot;. In PCRE, \\K is acted upon when it occurs\ninside positive assertions, but is ignored in negative\nassertions. Note that when a pattern such as (?=ab\\K)\nmatches, the reported start of the match can be greater than\nthe end of the match.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Simple\nassertions</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The final use\nof backslash is for certain simple assertions. An assertion\nspecifies a condition that has to be met at a particular\npoint in a match, without consuming any characters from the\nsubject string. The use of subpatterns for more complicated\nassertions is described below. The backslashed assertions\nare:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\b matches at a\nword boundary <br>\n\\B matches when not at a word boundary <br>\n\\A matches at the start of the subject <br>\n\\Z matches at the end of the subject <br>\nalso matches before a newline at the end of the subject <br>\n\\z matches only at the end of the subject <br>\n\\G matches at the first matching position in the subject</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Inside a\ncharacter class, \\b has a different meaning; it matches the\nbackspace character. If any other of these assertions\nappears in a character class, by default it matches the\ncorresponding literal character (for example, \\B matches the\nletter B). However, if the PCRE_EXTRA option is set, an\n&quot;invalid escape sequence&quot; error is generated\ninstead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A word boundary\nis a position in the subject string where the current\ncharacter and the previous character do not both match \\w or\n\\W (i.e. one matches \\w and the other matches \\W), or the\nstart or end of the string if the first or last character\nmatches \\w, respectively. In a UTF mode, the meanings of \\w\nand \\W can be changed by setting the PCRE_UCP option. When\nthis is done, it also affects \\b and \\B. Neither PCRE nor\nPerl has a separate &quot;start of word&quot; or &quot;end\nof word&quot; metasequence. However, whatever follows \\b\nnormally determines which it is. For example, the fragment\n\\ba matches &quot;a&quot; at the start of a word.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The \\A, \\Z, and\n\\z assertions differ from the traditional circumflex and\ndollar (described in the next section) in that they only\never match at the very start and end of the subject string,\nwhatever options are set. Thus, they are independent of\nmultiline mode. These three assertions are not affected by\nthe PCRE_NOTBOL or PCRE_NOTEOL options, which affect only\nthe behaviour of the circumflex and dollar metacharacters.\nHowever, if the <i>startoffset</i> argument of\n<b>pcre_exec()</b> is non-zero, indicating that matching is\nto start at a point other than the beginning of the subject,\n\\A can never match. The difference between \\Z and \\z is that\n\\Z matches before a newline at the end of the string as well\nas at the very end, whereas \\z matches only at the end.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The \\G\nassertion is true only when the current matching position is\nat the start point of the match, as specified by the\n<i>startoffset</i> argument of <b>pcre_exec()</b>. It\ndiffers from \\A when the value of <i>startoffset</i> is\nnon-zero. By calling <b>pcre_exec()</b> multiple times with\nappropriate arguments, you can mimic Perl&rsquo;s /g option,\nand it is in this kind of implementation where \\G can be\nuseful.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note, however,\nthat PCRE&rsquo;s interpretation of \\G, as the start of the\ncurrent match, is subtly different from Perl&rsquo;s, which\ndefines it as the end of the previous match. In Perl, these\ncan be different when the previously matched string was\nempty. Because PCRE does just one match at a time, it cannot\nreproduce this behaviour.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If all the\nalternatives of a pattern begin with \\G, the expression is\nanchored to the starting match position, and the\n&quot;anchored&quot; flag is set in the compiled regular\nexpression.</p>\n\n<h2>CIRCUMFLEX AND DOLLAR\n<a name=\"CIRCUMFLEX AND DOLLAR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The circumflex\nand dollar metacharacters are zero-width assertions. That\nis, they test for a particular condition being true without\nconsuming any characters from the subject string.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Outside a\ncharacter class, in the default matching mode, the\ncircumflex character is an assertion that is true only if\nthe current matching point is at the start of the subject\nstring. If the <i>startoffset</i> argument of\n<b>pcre_exec()</b> is non-zero, circumflex can never match\nif the PCRE_MULTILINE option is unset. Inside a character\nclass, circumflex has an entirely different meaning (see\nbelow).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Circumflex need\nnot be the first character of the pattern if a number of\nalternatives are involved, but it should be the first thing\nin each alternative in which it appears if the pattern is\never to match that branch. If all possible alternatives\nstart with a circumflex, that is, if the pattern is\nconstrained to match only at the start of the subject, it is\nsaid to be an &quot;anchored&quot; pattern. (There are also\nother constructs that can cause a pattern to be\nanchored.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The dollar\ncharacter is an assertion that is true only if the current\nmatching point is at the end of the subject string, or\nimmediately before a newline at the end of the string (by\ndefault). Note, however, that it does not actually match the\nnewline. Dollar need not be the last character of the\npattern if a number of alternatives are involved, but it\nshould be the last item in any branch in which it appears.\nDollar has no special meaning in a character class.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The meaning of\ndollar can be changed so that it matches only at the very\nend of the string, by setting the PCRE_DOLLAR_ENDONLY option\nat compile time. This does not affect the \\Z assertion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The meanings of\nthe circumflex and dollar characters are changed if the\nPCRE_MULTILINE option is set. When this is the case, a\ncircumflex matches immediately after internal newlines as\nwell as at the start of the subject string. It does not\nmatch after a newline that ends the string. A dollar matches\nbefore any newlines in the string, as well as at the very\nend, when PCRE_MULTILINE is set. When newline is specified\nas the two-character sequence CRLF, isolated CR and LF\ncharacters do not indicate newlines.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nthe pattern /^abc$/ matches the subject string\n&quot;def\\nabc&quot; (where \\n represents a newline) in\nmultiline mode, but not otherwise. Consequently, patterns\nthat are anchored in single line mode because all branches\nstart with ^ are not anchored in multiline mode, and a match\nfor circumflex is possible when the <i>startoffset</i>\nargument of <b>pcre_exec()</b> is non-zero. The\nPCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is\nset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nsequences \\A, \\Z, and \\z can be used to match the start and\nend of the subject in both modes, and if all branches of a\npattern start with \\A it is always anchored, whether or not\nPCRE_MULTILINE is set.</p>\n\n<h2>FULL STOP (PERIOD, DOT) AND \\N\n<a name=\"FULL STOP (PERIOD, DOT) AND \\N\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Outside a\ncharacter class, a dot in the pattern matches any one\ncharacter in the subject string except (by default) a\ncharacter that signifies the end of a line.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a line\nending is defined as a single character, dot never matches\nthat character; when the two-character sequence CRLF is\nused, dot does not match CR if it is immediately followed by\nLF, but otherwise it matches all characters (including\nisolated CRs and LFs). When any Unicode line endings are\nbeing recognized, dot does not match CR or LF or any of the\nother line ending characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The behaviour\nof dot with regard to newlines can be changed. If the\nPCRE_DOTALL option is set, a dot matches any one character,\nwithout exception. If the two-character sequence CRLF is\npresent in the subject string, it takes two dots to match\nit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The handling of\ndot is entirely independent of the handling of circumflex\nand dollar, the only relationship being that they both\ninvolve newlines. Dot has no special meaning in a character\nclass.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The escape\nsequence \\N behaves like a dot, except that it is not\naffected by the PCRE_DOTALL option. In other words, it\nmatches any character except one that signifies the end of a\nline. Perl also uses \\N to match characters by name; PCRE\ndoes not support this.</p>\n\n<h2>MATCHING A SINGLE DATA UNIT\n<a name=\"MATCHING A SINGLE DATA UNIT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Outside a\ncharacter class, the escape sequence \\C matches any one data\nunit, whether or not a UTF mode is set. In the 8-bit\nlibrary, one data unit is one byte; in the 16-bit library it\nis a 16-bit unit; in the 32-bit library it is a 32-bit unit.\nUnlike a dot, \\C always matches line-ending characters. The\nfeature is provided in Perl in order to match individual\nbytes in UTF-8 mode, but it is unclear how it can usefully\nbe used. Because \\C breaks up characters into individual\ndata units, matching one unit with \\C in a UTF mode means\nthat the rest of the string may start with a malformed UTF\ncharacter. This has undefined results, because PCRE assumes\nthat it is dealing with valid UTF strings (and by default it\nchecks this at the start of processing unless the\nPCRE_NO_UTF8_CHECK, PCRE_NO_UTF16_CHECK or\nPCRE_NO_UTF32_CHECK option is used).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE does not\nallow \\C to appear in lookbehind assertions (described\nbelow) in a UTF mode, because this would make it impossible\nto calculate the length of the lookbehind.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In general, the\n\\C escape sequence is best avoided. However, one way of\nusing it that avoids the problem of malformed UTF characters\nis to use a lookahead to check the length of the next\ncharacter, as in this pattern, which could be used with a\nUTF-8 string (ignore white space and line breaks):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?|\n(?=[\\x00-\\x7f])(\\C) | <br>\n(?=[\\x80-\\x{7ff}])(\\C)(\\C) | <br>\n(?=[\\x{800}-\\x{ffff}])(\\C)(\\C)(\\C) | <br>\n(?=[\\x{10000}-\\x{1fffff}])(\\C)(\\C)(\\C)(\\C))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A group that\nstarts with (?| resets the capturing parentheses numbers in\neach alternative (see &quot;Duplicate Subpattern\nNumbers&quot; below). The assertions at the start of each\nbranch check the next UTF-8 character for values whose\nencoding uses 1, 2, 3, or 4 bytes, respectively. The\ncharacter&rsquo;s individual bytes are then captured by the\nappropriate number of groups.</p>\n\n<h2>SQUARE BRACKETS AND CHARACTER CLASSES\n<a name=\"SQUARE BRACKETS AND CHARACTER CLASSES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">An opening\nsquare bracket introduces a character class, terminated by a\nclosing square bracket. A closing square bracket on its own\nis not special by default. However, if the\nPCRE_JAVASCRIPT_COMPAT option is set, a lone closing square\nbracket causes a compile-time error. If a closing square\nbracket is required as a member of the class, it should be\nthe first data character in the class (after an initial\ncircumflex, if present) or escaped with a backslash.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A character\nclass matches a single character in the subject. In a UTF\nmode, the character may be more than one data unit long. A\nmatched character must be in the set of characters defined\nby the class, unless the first character in the class\ndefinition is a circumflex, in which case the subject\ncharacter must not be in the set defined by the class. If a\ncircumflex is actually required as a member of the class,\nensure it is not the first character, or escape it with a\nbackslash.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nthe character class [aeiou] matches any lower case vowel,\nwhile [^aeiou] matches any character that is not a lower\ncase vowel. Note that a circumflex is just a convenient\nnotation for specifying the characters that are in the class\nby enumerating those that are not. A class that starts with\na circumflex is not an assertion; it still consumes a\ncharacter from the subject string, and therefore it fails if\nthe current pointer is at the end of the string.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In UTF-8\n(UTF-16, UTF-32) mode, characters with values greater than\n255 (0xffff) can be included in a class as a literal string\nof data units, or by using the \\x{ escaping mechanism.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When caseless\nmatching is set, any letters in a class represent both their\nupper case and lower case versions, so for example, a\ncaseless [aeiou] matches &quot;A&quot; as well as\n&quot;a&quot;, and a caseless [^aeiou] does not match\n&quot;A&quot;, whereas a caseful version would. In a UTF\nmode, PCRE always understands the concept of case for\ncharacters whose values are less than 128, so caseless\nmatching is always possible. For characters with higher\nvalues, the concept of case is supported if PCRE is compiled\nwith Unicode property support, but not otherwise. If you\nwant to use caseless matching in a UTF mode for characters\n128 and above, you must ensure that PCRE is compiled with\nUnicode property support as well as with UTF support.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Characters that\nmight indicate line breaks are never treated in any special\nway when matching character classes, whatever line-ending\nsequence is in use, and whatever setting of the PCRE_DOTALL\nand PCRE_MULTILINE options is used. A class such as [^a]\nalways matches one of these characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The minus\n(hyphen) character can be used to specify a range of\ncharacters in a character class. For example, [d-m] matches\nany letter between d and m, inclusive. If a minus character\nis required in a class, it must be escaped with a backslash\nor appear in a position where it cannot be interpreted as\nindicating a range, typically as the first or last character\nin the class, or immediately after a range. For example,\n[b-d-z] matches letters in the range b to d, a hyphen\ncharacter, or z.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is not\npossible to have the literal character &quot;]&quot; as the\nend character of a range. A pattern such as [W-]46] is\ninterpreted as a class of two characters (&quot;W&quot; and\n&quot;-&quot;) followed by a literal string &quot;46]&quot;,\nso it would match &quot;W46]&quot; or &quot;-46]&quot;.\nHowever, if the &quot;]&quot; is escaped with a backslash it\nis interpreted as the end of range, so [W-\\]46] is\ninterpreted as a class containing a range followed by two\nother characters. The octal or hexadecimal representation of\n&quot;]&quot; can also be used to end a range.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An error is\ngenerated if a POSIX character class (see below) or an\nescape sequence other than one that defines a single\ncharacter appears at a point where a range ending character\nis expected. For example, [z-\\xff] is valid, but [A-\\d] and\n[A-[:digit:]] are not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Ranges operate\nin the collating sequence of character values. They can also\nbe used for characters specified numerically, for example\n[\\000-\\037]. Ranges can include any characters that are\nvalid for the current mode.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a range that\nincludes letters is used when caseless matching is set, it\nmatches the letters in either case. For example, [W-c] is\nequivalent to [][\\\\^_&rsquo;wxyzabc], matched caselessly,\nand in a non-UTF mode, if character tables for a French\nlocale are in use, [\\xc8-\\xcb] matches accented E characters\nin both cases. In UTF modes, PCRE supports the concept of\ncase for characters with values greater than 128 only when\nit is compiled with Unicode property support.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The character\nescape sequences \\d, \\D, \\h, \\H, \\p, \\P, \\s, \\S, \\v, \\V, \\w,\nand \\W may appear in a character class, and add the\ncharacters that they match to the class. For example,\n[\\dABCDEF] matches any hexadecimal digit. In UTF modes, the\nPCRE_UCP option affects the meanings of \\d, \\s, \\w and their\nupper case partners, just as it does when they appear\noutside a character class, as described in the section\nentitled &quot;Generic character types&quot; above. The\nescape sequence \\b has a different meaning inside a\ncharacter class; it matches the backspace character. The\nsequences \\B, \\N, \\R, and \\X are not special inside a\ncharacter class. Like any other unrecognized escape\nsequences, they are treated as the literal characters\n&quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and\n&quot;X&quot; by default, but cause an error if the\nPCRE_EXTRA option is set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A circumflex\ncan conveniently be used with the upper case character types\nto specify a more restricted set of characters than the\nmatching lower case type. For example, the class [^\\W_]\nmatches any letter or digit, but not underscore, whereas\n[\\w] includes underscore. A positive character class should\nbe read as &quot;something OR something OR ...&quot; and a\nnegative class as &quot;NOT something AND NOT something AND\nNOT ...&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The only\nmetacharacters that are recognized in character classes are\nbackslash, hyphen (only where it can be interpreted as\nspecifying a range), circumflex (only at the start), opening\nsquare bracket (only when it can be interpreted as\nintroducing a POSIX class name, or for a special\ncompatibility feature - see the next two sections), and the\nterminating closing square bracket. However, escaping other\nnon-alphanumeric characters does no harm.</p>\n\n<h2>POSIX CHARACTER CLASSES\n<a name=\"POSIX CHARACTER CLASSES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl supports\nthe POSIX notation for character classes. This uses names\nenclosed by [: and :] within the enclosing square brackets.\nPCRE also supports this notation. For example,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">[01[:alpha:]%]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;0&quot;, &quot;1&quot;, any alphabetic character, or\n&quot;%&quot;. The supported class names are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">alnum letters\nand digits <br>\nalpha letters <br>\nascii character codes 0 - 127 <br>\nblank space or tab only <br>\ncntrl control characters <br>\ndigit decimal digits (same as \\d) <br>\ngraph printing characters, excluding space <br>\nlower lower case letters <br>\nprint printing characters, including space <br>\npunct printing characters, excluding letters and digits and\nspace <br>\nspace white space (the same as \\s from PCRE 8.34) <br>\nupper upper case letters <br>\nword &quot;word&quot; characters (same as \\w) <br>\nxdigit hexadecimal digits</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The default\n&quot;space&quot; characters are HT (9), LF (10), VT (11),\nFF (12), CR (13), and space (32). If locale-specific\nmatching is taking place, the list of space characters may\nbe different; there may be fewer or more of them.\n&quot;Space&quot; used to be different to \\s, which did not\ninclude VT, for Perl compatibility. However, Perl changed at\nrelease 5.18, and PCRE followed at release 8.34.\n&quot;Space&quot; and \\s now match the same set of\ncharacters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The name\n&quot;word&quot; is a Perl extension, and &quot;blank&quot;\nis a GNU extension from Perl 5.8. Another Perl extension is\nnegation, which is indicated by a ^ character after the\ncolon. For example,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">[12[:^digit:]]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;1&quot;, &quot;2&quot;, or any non-digit. PCRE (and\nPerl) also recognize the POSIX syntax [.ch.] and [=ch=]\nwhere &quot;ch&quot; is a &quot;collating element&quot;, but\nthese are not supported, and an error is given if they are\nencountered.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\ncharacters with values greater than 128 do not match any of\nthe POSIX character classes. However, if the PCRE_UCP option\nis passed to <b>pcre_compile()</b>, some of the classes are\nchanged so that Unicode character properties are used. This\nis achieved by replacing certain POSIX classes by other\nsequences, as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[:alnum:]\nbecomes \\p{Xan} <br>\n[:alpha:] becomes \\p{L} <br>\n[:blank:] becomes \\h <br>\n[:digit:] becomes \\p{Nd} <br>\n[:lower:] becomes \\p{Ll} <br>\n[:space:] becomes \\p{Xps} <br>\n[:upper:] becomes \\p{Lu} <br>\n[:word:] becomes \\p{Xwd}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Negated\nversions, such as [:^alpha:] use \\P instead of \\p. Three\nother POSIX classes are handled specially in UCP mode:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p>[:graph:]</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>This matches characters that have glyphs that mark the\npage when printed. In Unicode property terms, it matches all\ncharacters with the L, M, N, P, S, or Cf properties, except\nfor:</p> </td></tr>\n</table>\n\n<p style=\"margin-left:26%; margin-top: 1em\">U+061C Arabic\nLetter Mark <br>\nU+180E Mongolian Vowel Separator <br>\nU+2066 - U+2069 Various &quot;isolate&quot;s</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p style=\"margin-top: 1em\">[:print:]</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\">This matches the same characters\nas [:graph:] plus space characters that are not controls,\nthat is, characters with the Zs property.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p>[:punct:]</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>This matches all characters that have the Unicode P\n(punctuation) property, plus those characters whose code\npoints are less than 128 that have the S (Symbol)\nproperty.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The other POSIX\nclasses are unchanged, and match only characters with code\npoints less than 128.</p>\n\n<h2>COMPATIBILITY FEATURE FOR WORD BOUNDARIES\n<a name=\"COMPATIBILITY FEATURE FOR WORD BOUNDARIES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the POSIX.2\ncompliant library that was included in 4.4BSD Unix, the ugly\nsyntax [[:&lt;:]] and [[:&gt;:]] is used for matching\n&quot;start of word&quot; and &quot;end of word&quot;. PCRE\ntreats these items as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">[[:&lt;:]] is\nconverted to \\b(?=\\w) <br>\n[[:&gt;:]] is converted to \\b(?&lt;=\\w)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Only these\nexact character sequences are recognized. A sequence such as\n[a[:&lt;:]b] provokes error for an unrecognized POSIX class\nname. This support is not compatible with Perl. It is\nprovided to help migrations from other environments, and is\nbest not used in any new patterns. Note that \\b matches at\nthe start and the end of a word (see &quot;Simple\nassertions&quot; above), and in a Perl-style pattern the\npreceding or following character normally shows which is\nwanted, without the need for the assertions that are used\nabove in order to give exactly the POSIX behaviour.</p>\n\n<h2>VERTICAL BAR\n<a name=\"VERTICAL BAR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Vertical bar\ncharacters are used to separate alternative patterns. For\nexample, the pattern</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">gilbert|sullivan</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches either\n&quot;gilbert&quot; or &quot;sullivan&quot;. Any number of\nalternatives may appear, and an empty alternative is\npermitted (matching the empty string). The matching process\ntries each alternative in turn, from left to right, and the\nfirst one that succeeds is used. If the alternatives are\nwithin a subpattern (defined below), &quot;succeeds&quot;\nmeans matching the rest of the main pattern as well as the\nalternative in the subpattern.</p>\n\n<h2>INTERNAL OPTION SETTING\n<a name=\"INTERNAL OPTION SETTING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The settings of\nthe PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and\nPCRE_EXTENDED options (which are Perl-compatible) can be\nchanged from within the pattern by a sequence of Perl option\nletters enclosed between &quot;(?&quot; and &quot;)&quot;.\nThe option letters are</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">i for\nPCRE_CASELESS <br>\nm for PCRE_MULTILINE <br>\ns for PCRE_DOTALL <br>\nx for PCRE_EXTENDED</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\n(?im) sets caseless, multiline matching. It is also possible\nto unset these options by preceding the letter with a\nhyphen, and a combined setting and unsetting such as\n(?im-sx), which sets PCRE_CASELESS and PCRE_MULTILINE while\nunsetting PCRE_DOTALL and PCRE_EXTENDED, is also permitted.\nIf a letter appears both before and after the hyphen, the\noption is unset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nPCRE-specific options PCRE_DUPNAMES, PCRE_UNGREEDY, and\nPCRE_EXTRA can be changed in the same way as the\nPerl-compatible options by using the characters J, U and X\nrespectively.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When one of\nthese option changes occurs at top level (that is, not\ninside subpattern parentheses), the change applies to the\nremainder of the pattern that follows. If the change is\nplaced right at the start of a pattern, PCRE extracts it\ninto the global options (and it will therefore show up in\ndata extracted by the <b>pcre_fullinfo()</b> function).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An option\nchange within a subpattern (see below for a description of\nsubpatterns) affects only that part of the subpattern that\nfollows it, so</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(a(?i)b)c</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches abc and\naBc and no other strings (assuming PCRE_CASELESS is not\nused). By this means, options can be made to have different\nsettings in different parts of the pattern. Any changes made\nin one alternative do carry on into subsequent branches\nwithin the same subpattern. For example,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(a(?i)b|c)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;, and\n&quot;C&quot;, even though when matching &quot;C&quot; the\nfirst branch is abandoned before the option setting. This is\nbecause the effects of option settings happen at compile\ntime. There would be some very weird behaviour\notherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Note:</b>\nThere are other PCRE-specific options that can be set by the\napplication when the compiling or matching functions are\ncalled. In some cases the pattern can contain special\nleading sequences such as (*CRLF) to override what the\napplication has set or what has been defaulted. Details are\ngiven in the section entitled &quot;Newline sequences&quot;\nabove. There are also the (*UTF8), (*UTF16),(*UTF32), and\n(*UCP) leading sequences that can be used to set UTF and\nUnicode property modes; they are equivalent to setting the\nPCRE_UTF8, PCRE_UTF16, PCRE_UTF32 and the PCRE_UCP options,\nrespectively. The (*UTF) sequence is a generic version that\ncan be used with any of the libraries. However, the\napplication can set the PCRE_NEVER_UTF option, which locks\nout the use of the (*UTF) sequences.</p>\n\n<h2>SUBPATTERNS\n<a name=\"SUBPATTERNS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Subpatterns are\ndelimited by parentheses (round brackets), which can be\nnested. Turning part of a pattern into a subpattern does two\nthings:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">1. It localizes\na set of alternatives. For example, the pattern</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cat(aract|erpillar|)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;cataract&quot;, &quot;caterpillar&quot;, or\n&quot;cat&quot;. Without the parentheses, it would match\n&quot;cataract&quot;, &quot;erpillar&quot; or an empty\nstring.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">2. It sets up\nthe subpattern as a capturing subpattern. This means that,\nwhen the whole pattern matches, that portion of the subject\nstring that matched the subpattern is passed back to the\ncaller via the <i>ovector</i> argument of the matching\nfunction. (This applies only to the traditional matching\nfunctions; the DFA matching functions do not support\ncapturing.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Opening\nparentheses are counted from left to right (starting from 1)\nto obtain numbers for the capturing subpatterns. For\nexample, if the string &quot;the red king&quot; is matched\nagainst the pattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the\n((red|white) (king|queen))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the captured\nsubstrings are &quot;red king&quot;, &quot;red&quot;, and\n&quot;king&quot;, and are numbered 1, 2, and 3,\nrespectively.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The fact that\nplain parentheses fulfil two functions is not always\nhelpful. There are often times when a grouping subpattern is\nrequired without a capturing requirement. If an opening\nparenthesis is followed by a question mark and a colon, the\nsubpattern does not do any capturing, and is not counted\nwhen computing the number of any subsequent capturing\nsubpatterns. For example, if the string &quot;the white\nqueen&quot; is matched against the pattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the\n((?:red|white) (king|queen))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the captured\nsubstrings are &quot;white queen&quot; and\n&quot;queen&quot;, and are numbered 1 and 2. The maximum\nnumber of capturing subpatterns is 65535.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As a convenient\nshorthand, if any option settings are required at the start\nof a non-capturing subpattern, the option letters may appear\nbetween the &quot;?&quot; and the &quot;:&quot;. Thus the\ntwo patterns</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?i:saturday|sunday)\n<br>\n(?:(?i)saturday|sunday)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">match exactly\nthe same set of strings. Because alternative branches are\ntried from left to right, and options are not reset until\nthe end of the subpattern is reached, an option setting in\none branch does affect subsequent branches, so the above\npatterns match &quot;SUNDAY&quot; as well as\n&quot;Saturday&quot;.</p>\n\n<h2>DUPLICATE SUBPATTERN NUMBERS\n<a name=\"DUPLICATE SUBPATTERN NUMBERS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl 5.10\nintroduced a feature whereby each alternative in a\nsubpattern uses the same numbers for its capturing\nparentheses. Such a subpattern starts with (?| and is itself\na non-capturing subpattern. For example, consider this\npattern:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?|(Sat)ur|(Sun))day</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because the two\nalternatives are inside a (?| group, both sets of capturing\nparentheses are numbered one. Thus, when the pattern\nmatches, you can look at captured substring number one,\nwhichever alternative matched. This construct is useful when\nyou want to capture part, but not all, of one of a number of\nalternatives. Inside a (?| group, parentheses are numbered\nas usual, but the number is reset at the start of each\nbranch. The numbers of any capturing parentheses that follow\nthe subpattern start after the highest number used in any\nbranch. The following example is taken from the Perl\ndocumentation. The numbers underneath show in which buffer\nthe captured content will be stored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># before\n---------------branch-reset----------- after <br>\n/ ( a ) (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x\n<br>\n# 1 2 2 3 2 3 4</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A back\nreference to a numbered subpattern uses the most recent\nvalue that is set for that number by any subpattern. The\nfollowing pattern matches &quot;abcabc&quot; or\n&quot;defdef&quot;:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">/(?|(abc)|(def))\\1/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In contrast, a\nsubroutine call to a numbered subpattern always refers to\nthe first one in the pattern with the given number. The\nfollowing pattern matches &quot;abcabc&quot; or\n&quot;defabc&quot;:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">/(?|(abc)|(def))(?1)/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a condition\ntest for a subpattern&rsquo;s having matched refers to a\nnon-unique number, the test is true if any of the\nsubpatterns of that number have matched.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An alternative\napproach to using this &quot;branch reset&quot; feature is\nto use duplicate named subpatterns, as described in the next\nsection.</p>\n\n<h2>NAMED SUBPATTERNS\n<a name=\"NAMED SUBPATTERNS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Identifying\ncapturing parentheses by number is simple, but it can be\nvery hard to keep track of the numbers in complicated\nregular expressions. Furthermore, if an expression is\nmodified, the numbers may change. To help with this\ndifficulty, PCRE supports the naming of subpatterns. This\nfeature was not added to Perl until release 5.10. Python had\nthe feature earlier, and PCRE introduced it at release 4.0,\nusing the Python syntax. PCRE now supports both the Perl and\nthe Python syntax. Perl allows identically numbered\nsubpatterns to have different names, but PCRE does not.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In PCRE, a\nsubpattern can be named in one of three ways:\n(?&lt;name&gt;...) or (?&rsquo;name&rsquo;...) as in Perl,\nor (?P&lt;name&gt;...) as in Python. References to capturing\nparentheses from other parts of the pattern, such as back\nreferences, recursion, and conditions, can be made by name\nas well as by number.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Names consist\nof up to 32 alphanumeric characters and underscores, but\nmust start with a non-digit. Named capturing parentheses are\nstill allocated numbers as well as names, exactly as if the\nnames were not present. The PCRE API provides function calls\nfor extracting the name-to-number translation table from a\ncompiled pattern. There is also a convenience function for\nextracting a captured substring by name.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default, a\nname must be unique within a pattern, but it is possible to\nrelax this constraint by setting the PCRE_DUPNAMES option at\ncompile time. (Duplicate names are also always permitted for\nsubpatterns with the same number, set up as described in the\nprevious section.) Duplicate names can be useful for\npatterns where only one instance of the named parentheses\ncan match. Suppose you want to match the name of a weekday,\neither as a 3-letter abbreviation or as the full name, and\nin both cases you want to extract the abbreviation. This\npattern (ignoring the line breaks) does the job:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;DN&gt;Mon|Fri|Sun)(?:day)?|\n<br>\n(?&lt;DN&gt;Tue)(?:sday)?| <br>\n(?&lt;DN&gt;Wed)(?:nesday)?| <br>\n(?&lt;DN&gt;Thu)(?:rsday)?| <br>\n(?&lt;DN&gt;Sat)(?:urday)?</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are five\ncapturing substrings, but only one is ever set after a\nmatch. (An alternative way of solving this problem is to use\na &quot;branch reset&quot; subpattern, as described in the\nprevious section.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The convenience\nfunction for extracting the data by name returns the\nsubstring for the first (and in this example, the only)\nsubpattern of that name that matched. This saves searching\nto find which numbered subpattern it was.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you make a\nback reference to a non-unique named subpattern from\nelsewhere in the pattern, the subpatterns to which the name\nrefers are checked in the order in which they appear in the\noverall pattern. The first one that is set is used for the\nreference. For example, this pattern matches both\n&quot;foofoo&quot; and &quot;barbar&quot; but not\n&quot;foobar&quot; or &quot;barfoo&quot;:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?:(?&lt;n&gt;foo)|(?&lt;n&gt;bar))\\k&lt;n&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you make a\nsubroutine call to a non-unique named subpattern, the one\nthat corresponds to the first occurrence of the name is\nused. In the absence of duplicate numbers (see the previous\nsection) this is the one with the lowest number.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you use a\nnamed reference in a condition test (see the section about\nconditions below), either to check whether a subpattern has\nmatched, or to check for recursion, all subpatterns with the\nsame name are tested. If the condition is true for any one\nof them, the overall condition is true. This is the same\nbehaviour as testing by number. For further details of the\ninterfaces for handling named subpatterns, see the\n<b>pcreapi</b> documentation.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Warning:</b>\nYou cannot use different names to distinguish between two\nsubpatterns with the same number because PCRE uses only the\nnumbers when matching. For this reason, an error is given at\ncompile time if different names are given to subpatterns\nwith the same number. However, you can always give the same\nname to subpatterns with the same number, even when\nPCRE_DUPNAMES is not set.</p>\n\n<h2>REPETITION\n<a name=\"REPETITION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Repetition is\nspecified by quantifiers, which can follow any of the\nfollowing items:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a literal data\ncharacter <br>\nthe dot metacharacter <br>\nthe \\C escape sequence <br>\nthe \\X escape sequence <br>\nthe \\R escape sequence <br>\nan escape such as \\d or \\pL that matches a single character\n<br>\na character class <br>\na back reference (see next section) <br>\na parenthesized subpattern (including assertions) <br>\na subroutine call to a subpattern (recursive or\notherwise)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The general\nrepetition quantifier specifies a minimum and maximum number\nof permitted matches, by giving the two numbers in curly\nbrackets (braces), separated by a comma. The numbers must be\nless than 65536, and the first must be less than or equal to\nthe second. For example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">z{2,4}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;. A\nclosing brace on its own is not a special character. If the\nsecond number is omitted, but the comma is present, there is\nno upper limit; if the second number and the comma are both\nomitted, the quantifier specifies an exact number of\nrequired matches. Thus</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">[aeiou]{3,}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches at\nleast 3 successive vowels, but may match many more,\nwhile</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\d{8}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches exactly\n8 digits. An opening curly bracket that appears in a\nposition where a quantifier is not allowed, or one that does\nnot match the syntax of a quantifier, is taken as a literal\ncharacter. For example, {,6} is not a quantifier, but a\nliteral string of four characters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In UTF modes,\nquantifiers apply to characters rather than to individual\ndata units. Thus, for example, \\x{100}{2} matches two\ncharacters, each of which is represented by a two-byte\nsequence in a UTF-8 string. Similarly, \\X{3} matches three\nUnicode extended grapheme clusters, each of which may be\nseveral data units long (and they may be of different\nlengths).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The quantifier\n{0} is permitted, causing the expression to behave as if the\nprevious item and the quantifier were not present. This may\nbe useful for subpatterns that are referenced as subroutines\nfrom elsewhere in the pattern (but see also the section\nentitled &quot;Defining subpatterns for use by reference\nonly&quot; below). Items other than subpatterns that have a\n{0} quantifier are omitted from the compiled pattern.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\nconvenience, the three most common quantifiers have\nsingle-character abbreviations:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">* is equivalent\nto {0,} <br>\n+ is equivalent to {1,} <br>\n? is equivalent to {0,1}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is possible\nto construct infinite loops by following a subpattern that\ncan match no characters with a quantifier that has no upper\nlimit, for example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(a?)*</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Earlier\nversions of Perl and PCRE used to give an error at compile\ntime for such patterns. However, because there are cases\nwhere this can be useful, such patterns are now accepted,\nbut if any repetition of the subpattern does in fact match\nno characters, the loop is forcibly broken.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default, the\nquantifiers are &quot;greedy&quot;, that is, they match as\nmuch as possible (up to the maximum number of permitted\ntimes), without causing the rest of the pattern to fail. The\nclassic example of where this gives problems is in trying to\nmatch comments in C programs. These appear between /* and */\nand within the comment, individual * and / characters may\nappear. An attempt to match C comments by applying the\npattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/\\*.*\\*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">to the\nstring</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* first\ncomment */ not comment /* second comment */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">fails, because\nit matches the entire string owing to the greediness of the\n.* item.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if a\nquantifier is followed by a question mark, it ceases to be\ngreedy, and instead matches the minimum number of times\npossible, so the pattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/\\*.*?\\*/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">does the right\nthing with the C comments. The meaning of the various\nquantifiers is not otherwise changed, just the preferred\nnumber of matches. Do not confuse this use of question mark\nwith its use as a quantifier in its own right. Because it\nhas two uses, it can sometimes appear doubled, as in</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\d??\\d</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">which matches\none digit by preference, but can match two if that is the\nonly way the rest of the pattern matches.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nPCRE_UNGREEDY option is set (an option that is not available\nin Perl), the quantifiers are not greedy by default, but\nindividual ones can be made greedy by following them with a\nquestion mark. In other words, it inverts the default\nbehaviour.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a\nparenthesized subpattern is quantified with a minimum repeat\ncount that is greater than 1 or with a limited maximum, more\nmemory is required for the compiled pattern, in proportion\nto the size of the minimum or maximum.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a pattern\nstarts with .* or .{0,} and the PCRE_DOTALL option\n(equivalent to Perl&rsquo;s /s) is set, thus allowing the\ndot to match newlines, the pattern is implicitly anchored,\nbecause whatever follows will be tried against every\ncharacter position in the subject string, so there is no\npoint in retrying the overall match at any position after\nthe first. PCRE normally treats such a pattern as though it\nwere preceded by \\A.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In cases where\nit is known that the subject string contains no newlines, it\nis worth setting PCRE_DOTALL in order to obtain this\noptimization, or alternatively using ^ to indicate anchoring\nexplicitly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, there\nare some cases where the optimization cannot be used. When\n.* is inside capturing parentheses that are the subject of a\nback reference elsewhere in the pattern, a match at the\nstart may fail where a later one succeeds. Consider, for\nexample:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(.*)abc\\1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the subject\nis &quot;xyz123abc123&quot; the match point is the fourth\ncharacter. For this reason, such a pattern is not implicitly\nanchored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another case\nwhere implicit anchoring is not applied is when the leading\n.* is inside an atomic group. Once again, a match at the\nstart may fail where a later one succeeds. Consider this\npattern:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&gt;.*?a)b</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It matches\n&quot;ab&quot; in the subject &quot;aab&quot;. The use of\nthe backtracking control verbs (*PRUNE) and (*SKIP) also\ndisable this optimization.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a\ncapturing subpattern is repeated, the value captured is the\nsubstring that matched the final iteration. For example,\nafter</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(tweedle[dume]{3}\\s*)+</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">has matched\n&quot;tweedledum tweedledee&quot; the value of the captured\nsubstring is &quot;tweedledee&quot;. However, if there are\nnested capturing subpatterns, the corresponding captured\nvalues may have been set in previous iterations. For\nexample, after</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/(a|(b))+/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;aba&quot; the value of the second captured substring\nis &quot;b&quot;.</p>\n\n<h2>ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS\n<a name=\"ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">With both\nmaximizing (&quot;greedy&quot;) and minimizing\n(&quot;ungreedy&quot; or &quot;lazy&quot;) repetition,\nfailure of what follows normally causes the repeated item to\nbe re-evaluated to see if a different number of repeats\nallows the rest of the pattern to match. Sometimes it is\nuseful to prevent this, either to change the nature of the\nmatch, or to cause it fail earlier than it otherwise might,\nwhen the author of the pattern knows there is no point in\ncarrying on.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider, for\nexample, the pattern \\d+foo when applied to the subject\nline</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">123456bar</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After matching\nall 6 digits and then failing to match &quot;foo&quot;, the\nnormal action of the matcher is to try again with only 5\ndigits matching the \\d+ item, and then with 4, and so on,\nbefore ultimately failing. &quot;Atomic grouping&quot; (a\nterm taken from Jeffrey Friedl&rsquo;s book) provides the\nmeans for specifying that once a subpattern has matched, it\nis not to be re-evaluated in this way.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If we use\natomic grouping for the previous example, the matcher gives\nup immediately on failing to match &quot;foo&quot; the first\ntime. The notation is a kind of special parenthesis,\nstarting with (?&gt; as in this example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&gt;\\d+)foo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This kind of\nparenthesis &quot;locks up&quot; the part of the pattern it\ncontains once it has matched, and a failure further into the\npattern is prevented from backtracking into it. Backtracking\npast it to previous items, however, works as normal.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An alternative\ndescription is that a subpattern of this type matches the\nstring of characters that an identical standalone pattern\nwould match, if anchored at the current point in the subject\nstring.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Atomic grouping\nsubpatterns are not capturing subpatterns. Simple cases such\nas the above example can be thought of as a maximizing\nrepeat that must swallow everything it can. So, while both\n\\d+ and \\d+? are prepared to adjust the number of digits\nthey match in order to make the rest of the pattern match,\n(?&gt;\\d+) can only match an entire sequence of digits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Atomic groups\nin general can of course contain arbitrarily complicated\nsubpatterns, and can be nested. However, when the subpattern\nfor an atomic group is just a single repeated item, as in\nthe example above, a simpler notation, called a\n&quot;possessive quantifier&quot; can be used. This consists\nof an additional + character following a quantifier. Using\nthis notation, the previous example can be rewritten as</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\d++foo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that a\npossessive quantifier can be used with an entire group, for\nexample:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(abc|xyz){2,3}+</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Possessive\nquantifiers are always greedy; the setting of the\nPCRE_UNGREEDY option is ignored. They are a convenient\nnotation for the simpler forms of atomic group. However,\nthere is no difference in the meaning of a possessive\nquantifier and the equivalent atomic group, though there may\nbe a performance difference; possessive quantifiers should\nbe slightly faster.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The possessive\nquantifier syntax is an extension to the Perl 5.8 syntax.\nJeffrey Friedl originated the idea (and the name) in the\nfirst edition of his book. Mike McCloskey liked it, so\nimplemented it when he built Sun&rsquo;s Java package, and\nPCRE copied it from there. It ultimately found its way into\nPerl at release 5.10.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE has an\noptimization that automatically &quot;possessifies&quot;\ncertain simple pattern constructs. For example, the sequence\nA+B is treated as A++B because there is no point in\nbacktracking into a sequence of A&rsquo;s when B must\nfollow.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a pattern\ncontains an unlimited repeat inside a subpattern that can\nitself be repeated an unlimited number of times, the use of\nan atomic group is the only way to avoid some failing\nmatches taking a very long time indeed. The pattern</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(\\D+|&lt;\\d+&gt;)*[!?]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches an\nunlimited number of substrings that either consist of\nnon-digits, or digits enclosed in &lt;&gt;, followed by\neither ! or ?. When it matches, it runs quickly. However, if\nit is applied to</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">it takes a long\ntime before reporting failure. This is because the string\ncan be divided between the internal \\D+ repeat and the\nexternal * repeat in a large number of ways, and all have to\nbe tried. (The example uses [!?] rather than a single\ncharacter at the end, because both PCRE and Perl have an\noptimization that allows for fast failure when a single\ncharacter is used. They remember the last single character\nthat is required for a match, and fail early if it is not\npresent in the string.) If the pattern is changed so that it\nuses an atomic group, like this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">((?&gt;\\D+)|&lt;\\d+&gt;)*[!?]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">sequences of\nnon-digits cannot be broken, and failure happens\nquickly.</p>\n\n<h2>BACK REFERENCES\n<a name=\"BACK REFERENCES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Outside a\ncharacter class, a backslash followed by a digit greater\nthan 0 (and possibly further digits) is a back reference to\na capturing subpattern earlier (that is, to its left) in the\npattern, provided there have been that many previous\ncapturing left parentheses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if the\ndecimal number following the backslash is less than 10, it\nis always taken as a back reference, and causes an error\nonly if there are not that many capturing left parentheses\nin the entire pattern. In other words, the parentheses that\nare referenced need not be to the left of the reference for\nnumbers less than 10. A &quot;forward back reference&quot;\nof this type can make sense when a repetition is involved\nand the subpattern to the right has participated in an\nearlier iteration.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is not\npossible to have a numerical &quot;forward back\nreference&quot; to a subpattern whose number is 10 or more\nusing this syntax because a sequence such as \\50 is\ninterpreted as a character defined in octal. See the\nsubsection entitled &quot;Non-printing characters&quot;\nabove for further details of the handling of digits\nfollowing a backslash. There is no such problem when named\nparentheses are used. A back reference to any subpattern is\npossible using named parentheses (see below).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another way of\navoiding the ambiguity inherent in the use of digits\nfollowing a backslash is to use the \\g escape sequence. This\nescape must be followed by an unsigned number or a negative\nnumber, optionally enclosed in braces. These examples are\nall identical:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(ring), \\1 <br>\n(ring), \\g1 <br>\n(ring), \\g{1}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An unsigned\nnumber specifies an absolute reference without the ambiguity\nthat is present in the older syntax. It is also useful when\nliteral digits follow the reference. A negative number is a\nrelative reference. Consider this example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(abc(def)ghi)\\g{-1}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sequence\n\\g{-1} is a reference to the most recently started capturing\nsubpattern before \\g, that is, is it equivalent to \\2 in\nthis example. Similarly, \\g{-2} would be equivalent to \\1.\nThe use of relative references can be helpful in long\npatterns, and also in patterns that are created by joining\ntogether fragments that contain references within\nthemselves.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A back\nreference matches whatever actually matched the capturing\nsubpattern in the current subject string, rather than\nanything matching the subpattern itself (see\n&quot;Subpatterns as subroutines&quot; below for a way of\ndoing that). So the pattern</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(sens|respons)e\nand \\1ibility</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;sense and sensibility&quot; and &quot;response and\nresponsibility&quot;, but not &quot;sense and\nresponsibility&quot;. If caseful matching is in force at the\ntime of the back reference, the case of letters is relevant.\nFor example,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">((?i)rah)\\s+\\1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;rah rah&quot; and &quot;RAH RAH&quot;, but not\n&quot;RAH rah&quot;, even though the original capturing\nsubpattern is matched caselessly.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are\nseveral different ways of writing back references to named\nsubpatterns. The .NET syntax \\k{name} and the Perl syntax\n\\k&lt;name&gt; or \\k&rsquo;name&rsquo; are supported, as is\nthe Python syntax (?P=name). Perl 5.10&rsquo;s unified back\nreference syntax, in which \\g can be used for both numeric\nand named references, is also supported. We could rewrite\nthe above example in any of the following ways:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;p1&gt;(?i)rah)\\s+\\k&lt;p1&gt;\n<br>\n(?&rsquo;p1&rsquo;(?i)rah)\\s+\\k{p1} <br>\n(?P&lt;p1&gt;(?i)rah)\\s+(?P=p1) <br>\n(?&lt;p1&gt;(?i)rah)\\s+\\g{p1}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A subpattern\nthat is referenced by name may appear in the pattern before\nor after the reference.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There may be\nmore than one back reference to the same subpattern. If a\nsubpattern has not actually been used in a particular match,\nany back references to it always fail by default. For\nexample, the pattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(a|(bc))\\2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">always fails if\nit starts to match &quot;a&quot; rather than &quot;bc&quot;.\nHowever, if the PCRE_JAVASCRIPT_COMPAT option is set at\ncompile time, a back reference to an unset value matches an\nempty string.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Because there\nmay be many capturing parentheses in a pattern, all digits\nfollowing a backslash are taken as part of a potential back\nreference number. If the pattern continues with a digit\ncharacter, some delimiter must be used to terminate the back\nreference. If the PCRE_EXTENDED option is set, this can be\nwhite space. Otherwise, the \\g{ syntax or an empty comment\n(see &quot;Comments&quot; below) can be used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Recursive\nback references</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A back\nreference that occurs inside the parentheses to which it\nrefers fails when the subpattern is first used, so, for\nexample, (a\\1) never matches. However, such references can\nbe useful inside repeated subpatterns. For example, the\npattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(a|b\\1)+</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches any\nnumber of &quot;a&quot;s and also &quot;aba&quot;,\n&quot;ababbaa&quot; etc. At each iteration of the\nsubpattern, the back reference matches the character string\ncorresponding to the previous iteration. In order for this\nto work, the pattern must be such that the first iteration\ndoes not need to match the back reference. This can be done\nusing alternation, as in the example above, or by a\nquantifier with a minimum of zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Back references\nof this type cause the group that they reference to be\ntreated as an atomic group. Once the whole group has been\nmatched, a subsequent matching failure cannot cause\nbacktracking into the middle of the group.</p>\n\n<h2>ASSERTIONS\n<a name=\"ASSERTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">An assertion is\na test on the characters following or preceding the current\nmatching point that does not actually consume any\ncharacters. The simple assertions coded as \\b, \\B, \\A, \\G,\n\\Z, \\z, ^ and $ are described above.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">More\ncomplicated assertions are coded as subpatterns. There are\ntwo kinds: those that look ahead of the current position in\nthe subject string, and those that look behind it. An\nassertion subpattern is matched in the normal way, except\nthat it does not cause the current matching position to be\nchanged.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Assertion\nsubpatterns are not capturing subpatterns. If such an\nassertion contains capturing subpatterns within it, these\nare counted for the purposes of numbering the capturing\nsubpatterns in the whole pattern. However, substring\ncapturing is carried out only for positive assertions. (Perl\nsometimes, but not always, does do capturing in negative\nassertions.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\ncompatibility with Perl, assertion subpatterns may be\nrepeated; though it makes no sense to assert the same thing\nseveral times, the side effect of capturing parentheses may\noccasionally be useful. In practice, there only three\ncases:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(1) If the\nquantifier is {0}, the assertion is never obeyed during\nmatching. However, it may contain internal capturing\nparenthesized groups that are called from elsewhere via the\nsubroutine mechanism.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(2) If\nquantifier is {0,n} where n is greater than zero, it is\ntreated as if it were {0,1}. At run time, the rest of the\npattern match is tried with and without the assertion, the\norder depending on the greediness of the quantifier.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(3) If the\nminimum repetition is greater than zero, the quantifier is\nignored. The assertion is obeyed just once when encountered\nduring matching.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Lookahead\nassertions</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Lookahead\nassertions start with (?= for positive assertions and (?!\nfor negative assertions. For example,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\w+(?=;)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches a word\nfollowed by a semicolon, but does not include the semicolon\nin the match, and</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">foo(?!bar)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches any\noccurrence of &quot;foo&quot; that is not followed by\n&quot;bar&quot;. Note that the apparently similar\npattern</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?!foo)bar</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">does not find\nan occurrence of &quot;bar&quot; that is preceded by\nsomething other than &quot;foo&quot;; it finds any\noccurrence of &quot;bar&quot; whatsoever, because the\nassertion (?!foo) is always true when the next three\ncharacters are &quot;bar&quot;. A lookbehind assertion is\nneeded to achieve the other effect.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want to\nforce a matching failure at some point in a pattern, the\nmost convenient way to do it is with (?!) because an empty\nstring always matches, so an assertion that requires there\nnot to be an empty string must always fail. The backtracking\ncontrol verb (*FAIL) or (*F) is a synonym for (?!).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Lookbehind\nassertions</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Lookbehind\nassertions start with (?&lt;= for positive assertions and\n(?&lt;! for negative assertions. For example,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;!foo)bar</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">does find an\noccurrence of &quot;bar&quot; that is not preceded by\n&quot;foo&quot;. The contents of a lookbehind assertion are\nrestricted such that all the strings it matches must have a\nfixed length. However, if there are several top-level\nalternatives, they do not all have to have the same fixed\nlength. Thus</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;=bullock|donkey)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is permitted,\nbut</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;!dogs?|cats?)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">causes an error\nat compile time. Branches that match different length\nstrings are permitted only at the top level of a lookbehind\nassertion. This is an extension compared with Perl, which\nrequires all branches to match the same length of string. An\nassertion such as</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;=ab(c|de))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is not\npermitted, because its single top-level branch can match two\ndifferent lengths, but it is acceptable to PCRE if rewritten\nto use two top-level branches:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;=abc|abde)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In some cases,\nthe escape sequence \\K (see above) can be used instead of a\nlookbehind assertion to get round the fixed-length\nrestriction.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nimplementation of lookbehind assertions is, for each\nalternative, to temporarily move the current position back\nby the fixed length and then try to match. If there are\ninsufficient characters before the current position, the\nassertion fails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a UTF mode,\nPCRE does not allow the \\C escape (which matches a single\ndata unit even in a UTF mode) to appear in lookbehind\nassertions, because it makes it impossible to calculate the\nlength of the lookbehind. The \\X and \\R escapes, which can\nmatch different numbers of data units, are also not\npermitted.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;Subroutine&quot;\ncalls (see below) such as (?2) or (?&amp;X) are permitted in\nlookbehinds, as long as the subpattern matches a\nfixed-length string. Recursion, however, is not\nsupported.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Possessive\nquantifiers can be used in conjunction with lookbehind\nassertions to specify efficient matching of fixed-length\nstrings at the end of subject strings. Consider a simple\npattern such as</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">abcd$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">when applied to\na long string that does not match. Because matching proceeds\nfrom left to right, PCRE will look for each &quot;a&quot; in\nthe subject and then see if what follows matches the rest of\nthe pattern. If the pattern is specified as</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">^.*abcd$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the initial .*\nmatches the entire string at first, but when this fails\n(because there is no following &quot;a&quot;), it backtracks\nto match all but the last character, then all but the last\ntwo characters, and so on. Once again the search for\n&quot;a&quot; covers the entire string, from right to left,\nso we are no better off. However, if the pattern is written\nas</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">^.*+(?&lt;=abcd)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">there can be no\nbacktracking for the .*+ item; it can match only the entire\nstring. The subsequent lookbehind assertion does a single\ntest on the last four characters. If it fails, the match\nfails immediately. For long strings, this approach makes a\nsignificant difference to the processing time.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Using\nmultiple assertions</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Several\nassertions (of any sort) may occur in succession. For\nexample,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;=\\d{3})(?&lt;!999)foo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;foo&quot; preceded by three digits that are not\n&quot;999&quot;. Notice that each of the assertions is\napplied independently at the same point in the subject\nstring. First there is a check that the previous three\ncharacters are all digits, and then there is a check that\nthe same three characters are not &quot;999&quot;. This\npattern does <i>not</i> match &quot;foo&quot; preceded by\nsix characters, the first of which are digits and the last\nthree of which are not &quot;999&quot;. For example, it\ndoesn&rsquo;t match &quot;123abcfoo&quot;. A pattern to do\nthat is</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;=\\d{3}...)(?&lt;!999)foo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This time the\nfirst assertion looks at the preceding six characters,\nchecking that the first three are digits, and then the\nsecond assertion checks that the preceding three characters\nare not &quot;999&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Assertions can\nbe nested in any combination. For example,</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;=(?&lt;!foo)bar)baz</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches an\noccurrence of &quot;baz&quot; that is preceded by\n&quot;bar&quot; which in turn is not preceded by\n&quot;foo&quot;, while</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;=\\d{3}(?!999)...)foo</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is another\npattern that matches &quot;foo&quot; preceded by three\ndigits and any three characters that are not\n&quot;999&quot;.</p>\n\n<h2>CONDITIONAL SUBPATTERNS\n<a name=\"CONDITIONAL SUBPATTERNS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is possible\nto cause the matching process to obey a subpattern\nconditionally or to choose between two alternative\nsubpatterns, depending on the result of an assertion, or\nwhether a specific capturing subpattern has already been\nmatched. The two possible forms of conditional subpattern\nare:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?(condition)yes-pattern)\n<br>\n(?(condition)yes-pattern|no-pattern)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncondition is satisfied, the yes-pattern is used; otherwise\nthe no-pattern (if present) is used. If there are more than\ntwo alternatives in the subpattern, a compile-time error\noccurs. Each of the two alternatives may itself contain\nnested subpatterns of any form, including conditional\nsubpatterns; the restriction to two alternatives applies\nonly at the level of the condition. This pattern fragment is\nan example where the alternatives are complex:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?(1) (A|B|C) |\n(D | (?(2)E|F) | E) )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are four\nkinds of condition: references to subpatterns, references to\nrecursion, a pseudo-condition called DEFINE, and\nassertions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Checking for\na used subpattern by number</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the text\nbetween the parentheses consists of a sequence of digits,\nthe condition is true if a capturing subpattern of that\nnumber has previously matched. If there is more than one\ncapturing subpattern with the same number (see the earlier\nsection about duplicate subpattern numbers), the condition\nis true if any of them have matched. An alternative notation\nis to precede the digits with a plus or minus sign. In this\ncase, the subpattern number is relative rather than\nabsolute. The most recently opened parentheses can be\nreferenced by (?(-1), the next most recent by (?(-2), and so\non. Inside loops it can also make sense to refer to\nsubsequent groups. The next parentheses to be opened can be\nreferenced as (?(+1), and so on. (The value zero in any of\nthese forms is not used; it provokes a compile-time\nerror.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider the\nfollowing pattern, which contains non-significant white\nspace to make it more readable (assume the PCRE_EXTENDED\noption) and to divide it into three parts for ease of\ndiscussion:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">( \\( )? [^()]+\n(?(1) \\) )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first part\nmatches an optional opening parenthesis, and if that\ncharacter is present, sets it as the first captured\nsubstring. The second part matches one or more characters\nthat are not parentheses. The third part is a conditional\nsubpattern that tests whether or not the first set of\nparentheses matched. If they did, that is, if subject\nstarted with an opening parenthesis, the condition is true,\nand so the yes-pattern is executed and a closing parenthesis\nis required. Otherwise, since no-pattern is not present, the\nsubpattern matches nothing. In other words, this pattern\nmatches a sequence of non-parentheses, optionally enclosed\nin parentheses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you were\nembedding this pattern in a larger one, you could use a\nrelative reference:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">...other\nstuff... ( \\( )? [^()]+ (?(-1) \\) ) ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This makes the\nfragment independent of the parentheses in the larger\npattern.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Checking for\na used subpattern by name</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl uses the\nsyntax (?(&lt;name&gt;)...) or (?(&rsquo;name&rsquo;)...) to\ntest for a used subpattern by name. For compatibility with\nearlier versions of PCRE, which had this facility before\nPerl, the syntax (?(name)...) is also recognized.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Rewriting the\nabove example to use a named subpattern gives this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;OPEN&gt;\n\\( )? [^()]+ (?(&lt;OPEN&gt;) \\) )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the name\nused in a condition of this kind is a duplicate, the test is\napplied to all subpatterns of the same name, and is true if\nany one of them has matched.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Checking for\npattern recursion</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncondition is the string (R), and there is no subpattern with\nthe name R, the condition is true if a recursive call to the\nwhole pattern or any subpattern has been made. If digits or\na name preceded by ampersand follow the letter R, for\nexample:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?(R3)...) or\n(?(R&amp;name)...)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the condition\nis true if the most recent recursion is into a subpattern\nwhose number or name is given. This condition does not check\nthe entire recursion stack. If the name used in a condition\nof this kind is a duplicate, the test is applied to all\nsubpatterns of the same name, and is true if any one of them\nis the most recent recursion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">At &quot;top\nlevel&quot;, all these recursion test conditions are false.\nThe syntax for recursive patterns is described below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Defining\nsubpatterns for use by reference only</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncondition is the string (DEFINE), and there is no subpattern\nwith the name DEFINE, the condition is always false. In this\ncase, there may be only one alternative in the subpattern.\nIt is always skipped if control reaches this point in the\npattern; the idea of DEFINE is that it can be used to define\nsubroutines that can be referenced from elsewhere. (The use\nof subroutines is described below.) For example, a pattern\nto match an IPv4 address such as &quot;192.168.23.245&quot;\ncould be written like this (ignore white space and line\nbreaks):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?(DEFINE)\n(?&lt;byte&gt; 2[0-4]\\d | 25[0-5] | 1\\d\\d | [1-9]?\\d) ) <br>\n\\b (?&amp;byte) (\\.(?&amp;byte)){3} \\b</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The first part\nof the pattern is a DEFINE group inside which a another\ngroup named &quot;byte&quot; is defined. This matches an\nindividual component of an IPv4 address (a number less than\n256). When matching takes place, this part of the pattern is\nskipped because DEFINE acts like a false condition. The rest\nof the pattern uses references to the named group to match\nthe four dot-separated components of an IPv4 address,\ninsisting on a word boundary at each end.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Assertion\nconditions</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\ncondition is not in any of the above formats, it must be an\nassertion. This may be a positive or negative lookahead or\nlookbehind assertion. Consider this pattern, again\ncontaining non-significant white space, and with the two\nalternatives on the second line:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?(?=[^a-z]*[a-z])\n<br>\n\\d{2}-[a-z]{3}-\\d{2} | \\d{2}-\\d{2}-\\d{2} )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The condition\nis a positive lookahead assertion that matches an optional\nsequence of non-letters followed by a letter. In other\nwords, it tests for the presence of at least one letter in\nthe subject. If a letter is found, the subject is matched\nagainst the first alternative; otherwise it is matched\nagainst the second. This pattern matches strings in one of\nthe two forms dd-aaa-dd or dd-dd-dd, where aaa are letters\nand dd are digits.</p>\n\n<h2>COMMENTS\n<a name=\"COMMENTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\nways of including comments in patterns that are processed by\nPCRE. In both cases, the start of the comment must not be in\na character class, nor in the middle of any other sequence\nof related characters such as (?: or a subpattern name or\nnumber. The characters that make up a comment play no part\nin the pattern matching.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The sequence\n(?# marks the start of a comment that continues up to the\nnext closing parenthesis. Nested parentheses are not\npermitted. If the PCRE_EXTENDED option is set, an unescaped\n# character also introduces a comment, which in this case\ncontinues to immediately after the next newline character or\ncharacter sequence in the pattern. Which characters are\ninterpreted as newlines is controlled by the options passed\nto a compiling function or by a special sequence at the\nstart of the pattern, as described in the section entitled\n&quot;Newline conventions&quot; above. Note that the end of\nthis type of comment is a literal newline sequence in the\npattern; escape sequences that happen to represent a newline\ndo not count. For example, consider this pattern when\nPCRE_EXTENDED is set, and the default newline convention is\nin force:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">abc #comment \\n\nstill comment</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On encountering\nthe # character, <b>pcre_compile()</b> skips along, looking\nfor a newline in the pattern. The sequence \\n is still\nliteral at this stage, so it does not terminate the comment.\nOnly an actual character with the code value 0x0a (the\ndefault newline) does so.</p>\n\n<h2>RECURSIVE PATTERNS\n<a name=\"RECURSIVE PATTERNS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider the\nproblem of matching a string in parentheses, allowing for\nunlimited nested parentheses. Without the use of recursion,\nthe best that can be done is to use a pattern that matches\nup to some fixed depth of nesting. It is not possible to\nhandle an arbitrary nesting depth.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For some time,\nPerl has provided a facility that allows regular expressions\nto recurse (amongst other things). It does this by\ninterpolating Perl code in the expression at run time, and\nthe code can refer to the expression itself. A Perl pattern\nusing code interpolation to solve the parentheses problem\ncan be created like this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$re = qr{\\( (?:\n(?&gt;[^()]+) | (?p{$re}) )* \\)}x;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The (?p{...})\nitem interpolates Perl code at run time, and in this case\nrefers recursively to the pattern in which it appears.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Obviously, PCRE\ncannot support the interpolation of Perl code. Instead, it\nsupports special syntax for recursion of the entire pattern,\nand also for individual subpattern recursion. After its\nintroduction in PCRE and Python, this kind of recursion was\nsubsequently introduced into Perl at release 5.10.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A special item\nthat consists of (? followed by a number greater than zero\nand a closing parenthesis is a recursive subroutine call of\nthe subpattern of the given number, provided that it occurs\ninside that subpattern. (If not, it is a non-recursive\nsubroutine call, which is described in the next section.)\nThe special item (?R) or (?0) is a recursive call of the\nentire regular expression.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This PCRE\npattern solves the nested parentheses problem (assume the\nPCRE_EXTENDED option is set so that white space is\nignored):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">\\( ( [^()]++ |\n(?R) )* \\)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">First it\nmatches an opening parenthesis. Then it matches any number\nof substrings which can either be a sequence of\nnon-parentheses, or a recursive match of the pattern itself\n(that is, a correctly parenthesized substring). Finally\nthere is a closing parenthesis. Note the use of a possessive\nquantifier to avoid backtracking into sequences of\nnon-parentheses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If this were\npart of a larger pattern, you would not want to recurse the\nentire pattern, so instead you could use this:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">( \\( ( [^()]++\n| (?1) )* \\) )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">We have put the\npattern into parentheses, and caused the recursion to refer\nto them instead of the whole pattern.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In a larger\npattern, keeping track of parenthesis numbers can be tricky.\nThis is made easier by the use of relative references.\nInstead of (?1) in the pattern above you can write (?-2) to\nrefer to the second most recently opened parentheses\npreceding the recursion. In other words, a negative number\ncounts capturing parentheses leftwards from the point at\nwhich it is encountered.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is also\npossible to refer to subsequently opened parentheses, by\nwriting references such as (?+2). However, these cannot be\nrecursive because the reference is not inside the\nparentheses that are referenced. They are always\nnon-recursive subroutine calls, as described in the next\nsection.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An alternative\napproach is to use named parentheses instead. The Perl\nsyntax for this is (?&amp;name); PCRE&rsquo;s earlier syntax\n(?P&gt;name) is also supported. We could rewrite the above\nexample as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;pn&gt; \\(\n( [^()]++ | (?&amp;pn) )* \\) )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If there is\nmore than one subpattern with the same name, the earliest\none is used.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This particular\nexample pattern that we have been looking at contains nested\nunlimited repeats, and so the use of a possessive quantifier\nfor matching strings of non-parentheses is important when\napplying the pattern to strings that do not match. For\nexample, when this pattern is applied to</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">it yields\n&quot;no match&quot; quickly. However, if a possessive\nquantifier is not used, the match runs for a very long time\nindeed because there are so many different ways the + and *\nrepeats can carve up the subject, and all have to be tested\nbefore failure can be reported.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">At the end of a\nmatch, the values of capturing parentheses are those from\nthe outermost level. If you want to obtain intermediate\nvalues, a callout function can be used (see below and the\n<b>pcrecallout</b> documentation). If the pattern above is\nmatched against</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(ab(cd)ef)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the value for\nthe inner capturing parentheses (numbered 2) is\n&quot;ef&quot;, which is the last value taken on at the top\nlevel. If a capturing subpattern is not matched at the top\nlevel, its final captured value is unset, even if it was\n(temporarily) set at a deeper level during the matching\nprocess.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If there are\nmore than 15 capturing parentheses in a pattern, PCRE has to\nobtain extra memory to store data during a recursion, which\nit does by using <b>pcre_malloc</b>, freeing it via\n<b>pcre_free</b> afterwards. If no memory can be obtained,\nthe match fails with the PCRE_ERROR_NOMEMORY error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Do not confuse\nthe (?R) item with the condition (R), which tests for\nrecursion. Consider this pattern, which matches text in\nangle brackets, allowing for arbitrary nesting. Only digits\nare allowed in nested brackets (that is, when recursing),\nwhereas any characters are permitted at the outer level.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt; (?: (?(R)\n\\d++ | [^&lt;&gt;]*+) | (?R)) * &gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In this\npattern, (?(R) is the start of a conditional subpattern,\nwith two different alternatives for the recursive and\nnon-recursive cases. The (?R) item is the actual recursive\ncall.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Differences\nin recursion processing between PCRE and Perl</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Recursion\nprocessing in PCRE differs from Perl in two important ways.\nIn PCRE (like Python, but unlike Perl), a recursive\nsubpattern call is always treated as an atomic group. That\nis, once it has matched some of the subject string, it is\nnever re-entered, even if it contains untried alternatives\nand there is a subsequent matching failure. This can be\nillustrated by the following pattern, which purports to\nmatch a palindromic string that contains an odd number of\ncharacters (for example, &quot;a&quot;, &quot;aba&quot;,\n&quot;abcba&quot;, &quot;abcdcba&quot;):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">^(.|(.)(?1)\\2)$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The idea is\nthat it either matches a single character, or two identical\ncharacters surrounding a sub-palindrome. In Perl, this\npattern works; in PCRE it does not if the pattern is longer\nthan three characters. Consider the subject string\n&quot;abcba&quot;:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">At the top\nlevel, the first character is matched, but as it is not at\nthe end of the string, the first alternative fails; the\nsecond alternative is taken and the recursion kicks in. The\nrecursive call to subpattern 1 successfully matches the next\ncharacter (&quot;b&quot;). (Note that the beginning and end\nof line tests are not part of the recursion).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Back at the top\nlevel, the next character (&quot;c&quot;) is compared with\nwhat subpattern 2 matched, which was &quot;a&quot;. This\nfails. Because the recursion is treated as an atomic group,\nthere are now no backtracking points, and so the entire\nmatch fails. (Perl is able, at this point, to re-enter the\nrecursion and try the second alternative.) However, if the\npattern is written with the alternatives in the other order,\nthings are different:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">^((.)(?1)\\2|.)$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This time, the\nrecursing alternative is tried first, and continues to\nrecurse until it runs out of characters, at which point the\nrecursion fails. But this time we do have another\nalternative to try at the higher level. That is the big\ndifference: in the previous case the remaining alternative\nis at a deeper recursion level, which PCRE cannot use.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To change the\npattern so that it matches all palindromic strings, not just\nthose with an odd number of characters, it is tempting to\nchange the pattern to this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">^((.)(?1)\\2|.?)$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Again, this\nworks in Perl, but not in PCRE, and for the same reason.\nWhen a deeper recursion has matched a single character, it\ncannot be entered again in order to match an empty string.\nThe solution is to separate the two cases, and write out the\nodd and even cases as alternatives at the higher level:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">^(?:((.)(?1)\\2|)|((.)(?3)\\4|.))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want to\nmatch typical palindromic phrases, the pattern has to ignore\nall non-word characters, which can be done like this:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">^\\W*+(?:((.)\\W*+(?1)\\W*+\\2|)|((.)\\W*+(?3)\\W*+\\4|\\W*+.\\W*+))\\W*+$</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If run with the\nPCRE_CASELESS option, this pattern matches phrases such as\n&quot;A man, a plan, a canal: Panama!&quot; and it works\nwell in both PCRE and Perl. Note the use of the possessive\nquantifier *+ to avoid backtracking into sequences of\nnon-word characters. Without this, PCRE takes a great deal\nlonger (ten times or more) to match typical phrases, and\nPerl takes so long that you think it has gone into a\nloop.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>WARNING</b>:\nThe palindrome-matching patterns above work only if the\nsubject string does not start with a palindrome that is\nshorter than the entire string. For example, although\n&quot;abcba&quot; is correctly matched, if the subject is\n&quot;ababa&quot;, PCRE finds the palindrome &quot;aba&quot;\nat the start, then fails at top level because the end of the\nstring does not follow. Once again, it cannot jump back into\nthe recursion to try other alternatives, so the entire match\nfails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The second way\nin which PCRE and Perl differ in their recursion processing\nis in the handling of captured values. In Perl, when a\nsubpattern is called recursively or as a subpattern (see the\nnext section), it has no access to any values that were\ncaptured outside the recursion, whereas in PCRE these values\ncan be referenced. Consider this pattern:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">^(.)(\\1|a(?2))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In PCRE, this\npattern matches &quot;bab&quot;. The first capturing\nparentheses match &quot;b&quot;, then in the second group,\nwhen the back reference \\1 fails to match &quot;b&quot;, the\nsecond alternative matches &quot;a&quot; and then recurses.\nIn the recursion, \\1 does now match &quot;b&quot; and so the\nwhole match succeeds. In Perl, the pattern fails to match\nbecause inside the recursive call \\1 cannot access the\nexternally set value.</p>\n\n<h2>SUBPATTERNS AS SUBROUTINES\n<a name=\"SUBPATTERNS AS SUBROUTINES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the syntax\nfor a recursive subpattern call (either by number or by\nname) is used outside the parentheses to which it refers, it\noperates like a subroutine in a programming language. The\ncalled subpattern may be defined before or after the\nreference. A numbered reference can be absolute or relative,\nas in these examples:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(...(absolute)...)...(?2)...\n<br>\n(...(relative)...)...(?-1)... <br>\n(...(?+1)...(relative)...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An earlier\nexample pointed out that the pattern</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(sens|respons)e\nand \\1ibility</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">matches\n&quot;sense and sensibility&quot; and &quot;response and\nresponsibility&quot;, but not &quot;sense and\nresponsibility&quot;. If instead the pattern</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(sens|respons)e\nand (?1)ibility</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">is used, it\ndoes match &quot;sense and responsibility&quot; as well as\nthe other two strings. Another example is given in the\ndiscussion of DEFINE above.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All subroutine\ncalls, whether recursive or not, are always treated as\natomic groups. That is, once a subroutine has matched some\nof the subject string, it is never re-entered, even if it\ncontains untried alternatives and there is a subsequent\nmatching failure. Any capturing parentheses that are set\nduring the subroutine call revert to their previous values\nafterwards.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Processing\noptions such as case-independence are fixed when a\nsubpattern is defined, so if it is used as a subroutine,\nsuch options cannot be changed for different calls. For\nexample, consider this pattern:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(abc)(?i:(?-1))</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It matches\n&quot;abcabc&quot;. It does not match &quot;abcABC&quot;\nbecause the change of processing option does not affect the\ncalled subpattern.</p>\n\n<h2>ONIGURUMA SUBROUTINE SYNTAX\n<a name=\"ONIGURUMA SUBROUTINE SYNTAX\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\ncompatibility with Oniguruma, the non-Perl syntax \\g\nfollowed by a name or a number enclosed either in angle\nbrackets or single quotes, is an alternative syntax for\nreferencing a subpattern as a subroutine, possibly\nrecursively. Here are two of the examples used above,\nrewritten using this syntax:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?&lt;pn&gt; \\(\n( (?&gt;[^()]+) | \\g&lt;pn&gt; )* \\) ) <br>\n(sens|respons)e and \\g&rsquo;1&rsquo;ibility</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE supports\nan extension to Oniguruma: if a number is preceded by a plus\nor a minus sign it is taken as a relative reference. For\nexample:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(abc)(?i:\\g&lt;-1&gt;)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\n\\g{...} (Perl syntax) and \\g&lt;...&gt; (Oniguruma syntax)\nare <i>not</i> synonymous. The former is a back reference;\nthe latter is a subroutine call.</p>\n\n<h2>CALLOUTS\n<a name=\"CALLOUTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl has a\nfeature whereby using the sequence (?{...}) causes arbitrary\nPerl code to be obeyed in the middle of matching a regular\nexpression. This makes it possible, amongst other things, to\nextract different substrings that match the same pair of\nparentheses when there is a repetition.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE provides a\nsimilar feature, but of course it cannot obey arbitrary Perl\ncode. The feature is called &quot;callout&quot;. The caller\nof PCRE provides an external function by putting its entry\npoint in the global variable <i>pcre_callout</i> (8-bit\nlibrary) or <i>pcre[16|32]_callout</i> (16-bit or 32-bit\nlibrary). By default, this variable contains NULL, which\ndisables all calling out.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Within a\nregular expression, (?C) indicates the points at which the\nexternal function is to be called. If you want to identify\ndifferent callout points, you can put a number less than 256\nafter the letter C. The default value is zero. For example,\nthis pattern has two callout points:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?C1)abc(?C2)def</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nPCRE_AUTO_CALLOUT flag is passed to a compiling function,\ncallouts are automatically installed before each item in the\npattern. They are all numbered 255. If there is a\nconditional group in the pattern whose condition is an\nassertion, an additional callout is inserted just before the\ncondition. An explicit callout may also be set at this\nposition, as in this example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(?(?C9)(?=a)abc|def)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that this\napplies only to assertion conditions, not to other types of\ncondition.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">During\nmatching, when PCRE reaches a callout point, the external\nfunction is called. It is provided with the number of the\ncallout, the position in the pattern, and, optionally, one\nitem of data originally supplied by the caller of the\nmatching function. The callout function may cause matching\nto proceed, to backtrack, or to fail altogether.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nPCRE implements a number of optimizations at compile time\nand matching time, and one side-effect is that sometimes\ncallouts are skipped. If you need all possible callouts to\nhappen, you need to set options that disable the relevant\noptimizations. More details, and a complete description of\nthe interface to the callout function, are given in the\n<b>pcrecallout</b> documentation.</p>\n\n<h2>BACKTRACKING CONTROL\n<a name=\"BACKTRACKING CONTROL\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl 5.10\nintroduced a number of &quot;Special Backtracking Control\nVerbs&quot;, which are still described in the Perl\ndocumentation as &quot;experimental and subject to change or\nremoval in a future version of Perl&quot;. It goes on to\nsay: &quot;Their usage in production code should be noted to\navoid problems during upgrades.&quot; The same remarks apply\nto the PCRE features described in this section.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The new verbs\nmake use of what was previously invalid syntax: an opening\nparenthesis followed by an asterisk. They are generally of\nthe form (*VERB) or (*VERB:NAME). Some may take either form,\npossibly behaving differently depending on whether or not a\nname is present. A name is any sequence of characters that\ndoes not include a closing parenthesis. The maximum length\nof name is 255 in the 8-bit library and 65535 in the 16-bit\nand 32-bit libraries. If the name is empty, that is, if the\nclosing parenthesis immediately follows the colon, the\neffect is as if the colon were not there. Any number of\nthese verbs may occur in a pattern.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since these\nverbs are specifically related to backtracking, most of them\ncan be used only when the pattern is to be matched using one\nof the traditional matching functions, because these use a\nbacktracking algorithm. With the exception of (*FAIL), which\nbehaves like a failing negative assertion, the backtracking\ncontrol verbs cause an error if encountered by a DFA\nmatching function.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The behaviour\nof these verbs in repeated groups, assertions, and in\nsubpatterns called as subroutines (whether or not\nrecursively) is documented below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Optimizations\nthat affect backtracking verbs</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE contains\nsome optimizations that are used to speed up matching by\nrunning some checks at the start of each match attempt. For\nexample, it may know the minimum length of matching subject,\nor that a particular character must be present. When one of\nthese optimizations bypasses the running of a match, any\nincluded backtracking verbs will not, of course, be\nprocessed. You can suppress the start-of-match optimizations\nby setting the PCRE_NO_START_OPTIMIZE option when calling\n<b>pcre_compile()</b> or <b>pcre_exec()</b>, or by starting\nthe pattern with (*NO_START_OPT). There is more discussion\nof this option in the section entitled &quot;Option bits for\n<b>pcre_exec()</b>&quot; in the <b>pcreapi</b>\ndocumentation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Experiments\nwith Perl suggest that it too has similar optimizations,\nsometimes leading to anomalous results.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Verbs that\nact immediately</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nverbs act as soon as they are encountered. They may not be\nfollowed by a name.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*ACCEPT)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This verb\ncauses the match to end successfully, skipping the remainder\nof the pattern. However, when it is inside a subpattern that\nis called as a subroutine, only that subpattern is ended\nsuccessfully. Matching then continues at the outer level. If\n(*ACCEPT) in triggered in a positive assertion, the\nassertion succeeds; in a negative assertion, the assertion\nfails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If (*ACCEPT) is\ninside capturing parentheses, the data so far is captured.\nFor example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A((?:A|B(*ACCEPT)|C)D)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This matches\n&quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;; when it\nmatches &quot;AB&quot;, &quot;B&quot; is captured by the\nouter parentheses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*FAIL) or\n(*F)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This verb\ncauses a matching failure, forcing backtracking to occur. It\nis equivalent to (?!) but easier to read. The Perl\ndocumentation notes that it is probably useful only when\ncombined with (?{}) or (??{}). Those are, of course, Perl\nfeatures that are not present in PCRE. The nearest\nequivalent is the callout feature, as for example in this\npattern:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">a+(?C)(*FAIL)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A match with\nthe string &quot;aaaa&quot; always fails, but the callout is\ntaken before each backtrack happens (in this example, 10\ntimes).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Recording\nwhich path was taken</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is one\nverb whose main purpose is to track how a match was arrived\nat, though it also has a secondary use in conjunction with\nadvancing the match starting point (see (*SKIP) below).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*MARK:NAME) or\n(*:NAME)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A name is\nalways required with this verb. There may be as many\ninstances of (*MARK) as you like in a pattern, and their\nnames do not have to be unique.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a match\nsucceeds, the name of the last-encountered (*MARK:NAME),\n(*PRUNE:NAME), or (*THEN:NAME) on the matching path is\npassed back to the caller as described in the section\nentitled &quot;Extra data for <b>pcre_exec()</b>&quot; in\nthe <b>pcreapi</b> documentation. Here is an example of\n<b>pcretest</b> output, where the /K modifier requests the\nretrieval and outputting of (*MARK) data:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">re&gt;\n/X(*MARK:A)Y|X(*MARK:B)Z/K <br>\ndata&gt; XY <br>\n0: XY <br>\nMK: A <br>\nXZ <br>\n0: XZ <br>\nMK: B</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The (*MARK)\nname is tagged with &quot;MK:&quot; in this output, and in\nthis example it indicates which of the two alternatives\nmatched. This is a more efficient way of obtaining this\ninformation than putting each alternative in its own\ncapturing parentheses.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a verb with\na name is encountered in a positive assertion that is true,\nthe name is recorded and passed back if it is the\nlast-encountered. This does not happen for negative\nassertions or failing positive assertions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After a partial\nmatch or a failed match, the last encountered name in the\nentire match process is returned. For example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">re&gt;\n/X(*MARK:A)Y|X(*MARK:B)Z/K <br>\ndata&gt; XP <br>\nNo match, mark = B</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that in\nthis unanchored example the mark is retained from the match\nattempt that started at the letter &quot;X&quot; in the\nsubject. Subsequent match attempts starting at &quot;P&quot;\nand then with an empty string do not get as far as the\n(*MARK) item, but nevertheless do not reset it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you are\ninterested in (*MARK) values after failed matches, you\nshould probably set the PCRE_NO_START_OPTIMIZE option (see\nabove) to ensure that the match is always attempted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Verbs that\nact after backtracking</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nverbs do nothing when they are encountered. Matching\ncontinues with what follows, but if there is no subsequent\nmatch, causing a backtrack to the verb, a failure is forced.\nThat is, backtracking cannot pass to the left of the verb.\nHowever, when one of these verbs appears inside an atomic\ngroup or an assertion that is true, its effect is confined\nto that group, because once the group has been matched,\nthere is never any backtracking into it. In this situation,\nbacktracking can &quot;jump back&quot; to the left of the\nentire atomic group or assertion. (Remember also, as stated\nabove, that this localization also applies in subroutine\ncalls.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These verbs\ndiffer in exactly what kind of failure occurs when\nbacktracking reaches them. The behaviour described below is\nwhat happens when the verb is not in a subroutine or an\nassertion. Subsequent sections cover these special\ncases.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*COMMIT)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This verb,\nwhich may not be followed by a name, causes the whole match\nto fail outright if there is a later matching failure that\ncauses backtracking to reach it. Even if the pattern is\nunanchored, no further attempts to find a match by advancing\nthe starting point take place. If (*COMMIT) is the only\nbacktracking verb that is encountered, once it has been\npassed <b>pcre_exec()</b> is committed to finding a match at\nthe current starting point, or not at all. For example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">a+(*COMMIT)b</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This matches\n&quot;xxaab&quot; but not &quot;aacaab&quot;. It can be\nthought of as a kind of dynamic anchor, or &quot;I&rsquo;ve\nstarted, so I must finish.&quot; The name of the most\nrecently passed (*MARK) in the path is passed back when\n(*COMMIT) forces a match failure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If there is\nmore than one backtracking verb in a pattern, a different\none that follows (*COMMIT) may be triggered first, so merely\npassing (*COMMIT) during a match does not always guarantee\nthat a match must be at this starting point.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\n(*COMMIT) at the start of a pattern is not the same as an\nanchor, unless PCRE&rsquo;s start-of-match optimizations are\nturned off, as shown in this output from\n<b>pcretest</b>:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">re&gt;\n/(*COMMIT)abc/ <br>\ndata&gt; xyzabc <br>\n0: abc <br>\ndata&gt; xyzabc\\Y <br>\nNo match</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For this\npattern, PCRE knows that any match must start with\n&quot;a&quot;, so the optimization skips along the subject\nto &quot;a&quot; before applying the pattern to the first\nset of data. The match attempt then succeeds. In the second\nset of data, the escape sequence \\Y is interpreted by the\n<b>pcretest</b> program. It causes the\nPCRE_NO_START_OPTIMIZE option to be set when\n<b>pcre_exec()</b> is called. This disables the optimization\nthat skips along to the first character. The pattern is now\napplied starting at &quot;x&quot;, and so the (*COMMIT)\ncauses the match to fail without trying any other starting\npoints.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*PRUNE) or\n(*PRUNE:NAME)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This verb\ncauses the match to fail at the current starting position in\nthe subject if there is a later matching failure that causes\nbacktracking to reach it. If the pattern is unanchored, the\nnormal &quot;bumpalong&quot; advance to the next starting\ncharacter then happens. Backtracking can occur as usual to\nthe left of (*PRUNE), before it is reached, or when matching\nto the right of (*PRUNE), but if there is no match to the\nright, backtracking cannot cross (*PRUNE). In simple cases,\nthe use of (*PRUNE) is just an alternative to an atomic\ngroup or possessive quantifier, but there are some uses of\n(*PRUNE) that cannot be expressed in any other way. In an\nanchored pattern (*PRUNE) has the same effect as\n(*COMMIT).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The behaviour\nof (*PRUNE:NAME) is the not the same as\n(*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the\nname is remembered for passing back to the caller. However,\n(*SKIP:NAME) searches only for names set with (*MARK).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*SKIP)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This verb, when\ngiven without a name, is like (*PRUNE), except that if the\npattern is unanchored, the &quot;bumpalong&quot; advance is\nnot to the next character, but to the position in the\nsubject where (*SKIP) was encountered. (*SKIP) signifies\nthat whatever text was matched leading up to it cannot be\npart of a successful match. Consider:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">a+(*SKIP)b</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the subject\nis &quot;aaaac...&quot;, after the first match attempt fails\n(starting at the first character in the string), the\nstarting point skips on to start the next attempt at\n&quot;c&quot;. Note that a possessive quantifer does not\nhave the same effect as this example; although it would\nsuppress backtracking during the first match attempt, the\nsecond attempt would start at the second character instead\nof skipping on to &quot;c&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*SKIP:NAME)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When (*SKIP)\nhas an associated name, its behaviour is modified. When it\nis triggered, the previous path through the pattern is\nsearched for the most recent (*MARK) that has the same name.\nIf one is found, the &quot;bumpalong&quot; advance is to the\nsubject position that corresponds to that (*MARK) instead of\nto where (*SKIP) was encountered. If no (*MARK) with a\nmatching name is found, the (*SKIP) is ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\n(*SKIP:NAME) searches only for names set by (*MARK:NAME). It\nignores names that are set by (*PRUNE:NAME) or\n(*THEN:NAME).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*THEN) or\n(*THEN:NAME)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This verb\ncauses a skip to the next innermost alternative when\nbacktracking reaches it. That is, it cancels any further\nbacktracking within the current alternative. Its name comes\nfrom the observation that it can be used for a pattern-based\nif-then-else block:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">( COND1 (*THEN)\nFOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the COND1\npattern matches, FOO is tried (and possibly further items\nafter the end of the group if FOO succeeds); on failure, the\nmatcher skips to the second alternative and tries COND2,\nwithout backtracking into COND1. If that succeeds and BAR\nfails, COND3 is tried. If subsequently BAZ fails, there are\nno more alternatives, so there is a backtrack to whatever\ncame before the entire group. If (*THEN) is not inside an\nalternation, it acts like (*PRUNE).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The behaviour\nof (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN).\nIt is like (*MARK:NAME) in that the name is remembered for\npassing back to the caller. However, (*SKIP:NAME) searches\nonly for names set with (*MARK).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A subpattern\nthat does not contain a | character is just a part of the\nenclosing alternative; it is not a nested alternation with\nonly one alternative. The effect of (*THEN) extends beyond\nsuch a subpattern to the enclosing alternative. Consider\nthis pattern, where A, B, etc. are complex pattern fragments\nthat do not contain any | characters at this level:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A (B(*THEN)C) |\nD</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If A and B are\nmatched, but there is a failure in C, matching does not\nbacktrack into A; instead it moves to the next alternative,\nthat is, D. However, if the subpattern containing (*THEN) is\ngiven an alternative, it behaves differently:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A (B(*THEN)C |\n(*FAIL)) | D</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The effect of\n(*THEN) is now confined to the inner subpattern. After a\nfailure in C, matching moves to (*FAIL), which causes the\nwhole subpattern to fail because there are no more\nalternatives to try. In this case, matching does now\nbacktrack into A.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that a\nconditional subpattern is not considered as having two\nalternatives, because only one is ever used. In other words,\nthe | character in a conditional subpattern has a different\nmeaning. Ignoring white space, consider:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">^.*? (?(?=a) a\n| b(*THEN)c )</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the subject\nis &quot;ba&quot;, this pattern does not match. Because .*?\nis ungreedy, it initially matches zero characters. The\ncondition (?=a) then fails, the character &quot;b&quot; is\nmatched, but &quot;c&quot; is not. At this point, matching\ndoes not backtrack to .*? as might perhaps be expected from\nthe presence of the | character. The conditional subpattern\nis part of the single alternative that comprises the whole\npattern, and so the match fails. (If there was a backtrack\ninto .*?, allowing it to match &quot;b&quot;, the match\nwould succeed.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The verbs just\ndescribed provide four different &quot;strengths&quot; of\ncontrol when subsequent matching fails. (*THEN) is the\nweakest, carrying on the match at the next alternative.\n(*PRUNE) comes next, failing the match at the current\nstarting position, but allowing an advance to the next\ncharacter (for an unanchored pattern). (*SKIP) is similar,\nexcept that the advance may be more than one character.\n(*COMMIT) is the strongest, causing the entire match to\nfail.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>More than\none backtracking verb</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If more than\none backtracking verb is present in a pattern, the one that\nis backtracked onto first acts. For example, consider this\npattern, where A, B, etc. are complex pattern fragments:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">(A(*COMMIT)B(*THEN)C|ABD)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If A matches\nbut B fails, the backtrack to (*COMMIT) causes the entire\nmatch to fail. However, if A and B match, but C fails, the\nbacktrack to (*THEN) causes the next alternative (ABD) to be\ntried. This behaviour is consistent, but is not always the\nsame as Perl&rsquo;s. It means that if two or more\nbacktracking verbs appear in succession, all the the last of\nthem has no effect. Consider this example:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">...(*COMMIT)(*PRUNE)...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If there is a\nmatching failure to the right, backtracking onto (*PRUNE)\ncauses it to be triggered, and its action is taken. There\ncan never be a backtrack onto (*COMMIT).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Backtracking\nverbs in repeated groups</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">PCRE differs\nfrom Perl in its handling of backtracking verbs in repeated\ngroups. For example, consider:</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">/(a(*COMMIT)b)+ac/</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the subject\nis &quot;abac&quot;, Perl matches, but PCRE fails because\nthe (*COMMIT) in the second repeat of the group acts.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Backtracking\nverbs in assertions</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*FAIL) in an\nassertion has its normal effect: it forces an immediate\nbacktrack.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*ACCEPT) in a\npositive assertion causes the assertion to succeed without\nany further processing. In a negative assertion, (*ACCEPT)\ncauses the assertion to fail without any further\nprocessing.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The other\nbacktracking verbs are not treated specially if they appear\nin a positive assertion. In particular, (*THEN) skips to the\nnext alternative in the innermost enclosing group that has\nalternations, whether or not this is within the\nassertion.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Negative\nassertions are, however, different, in order to ensure that\nchanging a positive assertion into a negative assertion\nchanges its result. Backtracking into (*COMMIT), (*SKIP), or\n(*PRUNE) causes a negative assertion to be true, without\nconsidering any further alternative branches in the\nassertion. Backtracking into (*THEN) causes it to skip to\nthe next enclosing alternative within the assertion (the\nnormal behaviour), but if the assertion does not have such\nan alternative, (*THEN) behaves like (*PRUNE).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Backtracking\nverbs in subroutines</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These\nbehaviours occur whether or not the subpattern is called\nrecursively. Perl&rsquo;s treatment of subroutines is\ndifferent in some cases.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*FAIL) in a\nsubpattern called as a subroutine has its normal effect: it\nforces an immediate backtrack.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*ACCEPT) in a\nsubpattern called as a subroutine causes the subroutine\nmatch to succeed without any further processing. Matching\nthen continues after the subroutine call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*COMMIT),\n(*SKIP), and (*PRUNE) in a subpattern called as a subroutine\ncause the subroutine match to fail.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(*THEN) skips\nto the next alternative in the innermost enclosing group\nwithin the subpattern that has alternatives. If there is no\nsuch group within the subpattern, (*THEN) causes the\nsubroutine match to fail.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/pcreapi\">pcreapi(3)</a>,\n<a href=\"https://man.page/3/pcrecallout\">pcrecallout(3)</a>, <a href=\"https://man.page/3/pcrematching\">pcrematching(3)</a>,\n<a href=\"https://man.page/3/pcresyntax\">pcresyntax(3)</a>, <a href=\"https://man.page/3/pcre\">pcre(3)</a>, <b>pcre16(3)</b>,\n<b>pcre32(3)</b>.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Philip Hazel\n<br>\nUniversity Computing Service <br>\nCambridge CB2 3QH, England.</p>\n\n<h2>REVISION\n<a name=\"REVISION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Last updated:\n14 June 2015 <br>\nCopyright (c) 1997-2015 University of Cambridge.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#PCRE REGULAR EXPRESSION DETAILS\">PCRE REGULAR EXPRESSION DETAILS</a>","<a href=\"#SPECIAL START-OF-PATTERN ITEMS\">SPECIAL START-OF-PATTERN ITEMS</a>","<a href=\"#EBCDIC CHARACTER CODES\">EBCDIC CHARACTER CODES</a>","<a href=\"#CHARACTERS AND METACHARACTERS\">CHARACTERS AND METACHARACTERS</a>","<a href=\"#BACKSLASH\">BACKSLASH</a>","<a href=\"#CIRCUMFLEX AND DOLLAR\">CIRCUMFLEX AND DOLLAR</a>","<a href=\"#FULL STOP (PERIOD, DOT) AND \\N\">FULL STOP (PERIOD, DOT) AND \\N</a>","<a href=\"#MATCHING A SINGLE DATA UNIT\">MATCHING A SINGLE DATA UNIT</a>","<a href=\"#SQUARE BRACKETS AND CHARACTER CLASSES\">SQUARE BRACKETS AND CHARACTER CLASSES</a>","<a href=\"#POSIX CHARACTER CLASSES\">POSIX CHARACTER CLASSES</a>","<a href=\"#COMPATIBILITY FEATURE FOR WORD BOUNDARIES\">COMPATIBILITY FEATURE FOR WORD BOUNDARIES</a>","<a href=\"#VERTICAL BAR\">VERTICAL BAR</a>","<a href=\"#INTERNAL OPTION SETTING\">INTERNAL OPTION SETTING</a>","<a href=\"#SUBPATTERNS\">SUBPATTERNS</a>","<a href=\"#DUPLICATE SUBPATTERN NUMBERS\">DUPLICATE SUBPATTERN NUMBERS</a>","<a href=\"#NAMED SUBPATTERNS\">NAMED SUBPATTERNS</a>","<a href=\"#REPETITION\">REPETITION</a>","<a href=\"#ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS\">ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS</a>","<a href=\"#BACK REFERENCES\">BACK REFERENCES</a>","<a href=\"#ASSERTIONS\">ASSERTIONS</a>","<a href=\"#CONDITIONAL SUBPATTERNS\">CONDITIONAL SUBPATTERNS</a>","<a href=\"#COMMENTS\">COMMENTS</a>","<a href=\"#RECURSIVE PATTERNS\">RECURSIVE PATTERNS</a>","<a href=\"#SUBPATTERNS AS SUBROUTINES\">SUBPATTERNS AS SUBROUTINES</a>","<a href=\"#ONIGURUMA SUBROUTINE SYNTAX\">ONIGURUMA SUBROUTINE SYNTAX</a>","<a href=\"#CALLOUTS\">CALLOUTS</a>","<a href=\"#BACKTRACKING CONTROL\">BACKTRACKING CONTROL</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#REVISION\">REVISION</a>"],"level":3}