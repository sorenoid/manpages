{"name":"dlopen","description":"dlclose,\ndlopen, dlmopen - open and close a shared object","body":"\n\n<h1 align=\"center\">DLOPEN</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">dlclose,\ndlopen, dlmopen - open and close a shared object</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;dlfcn.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*dlopen(const char *</b><i>filename</i><b>, int</b>\n<i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ndlclose(void *</b><i>handle</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE <br>\n#include &lt;dlfcn.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\n*dlmopen(Lmid_t</b> <i>lmid</i><b>, const char\n*</b><i>filename</i><b>, int</b> <i>flags</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Link with\n<i>-ldl</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dlopen()</b>\n<br>\nThe function <b>dlopen</b>() loads the dynamic shared object\n(shared library) file named by the null-terminated string\n<i>filename</i> and returns an opaque &quot;handle&quot; for\nthe loaded object. This handle is employed with other\nfunctions in the dlopen API, such as <a href=\"https://man.page/3/dlsym\">dlsym(3)</a>,\n<a href=\"https://man.page/3/dladdr\">dladdr(3)</a>, <a href=\"https://man.page/3/dlinfo\">dlinfo(3)</a>, and\n<b>dlclose</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>filename</i> is NULL, then the returned handle is for the\nmain program. If <i>filename</i> contains a slash\n(&quot;/&quot;), then it is interpreted as a (relative or\nabsolute) pathname. Otherwise, the dynamic linker searches\nfor the object as follows (see <b>ld.so</b>(8) for further\ndetails):</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>o</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>(ELF only) If the calling object (i.e., the shared\nlibrary or executable from which <b>dlopen</b>() is called)\ncontains a DT_RPATH tag, and does not contain a DT_RUNPATH\ntag, then the directories listed in the DT_RPATH tag are\nsearched.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>o</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>If, at the time that the program was started, the\nenvironment variable <b>LD_LIBRARY_PATH</b> was defined to\ncontain a colon-separated list of directories, then these\nare searched. (As a security measure, this variable is\nignored for set-user-ID and set-group-ID programs.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>o</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>(ELF only) If the calling object contains a DT_RUNPATH\ntag, then the directories listed in that tag are\nsearched.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>o</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>The cache file <i>/etc/ld.so.cache</i> (maintained by\n<b>ldconfig</b>(8)) is checked to see whether it contains an\nentry for <i>filename</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>o</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>The directories <i>/lib</i> and <i>/usr/lib</i> are\nsearched (in that order).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the object\nspecified by <i>filename</i> has dependencies on other\nshared objects, then these are also automatically loaded by\nthe dynamic linker using the same rules. (This process may\noccur recursively, if those objects in turn have\ndependencies, and so on.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">One of the\nfollowing two values must be included in <i>flags</i>:\n<b><br>\nRTLD_LAZY</b></p>\n\n<p style=\"margin-left:22%;\">Perform lazy binding. Resolve\nsymbols only as the code that references them is executed.\nIf the symbol is never referenced, then it is never\nresolved. (Lazy binding is performed only for function\nreferences; references to variables are always immediately\nbound when the shared object is loaded.) Since glibc 2.1.1,\nthis flag is overridden by the effect of the\n<b>LD_BIND_NOW</b> environment variable.</p>\n\n<p style=\"margin-left:11%;\"><b>RTLD_NOW</b></p>\n\n<p style=\"margin-left:22%;\">If this value is specified, or\nthe environment variable <b>LD_BIND_NOW</b> is set to a\nnonempty string, all undefined symbols in the shared object\nare resolved before <b>dlopen</b>() returns. If this cannot\nbe done, an error is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Zero or more of\nthe following values may also be ORed in <i>flags</i>:\n<b><br>\nRTLD_GLOBAL</b></p>\n\n<p style=\"margin-left:22%;\">The symbols defined by this\nshared object will be made available for symbol resolution\nof subsequently loaded shared objects.</p>\n\n<p style=\"margin-left:11%;\"><b>RTLD_LOCAL</b></p>\n\n<p style=\"margin-left:22%;\">This is the converse of\n<b>RTLD_GLOBAL</b>, and the default if neither flag is\nspecified. Symbols defined in this shared object are not\nmade available to resolve references in subsequently loaded\nshared objects.</p>\n\n<p style=\"margin-left:11%;\"><b>RTLD_NODELETE</b> (since\nglibc 2.2)</p>\n\n<p style=\"margin-left:22%;\">Do not unload the shared object\nduring <b>dlclose</b>(). Consequently, the object&rsquo;s\nstatic and global variables are not reinitialized if the\nobject is reloaded with <b>dlopen</b>() at a later time.</p>\n\n<p style=\"margin-left:11%;\"><b>RTLD_NOLOAD</b> (since glibc\n2.2)</p>\n\n<p style=\"margin-left:22%;\">Don&rsquo;t load the shared\nobject. This can be used to test if the object is already\nresident (<b>dlopen</b>() returns NULL if it is not, or the\nobject&rsquo;s handle if it is resident). This flag can also\nbe used to promote the flags on a shared object that is\nalready loaded. For example, a shared object that was\npreviously loaded with <b>RTLD_LOCAL</b> can be reopened\nwith <b>RTLD_NOLOAD&nbsp;|&nbsp;RTLD_GLOBAL</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>RTLD_DEEPBIND</b> (since\nglibc 2.3.4)</p>\n\n<p style=\"margin-left:22%;\">Place the lookup scope of the\nsymbols in this shared object ahead of the global scope.\nThis means that a self-contained object will use its own\nsymbols in preference to global symbols with the same name\ncontained in objects that have already been loaded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>filename</i> is NULL, then the returned handle is for the\nmain program. When given to <a href=\"https://man.page/3/dlsym\">dlsym(3)</a>, this handle\ncauses a search for a symbol in the main program, followed\nby all shared objects loaded at program startup, and then\nall shared objects loaded by <b>dlopen</b>() with the flag\n<b>RTLD_GLOBAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Symbol\nreferences in the shared object are resolved using (in\norder): symbols in the link map of objects loaded for the\nmain program and its dependencies; symbols in shared objects\n(and their dependencies) that were previously opened with\n<b>dlopen</b>() using the <b>RTLD_GLOBAL</b> flag; and\ndefinitions in the shared object itself (and any\ndependencies that were loaded for that object).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Any global\nsymbols in the executable that were placed into its dynamic\nsymbol table by <a href=\"https://man.page/1/ld\">ld(1)</a> can also be used to resolve\nreferences in a dynamically loaded shared object. Symbols\nmay be placed in the dynamic symbol table either because the\nexecutable was linked with the flag &quot;-rdynamic&quot;\n(or, synonymously, &quot;--export-dynamic&quot;), which\ncauses all of the executable&rsquo;s global symbols to be\nplaced in the dynamic symbol table, or because <a href=\"https://man.page/1/ld\">ld(1)</a>\nnoted a dependency on a symbol in another object during\nstatic linking.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the same\nshared object is opened again with <b>dlopen</b>(), the same\nobject handle is returned. The dynamic linker maintains\nreference counts for object handles, so a dynamically loaded\nshared object is not deallocated until <b>dlclose</b>() has\nbeen called on it as many times as <b>dlopen</b>() has\nsucceeded on it. Constructors (see below) are called only\nwhen the object is actually loaded into memory (i.e., when\nthe reference count increases to 1).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A subsequent\n<b>dlopen</b>() call that loads the same shared object with\n<b>RTLD_NOW</b> may force symbol resolution for a shared\nobject earlier loaded with <b>RTLD_LAZY</b>. Similarly, an\nobject that was previously opened with <b>RTLD_LOCAL</b> can\nbe promoted to <b>RTLD_GLOBAL</b> in a subsequent\n<b>dlopen</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<b>dlopen</b>() fails for any reason, it returns NULL.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dlmopen()</b>\n<br>\nThis function performs the same task as\n<b>dlopen</b>()&mdash;the <i>filename</i> and <i>flags</i>\narguments, as well as the return value, are the same, except\nfor the differences noted below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>dlmopen</b>() function differs from <b>dlopen</b>()\nprimarily in that it accepts an additional argument,\n<i>lmid</i>, that specifies the link-map list (also referred\nto as a <i>namespace</i>) in which the shared object should\nbe loaded. (By comparison, <b>dlopen</b>() adds the\ndynamically loaded shared object to the same namespace as\nthe shared object from which the <b>dlopen</b>() call is\nmade.) The <i>Lmid_t</i> type is an opaque handle that\nrefers to a namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>lmid</i>\nargument is either the ID of an existing namespace (which\ncan be obtained using the <a href=\"https://man.page/3/dlinfo\">dlinfo(3)</a>\n<b>RTLD_DI_LMID</b> request) or one of the following special\nvalues: <b><br>\nLM_ID_BASE</b></p>\n\n<p style=\"margin-left:22%;\">Load the shared object in the\ninitial namespace (i.e., the application&rsquo;s\nnamespace).</p>\n\n<p style=\"margin-left:11%;\"><b>LM_ID_NEWLM</b></p>\n\n<p style=\"margin-left:22%;\">Create a new namespace and load\nthe shared object in that namespace. The object must have\nbeen correctly linked to reference all of the other shared\nobjects that it requires, since the new namespace is\ninitially empty.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n<i>filename</i> is NULL, then the only permitted value for\n<i>lmid</i> is <b>LM_ID_BASE</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dlclose()</b>\n<br>\nThe function <b>dlclose</b>() decrements the reference count\non the dynamically loaded shared object referred to by\n<i>handle</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nobject&rsquo;s reference count drops to zero and no symbols\nin this object are required by other objects, then the\nobject is unloaded after first calling any destructors\ndefined for the object. (Symbols in this object might be\nrequired in another object because this object was opened\nwith the <b>RTLD_GLOBAL</b> flag and one of its symbols\nsatisfied a relocation in another object.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All shared\nobjects that were automatically loaded when <b>dlopen</b>()\nwas invoked on the object referred to by <i>handle</i> are\nrecursively closed in the same manner.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A successful\nreturn from <b>dlclose</b>() does not guarantee that the\nsymbols associated with <i>handle</i> are removed from the\ncaller&rsquo;s address space. In addition to references\nresulting from explicit <b>dlopen</b>() calls, a shared\nobject may have been implicitly loaded (and reference\ncounted) because of dependencies in other shared objects.\nOnly when all references have been released can the shared\nobject be removed from the address space.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>dlopen</b>() and <b>dlmopen</b>() return a non-NULL\nhandle for the loaded object. On error (file could not be\nfound, was not readable, had the wrong format, or caused\nerrors during loading), these functions return NULL.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\n<b>dlclose</b>() returns 0; on error, it returns a nonzero\nvalue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Errors from\nthese functions can be diagnosed using\n<a href=\"https://man.page/3/dlerror\">dlerror(3)</a>.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dlopen</b>()\nand <b>dlclose</b>() are present in glibc 2.0 and later.\n<b>dlmopen</b>() first appeared in glibc 2.3.4.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3296431.png\" alt=\"Image grohtml-3296431.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2001\ndescribes <b>dlclose</b>() and <b>dlopen</b>(). The\n<b>dlmopen</b>() function is a GNU extension.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>RTLD_NOLOAD</b>, <b>RTLD_NODELETE</b>, and\n<b>RTLD_DEEPBIND</b> flags are GNU extensions; the first two\nof these flags are also present on Solaris.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dlmopen()\nand namespaces</b> <br>\nA link-map list defines an isolated namespace for the\nresolution of symbols by the dynamic linker. Within a\nnamespace, dependent shared objects are implicitly loaded\naccording to the usual rules, and symbol references are\nlikewise resolved according to the usual rules, but such\nresolution is confined to the definitions provided by the\nobjects that have been (explicitly and implicitly) loaded\ninto the namespace.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>dlmopen</b>() function permits object-load\nisolation&mdash;the ability to load a shared object in a new\nnamespace without exposing the rest of the application to\nthe symbols made available by the new object. Note that the\nuse of the <b>RTLD_LOCAL</b> flag is not sufficient for this\npurpose, since it prevents a shared object&rsquo;s symbols\nfrom being available to <i>any</i> other shared object. In\nsome cases, we may want to make the symbols provided by a\ndynamically loaded shared object available to (a subset of)\nother shared objects without exposing those symbols to the\nentire application. This can be achieved by using a separate\nnamespace and the <b>RTLD_GLOBAL</b> flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>dlmopen</b>() function also can be used to provide better\nisolation than the <b>RTLD_LOCAL</b> flag. In particular,\nshared objects loaded with <b>RTLD_LOCAL</b> may be promoted\nto <b>RTLD_GLOBAL</b> if they are dependencies of another\nshared object loaded with <b>RTLD_GLOBAL</b>. Thus,\n<b>RTLD_LOCAL</b> is insufficient to isolate a loaded shared\nobject except in the (uncommon) case where one has explicit\ncontrol over all shared object dependencies.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Possible uses\nof <b>dlmopen</b>() are plugins where the author of the\nplugin-loading framework can&rsquo;t trust the plugin\nauthors and does not wish any undefined symbols from the\nplugin framework to be resolved to plugin symbols. Another\nuse is to load the same object more than once. Without the\nuse of <b>dlmopen</b>(), this would require the creation of\ndistinct copies of the shared object file. Using\n<b>dlmopen</b>(), this can be achieved by loading the same\nshared object file into different namespaces.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The glibc\nimplementation supports a maximum of 16 namespaces.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Initialization\nand finalization functions</b> <br>\nShared objects may export functions using the\n<b>__attribute__((constructor))</b> and\n<b>__attribute__((destructor))</b> function attributes.\nConstructor functions are executed before <b>dlopen</b>()\nreturns, and destructor functions are executed before\n<b>dlclose</b>() returns. A shared object may export\nmultiple constructors and destructors, and priorities can be\nassociated with each function to determine the order in\nwhich they are executed. See the <b>gcc</b> info pages\n(under &quot;Function attributes&quot;) for further\ninformation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An older method\nof (partially) achieving the same result is via the use of\ntwo special symbols recognized by the linker: <b>_init</b>\nand <b>_fini</b>. If a dynamically loaded shared object\nexports a routine named <b>_init</b>(), then that code is\nexecuted after loading a shared object, before\n<b>dlopen</b>() returns. If the shared object exports a\nroutine named <b>_fini</b>(), then that routine is called\njust before the object is unloaded. In this case, one must\navoid linking against the system startup files, which\ncontain default versions of these files; this can be done by\nusing the <a href=\"https://man.page/1/gcc\">gcc(1)</a> <i>-nostartfiles</i> command-line\noption.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Use of\n<b>_init</b> and <b>_fini</b> is now deprecated in favor of\nthe aforementioned constructors and destructors, which among\nother advantages, permit multiple initialization and\nfinalization functions to be defined.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since glibc\n2.2.3, <a href=\"https://man.page/3/atexit\">atexit(3)</a> can be used to register an exit\nhandler that is automatically called when a shared object is\nunloaded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>History</b>\n<br>\nThese functions are part of the dlopen API, derived from\nSunOS.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">As at glibc\n2.24, specifying the <b>RTLD_GLOBAL</b> flag when calling\n<b>dlmopen</b>() generates an error. Furthermore, specifying\n<b>RTLD_GLOBAL</b> when calling <b>dlopen</b>() results in a\nprogram crash (<b>SIGSEGV</b>) if the call is made from any\nobject loaded in a namespace other than the initial\nnamespace.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow loads the (glibc) math library, looks up the address\nof the <a href=\"https://man.page/3/cos\">cos(3)</a> function, and prints the cosine of 2.0.\nThe following is an example of building and running the\nprogram:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cc\ndlopen_demo.c -ldl</b> <br>\n$ <b>./a.out</b> <br>\n-0.416147</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;dlfcn.h&gt; <br>\n#include &lt;gnu/lib-names.h&gt; /* Defines LIBM_SO (which\nwill be a <br>\nstring such as &quot;libm.so.6&quot;) */ <br>\nint <br>\nmain(void) <br>\n{ <br>\nvoid *handle; <br>\ndouble (*cosine)(double); <br>\nchar *error;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">handle =\ndlopen(LIBM_SO, RTLD_LAZY); <br>\nif (!handle) { <br>\nfprintf(stderr, &quot;%s\\n&quot;, dlerror()); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">dlerror(); /*\nClear any existing error */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">cosine =\n(double (*)(double)) dlsym(handle, &quot;cos&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* According to\nthe ISO C standard, casting between function <br>\npointers and 'void *', as done above, produces undefined\nresults. <br>\nPOSIX.1-2001 and POSIX.1-2008 accepted this state of affairs\nand <br>\nproposed the following workaround:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">*(void **)\n(&amp;cosine) = dlsym(handle, &quot;cos&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This (clumsy)\ncast conforms with the ISO C standard and will <br>\navoid any compiler warnings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The 2013\nTechnical Corrigendum 1 to POSIX.1-2008 improved matters\n<br>\nby requiring that conforming implementations support casting\n<br>\n'void *' to a function pointer. Nevertheless, some compilers\n<br>\n(e.g., gcc with the '-pedantic' option) may complain about\nthe <br>\ncast used in this program. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">error =\ndlerror(); <br>\nif (error != NULL) { <br>\nfprintf(stderr, &quot;%s\\n&quot;, error); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;%f\\n&quot;,\n(*cosine)(2.0)); <br>\ndlclose(handle); <br>\nexit(EXIT_SUCCESS); <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/ld\">ld(1)</a>,\n<a href=\"https://man.page/1/ldd\">ldd(1)</a>, <a href=\"https://man.page/1/pldd\">pldd(1)</a>, <a href=\"https://man.page/3/dl_iterate_phdr\">dl_iterate_phdr(3)</a>,\n<a href=\"https://man.page/3/dladdr\">dladdr(3)</a>, <a href=\"https://man.page/3/dlerror\">dlerror(3)</a>, <a href=\"https://man.page/3/dlinfo\">dlinfo(3)</a>,\n<a href=\"https://man.page/3/dlsym\">dlsym(3)</a>, <a href=\"https://man.page/7/rtld-audit\">rtld-audit(7)</a>, <b>ld.so</b>(8),\n<b>ldconfig</b>(8)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">gcc info pages,\nld info pages</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}