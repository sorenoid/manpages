{"name":"setjmp","body":"\n\n<h1 align=\"center\">SETJMP</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">setjmp,\nsigsetjmp, longjmp, siglongjmp - performing a nonlocal\ngoto</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;setjmp.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nsetjmp(jmp_buf</b> <i>env</i><b>); <br>\nint sigsetjmp(sigjmp_buf</b> <i>env</i><b>, int</b>\n<i>savesigs</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nlongjmp(jmp_buf</b> <i>env</i><b>, int</b> <i>val</i><b>);\n<br>\nvoid siglongjmp(sigjmp_buf</b> <i>env</i><b>, int</b>\n<i>val</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>setjmp</b>():\nsee NOTES.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>sigsetjmp</b>():\n_POSIX_C_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\ndescribed on this page are used for performing\n&quot;nonlocal gotos&quot;: transferring execution from one\nfunction to a predetermined location in another function.\nThe <b>setjmp</b>() function dynamically establishes the\ntarget to which control will later be transferred, and\n<b>longjmp</b>() performs the transfer of execution.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>setjmp</b>() function saves various information about the\ncalling environment (typically, the stack pointer, the\ninstruction pointer, possibly the values of other registers\nand the signal mask) in the buffer <i>env</i> for later use\nby <b>longjmp</b>(). In this case, <b>setjmp</b>() returns\n0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>longjmp</b>() function uses the information saved in\n<i>env</i> to transfer control back to the point where\n<b>setjmp</b>() was called and to restore\n(&quot;rewind&quot;) the stack to its state at the time of\nthe <b>setjmp</b>() call. In addition, and depending on the\nimplementation (see NOTES), the values of some other\nregisters and the process signal mask may be restored to\ntheir state at the time of the <b>setjmp</b>() call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Following a\nsuccessful <b>longjmp</b>(), execution continues as if\n<b>setjmp</b>() had returned for a second time. This\n&quot;fake&quot; return can be distinguished from a true\n<b>setjmp</b>() call because the &quot;fake&quot; return\nreturns the value provided in <i>val</i>. If the programmer\nmistakenly passes the value 0 in <i>val</i>, the\n&quot;fake&quot; return will instead return 1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>sigsetjmp()\nand siglongjmp() <br>\nsigsetjmp</b>() and <b>siglongjmp</b>() also perform\nnonlocal gotos, but provide predictable handling of the\nprocess signal mask.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If, and only\nif, the <i>savesigs</i> argument provided to\n<b>sigsetjmp</b>() is nonzero, the process&rsquo;s current\nsignal mask is saved in <i>env</i> and will be restored if a\n<b>siglongjmp</b>() is later performed with this\n<i>env</i>.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>setjmp</b>()\nand <b>sigsetjmp</b>() return 0 when called directly; on the\n&quot;fake&quot; return that occurs after <b>longjmp</b>()\nor <b>siglongjmp</b>(), the nonzero value specified in\n<i>val</i> is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>longjmp</b>() or <b>siglongjmp</b>() functions do not\nreturn.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\">\n</td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n</table>\n\n\n<p align=\"center\"><img src=\"grohtml-3389551.png\" alt=\"Image grohtml-3389551.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>setjmp</b>(),\n<b>longjmp</b>(): POSIX.1-2001, POSIX.1-2008, C89, C99.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>sigsetjmp</b>(),\n<b>siglongjmp</b>(): POSIX.1-2001, POSIX.1-2008.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX does not\nspecify whether <b>setjmp</b>() will save the signal mask\n(to be later restored during <b>longjmp</b>()). In System V\nit will not. In 4.3BSD it will, and there is a function\n<b>_setjmp</b>() that will not. The behavior under Linux\ndepends on the glibc version and the setting of feature test\nmacros. On Linux with glibc versions before 2.19,\n<b>setjmp</b>() follows the System V behavior by default,\nbut the BSD behavior is provided if the <b>_BSD_SOURCE</b>\nfeature test macro is explicitly defined and none of\n<b>_POSIX_SOURCE</b>, <b>_POSIX_C_SOURCE</b>,\n<b>_XOPEN_SOURCE</b>, <b>_GNU_SOURCE</b>, or\n<b>_SVID_SOURCE</b> is defined. Since glibc 2.19,\n<i>&lt;setjmp.h&gt;</i> exposes only the System V version of\n<b>setjmp</b>(). Programs that need the BSD semantics should\nreplace calls to <b>setjmp</b>() with calls to\n<b>sigsetjmp</b>() with a nonzero <i>savesigs</i>\nargument.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>setjmp</b>()\nand <b>longjmp</b>() can be useful for dealing with errors\ninside deeply nested function calls or to allow a signal\nhandler to pass control to a specific point in the program,\nrather than returning to the point where the handler\ninterrupted the main program. In the latter case, if you\nwant to portably save and restore signal masks, use\n<b>sigsetjmp</b>() and <b>siglongjmp</b>(). See also the\ndiscussion of program readability below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The compiler\nmay optimize variables into registers, and <b>longjmp</b>()\nmay restore the values of other registers in addition to the\nstack pointer and program counter. Consequently, the values\nof automatic variables are unspecified after a call to\n<b>longjmp</b>() if they meet all the following\ncriteria:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>they are local to the function that made the\ncorresponding <b>setjmp</b>() call;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>their values are changed between the calls to\n<b>setjmp</b>() and <b>longjmp</b>(); and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>they are not declared as <i>volatile</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Analogous\nremarks apply for <b>siglongjmp</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Nonlocal\ngotos and program readability</b> <br>\nWhile it can be abused, the traditional C &quot;goto&quot;\nstatement at least has the benefit that lexical cues (the\ngoto statement and the target label) allow the programmer to\neasily perceive the flow of control. Nonlocal gotos provide\nno such cues: multiple <b>setjmp</b>() calls might employ\nthe same <i>jmp_buf</i> variable so that the content of the\nvariable may change over the lifetime of the application.\nConsequently, the programmer may be forced to perform\ndetailed reading of the code to determine the dynamic target\nof a particular <b>longjmp</b>() call. (To make the\nprogrammer&rsquo;s life easier, each <b>setjmp</b>() call\nshould employ a unique <i>jmp_buf</i> variable.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Adding further\ndifficulty, the <b>setjmp</b>() and <b>longjmp</b>() calls\nmay not even be in the same source code module.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In summary,\nnonlocal gotos can make programs harder to understand and\nmaintain, and an alternative should be used if possible.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Caveats</b>\n<br>\nIf the function which called <b>setjmp</b>() returns before\n<b>longjmp</b>() is called, the behavior is undefined. Some\nkind of subtle or unsubtle chaos is sure to result.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If, in a\nmultithreaded program, a <b>longjmp</b>() call employs an\n<i>env</i> buffer that was initialized by a call to\n<b>setjmp</b>() in a different thread, the behavior is\nundefined.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">POSIX.1-2008\nTechnical Corrigendum 2 adds <b>longjmp</b>() and\n<b>siglongjmp</b>() to the list of async-signal-safe\nfunctions. However, the standard recommends avoiding the use\nof these functions from signal handlers and goes on to point\nout that if these functions are called from a signal handler\nthat interrupted a call to a non-async-signal-safe function\n(or some equivalent, such as the steps equivalent to\n<a href=\"https://man.page/3/exit\">exit(3)</a> that occur upon a return from the initial\ncall to <i>main</i>()), the behavior is undefined if the\nprogram subsequently makes a call to a non-async-signal-safe\nfunction. The only way of avoiding undefined behavior is to\nensure one of the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p style=\"margin-top: 1em\">After long jumping from the\nsignal handler, the program does not call any\nnon-async-signal-safe functions and does not return from the\ninitial call to <i>main</i>().</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"85%\">\n\n\n<p>Any signal whose handler performs a long jump must be\nblocked during <i>every</i> call to a non-async-signal-safe\nfunction and no non-async-signal-safe functions are called\nafter returning from the initial call to <i>main</i>().</p></td></tr>\n</table>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/7/signal\">signal(7)</a>,\n<a href=\"https://man.page/7/signal-safety\">signal-safety(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}