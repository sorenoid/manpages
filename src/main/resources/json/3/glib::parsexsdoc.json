{"name":"glib::parsexsdoc","description":"Glib::ParseXSDoc\n- Parse POD and XSub declarations from XS files.\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\nThis is the\nheart of an automatic <small>API</small> reference\ndocumentation system for XS-based Perl modules.\n<small>FIXME</small> more info here!!\n\n\n<small>FIXME</small>\ndocument recognized <small>POD</small> directives and the\noutput data structures\n\n<h2>FUNCTIONS\n<a name=\"FUNCTIONS\"></a>\n</h2>\n\n\nxsdocparse\n(@filenames)\n\n<p style=\"margin-left:17%;\">Parse xs files for xsub\nsignatures and pod. Writes to standard output a data\nstructure suitable for eval&rsquo;ing in another Perl\nscript, describing all the stuff found. The output contains\nthree variables: <br>\n$xspods = <small>ARRAYREF</small>\n\n<p style=\"margin-left:23%;\">array of pods found in the\nverbatim C portion of the <small>XS</small> file, listed in\nthe order found. These are assumed to pertain to the\n<small>XS/C</small> api, not the Perl api. Any &quot;=for\napidoc&quot; paragraphs following an &quot;=object&quot;\nparagraphs in the verbatim sections are stripped (as are the\n&quot;=object&quot; paragraphs), and will appear instead in\n&quot;$data-&gt;{$package}{pods}&quot;.\n\n<p style=\"margin-left:17%;\">$data =\n<small>HASHREF</small>\n\n<p style=\"margin-left:23%;\">big hash keyed by package name\n(as found in the <small>MODULE</small> line), containing\nunder each key a hash with all the xsubs and pods in that\npackage, in the order found. Packages are consolidated\nacross multiple files.\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>FYI,</small>\nthis creates a new parser and calls &quot;parse_file&quot;\non it for each input filename; then calls\n&quot;swizzle_pods&quot; to ensure that any &quot;=for\napidoc name&quot; pods are matched up with their target\nxsubs; and finally calls Data::Dumper to write the data to\nstdout. So, if you want to get finer control over how the\noutput is created, or keep all the data in-process, now you\nknow how. :-)\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n\n$Glib::ParseXSDoc::verbose\n\n<p style=\"margin-left:17%;\">If true, this causes the parser\nto be verbose.\n\n<p style=\"margin-left:11%;\">$parser =\nGlib::ParseXSDoc-&gt;new\n\n<p style=\"margin-left:17%;\">Create a new xsub parser.\n\n<p style=\"margin-left:11%;\">string =\n$parser-&gt;package\n\n<p style=\"margin-left:17%;\">Get the current package name.\nFalls back to the module name. Will be undef if the parser\nhasn&rsquo;t reached the first <small>MODULE</small>\nline.\n\n<p style=\"margin-left:11%;\"><small>HASHREF</small> =\n$parser-&gt;pkgdata\n\n<p style=\"margin-left:17%;\">The data hash corresponding to\nthe current package, honoring the most recently encountered\n&quot;=for object&quot; directive. Ensures that it exists.\nReturns a reference to the member of the main data\nstructure, so modifications are permanent and useful.\n\n<p style=\"margin-left:11%;\">$parser-&gt;parse_file\n(filename)\n\n<p style=\"margin-left:17%;\">Parse one xs file. Stores all\nthe collected data in <i>$parser</i>&rsquo;s internal data\nstructures.\n\n<p style=\"margin-left:11%;\">$parser-&gt;swizzle_pods\n\n<p style=\"margin-left:17%;\">Match &quot;=for apidoc&quot;\npods to xsubs.\n\n\n<p style=\"margin-left:11%;\">$parser-&gt;preprocess_pods\n\n<p style=\"margin-left:17%;\">Honor the &quot;__hide__&quot;\nand &quot;__function__&quot; directives in &quot;=for\napidoc&quot; lines.\n\n<p style=\"margin-left:17%; margin-top: 1em\">We look for the\nstrings anywhere, but you&rsquo;ll typically have it at the\nend of the line, e.g.:\n\n<p style=\"margin-left:17%; margin-top: 1em\">=for apidoc\nsymname __hide__ for detached blocks <br>\n=for apidoc __hide__ for attached blocks <br>\n=for apidoc symname __function__ for functions rather than\nmethods <br>\n=for apidoc __function__ for functions rather than\nmethods\n\n<p style=\"margin-left:11%;\">bool =\n$parser-&gt;is_module_line ($line)\n\n<p style=\"margin-left:17%;\">Analyze <i>$line</i> to see if\nit contains an <small>XS MODULE</small> directive. If so,\nreturns true after setting the <i>$parser</i>&rsquo;s\n<i>module</i>, <i>package</i>, and <i>prefix</i>\naccordingly.\n\n<p style=\"margin-left:11%;\">$pod =\n$parser-&gt;slurp_pod_paragraph ($firstline, <br>\n$term_regex=/^=cut\\s*/)\n\n<p style=\"margin-left:17%;\">Slurp up <small>POD</small>\nlines from <i>$filehandle</i> from here to the next\n<i>$term_regex</i> or <small>EOF.</small> Since you probably\nalready read a line to determine that we needed to start a\npod, you can pass that first line to be included.\n\n<p style=\"margin-left:11%;\">$xsub = $parser-&gt;parse_xsub\n(\\@lines) <br>\n$xsub = $parser-&gt;parse_xsub (@lines)\n\n<p style=\"margin-left:17%;\">Parse an xsub header, in the\nform of a list of lines, into a data structure describing\nthe xsub. That includes pulling out the argument types,\naliases, and code type.\n\n<p style=\"margin-left:17%; margin-top: 1em\">Without\nartificial intelligence, we cannot reliably determine\nanything about the types or number of parameters returned\nfrom xsubs with <small>PPCODE</small> bodies.\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>OUTLIST</small>\nparameters are pulled from the args list and put into an\n&quot;outlist&quot; key. <small>IN_OUTLIST</small>\nparameters are put into both.\n\n<p style=\"margin-left:17%; margin-top: 1em\">Data type names\nare not mangled at all.\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\nmethod can take either a list of lines or a reference to a\nlist of lines. The flat list form is provided for\ncompatibility; the reference form is preferred, to avoid\nduplicating a potentially large list of strings.\n\n\n<p style=\"margin-left:11%;\">$parser-&gt;clean_out_empty_pods\n\n<p style=\"margin-left:17%;\">Looks through the data member\nof the parser and removes any keys (and associated values)\nwhen no pod, enums, and xsubs exist for the package.\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\nmuppet\n&lt;scott at asofyet dot org&gt;\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\nCopyright (C)\n2003, 2004 by muppet\n\nThis library is\nfree software; you can redistribute it and/or modify it\nunder the terms of the <small>GNU</small> Library General\nPublic License as published by the Free Software Foundation;\neither version 2.1 of the License, or (at your option) any\nlater version.\n\nThis library is\ndistributed in the hope that it will be useful, but\n<small>WITHOUT ANY WARRANTY</small> ; without even the\nimplied warranty of <small>MERCHANTABILITY</small> or\n<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the\n<small>GNU</small> Library General Public License for more\ndetails.\n\nYou should have\nreceived a copy of the <small>GNU</small> Library General\nPublic License along with this library; if not, write to the\nFree Software Foundation, Inc., 51 Franklin Street, Fifth\nFloor, Boston, <small>MA 02110-1301 USA.</small>","body":"\n\n<h1 align=\"center\">Glib::ParseXSDoc</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glib::ParseXSDoc\n- Parse POD and XSub declarations from XS files.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is the\nheart of an automatic <small>API</small> reference\ndocumentation system for XS-based Perl modules.\n<small>FIXME</small> more info here!!</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>FIXME</small>\ndocument recognized <small>POD</small> directives and the\noutput data structures</p>\n\n<h2>FUNCTIONS\n<a name=\"FUNCTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">xsdocparse\n(@filenames)</p>\n\n<p style=\"margin-left:17%;\">Parse xs files for xsub\nsignatures and pod. Writes to standard output a data\nstructure suitable for eval&rsquo;ing in another Perl\nscript, describing all the stuff found. The output contains\nthree variables: <br>\n$xspods = <small>ARRAYREF</small></p>\n\n<p style=\"margin-left:23%;\">array of pods found in the\nverbatim C portion of the <small>XS</small> file, listed in\nthe order found. These are assumed to pertain to the\n<small>XS/C</small> api, not the Perl api. Any &quot;=for\napidoc&quot; paragraphs following an &quot;=object&quot;\nparagraphs in the verbatim sections are stripped (as are the\n&quot;=object&quot; paragraphs), and will appear instead in\n&quot;$data-&gt;{$package}{pods}&quot;.</p>\n\n<p style=\"margin-left:17%;\">$data =\n<small>HASHREF</small></p>\n\n<p style=\"margin-left:23%;\">big hash keyed by package name\n(as found in the <small>MODULE</small> line), containing\nunder each key a hash with all the xsubs and pods in that\npackage, in the order found. Packages are consolidated\nacross multiple files.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>FYI,</small>\nthis creates a new parser and calls &quot;parse_file&quot;\non it for each input filename; then calls\n&quot;swizzle_pods&quot; to ensure that any &quot;=for\napidoc name&quot; pods are matched up with their target\nxsubs; and finally calls Data::Dumper to write the data to\nstdout. So, if you want to get finer control over how the\noutput is created, or keep all the data in-process, now you\nknow how. :-)</p>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">$Glib::ParseXSDoc::verbose</p>\n\n<p style=\"margin-left:17%;\">If true, this causes the parser\nto be verbose.</p>\n\n<p style=\"margin-left:11%;\">$parser =\nGlib::ParseXSDoc-&gt;new</p>\n\n<p style=\"margin-left:17%;\">Create a new xsub parser.</p>\n\n<p style=\"margin-left:11%;\">string =\n$parser-&gt;package</p>\n\n<p style=\"margin-left:17%;\">Get the current package name.\nFalls back to the module name. Will be undef if the parser\nhasn&rsquo;t reached the first <small>MODULE</small>\nline.</p>\n\n<p style=\"margin-left:11%;\"><small>HASHREF</small> =\n$parser-&gt;pkgdata</p>\n\n<p style=\"margin-left:17%;\">The data hash corresponding to\nthe current package, honoring the most recently encountered\n&quot;=for object&quot; directive. Ensures that it exists.\nReturns a reference to the member of the main data\nstructure, so modifications are permanent and useful.</p>\n\n<p style=\"margin-left:11%;\">$parser-&gt;parse_file\n(filename)</p>\n\n<p style=\"margin-left:17%;\">Parse one xs file. Stores all\nthe collected data in <i>$parser</i>&rsquo;s internal data\nstructures.</p>\n\n<p style=\"margin-left:11%;\">$parser-&gt;swizzle_pods</p>\n\n<p style=\"margin-left:17%;\">Match &quot;=for apidoc&quot;\npods to xsubs.</p>\n\n\n<p style=\"margin-left:11%;\">$parser-&gt;preprocess_pods</p>\n\n<p style=\"margin-left:17%;\">Honor the &quot;__hide__&quot;\nand &quot;__function__&quot; directives in &quot;=for\napidoc&quot; lines.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">We look for the\nstrings anywhere, but you&rsquo;ll typically have it at the\nend of the line, e.g.:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">=for apidoc\nsymname __hide__ for detached blocks <br>\n=for apidoc __hide__ for attached blocks <br>\n=for apidoc symname __function__ for functions rather than\nmethods <br>\n=for apidoc __function__ for functions rather than\nmethods</p>\n\n<p style=\"margin-left:11%;\">bool =\n$parser-&gt;is_module_line ($line)</p>\n\n<p style=\"margin-left:17%;\">Analyze <i>$line</i> to see if\nit contains an <small>XS MODULE</small> directive. If so,\nreturns true after setting the <i>$parser</i>&rsquo;s\n<i>module</i>, <i>package</i>, and <i>prefix</i>\naccordingly.</p>\n\n<p style=\"margin-left:11%;\">$pod =\n$parser-&gt;slurp_pod_paragraph ($firstline, <br>\n$term_regex=/^=cut\\s*/)</p>\n\n<p style=\"margin-left:17%;\">Slurp up <small>POD</small>\nlines from <i>$filehandle</i> from here to the next\n<i>$term_regex</i> or <small>EOF.</small> Since you probably\nalready read a line to determine that we needed to start a\npod, you can pass that first line to be included.</p>\n\n<p style=\"margin-left:11%;\">$xsub = $parser-&gt;parse_xsub\n(\\@lines) <br>\n$xsub = $parser-&gt;parse_xsub (@lines)</p>\n\n<p style=\"margin-left:17%;\">Parse an xsub header, in the\nform of a list of lines, into a data structure describing\nthe xsub. That includes pulling out the argument types,\naliases, and code type.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Without\nartificial intelligence, we cannot reliably determine\nanything about the types or number of parameters returned\nfrom xsubs with <small>PPCODE</small> bodies.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>OUTLIST</small>\nparameters are pulled from the args list and put into an\n&quot;outlist&quot; key. <small>IN_OUTLIST</small>\nparameters are put into both.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Data type names\nare not mangled at all.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\nmethod can take either a list of lines or a reference to a\nlist of lines. The flat list form is provided for\ncompatibility; the reference form is preferred, to avoid\nduplicating a potentially large list of strings.</p>\n\n\n<p style=\"margin-left:11%;\">$parser-&gt;clean_out_empty_pods</p>\n\n<p style=\"margin-left:17%;\">Looks through the data member\nof the parser and removes any keys (and associated values)\nwhen no pod, enums, and xsubs exist for the package.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">muppet\n&lt;scott at asofyet dot org&gt;</p>\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright (C)\n2003, 2004 by muppet</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the terms of the <small>GNU</small> Library General\nPublic License as published by the Free Software Foundation;\neither version 2.1 of the License, or (at your option) any\nlater version.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\ndistributed in the hope that it will be useful, but\n<small>WITHOUT ANY WARRANTY</small> ; without even the\nimplied warranty of <small>MERCHANTABILITY</small> or\n<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the\n<small>GNU</small> Library General Public License for more\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You should have\nreceived a copy of the <small>GNU</small> Library General\nPublic License along with this library; if not, write to the\nFree Software Foundation, Inc., 51 Franklin Street, Fifth\nFloor, Boston, <small>MA 02110-1301 USA.</small></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#FUNCTIONS\">FUNCTIONS</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT AND LICENSE\">COPYRIGHT AND LICENSE</a>"],"level":3}