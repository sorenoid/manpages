{"name":"io::html","description":"IO::HTML - Open\nan HTML file with automatic charset detection\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\nThis document\ndescribes version 1.004 of <small>IO::HTML,</small> released\nSeptember 26, 2020.","body":"\n\n<h1 align=\"center\">IO::HTML</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IO::HTML - Open\nan HTML file with automatic charset detection</p>\n\n<h2>VERSION\n<a name=\"VERSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This document\ndescribes version 1.004 of <small>IO::HTML,</small> released\nSeptember 26, 2020.</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use IO::HTML; #\nexports html_file by default <br>\nuse HTML::TreeBuilder; <br>\nmy $tree = HTML::TreeBuilder-&gt;new_from_file( <br>\nhtml_file('foo.html') <br>\n); <br>\n# Alternative interface: <br>\nopen(my $in, '&lt;:raw', 'bar.html'); <br>\nmy $encoding = IO::HTML::sniff_encoding($in,\n'bar.html');</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>IO::HTML</small>\nprovides an easy way to open a file containing\n<small>HTML</small> while automatically determining its\nencoding. It uses the <small>HTML5</small> encoding sniffing\nalgorithm specified in section 8.2.2.2 of the draft\nstandard.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The algorithm\nas implemented here is:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>If the file begins with a byte order mark indicating\n<small>UTF-16LE, UTF-16BE,</small> or <small>UTF-8,</small>\nthen that is the encoding.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>If the first $bytes_to_check bytes of the file contain a\n&quot;&lt;meta&gt;&quot; tag that indicates the charset, and\nEncode recognizes the specified charset name, then that is\nthe encoding. (This portion of the algorithm is implemented\nby &quot;find_charset_in&quot;.)</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;&lt;meta&gt;&quot; tag can be in one of two\nformats:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;meta\ncharset=&quot;...&quot;&gt; <br>\n&lt;meta http-equiv=&quot;Content-Type&quot;\ncontent=&quot;...charset=...&quot;&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The search is\ncase-insensitive, and the order of attributes within the tag\nis irrelevant. Any additional attributes of the tag are\nignored. The first matching tag with a recognized encoding\nends the search.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">3.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">If the first $bytes_to_check\nbytes of the file are valid <small>UTF-8</small> (with at\nleast 1 non-ASCII character), then the encoding is\n<small>UTF-8.</small></p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>If all else fails, use the default character encoding.\nThe <small>HTML5</small> standard suggests the default\nencoding should be locale dependent, but currently it is\nalways &quot;cp1252&quot; unless you set\n$IO::HTML::default_encoding to a different value. Note:\n&quot;sniff_encoding&quot; does not apply this step; only\n&quot;html_file&quot; does that.</p></td></tr>\n</table>\n\n<h2>SUBROUTINES\n<a name=\"SUBROUTINES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>html_file</b>\n<br>\n$filehandle = html_file($filename, \\%options);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\n(exported by default) is the primary entry point. It opens\nthe file specified by $filename for reading, uses\n&quot;sniff_encoding&quot; to find a suitable encoding\nlayer, and applies it. It also applies the &quot;:crlf&quot;\nlayer. If the file begins with a <small>BOM,</small> the\nfilehandle is positioned just after the\n<small>BOM.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The optional\nsecond argument is a hashref containing options. The\npossible keys are described under\n&quot;find_charset_in&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n&quot;sniff_encoding&quot; is unable to determine the\nencoding, it defaults to $IO::HTML::default_encoding, which\nis set to &quot;cp1252&quot; (a.k.a. Windows-1252) by\ndefault. According to the standard, the default should be\nlocale dependent, but that is not currently implemented.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It dies if the\nfile cannot be opened, or if &quot;sniff_encoding&quot;\ncannot determine the encoding and\n$IO::HTML::default_encoding has been set to\n&quot;undef&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>html_file_and_encoding</b>\n<br>\n($filehandle, $encoding, $bom) <br>\n= html_file_and_encoding($filename, \\%options);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\n(exported only by request) is just like\n&quot;html_file&quot;, but returns more information. In\naddition to the filehandle, it returns the name of the\nencoding used, and a flag indicating whether a byte order\nmark was found (if $bom is true, the file began with a\n<small>BOM</small> ). This may be useful if you want to\nwrite the file out again (especially in conjunction with the\n&quot;html_outfile&quot; function).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The optional\nsecond argument is a hashref containing options. The\npossible keys are described under\n&quot;find_charset_in&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It dies if the\nfile cannot be opened, or if &quot;sniff_encoding&quot;\ncannot determine the encoding and\n$IO::HTML::default_encoding has been set to\n&quot;undef&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The result of\ncalling &quot;html_file_and_encoding&quot; in scalar context\nis undefined (in the C sense of there is no guarantee what\nyou&rsquo;ll get).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>html_outfile</b>\n<br>\n$filehandle = html_outfile($filename, $encoding, $bom);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\n(exported only by request) opens $filename for output using\n$encoding, and writes a <small>BOM</small> to it if $bom is\ntrue. If $encoding is &quot;undef&quot;, it defaults to\n$IO::HTML::default_encoding. $encoding may be either an\nencoding name or an Encode::Encoding object.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It dies if the\nfile cannot be opened, or if both $encoding and\n$IO::HTML::default_encoding are &quot;undef&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>sniff_encoding</b>\n<br>\n($encoding, $bom) = sniff_encoding($filehandle, $filename,\n\\%options);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\n(exported only by request) runs the <small>HTML5</small>\nencoding sniffing algorithm on $filehandle (which must be\nseekable, and should have been opened in &quot;:raw&quot;\nmode). $filename is used only for error messages (if\nthere&rsquo;s a problem using the filehandle), and defaults\nto &quot;file&quot; if omitted. The optional third argument\nis a hashref containing options. The possible keys are\ndescribed under &quot;find_charset_in&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It returns\nPerl&rsquo;s canonical name for the encoding, which is not\nnecessarily the same as the <small>MIME</small> or\n<small>IANA</small> charset name. It returns\n&quot;undef&quot; if the encoding cannot be determined. $bom\nis true if the file began with a byte order mark. In scalar\ncontext, it returns only $encoding.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nfilehandle&rsquo;s position is restored to its original\nposition (normally the beginning of the file) unless $bom is\ntrue. In that case, the position is immediately after the\n<small>BOM.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Tip: If you\nwant to run &quot;sniff_encoding&quot; on a file\nyou&rsquo;ve already loaded into a string, open an in-memory\nfile on the string, and pass that handle:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">($encoding,\n$bom) = do { <br>\nopen(my $fh, '&lt;', \\$string); sniff_encoding($fh) <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(This only\nmakes sense if $string contains bytes, not characters.)</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>find_charset_in</b>\n<br>\n$encoding = find_charset_in($string_containing_HTML,\n\\%options);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\n(exported only by request) looks for charset information in\na &quot;&lt;meta&gt;&quot; tag in a possibly-incomplete\n<small>HTML</small> document using the &quot;two step&quot;\nalgorithm specified by <small>HTML5.</small> It does not\nlook for a <small>BOM.</small> The &quot;&lt;meta&gt;&quot;\ntag must begin within the first $IO::HTML::bytes_to_check\nbytes of the string.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It returns\nPerl&rsquo;s canonical name for the encoding, which is not\nnecessarily the same as the <small>MIME</small> or\n<small>IANA</small> charset name. It returns\n&quot;undef&quot; if no charset is specified or if the\nspecified charset is not recognized by the Encode\nmodule.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The optional\nsecond argument is a hashref containing options. The\nfollowing keys are recognized: <br>\n&quot;encoding&quot;</p>\n\n<p style=\"margin-left:17%;\">If true, return the\nEncode::Encoding object instead of its name. Defaults to\nfalse.</p>\n\n<p style=\"margin-left:11%;\">&quot;need_pragma&quot;</p>\n\n<p style=\"margin-left:17%;\">If true (the default), follow\nthe <small>HTML5</small> spec and examine the\n&quot;content&quot; attribute only of &quot;&lt;meta\nhttp-equiv=&quot;Content-Type&quot;&quot;. If set to 0,\nrelax the <small>HTML5</small> spec, and look for\n&quot;charset=&quot; in the &quot;content&quot; attribute of\n<i>every</i> meta tag.</p>\n\n<h2>EXPORTS\n<a name=\"EXPORTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nonly &quot;html_file&quot; is exported. Other functions may\nbe exported on request.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For people who\nprefer not to export functions, all functions beginning with\n&quot;html_&quot; have an alias without that prefix (e.g.\nyou can call &quot;IO::HTML::file(...)&quot; instead of\n&quot;IO::HTML::html_file(...)&quot;. These aliases are not\nexportable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nexport tags are available: <br>\n&quot;:all&quot;</p>\n\n<p style=\"margin-left:17%;\">All exportable functions.</p>\n\n<p style=\"margin-left:11%;\">&quot;:rw&quot;</p>\n\n<p style=\"margin-left:17%;\">&quot;html_file&quot;,\n&quot;html_file_and_encoding&quot;,\n&quot;html_outfile&quot;.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<small>HTML5</small> specification, section 8.2.2.2\nDetermining the character encoding:\n&lt;http://www.w3.org/TR/html5/syntax.html#determining-the-character-encoding&gt;</p>\n\n<h2>DIAGNOSTICS\n<a name=\"DIAGNOSTICS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;Could not\nread %s: %s&quot;</p>\n\n<p style=\"margin-left:17%;\">The specified file could not be\nread from for the reason specified by $!.</p>\n\n<p style=\"margin-left:11%;\">&quot;Could not seek %s:\n%s&quot;</p>\n\n<p style=\"margin-left:17%;\">The specified file could not be\nrewound for the reason specified by $!.</p>\n\n<p style=\"margin-left:11%;\">&quot;Failed to open %s:\n%s&quot;</p>\n\n<p style=\"margin-left:17%;\">The specified file could not be\nopened for reading for the reason specified by $!.</p>\n\n<p style=\"margin-left:11%;\">&quot;No default encoding\nspecified&quot;</p>\n\n<p style=\"margin-left:17%;\">The &quot;sniff_encoding&quot;\nalgorithm didn&rsquo;t find an encoding to use, and you set\n$IO::HTML::default_encoding to &quot;undef&quot;.</p>\n\n<h2>CONFIGURATION AND ENVIRONMENT\n<a name=\"CONFIGURATION AND ENVIRONMENT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are two\nglobal variables that affect <small>IO::HTML.</small> If you\nneed to change them, you should do so using\n&quot;local&quot; if possible:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $file = do {\n<br>\n# This file may define the charset later in the header <br>\nlocal $IO::HTML::bytes_to_check = 4096; <br>\nhtml_file(...); <br>\n}; <br>\n$bytes_to_check</p>\n\n<p style=\"margin-left:17%;\">This is the number of bytes\nthat &quot;sniff_encoding&quot; will read from the stream.\nIt is also the number of bytes that\n&quot;find_charset_in&quot; will search for a\n&quot;&lt;meta&gt;&quot; tag containing charset information.\nIt must be a positive integer.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The <small>HTML\n5</small> specification recommends using the default value\nof 1024, but some pages do not follow the specification.</p>\n\n<p style=\"margin-left:11%;\">$default_encoding</p>\n\n<p style=\"margin-left:17%;\">This is the encoding that\n&quot;html_file&quot; and &quot;html_file_and_encoding&quot;\nwill use if no encoding can be detected by\n&quot;sniff_encoding&quot;. The default value is\n&quot;cp1252&quot; (a.k.a. Windows-1252).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Setting it to\n&quot;undef&quot; will cause the file subroutines to croak\nif &quot;sniff_encoding&quot; fails to determine the\nencoding. (&quot;sniff_encoding&quot; itself does not use\n$default_encoding).</p>\n\n<h2>DEPENDENCIES\n<a name=\"DEPENDENCIES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>IO::HTML</small>\nhas no non-core dependencies for Perl 5.8.7+. With earlier\nversions of Perl 5.8, you need to upgrade Encode to at least\nversion 2.10, and you may need to upgrade Exporter to at\nleast version 5.57.</p>\n\n<h2>INCOMPATIBILITIES\n<a name=\"INCOMPATIBILITIES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">None\nreported.</p>\n\n<h2>BUGS AND LIMITATIONS\n<a name=\"BUGS AND LIMITATIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">No bugs have\nbeen reported.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Christopher J.\nMadsen\n&quot;&lt;perl&Acirc;&nbsp;AT&Acirc;&nbsp;cjmweb.net&gt;&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Please report\nany bugs or feature requests to\n&quot;&lt;bug-IO-HTML&Acirc;&nbsp;AT&Acirc;&nbsp;rt.cpan.org&gt;&quot;\nor through the web interface at\n&lt;http://rt.cpan.org/Public/Bug/Report.html?Queue=IO-HTML&gt;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can follow\nor contribute to IO-HTML&rsquo;s development at\n&lt;https://github.com/madsen/io-html&gt;.</p>\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This software\nis copyright (c) 2020 by Christopher J. Madsen.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is free\nsoftware; you can redistribute it and/or modify it under the\nsame terms as the Perl 5 programming language system\nitself.</p>\n\n<h2>DISCLAIMER OF WARRANTY\n<a name=\"DISCLAIMER OF WARRANTY\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>BECAUSE\nTHIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE\nCOPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE\n&quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER\nEXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND\nPERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE\nPROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY\nSERVICING, REPAIR, OR CORRECTION.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>IN NO\nEVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO\nMAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY\nTHE ABOVE LICENSE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING\nANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\nARISING OUT OF THE USE OR INABILITY TO USE THE\nSOFTWARE</small> ( <small>INCLUDING BUT NOT LIMITED TO LOSS\nOF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES\nSUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE\nSOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE</small> ),\n<small>EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.</small></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#VERSION\">VERSION</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SUBROUTINES\">SUBROUTINES</a>","<a href=\"#EXPORTS\">EXPORTS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#DIAGNOSTICS\">DIAGNOSTICS</a>","<a href=\"#CONFIGURATION AND ENVIRONMENT\">CONFIGURATION AND ENVIRONMENT</a>","<a href=\"#DEPENDENCIES\">DEPENDENCIES</a>","<a href=\"#INCOMPATIBILITIES\">INCOMPATIBILITIES</a>","<a href=\"#BUGS AND LIMITATIONS\">BUGS AND LIMITATIONS</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT AND LICENSE\">COPYRIGHT AND LICENSE</a>","<a href=\"#DISCLAIMER OF WARRANTY\">DISCLAIMER OF WARRANTY</a>"],"level":3}