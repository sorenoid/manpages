{"name":"slist","description":"slist(3) - linux command line manual","body":"\n\n<h1 align=\"center\">SLIST</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SLIST_EMPTY,\nSLIST_ENTRY, SLIST_FIRST, SLIST_FOREACH, SLIST_HEAD,\nSLIST_HEAD_INITIALIZER, SLIST_INIT, SLIST_INSERT_AFTER,\nSLIST_INSERT_HEAD, SLIST_NEXT, SLIST_REMOVE,\nSLIST_REMOVE_HEAD - implementation of a singly linked\nlist</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/queue.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nSLIST_EMPTY(SLIST_HEAD *</b><i>head</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SLIST_ENTRY(TYPE);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct TYPE\n*SLIST_FIRST(SLIST_HEAD *</b><i>head</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SLIST_FOREACH(struct\nTYPE *</b><i>var</i><b>, SLIST_HEAD *</b><i>head</i><b>,\nSLIST_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SLIST_HEAD(HEADNAME,\nTYPE);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SLIST_HEAD\nSLIST_HEAD_INITIALIZER(SLIST_HEAD</b>\n<i>head</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSLIST_INIT(SLIST_HEAD *</b><i>head</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSLIST_INSERT_AFTER(struct TYPE *</b><i>listelm</i><b>,\nstruct TYPE *</b><i>elm</i><b>, <br>\nSLIST_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSLIST_INSERT_HEAD(SLIST_HEAD *</b><i>head</i><b>, struct\nTYPE *</b><i>elm</i><b>, <br>\nSLIST_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct TYPE\n*SLIST_NEXT(struct TYPE *</b><i>elm</i><b>, SLIST_ENTRY</b>\n<i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSLIST_REMOVE(SLIST_HEAD *</b><i>head</i><b>, struct TYPE\n*</b><i>elm</i><b>, SLIST_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nSLIST_REMOVE_HEAD(SLIST_HEAD *</b><i>head</i><b>,\nSLIST_ENTRY</b> <i>NAME</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These macros\ndefine and operate on doubly linked lists.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the macro\ndefinitions, <i>TYPE</i> is the name of a user-defined\nstructure, that must contain a field of type\n<i>SLIST_ENTRY</i>, named <i>NAME</i>. The argument\n<i>HEADNAME</i> is the name of a user-defined structure that\nmust be declared using the macro <b>SLIST_HEAD</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A singly linked\nlist is headed by a structure defined by the\n<b>SLIST_HEAD</b>() macro. This structure contains a single\npointer to the first element on the list. The elements are\nsingly linked for minimum space and pointer manipulation\noverhead at the expense of O(n) removal for arbitrary\nelements. New elements can be added to the list after an\nexisting element or at the head of the list. An\n<i>SLIST_HEAD</i> structure is declared as follows:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">SLIST_HEAD(HEADNAME,\nTYPE) head;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where <i>struct\nHEADNAME</i> is the structure to be defined, and <i>struct\nTYPE</i> is the type of the elements to be linked into the\nlist. A pointer to the head of the list can later be\ndeclared as:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct HEADNAME\n*headp;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">(The names\n<i>head</i> and <i>headp</i> are user selectable.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_HEAD_INITIALIZER</b>() evaluates to an initializer\nfor the list <i>head</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_EMPTY</b>() evaluates to true if there are no\nelements in the list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_ENTRY</b>() declares a structure that connects the\nelements in the list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_FIRST</b>() returns the first element in the list\nor NULL if the list is empty.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_FOREACH</b>() traverses the list referenced by\n<i>head</i> in the forward direction, assigning each element\nin turn to <i>var</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_INIT</b>() initializes the list referenced by\n<i>head</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_INSERT_HEAD</b>() inserts the new element\n<i>elm</i> at the head of the list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_INSERT_AFTER</b>() inserts the new element\n<i>elm</i> after the element <i>listelm</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_NEXT</b>() returns the next element in the\nlist.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_REMOVE_HEAD</b>() removes the element <i>elm</i>\nfrom the head of the list. For optimum efficiency, elements\nbeing removed from the head of the list should explicitly\nuse this macro instead of the generic <i>SLIST_REMOVE</i>\nmacro.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_REMOVE</b>() removes the element <i>elm</i> from\nthe list.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SLIST_EMPTY</b>()\nreturns nonzero if the list is empty, and zero if the list\ncontains at least one entry.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SLIST_FIRST</b>(),\nand <b>SLIST_NEXT</b>() return a pointer to the first or\nnext <i>TYPE</i> structure, respectively.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SLIST_HEAD_INITIALIZER</b>()\nreturns an initializer that can be assigned to the list\n<i>head</i>.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Not in POSIX.1,\nPOSIX.1-2001 or POSIX.1-2008. Present on the BSDs (SLIST\nmacros first appeared in 4.4BSD).</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The macro\n<b>SLIST_FOREACH</b>() doesn&rsquo;t allow <i>var</i> to be\nremoved or freed within the loop, as it would interfere with\nthe traversal. The macro <b>SLIST_FOREACH_SAFE</b>(), which\nis present on the BSDs but is not present in glibc, fixes\nthis limitation by allowing <i>var</i> to safely be removed\nfrom the list and freed from within the loop without\ninterfering with the traversal.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;stddef.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;sys/queue.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">struct entry {\n<br>\nint data; <br>\nSLIST_ENTRY(entry) entries; /* Singly linked List. */ <br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SLIST_HEAD(slisthead,\nentry);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(void) <br>\n{ <br>\nstruct entry *n1, *n2, *n3, *np; <br>\nstruct slisthead head; /* Singly linked List <br>\nhead. */</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SLIST_INIT(&amp;head);\n/* Initialize the queue. */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n1 =\nmalloc(sizeof(struct entry)); /* Insert at the head. */ <br>\nSLIST_INSERT_HEAD(&amp;head, n1, entries);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n2 =\nmalloc(sizeof(struct entry)); /* Insert after. */ <br>\nSLIST_INSERT_AFTER(n1, n2, entries);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">SLIST_REMOVE(&amp;head,\nn2, entry, entries);/* Deletion. */ <br>\nfree(n2);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">n3 =\nSLIST_FIRST(&amp;head); <br>\nSLIST_REMOVE_HEAD(&amp;head, entries); /* Deletion from the\nhead. */ <br>\nfree(n3);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">for (int i = 0;\ni &lt; 5; i++) { <br>\nn1 = malloc(sizeof(struct entry)); <br>\nSLIST_INSERT_HEAD(&amp;head, n1, entries); <br>\nn1-&gt;data = i; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">/* Forward\ntraversal. */ <br>\nSLIST_FOREACH(np, &amp;head, entries) <br>\nprintf(&quot;%i\\n&quot;, np-&gt;data);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while\n(!SLIST_EMPTY(&amp;head)) { /* List Deletion. */ <br>\nn1 = SLIST_FIRST(&amp;head); <br>\nSLIST_REMOVE_HEAD(&amp;head, entries); <br>\nfree(n1); <br>\n} <br>\nSLIST_INIT(&amp;head);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/insque\">insque(3)</a>,\n<a href=\"https://man.page/7/queue\">queue(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}