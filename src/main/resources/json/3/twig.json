{"name":"twig","body":"\n\n<h1 align=\"center\">Twig</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Twig - A\nperl module for processing huge XML documents in tree\nmode.</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that this\ndocumentation is intended as a reference to the module.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Complete docs,\nincluding a tutorial, examples, an easier to use\n<small>HTML</small> version, a quick reference card and a\n<small>FAQ</small> are available at\n&lt;http://www.xmltwig.org/xmltwig&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Small documents\n(loaded in memory as a tree):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my\n$twig=XML::Twig-&gt;new(); # create the twig <br>\n$twig-&gt;parsefile( 'doc.xml'); # build it <br>\nmy_process( $twig); # use twig methods to process it <br>\n$twig-&gt;print; # output the twig</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Huge documents\n(processed in combined stream/tree mode):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># at most one\ndiv will be loaded in memory <br>\nmy $twig=XML::Twig-&gt;new( <br>\ntwig_handlers =&gt; <br>\n{ title =&gt; sub { $_-&gt;set_tag( 'h2') }, # change title\ntags to h2 <br>\n# $_ is the current element <br>\npara =&gt; sub { $_-&gt;set_tag( 'p') }, # change para to p\n<br>\nhidden =&gt; sub { $_-&gt;delete; }, # remove hidden\nelements <br>\nlist =&gt; \\&amp;my_list_process, # process list elements\n<br>\ndiv =&gt; sub { $_[0]-&gt;flush; }, # output and free memory\n<br>\n}, <br>\npretty_print =&gt; 'indented', # output will be nicely\nformatted <br>\nempty_tags =&gt; 'html', # outputs &lt;empty_tag /&gt; <br>\n); <br>\n$twig-&gt;parsefile( 'my_big.xml'); <br>\nsub my_list_process <br>\n{ my( $twig, $list)= @_; <br>\n# ... <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See XML::Twig\n101 for other ways to use the module, as a filter for\nexample.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\nprovides a way to process <small>XML</small> documents. It\nis build on top of &quot;XML::Parser&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The module\noffers a tree interface to the document, while allowing you\nto output the parts of it that have been completely\nprocessed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It allows\nminimal resource ( <small>CPU</small> and memory) usage by\nbuilding the tree only for the parts of the documents that\nneed actual processing, through the use of the\n&quot;twig_roots &quot; and &quot;twig_print_outside_roots\n&quot; options. The &quot;finish &quot; and\n&quot;finish_print &quot; methods also help to increase\nperformances.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Twig tries\nto make simple things easy so it tries its best to takes\ncare of a lot of the (usually) annoying (but sometimes\nnecessary) features that come with <small>XML</small> and\nXML::Parser.</p>\n\n<h2>TOOLS\n<a name=\"TOOLS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Twig comes\nwith a few command-line utilities:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>xml_pp - xml\npretty-printer</b> <small><br>\nXML</small> pretty printer using XML::Twig</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>xml_grep -\ngrep <small>XML</small> files looking for specific\nelements</b> <br>\n&quot;xml_grep&quot; does a grep on <small>XML</small>\nfiles. Instead of using regular expressions it uses XPath\nexpressions (in fact the subset of XPath supported by\nXML::Twig).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>xml_split -\ncut a big <small>XML</small> file into smaller chunks</b>\n<br>\n&quot;xml_split&quot; takes a (presumably big)\n<small>XML</small> file and split it in several smaller\nfiles, based on various criteria (level in the tree, size or\nan XPath expression)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>xml_merge -\nmerge back <small>XML</small> files split with xml_split</b>\n<br>\n&quot;xml_merge&quot; takes several xml files that have been\nsplit using &quot;xml_split&quot; and recreates a single\nfile.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>xml_spellcheck\n- spellcheck <small>XML</small> files</b> <br>\n&quot;xml_spellcheck&quot; lets you spell check the content\nof an <small>XML</small> file. It extracts the text (the\ncontent of elements and optionally of attributes), call a\nspell checker on it and then recreates the\n<small>XML</small> document.</p>\n\n<h2>XML::Twig 101\n<a name=\"XML::Twig 101\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Twig can\nbe used either on &quot;small&quot; <small>XML</small>\ndocuments (that fit in memory) or on huge ones, by\nprocessing parts of the document and outputting or\ndiscarding them once they are processed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Loading an\n<small>XML</small> document and processing it</b> <br>\nmy $t= XML::Twig-&gt;new(); <br>\n$t-&gt;parse(\n'&lt;d&gt;&lt;title&gt;title&lt;/title&gt;&lt;para&gt;p\n1&lt;/para&gt;&lt;para&gt;p 2&lt;/para&gt;&lt;/d&gt;'); <br>\nmy $root= $t-&gt;root; <br>\n$root-&gt;set_tag( 'html'); # change doc to html <br>\n$title= $root-&gt;first_child( 'title'); # get the title\n<br>\n$title-&gt;set_tag( 'h1'); # turn it into h1 <br>\nmy @para= $root-&gt;children( 'para'); # get the para\nchildren <br>\nforeach my $para (@para) <br>\n{ $para-&gt;set_tag( 'p'); } # turn them into p <br>\n$t-&gt;print; # output the document</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other useful\nmethods include:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">att:\n&quot;$elt-&gt;{'att'}-&gt;{'foo'}&quot; return the\n&quot;foo&quot; attribute for an element,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">set_att :\n&quot;$elt-&gt;set_att( foo =&gt; &quot;bar&quot;)&quot;\nsets the &quot;foo&quot; attribute to the &quot;bar&quot;\nvalue,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">next_sibling:\n&quot;$elt-&gt;{next_sibling}&quot; return the next sibling\nin the document (in the example\n&quot;$title-&gt;{next_sibling}&quot; is the first\n&quot;para&quot;, you can also (and actually should) use\n&quot;$elt-&gt;next_sibling( 'para')&quot; to get it</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The document\ncan also be transformed through the use of the cut, copy,\npaste and move methods: &quot;$title-&gt;cut;\n$title-&gt;paste( after =&gt; $p);&quot; for example</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">And much, much\nmore, see XML::Twig::Elt.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Processing\nan <small>XML</small> document chunk by chunk</b> <br>\nOne of the strengths of XML::Twig is that it let you work\nwith files that do not fit in memory ( <small>BTW</small>\nstoring an <small>XML</small> document in memory as a tree\nis quite memory-expensive, the expansion factor being often\naround 10).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To do this you\ncan define handlers, that will be called once a specific\nelement has been completely parsed. In these handlers you\ncan access the element and process it as you see fit, using\nthe navigation and the cut-n-paste methods, plus lots of\nconvenient ones like &quot;prefix &quot;. Once the element\nis completely processed you can then &quot;flush &quot; it,\nwhich will output it and free the memory. You can also\n&quot;purge &quot; it if you don&rsquo;t need to output it\n(if you are just extracting some data from the document for\nexample). The handler will be called again once the next\nrelevant element has been parsed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( twig_handlers =&gt; <br>\n{ section =&gt; \\&amp;section, <br>\npara =&gt; sub { $_-&gt;set_tag( 'p'); } <br>\n}, <br>\n); <br>\n$t-&gt;parsefile( 'doc.xml'); <br>\n# the handler is called once a section is completely parsed,\nie when <br>\n# the end tag for section is found, it receives the twig\nitself and <br>\n# the element (including all its sub-elements) as arguments\n<br>\nsub section <br>\n{ my( $t, $section)= @_; # arguments for all twig_handlers\n<br>\n$section-&gt;set_tag( 'div'); # change the tag name <br>\n# let's use the attribute nb as a prefix to the title <br>\nmy $title= $section-&gt;first_child( 'title'); # find the\ntitle <br>\nmy $nb= $title-&gt;{'att'}-&gt;{'nb'}; # get the attribute\n<br>\n$title-&gt;prefix( &quot;$nb - &quot;); # easy isn't it?\n<br>\n$section-&gt;flush; # outputs the section and frees memory\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is of\ncourse more to it: you can trigger handlers on more\nelaborate conditions than just the name of the element,\n&quot;section/title&quot; for example.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( twig_handlers =&gt; <br>\n{ 'section/title' =&gt; sub { $_-&gt;print } } <br>\n) <br>\n-&gt;parsefile( 'doc.xml');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here &quot;sub\n{ $_-&gt;print }&quot; simply prints the current element ($_\nis aliased to the element in the handler).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can also\ntrigger a handler on a test on an attribute:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( twig_handlers =&gt; <br>\n{ 'section[@level=&quot;1&quot;]' =&gt; sub { $_-&gt;print }\n} <br>\n); <br>\n-&gt;parsefile( 'doc.xml');</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can also\nuse &quot;start_tag_handlers &quot; to process an element as\nsoon as the start tag is found. Besides &quot;prefix &quot;\nyou can also use &quot;suffix &quot;,</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Processing\njust parts of an <small>XML</small> document</b> <br>\nThe twig_roots mode builds only the required sub-trees from\nthe document Anything outside of the twig roots will just be\nignored:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( <br>\n# the twig will include just the root and selected titles\n<br>\ntwig_roots =&gt; { 'section/title' =&gt;\n\\&amp;print_n_purge, <br>\n'annex/title' =&gt; \\&amp;print_n_purge <br>\n} <br>\n); <br>\n$t-&gt;parsefile( 'doc.xml'); <br>\nsub print_n_purge <br>\n{ my( $t, $elt)= @_; <br>\nprint $elt-&gt;text; # print the text (including sub-element\ntexts) <br>\n$t-&gt;purge; # frees the memory <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can use\nthat mode when you want to process parts of a documents but\nare not interested in the rest and you don&rsquo;t want to\npay the price, either in time or memory, to build the tree\nfor the it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Building an\n<small>XML</small> filter</b> <br>\nYou can combine the &quot;twig_roots&quot; and the\n&quot;twig_print_outside_roots&quot; options to build\nfilters, which let you modify selected elements and will\noutput the rest of the document as is.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This would\nconvert prices in $ to prices in Euro in a document:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( <br>\ntwig_roots =&gt; { 'price' =&gt; \\&amp;convert, }, # process\nprices <br>\ntwig_print_outside_roots =&gt; 1, # print the rest <br>\n); <br>\n$t-&gt;parsefile( 'doc.xml'); <br>\nsub convert <br>\n{ my( $t, $price)= @_; <br>\nmy $currency= $price-&gt;{'att'}-&gt;{'currency'}; # get the\ncurrency <br>\nif( $currency eq 'USD') <br>\n{ $usd_price= $price-&gt;text; # get the price <br>\n# %rate is just a conversion table <br>\nmy $euro_price= $usd_price * $rate{usd2euro}; <br>\n$price-&gt;set_text( $euro_price); # set the new price <br>\n$price-&gt;set_att( currency =&gt; 'EUR'); # don't forget\nthis! <br>\n} <br>\n$price-&gt;print; # output the price <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig\nand various versions of Perl, XML::Parser and expat:</b>\n<br>\nXML::Twig is a lot more sensitive to variations in versions\nof perl, XML::Parser and expat than to the\n<small>OS,</small> so this should cover some reasonable\nconfigurations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;recommended configuration&quot; is perl 5.8.3+ (for\ngood Unicode support), XML::Parser 2.31+ and expat\n1.95.5+</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n&lt;http://testers.cpan.org/search?request=dist&amp;dist=XML-Twig&gt;\nfor the <small>CPAN</small> testers reports on XML::Twig,\nwhich list all tested configurations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An Atom feed of\nthe <small>CPAN</small> Testers results is available at\n&lt;http://xmltwig.org/rss/twig_testers.rss&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Finally: <br>\nXML::Twig does <b><small>NOT</small></b> work with expat\n1.95.4 <br>\nXML::Twig only works with XML::Parser 2.27 in perl 5.6.*</p>\n\n<p style=\"margin-left:17%;\">Note that I can&rsquo;t compile\nXML::Parser 2.27 anymore, so I can&rsquo;t guarantee that it\nstill works</p>\n\n<p style=\"margin-left:11%;\">XML::Parser 2.28 does not\nreally work</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When in doubt,\nupgrade expat, XML::Parser and Scalar::Util</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Finally, for\nsome optional features, XML::Twig depends on some additional\nmodules. The complete list, which depends somewhat on the\nversion of Perl that you are running, is given by running\n&quot;t/zz_dump_config.t&quot;</p>\n\n<h2>Simplifying XML processing\n<a name=\"Simplifying XML processing\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Whitespaces</p>\n\n<p style=\"margin-left:17%;\">Whitespaces that look\nnon-significant are discarded, this behaviour can be\ncontrolled using the &quot;keep_spaces &quot;,\n&quot;keep_spaces_in &quot; and &quot;discard_spaces_in\n&quot; options.</p>\n\n<p style=\"margin-left:11%;\">Encoding</p>\n\n<p style=\"margin-left:17%;\">You can specify that you want\nthe output in the same encoding as the input (provided you\nhave valid <small>XML,</small> which means you have to\nspecify the encoding either in the document or when you\ncreate the Twig object) using the &quot;keep_encoding &quot;\noption</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can also\nuse &quot;output_encoding&quot; to convert the internal\n<small>UTF-8</small> format to the required encoding.</p>\n\n<p style=\"margin-left:11%;\">Comments and Processing\nInstructions ( <small>PI</small> )</p>\n\n<p style=\"margin-left:17%;\">Comments and <small>PI</small>\n&rsquo;s can be hidden from the processing, but still appear\nin the output (they are carried by the &quot;real&quot;\nelement closer to them)</p>\n\n<p style=\"margin-left:11%;\">Pretty Printing</p>\n\n<p style=\"margin-left:17%;\">XML::Twig can output the\ndocument pretty printed so it is easier to read for us\nhumans.</p>\n\n<p style=\"margin-left:11%;\">Surviving an untimely death</p>\n\n<p style=\"margin-left:17%;\"><small>XML</small> parsers are\nsupposed to react violently when fed improper\n<small>XML.</small> XML::Parser just dies.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">XML::Twig\nprovides the &quot;safe_parse &quot; and the\n&quot;safe_parsefile &quot; methods which wrap the parse in\nan eval and return either the parsed twig or 0 in case of\nfailure.</p>\n\n<p style=\"margin-left:11%;\">Private attributes</p>\n\n<p style=\"margin-left:17%;\">Attributes with a name starting\nwith # (illegal in <small>XML</small> ) will not be output,\nso you can safely use them to store temporary values during\nprocessing. Note that you can store anything in a private\nattribute, not just text, it&rsquo;s just a regular Perl\nvariable, so a reference to an object or a huge data\nstructure is perfectly fine.</p>\n\n<h2>CLASSES\n<a name=\"CLASSES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Twig uses\na very limited number of classes. The ones you are most\nlikely to use are &quot;XML::Twig&quot; of course, which\nrepresents a complete <small>XML</small> document, including\nthe document itself (the root of the document itself is\n&quot;root&quot;), its handlers, its input or output\nfilters... The other main class is\n&quot;XML::Twig::Elt&quot;, which models an\n<small>XML</small> element. Element here has a very wide\ndefinition: it can be a regular element, or but also text,\nwith an element &quot;tag&quot; of &quot;#PCDATA&quot; (or\n&quot;#CDATA&quot;), an entity (tag is &quot;#ENT&quot;), a\nProcessing Instruction (&quot;#PI&quot;), a comment\n(&quot;#COMMENT&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Those are the 2\ncommonly used classes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You might want\nto look the &quot;elt_class&quot; option if you want to\nsubclass &quot;XML::Twig::Elt&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Attributes are\njust attached to their parent element, they are not objects\nper se. (Please use the provided methods &quot;att&quot; and\n&quot;set_att&quot; to access them, if you access them as a\nhash, then your code becomes implementation dependent and\nmight break in the future).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other classes\nthat are seldom used are &quot;XML::Twig::Entity_list&quot;\nand &quot;XML::Twig::Entity&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you use\n&quot;XML::Twig::XPath&quot; instead of\n&quot;XML::Twig&quot;, elements are then created as\n&quot;XML::Twig::XPath::Elt&quot;</p>\n\n<h2>METHODS\n<a name=\"METHODS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig</b>\n<br>\nA twig is a subclass of XML::Parser, so all XML::Parser\nmethods can be called on a twig object, including parse and\nparsefile. &quot;setHandlers&quot; on the other hand cannot\nbe used, see &quot;BUGS &quot;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>new</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>This is a class method, the constructor for XML::Twig.\nOptions are passed as keyword value pairs. Recognized\noptions are the same as XML::Parser, plus some (in fact a\nlot!) XML::Twig specifics.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">New Options:\n<br>\ntwig_handlers</p>\n\n<p style=\"margin-left:23%;\">This argument consists of a\nhash &quot;{ expression =&quot; \\&amp;handler}&gt; where\nexpression is a an <i>XPath-like expression</i> (+ some\nothers).</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">XPath\nexpressions are limited to using the child and descendant\naxis (indeed you can&rsquo;t specify an axis), and\npredicates cannot be nested. You can use the\n&quot;string&quot;, or &quot;string(&lt;tag&gt;)&quot;\nfunction (except in &quot;twig_roots&quot; triggers).</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Additionally\nyou can use regexps (/ delimited) to match attribute and\nstring values.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Examples:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">foo <br>\nfoo/bar <br>\nfoo//bar <br>\n/foo/bar <br>\n/foo//bar <br>\n/foo/bar[@att1 = &quot;val1&quot; and @att2 =\n&quot;val2&quot;]/baz[@a &gt;= 1] <br>\nfoo[string()=~ /^duh!+/] <br>\n/foo[string(bar)=~ /\\d+/]/baz[@att != 3]</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">#CDATA can be\nused to call a handler for a <small>CDATA</small> section.\n#COMMENT can be used to call a handler for comments</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Some additional\n(non-XPath) expressions are also provided for convenience:\n<br>\nprocessing instructions</p>\n\n<p style=\"margin-left:29%;\">'?' or '#PI' triggers the\nhandler for any processing instruction, and\n'?&lt;target&gt;' or '#PI &lt;target&gt;' triggers a handler\nfor processing instruction with the given target( ex: '#PI\nxml-stylesheet').</p>\n\n<p style=\"margin-left:23%;\">level(&lt;level&gt;)</p>\n\n<p style=\"margin-left:29%;\">Triggers the handler on any\nelement at that level in the tree (root is level 1)</p>\n\n<p style=\"margin-left:23%;\">_all_</p>\n\n<p style=\"margin-left:29%;\">Triggers the handler for\n<b>all</b> elements in the tree</p>\n\n<p style=\"margin-left:23%;\">_default_</p>\n\n<p style=\"margin-left:29%;\">Triggers the handler for each\nelement that does <small>NOT</small> have any other\nhandler.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Expressions are\nevaluated against the input document. Which means that even\nif you have changed the tag of an element (changing the tag\nof a parent element from a handler for example) the change\nwill not impact the expression evaluation. There is an\nexception to this: &quot;private&quot; attributes (which\nname start with a &rsquo;#&rsquo;, and can only be created\nduring the parsing, as they are not valid <small>XML</small>\n) are checked against the current twig.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Handlers are\ntriggered in fixed order, sorted by their type (xpath\nexpressions first, then regexps, then level), then by\nwhether they specify a full path (starting at the root\nelement) or not, then by number of steps in the expression,\nthen number of predicates, then number of tests in\npredicates. Handlers where the last step does not specify a\nstep (&quot;foo/bar/*&quot;) are triggered after other XPath\nhandlers. Finally &quot;_all_&quot; handlers are triggered\nlast.</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b>Important</b>:\nonce a handler has been triggered if it returns 0 then no\nother handler is called, except a &quot;_all_&quot; handler\nwhich will be called anyway.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If a handler\nreturns a true value and other handlers apply, then the next\napplicable handler will be called. Repeat, rinse, lather..;\nThe exception to that rule is when the\n&quot;do_not_chain_handlers&quot; option is set, in which\ncase only the first handler will be called.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note that it\nmight be a good idea to explicitly return a short true value\n(like 1) from handlers: this ensures that other applicable\nhandlers are called even if the last statement for the\nhandler happens to evaluate to false. This might also\nspeedup the code by avoiding the result of the last\nstatement of the code to be copied and passed to the code\nmanaging handlers. It can really pay to have 1 instead of a\nlong string returned.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">When the\nclosing tag for an element is parsed the corresponding\nhandler is called, with 2 arguments: the twig and the\n&quot;Element &quot;. The twig includes the document tree\nthat has been built so far, the element is the complete\nsub-tree for the element. <b>The fact that the handler is\ncalled only when the closing tag for the element is found\nmeans that handlers for inner elements are called before\nhandlers for outer elements</b>.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$_ is also set\nto the element, so it is easy to write inline handlers\nlike</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">para =&gt; sub\n{ $_-&gt;set_tag( 'p'); }</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Text is stored\nin elements whose tag name is #PCDATA (due to mixed content,\ntext and sub-element in an element there is no way to store\nthe text as just an attribute of the enclosing element, this\nis similar to the <small>DOM</small> model).</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b>Warning</b>:\nif you have used purge or flush on the twig the element\nmight not be complete, some of its children might have been\nentirely flushed or purged, and the start tag might even\nhave been printed (by &quot;flush&quot;) already, so\nchanging its tag might not give the expected result.</p>\n\n<p style=\"margin-left:17%;\">twig_roots</p>\n\n<p style=\"margin-left:23%;\">This argument lets you build\nthe tree only for those elements you are interested in.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Example: my $t=\nXML::Twig-&gt;new( twig_roots =&gt; { title =&gt; 1,\nsubtitle =&gt; 1}); <br>\n$t-&gt;parsefile( file); <br>\nmy $t= XML::Twig-&gt;new( twig_roots =&gt; { 'section/title'\n=&gt; 1}); <br>\n$t-&gt;parsefile( file);</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">return a twig\ncontaining a document including only &quot;title&quot; and\n&quot;subtitle&quot; elements, as children of the root\nelement.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">You can use\n<i>generic_attribute_condition</i>,\n<i>attribute_condition</i>, <i>full_path</i>,\n<i>partial_path</i>, <i>tag</i>, <i>tag_regexp</i>,\n<i>_default_</i> and <i>_all_</i> to trigger the building of\nthe twig. <i>string_condition</i> and\n<i>regexp_condition</i> cannot be used as the content of the\nelement, and the string, have not yet been parsed when the\ncondition is checked.</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b><small>WARNING</small></b>\n: path are checked for the document. Even if the\n&quot;twig_roots&quot; option is used they will be checked\nagainst the full document tree, not the virtual tree created\nby XML::Twig</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b><small>WARNING</small></b>\n: twig_roots elements should <small>NOT</small> be nested,\nthat would hopelessly confuse XML::Twig ;--(</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note: you can\nset handlers (twig_handlers) using twig_roots <br>\nExample: my $t= XML::Twig-&gt;new( twig_roots =&gt; <br>\n{ title =&gt; sub { $_[1]-&gt;print;}, <br>\nsubtitle =&gt; \\&amp;process_subtitle <br>\n} <br>\n); <br>\n$t-&gt;parsefile( file);</p>\n\n<p style=\"margin-left:17%;\">twig_print_outside_roots</p>\n\n<p style=\"margin-left:23%;\">To be used in conjunction with\nthe &quot;twig_roots&quot; argument. When set to a true\nvalue this will print the document outside of the\n&quot;twig_roots&quot; elements.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Example: my $t=\nXML::Twig-&gt;new( twig_roots =&gt; { title =&gt;\n\\&amp;number_title }, <br>\ntwig_print_outside_roots =&gt; 1, <br>\n); <br>\n$t-&gt;parsefile( file); <br>\n{ my $nb; <br>\nsub number_title <br>\n{ my( $twig, $title); <br>\n$nb++; <br>\n$title-&gt;prefix( &quot;$nb &quot;); <br>\n$title-&gt;print; <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This example\nprints the document outside of the title element, calls\n&quot;number_title&quot; for each &quot;title&quot; element,\nprints it, and then resumes printing the document. The twig\nis built only for the &quot;title&quot; elements.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If the value is\na reference to a file handle then the document outside the\n&quot;twig_roots&quot; elements will be output to this file\nhandle:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">open( my $out,\n'&gt;', 'out_file.xml') or die &quot;cannot open out\nfile.xml out_file:$!&quot;; <br>\nmy $t= XML::Twig-&gt;new( twig_roots =&gt; { title =&gt;\n\\&amp;number_title }, <br>\n# default output to $out <br>\ntwig_print_outside_roots =&gt; $out, <br>\n); <br>\n{ my $nb; <br>\nsub number_title <br>\n{ my( $twig, $title); <br>\n$nb++; <br>\n$title-&gt;prefix( &quot;$nb &quot;); <br>\n$title-&gt;print( $out); # you have to print to \\*OUT here\n<br>\n} <br>\n}</p>\n\n<p style=\"margin-left:17%;\">start_tag_handlers</p>\n\n<p style=\"margin-left:23%;\">A hash &quot;{ expression\n=&quot; \\&amp;handler}&gt;. Sets element handlers that are\ncalled when the element is open (at the end of the\nXML::Parser &quot;Start&quot; handler). The handlers are\ncalled with 2 params: the twig and the element. The element\nis empty at that point, its attributes are created\nthough.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">You can use\n<i>generic_attribute_condition</i>,\n<i>attribute_condition</i>, <i>full_path</i>,\n<i>partial_path</i>, <i>tag</i>, <i>tag_regexp</i>,\n<i>_default_</i> and <i>_all_</i> to trigger the\nhandler.</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><i>string_condition</i>\nand <i>regexp_condition</i> cannot be used as the content of\nthe element, and the string, have not yet been parsed when\nthe condition is checked.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The main uses\nfor those handlers are to change the tag name (you might\nhave to do it as soon as you find the open tag if you plan\nto &quot;flush&quot; the twig at some point in the element,\nand to create temporary attributes that will be used when\nprocessing sub-element with &quot;twig_hanlders&quot;.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b>Note</b>:\n&quot;start_tag&quot; handlers can be called outside of\n&quot;twig_roots&quot; if this argument is used. Since the\nelement object is not built, in this case handlers are\ncalled with the following arguments: $t (the twig), $tag\n(the tag of the element) and %att (a hash of the attributes\nof the element).</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If the\n&quot;twig_print_outside_roots&quot; argument is also used,\nif the last handler called returns a &quot;true&quot; value,\nthen the start tag will be output as it appeared in the\noriginal document, if the handler returns a\n&quot;false&quot; value then the start tag will <b>not</b>\nbe printed (so you can print a modified string yourself for\nexample).</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note that you\ncan use the ignore method in &quot;start_tag_handlers&quot;\n(and only there).</p>\n\n<p style=\"margin-left:17%;\">end_tag_handlers</p>\n\n<p style=\"margin-left:23%;\">A hash &quot;{ expression\n=&quot; \\&amp;handler}&gt;. Sets element handlers that are\ncalled when the element is closed (at the end of the\nXML::Parser &quot;End&quot; handler). The handlers are\ncalled with 2 params: the twig and the tag of the\nelement.</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><i>twig_handlers</i>\nare called when an element is completely parsed, so why have\nthis redundant option? There is only one use for\n&quot;end_tag_handlers&quot;: when using the\n&quot;twig_roots&quot; option, to trigger a handler for an\nelement <b>outside</b> the roots. It is for example very\nuseful to number titles in a document using nested\nsections:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">my @no= (0);\n<br>\nmy $no; <br>\nmy $t= XML::Twig-&gt;new( <br>\nstart_tag_handlers =&gt; <br>\n{ section =&gt; sub { $no[$#no]++; $no= join '.', @no; push\n@no, 0; } }, <br>\ntwig_roots =&gt; <br>\n{ title =&gt; sub { $_-&gt;prefix( $no); $_-&gt;print; } },\n<br>\nend_tag_handlers =&gt; { section =&gt; sub { pop @no; } },\n<br>\ntwig_print_outside_roots =&gt; 1 <br>\n); <br>\n$t-&gt;parsefile( $file);</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Using the\n&quot;end_tag_handlers&quot; argument without\n&quot;twig_roots&quot; will result in an error.</p>\n\n<p style=\"margin-left:17%;\">do_not_chain_handlers</p>\n\n<p style=\"margin-left:23%;\">If this option is set to a true\nvalue, then only one handler will be called for each\nelement, even if several satisfy the condition</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note that the\n&quot;_all_&quot; handler will still be called\nregardless</p>\n\n<p style=\"margin-left:17%;\">ignore_elts</p>\n\n<p style=\"margin-left:23%;\">This option lets you ignore\nelements when building the twig. This is useful in cases\nwhere you cannot use &quot;twig_roots&quot; to ignore\nelements, for example if the element to ignore is a sibling\nof elements you are interested in.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Example:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">my $twig=\nXML::Twig-&gt;new( ignore_elts =&gt; { elt =&gt; 'discard'\n}); <br>\n$twig-&gt;parsefile( 'doc.xml');</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This will build\nthe complete twig for the document, except that all\n&quot;elt&quot; elements (and their children) will be left\nout.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The keys in the\nhash are triggers, limited to the same subset as\n&quot;start_tag_handlers&quot;. The values can be\n&quot;discard&quot;, to discard the element,\n&quot;print&quot;, to output the element as-is,\n&quot;string&quot; to store the text of the ignored\nelement(s), including markup, in a field of the twig:\n&quot;$t-&gt;{twig_buffered_string}&quot; or a reference to\na scalar, in which case the text of the ignored element(s),\nincluding markup, will be stored in the scalar. Any other\nvalue will be treated as &quot;discard&quot;.</p>\n\n<p style=\"margin-left:17%;\">char_handler</p>\n\n<p style=\"margin-left:23%;\">A reference to a subroutine\nthat will be called every time &quot;PCDATA&quot; is\nfound.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The subroutine\nreceives the string as argument, and returns the modified\nstring:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"># WE WANT ALL\nSTRINGS IN UPPER CASE <br>\nsub my_char_handler <br>\n{ my( $text)= @_; <br>\n$text= uc( $text); <br>\nreturn $text; <br>\n}</p>\n\n<p style=\"margin-left:17%;\">elt_class</p>\n\n<p style=\"margin-left:23%;\">The name of a class used to\nstore elements. this class should inherit from\n&quot;XML::Twig::Elt&quot; (and by default it is\n&quot;XML::Twig::Elt&quot;). This option is used to subclass\nthe element class and extend it with new methods.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This option is\nneeded because during the parsing of the <small>XML,</small>\nelements are created by &quot;XML::Twig&quot;, without any\ncontrol from the user code.</p>\n\n<p style=\"margin-left:17%;\">keep_atts_order</p>\n\n<p style=\"margin-left:23%;\">Setting this option to a true\nvalue causes the attribute hash to be tied to a\n&quot;Tie::IxHash&quot; object. This means that\n&quot;Tie::IxHash&quot; needs to be installed for this\noption to be available. It also means that the hash keeps\nits order, so you will get the attributes in order. This\nallows outputting the attributes in the same order as they\nwere in the original document.</p>\n\n<p style=\"margin-left:17%;\">keep_encoding</p>\n\n<p style=\"margin-left:23%;\">This is a (slightly?) evil\noption: if the <small>XML</small> document is not\n<small>UTF-8</small> encoded and you want to keep it that\nway, then setting keep_encoding will use\nthe&quot;Expat&quot; original_string method for character,\nthus keeping the original encoding, as well as the original\nentities in the strings.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">See the\n&quot;t/test6.t&quot; test file to see what results you can\nexpect from the various encoding options.</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b><small>WARNING</small></b>\n: if the original encoding is multi-byte then attribute\nparsing will be <small>EXTREMELY</small> unsafe under any\nPerl before 5.6, as it uses regular expressions which do not\ndeal properly with multi-byte characters. You can specify an\nalternate function to parse the start tags with the\n&quot;parse_start_tag&quot; option (see below)</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b><small>WARNING</small></b>\n: this option is <small>NOT</small> used when parsing with\nXML::Parser non-blocking parser (&quot;parse_start&quot;,\n&quot;parse_more&quot;, &quot;parse_done&quot; methods)\nwhich you probably should not use with XML::Twig anyway as\nthey are totally untested!</p>\n\n<p style=\"margin-left:17%;\">output_encoding</p>\n\n<p style=\"margin-left:23%;\">This option generates an\noutput_filter using &quot;Encode&quot;,\n&quot;Text::Iconv&quot; or &quot;Unicode::Map8&quot; and\n&quot;Unicode::Strings&quot;, and sets the encoding in the\n<small>XML</small> declaration. This is the easiest way to\ndeal with encodings, if you need more sophisticated\nfeatures, look at &quot;output_filter&quot; below</p>\n\n<p style=\"margin-left:17%;\">output_filter</p>\n\n<p style=\"margin-left:23%;\">This option is used to convert\nthe character encoding of the output document. It is passed\neither a string corresponding to a predefined filter or a\nsubroutine reference. The filter will be called every time a\ndocument or element is processed by the &quot;print&quot;\nfunctions (&quot;print&quot;, &quot;sprint&quot;,\n&quot;flush&quot;).</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Pre-defined\nfilters: <br>\nlatin1</p>\n\n<p style=\"margin-left:29%;\">uses either &quot;Encode&quot;,\n&quot;Text::Iconv&quot; or &quot;Unicode::Map8&quot; and\n&quot;Unicode::String&quot; or a regexp (which works only\nwith XML::Parser 2.27), in this order, to convert all\ncharacters to <small>ISO-8859-15</small> (usually latin1 is\nsynonym to <small>ISO-8859-1,</small> but in practice it\nseems that <small>ISO-8859-15,</small> which includes the\neuro sign, is more useful and probably what most people\nwant).</p>\n\n<p style=\"margin-left:23%;\">html</p>\n\n<p style=\"margin-left:29%;\">does the same conversion as\n&quot;latin1&quot;, plus encodes entities using\n&quot;HTML::Entities&quot; (oddly enough you will need to\nhave HTML::Entities installed for it to be available). This\nshould only be used if the tags and attribute names\nthemselves are in US-ASCII, or they will be converted and\nthe output will not be valid <small>XML</small> any more</p>\n\n<p style=\"margin-left:23%;\">safe</p>\n\n<p style=\"margin-left:29%;\">converts the output to\n<small>ASCII</small> ( <small>US</small> ) only plus\n<i>character entities</i> (&quot;&amp;#nnn;&quot;) this\nshould be used only if the tags and attribute names\nthemselves are in US-ASCII, or they will be converted and\nthe output will not be valid <small>XML</small> any more</p>\n\n<p style=\"margin-left:23%;\">safe_hex</p>\n\n<p style=\"margin-left:29%;\">same as &quot;safe&quot; except\nthat the character entities are in hex\n(&quot;&amp;#xnnn;&quot;)</p>\n\n<p style=\"margin-left:23%;\">encode_convert ($encoding)</p>\n\n<p style=\"margin-left:29%;\">Return a subref that can be\nused to convert utf8 strings to $encoding). Uses\n&quot;Encode&quot;.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">my $conv =\nXML::Twig::encode_convert( 'latin1'); <br>\nmy $t = XML::Twig-&gt;new(output_filter =&gt; $conv);</p>\n\n<p style=\"margin-left:23%;\">iconv_convert ($encoding)</p>\n\n<p style=\"margin-left:29%;\">this function is used to create\na filter subroutine that will be used to convert the\ncharacters to the target encoding using\n&quot;Text::Iconv&quot; (which needs to be installed, look\nat the documentation for the module and for the\n&quot;iconv&quot; library to find out which encodings are\navailable on your system, &quot;iconv -l&quot; should give\nyou a list of available encodings)</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">my $conv =\nXML::Twig::iconv_convert( 'latin1'); <br>\nmy $t = XML::Twig-&gt;new(output_filter =&gt; $conv);</p>\n\n<p style=\"margin-left:23%;\">unicode_convert ($encoding)</p>\n\n<p style=\"margin-left:29%;\">this function is used to create\na filter subroutine that will be used to convert the\ncharacters to the target encoding using\n&quot;Unicode::Strings&quot; and &quot;Unicode::Map8&quot;\n(which need to be installed, look at the documentation for\nthe modules to find out which encodings are available on\nyour system)</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">my $conv =\nXML::Twig::unicode_convert( 'latin1'); <br>\nmy $t = XML::Twig-&gt;new(output_filter =&gt; $conv);</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The\n&quot;text&quot; and &quot;att&quot; methods do not use the\nfilter, so their result are always in unicode.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Those\npredeclared filters are based on subroutines that can be\nused by themselves (as &quot;XML::Twig::foo&quot;). <br>\nhtml_encode ($string)</p>\n\n<p style=\"margin-left:29%;\">Use &quot;HTML::Entities&quot;\nto encode a utf8 string</p>\n\n<p style=\"margin-left:23%;\">safe_encode ($string)</p>\n\n<p style=\"margin-left:29%;\">Use either a regexp (perl &lt;\n5.8) or &quot;Encode&quot; to encode non-ascii characters in\nthe string in &quot;&amp;#&lt;nnnn&gt;;&quot; format</p>\n\n<p style=\"margin-left:23%;\">safe_encode_hex ($string)</p>\n\n<p style=\"margin-left:29%;\">Use either a regexp (perl &lt;\n5.8) or &quot;Encode&quot; to encode non-ascii characters in\nthe string in &quot;&amp;#x&lt;nnnn&gt;;&quot; format</p>\n\n<p style=\"margin-left:23%;\">regexp2latin1 ($string)</p>\n\n<p style=\"margin-left:29%;\">Use a regexp to encode a utf8\nstring into latin 1 ( <small>ISO-8859-1</small> ). Does not\nwork with Perl 5.8.0!</p>\n\n<p style=\"margin-left:17%;\">output_text_filter</p>\n\n<p style=\"margin-left:23%;\">same as output_filter, except\nit doesn&rsquo;t apply to the brackets and quotes around\nattribute values. This is useful for all filters that could\nchange the tagging, basically anything that does not just\nchange the encoding of the output. &quot;html&quot;,\n&quot;safe&quot; and &quot;safe_hex&quot; are better used\nwith this option.</p>\n\n<p style=\"margin-left:17%;\">input_filter</p>\n\n<p style=\"margin-left:23%;\">This option is similar to\n&quot;output_filter&quot; except the filter is applied to\nthe characters before they are stored in the twig, at\nparsing time.</p>\n\n<p style=\"margin-left:17%;\">remove_cdata</p>\n\n<p style=\"margin-left:23%;\">Setting this option to a true\nvalue will force the twig to output <small>CDATA</small>\nsections as regular (escaped) <small>PCDATA</small></p>\n\n<p style=\"margin-left:17%;\">parse_start_tag</p>\n\n<p style=\"margin-left:23%;\">If you use the\n&quot;keep_encoding&quot; option then this option can be\nused to replace the default parsing function. You should\nprovide a coderef (a reference to a subroutine) as the\nargument, this subroutine takes the original tag (given by\nXML::Parser::Expat &quot;original_string()&quot; method) and\nreturns a tag and the attributes in a hash (or in a list\nattribute_name/attribute value).</p>\n\n<p style=\"margin-left:17%;\">no_xxe</p>\n\n<p style=\"margin-left:23%;\">prevents external entities to\nbe parsed.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This is a\nsecurity feature, in case the input <small>XML</small>\ncannot be trusted. With this option set to a true value\ndefining external entities in the document will cause the\nparse to fail.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This prevents\nan entity like &quot;&lt;!ENTITY xxe PUBLIC &quot;bar&quot;\n&quot;/etc/passwd&quot;&gt;&quot; to make the password fiel\navailable in the document.</p>\n\n<p style=\"margin-left:17%;\">expand_external_ents</p>\n\n<p style=\"margin-left:23%;\">When this option is used\nexternal entities (that are defined) are expanded when the\ndocument is output using &quot;print&quot; functions such as\n&quot;print &quot;, &quot;sprint &quot;, &quot;flush &quot;\nand &quot;xml_string &quot;. Note that in the twig the\nentity will be stored as an element with a tag\n&rsquo;&quot;#ENT&quot;&rsquo;, the entity will not be\nexpanded there, so you might want to process the entities\nbefore outputting it.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If an external\nentity is not available, then the parse will fail.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">A special case\nis when the value of this option is -1. In that case a\nmissing entity will not cause the parser to die, but its\n&quot;name&quot;, &quot;sysid&quot; and &quot;pubid&quot;\nwill be stored in the twig as\n&quot;$twig-&gt;{twig_missing_system_entities}&quot; (a\nreference to an array of hashes { name =&gt; &lt;name&gt;,\nsysid =&gt; &lt;sysid&gt;, pubid =&gt; &lt;pubid&gt; }).\nYes, this is a bit of a hack, but it&rsquo;s useful in some\ncases.</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b><small>WARNING</small></b>\n: setting expand_external_ents to 0 or -1 currently\ndoesn&rsquo;t work as expected; cf.\n&lt;https://rt.cpan.org/Public/Bug/Display.html?id=118097&gt;.\nTo completelty turn off expanding external entities use\n&quot;no_xxe&quot;.</p>\n\n<p style=\"margin-left:17%;\">no_xxe</p>\n\n<p style=\"margin-left:23%;\">If this argument is set to a\ntrue value, expanding of external entities is turned\noff.</p>\n\n<p style=\"margin-left:17%;\">load_DTD</p>\n\n<p style=\"margin-left:23%;\">If this argument is set to a\ntrue value, &quot;parse&quot; or &quot;parsefile&quot; on\nthe twig will load the <small>DTD</small> information. This\ninformation can then be accessed through the twig, in a\n&quot;DTD_handler&quot; for example. This will load even an\nexternal <small>DTD.</small></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Default and\nfixed values for attributes will also be filled, based on\nthe <small>DTD.</small></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note that to do\nthis the module will generate a temporary file in the\ncurrent directory. If this is a problem let me know and I\nwill add an option to specify an alternate directory.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">See &quot;\n<small>DTD</small> Handling&quot; for more information</p>\n\n<p style=\"margin-left:17%;\">DTD_base\n&lt;path_to_DTD_directory&gt;</p>\n\n<p style=\"margin-left:23%;\">If the <small>DTD</small> is in\na different directory, looks for it there, useful to make up\nsomewhat for the lack of catalog support in\n&quot;expat&quot;. You still need a <small>SYSTEM</small>\ndeclaration</p>\n\n<p style=\"margin-left:17%;\">DTD_handler</p>\n\n<p style=\"margin-left:23%;\">Set a handler that will be\ncalled once the doctype (and the <small>DTD</small> ) have\nbeen loaded, with 2 arguments, the twig and the\n<small>DTD.</small></p>\n\n<p style=\"margin-left:17%;\">no_prolog</p>\n\n<p style=\"margin-left:23%;\">Does not output a prolog (\n<small>XML</small> declaration and <small>DTD</small> )</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p>id</p></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>This optional argument gives the name of an attribute\nthat can be used as an <small>ID</small> in the document.\nElements whose <small>ID</small> is known can be accessed\nthrough the elt_id method. id defaults to &rsquo;id&rsquo;.\nSee &quot;BUGS &quot;</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%;\">discard_spaces</p>\n\n<p style=\"margin-left:23%;\">If this optional argument is\nset to a true value then spaces are discarded when they look\nnon-significant: strings containing only spaces and at least\none line feed are discarded. This argument is set to true by\ndefault.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The exact\nalgorithm to drop spaces is: strings including only spaces\n(perl \\s) and at least one \\n right before an open or close\ntag are dropped.</p>\n\n<p style=\"margin-left:17%;\">discard_all_spaces</p>\n\n<p style=\"margin-left:23%;\">If this argument is set to a\ntrue value, spaces are discarded more aggressively than with\n&quot;discard_spaces&quot;: strings not including a \\n are\nalso dropped. This option is appropriate for data-oriented\n<small>XML.</small></p>\n\n<p style=\"margin-left:17%;\">keep_spaces</p>\n\n<p style=\"margin-left:23%;\">If this optional argument is\nset to a true value then all spaces in the document are\nkept, and stored as &quot;PCDATA&quot;.</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b>Warning</b>:\nadding this option can result in changes in the twig\ngenerated: space that was previously discarded might end up\nin a new text element. see the difference by calling the\nfollowing code with 0 and 1 as arguments:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">perl\n-MXML::Twig -e'print XML::Twig-&gt;new( keep_spaces =&gt;\nshift)-&gt;parse( &quot;&lt;d&gt;\n\\n&lt;e/&gt;&lt;/d&gt;&quot;)-&gt;_dump'</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\">&quot;keep_spaces&quot;\nand &quot;discard_spaces&quot; cannot be both set.</p>\n\n<p style=\"margin-left:17%;\">discard_spaces_in</p>\n\n<p style=\"margin-left:23%;\">This argument sets\n&quot;keep_spaces&quot; to true but will cause the twig\nbuilder to discard spaces in the elements listed.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The syntax for\nusing this argument is:</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\">XML::Twig-&gt;new(\ndiscard_spaces_in =&gt; [ 'elt1', 'elt2']);</p>\n\n<p style=\"margin-left:17%;\">keep_spaces_in</p>\n\n<p style=\"margin-left:23%;\">This argument sets\n&quot;discard_spaces&quot; to true but will cause the twig\nbuilder to keep spaces in the elements listed.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The syntax for\nusing this argument is:</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\">XML::Twig-&gt;new(\nkeep_spaces_in =&gt; [ 'elt1', 'elt2']);</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><b>Warning</b>:\nadding this option can result in changes in the twig\ngenerated: space that was previously discarded might end up\nin a new text element.</p>\n\n<p style=\"margin-left:17%;\">pretty_print</p>\n\n<p style=\"margin-left:23%;\">Set the pretty print method,\namongst &rsquo;&quot;none&quot;&rsquo; (default),\n&rsquo;&quot;nsgmls&quot;&rsquo;,\n&rsquo;&quot;nice&quot;&rsquo;,\n&rsquo;&quot;indented&quot;&rsquo;,\n&rsquo;&quot;indented_c&quot;&rsquo;,\n&rsquo;&quot;indented_a&quot;&rsquo;,\n&rsquo;&quot;indented_close_tag&quot;&rsquo;,\n&rsquo;&quot;cvs&quot;&rsquo;,\n&rsquo;&quot;wrapped&quot;&rsquo;,\n&rsquo;&quot;record&quot;&rsquo; and\n&rsquo;&quot;record_c&quot;&rsquo;</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">pretty_print\nformats: <br>\nnone</p>\n\n<p style=\"margin-left:29%;\">The document is output as one\nling string, with no line breaks except those found within\ntext elements</p>\n\n<p style=\"margin-left:23%;\">nsgmls</p>\n\n<p style=\"margin-left:29%;\">Line breaks are inserted in\nsafe places: that is within tags, between a tag and an\nattribute, between attributes and before the &gt; at the end\nof a tag.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">This is quite\nugly but better than &quot;none&quot;, and it is very safe,\nthe document will still be valid (conforming to its\n<small>DTD</small> ).</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">This is how the\n<small>SGML</small> parser &quot;sgmls&quot; splits\ndocuments, hence the name.</p>\n\n<p style=\"margin-left:23%;\">nice</p>\n\n<p style=\"margin-left:29%;\">This option inserts line breaks\nbefore any tag that does not contain text (so element with\ntextual content are not broken as the \\n is the\nsignificant).</p>\n\n\n<p style=\"margin-left:29%; margin-top: 1em\"><b><small>WARNING</small></b>\n: this option leaves the document well-formed but might make\nit invalid (not conformant to its <small>DTD</small> ). If\nyou have elements declared as</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">&lt;!ELEMENT\nfoo (#PCDATA|bar)&gt;</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">then a\n&quot;foo&quot; element including a &quot;bar&quot; one will\nbe printed as</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">&lt;foo&gt;\n<br>\n&lt;bar&gt;bar is just pcdata&lt;/bar&gt; <br>\n&lt;/foo&gt;</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">This is\ninvalid, as the parser will take the line break after the\n&quot;foo&quot; tag as a sign that the element contains\n<small>PCDATA,</small> it will then die when it finds the\n&quot;bar&quot; tag. This may or may not be important for\nyou, but be aware of it!</p>\n\n<p style=\"margin-left:23%;\">indented</p>\n\n<p style=\"margin-left:29%;\">Same as &quot;nice&quot; (and\nwith the same warning) but indents elements according to\ntheir level</p>\n\n<p style=\"margin-left:23%;\">indented_c</p>\n\n<p style=\"margin-left:29%;\">Same as &quot;indented&quot;\nbut a little more compact: the closing tags are on the same\nline as the preceding text</p>\n\n<p style=\"margin-left:23%;\">indented_close_tag</p>\n\n<p style=\"margin-left:29%;\">Same as &quot;indented&quot;\nexcept that the closing tag is also indented, to line up\nwith the tags within the element</p>\n\n<p style=\"margin-left:23%;\">idented_a</p>\n\n<p style=\"margin-left:29%;\">This formats <small>XML</small>\nfiles in a line-oriented version control friendly way. The\nformat is described in &lt;http://tinyurl.com/2kwscq&gt;\n(that&rsquo;s an Oracle document with an insanely long\n<small>URL</small> ).</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">Note that to be\ntotaly conformant to the &quot;spec&quot;, the order of\nattributes should not be changed, so if they are not already\nin alphabetical order you will need to use the\n&quot;keep_atts_order&quot; option.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"23%\"></td>\n<td width=\"5%\">\n\n\n<p>cvs</p></td>\n<td width=\"1%\"></td>\n<td width=\"31%\">\n\n\n<p>Same as &quot;idented_a&quot;.</p></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%;\">wrapped</p>\n\n<p style=\"margin-left:29%;\">Same as &quot;indented_c&quot;\nbut lines are wrapped using Text::Wrap::wrap. The default\nlength for lines is the default for $Text::Wrap::columns,\nand can be changed by changing that variable.</p>\n\n<p style=\"margin-left:23%;\">record</p>\n\n<p style=\"margin-left:29%;\">This is a record-oriented\npretty print, that display data in records, one field per\nline (which looks a <small>LOT</small> like\n&quot;indented&quot;)</p>\n\n<p style=\"margin-left:23%;\">record_c</p>\n\n<p style=\"margin-left:29%;\">Stands for record compact, one\nrecord per line</p>\n\n<p style=\"margin-left:17%;\">empty_tags</p>\n\n<p style=\"margin-left:23%;\">Set the empty tag display style\n(&rsquo;&quot;normal&quot;&rsquo;,\n&rsquo;&quot;html&quot;&rsquo; or\n&rsquo;&quot;expand&quot;&rsquo;).</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\">&quot;normal&quot;\noutputs an empty tag &rsquo;&quot;&lt;tag/&gt;&quot;&rsquo;,\n&quot;html&quot; adds a space &rsquo;&quot;&lt;tag\n/&gt;&quot;&rsquo; for elements that can be empty in\n<small>XHTML</small> and &quot;expand&quot; outputs\n&rsquo;&quot;&lt;tag&gt;&lt;/tag&gt;&quot;&rsquo;</p>\n\n<p style=\"margin-left:17%;\">quote</p>\n\n<p style=\"margin-left:23%;\">Set the quote character for\nattributes (&rsquo;&quot;single&quot;&rsquo; or\n&rsquo;&quot;double&quot;&rsquo;).</p>\n\n<p style=\"margin-left:17%;\">escape_gt</p>\n\n<p style=\"margin-left:23%;\">By default XML::Twig does not\nescape the character &gt; in its output, as it is not\nmandated by the <small>XML</small> spec. With this option\non, &gt; will be replaced by &quot;&amp;gt;&quot;</p>\n\n<p style=\"margin-left:17%;\">comments</p>\n\n<p style=\"margin-left:23%;\">Set the way comments are\nprocessed: &rsquo;&quot;drop&quot;&rsquo; (default),\n&rsquo;&quot;keep&quot;&rsquo; or\n&rsquo;&quot;process&quot;&rsquo;</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Comments\nprocessing options: <br>\ndrop</p>\n\n<p style=\"margin-left:29%;\">drops the comments, they are\nnot read, nor printed to the output</p>\n\n<p style=\"margin-left:23%;\">keep</p>\n\n<p style=\"margin-left:29%;\">comments are loaded and will\nappear on the output, they are not accessible within the\ntwig and will not interfere with processing though</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\"><b>Note</b>:\ncomments in the middle of a text element such as</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">&lt;p&gt;text\n&lt;!-- comment --&gt; more text --&gt;&lt;/p&gt;</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">are kept at\ntheir original position in the text. Using &quot;print&quot;\nmethods like &quot;print&quot; or &quot;sprint&quot; will\nreturn the comments in the text. Using &quot;text&quot; or\n&quot;field&quot; on the other hand will not.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">Any use of\n&quot;set_pcdata&quot; on the &quot;#PCDATA&quot; element\n(directly or through other methods like\n&quot;set_content&quot;) will delete the comment(s).</p>\n\n<p style=\"margin-left:23%;\">process</p>\n\n<p style=\"margin-left:29%;\">comments are loaded in the twig\nand will be treated as regular elements (their\n&quot;tag&quot; is &quot;#COMMENT&quot;) this can interfere\nwith processing if you expect\n&quot;$elt-&gt;{first_child}&quot; to be an element but find\na comment there. Validation will not protect you from this\nas comments can happen anywhere. You can use\n&quot;$elt-&gt;first_child( 'tag')&quot; (which is a good\nhabit anyway) to get where you want.</p>\n\n<p style=\"margin-left:29%; margin-top: 1em\">Consider using\n&quot;process&quot; if you are outputting <small>SAX</small>\nevents from XML::Twig.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p>pi</p></td>\n<td width=\"3%\"></td>\n<td width=\"77%\">\n\n\n<p>Set the way processing instructions are processed:\n&rsquo;&quot;drop&quot;&rsquo;,\n&rsquo;&quot;keep&quot;&rsquo; (default) or\n&rsquo;&quot;process&quot;&rsquo;</p> </td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note that you\ncan also set <small>PI</small> handlers in the\n&quot;twig_handlers&quot; option:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">'?' =&gt;\n\\&amp;handler <br>\n'?target' =&gt; \\&amp;handler 2</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">The handlers\nwill be called with 2 parameters, the twig and the\n<small>PI</small> element if &quot;pi&quot; is set to\n&quot;process&quot;, and with 3, the twig, the target and\nthe data if &quot;pi&quot; is set to &quot;keep&quot;. Of\ncourse they will not be called if &quot;pi&quot; is set to\n&quot;drop&quot;.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If\n&quot;pi&quot; is set to &quot;keep&quot; the handler should\nreturn a string that will be used as-is as the\n<small>PI</small> text (it should look like &quot;&quot;\n&lt;?target data?&quot; &gt;&quot; or &rsquo;&rsquo; if you\nwant to remove the <small>PI</small> ),</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Only one\nhandler will be called, &quot;?target&quot; or &quot;?&quot;\nif no specific handler for that target is available.</p>\n\n<p style=\"margin-left:17%;\">map_xmlns</p>\n\n<p style=\"margin-left:23%;\">This option is passed a hashref\nthat maps uri&rsquo;s to prefixes. The prefixes in the\ndocument will be replaced by the ones in the map. The mapped\nprefixes can (actually have to) be used to trigger handlers,\nnavigate or query the document.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Here is an\nexample:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( map_xmlns =&gt;\n{'http://www.w3.org/2000/svg' =&gt; &quot;svg&quot;}, <br>\ntwig_handlers =&gt; <br>\n{ 'svg:circle' =&gt; sub { $_-&gt;set_att( r =&gt; 20) } },\n<br>\npretty_print =&gt; 'indented', <br>\n) <br>\n-&gt;parse( '&lt;doc\nxmlns:gr=&quot;http://www.w3.org/2000/svg&quot;&gt; <br>\n&lt;gr:circle cx=&quot;10&quot; cy=&quot;90&quot;\nr=&quot;10&quot;/&gt; <br>\n&lt;/doc&gt;' <br>\n) <br>\n-&gt;print;</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This will\noutput:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&lt;doc\nxmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt; <br>\n&lt;svg:circle cx=&quot;10&quot; cy=&quot;90&quot;\nr=&quot;20&quot;/&gt; <br>\n&lt;/doc&gt;</p>\n\n<p style=\"margin-left:17%;\">keep_original_prefix</p>\n\n<p style=\"margin-left:23%;\">When used with\n&quot;map_xmlns&quot; this option will make\n&quot;XML::Twig&quot; use the original namespace prefixes\nwhen outputting a document. The mapped prefix will still be\nused for triggering handlers and in navigation and query\nmethods.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( map_xmlns =&gt;\n{'http://www.w3.org/2000/svg' =&gt; &quot;svg&quot;}, <br>\ntwig_handlers =&gt; <br>\n{ 'svg:circle' =&gt; sub { $_-&gt;set_att( r =&gt; 20) } },\n<br>\nkeep_original_prefix =&gt; 1, <br>\npretty_print =&gt; 'indented', <br>\n) <br>\n-&gt;parse( '&lt;doc\nxmlns:gr=&quot;http://www.w3.org/2000/svg&quot;&gt; <br>\n&lt;gr:circle cx=&quot;10&quot; cy=&quot;90&quot;\nr=&quot;10&quot;/&gt; <br>\n&lt;/doc&gt;' <br>\n) <br>\n-&gt;print;</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This will\noutput:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&lt;doc\nxmlns:gr=&quot;http://www.w3.org/2000/svg&quot;&gt; <br>\n&lt;gr:circle cx=&quot;10&quot; cy=&quot;90&quot;\nr=&quot;20&quot;/&gt; <br>\n&lt;/doc&gt;</p>\n\n<p style=\"margin-left:17%;\">original_uri ($prefix)</p>\n\n<p style=\"margin-left:23%;\">called within a handler, this\nwill return the uri bound to the namespace prefix in the\noriginal document.</p>\n\n<p style=\"margin-left:17%;\">index ($arrayref or\n$hashref)</p>\n\n<p style=\"margin-left:23%;\">This option creates lists of\nspecific elements during the parsing of the\n<small>XML.</small> It takes a reference to either a list of\ntriggering expressions or to a hash name =&gt; expression,\nand for each one generates the list of elements that match\nthe expression. The list can be accessed through the\n&quot;index&quot; method.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">example:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"># using an\narray ref <br>\nmy $t= XML::Twig-&gt;new( index =&gt; [ 'div', 'table' ])\n<br>\n-&gt;parsefile( &quot;foo.xml&quot;); <br>\nmy $divs= $t-&gt;index( 'div'); <br>\nmy $first_div= $divs-&gt;[0]; <br>\nmy $last_table= $t-&gt;index( table =&gt; -1); <br>\n# using a hashref to name the indexes <br>\nmy $t= XML::Twig-&gt;new( index =&gt; { email =&gt;\n'a[@href=~/^ \\s*mailto:/]'}) <br>\n-&gt;parsefile( &quot;foo.xml&quot;); <br>\nmy $last_emails= $t-&gt;index( email =&gt; -1);</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Note that the\nindex is not maintained after the parsing. If elements are\ndeleted, renamed or otherwise hurt during processing, the\nindex is <small>NOT</small> updated. (changing the id\nelement <small>OTOH</small> will update the index)</p>\n\n<p style=\"margin-left:17%;\">att_accessors &lt;list of\nattribute names&gt;</p>\n\n<p style=\"margin-left:23%;\">creates methods that give\ndirect access to attribute:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( att_accessors =&gt; [ 'href', 'src'])\n<br>\n-&gt;parsefile( $file); <br>\nmy $first_href= $t-&gt;first_elt( 'img')-&gt;src; # same as\n-&gt;att( 'src') <br>\n$t-&gt;first_elt( 'img')-&gt;src( 'new_logo.png') # changes\nthe attribute value</p>\n\n<p style=\"margin-left:17%;\">elt_accessors</p>\n\n<p style=\"margin-left:23%;\">creates methods that give\ndirect access to the first child element (in scalar context)\nor the list of elements (in list context):</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">the list of\naccessors to create can be given 1 2 different ways: in an\narray, or in a hash alias =&gt; expression <br>\nmy $t= XML::Twig-&gt;new( elt_accessors =&gt; [\n&rsquo;head&rsquo;]) <br>\n-&gt;parsefile( $file); <br>\nmy $title_text= $t-&gt;root-&gt;head-&gt;field(\n&rsquo;title&rsquo;); <br>\n# same as $title_text= $t-&gt;root-&gt;first_child(\n&rsquo;head&rsquo;)-&gt;field( &rsquo;title&rsquo;);</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( elt_accessors =&gt; { warnings =&gt;\n'p[@class=&quot;warning&quot;]', d2 =&gt; 'div[2]'}, ) <br>\n-&gt;parsefile( $file); <br>\nmy $body= $t-&gt;first_elt( 'body'); <br>\nmy @warnings= $body-&gt;warnings; # same as\n$body-&gt;children( 'p[@class=&quot;warning&quot;]'); <br>\nmy $s2= $body-&gt;d2; # same as $body-&gt;first_child(\n'div[2]')</p>\n\n<p style=\"margin-left:17%;\">field_accessors</p>\n\n<p style=\"margin-left:23%;\">creates methods that give\ndirect access to the first child element text:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new( field_accessors =&gt; [ 'h1']) <br>\n-&gt;parsefile( $file); <br>\nmy $div_title_text= $t-&gt;first_elt( 'div')-&gt;title; <br>\n# same as $title_text= $t-&gt;first_elt( 'div')-&gt;field(\n'title');</p>\n\n<p style=\"margin-left:17%;\">use_tidy</p>\n\n<p style=\"margin-left:23%;\">set this option to use\nHTML::Tidy instead of HTML::TreeBuilder to convert\n<small>HTML</small> to <small>XML. HTML,</small> especially\nreal (real &quot;crap&quot;) <small>HTML</small> found in\nthe wild, so depending on the data, one module or the other\ndoes a better job at the conversion. Also, HTML::Tidy can be\na bit difficult to install, so XML::Twig offers both option.\n<small>TIMTOWTDI</small></p>\n\n<p style=\"margin-left:17%;\">output_html_doctype</p>\n\n<p style=\"margin-left:23%;\">when using HTML::TreeBuilder to\nconvert <small>HTML,</small> this option causes the\n<small>DOCTYPE</small> declaration to be output, which may\nbe important for some legacy browsers. Without that option\nthe <small>DOCTYPE</small> definition is <small>NOT</small>\noutput. Also if the definition is completely wrong (ie not\neasily parsable), it is not output either.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>Note</b>: I\n_HATE_ the Java-like name of arguments used by most\n<small>XML</small> modules. So in pure\n<small>TIMTOWTDI</small> fashion all arguments can be\nwritten either as &quot;UglyJavaLikeName&quot; or as\n&quot;readable_perl_name&quot;:\n&quot;twig_print_outside_roots&quot; or\n&quot;TwigPrintOutsideRoots&quot; (or even\n&quot;twigPrintOutsideRoots&quot; {shudder}). XML::Twig\nnormalizes them before processing them.</p>\n\n<p style=\"margin-left:11%;\">parse ( $source)</p>\n\n<p style=\"margin-left:17%;\">The $source parameter should\neither be a string containing the whole <small>XML</small>\ndocument, or it should be an open &quot;IO::Handle&quot;\n(aka a filehandle).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A die call is\nthrown if a parse error occurs. Otherwise it will return the\ntwig built by the parse. Use &quot;safe_parse&quot; if you\nwant the parsing to return even when an error occurs.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If this method\nis called as a class method (&quot;XML::Twig-&gt;parse(\n$some_xml_or_html)&quot;) then an XML::Twig object is\ncreated, using the parameters except the last one (eg\n&quot;XML::Twig-&gt;parse( pretty_print =&gt; 'indented',\n$some_xml_or_html)&quot;) and &quot;xparse&quot; is called\non it.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that when\nparsing a filehandle, the handle should <small>NOT</small>\nbe open with an encoding (ie open with &quot;open( my $in,\n'&lt;', $filename)&quot;. The file will be parsed by\n&quot;expat&quot;, so specifying the encoding actually\ncauses problems for the parser (as in: it can crash it, see\nhttps://rt.cpan.org/Ticket/Display.html?id=78877). For\nparsing a file it is actually recommended to use\n&quot;parsefile&quot; on the file name, instead of\n&lt;parse&gt; on the open file.</p>\n\n<p style=\"margin-left:11%;\">parsestring</p>\n\n<p style=\"margin-left:17%;\">This is just an alias for\n&quot;parse&quot; for backwards compatibility.</p>\n\n<p style=\"margin-left:11%;\">parsefile ( <small>FILE</small>\n[, <small>OPT</small> =&gt; <small>OPT_VALUE</small>\n[...]])</p>\n\n<p style=\"margin-left:17%;\">Open &quot;FILE&quot; for\nreading, then call &quot;parse&quot; with the open handle.\nThe file is closed no matter how &quot;parse&quot;\nreturns.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A\n&quot;die&quot; call is thrown if a parse error occurs.\nOtherwise it will return the twig built by the parse. Use\n&quot;safe_parsefile&quot; if you want the parsing to return\neven when an error occurs.</p>\n\n<p style=\"margin-left:11%;\">parsefile_inplace ( $file,\n$optional_extension)</p>\n\n<p style=\"margin-left:17%;\">Parse and update a file\n&quot;in place&quot;. It does this by creating a temp file,\nselecting it as the default for <b>print()</b> statements\n(and methods), then parsing the input file. If the parsing\nis successful, then the temp file is moved to replace the\ninput file.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If an extension\nis given then the original file is backed-up (the rules for\nthe extension are the same as the rule for the -i option in\nperl).</p>\n\n<p style=\"margin-left:11%;\">parsefile_html_inplace ( $file,\n$optional_extension)</p>\n\n<p style=\"margin-left:17%;\">Same as parsefile_inplace,\nexcept that it parses <small>HTML</small> instead of\n<small>XML</small></p>\n\n<p style=\"margin-left:11%;\">parseurl ($url\n$optional_user_agent)</p>\n\n<p style=\"margin-left:17%;\">Gets the data from $url and\nparse it. The data is piped to the parser in chunks the size\nof the XML::Parser::Expat buffer, so memory consumption and\nhopefully speed are optimal.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For most (read\n&quot;small&quot;) <small>XML</small> it is probably as\nefficient (and easier to debug) to just &quot;get&quot; the\n<small>XML</small> file and then parse it as a string.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">use XML::Twig;\n<br>\nuse LWP::Simple; <br>\nmy $twig= XML::Twig-&gt;new(); <br>\n$twig-&gt;parse( LWP::Simple::get( $URL ));</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">or</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">use XML::Twig;\n<br>\nmy $twig= XML::Twig-&gt;nparse( $URL);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the\n$optional_user_agent argument is used then it is used,\notherwise a new one is created.</p>\n\n<p style=\"margin-left:11%;\">safe_parse (\n<small>SOURCE</small> [, <small>OPT</small> =&gt;\n<small>OPT_VALUE</small> [...]])</p>\n\n<p style=\"margin-left:17%;\">This method is similar to\n&quot;parse&quot; except that it wraps the parsing in an\n&quot;eval&quot; block. It returns the twig on success and 0\non failure (the twig object also contains the parsed twig).\n$@ contains the error message on failure.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\nparsing still stops as soon as an error is detected, there\nis no way to keep going after an error.</p>\n\n<p style=\"margin-left:11%;\">safe_parsefile (\n<small>FILE</small> [, <small>OPT</small> =&gt;\n<small>OPT_VALUE</small> [...]])</p>\n\n<p style=\"margin-left:17%;\">This method is similar to\n&quot;parsefile&quot; except that it wraps the parsing in an\n&quot;eval&quot; block. It returns the twig on success and 0\non failure (the twig object also contains the parsed twig) .\n$@ contains the error message on failure</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\nparsing still stops as soon as an error is detected, there\nis no way to keep going after an error.</p>\n\n<p style=\"margin-left:11%;\">safe_parseurl ($url\n$optional_user_agent)</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;parseurl&quot;\nexcept that it wraps the parsing in an &quot;eval&quot;\nblock. It returns the twig on success and 0 on failure (the\ntwig object also contains the parsed twig) . $@ contains the\nerror message on failure</p>\n\n<p style=\"margin-left:11%;\">parse_html ($string_or_fh)</p>\n\n<p style=\"margin-left:17%;\">parse an <small>HTML</small>\nstring or file handle (by converting it to\n<small>XML</small> using HTML::TreeBuilder, which needs to\nbe available).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This works\nnicely, but some information gets lost in the process:\nnewlines are removed, and (at least on the version I use),\ncomments get an extra <small>CDATA</small> section inside (\n&lt;!-- foo --&gt; becomes &lt;!-- &lt;![CDATA[ foo ]]&gt;\n--&gt;</p>\n\n<p style=\"margin-left:11%;\">parsefile_html ($file)</p>\n\n<p style=\"margin-left:17%;\">parse an <small>HTML</small>\nfile (by converting it to <small>XML</small> using\nHTML::TreeBuilder, which needs to be available, or\nHTML::Tidy if the &quot;use_tidy&quot; option was used). The\nfile is loaded completely in memory and converted to\n<small>XML</small> before being parsed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">this method is\nto be used with caution though, as it doesn&rsquo;t know\nabout the file encoding, it is usually better to use\n&quot;parse_html&quot;, which gives you a chance to open the\nfile with the proper encoding layer.</p>\n\n<p style=\"margin-left:11%;\">parseurl_html ($url\n$optional_user_agent)</p>\n\n<p style=\"margin-left:17%;\">parse an <small>URL</small> as\nhtml the same way &quot;parse_html&quot; does</p>\n\n<p style=\"margin-left:11%;\">safe_parseurl_html ($url\n$optional_user_agent)</p>\n\n<p style=\"margin-left:17%;\">Same as\n&quot;parseurl_html&quot;&gt; except that it wraps the\nparsing in an &quot;eval&quot; block. It returns the twig on\nsuccess and 0 on failure (the twig object also contains the\nparsed twig) . $@ contains the error message on failure</p>\n\n<p style=\"margin-left:11%;\">safe_parsefile_html ($file\n$optional_user_agent)</p>\n\n<p style=\"margin-left:17%;\">Same as\n&quot;parsefile_html&quot;&gt; except that it wraps the\nparsing in an &quot;eval&quot; block. It returns the twig on\nsuccess and 0 on failure (the twig object also contains the\nparsed twig) . $@ contains the error message on failure</p>\n\n<p style=\"margin-left:11%;\">safe_parse_html\n($string_or_fh)</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;parse_html&quot;\nexcept that it wraps the parsing in an &quot;eval&quot;\nblock. It returns the twig on success and 0 on failure (the\ntwig object also contains the parsed twig) . $@ contains the\nerror message on failure</p>\n\n<p style=\"margin-left:11%;\">xparse ($thing_to_parse)</p>\n\n<p style=\"margin-left:17%;\">parse the $thing_to_parse,\nwhether it is a filehandle, a string, an <small>HTML</small>\nfile, an <small>HTML URL,</small> an <small>URL</small> or a\nfile.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that this\nis mostly a convenience method for one-off scripts. For\nexample files that end in &rsquo;.htm&rsquo; or\n&rsquo;.html&rsquo; are parsed first as <small>XML,</small>\nand if this fails as <small>HTML.</small> This is certainly\nnot the most efficient way to do this in general.</p>\n\n<p style=\"margin-left:11%;\">nparse ($optional_twig_options,\n$thing_to_parse)</p>\n\n<p style=\"margin-left:17%;\">create a twig with the\n$optional_options, and parse the $thing_to_parse, whether it\nis a filehandle, a string, an <small>HTML</small> file, an\n<small>HTML URL,</small> an <small>URL</small> or a\nfile.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Examples:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">XML::Twig-&gt;nparse(\n&quot;file.xml&quot;); <br>\nXML::Twig-&gt;nparse( error_context =&gt; 1,\n&quot;file://file.xml&quot;);</p>\n\n<p style=\"margin-left:11%;\">nparse_pp\n($optional_twig_options, $thing_to_parse)</p>\n\n<p style=\"margin-left:17%;\">same as &quot;nparse&quot; but\nalso sets the &quot;pretty_print&quot; option to\n&quot;indented&quot;.</p>\n\n<p style=\"margin-left:11%;\">nparse_e\n($optional_twig_options, $thing_to_parse)</p>\n\n<p style=\"margin-left:17%;\">same as &quot;nparse&quot; but\nalso sets the &quot;error_context&quot; option to 1.</p>\n\n<p style=\"margin-left:11%;\">nparse_ppe\n($optional_twig_options, $thing_to_parse)</p>\n\n<p style=\"margin-left:17%;\">same as &quot;nparse&quot; but\nalso sets the &quot;pretty_print&quot; option to\n&quot;indented&quot; and the &quot;error_context&quot;\noption to 1.</p>\n\n<p style=\"margin-left:11%;\">parser</p>\n\n<p style=\"margin-left:17%;\">This method returns the\n&quot;expat&quot; object (actually the XML::Parser::Expat\nobject) used during parsing. It is useful for example to\ncall XML::Parser::Expat methods on it. To get the line of a\ntag for example use\n&quot;$t-&gt;parser-&gt;current_line&quot;.</p>\n\n<p style=\"margin-left:11%;\">setTwigHandlers ($handlers)</p>\n\n<p style=\"margin-left:17%;\">Set the twig_handlers.\n$handlers is a reference to a hash similar to the one in the\n&quot;twig_handlers&quot; option of new. All previous\nhandlers are unset. The method returns the reference to the\nprevious handlers.</p>\n\n<p style=\"margin-left:11%;\">setTwigHandler ($exp\n$handler)</p>\n\n<p style=\"margin-left:17%;\">Set a single twig_handler for\nelements matching $exp. $handler is a reference to a\nsubroutine. If the handler was previously set then the\nreference to the previous handler is returned.</p>\n\n<p style=\"margin-left:11%;\">setStartTagHandlers\n($handlers)</p>\n\n<p style=\"margin-left:17%;\">Set the start_tag handlers.\n$handlers is a reference to a hash similar to the one in the\n&quot;start_tag_handlers&quot; option of new. All previous\nhandlers are unset. The method returns the reference to the\nprevious handlers.</p>\n\n<p style=\"margin-left:11%;\">setStartTagHandler ($exp\n$handler)</p>\n\n<p style=\"margin-left:17%;\">Set a single start_tag handlers\nfor elements matching $exp. $handler is a reference to a\nsubroutine. If the handler was previously set then the\nreference to the previous handler is returned.</p>\n\n<p style=\"margin-left:11%;\">setEndTagHandlers\n($handlers)</p>\n\n<p style=\"margin-left:17%;\">Set the end_tag handlers.\n$handlers is a reference to a hash similar to the one in the\n&quot;end_tag_handlers&quot; option of new. All previous\nhandlers are unset. The method returns the reference to the\nprevious handlers.</p>\n\n<p style=\"margin-left:11%;\">setEndTagHandler ($exp\n$handler)</p>\n\n<p style=\"margin-left:17%;\">Set a single end_tag handlers\nfor elements matching $exp. $handler is a reference to a\nsubroutine. If the handler was previously set then the\nreference to the previous handler is returned.</p>\n\n<p style=\"margin-left:11%;\">setTwigRoots ($handlers)</p>\n\n<p style=\"margin-left:17%;\">Same as using the\n&quot;twig_roots&quot; option when creating the twig</p>\n\n<p style=\"margin-left:11%;\">setCharHandler ($exp\n$handler)</p>\n\n<p style=\"margin-left:17%;\">Set a\n&quot;char_handler&quot;</p>\n\n<p style=\"margin-left:11%;\">setIgnoreEltsHandler ($exp)</p>\n\n<p style=\"margin-left:17%;\">Set a &quot;ignore_elt&quot;\nhandler (elements that match $exp will be ignored</p>\n\n<p style=\"margin-left:11%;\">setIgnoreEltsHandlers\n($exp)</p>\n\n<p style=\"margin-left:17%;\">Set all &quot;ignore_elt&quot;\nhandlers (previous handlers are replaced)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>dtd</p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Return the dtd (an XML::Twig::DTD object) of a twig</p></td>\n<td width=\"5%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">xmldecl</p>\n\n<p style=\"margin-left:17%;\">Return the <small>XML</small>\ndeclaration for the document, or a default one if it\ndoesn&rsquo;t have one</p>\n\n<p style=\"margin-left:11%;\">doctype</p>\n\n<p style=\"margin-left:17%;\">Return the doctype for the\ndocument</p>\n\n<p style=\"margin-left:11%;\">doctype_name</p>\n\n<p style=\"margin-left:17%;\">returns the doctype of the\ndocument from the doctype declaration</p>\n\n<p style=\"margin-left:11%;\">system_id</p>\n\n<p style=\"margin-left:17%;\">returns the system value of the\n<small>DTD</small> of the document from the doctype\ndeclaration</p>\n\n<p style=\"margin-left:11%;\">public_id</p>\n\n<p style=\"margin-left:17%;\">returns the public doctype of\nthe document from the doctype declaration</p>\n\n<p style=\"margin-left:11%;\">internal_subset</p>\n\n<p style=\"margin-left:17%;\">returns the internal subset of\nthe <small>DTD</small></p>\n\n<p style=\"margin-left:11%;\">dtd_text</p>\n\n<p style=\"margin-left:17%;\">Return the <small>DTD</small>\ntext</p>\n\n<p style=\"margin-left:11%;\">dtd_print</p>\n\n<p style=\"margin-left:17%;\">Print the\n<small>DTD</small></p>\n\n<p style=\"margin-left:11%;\">model ($tag)</p>\n\n<p style=\"margin-left:17%;\">Return the model (in the\n<small>DTD</small> ) for the element $tag</p>\n\n<p style=\"margin-left:11%;\">root</p>\n\n<p style=\"margin-left:17%;\">Return the root element of a\ntwig</p>\n\n<p style=\"margin-left:11%;\">set_root ($elt)</p>\n\n<p style=\"margin-left:17%;\">Set the root of a twig</p>\n\n<p style=\"margin-left:11%;\">first_elt\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the first element\nmatching $optional_condition of a twig, if no condition is\ngiven then the root is returned</p>\n\n<p style=\"margin-left:11%;\">last_elt\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the last element\nmatching $optional_condition of a twig, if no condition is\ngiven then the last element of the twig is returned</p>\n\n<p style=\"margin-left:11%;\">elt_id ($id)</p>\n\n<p style=\"margin-left:17%;\">Return the element whose\n&quot;id&quot; attribute is $id</p>\n\n<p style=\"margin-left:11%;\">getEltById</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;elt_id&quot;</p>\n\n<p style=\"margin-left:11%;\">index ($index_name,\n$optional_index)</p>\n\n<p style=\"margin-left:17%;\">If the $optional_index argument\nis present, return the corresponding element in the index\n(created using the &quot;index&quot; option for\n&quot;XML::Twig-&quot;new&gt;)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the argument\nis not present, return an arrayref to the index</p>\n\n<p style=\"margin-left:11%;\">normalize</p>\n\n<p style=\"margin-left:17%;\">merge together all consecutive\npcdata elements in the document (if for example you have\nturned some elements into pcdata using &quot;erase&quot;,\nthis will give you a &quot;clean&quot; document in which\nthere all text elements are as long as possible).</p>\n\n<p style=\"margin-left:11%;\">encoding</p>\n\n<p style=\"margin-left:17%;\">This method returns the\nencoding of the <small>XML</small> document, as defined by\nthe &quot;encoding&quot; attribute in the <small>XML</small>\ndeclaration (ie it is &quot;undef&quot; if the attribute is\nnot defined)</p>\n\n<p style=\"margin-left:11%;\">set_encoding</p>\n\n<p style=\"margin-left:17%;\">This method sets the value of\nthe &quot;encoding&quot; attribute in the <small>XML</small>\ndeclaration. Note that if the document did not have a\ndeclaration it is generated (with an <small>XML</small>\nversion of 1.0)</p>\n\n<p style=\"margin-left:11%;\">xml_version</p>\n\n<p style=\"margin-left:17%;\">This method returns the\n<small>XML</small> version, as defined by the\n&quot;version&quot; attribute in the <small>XML</small>\ndeclaration (ie it is &quot;undef&quot; if the attribute is\nnot defined)</p>\n\n<p style=\"margin-left:11%;\">set_xml_version</p>\n\n<p style=\"margin-left:17%;\">This method sets the value of\nthe &quot;version&quot; attribute in the <small>XML</small>\ndeclaration. If the declaration did not exist it is\ncreated.</p>\n\n<p style=\"margin-left:11%;\">standalone</p>\n\n<p style=\"margin-left:17%;\">This method returns the value\nof the &quot;standalone&quot; declaration for the\ndocument</p>\n\n<p style=\"margin-left:11%;\">set_standalone</p>\n\n<p style=\"margin-left:17%;\">This method sets the value of\nthe &quot;standalone&quot; attribute in the\n<small>XML</small> declaration. Note that if the document\ndid not have a declaration it is generated (with an\n<small>XML</small> version of 1.0)</p>\n\n<p style=\"margin-left:11%;\">set_output_encoding</p>\n\n<p style=\"margin-left:17%;\">Set the &quot;encoding&quot;\n&quot;attribute&quot; in the <small>XML</small>\ndeclaration</p>\n\n<p style=\"margin-left:11%;\">set_doctype ($name, $system,\n$public, $internal)</p>\n\n<p style=\"margin-left:17%;\">Set the doctype of the element.\nIf an argument is &quot;undef&quot; (or not present) then\nits former value is retained, if a false (&rsquo;&rsquo; or\n0) value is passed then the former value is deleted;</p>\n\n<p style=\"margin-left:11%;\">entity_list</p>\n\n<p style=\"margin-left:17%;\">Return the entity list of a\ntwig</p>\n\n<p style=\"margin-left:11%;\">entity_names</p>\n\n<p style=\"margin-left:17%;\">Return the list of all defined\nentities</p>\n\n<p style=\"margin-left:11%;\">entity ($entity_name)</p>\n\n<p style=\"margin-left:17%;\">Return the entity</p>\n\n<p style=\"margin-left:11%;\">notation_list</p>\n\n<p style=\"margin-left:17%;\">Return the notation list of a\ntwig</p>\n\n<p style=\"margin-left:11%;\">notation_names</p>\n\n<p style=\"margin-left:17%;\">Return the list of all defined\nnotations</p>\n\n<p style=\"margin-left:11%;\">notation ($notation_name)</p>\n\n<p style=\"margin-left:17%;\">Return the notation</p>\n\n<p style=\"margin-left:11%;\">change_gi ($old_gi,\n$new_gi)</p>\n\n<p style=\"margin-left:17%;\">Performs a (very fast) global\nchange. All elements $old_gi are now $new_gi. This is a bit\ndangerous though and should be avoided if &lt; possible, as\nthe new tag might be ignored in subsequent processing.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See &quot;BUGS\n&quot;</p>\n\n<p style=\"margin-left:11%;\">flush ($optional_filehandle,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Flushes a twig up to (and\nincluding) the current element, then deletes all unnecessary\nelements from the tree that&rsquo;s kept in memory.\n&quot;flush&quot; keeps track of which elements need to be\nopen/closed, so if you flush from handlers you don&rsquo;t\nhave to worry about anything. Just keep flushing the twig\nevery time you&rsquo;re done with a sub-tree and it will\ncome out well-formed. After the whole parsing don&rsquo;t\nforget to&quot;flush&quot; one more time to print the end of\nthe document. The doctype and entity declarations are also\nprinted.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">flush take an\noptional filehandle as an argument.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you use\n&quot;flush&quot; at any point during parsing, the document\nwill be flushed one last time at the end of the parsing, to\nthe proper filehandle.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: use\nthe &quot;update_DTD&quot; option if you have updated the\n(internal) <small>DTD</small> and/or the entity list and you\nwant the updated <small>DTD</small> to be output</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&quot;pretty_print&quot; option sets the pretty printing of\nthe document.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Example:\n$t-&gt;flush( Update_DTD =&gt; 1); <br>\n$t-&gt;flush( $filehandle, pretty_print =&gt; 'indented');\n<br>\n$t-&gt;flush( \\*FILE);</p>\n\n<p style=\"margin-left:11%;\">flush_up_to ($elt,\n$optional_filehandle, %options)</p>\n\n<p style=\"margin-left:17%;\">Flushes up to the $elt element.\nThis allows you to keep part of the tree in memory when you\n&quot;flush&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\nflush.</p>\n\n<p style=\"margin-left:11%;\">purge</p>\n\n<p style=\"margin-left:17%;\">Does the same as a\n&quot;flush&quot; except it does not print the twig. It just\ndeletes all elements that have been completely parsed so\nfar.</p>\n\n<p style=\"margin-left:11%;\">purge_up_to ($elt)</p>\n\n<p style=\"margin-left:17%;\">Purges up to the $elt element.\nThis allows you to keep part of the tree in memory when you\n&quot;purge&quot;.</p>\n\n<p style=\"margin-left:11%;\">print ($optional_filehandle,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Prints the whole document\nassociated with the twig. To be used only\n<small>AFTER</small> the parse.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\n&quot;flush&quot;.</p>\n\n<p style=\"margin-left:11%;\">print_to_file ($filename,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Prints the whole document\nassociated with the twig to file $filename. To be used only\n<small>AFTER</small> the parse.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\n&quot;flush&quot;.</p>\n\n<p style=\"margin-left:11%;\">safe_print_to_file ($filename,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Prints the whole document\nassociated with the twig to file $filename. This variant,\nwhich probably only works on *nix prints to a temp file,\nthen move the temp file to overwrite the original file.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This is a bit\nsafer when 2 processes an potentiallywrite the same file:\nonly the last one will succeed, but the file won&rsquo;t be\ncorruted. I often use this for cron jobs, so testing the\ncode doesn&rsquo;t interfere with the cron job running at\nthe same time.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\n&quot;flush&quot;.</p>\n\n<p style=\"margin-left:11%;\">sprint</p>\n\n<p style=\"margin-left:17%;\">Return the text of the whole\ndocument associated with the twig. To be used only\n<small>AFTER</small> the parse.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\n&quot;flush&quot;.</p>\n\n<p style=\"margin-left:11%;\">trim</p>\n\n<p style=\"margin-left:17%;\">Trim the document: gets rid of\ninitial and trailing spaces, and replaces multiple spaces by\na single one.</p>\n\n<p style=\"margin-left:11%;\">toSAX1 ($handler)</p>\n\n<p style=\"margin-left:17%;\">Send <small>SAX</small> events\nfor the twig to the <small>SAX1</small> handler $handler</p>\n\n<p style=\"margin-left:11%;\">toSAX2 ($handler)</p>\n\n<p style=\"margin-left:17%;\">Send <small>SAX</small> events\nfor the twig to the <small>SAX2</small> handler $handler</p>\n\n<p style=\"margin-left:11%;\">flush_toSAX1 ($handler)</p>\n\n<p style=\"margin-left:17%;\">Same as flush, except that\n<small>SAX</small> events are sent to the\n<small>SAX1</small> handler $handler instead of the twig\nbeing printed</p>\n\n<p style=\"margin-left:11%;\">flush_toSAX2 ($handler)</p>\n\n<p style=\"margin-left:17%;\">Same as flush, except that\n<small>SAX</small> events are sent to the\n<small>SAX2</small> handler $handler instead of the twig\nbeing printed</p>\n\n<p style=\"margin-left:11%;\">ignore</p>\n\n<p style=\"margin-left:17%;\">This method should be called\nduring parsing, usually in &quot;start_tag_handlers&quot;.\nIt causes the element to be skipped during the parsing: the\ntwig is not built for this element, it will not be\naccessible during parsing or after it. The element will not\ntake up any memory and parsing will be faster.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that this\nmethod can also be called on an element. If the element is a\nparent of the current element then this element will be\nignored (the twig will not be built any more for it and what\nhas already been built will be deleted).</p>\n\n<p style=\"margin-left:11%;\">set_pretty_print ($style)</p>\n\n<p style=\"margin-left:17%;\">Set the pretty print method,\namongst &rsquo;&quot;none&quot;&rsquo; (default),\n&rsquo;&quot;nsgmls&quot;&rsquo;,\n&rsquo;&quot;nice&quot;&rsquo;,\n&rsquo;&quot;indented&quot;&rsquo;, &quot;indented_c&quot;,\n&rsquo;&quot;wrapped&quot;&rsquo;,\n&rsquo;&quot;record&quot;&rsquo; and\n&rsquo;&quot;record_c&quot;&rsquo;</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b><small>WARNING:</small></b>\nthe pretty print style is a <b><small>GLOBAL</small></b>\nvariable, so once set it&rsquo;s applied to\n<b><small>ALL</small></b> &quot;print&quot;&rsquo;s (and\n&quot;sprint&quot;&rsquo;s). Same goes if you use XML::Twig\nwith &quot;mod_perl&quot; . This should not be a problem as\nthe <small>XML</small> that&rsquo;s generated is valid\nanyway, and <small>XML</small> processors (as well as\n<small>HTML</small> processors, including browsers) should\nnot care. Let me know if this is a big problem, but at the\nmoment the performance/cleanliness trade-off clearly favors\nthe global approach.</p>\n\n<p style=\"margin-left:11%;\">set_empty_tag_style\n($style)</p>\n\n<p style=\"margin-left:17%;\">Set the empty tag display style\n(&rsquo;&quot;normal&quot;&rsquo;,\n&rsquo;&quot;html&quot;&rsquo; or\n&rsquo;&quot;expand&quot;&rsquo;). As with\n&quot;set_pretty_print&quot; this sets a global flag.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;normal&quot;\noutputs an empty tag &rsquo;&quot;&lt;tag/&gt;&quot;&rsquo;,\n&quot;html&quot; adds a space &rsquo;&quot;&lt;tag\n/&gt;&quot;&rsquo; for elements that can be empty in\n<small>XHTML</small> and &quot;expand&quot; outputs\n&rsquo;&quot;&lt;tag&gt;&lt;/tag&gt;&quot;&rsquo;</p>\n\n<p style=\"margin-left:11%;\">set_remove_cdata ($flag)</p>\n\n<p style=\"margin-left:17%;\">set (or unset) the flag that\nforces the twig to output <small>CDATA</small> sections as\nregular (escaped) <small>PCDATA</small></p>\n\n<p style=\"margin-left:11%;\">print_prolog\n($optional_filehandle, %options)</p>\n\n<p style=\"margin-left:17%;\">Prints the prolog (\n<small>XML</small> declaration + <small>DTD +</small> entity\ndeclarations) of a document.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\n&quot;flush&quot;.</p>\n\n<p style=\"margin-left:11%;\">prolog ($optional_filehandle,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Return the prolog (\n<small>XML</small> declaration + <small>DTD +</small> entity\ndeclarations) of a document.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\n&quot;flush&quot;.</p>\n\n<p style=\"margin-left:11%;\">finish</p>\n\n<p style=\"margin-left:17%;\">Call Expat &quot;finish&quot;\nmethod. Unsets all handlers (including internal ones that\nset context), but expat continues parsing to the end of the\ndocument or until it finds an error. It should finish up a\nlot faster than with the handlers set.</p>\n\n<p style=\"margin-left:11%;\">finish_print</p>\n\n<p style=\"margin-left:17%;\">Stops twig processing, flush\nthe twig and proceed to finish printing the document as fast\nas possible. Use this method when modifying a document and\nthe modification is done.</p>\n\n<p style=\"margin-left:11%;\">finish_now</p>\n\n<p style=\"margin-left:17%;\">Stops twig processing, does not\nfinish parsing the document (which could actually be not\nwell-formed after the point where &quot;finish_now&quot; is\ncalled). Execution resumes after the &quot;Lparse&quot;&gt;\nor &quot;parsefile&quot; call. The content of the twig is\nwhat has been parsed so far (all open elements at the time\n&quot;finish_now&quot; is called are considered closed).</p>\n\n\n<p style=\"margin-left:11%;\">set_expand_external_entities</p>\n\n<p style=\"margin-left:17%;\">Same as using the\n&quot;expand_external_ents&quot; option when creating the\ntwig</p>\n\n<p style=\"margin-left:11%;\">set_input_filter</p>\n\n<p style=\"margin-left:17%;\">Same as using the\n&quot;input_filter&quot; option when creating the twig</p>\n\n<p style=\"margin-left:11%;\">set_keep_atts_order</p>\n\n<p style=\"margin-left:17%;\">Same as using the\n&quot;keep_atts_order&quot; option when creating the\ntwig</p>\n\n<p style=\"margin-left:11%;\">set_keep_encoding</p>\n\n<p style=\"margin-left:17%;\">Same as using the\n&quot;keep_encoding&quot; option when creating the twig</p>\n\n<p style=\"margin-left:11%;\">escape_gt</p>\n\n<p style=\"margin-left:17%;\">usually XML::Twig does not\nescape &gt; in its output. Using this option makes it\nreplace &gt; by &amp;gt;</p>\n\n<p style=\"margin-left:11%;\">do_not_escape_gt</p>\n\n<p style=\"margin-left:17%;\">reverts XML::Twig behavior to\nits default of not escaping &gt; in its output.</p>\n\n<p style=\"margin-left:11%;\">set_output_filter</p>\n\n<p style=\"margin-left:17%;\">Same as using the\n&quot;output_filter&quot; option when creating the twig</p>\n\n<p style=\"margin-left:11%;\">set_output_text_filter</p>\n\n<p style=\"margin-left:17%;\">Same as using the\n&quot;output_text_filter&quot; option when creating the\ntwig</p>\n\n<p style=\"margin-left:11%;\">add_stylesheet ($type,\n@options)</p>\n\n<p style=\"margin-left:17%;\">Adds an external stylesheet to\nan <small>XML</small> document.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Supported types\nand options:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p>xsl</p></td>\n<td width=\"1%\"></td>\n<td width=\"51%\">\n\n\n<p>option: the url of the stylesheet</p></td>\n<td width=\"26%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Example:</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\">$t-&gt;add_stylesheet(\nxsl =&gt; &quot;xsl_style.xsl&quot;);</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">will generate\nthe following <small>PI</small> at the beginning of the\ndocument:</p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\">&lt;?xml-stylesheet\ntype=&quot;text/xsl&quot;\nhref=&quot;xsl_style.xsl&quot;?&gt;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"5%\">\n\n\n<p style=\"margin-top: 1em\">css</p></td>\n<td width=\"1%\"></td>\n<td width=\"51%\">\n\n\n<p style=\"margin-top: 1em\">option: the url of the\nstylesheet</p> </td>\n<td width=\"26%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:17%;\">active_twig</p>\n\n<p style=\"margin-left:23%;\">a class method that returns the\nlast processed twig, so you don&rsquo;t necessarily need the\nobject to call methods on it.</p>\n\n<p style=\"margin-left:11%;\">Methods inherited from\nXML::Parser::Expat</p>\n\n<p style=\"margin-left:17%;\">A twig inherits all the\nrelevant methods from XML::Parser::Expat. These methods can\nonly be used during the parsing phase (they will generate a\nfatal error otherwise).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Inherited\nmethods are: <br>\ndepth</p>\n\n<p style=\"margin-left:23%;\">Returns the size of the context\nlist.</p>\n\n<p style=\"margin-left:17%;\">in_element</p>\n\n<p style=\"margin-left:23%;\">Returns true if\n<small>NAME</small> is equal to the name of the innermost\ncurrently opened element. If namespace processing is being\nused and you want to check against a name that may be in a\nnamespace, then use the generate_ns_name method to create\nthe <small>NAME</small> argument.</p>\n\n<p style=\"margin-left:17%;\">within_element</p>\n\n<p style=\"margin-left:23%;\">Returns the number of times the\ngiven name appears in the context list. If namespace\nprocessing is being used and you want to check against a\nname that may be in a namespace, then use the\ngenerate_ns_name method to create the <small>NAME</small>\nargument.</p>\n\n<p style=\"margin-left:17%;\">context</p>\n\n<p style=\"margin-left:23%;\">Returns a list of element names\nthat represent open elements, with the last one being the\ninnermost. Inside start and end tag handlers, this will be\nthe tag of the parent element.</p>\n\n<p style=\"margin-left:17%;\">current_line</p>\n\n<p style=\"margin-left:23%;\">Returns the line number of the\ncurrent position of the parse.</p>\n\n<p style=\"margin-left:17%;\">current_column</p>\n\n<p style=\"margin-left:23%;\">Returns the column number of\nthe current position of the parse.</p>\n\n<p style=\"margin-left:17%;\">current_byte</p>\n\n<p style=\"margin-left:23%;\">Returns the current position of\nthe parse.</p>\n\n<p style=\"margin-left:17%;\">position_in_context</p>\n\n<p style=\"margin-left:23%;\">Returns a string that shows the\ncurrent parse position. <small>LINES</small> should be an\ninteger &gt;= 0 that represents the number of lines on\neither side of the current parse line to place into the\nreturned string.</p>\n\n<p style=\"margin-left:17%;\">base ([ <small>NEWBASE</small>\n])</p>\n\n<p style=\"margin-left:23%;\">Returns the current value of\nthe base for resolving relative URIs. If\n<small>NEWBASE</small> is supplied, changes the base to that\nvalue.</p>\n\n<p style=\"margin-left:17%;\">current_element</p>\n\n<p style=\"margin-left:23%;\">Returns the name of the\ninnermost currently opened element. Inside start or end\nhandlers, returns the parent of the element associated with\nthose tags.</p>\n\n<p style=\"margin-left:17%;\">element_index</p>\n\n<p style=\"margin-left:23%;\">Returns an integer that is the\ndepth-first visit order of the current element. This will be\nzero outside of the root element. For example, this will\nreturn 1 when called from the start handler for the root\nelement start tag.</p>\n\n<p style=\"margin-left:17%;\">recognized_string</p>\n\n<p style=\"margin-left:23%;\">Returns the string from the\ndocument that was recognized in order to call the current\nhandler. For instance, when called from a start handler, it\nwill give us the start-tag string. The string is encoded in\n<small>UTF-8.</small> This method doesn&rsquo;t return a\nmeaningful string inside declaration handlers.</p>\n\n<p style=\"margin-left:17%;\">original_string</p>\n\n<p style=\"margin-left:23%;\">Returns the verbatim string\nfrom the document that was recognized in order to call the\ncurrent handler. The string is in the original document\nencoding. This method doesn&rsquo;t return a meaningful\nstring inside declaration handlers.</p>\n\n<p style=\"margin-left:17%;\">xpcroak</p>\n\n<p style=\"margin-left:23%;\">Concatenate onto the given\nmessage the current line number within the\n<small>XML</small> document plus the message implied by\nErrorContext. Then croak with the formed message.</p>\n\n<p style=\"margin-left:17%;\">xpcarp</p>\n\n<p style=\"margin-left:23%;\">Concatenate onto the given\nmessage the current line number within the\n<small>XML</small> document plus the message implied by\nErrorContext. Then carp with the formed message.</p>\n\n<p style=\"margin-left:17%;\">xml_escape( <small>TEXT</small>\n[, <small>CHAR</small> [, <small>CHAR ...</small> ]])</p>\n\n<p style=\"margin-left:23%;\">Returns <small>TEXT</small>\nwith markup characters turned into character entities. Any\nadditional characters provided as arguments are also turned\ninto character references where found in\n<small>TEXT.</small></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">(this method is\nbroken on some versions of expat/XML::Parser)</p>\n\n<p style=\"margin-left:11%;\">path ( $optional_tag)</p>\n\n<p style=\"margin-left:17%;\">Return the element context in a\nform similar to XPath&rsquo;s short form:\n&rsquo;&quot;/root/tag1/../tag&quot;&rsquo;</p>\n\n<p style=\"margin-left:11%;\">get_xpath (\n$optional_array_ref, $xpath, $optional_offset)</p>\n\n<p style=\"margin-left:17%;\">Performs a\n&quot;get_xpath&quot; on the document root (see\n&lt;Elt|&quot;Elt&quot;&gt;)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the\n$optional_array_ref argument is used the array must contain\nelements. The $xpath expression is applied to each element\nin turn and the result is union of all results. This way a\nfirst query can be refined in further steps.</p>\n\n<p style=\"margin-left:11%;\">find_nodes (\n$optional_array_ref, $xpath, $optional_offset)</p>\n\n<p style=\"margin-left:17%;\">same as\n&quot;get_xpath&quot;</p>\n\n<p style=\"margin-left:11%;\">findnodes (\n$optional_array_ref, $xpath, $optional_offset)</p>\n\n<p style=\"margin-left:17%;\">same as &quot;get_xpath&quot;\n(similar to the XML::LibXML method)</p>\n\n<p style=\"margin-left:11%;\">findvalue (\n$optional_array_ref, $xpath, $optional_offset)</p>\n\n<p style=\"margin-left:17%;\">Return the &quot;join&quot; of\nall texts of the results of applying &quot;get_xpath&quot;\nto the node (similar to the XML::LibXML method)</p>\n\n<p style=\"margin-left:11%;\">findvalues (\n$optional_array_ref, $xpath, $optional_offset)</p>\n\n<p style=\"margin-left:17%;\">Return an array of all texts of\nthe results of applying &quot;get_xpath&quot; to the\nnode</p>\n\n<p style=\"margin-left:11%;\">subs_text ($regexp,\n$replace)</p>\n\n<p style=\"margin-left:17%;\">subs_text does text\nsubstitution on the whole document, similar to perl&rsquo;s\n&quot; s///&quot; operator.</p>\n\n<p style=\"margin-left:11%;\">dispose</p>\n\n<p style=\"margin-left:17%;\">Useful only if you don&rsquo;t\nhave &quot;Scalar::Util&quot; or &quot;WeakRef&quot;\ninstalled.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Reclaims\nproperly the memory used by an XML::Twig object. As the\nobject has circular references it never goes out of scope,\nso if you want to parse lots of <small>XML</small> documents\nthen the memory leak becomes a problem. Use\n&quot;$twig-&gt;dispose&quot; to clear this problem.</p>\n\n<p style=\"margin-left:11%;\">att_accessors\n(list_of_attribute_names)</p>\n\n<p style=\"margin-left:17%;\">A convenience method that\ncreates l-valued accessors for attributes. So\n&quot;$twig-&gt;create_accessors( 'foo')&quot; will create a\n&quot;foo&quot; method that can be called on elements:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;foo; #\nequivalent to $elt-&gt;{'att'}-&gt;{'foo'}; <br>\n$elt-&gt;foo( 'bar'); # equivalent to $elt-&gt;set_att( foo\n=&gt; 'bar');</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The methods are\nl-valued only under those perl&rsquo;s that support this\nfeature (5.6 and above)</p>\n\n<p style=\"margin-left:11%;\">create_accessors\n(list_of_attribute_names)</p>\n\n<p style=\"margin-left:17%;\">Same as att_accessors</p>\n\n<p style=\"margin-left:11%;\">elt_accessors\n(list_of_attribute_names)</p>\n\n<p style=\"margin-left:17%;\">A convenience method that\ncreates accessors for elements. So\n&quot;$twig-&gt;create_accessors( 'foo')&quot; will create a\n&quot;foo&quot; method that can be called on elements:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;foo; #\nequivalent to $elt-&gt;first_child( 'foo');</p>\n\n<p style=\"margin-left:11%;\">field_accessors\n(list_of_attribute_names)</p>\n\n<p style=\"margin-left:17%;\">A convenience method that\ncreates accessors for element values (&quot;field&quot;). So\n&quot;$twig-&gt;create_accessors( 'foo')&quot; will create a\n&quot;foo&quot; method that can be called on elements:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;foo; #\nequivalent to $elt-&gt;field( 'foo');</p>\n\n\n<p style=\"margin-left:11%;\">set_do_not_escape_amp_in_atts</p>\n\n<p style=\"margin-left:17%;\">An evil method, that I only\ndocument because Test::Pod::Coverage complaints otherwise,\nbut really, you don&rsquo;t want to know about it.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig::Elt</b>\n<br>\nnew ($optional_tag, $optional_atts, @optional_content)</p>\n\n<p style=\"margin-left:17%;\">The &quot;tag&quot; is optional\n(but then you can&rsquo;t have a content ), the\n$optional_atts argument is a reference to a hash of\nattributes, the content can be just a string or a list of\nstrings and element. A content of\n&rsquo;&quot;#EMPTY&quot;&rsquo; creates an empty\nelement;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Examples: my\n$elt= XML::Twig::Elt-&gt;new(); <br>\nmy $elt= XML::Twig::Elt-&gt;new( para =&gt; { align =&gt;\n'center' }); <br>\nmy $elt= XML::Twig::Elt-&gt;new( para =&gt; { align =&gt;\n'center' }, 'foo'); <br>\nmy $elt= XML::Twig::Elt-&gt;new( br =&gt; '#EMPTY'); <br>\nmy $elt= XML::Twig::Elt-&gt;new( 'para'); <br>\nmy $elt= XML::Twig::Elt-&gt;new( para =&gt; 'this is a\npara'); <br>\nmy $elt= XML::Twig::Elt-&gt;new( para =&gt; $elt3, 'another\npara');</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The strings are\nnot parsed, the element is not attached to any twig.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b><small>WARNING</small></b>\n: if you rely on <small>ID</small> &rsquo;s then you will\nhave to set the id yourself. At this point the element does\nnot belong to a twig yet, so the <small>ID</small> attribute\nis not known so it won&rsquo;t be stored in the\n<small>ID</small> list.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\n&quot;#COMMENT&quot;, &quot;#PCDATA&quot; or\n&quot;#CDATA&quot; are valid tag names, that will create\ntext elements.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">To create an\nelement &quot;foo&quot; containing a <small>CDATA</small>\nsection:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $foo=\nXML::Twig::Elt-&gt;new( '#CDATA' =&gt; &quot;content of the\nCDATA section&quot;) <br>\n-&gt;wrap_in( 'foo');</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">An attribute of\n&rsquo;#CDATA&rsquo;, will create the content of the element\nas <small>CDATA:</small></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $elt=\nXML::Twig::Elt-&gt;new( 'p' =&gt; { '#CDATA' =&gt; 1}, 'foo\n&lt; bar');</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">creates an\nelement</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;p&gt;&lt;![CDATA[foo\n&lt; bar]]&gt;&lt;/&gt;</p>\n\n<p style=\"margin-left:11%;\">parse ($string, %args)</p>\n\n<p style=\"margin-left:17%;\">Creates an element from an\n<small>XML</small> string. The string is actually parsed as\na new twig, then the root of that twig is returned. The\narguments in %args are passed to the twig. As always if the\nparse fails the parser will die, so use an eval if you want\nto trap syntax errors.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">As obviously\nthe element does not exist beforehand this method has to be\ncalled on the class:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $elt= parse\nXML::Twig::Elt( &quot;&lt;a&gt; string to parse, with\n&lt;sub/&gt; <br>\n&lt;elements&gt;, actually tons of &lt;/elements&gt; <br>\nh&lt;/a&gt;&quot;);</p>\n\n<p style=\"margin-left:11%;\">set_inner_xml ($string)</p>\n\n<p style=\"margin-left:17%;\">Sets the content of the element\nto be the tree created from the string</p>\n\n<p style=\"margin-left:11%;\">set_inner_html ($string)</p>\n\n<p style=\"margin-left:17%;\">Sets the content of the\nelement, after parsing the string with an\n<small>HTML</small> parser (HTML::Parser)</p>\n\n<p style=\"margin-left:11%;\">set_outer_xml ($string)</p>\n\n<p style=\"margin-left:17%;\">Replaces the element with the\ntree created from the string</p>\n\n<p style=\"margin-left:11%;\">print ($optional_filehandle,\n$optional_pretty_print_style)</p>\n\n<p style=\"margin-left:17%;\">Prints an entire element,\nincluding the tags, optionally to a $optional_filehandle,\noptionally with a $pretty_print_style.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The print\noutputs <small>XML</small> data so base entities are\nescaped.</p>\n\n<p style=\"margin-left:11%;\">print_to_file ($filename,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Prints the element to file\n$filename.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">options: see\n&quot;flush&quot;. =item sprint ($elt,\n$optional_no_enclosing_tag)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the xml\nstring for an entire element, including the tags. If the\noptional second argument is true then only the string inside\nthe element is returned (the start and end tag for $elt are\nnot). The text is XML-escaped: base entities (&amp; and &lt;\nin text, &amp; &lt; and &quot; in attribute values) are\nturned into entities.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>gi</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Return the gi of the element (the gi is the\n&quot;generic identifier&quot; the tag name in\n<small>SGML</small> parlance).</p></td></tr>\n</table>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;tag&quot;\nand &quot;name&quot; are synonyms of &quot;gi&quot;.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\">tag</p></td>\n<td width=\"2%\"></td>\n<td width=\"18%\">\n\n\n<p style=\"margin-top: 1em\">Same as &quot;gi&quot;</p></td>\n<td width=\"65%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">name</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;tag&quot;</p>\n\n<p style=\"margin-left:11%;\">set_gi ($tag)</p>\n\n<p style=\"margin-left:17%;\">Set the gi (tag) of an\nelement</p>\n\n<p style=\"margin-left:11%;\">set_tag ($tag)</p>\n\n<p style=\"margin-left:17%;\">Set the tag (=&quot;tag&quot;)\nof an element</p>\n\n<p style=\"margin-left:11%;\">set_name ($name)</p>\n\n<p style=\"margin-left:17%;\">Set the name (=&quot;tag&quot;)\nof an element</p>\n\n<p style=\"margin-left:11%;\">root</p>\n\n<p style=\"margin-left:17%;\">Return the root of the twig in\nwhich the element is contained.</p>\n\n<p style=\"margin-left:11%;\">twig</p>\n\n<p style=\"margin-left:17%;\">Return the twig containing the\nelement.</p>\n\n<p style=\"margin-left:11%;\">parent\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the parent of the\nelement, or the first ancestor matching the\n$optional_condition</p>\n\n<p style=\"margin-left:11%;\">first_child\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the first child of the\nelement, or the first child matching the\n$optional_condition</p>\n\n<p style=\"margin-left:11%;\">has_child\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the first child of the\nelement, or the first child matching the $optional_condition\n(same as first_child)</p>\n\n<p style=\"margin-left:11%;\">has_children\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the first child of the\nelement, or the first child matching the $optional_condition\n(same as first_child)</p>\n\n<p style=\"margin-left:11%;\">first_child_text\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the text of the first\nchild of the element, or the first child <br>\nmatching the $optional_condition If there is no first_child\nthen returns &rsquo;&rsquo;. This avoids getting the child,\nchecking for its existence then getting the text for trivial\ncases.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Similar methods\nare available for the other navigation methods: <br>\nlast_child_text <br>\nprev_sibling_text <br>\nnext_sibling_text <br>\nprev_elt_text <br>\nnext_elt_text <br>\nchild_text <br>\nparent_text</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">All this\nmethods also exist in &quot;trimmed&quot; variant: <br>\nfirst_child_trimmed_text <br>\nlast_child_trimmed_text <br>\nprev_sibling_trimmed_text <br>\nnext_sibling_trimmed_text <br>\nprev_elt_trimmed_text <br>\nnext_elt_trimmed_text <br>\nchild_trimmed_text <br>\nparent_trimmed_text</p>\n\n<p style=\"margin-left:11%;\">field ($condition)</p>\n\n<p style=\"margin-left:17%;\">Same method as\n&quot;first_child_text&quot; with a different name</p>\n\n<p style=\"margin-left:11%;\">fields ($condition_list)</p>\n\n<p style=\"margin-left:17%;\">Return the list of field (text\nof first child matching the conditions), missing fields are\nreturned as the empty string.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Same method as\n&quot;first_child_text&quot; with a different name</p>\n\n<p style=\"margin-left:11%;\">trimmed_field\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Same method as\n&quot;first_child_trimmed_text&quot; with a different\nname</p>\n\n<p style=\"margin-left:11%;\">set_field ($condition,\n$optional_atts, @list_of_elt_and_strings)</p>\n\n<p style=\"margin-left:17%;\">Set the content of the first\nchild of the element that matches $condition, the rest of\nthe arguments is the same as for &quot;set_content&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If no child\nmatches $condition _and_ if $condition is a valid\n<small>XML</small> element name, then a new element by that\nname is created and inserted as the last child.</p>\n\n<p style=\"margin-left:11%;\">first_child_matches\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the element if the first\nchild of the element (if it exists) passes the\n$optional_condition &quot;undef&quot; otherwise</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if(\n$elt-&gt;first_child_matches( 'title')) ...</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">is equivalent\nto</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if(\n$elt-&gt;{first_child} &amp;&amp;\n$elt-&gt;{first_child}-&gt;passes( 'title'))</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;first_child_is&quot;\nis another name for this method</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Similar methods\nare available for the other navigation methods: <br>\nlast_child_matches <br>\nprev_sibling_matches <br>\nnext_sibling_matches <br>\nprev_elt_matches <br>\nnext_elt_matches <br>\nchild_matches <br>\nparent_matches</p>\n\n<p style=\"margin-left:11%;\">is_first_child\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">returns true (the element) if\nthe element is the first child of its parent (optionally\nthat satisfies the $optional_condition)</p>\n\n<p style=\"margin-left:11%;\">is_last_child\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">returns true (the element) if\nthe element is the last child of its parent (optionally that\nsatisfies the $optional_condition)</p>\n\n<p style=\"margin-left:11%;\">prev_sibling\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the previous sibling of\nthe element, or the previous sibling matching\n$optional_condition</p>\n\n<p style=\"margin-left:11%;\">next_sibling\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the next sibling of the\nelement, or the first one matching $optional_condition.</p>\n\n<p style=\"margin-left:11%;\">next_elt ($optional_elt,\n$optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the next elt (optionally\nmatching $optional_condition) of the element. This is\ndefined as the next element which opens after the current\nelement opens. Which usually means the first child of the\nelement. Counter-intuitive as it might look this allows you\nto loop through the whole document by starting from the\nroot.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n$optional_elt is the root of a subtree. When the\n&quot;next_elt&quot; is out of the subtree then the method\nreturns undef. You can then walk a sub-tree with:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $elt=\n$subtree_root; <br>\nwhile( $elt= $elt-&gt;next_elt( $subtree_root)) <br>\n{ # insert processing code here <br>\n}</p>\n\n<p style=\"margin-left:11%;\">prev_elt\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the previous elt\n(optionally matching $optional_condition) of the element.\nThis is the first element which opens before the current\none. It is usually either the last descendant of the\nprevious sibling or simply the parent</p>\n\n<p style=\"margin-left:11%;\">next_n_elt ($offset,\n$optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the $offset-th element\nthat matches the $optional_condition</p>\n\n<p style=\"margin-left:11%;\">following_elt</p>\n\n<p style=\"margin-left:17%;\">Return the following element\n(as per the XPath following axis)</p>\n\n<p style=\"margin-left:11%;\">preceding_elt</p>\n\n<p style=\"margin-left:17%;\">Return the preceding element\n(as per the XPath preceding axis)</p>\n\n<p style=\"margin-left:11%;\">following_elts</p>\n\n<p style=\"margin-left:17%;\">Return the list of following\nelements (as per the XPath following axis)</p>\n\n<p style=\"margin-left:11%;\">preceding_elts</p>\n\n<p style=\"margin-left:17%;\">Return the list of preceding\nelements (as per the XPath preceding axis)</p>\n\n<p style=\"margin-left:11%;\">children\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the list of children\n(optionally which matches $optional_condition) of the\nelement. The list is in document order.</p>\n\n<p style=\"margin-left:11%;\">children_count\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the number of children\nof the element (optionally which matches\n$optional_condition)</p>\n\n<p style=\"margin-left:11%;\">children_text\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">In array context, returns an\narray containing the text of children of the element\n(optionally which matches $optional_condition)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In scalar\ncontext, returns the concatenation of the text of children\nof the element</p>\n\n<p style=\"margin-left:11%;\">children_trimmed_text\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">In array context, returns an\narray containing the trimmed text of children of the element\n(optionally which matches $optional_condition)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In scalar\ncontext, returns the concatenation of the trimmed text of\nchildren of the element</p>\n\n<p style=\"margin-left:11%;\">children_copy\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return a list of elements that\nare copies of the children of the element, optionally which\nmatches $optional_condition</p>\n\n<p style=\"margin-left:11%;\">descendants\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the list of all\ndescendants (optionally which matches $optional_condition)\nof the element. This is the equivalent of the\n&quot;getElementsByTagName&quot; of the <small>DOM</small>\n(by the way, if you are really a <small>DOM</small> addict,\nyou can use &quot;getElementsByTagName&quot; instead)</p>\n\n<p style=\"margin-left:11%;\">getElementsByTagName\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Same as\n&quot;descendants&quot;</p>\n\n<p style=\"margin-left:11%;\">find_by_tag_name\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Same as\n&quot;descendants&quot;</p>\n\n<p style=\"margin-left:11%;\">descendants_or_self\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;descendants&quot;\nexcept that the element itself is included in the list if it\nmatches the $optional_condition</p>\n\n<p style=\"margin-left:11%;\">first_descendant\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the first descendant of\nthe element that matches the condition</p>\n\n<p style=\"margin-left:11%;\">last_descendant\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the last descendant of\nthe element that matches the condition</p>\n\n<p style=\"margin-left:11%;\">ancestors\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the list of ancestors\n(optionally matching $optional_condition) of the element.\nThe list is ordered from the innermost ancestor to the\noutermost one</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>NOTE:</small>\nthe element itself is not part of the list, in order to\ninclude it you will have to use ancestors_or_self</p>\n\n<p style=\"margin-left:11%;\">ancestors_or_self\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the list of ancestors\n(optionally matching $optional_condition) of the element,\nincluding the element (if it matches the condition&gt;). The\nlist is ordered from the innermost ancestor to the outermost\none</p>\n\n<p style=\"margin-left:11%;\">passes ($condition)</p>\n\n<p style=\"margin-left:17%;\">Return the element if it passes\nthe $condition</p>\n\n<p style=\"margin-left:11%;\">att ($att)</p>\n\n<p style=\"margin-left:17%;\">Return the value of attribute\n$att or &quot;undef&quot;</p>\n\n<p style=\"margin-left:11%;\">latt ($att)</p>\n\n<p style=\"margin-left:17%;\">Return the value of attribute\n$att or &quot;undef&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">this method is\nan lvalue, so you can do &quot;$elt-&gt;latt( 'foo')=\n'bar'&quot; or &quot;$elt-&gt;latt( 'foo')++;&quot;</p>\n\n<p style=\"margin-left:11%;\">set_att ($att, $att_value)</p>\n\n<p style=\"margin-left:17%;\">Set the attribute of the\nelement to the given value</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can\nactually set several attributes this way:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;set_att(\natt1 =&gt; &quot;val1&quot;, att2 =&gt;\n&quot;val2&quot;);</p>\n\n<p style=\"margin-left:11%;\">del_att ($att)</p>\n\n<p style=\"margin-left:17%;\">Delete the attribute for the\nelement</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can\nactually delete several attributes at once:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;del_att(\n'att1', 'att2', 'att3');</p>\n\n<p style=\"margin-left:11%;\">att_exists ($att)</p>\n\n<p style=\"margin-left:17%;\">Returns true if the attribute\n$att exists for the element, false otherwise</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>cut</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Cut the element from the tree. The element still exists,\nit can be copied or pasted somewhere else, it is just not\nattached to the tree anymore.</p></td></tr>\n</table>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\n&quot;old&quot; links to the parent, previous and next\nsiblings can still be accessed using the former_*\nmethods</p>\n\n<p style=\"margin-left:11%;\">former_next_sibling</p>\n\n<p style=\"margin-left:17%;\">Returns the former next sibling\nof a cut node (or undef if the node has not been cut)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This makes it\neasier to write loops where you cut elements:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $child=\n$parent-&gt;first_child( 'achild'); <br>\nwhile( $child-&gt;{'att'}-&gt;{'cut'}) <br>\n{ $child-&gt;cut; $child= ($child-&gt;{former} &amp;&amp;\n$child-&gt;{former}-&gt;{next_sibling}); }</p>\n\n<p style=\"margin-left:11%;\">former_prev_sibling</p>\n\n<p style=\"margin-left:17%;\">Returns the former previous\nsibling of a cut node (or undef if the node has not been\ncut)</p>\n\n<p style=\"margin-left:11%;\">former_parent</p>\n\n<p style=\"margin-left:17%;\">Returns the former parent of a\ncut node (or undef if the node has not been cut)</p>\n\n<p style=\"margin-left:11%;\">cut_children\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Cut all the children of the\nelement (or all of those which satisfy the\n$optional_condition).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the list\nof children</p>\n\n<p style=\"margin-left:11%;\">cut_descendants\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Cut all the descendants of the\nelement (or all of those which satisfy the\n$optional_condition).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the list\nof descendants</p>\n\n<p style=\"margin-left:11%;\">copy ($elt)</p>\n\n<p style=\"margin-left:17%;\">Return a copy of the element.\nThe copy is a &quot;deep&quot; copy: all sub-elements of the\nelement are duplicated.</p>\n\n<p style=\"margin-left:11%;\">paste ($optional_position,\n$ref)</p>\n\n<p style=\"margin-left:17%;\">Paste a (previously\n&quot;cut&quot; or newly generated) element. Die if the\nelement already belongs to a tree.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\ncalling element is pasted:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$child-&gt;paste(\nfirst_child =&gt; $existing_parent); <br>\n$new_sibling-&gt;paste( after =&gt;\n$this_sibling_is_already_in_the_tree);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">or</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $new_elt=\nXML::Twig::Elt-&gt;new( tag =&gt; $content); <br>\n$new_elt-&gt;paste( $position =&gt; $existing_elt);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $t=\nXML::Twig-&gt;new-&gt;parse( 'doc.xml') <br>\nmy $toc= $t-&gt;root-&gt;new( 'toc'); <br>\n$toc-&gt;paste( $t-&gt;root); # $toc is pasted as first\nchild of the root <br>\nforeach my $title ($t-&gt;findnodes( '/doc/section/title'))\n<br>\n{ my $title_toc= $title-&gt;copy; <br>\n# paste $title_toc as the last child of toc <br>\n$title_toc-&gt;paste( last_child =&gt; $toc) <br>\n}</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Position\noptions: <br>\nfirst_child (default)</p>\n\n<p style=\"margin-left:23%;\">The element is pasted as the\nfirst child of $ref</p>\n\n<p style=\"margin-left:17%;\">last_child</p>\n\n<p style=\"margin-left:23%;\">The element is pasted as the\nlast child of $ref</p>\n\n<p style=\"margin-left:17%;\">before</p>\n\n<p style=\"margin-left:23%;\">The element is pasted before\n$ref, as its previous sibling.</p>\n\n<p style=\"margin-left:17%;\">after</p>\n\n<p style=\"margin-left:23%;\">The element is pasted after\n$ref, as its next sibling.</p>\n\n<p style=\"margin-left:17%;\">within</p>\n\n<p style=\"margin-left:23%;\">In this case an extra argument,\n$offset, should be supplied. The element will be pasted in\nthe reference element (or in its first text child) at the\ngiven offset. To achieve this the reference element will be\nsplit at the offset.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that you\ncan call directly the underlying method: <br>\npaste_before <br>\npaste_after <br>\npaste_first_child <br>\npaste_last_child <br>\npaste_within</p>\n\n<p style=\"margin-left:11%;\">move ($optional_position,\n$ref)</p>\n\n<p style=\"margin-left:17%;\">Move an element in the tree.\nThis is just a &quot;cut&quot; then a &quot;paste&quot;. The\nsyntax is the same as &quot;paste&quot;.</p>\n\n<p style=\"margin-left:11%;\">replace ($ref)</p>\n\n<p style=\"margin-left:17%;\">Replaces an element in the\ntree. Sometimes it is just not possible to&quot;cut&quot; an\nelement then &quot;paste&quot; another in its place, so\n&quot;replace&quot; comes in handy. The calling element\nreplaces $ref.</p>\n\n<p style=\"margin-left:11%;\">replace_with (@elts)</p>\n\n<p style=\"margin-left:17%;\">Replaces the calling element\nwith one or more elements</p>\n\n<p style=\"margin-left:11%;\">delete</p>\n\n<p style=\"margin-left:17%;\">Cut the element and frees the\nmemory.</p>\n\n<p style=\"margin-left:11%;\">prefix ($text,\n$optional_option)</p>\n\n<p style=\"margin-left:17%;\">Add a prefix to an element. If\nthe element is a &quot;PCDATA&quot; element the text is\nadded to the pcdata, if the elements first child is a\n&quot;PCDATA&quot; then the text is added to it&rsquo;s\npcdata, otherwise a new &quot;PCDATA&quot; element is\ncreated and pasted as the first child of the element.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the option\nis &quot;asis&quot; then the prefix is added asis: it is\ncreated in a separate &quot;PCDATA&quot; element with an\n&quot;asis&quot; property. You can then write:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt1-&gt;prefix(\n'&lt;b&gt;', 'asis');</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">to create a\n&quot;&lt;b&gt;&quot; in the output of\n&quot;print&quot;.</p>\n\n<p style=\"margin-left:11%;\">suffix ($text,\n$optional_option)</p>\n\n<p style=\"margin-left:17%;\">Add a suffix to an element. If\nthe element is a &quot;PCDATA&quot; element the text is\nadded to the pcdata, if the elements last child is a\n&quot;PCDATA&quot; then the text is added to it&rsquo;s\npcdata, otherwise a new <small>PCDATA</small> element is\ncreated and pasted as the last child of the element.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the option\nis &quot;asis&quot; then the suffix is added asis: it is\ncreated in a separate &quot;PCDATA&quot; element with an\n&quot;asis&quot; property. You can then write:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt2-&gt;suffix(\n'&lt;/b&gt;', 'asis');</p>\n\n<p style=\"margin-left:11%;\">trim</p>\n\n<p style=\"margin-left:17%;\">Trim the element in-place:\nspaces at the beginning and at the end of the element are\ndiscarded and multiple spaces within the element (or its\ndescendants) are replaced by a single space.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that in\nsome cases you can still end up with multiple spaces, if\nthey are split between several elements:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;doc&gt;\ntext &lt;b&gt; hah! &lt;/b&gt; yep&lt;/doc&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">gets trimmed\nto</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;doc&gt;text\n&lt;b&gt; hah! &lt;/b&gt; yep&lt;/doc&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This is\nsomewhere in between a bug and a feature.</p>\n\n<p style=\"margin-left:11%;\">normalize</p>\n\n<p style=\"margin-left:17%;\">merge together all consecutive\npcdata elements in the element (if for example you have\nturned some elements into pcdata using &quot;erase&quot;,\nthis will give you a &quot;clean&quot; element in which\nthere all text fragments are as long as possible).</p>\n\n<p style=\"margin-left:11%;\">simplify (%options)</p>\n\n<p style=\"margin-left:17%;\">Return a data structure\nsuspiciously similar to XML::Simple&rsquo;s. Options are\nidentical to XMLin options, see XML::Simple doc for more\ndetails (or use DATA::dumper or <small>YAML</small> to dump\nthe data structure)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>Note</b>:\nthere is no magic here, if you write\n&quot;$twig-&gt;parsefile( $file )-&gt;simplify();&quot;\nthen it will load the entire document in memory. I am afraid\nyou will have to put some work into it to get just the bits\nyou want and discard the rest. Look at the synopsis or the\nXML::Twig 101 section at the top of the docs for more\ninformation. <br>\ncontent_key <br>\nforcearray <br>\nkeyattr <br>\nnoattr <br>\nnormalize_space</p>\n\n<p style=\"margin-left:23%;\">aka normalise_space</p>\n\n<p style=\"margin-left:17%;\">variables (%var_hash)</p>\n\n<p style=\"margin-left:23%;\">%var_hash is a hash { name\n=&gt; value }</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">This option\nallows variables in the <small>XML</small> to be expanded\nwhen the file is read. (there is no facility for putting the\nvariable names back if you regenerate <small>XML</small>\nusing XMLout).</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">A\n&rsquo;variable&rsquo; is any text of the form ${name} (or\n$name) which occurs in an attribute value or in the text\ncontent of an element. If &rsquo;name&rsquo; matches a key\nin the supplied hashref, ${name} will be replaced with the\ncorresponding value from the hashref. If no matching key is\nfound, the variable will not be replaced.</p>\n\n<p style=\"margin-left:17%;\">var_att ($attribute_name)</p>\n\n<p style=\"margin-left:23%;\">This option gives the name of\nan attribute that will be used to create variables in the\n<small>XML:</small></p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&lt;dirs&gt;\n<br>\n&lt;dir name=&quot;prefix&quot;&gt;/usr/local&lt;/dir&gt;\n<br>\n&lt;dir\nname=&quot;exec_prefix&quot;&gt;$prefix/bin&lt;/dir&gt; <br>\n&lt;/dirs&gt;</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">use &quot;var\n=&gt; 'name'&quot; to get $prefix replaced by /usr/local in\nthe generated data structure</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">By default\nvariables are captured by the following regexp: /$(\\w+)/</p>\n\n<p style=\"margin-left:17%;\">var_regexp (regexp)</p>\n\n<p style=\"margin-left:23%;\">This option changes the regexp\nused to capture variables. The variable name should be in\n$1</p>\n\n<p style=\"margin-left:17%;\">group_tags { grouping tag =&gt;\ngrouped tag, grouping tag 2 =&gt; grouped <br>\ntag 2...}</p>\n\n<p style=\"margin-left:23%;\">Option used to simplify the\nstructure: elements listed will not be used. Their children\nwill be, they will be considered children of the element\nparent.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">If the element\nis:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&lt;config\nhost=&quot;laptop.xmltwig.org&quot;&gt; <br>\n&lt;server&gt;localhost&lt;/server&gt; <br>\n&lt;dirs&gt; <br>\n&lt;dir\nname=&quot;base&quot;&gt;/home/mrodrigu/standards&lt;/dir&gt;\n<br>\n&lt;dir name=&quot;tools&quot;&gt;$base/tools&lt;/dir&gt;\n<br>\n&lt;/dirs&gt; <br>\n&lt;templates&gt; <br>\n&lt;template\nname=&quot;std_def&quot;&gt;std_def.templ&lt;/template&gt;\n<br>\n&lt;template\nname=&quot;dummy&quot;&gt;dummy&lt;/template&gt; <br>\n&lt;/templates&gt; <br>\n&lt;/config&gt;</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">Then calling\nsimplify with &quot;group_tags =&gt; { dirs =&gt; 'dir',\ntemplates =&gt; 'template'}&quot; makes the data structure\nbe exactly as if the start and end tags for &quot;dirs&quot;\nand &quot;templates&quot; were not there.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">A\n<small>YAML</small> dump of the structure</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">base:\n'/home/mrodrigu/standards' <br>\nhost: laptop.xmltwig.org <br>\nserver: localhost <br>\ntemplate: <br>\n- std_def.templ <br>\n- dummy.templ <br>\ntools: '$base/tools'</p>\n\n<p style=\"margin-left:11%;\">split_at ($offset)</p>\n\n<p style=\"margin-left:17%;\">Split a text\n(&quot;PCDATA&quot; or &quot;CDATA&quot;) element in 2 at\n$offset, the original element now holds the first part of\nthe string and a new element holds the right part. The new\nelement is returned</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the element\nis not a text element then the first text child of the\nelement is split</p>\n\n<p style=\"margin-left:11%;\">split ( $optional_regexp,\n$tag1, $atts1, $tag2, $atts2...)</p>\n\n<p style=\"margin-left:17%;\">Split the text descendants of\nan element in place, the text is split using the $regexp, if\nthe regexp includes () then the matched separators will be\nwrapped in elements. $1 is wrapped in $tag1, with attributes\n$atts1 if $atts1 is given (as a hashref), $2 is wrapped in\n$tag2...</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if $elt is\n&quot;&lt;p&gt;tati tata &lt;b&gt;tutu tati titi&lt;/b&gt;\ntata tati tata&lt;/p&gt;&quot;</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;split(\nqr/(ta)ti/, 'foo', {type =&gt; 'toto'} )</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">will change\n$elt to</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;p&gt;&lt;foo\ntype=&quot;toto&quot;&gt;ta&lt;/foo&gt; tata &lt;b&gt;tutu\n&lt;foo type=&quot;toto&quot;&gt;ta&lt;/foo&gt; <br>\ntiti&lt;/b&gt; tata &lt;foo\ntype=&quot;toto&quot;&gt;ta&lt;/foo&gt; tata&lt;/p&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The regexp can\nbe passed either as a string or as &quot;qr//&quot; (perl\n5.005 and later), it defaults to \\s+ just as the\n&quot;split&quot; built-in (but this would be quite a\nuseless behaviour without the $optional_tag parameter)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$optional_tag\ndefaults to <small>PCDATA</small> or <small>CDATA,</small>\ndepending on the initial element type</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The list of\ndescendants is returned (including un-touched original\nelements and newly created ones)</p>\n\n<p style=\"margin-left:11%;\">mark ( $regexp, $optional_tag,\n$optional_attribute_ref)</p>\n\n<p style=\"margin-left:17%;\">This method behaves exactly as\nsplit, except only the newly created elements are\nreturned</p>\n\n<p style=\"margin-left:11%;\">wrap_children ( $regexp_string,\n$tag, $optional_attribute_hashref)</p>\n\n<p style=\"margin-left:17%;\">Wrap the children of the\nelement that match the regexp in an element $tag. If\n$optional_attribute_hashref is passed then the new element\nwill have these attributes.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n$regexp_string includes tags, within pointy brackets, as in\n&quot;&lt;title&gt;&lt;para&gt;+&quot; and the usual Perl\nmodifiers (+*?...). Tags can be further qualified with\nattributes: &quot;&lt;para type=&quot;warning&quot;\nclassif=&quot;cosmic_secret&quot;&gt;+&quot;. The values for\nattributes should be xml-escaped: &quot;&lt;candy\ntype=&quot;M&amp;amp;Ms&quot;&gt;*&quot; (&quot;&lt;&quot;,\n&quot;&amp;&quot; <b>&quot;&gt;&quot;</b> and\n&quot;&quot;&quot; should be escaped).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\nelements might get extra &quot;id&quot; attributes in the\nprocess. See add_id. Use strip_att to remove unwanted\nid&rsquo;s.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Here is an\nexample:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the element\n$elt has the following content:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;elt&gt;\n<br>\n&lt;p&gt;para 1&lt;/p&gt; <br>\n&lt;l_l1_1&gt;list 1 item 1 para 1&lt;/l_l1_1&gt; <br>\n&lt;l_l1&gt;list 1 item 1 para 2&lt;/l_l1&gt; <br>\n&lt;l_l1_n&gt;list 1 item 2 para 1 (only\npara)&lt;/l_l1_n&gt; <br>\n&lt;l_l1_n&gt;list 1 item 3 para 1&lt;/l_l1_n&gt; <br>\n&lt;l_l1&gt;list 1 item 3 para 2&lt;/l_l1&gt; <br>\n&lt;l_l1&gt;list 1 item 3 para 3&lt;/l_l1&gt; <br>\n&lt;l_l1_1&gt;list 2 item 1 para 1&lt;/l_l1_1&gt; <br>\n&lt;l_l1&gt;list 2 item 1 para 2&lt;/l_l1&gt; <br>\n&lt;l_l1_n&gt;list 2 item 2 para 1 (only\npara)&lt;/l_l1_n&gt; <br>\n&lt;l_l1_n&gt;list 2 item 3 para 1&lt;/l_l1_n&gt; <br>\n&lt;l_l1&gt;list 2 item 3 para 2&lt;/l_l1&gt; <br>\n&lt;l_l1&gt;list 2 item 3 para 3&lt;/l_l1&gt; <br>\n&lt;/elt&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Then the\ncode</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;wrap_children(\nq{&lt;l_l1_1&gt;&lt;l_l1&gt;*} , li =&gt; { type =&gt;\n&quot;ul1&quot; }); <br>\n$elt-&gt;wrap_children( q{&lt;l_l1_n&gt;&lt;l_l1&gt;*} , li\n=&gt; { type =&gt; &quot;ul&quot; }); <br>\n$elt-&gt;wrap_children( q{&lt;li\ntype=&quot;ul1&quot;&gt;&lt;li type=&quot;ul&quot;&gt;+},\n&quot;ul&quot;); <br>\n$elt-&gt;strip_att( 'id'); <br>\n$elt-&gt;strip_att( 'type'); <br>\n$elt-&gt;print;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">will\noutput:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;elt&gt;\n<br>\n&lt;p&gt;para 1&lt;/p&gt; <br>\n&lt;ul&gt; <br>\n&lt;li&gt; <br>\n&lt;l_l1_1&gt;list 1 item 1 para 1&lt;/l_l1_1&gt; <br>\n&lt;l_l1&gt;list 1 item 1 para 2&lt;/l_l1&gt; <br>\n&lt;/li&gt; <br>\n&lt;li&gt; <br>\n&lt;l_l1_n&gt;list 1 item 2 para 1 (only\npara)&lt;/l_l1_n&gt; <br>\n&lt;/li&gt; <br>\n&lt;li&gt; <br>\n&lt;l_l1_n&gt;list 1 item 3 para 1&lt;/l_l1_n&gt; <br>\n&lt;l_l1&gt;list 1 item 3 para 2&lt;/l_l1&gt; <br>\n&lt;l_l1&gt;list 1 item 3 para 3&lt;/l_l1&gt; <br>\n&lt;/li&gt; <br>\n&lt;/ul&gt; <br>\n&lt;ul&gt; <br>\n&lt;li&gt; <br>\n&lt;l_l1_1&gt;list 2 item 1 para 1&lt;/l_l1_1&gt; <br>\n&lt;l_l1&gt;list 2 item 1 para 2&lt;/l_l1&gt; <br>\n&lt;/li&gt; <br>\n&lt;li&gt; <br>\n&lt;l_l1_n&gt;list 2 item 2 para 1 (only\npara)&lt;/l_l1_n&gt; <br>\n&lt;/li&gt; <br>\n&lt;li&gt; <br>\n&lt;l_l1_n&gt;list 2 item 3 para 1&lt;/l_l1_n&gt; <br>\n&lt;l_l1&gt;list 2 item 3 para 2&lt;/l_l1&gt; <br>\n&lt;l_l1&gt;list 2 item 3 para 3&lt;/l_l1&gt; <br>\n&lt;/li&gt; <br>\n&lt;/ul&gt; <br>\n&lt;/elt&gt;</p>\n\n<p style=\"margin-left:11%;\">subs_text ($regexp,\n$replace)</p>\n\n<p style=\"margin-left:17%;\">subs_text does text\nsubstitution, similar to perl&rsquo;s &quot; s///&quot;\noperator.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$regexp must be\na perl regexp, created with the &quot;qr&quot; operator.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$replace can\ninclude &quot;$1, $2&quot;... from the $regexp. It can also\nbe used to create element and entities, by using\n&quot;&amp;elt( tag =&gt; { att =&gt; val }, text)&quot;\n(similar syntax as &quot;new&quot;) and &quot;&amp;ent(\nname)&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Here is a\nrather complex example:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;subs_text(\nqr{(?&lt;!do not )link to (http://([^\\s,]*))}, <br>\n'see &amp;elt( a =&gt;{ href =&gt; $1 }, $2)' <br>\n);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This will\nreplace text like <i>link to http://www.xmltwig.org</i> by\n<i>see &lt;a\nhref=&quot;www.xmltwig.org&quot;&gt;www.xmltwig.org&lt;/a&gt;</i>,\nbut not <i>do not link to...</i></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Generating\nentities (here replacing spaces with &amp;nbsp;):</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;subs_text(\nqr{ }, '&amp;ent( &quot;&amp;nbsp;&quot;)');</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">or, using a\nvariable:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my\n$ent=&quot;&amp;nbsp;&quot;; <br>\n$elt-&gt;subs_text( qr{ }, &quot;&amp;ent(\n'$ent')&quot;);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\nsubstitution is always global, as in using the &quot;g&quot;\nmodifier in a perl substitution, and that it is performed on\nall text descendants of the element.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>Bug</b>: in\nthe $regexp, you can only use &quot;\\1&quot;,\n&quot;\\2&quot;... if the replacement expression does not\ninclude elements or attributes. eg</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$t-&gt;subs_text(\nqr/((t[aiou])\\2)/, '$2'); # ok, replaces toto, tata, titi,\ntutu by to, ta, ti, tu <br>\n$t-&gt;subs_text( qr/((t[aiou])\\2)/, '&amp;elt(p =&gt; $1)'\n); # NOK, does not find toto...</p>\n\n<p style=\"margin-left:11%;\">add_id ($optional_coderef)</p>\n\n<p style=\"margin-left:17%;\">Add an id to the element.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The id is an\nattribute, &quot;id&quot; by default, see the &quot;id&quot;\noption for XML::Twig &quot;new&quot; to change it. Use an id\nstarting with &quot;#&quot; to get an id that&rsquo;s not\noutput by print, flush or sprint, yet that allows you to use\nthe elt_id method to get the element easily.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the element\nalready has an id, no new id is generated.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">By default the\nmethod create an id of the form\n&quot;twig_id_&lt;nnnn&gt;&quot;, where\n&quot;&lt;nnnn&gt;&quot; is a number, incremented each time\nthe method is called successfully.</p>\n\n<p style=\"margin-left:11%;\">set_id_seed ($prefix)</p>\n\n<p style=\"margin-left:17%;\">by default the id generated by\n&quot;add_id&quot; is &quot;twig_id_&lt;nnnn&gt;&quot;,\n&quot;set_id_seed&quot; changes the prefix to $prefix and\nresets the number to 1</p>\n\n<p style=\"margin-left:11%;\">strip_att ($att)</p>\n\n<p style=\"margin-left:17%;\">Remove the attribute $att from\nall descendants of the element (including the element)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the\nelement</p>\n\n<p style=\"margin-left:11%;\">change_att_name ($old_name,\n$new_name)</p>\n\n<p style=\"margin-left:17%;\">Change the name of the\nattribute from $old_name to $new_name. If there is no\nattribute $old_name nothing happens.</p>\n\n<p style=\"margin-left:11%;\">lc_attnames</p>\n\n<p style=\"margin-left:17%;\">Lower cases the name all the\nattributes of the element.</p>\n\n<p style=\"margin-left:11%;\">sort_children_on_value(\n%options)</p>\n\n<p style=\"margin-left:17%;\">Sort the children of the\nelement in place according to their text. All children are\nsorted.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the\nelement, with its children sorted.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">%options\nare</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">type : numeric\n| alpha (default: alpha) <br>\norder : normal | reverse (default: normal)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the\nelement, with its children sorted</p>\n\n<p style=\"margin-left:11%;\">sort_children_on_att ($att,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Sort the children of the\nelement in place according to attribute $att. %options are\nthe same as for &quot;sort_children_on_value&quot;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the\nelement.</p>\n\n<p style=\"margin-left:11%;\">sort_children_on_field ($tag,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Sort the children of the\nelement in place, according to the field $tag (the text of\nthe first child of the child with this tag). %options are\nthe same as for &quot;sort_children_on_value&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the\nelement, with its children sorted</p>\n\n<p style=\"margin-left:11%;\">sort_children( $get_key,\n%options)</p>\n\n<p style=\"margin-left:17%;\">Sort the children of the\nelement in place. The $get_key argument is a reference to a\nfunction that returns the sort key when passed an\nelement.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For\nexample:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;sort_children(\nsub { $_[0]-&gt;{'att'}-&gt;{&quot;nb&quot;} +\n$_[0]-&gt;text }, <br>\ntype =&gt; 'numeric', order =&gt; 'reverse' <br>\n);</p>\n\n<p style=\"margin-left:11%;\">field_to_att ($cond, $att)</p>\n\n<p style=\"margin-left:17%;\">Turn the text of the first\nsub-element matched by $cond into the value of attribute\n$att of the element. If $att is omitted then $cond is used\nas the name of the attribute, which makes sense only if\n$cond is a valid element (and attribute) name.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The sub-element\nis then cut.</p>\n\n<p style=\"margin-left:11%;\">att_to_field ($att, $tag)</p>\n\n<p style=\"margin-left:17%;\">Take the value of attribute\n$att and create a sub-element $tag as first child of the\nelement. If $tag is omitted then $att is used as the name of\nthe sub-element.</p>\n\n<p style=\"margin-left:11%;\">get_xpath ($xpath,\n$optional_offset)</p>\n\n<p style=\"margin-left:17%;\">Return a list of elements\nsatisfying the $xpath. $xpath is an XPATH-like\nexpression.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A subset of the\n<small>XPATH</small> abbreviated syntax is covered:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">tag <br>\ntag[1] (or any other positive number) <br>\ntag[last()] <br>\ntag[@att] (the attribute exists for the element) <br>\ntag[@att=&quot;val&quot;] <br>\ntag[@att=~ /regexp/] <br>\ntag[att1=&quot;val1&quot; and att2=&quot;val2&quot;] <br>\ntag[att1=&quot;val1&quot; or att2=&quot;val2&quot;] <br>\ntag[string()=&quot;toto&quot;] (returns tag elements which\ntext (as per the text method) <br>\nis toto) <br>\ntag[string()=~/regexp/] (returns tag elements which text (as\nper the text <br>\nmethod) matches regexp) <br>\nexpressions can start with / (search starts at the document\nroot) <br>\nexpressions can start with . (search starts at the current\nelement) <br>\n// can be used to get all descendants instead of just direct\nchildren <br>\n* matches any tag</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">So the\nfollowing examples from the <i>XPath\nrecommendation&lt;http://www.w3.org/TR/xpath.html#path-abbrev&gt;</i>\nwork:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">para selects\nthe para element children of the context node <br>\n* selects all element children of the context node <br>\npara[1] selects the first para child of the context node\n<br>\npara[last()] selects the last para child of the context node\n<br>\n*/para selects all para grandchildren of the context node\n<br>\n/doc/chapter[5]/section[2] selects the second section of the\nfifth chapter <br>\nof the doc <br>\nchapter//para selects the para element descendants of the\nchapter element <br>\nchildren of the context node <br>\n//para selects all the para descendants of the document root\nand thus selects <br>\nall para elements in the same document as the context node\n<br>\n//olist/item selects all the item elements in the same\ndocument as the <br>\ncontext node that have an olist parent <br>\n.//para selects the para element descendants of the context\nnode <br>\n.. selects the parent of the context node <br>\npara[@type=&quot;warning&quot;] selects all para children of\nthe context node that have <br>\na type attribute with value warning <br>\nemployee[@secretary and @assistant] selects all the employee\nchildren of the <br>\ncontext node that have both a secretary attribute and an\nassistant <br>\nattribute</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The elements\nwill be returned in the document order.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If\n$optional_offset is used then only one element will be\nreturned, the one with the appropriate offset in the list,\nstarting at 0</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Quoting and\ninterpolating variables can be a pain when the Perl syntax\nand the <small>XPATH</small> syntax collide, so use\nalternate quoting mechanisms like q or qq (I like q{} and\nqq{} myself).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Here are some\nmore examples to get you started:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">my $p1=\n&quot;p1&quot;; <br>\nmy $p2= &quot;p2&quot;; <br>\nmy @res= $t-&gt;get_xpath( qq{p[string( &quot;$p1&quot;) or\nstring( &quot;$p2&quot;)]}); <br>\nmy $a= &quot;a1&quot;; <br>\nmy @res= $t-&gt;get_xpath( qq{//*[@att=&quot;$a&quot;]});\n<br>\nmy $val= &quot;a1&quot;; <br>\nmy $exp= qq{//p[ \\@att='$val']}; # you need to use \\@ or you\nwill get a warning <br>\nmy @res= $t-&gt;get_xpath( $exp);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that the\nonly supported regexps delimiters are / and that you must\nbackslash all / in regexps <small>AND</small> in regular\nstrings.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">XML::Twig does\nnot provide natively full <small>XPATH</small> support, but\nyou can use &quot;XML::Twig::XPath&quot; to get\n&quot;findnodes&quot; to use &quot;XML::XPath&quot; as the\nXPath engine, with full coverage of the spec.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;XML::Twig::XPath&quot;\nto get &quot;findnodes&quot; to use &quot;XML::XPath&quot;\nas the XPath engine, with full coverage of the spec.</p>\n\n<p style=\"margin-left:11%;\">find_nodes</p>\n\n<p style=\"margin-left:17%;\">same\nas&quot;get_xpath&quot;</p>\n\n<p style=\"margin-left:11%;\">findnodes</p>\n\n<p style=\"margin-left:17%;\">same as\n&quot;get_xpath&quot;</p>\n\n<p style=\"margin-left:11%;\">text @optional_options</p>\n\n<p style=\"margin-left:17%;\">Return a string consisting of\nall the &quot;PCDATA&quot; and &quot;CDATA&quot; in an\nelement, without any tags. The text is not XML-escaped: base\nentities such as &quot;&amp;&quot; and &quot;&lt;&quot; are\nnot escaped.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&rsquo;&quot;no_recurse&quot;&rsquo; option will only return\nthe text of the element, not of any included sub-elements\n(same as &quot;text_only&quot;).</p>\n\n<p style=\"margin-left:11%;\">text_only</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;text&quot; except\nthat the text returned doesn&rsquo;t include the text of\nsub-elements.</p>\n\n<p style=\"margin-left:11%;\">trimmed_text</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;text&quot; except\nthat the text is trimmed: leading and trailing spaces are\ndiscarded, consecutive spaces are collapsed</p>\n\n<p style=\"margin-left:11%;\">set_text ($string)</p>\n\n<p style=\"margin-left:17%;\">Set the text for the element:\nif the element is a &quot;PCDATA&quot;, just set its text,\notherwise cut all the children of the element and create a\nsingle &quot;PCDATA&quot; child for it, which holds the\ntext.</p>\n\n<p style=\"margin-left:11%;\">merge ($elt2)</p>\n\n<p style=\"margin-left:17%;\">Move the content of $elt2\nwithin the element</p>\n\n<p style=\"margin-left:11%;\">insert ($tag1,\n[$optional_atts1], $tag2, [$optional_atts2],...)</p>\n\n<p style=\"margin-left:17%;\">For each tag in the list\ninserts an element $tag as the only child of the element.\nThe element gets the optional attributes\nin&quot;$optional_atts&lt;n&gt;.&quot; All children of the\nelement are set as children of the new element. The upper\nlevel element is returned.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$p-&gt;insert(\ntable =&gt; { border=&gt; 1}, 'tr', 'td')</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">put $p in a\ntable with a visible border, a single &quot;tr&quot; and a\nsingle &quot;td&quot; and return the &quot;table&quot;\nelement:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;p&gt;&lt;table\nborder=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;original content\nof p&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;</p>\n\n<p style=\"margin-left:11%;\">wrap_in (@tag)</p>\n\n<p style=\"margin-left:17%;\">Wrap elements in @tag as the\nsuccessive ancestors of the element, returns the new\nelement. &quot;$elt-&gt;wrap_in( 'td', 'tr', 'table')&quot;\nwraps the element as a single cell in a table for\nexample.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Optionally each\ntag can be followed by a hashref of attributes, that will be\nset on the wrapping element:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$elt-&gt;wrap_in(\np =&gt; { class =&gt; &quot;advisory&quot; }, div =&gt; {\nclass =&gt; &quot;intro&quot;, id =&gt;\n&quot;div_intro&quot; });</p>\n\n<p style=\"margin-left:11%;\">insert_new_elt ($opt_position,\n$tag, $opt_atts_hashref, @opt_content)</p>\n\n<p style=\"margin-left:17%;\">Combines a &quot;new &quot; and\na &quot;paste &quot;: creates a new element using $tag,\n$opt_atts_hashref and @opt_content which are arguments\nsimilar to those for &quot;new&quot;, then paste it, using\n$opt_position or 'first_child', relative to $elt.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return the\nnewly created element</p>\n\n<p style=\"margin-left:11%;\">erase</p>\n\n<p style=\"margin-left:17%;\">Erase the element: the element\nis deleted and all of its children are pasted in its\nplace.</p>\n\n<p style=\"margin-left:11%;\">set_content ( $optional_atts,\n@list_of_elt_and_strings) ( <br>\n$optional_atts, &rsquo;#EMPTY&rsquo;)</p>\n\n<p style=\"margin-left:17%;\">Set the content for the\nelement, from a list of strings and elements. Cuts all the\nelement children, then pastes the list elements as the\nchildren. This method will create a &quot;PCDATA&quot;\nelement for any strings in the list.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n$optional_atts argument is the ref of a hash of attributes.\nIf this argument is used then the previous attributes are\ndeleted, otherwise they are left untouched.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b><small>WARNING</small></b>\n: if you rely on <small>ID</small> &rsquo;s then you will\nhave to set the id yourself. At this point the element does\nnot belong to a twig yet, so the <small>ID</small> attribute\nis not known so it won&rsquo;t be stored in the\n<small>ID</small> list.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A content of\n&rsquo;&quot;#EMPTY&quot;&rsquo; creates an empty\nelement;</p>\n\n<p style=\"margin-left:11%;\">namespace\n($optional_prefix)</p>\n\n<p style=\"margin-left:17%;\">Return the <small>URI</small>\nof the namespace that $optional_prefix or the element name\nbelongs to. If the name doesn&rsquo;t belong to any\nnamespace, &quot;undef&quot; is returned.</p>\n\n<p style=\"margin-left:11%;\">local_name</p>\n\n<p style=\"margin-left:17%;\">Return the local name (without\nthe prefix) for the element</p>\n\n<p style=\"margin-left:11%;\">ns_prefix</p>\n\n<p style=\"margin-left:17%;\">Return the namespace prefix for\nthe element</p>\n\n<p style=\"margin-left:11%;\">current_ns_prefixes</p>\n\n<p style=\"margin-left:17%;\">Return a list of namespace\nprefixes valid for the element. The order of the prefixes in\nthe list has no meaning. If the default namespace is\ncurrently bound, &rsquo;&rsquo; appears in the list.</p>\n\n<p style=\"margin-left:11%;\">inherit_att ($att,\n@optional_tag_list)</p>\n\n<p style=\"margin-left:17%;\">Return the value of an\nattribute inherited from parent tags. The value returned is\nfound by looking for the attribute in the element then in\nturn in each of its ancestors. If the @optional_tag_list is\nsupplied only those ancestors whose tag is in the list will\nbe checked.</p>\n\n<p style=\"margin-left:11%;\">all_children_are\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">return 1 if all children of the\nelement pass the $optional_condition, 0 otherwise</p>\n\n<p style=\"margin-left:11%;\">level ($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the depth of the element\nin the twig (root is 0). If $optional_condition is given\nthen only ancestors that match the condition are\ncounted.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b><small>WARNING</small></b>\n: in a tree created using the &quot;twig_roots&quot; option\nthis will not return the level in the document tree, level 0\nwill be the document root, level 1 will be the\n&quot;twig_roots&quot; elements. During the parsing (in a\n&quot;twig_handler&quot;) you can use the &quot;depth&quot;\nmethod on the twig object to get the real parsing depth.</p>\n\n<p style=\"margin-left:11%;\">in ($potential_parent)</p>\n\n<p style=\"margin-left:17%;\">Return true if the element is\nin the potential_parent ($potential_parent is an\nelement)</p>\n\n<p style=\"margin-left:11%;\">in_context ($cond,\n$optional_level)</p>\n\n<p style=\"margin-left:17%;\">Return true if the element is\nincluded in an element which passes $cond optionally within\n$optional_level levels. The returned value is the including\nelement.</p>\n\n<p style=\"margin-left:11%;\">pcdata</p>\n\n<p style=\"margin-left:17%;\">Return the text of a\n&quot;PCDATA&quot; element or &quot;undef&quot; if the\nelement is not &quot;PCDATA&quot;.</p>\n\n<p style=\"margin-left:11%;\">pcdata_xml_string</p>\n\n<p style=\"margin-left:17%;\">Return the text of a\n&quot;PCDATA&quot; element or undef if the element is not\n&quot;PCDATA&quot;. The text is &quot;XML-escaped&quot;\n(&rsquo;&amp;&rsquo; and &rsquo;&lt;&rsquo; are replaced by\n&rsquo;&amp;amp;&rsquo; and &rsquo;&amp;lt;&rsquo;)</p>\n\n<p style=\"margin-left:11%;\">set_pcdata ($text)</p>\n\n<p style=\"margin-left:17%;\">Set the text of a\n&quot;PCDATA&quot; element. This method does not check that\nthe element is indeed a &quot;PCDATA&quot; so usually you\nshould use &quot;set_text&quot; instead.</p>\n\n<p style=\"margin-left:11%;\">append_pcdata ($text)</p>\n\n<p style=\"margin-left:17%;\">Add the text at the end of a\n&quot;PCDATA&quot; element.</p>\n\n<p style=\"margin-left:11%;\">is_cdata</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element is a\n&quot;CDATA&quot; element, returns 0 otherwise.</p>\n\n<p style=\"margin-left:11%;\">is_text</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element is a\n&quot;CDATA&quot; or &quot;PCDATA&quot; element, returns 0\notherwise.</p>\n\n<p style=\"margin-left:11%;\">cdata</p>\n\n<p style=\"margin-left:17%;\">Return the text of a\n&quot;CDATA&quot; element or &quot;undef&quot; if the\nelement is not &quot;CDATA&quot;.</p>\n\n<p style=\"margin-left:11%;\">cdata_string</p>\n\n<p style=\"margin-left:17%;\">Return the <small>XML</small>\nstring of a &quot;CDATA&quot; element, including the opening\nand closing markers.</p>\n\n<p style=\"margin-left:11%;\">set_cdata ($text)</p>\n\n<p style=\"margin-left:17%;\">Set the text of a\n&quot;CDATA&quot; element.</p>\n\n<p style=\"margin-left:11%;\">append_cdata ($text)</p>\n\n<p style=\"margin-left:17%;\">Add the text at the end of a\n&quot;CDATA&quot; element.</p>\n\n<p style=\"margin-left:11%;\">remove_cdata</p>\n\n<p style=\"margin-left:17%;\">Turns all &quot;CDATA&quot;\nsections in the element into regular &quot;PCDATA&quot;\nelements. This is useful when converting <small>XML</small>\nto <small>HTML,</small> as browsers do not support\n<small>CDATA</small> sections.</p>\n\n<p style=\"margin-left:11%;\">extra_data</p>\n\n<p style=\"margin-left:17%;\">Return the extra_data (comments\nand <small>PI</small> &rsquo;s) attached to an element</p>\n\n<p style=\"margin-left:11%;\">set_extra_data\n($extra_data)</p>\n\n<p style=\"margin-left:17%;\">Set the extra_data (comments\nand <small>PI</small> &rsquo;s) attached to an element</p>\n\n<p style=\"margin-left:11%;\">append_extra_data\n($extra_data)</p>\n\n<p style=\"margin-left:17%;\">Append extra_data to the\nexisting extra_data before the element (if no previous\nextra_data exists then it is created)</p>\n\n<p style=\"margin-left:11%;\">set_asis</p>\n\n<p style=\"margin-left:17%;\">Set a property of the element\nthat causes it to be output without being <small>XML</small>\nescaped by the print functions: if it contains &quot;a &lt;\nb&quot; it will be output as such and not as &quot;a\n&amp;lt; b&quot;. This can be useful to create text elements\nthat will be output as markup. Note that all\n&quot;PCDATA&quot; descendants of the element are also\nmarked as having the property (they are the ones that are\nactually impacted by the change).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the element\nis a &quot;CDATA&quot; element it will also be output asis,\nwithout the &quot;CDATA&quot; markers. The same goes for any\n&quot;CDATA&quot; descendant of the element</p>\n\n<p style=\"margin-left:11%;\">set_not_asis</p>\n\n<p style=\"margin-left:17%;\">Unsets the &quot;asis&quot;\nproperty for the element and its text descendants.</p>\n\n<p style=\"margin-left:11%;\">is_asis</p>\n\n<p style=\"margin-left:17%;\">Return the &quot;asis&quot;\nproperty status of the element ( 1 or &quot;undef&quot;)</p>\n\n<p style=\"margin-left:11%;\">closed</p>\n\n<p style=\"margin-left:17%;\">Return true if the element has\nbeen closed. Might be useful if you are somewhere in the\ntree, during the parse, and have no idea whether a parent\nelement is completely loaded or not.</p>\n\n<p style=\"margin-left:11%;\">get_type</p>\n\n<p style=\"margin-left:17%;\">Return the type of the element:\n&rsquo;&quot;#ELT&quot;&rsquo; for &quot;real&quot;\nelements, or &rsquo;&quot;#PCDATA&quot;&rsquo;,\n&rsquo;&quot;#CDATA&quot;&rsquo;,\n&rsquo;&quot;#COMMENT&quot;&rsquo;,\n&rsquo;&quot;#ENT&quot;&rsquo;,\n&rsquo;&quot;#PI&quot;&rsquo;</p>\n\n<p style=\"margin-left:11%;\">is_elt</p>\n\n<p style=\"margin-left:17%;\">Return the tag if the element\nis a &quot;real&quot; element, or 0 if it is\n&quot;PCDATA&quot;, &quot;CDATA&quot;...</p>\n\n<p style=\"margin-left:11%;\">contains_only_text</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element does\nnot contain any other &quot;real&quot; element</p>\n\n<p style=\"margin-left:11%;\">contains_only ($exp)</p>\n\n<p style=\"margin-left:17%;\">Return the list of children if\nall children of the element match the expression $exp</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if(\n$para-&gt;contains_only( 'tt')) { ... }</p>\n\n<p style=\"margin-left:11%;\">contains_a_single ($exp)</p>\n\n<p style=\"margin-left:17%;\">If the element contains a\nsingle child that matches the expression $exp returns that\nelement. Otherwise returns 0.</p>\n\n<p style=\"margin-left:11%;\">is_field</p>\n\n<p style=\"margin-left:17%;\">same as\n&quot;contains_only_text&quot;</p>\n\n<p style=\"margin-left:11%;\">is_pcdata</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element is a\n&quot;PCDATA&quot; element, returns 0 otherwise.</p>\n\n<p style=\"margin-left:11%;\">is_ent</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element is an\nentity (an unexpanded entity) element, return 0\notherwise.</p>\n\n<p style=\"margin-left:11%;\">is_empty</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element is\nempty, 0 otherwise</p>\n\n<p style=\"margin-left:11%;\">set_empty</p>\n\n<p style=\"margin-left:17%;\">Flags the element as empty. No\nfurther check is made, so if the element is actually not\nempty the output will be messed. The only effect of this\nmethod is that the output will be &quot;&lt;tag\natt=&quot;value&quot;&quot;/&gt;&quot;.</p>\n\n<p style=\"margin-left:11%;\">set_not_empty</p>\n\n<p style=\"margin-left:17%;\">Flags the element as not empty.\nif it is actually empty then the element will be output as\n&quot;&lt;tag\natt=&quot;value&quot;&quot;&gt;&lt;/tag&gt;&quot;</p>\n\n<p style=\"margin-left:11%;\">is_pi</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element is a\nprocessing instruction (&quot;#PI&quot;) element, return 0\notherwise.</p>\n\n<p style=\"margin-left:11%;\">target</p>\n\n<p style=\"margin-left:17%;\">Return the target of a\nprocessing instruction</p>\n\n<p style=\"margin-left:11%;\">set_target ($target)</p>\n\n<p style=\"margin-left:17%;\">Set the target of a processing\ninstruction</p>\n\n<p style=\"margin-left:11%;\">data</p>\n\n<p style=\"margin-left:17%;\">Return the data part of a\nprocessing instruction</p>\n\n<p style=\"margin-left:11%;\">set_data ($data)</p>\n\n<p style=\"margin-left:17%;\">Set the data of a processing\ninstruction</p>\n\n<p style=\"margin-left:11%;\">set_pi ($target, $data)</p>\n\n<p style=\"margin-left:17%;\">Set the target and data of a\nprocessing instruction</p>\n\n<p style=\"margin-left:11%;\">pi_string</p>\n\n<p style=\"margin-left:17%;\">Return the string form of a\nprocessing instruction (&quot;&lt;?target\ndata?&gt;&quot;)</p>\n\n<p style=\"margin-left:11%;\">is_comment</p>\n\n<p style=\"margin-left:17%;\">Return 1 if the element is a\ncomment (&quot;#COMMENT&quot;) element, return 0\notherwise.</p>\n\n<p style=\"margin-left:11%;\">set_comment ($comment_text)</p>\n\n<p style=\"margin-left:17%;\">Set the text for a comment</p>\n\n<p style=\"margin-left:11%;\">comment</p>\n\n<p style=\"margin-left:17%;\">Return the content of a comment\n(just the text, not the &quot;&lt;!--&quot; and\n&quot;--&gt;&quot;)</p>\n\n<p style=\"margin-left:11%;\">comment_string</p>\n\n<p style=\"margin-left:17%;\">Return the <small>XML</small>\nstring for a comment (&quot;&lt;!-- comment\n--&gt;&quot;)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that an\n<small>XML</small> comment cannot start or end with a\n&rsquo;-&rsquo;, or include &rsquo;--&rsquo;\n(http://www.w3.org/TR/2008/REC-xml-20081126/#sec-comments),\nif that is the case (because you have created the comment\nyourself presumably, as it could not be in the input\n<small>XML</small> ), then a space will be inserted before\nan initial &rsquo;-&rsquo;, after a trailing one or between\ntwo &rsquo;-&rsquo; in the comment (which could presumably\nmangle javascript &quot;hidden&quot; in an\n<small>XHTML</small> comment);</p>\n\n<p style=\"margin-left:11%;\">set_ent ($entity)</p>\n\n<p style=\"margin-left:17%;\">Set an (non-expanded) entity\n(&quot;#ENT&quot;). $entity) is the entity text\n(&quot;&amp;ent;&quot;)</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>ent</p></td>\n<td width=\"2%\"></td>\n<td width=\"83%\">\n\n\n<p>Return the entity for an entity (&quot;#ENT&quot;)\nelement (&quot;&amp;ent;&quot;)</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">ent_name</p>\n\n<p style=\"margin-left:17%;\">Return the entity name for an\nentity (&quot;#ENT&quot;) element (&quot;ent&quot;)</p>\n\n<p style=\"margin-left:11%;\">ent_string</p>\n\n<p style=\"margin-left:17%;\">Return the entity, either\nexpanded if the expanded version is available, or\nnon-expanded (&quot;&amp;ent;&quot;) otherwise</p>\n\n<p style=\"margin-left:11%;\">child ($offset,\n$optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the $offset-th child of\nthe element, optionally the $offset-th child that matches\n$optional_condition. The children are treated as a list, so\n&quot;$elt-&gt;child( 0)&quot; is the first child, while\n&quot;$elt-&gt;child( -1)&quot; is the last child.</p>\n\n<p style=\"margin-left:11%;\">child_text ($offset,\n$optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the text of a child or\n&quot;undef&quot; if the sibling does not exist. Arguments\nare the same as child.</p>\n\n<p style=\"margin-left:11%;\">last_child\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the last child of the\nelement, or the last child matching $optional_condition (ie\nthe last of the element children matching the\ncondition).</p>\n\n<p style=\"margin-left:11%;\">last_child_text\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Same as\n&quot;first_child_text&quot; but for the last child.</p>\n\n<p style=\"margin-left:11%;\">sibling ($offset,\n$optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the next or previous\n$offset-th sibling of the element, or the $offset-th one\nmatching $optional_condition. If $offset is negative then a\nprevious sibling is returned, if $offset is positive then a\nnext sibling is returned. &quot;$offset=0&quot; returns the\nelement if there is no condition or if the element matches\nthe condition&gt;, &quot;undef&quot; otherwise.</p>\n\n<p style=\"margin-left:11%;\">sibling_text ($offset,\n$optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the text of a sibling or\n&quot;undef&quot; if the sibling does not exist. Arguments\nare the same as &quot;sibling&quot;.</p>\n\n<p style=\"margin-left:11%;\">prev_siblings\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the list of previous\nsiblings (optionally matching $optional_condition) for the\nelement. The elements are ordered in document order.</p>\n\n<p style=\"margin-left:11%;\">next_siblings\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the list of siblings\n(optionally matching $optional_condition) following the\nelement. The elements are ordered in document order.</p>\n\n<p style=\"margin-left:11%;\">siblings\n($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the list of siblings\n(optionally matching $optional_condition) of the element\n(excluding the element itself). The elements are ordered in\ndocument order.</p>\n\n<p style=\"margin-left:11%;\">pos ($optional_condition)</p>\n\n<p style=\"margin-left:17%;\">Return the position of the\nelement in the children list. The first child has a position\nof 1 (as in XPath).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the\n$optional_condition is given then only siblings that match\nthe condition are counted. If the element itself does not\nmatch the condition then 0 is returned.</p>\n\n<p style=\"margin-left:11%;\">atts</p>\n\n<p style=\"margin-left:17%;\">Return a hash ref containing\nthe element attributes</p>\n\n<p style=\"margin-left:11%;\">set_atts ({ att1=&gt;$att1_val,\natt2=&gt; $att2_val... })</p>\n\n<p style=\"margin-left:17%;\">Set the element attributes with\nthe hash ref supplied as the argument. The previous\nattributes are lost (ie the attributes set by\n&quot;set_atts&quot; replace all of the attributes of the\nelement).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can also\npass a list instead of a hashref: &quot;$elt-&gt;set_atts(\natt1 =&gt; 'val1',...)&quot;</p>\n\n<p style=\"margin-left:11%;\">del_atts</p>\n\n<p style=\"margin-left:17%;\">Deletes all the element\nattributes.</p>\n\n<p style=\"margin-left:11%;\">att_nb</p>\n\n<p style=\"margin-left:17%;\">Return the number of attributes\nfor the element</p>\n\n<p style=\"margin-left:11%;\">has_atts</p>\n\n<p style=\"margin-left:17%;\">Return true if the element has\nattributes (in fact return the number of attributes, thus\nbeing an alias to &quot;att_nb&quot;</p>\n\n<p style=\"margin-left:11%;\">has_no_atts</p>\n\n<p style=\"margin-left:17%;\">Return true if the element has\nno attributes, false (0) otherwise</p>\n\n<p style=\"margin-left:11%;\">att_names</p>\n\n<p style=\"margin-left:17%;\">return a list of the attribute\nnames for the element</p>\n\n<p style=\"margin-left:11%;\">att_xml_string ($att,\n$options)</p>\n\n<p style=\"margin-left:17%;\">Return the attribute value,\nwhere &rsquo;&amp;&rsquo;, &rsquo;&lt;&rsquo; and quote\n(&quot; or the value of the quote option at twig creation)\nare XML-escaped.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The options are\npassed as a hashref, setting &quot;escape_gt&quot; to a true\nvalue will also escape &rsquo;&gt;&rsquo; ($elt(\n&rsquo;myatt&rsquo;, { escape_gt =&gt; 1 });</p>\n\n<p style=\"margin-left:11%;\">set_id ($id)</p>\n\n<p style=\"margin-left:17%;\">Set the &quot;id&quot;\nattribute of the element to the value. See &quot;elt_id\n&quot; to change the id attribute name</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>id</p></td>\n<td width=\"3%\"></td>\n<td width=\"41%\">\n\n\n<p>Gets the id attribute value</p></td>\n<td width=\"42%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">del_id ($id)</p>\n\n<p style=\"margin-left:17%;\">Deletes the &quot;id&quot;\nattribute of the element and remove it from the id list for\nthe document</p>\n\n<p style=\"margin-left:11%;\">class</p>\n\n<p style=\"margin-left:17%;\">Return the &quot;class&quot;\nattribute for the element (methods on the &quot;class&quot;\nattribute are quite convenient when dealing with\n<small>XHTML,</small> or plain <small>XML</small> that will\neventually be displayed using <small>CSS</small> )</p>\n\n<p style=\"margin-left:11%;\">lclass</p>\n\n<p style=\"margin-left:17%;\">same as class, except that this\nmethod is an lvalue, so you can do &quot;$elt-&gt;lclass=\n&quot;foo&quot;&quot;</p>\n\n<p style=\"margin-left:11%;\">set_class ($class)</p>\n\n<p style=\"margin-left:17%;\">Set the &quot;class&quot;\nattribute for the element to $class</p>\n\n<p style=\"margin-left:11%;\">add_class ($class)</p>\n\n<p style=\"margin-left:17%;\">Add $class to the element\n&quot;class&quot; attribute: the new class is added only if\nit is not already present.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\nclasses are then sorted alphabetically, so the\n&quot;class&quot; attribute can be changed even if the class\nis already there</p>\n\n<p style=\"margin-left:11%;\">remove_class ($class)</p>\n\n<p style=\"margin-left:17%;\">Remove $class from the element\n&quot;class&quot; attribute.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\nclasses are then sorted alphabetically, so the\n&quot;class&quot; attribute can be changed even if the class\nis already there</p>\n\n<p style=\"margin-left:11%;\">add_to_class ($class)</p>\n\n<p style=\"margin-left:17%;\">alias for add_class</p>\n\n<p style=\"margin-left:11%;\">att_to_class ($att)</p>\n\n<p style=\"margin-left:17%;\">Set the &quot;class&quot;\nattribute to the value of attribute $att</p>\n\n<p style=\"margin-left:11%;\">add_att_to_class ($att)</p>\n\n<p style=\"margin-left:17%;\">Add the value of attribute $att\nto the &quot;class&quot; attribute of the element</p>\n\n<p style=\"margin-left:11%;\">move_att_to_class ($att)</p>\n\n<p style=\"margin-left:17%;\">Add the value of attribute $att\nto the &quot;class&quot; attribute of the element and delete\nthe attribute</p>\n\n<p style=\"margin-left:11%;\">tag_to_class</p>\n\n<p style=\"margin-left:17%;\">Set the &quot;class&quot;\nattribute of the element to the element tag</p>\n\n<p style=\"margin-left:11%;\">add_tag_to_class</p>\n\n<p style=\"margin-left:17%;\">Add the element tag to its\n&quot;class&quot; attribute</p>\n\n<p style=\"margin-left:11%;\">set_tag_class ($new_tag)</p>\n\n<p style=\"margin-left:17%;\">Add the element tag to its\n&quot;class&quot; attribute and sets the tag to $new_tag</p>\n\n<p style=\"margin-left:11%;\">in_class ($class)</p>\n\n<p style=\"margin-left:17%;\">Return true (1) if the element\nis in the class $class (if $class is one of the tokens in\nthe element &quot;class&quot; attribute)</p>\n\n<p style=\"margin-left:11%;\">tag_to_span</p>\n\n<p style=\"margin-left:17%;\">Change the element tag tp\n&quot;span&quot; and set its class to the old tag</p>\n\n<p style=\"margin-left:11%;\">tag_to_div</p>\n\n<p style=\"margin-left:17%;\">Change the element tag tp\n&quot;div&quot; and set its class to the old tag</p>\n\n<p style=\"margin-left:11%;\"><small>DESTROY</small></p>\n\n<p style=\"margin-left:17%;\">Frees the element from\nmemory.</p>\n\n<p style=\"margin-left:11%;\">start_tag</p>\n\n<p style=\"margin-left:17%;\">Return the string for the start\ntag for the element, including the &quot;/&gt;&quot; at the\nend of an empty element tag</p>\n\n<p style=\"margin-left:11%;\">end_tag</p>\n\n<p style=\"margin-left:17%;\">Return the string for the end\ntag of an element. For an empty element, this returns the\nempty string (&rsquo;&rsquo;).</p>\n\n<p style=\"margin-left:11%;\">xml_string\n@optional_options</p>\n\n<p style=\"margin-left:17%;\">Equivalent to\n&quot;$elt-&gt;sprint( 1)&quot;, returns the string for the\nentire element, excluding the element&rsquo;s tags (but\nnested element tags are present)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n&rsquo;&quot;no_recurse&quot;&rsquo; option will only return\nthe text of the element, not of any included sub-elements\n(same as &quot;xml_text_only&quot;).</p>\n\n<p style=\"margin-left:11%;\">inner_xml</p>\n\n<p style=\"margin-left:17%;\">Another synonym for\nxml_string</p>\n\n<p style=\"margin-left:11%;\">outer_xml</p>\n\n<p style=\"margin-left:17%;\">Another synonym for sprint</p>\n\n<p style=\"margin-left:11%;\">xml_text</p>\n\n<p style=\"margin-left:17%;\">Return the text of the element,\nencoded (and processed by the current\n&quot;output_filter&quot; or &quot;output_encoding&quot;\noptions, without any tag.</p>\n\n<p style=\"margin-left:11%;\">xml_text_only</p>\n\n<p style=\"margin-left:17%;\">Same as &quot;xml_text&quot;\nexcept that the text returned doesn&rsquo;t include the text\nof sub-elements.</p>\n\n<p style=\"margin-left:11%;\">set_pretty_print ($style)</p>\n\n<p style=\"margin-left:17%;\">Set the pretty print method,\namongst &rsquo;&quot;none&quot;&rsquo; (default),\n&rsquo;&quot;nsgmls&quot;&rsquo;,\n&rsquo;&quot;nice&quot;&rsquo;,\n&rsquo;&quot;indented&quot;&rsquo;,\n&rsquo;&quot;record&quot;&rsquo; and\n&rsquo;&quot;record_c&quot;&rsquo;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">pretty_print\nstyles: <br>\nnone</p>\n\n<p style=\"margin-left:23%;\">the default, no &quot;\\n&quot;\nis used</p>\n\n<p style=\"margin-left:17%;\">nsgmls</p>\n\n<p style=\"margin-left:23%;\">nsgmls style, with\n&quot;\\n&quot; added within tags</p>\n\n<p style=\"margin-left:17%;\">nice</p>\n\n<p style=\"margin-left:23%;\">adds &quot;\\n&quot; wherever\npossible ( <small>NOT SAFE,</small> can lead to invalid\n<small>XML</small> )</p>\n\n<p style=\"margin-left:17%;\">indented</p>\n\n<p style=\"margin-left:23%;\">same as &quot;nice&quot; plus\nindents elements ( <small>NOT SAFE,</small> can lead to\ninvalid <small>XML</small> )</p>\n\n<p style=\"margin-left:17%;\">record</p>\n\n<p style=\"margin-left:23%;\">table-oriented pretty print,\none field per line</p>\n\n<p style=\"margin-left:17%;\">record_c</p>\n\n<p style=\"margin-left:23%;\">table-oriented pretty print,\nmore compact than &quot;record&quot;, one record per\nline</p>\n\n<p style=\"margin-left:11%;\">set_empty_tag_style\n($style)</p>\n\n<p style=\"margin-left:17%;\">Set the method to output empty\ntags, amongst &rsquo;&quot;normal&quot;&rsquo; (default),\n&rsquo;&quot;html&quot;&rsquo;, and\n&rsquo;&quot;expand&quot;&rsquo;,</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&quot;normal&quot;\noutputs an empty tag &rsquo;&quot;&lt;tag/&gt;&quot;&rsquo;,\n&quot;html&quot; adds a space &rsquo;&quot;&lt;tag\n/&gt;&quot;&rsquo; for elements that can be empty in\n<small>XHTML</small> and &quot;expand&quot; outputs\n&rsquo;&quot;&lt;tag&gt;&lt;/tag&gt;&quot;&rsquo;</p>\n\n<p style=\"margin-left:11%;\">set_remove_cdata ($flag)</p>\n\n<p style=\"margin-left:17%;\">set (or unset) the flag that\nforces the twig to output <small>CDATA</small> sections as\nregular (escaped) <small>PCDATA</small></p>\n\n<p style=\"margin-left:11%;\">set_indent ($string)</p>\n\n<p style=\"margin-left:17%;\">Set the indentation for the\nindented pretty print style (default is 2 spaces)</p>\n\n<p style=\"margin-left:11%;\">set_quote ($quote)</p>\n\n<p style=\"margin-left:17%;\">Set the quotes used for\nattributes. can be &rsquo;&quot;double&quot;&rsquo;\n(default) or &rsquo;&quot;single&quot;&rsquo;</p>\n\n<p style=\"margin-left:11%;\">cmp ($elt)</p>\n\n<p style=\"margin-left:17%;\">Compare the order of the 2\nelements in a twig. <br>\nC&lt;$a&gt; is the &lt;A&gt;..&lt;/A&gt; element,\nC&lt;$b&gt; is the &lt;B&gt;...&lt;/B&gt; element <br>\ndocument $a-&gt;cmp( $b) <br>\n&lt;A&gt; ... &lt;/A&gt; ... &lt;B&gt; ... &lt;/B&gt; -1\n<br>\n&lt;A&gt; ... &lt;B&gt; ... &lt;/B&gt; ... &lt;/A&gt; -1\n<br>\n&lt;B&gt; ... &lt;/B&gt; ... &lt;A&gt; ... &lt;/A&gt; 1 <br>\n&lt;B&gt; ... &lt;A&gt; ... &lt;/A&gt; ... &lt;/B&gt; 1 <br>\n$a == $b 0 <br>\n$a and $b not in the same tree undef</p>\n\n<p style=\"margin-left:11%;\">before ($elt)</p>\n\n<p style=\"margin-left:17%;\">Return 1 if $elt starts before\nthe element, 0 otherwise. If the 2 elements are not in the\nsame twig then return &quot;undef&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if( $a-&gt;cmp(\n$b) == -1) { return 1; } else { return 0; }</p>\n\n<p style=\"margin-left:11%;\">after ($elt)</p>\n\n<p style=\"margin-left:17%;\">Return 1 if $elt starts after\nthe element, 0 otherwise. If the 2 elements are not in the\nsame twig then return &quot;undef&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if( $a-&gt;cmp(\n$b) == -1) { return 1; } else { return 0; }</p>\n\n<p style=\"margin-left:11%;\">other comparison methods</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p>lt</p></td>\n<td width=\"80%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p>le</p></td>\n<td width=\"80%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p>gt</p></td>\n<td width=\"80%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"17%\"></td>\n<td width=\"3%\">\n\n\n<p>ge</p></td>\n<td width=\"80%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">path</p>\n\n<p style=\"margin-left:17%;\">Return the element context in a\nform similar to XPath&rsquo;s short form:\n&rsquo;&quot;/root/tag1/../tag&quot;&rsquo;</p>\n\n<p style=\"margin-left:11%;\">xpath</p>\n\n<p style=\"margin-left:17%;\">Return a unique XPath\nexpression that can be used to find the element again.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">It looks like\n&quot;/doc/sect[3]/title&quot;: unique elements do not have\nan index, the others do.</p>\n\n<p style=\"margin-left:11%;\">flush</p>\n\n<p style=\"margin-left:17%;\">flushes the twig up to the\ncurrent element (strictly equivalent to\n&quot;$elt-&gt;root-&gt;flush&quot;)</p>\n\n<p style=\"margin-left:11%;\">private methods</p>\n\n<p style=\"margin-left:17%;\">Low-level methods on the twig:\n<br>\nset_parent ($parent) <br>\nset_first_child ($first_child) <br>\nset_last_child ($last_child) <br>\nset_prev_sibling ($prev_sibling) <br>\nset_next_sibling ($next_sibling) <br>\nset_twig_current <br>\ndel_twig_current <br>\ntwig_current <br>\ncontains_text</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Those methods\nshould not be used, unless of course you find some creative\nand interesting, not to mention useful, ways to do it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>cond</b>\n<br>\nMost of the navigation functions accept a condition as an\noptional argument The first element (or all elements for\n&quot;children &quot; or &quot;ancestors &quot;) that passes\nthe condition is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The condition\nis a single step of an XPath expression using the XPath\nsubset defined by &quot;get_xpath&quot;. Additional\nconditions are:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The condition\ncan be <br>\n#ELT</p>\n\n<p style=\"margin-left:17%;\">return a &quot;real&quot;\nelement (not a <small>PCDATA, CDATA,</small> comment or pi\nelement)</p>\n\n<p style=\"margin-left:11%;\">#TEXT</p>\n\n<p style=\"margin-left:17%;\">return a <small>PCDATA</small>\nor <small>CDATA</small> element</p>\n\n<p style=\"margin-left:11%;\">regular expression</p>\n\n<p style=\"margin-left:17%;\">return an element whose tag\nmatches the regexp. The regexp has to be created with\n&quot;qr//&quot; (hence this is available only on perl 5.005\nand above)</p>\n\n<p style=\"margin-left:11%;\">code reference</p>\n\n<p style=\"margin-left:17%;\">applies the code, passing the\ncurrent element as argument, if the code returns true then\nthe element is returned, if it returns false then the code\nis applied to the next candidate.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig::XPath</b>\n<br>\nXML::Twig implements a subset of XPath through the\n&quot;get_xpath&quot; method.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want to\nuse the whole XPath power, then you can use\n&quot;XML::Twig::XPath&quot; instead. In this case\n&quot;XML::Twig&quot; uses &quot;XML::XPath&quot; to execute\nXPath queries. You will of course need\n&quot;XML::XPath&quot; installed to be able to use\n&quot;XML::Twig::XPath&quot;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See XML::XPath\nfor more information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The methods you\ncan use are: <br>\nfindnodes ($path)</p>\n\n<p style=\"margin-left:17%;\">return a list of nodes found by\n$path.</p>\n\n<p style=\"margin-left:11%;\">findnodes_as_string ($path)</p>\n\n<p style=\"margin-left:17%;\">return the nodes found\nreproduced as <small>XML.</small> The result is not\nguaranteed to be valid <small>XML</small> though.</p>\n\n<p style=\"margin-left:11%;\">findvalue ($path)</p>\n\n<p style=\"margin-left:17%;\">return the concatenation of the\ntext content of the result nodes</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In order for\n&quot;XML::XPath&quot; to be used as the XPath engine the\nfollowing methods are included in &quot;XML::Twig&quot;:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">in XML::Twig\n<br>\ngetRootNode <br>\ngetParentNode <br>\ngetChildNodes</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">in\nXML::Twig::Elt <br>\nstring_value <br>\ntoString <br>\ngetName <br>\ngetRootNode <br>\ngetNextSibling <br>\ngetPreviousSibling <br>\nisElementNode <br>\nisTextNode <br>\nisPI <br>\nisPINode <br>\nisProcessingInstructionNode <br>\nisComment <br>\nisCommentNode <br>\ngetTarget <br>\ngetChildNodes <br>\ngetElementById</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig::XPath::Elt</b>\n<br>\nThe methods you can use are the same as on\n&quot;XML::Twig::XPath&quot; elements: <br>\nfindnodes ($path)</p>\n\n<p style=\"margin-left:17%;\">return a list of nodes found by\n$path.</p>\n\n<p style=\"margin-left:11%;\">findnodes_as_string ($path)</p>\n\n<p style=\"margin-left:17%;\">return the nodes found\nreproduced as <small>XML.</small> The result is not\nguaranteed to be valid <small>XML</small> though.</p>\n\n<p style=\"margin-left:11%;\">findvalue ($path)</p>\n\n<p style=\"margin-left:17%;\">return the concatenation of the\ntext content of the result nodes</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig::Entity_list</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>new</p></td>\n<td width=\"2%\"></td>\n<td width=\"34%\">\n\n\n<p>Create an entity list.</p></td>\n<td width=\"49%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">add ($ent)</p>\n\n<p style=\"margin-left:17%;\">Add an entity to an entity\nlist.</p>\n\n<p style=\"margin-left:11%;\">add_new_ent ($name, $val,\n$sysid, $pubid, $ndata, $param)</p>\n\n<p style=\"margin-left:17%;\">Create a new entity and add it\nto the entity list</p>\n\n<p style=\"margin-left:11%;\">delete ($ent or $tag).</p>\n\n<p style=\"margin-left:17%;\">Delete an entity (defined by\nits name or by the Entity object) from the list.</p>\n\n<p style=\"margin-left:11%;\">print\n($optional_filehandle)</p>\n\n<p style=\"margin-left:17%;\">Print the entity list.</p>\n\n<p style=\"margin-left:11%;\">list</p>\n\n<p style=\"margin-left:17%;\">Return the list as an array</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig::Entity</b>\n<br>\nnew ($name, $val, $sysid, $pubid, $ndata, $param)</p>\n\n<p style=\"margin-left:17%;\">Same arguments as the Entity\nhandler for XML::Parser.</p>\n\n<p style=\"margin-left:11%;\">print\n($optional_filehandle)</p>\n\n<p style=\"margin-left:17%;\">Print an entity\ndeclaration.</p>\n\n<p style=\"margin-left:11%;\">name</p>\n\n<p style=\"margin-left:17%;\">Return the name of the\nentity</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>val</p></td>\n<td width=\"2%\"></td>\n<td width=\"46%\">\n\n\n<p>Return the value of the entity</p></td>\n<td width=\"37%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">sysid</p>\n\n<p style=\"margin-left:17%;\">Return the system id for the\nentity (for <small>NDATA</small> entities)</p>\n\n<p style=\"margin-left:11%;\">pubid</p>\n\n<p style=\"margin-left:17%;\">Return the public id for the\nentity (for <small>NDATA</small> entities)</p>\n\n<p style=\"margin-left:11%;\">ndata</p>\n\n<p style=\"margin-left:17%;\">Return true if the entity is an\n<small>NDATA</small> entity</p>\n\n<p style=\"margin-left:11%;\">param</p>\n\n<p style=\"margin-left:17%;\">Return true if the entity is a\nparameter entity</p>\n\n<p style=\"margin-left:11%;\">text</p>\n\n<p style=\"margin-left:17%;\">Return the entity declaration\ntext.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig::Notation_list</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p>new</p></td>\n<td width=\"2%\"></td>\n<td width=\"37%\">\n\n\n<p>Create an notation list.</p></td>\n<td width=\"46%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">add ($notation)</p>\n\n<p style=\"margin-left:17%;\">Add an notation to an notation\nlist.</p>\n\n<p style=\"margin-left:11%;\">add_new_notation ($name, $base,\n$sysid, $pubid)</p>\n\n<p style=\"margin-left:17%;\">Create a new notation and add\nit to the notation list</p>\n\n<p style=\"margin-left:11%;\">delete ($notation or $tag).</p>\n\n<p style=\"margin-left:17%;\">Delete an notation (defined by\nits name or by the Notation object) from the list.</p>\n\n<p style=\"margin-left:11%;\">print\n($optional_filehandle)</p>\n\n<p style=\"margin-left:17%;\">Print the notation list.</p>\n\n<p style=\"margin-left:11%;\">list</p>\n\n<p style=\"margin-left:17%;\">Return the list as an array</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>XML::Twig::Notation</b>\n<br>\nnew ($name, $base, $sysid, $pubid)</p>\n\n<p style=\"margin-left:17%;\">Same argumnotations as the\nNotation handler for XML::Parser.</p>\n\n<p style=\"margin-left:11%;\">print\n($optional_filehandle)</p>\n\n<p style=\"margin-left:17%;\">Print an notation\ndeclaration.</p>\n\n<p style=\"margin-left:11%;\">name</p>\n\n<p style=\"margin-left:17%;\">Return the name of the\nnotation</p>\n\n<p style=\"margin-left:11%;\">base</p>\n\n<p style=\"margin-left:17%;\">Return the base to be used for\nresolving a relative <small>URI</small></p>\n\n<p style=\"margin-left:11%;\">sysid</p>\n\n<p style=\"margin-left:17%;\">Return the system id for the\nnotation</p>\n\n<p style=\"margin-left:11%;\">pubid</p>\n\n<p style=\"margin-left:17%;\">Return the public id for the\nnotation</p>\n\n<p style=\"margin-left:11%;\">text</p>\n\n<p style=\"margin-left:17%;\">Return the notation declaration\ntext.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\nexamples (and a complete tutorial) can be found on the\n<i>XML::Twig\nPage&lt;http://www.xmltwig.org/xmltwig/&gt;</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To figure out\nwhat flush does call the following script with an\n<small>XML</small> file and an element name as arguments</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use XML::Twig;\n<br>\nmy ($file, $elt)= @ARGV; <br>\nmy $t= XML::Twig-&gt;new( twig_handlers =&gt; <br>\n{ $elt =&gt; sub {$_[0]-&gt;flush; print &quot;\\n[flushed\nhere]\\n&quot;;} }); <br>\n$t-&gt;parsefile( $file, ErrorContext =&gt; 2); <br>\n$t-&gt;flush; <br>\nprint &quot;\\n&quot;;</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Subclassing\nXML::Twig</b> <br>\nUseful methods: <br>\nelt_class</p>\n\n<p style=\"margin-left:17%;\">In order to subclass\n&quot;XML::Twig&quot; you will probably need to subclass\nalso &quot;XML::Twig::Elt&quot;. Use the\n&quot;elt_class&quot; option when you create the\n&quot;XML::Twig&quot; object to get the elements created in\na different class (which should be a subclass of\n&quot;XML::Twig::Elt&quot;.</p>\n\n<p style=\"margin-left:11%;\">add_options</p>\n\n<p style=\"margin-left:17%;\">If you inherit\n&quot;XML::Twig&quot; new method but want to add more\noptions to it you can use this method to prevent XML::Twig\nto issue warnings for those additional options.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>DTD</small>\nHandling</b> <br>\nThere are 3 possibilities here. They are: <br>\nNo <small>DTD</small></p>\n\n<p style=\"margin-left:17%;\">No doctype, no\n<small>DTD</small> information, no entity information, the\nworld is simple...</p>\n\n<p style=\"margin-left:11%;\">Internal <small>DTD</small></p>\n\n<p style=\"margin-left:17%;\">The <small>XML</small> document\nincludes an internal <small>DTD,</small> and maybe entity\ndeclarations.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you use the\nload_DTD option when creating the twig the\n<small>DTD</small> information and the entity declarations\ncan be accessed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The\n<small>DTD</small> and the entity declarations will be\n&quot;flush&quot;&rsquo;ed (or &quot;print&quot;&rsquo;ed)\neither as is (if they have not been modified) or as\nreconstructed (poorly, comments are lost, order is not kept,\ndue to it&rsquo;s content this <small>DTD</small> should not\nbe viewed by anyone) if they have been modified. You can\nalso modify them directly by changing the\n&quot;$twig-&gt;{twig_doctype}-&gt;{internal}&quot; field\n(straight from XML::Parser, see the &quot;Doctype&quot;\nhandler doc)</p>\n\n<p style=\"margin-left:11%;\">External <small>DTD</small></p>\n\n<p style=\"margin-left:17%;\">The <small>XML</small> document\nincludes a reference to an external <small>DTD,</small> and\nmaybe entity declarations.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you use the\n&quot;load_DTD&quot; when creating the twig the\n<small>DTD</small> information and the entity declarations\ncan be accessed. The entity declarations will be\n&quot;flush&quot;&rsquo;ed (or &quot;print&quot;&rsquo;ed)\neither as is (if they have not been modified) or as\nreconstructed (badly, comments are lost, order is not\nkept).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can change\nthe doctype through the &quot;$twig-&gt;set_doctype&quot;\nmethod and print the dtd through the\n&quot;$twig-&gt;dtd_text&quot; or\n&quot;$twig-&gt;dtd_print&quot; <br>\nmethods.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you need to\nmodify the entity list this is probably the easiest way to\ndo it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Flush</b>\n<br>\nRemember that element handlers are called when the element\nis <small>CLOSED,</small> so if you have handlers for nested\nelements the inner handlers will be called first. It makes\nit for example trickier than it would seem to number nested\nsections (or clauses, or divs), as the titles in the inner\nsections are handled before the outer sections.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">segfault during\nparsing</p>\n\n<p style=\"margin-left:17%;\">This happens when parsing huge\ndocuments, or lots of small ones, with a version of Perl\nbefore 5.16.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This is due to\na bug in the way weak references are handled in Perl\nitself.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The fix is\neither to upgrade to Perl 5.16 or later\n(&quot;perlbrew&quot; is a great tool to manage several\ninstallations of perl on the same machine).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Another,\n<small>NOT RECOMMENDED,</small> way of fixing the problem,\nis to switch off weak references by writing\n&quot;XML::Twig::_set_weakrefs( 0);&quot; at the top of the\ncode. This is totally unsupported, and may lead to other\nproblems though,</p>\n\n<p style=\"margin-left:11%;\">entity handling</p>\n\n<p style=\"margin-left:17%;\">Due to XML::Parser behaviour,\nnon-base entities in attribute values disappear if they are\nnot declared in the document:\n&quot;att=&quot;val&amp;ent;&quot;&quot; will be turned into\n&quot;att =&gt; val&quot;, unless you use the\n&quot;keep_encoding&quot; argument to\n&quot;XML::Twig-&gt;new&quot;</p>\n\n<p style=\"margin-left:11%;\"><small>DTD</small> handling</p>\n\n<p style=\"margin-left:17%;\">The <small>DTD</small> handling\nmethods are quite bugged. No one uses them and it seems very\ndifficult to get them to work in all cases, including with\nseveral slightly incompatible versions of XML::Parser and of\nlibexpat.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Basically you\ncan read the <small>DTD,</small> output it back properly,\nand update entities, but not much more.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">So use\nXML::Twig with standalone documents, or with documents\nreferring to an external <small>DTD,</small> but don&rsquo;t\nexpect it to properly parse and even output back the\n<small>DTD.</small></p>\n\n<p style=\"margin-left:11%;\">memory leak</p>\n\n<p style=\"margin-left:17%;\">If you use a\n<small>REALLY</small> old Perl (5.005!) and a lot of twigs\nyou might find that you leak quite a lot of memory (about\n2Ks per twig). You can use the &quot;dispose &quot; method\nto free that memory after you are done.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you create\nelements the same thing might happen, use the\n&quot;delete&quot; method to get rid of them.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Alternatively\ninstalling the &quot;Scalar::Util&quot; (or\n&quot;WeakRef&quot;) module on a version of Perl that\nsupports it (&gt;5.6.0) will get rid of the memory leaks\nautomagically.</p>\n\n<p style=\"margin-left:11%;\"><small>ID</small> list</p>\n\n<p style=\"margin-left:17%;\">The <small>ID</small> list is\n<small>NOT</small> updated when elements are cut or\ndeleted.</p>\n\n<p style=\"margin-left:11%;\">change_gi</p>\n\n<p style=\"margin-left:17%;\">This method will not function\nproperly if you do:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$twig-&gt;change_gi(\n$old1, $new); <br>\n$twig-&gt;change_gi( $old2, $new); <br>\n$twig-&gt;change_gi( $new, $even_newer);</p>\n\n<p style=\"margin-left:11%;\">sanity check on XML::Parser\nmethod calls</p>\n\n<p style=\"margin-left:17%;\">XML::Twig should really prevent\ncalls to some XML::Parser methods, especially the\n&quot;setHandlers&quot; method.</p>\n\n<p style=\"margin-left:11%;\">pretty printing</p>\n\n<p style=\"margin-left:17%;\">Pretty printing (at least using\nthe &rsquo;&quot;indented&quot;&rsquo; style) is hard to get\nright! Only elements that belong to the document will be\nproperly indented. Printing elements that do not belong to\nthe twig makes it impossible for XML::Twig to figure out\ntheir depth, and thus their indentation level.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Also there is\nan unavoidable bug when using &quot;flush&quot; and pretty\nprinting for elements with mixed content that start with an\nembedded element:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&lt;elt&gt;&lt;b&gt;b&lt;/b&gt;toto&lt;b&gt;bold&lt;/b&gt;&lt;/elt&gt;\n<br>\nwill be output as <br>\n&lt;elt&gt; <br>\n\n&lt;b&gt;b&lt;/b&gt;toto&lt;b&gt;bold&lt;/b&gt;&lt;/elt&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if you flush\nthe twig when you find the &quot;&lt;b&gt;&quot; element</p>\n\n<h2>Globals\n<a name=\"Globals\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These are the\nthings that can mess up calling code, especially if\nthreaded. They might also cause problem under mod_perl. <br>\nExported constants</p>\n\n<p style=\"margin-left:17%;\">Whether you want them or not\nyou get them! These are subroutines to use as constant when\ncreating or testing elements</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">PCDATA return\n'#PCDATA' <br>\nCDATA return '#CDATA' <br>\nPI return '#PI', I had the choice between PROC and PI\n:--(</p>\n\n<p style=\"margin-left:11%;\">Module scoped values:\nconstants</p>\n\n<p style=\"margin-left:17%;\">these should cause no\ntrouble:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">%base_ent= (\n'&gt;' =&gt; '&amp;gt;', <br>\n'&lt;' =&gt; '&amp;lt;', <br>\n'&amp;' =&gt; '&amp;amp;', <br>\n&quot;'&quot; =&gt; '&amp;apos;', <br>\n'&quot;' =&gt; '&amp;quot;', <br>\n); <br>\nCDATA_START = &quot;&lt;![CDATA[&quot;; <br>\nCDATA_END = &quot;]]&gt;&quot;; <br>\nPI_START = &quot;&lt;?&quot;; <br>\nPI_END = &quot;?&gt;&quot;; <br>\nCOMMENT_START = &quot;&lt;!--&quot;; <br>\nCOMMENT_END = &quot;--&gt;&quot;;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">pretty print\nstyles</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">( $NSGMLS,\n$NICE, $INDENTED, $INDENTED_C, $WRAPPED, $RECORD1,\n$RECORD2)= (1..7);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">empty tag\noutput style</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">( $HTML,\n$EXPAND)= (1..2);</p>\n\n<p style=\"margin-left:11%;\">Module scoped values: might be\nchanged</p>\n\n<p style=\"margin-left:17%;\">Most of these deal with pretty\nprinting, so the worst that can happen is probably that\n<small>XML</small> output does not look right, but is still\nvalid and processed identically by <small>XML</small>\nprocessors.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$empty_tag_style\ncan mess up <small>HTML</small> bowsers though and changing\n$ID would most likely create problems.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$pretty=0; #\npretty print style <br>\n$quote='&quot;'; # quote for attributes <br>\n$INDENT= ' '; # indent for indented pretty print <br>\n$empty_tag_style= 0; # how to display empty tags <br>\n$ID # attribute used as an id ('id' by default)</p>\n\n<p style=\"margin-left:11%;\">Module scoped values:\ndefinitely changed</p>\n\n<p style=\"margin-left:17%;\">These 2 variables are used to\nreplace tags by an index, thus saving some space when\ncreating a twig. If they really cause you too much trouble,\nlet me know, it is probably possible to create either a\nswitch or at least a version of XML::Twig that does not\nperform this optimization.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">%gi2index; #\ntag =&gt; index <br>\n@index2gi; # list of tags</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you need to\nmanipulate all those values, you can use the following\nmethods on the XML::Twig object: <br>\nglobal_state</p>\n\n<p style=\"margin-left:17%;\">Return a hashref with all the\nglobal variables used by XML::Twig</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The hash has\nthe following fields: &quot;pretty&quot;, &quot;quote&quot;,\n&quot;indent&quot;, &quot;empty_tag_style&quot;,\n&quot;keep_encoding&quot;,\n&quot;expand_external_entities&quot;,\n&quot;output_filter&quot;, &quot;output_text_filter&quot;,\n&quot;keep_atts_order&quot;</p>\n\n<p style=\"margin-left:11%;\">set_global_state ($state)</p>\n\n<p style=\"margin-left:17%;\">Set the global state, $state is\na hashref</p>\n\n<p style=\"margin-left:11%;\">save_global_state</p>\n\n<p style=\"margin-left:17%;\">Save the current global\nstate</p>\n\n<p style=\"margin-left:11%;\">restore_global_state</p>\n\n<p style=\"margin-left:17%;\">Restore the previously saved\n(using &quot;Lsave_global_state&quot;&gt; state</p>\n\n<h2>TODO\n<a name=\"TODO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>SAX</small>\nhandlers</p>\n\n<p style=\"margin-left:17%;\">Allowing XML::Twig to work on\ntop of any <small>SAX</small> parser</p>\n\n<p style=\"margin-left:11%;\">multiple twigs are not well\nsupported</p>\n\n<p style=\"margin-left:17%;\">A number of twig features are\njust global at the moment. These include the\n<small>ID</small> list and the &quot;tag pool&quot; (if you\nuse &quot;change_gi&quot; then you change the tag for\n<small>ALL</small> twigs).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A future\nversion will try to support this while trying not to be to\nhard on performance (at least when a single twig is\nused!).</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Michel\nRodriguez &lt;mirod@cpan.org&gt;</p>\n\n<h2>LICENSE\n<a name=\"LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Bug reports\nshould be sent using: <i><small>RT</small>\n&lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML-Twig&gt;</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Comments can be\nsent to mirod@cpan.org</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The XML::Twig\npage is at &lt;http://www.xmltwig.org/xmltwig/&gt; It\nincludes the development version of the module, a slightly\nbetter version of the documentation, examples, a tutorial\nand a: <i>Processing <small>XML</small> efficiently with\nPerl and XML::Twig:\n&lt;http://www.xmltwig.org/xmltwig/tutorial/index.html&gt;</i></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Complete docs,\nincluding a tutorial, examples, an easier to use\n<small>HTML</small> version of the docs, a quick reference\ncard and a <small>FAQ</small> are available at\n&lt;http://www.xmltwig.org/xmltwig/&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">git repository\nat &lt;http://github.com/mirod/xmltwig&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Parser,\nXML::Parser::Expat, XML::XPath, Encode, Text::Iconv,\nScalar::Utils</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Alternative\nModules</b> <br>\nXML::Twig is not the only XML::Processing module available\non <small>CPAN</small> (far from it!).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The main\nalternative I would recommend is XML::LibXML.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is a quick\ncomparison of the 2 modules:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::LibXML,\nactually &quot;libxml2&quot; on which it is based, sticks to\nthe standards, and implements a good number of them in a\nrather strict way: <small>XML,</small> XPath,\n<small>DOM,</small> RelaxNG, I must be forgetting a couple\n(XInclude?). It is fast and rather frugal memory-wise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">XML::Twig is\nolder: when I started writing it XML::Parser/expat was the\nonly game in town. It implements <small>XML</small> and\nthat&rsquo;s about it (plus a subset of XPath, and you can\nuse XML::Twig::XPath if you have XML::XPathEngine installed\nfor full support). It is slower and requires more memory for\na full tree than XML::LibXML. On the plus side (yes, there\nis a plus side!) it lets you process a big document in\nchunks, and thus let you tackle documents that\ncouldn&rsquo;t be loaded in memory by XML::LibXML, and it\noffers a lot (and I mean a <small>LOT</small> !) of\nhigher-level methods, for everything, from adding structure\nto &quot;low-level&quot; <small>XML,</small> to shortcuts\nfor <small>XHTML</small> conversions and more. It also DWIMs\nquite a bit, getting comments and non-significant\nwhitespaces out of the way but preserving them in the output\nfor example. As it does not stick to the <small>DOM,</small>\nis also usually leads to shorter code than in\nXML::LibXML.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Beyond the pure\nfeatures of the 2 modules, XML::LibXML seems to be preferred\nby &quot;XML-purists&quot;, while XML::Twig seems to be more\nused by Perl Hackers who have to deal with\n<small>XML.</small> As you have noted, XML::Twig also comes\nwith quite a lot of docs, but I am sure if you ask for help\nabout XML::LibXML here or on Perlmonks you will get\nanswers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that it is\nactually quite hard for me to compare the 2 modules: on one\nhand I know XML::Twig inside-out and I can get it to do\npretty much anything I need to (or I improve it ;--), while\nI have a very basic knowledge of XML::LibXML. So\nfeature-wise, I&rsquo;d rather use XML::Twig ;--). On the\nother hand, I am painfully aware of some of the\ndeficiencies, potential bugs and plain ugly code that lurk\nin XML::Twig, even though you are unlikely to be affected by\nthem (unless for example you need to change the\n<small>DTD</small> of a document programmatically), while I\nhaven&rsquo;t looked much into XML::LibXML so it still looks\nshinny and clean to me.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That said, if\nyou need to process a document that is too big to fit memory\nand XML::Twig is too slow for you, my reluctant advice would\nbe to use &quot;bare&quot; XML::Parser. It won&rsquo;t be as\neasy to use as XML::Twig: basically with XML::Twig you trade\nsome speed (depending on what you do from a factor 3 to...\nnone) for ease-of-use, but it will be easier\n<small>IMHO</small> than using <small>SAX</small> (albeit\nnot standard), and at this point a <small>LOT</small> faster\n(see the last test in\n&lt;http://www.xmltwig.org/article/simple_benchmark/&gt;).</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#TOOLS\">TOOLS</a>","<a href=\"#XML::Twig 101\">XML::Twig 101</a>","<a href=\"#Simplifying XML processing\">Simplifying XML processing</a>","<a href=\"#CLASSES\">CLASSES</a>","<a href=\"#METHODS\">METHODS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#Globals\">Globals</a>","<a href=\"#TODO\">TODO</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#LICENSE\">LICENSE</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>"],"level":3}