{"name":"scanf","description":"scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion","body":"\n\n<h1 align=\"center\">SCANF</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">scanf, fscanf,\nsscanf, vscanf, vsscanf, vfscanf - input format\nconversion</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;stdio.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nscanf(const char *</b><i>format</i><b>, ...); <br>\nint fscanf(FILE *</b><i>stream</i><b>, const char\n*</b><i>format</i><b>, ...); <br>\nint sscanf(const char *</b><i>str</i><b>, const char\n*</b><i>format</i><b>, ...);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;stdarg.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nvscanf(const char *</b><i>format</i><b>, va_list</b>\n<i>ap</i><b>); <br>\nint vsscanf(const char *</b><i>str</i><b>, const char\n*</b><i>format</i><b>, va_list</b> <i>ap</i><b>); <br>\nint vfscanf(FILE *</b><i>stream</i><b>, const char\n*</b><i>format</i><b>, va_list</b> <i>ap</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>vscanf</b>(),\n<b>vsscanf</b>(), <b>vfscanf</b>():</p>\n\n<p style=\"margin-left:17%;\">_ISOC99_SOURCE ||\n_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200112L</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>scanf</b>() family of functions scans input according to\n<i>format</i> as described below. This format may contain\n<i>conversion specifications</i>; the results from such\nconversions, if any, are stored in the locations pointed to\nby the <i>pointer</i> arguments that follow <i>format</i>.\nEach <i>pointer</i> argument must be of a type that is\nappropriate for the value returned by the corresponding\nconversion specification.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the number\nof conversion specifications in <i>format</i> exceeds the\nnumber of <i>pointer</i> arguments, the results are\nundefined. If the number of <i>pointer</i> arguments exceeds\nthe number of conversion specifications, then the excess\n<i>pointer</i> arguments are evaluated, but are otherwise\nignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>scanf</b>() function reads input from the standard input\nstream <i>stdin</i>, <b>fscanf</b>() reads input from the\nstream pointer <i>stream</i>, and <b>sscanf</b>() reads its\ninput from the character string pointed to by\n<i>str</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>vfscanf</b>() function is analogous to <a href=\"https://man.page/3/vfprintf\">vfprintf(3)</a>\nand reads input from the stream pointer <i>stream</i> using\na variable argument list of pointers (see <a href=\"https://man.page/3/stdarg\">stdarg(3)</a>.\nThe <b>vscanf</b>() function scans a variable argument list\nfrom the standard input and the <b>vsscanf</b>() function\nscans it from a string; these are analogous to the\n<a href=\"https://man.page/3/vprintf\">vprintf(3)</a> and <a href=\"https://man.page/3/vsprintf\">vsprintf(3)</a> functions\nrespectively.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>format</i> string consists of a sequence of\n<i>directives</i> which describe how to process the sequence\nof input characters. If processing of a directive fails, no\nfurther input is read, and <b>scanf</b>() returns. A\n&quot;failure&quot; can be either of the following: <i>input\nfailure</i>, meaning that input characters were unavailable,\nor <i>matching failure</i>, meaning that the input was\ninappropriate (see below).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A directive is\none of the following:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>A sequence of white-space characters (space, tab,\nnewline, etc.; see <a href=\"https://man.page/3/isspace\">isspace(3)</a>). This directive\nmatches any amount of white space, including none, in the\ninput.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>An ordinary character (i.e., one other than white space\nor '%'). This character must exactly match the next\ncharacter of input.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>A conversion specification, which commences with a '%'\n(percent) character. A sequence of characters from the input\nis converted according to this specification, and the result\nis placed in the corresponding <i>pointer</i> argument. If\nthe next item of input does not match the conversion\nspecification, the conversion fails&mdash;this is a\n<i>matching failure</i>.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each\n<i>conversion specification</i> in <i>format</i> begins with\neither the character '%' or the character sequence\n&quot;<b>%</b><i>n</i><b>$</b>&quot; (see below for the\ndistinction) followed by:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">An optional '*'\nassignment-suppression character: <b>scanf</b>() reads input\nas directed by the conversion specification, but discards\nthe input. No corresponding <i>pointer</i> argument is\nrequired, and this specification is not included in the\ncount of successful assignments returned by\n<b>scanf</b>().</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>For decimal conversions, an optional quote character\n('). This specifies that the input number may include\nthousands&rsquo; separators as defined by the\n<b>LC_NUMERIC</b> category of the current locale. (See\n<a href=\"https://man.page/3/setlocale\">setlocale(3)</a>.) The quote character may precede or\nfollow the '*' assignment-suppression character.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>An optional 'm' character. This is used with string\nconversions (<i>%s</i>, <i>%c</i>, <i>%[</i>), and relieves\nthe caller of the need to allocate a corresponding buffer to\nhold the input: instead, <b>scanf</b>() allocates a buffer\nof sufficient size, and assigns the address of this buffer\nto the corresponding <i>pointer</i> argument, which should\nbe a pointer to a <i>char&nbsp;*</i> variable (this variable\ndoes not need to be initialized before the call). The caller\nshould subsequently <a href=\"https://man.page/3/free\">free(3)</a> this buffer when it is no\nlonger required.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>An optional decimal integer which specifies the\n<i>maximum field width</i>. Reading of characters stops\neither when this maximum is reached or when a nonmatching\ncharacter is found, whichever happens first. Most\nconversions discard initial white space characters (the\nexceptions are noted below), and these discarded characters\ndon&rsquo;t count toward the maximum field width. String\ninput conversions store a terminating null byte ('\\0') to\nmark the end of the input; the maximum field width does not\ninclude this terminator.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>An optional <i>type modifier character</i>. For example,\nthe <b>l</b> type modifier is used with integer conversions\nsuch as <b>%d</b> to specify that the corresponding\n<i>pointer</i> argument refers to a <i>long</i> rather than\na pointer to an <i>int</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>A <i>conversion specifier</i> that specifies the type of\ninput conversion to be performed.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The conversion\nspecifications in <i>format</i> are of two forms, either\nbeginning with '%' or beginning with\n&quot;<b>%</b><i>n</i><b>$</b>&quot;. The two forms should\nnot be mixed in the same <i>format</i> string, except that a\nstring containing &quot;<b>%</b><i>n</i><b>$</b>&quot;\nspecifications can include <b>%%</b> and <b>%*</b>. If\n<i>format</i> contains '%' specifications, then these\ncorrespond in order with successive <i>pointer</i>\narguments. In the &quot;<b>%</b><i>n</i><b>$</b>&quot; form\n(which is specified in POSIX.1-2001, but not C99), <i>n</i>\nis a decimal integer that specifies that the converted input\nshould be placed in the location referred to by the\n<i>n</i>-th <i>pointer</i> argument following\n<i>format</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Conversions</b>\n<br>\nThe following <i>type modifier characters</i> can appear in\na conversion specification:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\"><b>h</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Indicates that the conversion\nwill be one of <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>,\n<b>x</b>, <b>X</b>, or <b>n</b> and the next pointer is a\npointer to a <i>short</i> or <i>unsigned short</i> (rather\nthan <i>int</i>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>hh</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>As for <b>h</b>, but the next pointer is a pointer to a\n<i>signed char</i> or <i>unsigned char</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>j</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>As for <b>h</b>, but the next pointer is a pointer to an\n<i>intmax_t</i> or a <i>uintmax_t</i>. This modifier was\nintroduced in C99.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>l</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>Indicates either that the conversion will be one of\n<b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>,\nor <b>n</b> and the next pointer is a pointer to a\n<i>long</i> or <i>unsigned long</i> (rather than\n<i>int</i>), or that the conversion will be one of <b>e</b>,\n<b>f</b>, or <b>g</b> and the next pointer is a pointer to\n<i>double</i> (rather than <i>float</i>). Specifying two\n<b>l</b> characters is equivalent to <b>L</b>. If used with\n<b>%c</b> or <b>%s</b>, the corresponding parameter is\nconsidered as a pointer to a wide character or\nwide-character string respectively.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>L</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>Indicates that the conversion will be either <b>e</b>,\n<b>f</b>, or <b>g</b> and the next pointer is a pointer to\n<i>long double</i> or the conversion will be <b>d</b>,\n<b>i</b>, <b>o</b>, <b>u</b>, or <b>x</b> and the next\npointer is a pointer to <i>long long</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>q</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>equivalent to <b>L</b>. This specifier does not exist in\nANSI C.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>t</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>As for <b>h</b>, but the next pointer is a pointer to a\n<i>ptrdiff_t</i>. This modifier was introduced in C99.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>z</b></p></td>\n<td width=\"8%\"></td>\n<td width=\"78%\">\n\n\n<p>As for <b>h</b>, but the next pointer is a pointer to a\n<i>size_t</i>. This modifier was introduced in C99.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\n<i>conversion specifiers</i> are available:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\"><b>%</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Matches a literal '%'. That is,\n<b>%%</b> in the format string matches a single input '%'\ncharacter. No conversion is done (but initial white space\ncharacters are discarded), and assignment does not\noccur.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>d</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches an optionally signed decimal integer; the next\npointer must be a pointer to <i>int</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>i</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches an optionally signed integer; the next pointer\nmust be a pointer to <i>int</i>. The integer is read in base\n16 if it begins with <i>0x</i> or <i>0X</i>, in base 8 if it\nbegins with <i>0</i>, and in base 10 otherwise. Only\ncharacters that correspond to the base are used.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>o</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches an unsigned octal integer; the next pointer must\nbe a pointer to <i>unsigned int</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>u</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches an unsigned decimal integer; the next pointer\nmust be a pointer to <i>unsigned int</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>x</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches an unsigned hexadecimal integer (that may\noptionally begin with a prefix of <i>0x</i> or <i>0X</i>,\nwhich is discarded); the next pointer must be a pointer to\n<i>unsigned int</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>X</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Equivalent to <b>x</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>f</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches an optionally signed floating-point number; the\nnext pointer must be a pointer to <i>float</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>e</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Equivalent to <b>f</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>g</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Equivalent to <b>f</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>E</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Equivalent to <b>f</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>a</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>(C99) Equivalent to <b>f</b>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>s</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches a sequence of non-white-space characters; the\nnext pointer must be a pointer to the initial element of a\ncharacter array that is long enough to hold the input\nsequence and the terminating null byte ('\\0'), which is\nadded automatically. The input string stops at white space\nor at the maximum field width, whichever occurs first.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>c</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches a sequence of characters whose length is\nspecified by the <i>maximum field width</i> (default 1); the\nnext pointer must be a pointer to <i>char</i>, and there\nmust be enough room for all the characters (no terminating\nnull byte is added). The usual skip of leading white space\nis suppressed. To skip white space first, use an explicit\nspace in the format.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>[</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches a nonempty sequence of characters from the\nspecified set of accepted characters; the next pointer must\nbe a pointer to <i>char</i>, and there must be enough room\nfor all the characters in the string, plus a terminating\nnull byte. The usual skip of leading white space is\nsuppressed. The string is to be made up of characters in (or\nnot in) a particular set; the set is defined by the\ncharacters between the open bracket <b>[</b> character and a\nclose bracket <b>]</b> character. The set <i>excludes</i>\nthose characters if the first character after the open\nbracket is a circumflex (<b>^</b>). To include a close\nbracket in the set, make it the first character after the\nopen bracket or the circumflex; any other position will end\nthe set. The hyphen character <b>-</b> is also special; when\nplaced between two other characters, it adds all intervening\ncharacters to the set. To include a hyphen, make it the last\ncharacter before the final close bracket. For instance,\n<b>[^]0-9-]</b> means the set &quot;everything except close\nbracket, zero through nine, and hyphen&quot;. The string\nends with the appearance of a character not in the (or, with\na circumflex, in) set or when the field width runs out.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>p</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Matches a pointer value (as printed by <b>%p</b> in\n<a href=\"https://man.page/3/printf\">printf(3)</a>); the next pointer must be a pointer to a\npointer to <i>void</i>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p><b>n</b></p></td>\n<td width=\"10%\"></td>\n<td width=\"78%\">\n\n\n<p>Nothing is expected; instead, the number of characters\nconsumed thus far from the input is stored through the next\npointer, which must be a pointer to <i>int</i>. This is\n<i>not</i> a conversion and does <i>not</i> increase the\ncount returned by the function. The assignment can be\nsuppressed with the <b>*</b> assignment-suppression\ncharacter, but the effect on the return value is undefined.\nTherefore <b>%*n</b> conversions should not be used.</p></td></tr>\n</table>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\nthese functions return the number of input items\nsuccessfully matched and assigned; this can be fewer than\nprovided for, or even zero, in the event of an early\nmatching failure.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The value\n<b>EOF</b> is returned if the end of input is reached before\neither the first successful conversion or a matching failure\noccurs. <b>EOF</b> is also returned if a read error occurs,\nin which case the error indicator for the stream (see\n<a href=\"https://man.page/3/ferror\">ferror(3)</a>) is set, and <i>errno</i> is set to\nindicate the error.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EAGAIN</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The file descriptor underlying\n<i>stream</i> is marked nonblocking, and the read operation\nwould block.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBADF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The file descriptor underlying <i>stream</i> is invalid,\nor not open for reading.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EILSEQ</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Input byte sequence does not form a valid character.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINTR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The read operation was interrupted by a signal; see\n<a href=\"https://man.page/7/signal\">signal(7)</a>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Not enough arguments; or <i>format</i> is NULL.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Out of memory.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ERANGE</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The result of an integer conversion would exceed the\nsize that can be stored in the corresponding integer\ntype.</p> </td></tr>\n</table>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3285891.png\" alt=\"Image grohtml-3285891.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\n<b>fscanf</b>(), <b>scanf</b>(), and <b>sscanf</b>() conform\nto C89 and C99 and POSIX.1-2001. These standards do not\nspecify the <b>ERANGE</b> error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <b>q</b>\nspecifier is the 4.4BSD notation for <i>long long</i>, while\n<b>ll</b> or the usage of <b>L</b> in integer conversions is\nthe GNU notation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Linux\nversion of these functions is based on the <i>GNU libio</i>\nlibrary. Take a look at the <i>info</i> documentation of\n<i>GNU libc (glibc-1.08)</i> for a more concise\ndescription.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The\n&rsquo;a&rsquo; assignment-allocation modifier</b> <br>\nOriginally, the GNU C library supported dynamic allocation\nfor string inputs (as a nonstandard extension) via the\n<b>a</b> character. (This feature is present at least as far\nback as glibc 2.0.) Thus, one could write the following to\nhave <b>scanf</b>() allocate a buffer for an input string,\nwith a pointer to that buffer being returned in\n<i>*buf</i>:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">char *buf; <br>\nscanf(&quot;%as&quot;, &amp;buf);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The use of the\nletter <b>a</b> for this purpose was problematic, since\n<b>a</b> is also specified by the ISO C standard as a\nsynonym for <b>f</b> (floating-point input). POSIX.1-2008\ninstead specifies the <b>m</b> modifier for assignment\nallocation (as documented in DESCRIPTION, above).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\n<b>a</b> modifier is not available if the program is\ncompiled with <i>gcc -std=c99</i> or <i>gcc\n-D_ISOC99_SOURCE</i> (unless <b>_GNU_SOURCE</b> is also\nspecified), in which case the <b>a</b> is interpreted as a\nspecifier for floating-point numbers (see above).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Support for the\n<b>m</b> modifier was added to glibc starting with version\n2.7, and new programs should use that modifier instead of\n<b>a</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As well as\nbeing standardized by POSIX, the <b>m</b> modifier has the\nfollowing further advantages over the use of <b>a:</b></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p style=\"margin-top: 1em\">It may also be applied to\n<b>%c</b> conversion specifiers (e.g., <b>%3mc</b>).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>It avoids ambiguity with respect to the <b>%a</b>\nfloating-point conversion specifier (and is unaffected by\n<i>gcc -std=c99</i> etc.).</p></td></tr>\n</table>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">All functions\nare fully C89 conformant, but provide the additional\nspecifiers <b>q</b> and <b>a</b> as well as an additional\nbehavior of the <b>L</b> and <b>l</b> specifiers. The latter\nmay be considered to be a bug, as it changes the behavior of\nspecifiers defined in C89.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some\ncombinations of the type modifiers and conversion specifiers\ndefined by ANSI C do not make sense (e.g., <b>%Ld</b>).\nWhile they may have a well-defined behavior on Linux, this\nneed not to be so on other architectures. Therefore it\nusually is better to use modifiers that are not defined by\nANSI C at all, that is, use <b>q</b> instead of <b>L</b> in\ncombination with <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>,\n<b>x</b>, and <b>X</b> conversions or <b>ll</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The usage of\n<b>q</b> is not the same as on 4.4BSD, as it may be used in\nfloat conversions equivalently to <b>L</b>.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">To use the\ndynamic allocation conversion specifier, specify <b>m</b> as\na length modifier (thus <b>%ms</b> or\n<b>%m[</b><i>range</i><b>]</b>). The caller must\n<a href=\"https://man.page/3/free\">free(3)</a> the returned string, as in the following\nexample:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">char *p; <br>\nint n;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">errno = 0; <br>\nn = scanf(&quot;%m[a-z]&quot;, &amp;p); <br>\nif (n == 1) { <br>\nprintf(&quot;read: %s\\n&quot;, p); <br>\nfree(p); <br>\n} else if (errno != 0) { <br>\nperror(&quot;scanf&quot;); <br>\n} else { <br>\nfprintf(stderr, &quot;No matching characters\\n&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As shown in the\nabove example, it is necessary to call <a href=\"https://man.page/3/free\">free(3)</a> only\nif the <b>scanf</b>() call successfully read a string.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/getc\">getc(3)</a>,\n<a href=\"https://man.page/3/printf\">printf(3)</a>, <a href=\"https://man.page/3/setlocale\">setlocale(3)</a>, <a href=\"https://man.page/3/strtod\">strtod(3)</a>,\n<a href=\"https://man.page/3/strtol\">strtol(3)</a>, <a href=\"https://man.page/3/strtoul\">strtoul(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}