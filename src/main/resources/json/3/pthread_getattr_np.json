{"name":"pthread_getattr_np","description":"pthread_getattr_np\n- get attributes of created thread","body":"\n\n<h1 align=\"center\">PTHREAD_GETATTR_NP</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">pthread_getattr_np\n- get attributes of created thread</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#define\n_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>\n#include &lt;pthread.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\npthread_getattr_np(pthread_t</b> <i>thread</i><b>,\npthread_attr_t *</b><i>attr</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Compile and\nlink with <i>-pthread</i>.</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>pthread_getattr_np</b>() function initializes the thread\nattributes object referred to by <i>attr</i> so that it\ncontains actual attribute values describing the running\nthread <i>thread</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The returned\nattribute values may differ from the corresponding attribute\nvalues passed in the <i>attr</i> object that was used to\ncreate the thread using <a href=\"https://man.page/3/pthread_create\">pthread_create(3)</a>. In\nparticular, the following attributes may differ:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>the detach state, since a joinable thread may have\ndetached itself after creation;</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>the stack size, which the implementation may align to a\nsuitable boundary.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"86%\">\n\n\n<p>and the guard size, which the implementation may round\nupward to a multiple of the page size, or ignore (i.e.,\ntreat as 0), if the application is allocating its own\nstack.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Furthermore, if\nthe stack address attribute was not set in the thread\nattributes object used to create the thread, then the\nreturned thread attributes object will report the actual\nstack address that the implementation selected for the\nthread.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the thread\nattributes object returned by <b>pthread_getattr_np</b>() is\nno longer required, it should be destroyed using\n<a href=\"https://man.page/3/pthread_attr_destroy\">pthread_attr_destroy(3)</a>.</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">On success,\nthis function returns 0; on error, it returns a nonzero\nerror number.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"30%\">\n\n\n<p style=\"margin-top: 1em\">Insufficient memory.</p></td>\n<td width=\"48%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In addition, if\n<i>thread</i> refers to the main thread, then\n<b>pthread_getattr_np</b>() can fail because of errors from\nvarious underlying calls: <a href=\"https://man.page/3/fopen\">fopen(3)</a>, if\n<i>/proc/self/maps</i> can&rsquo;t be opened; and\n<a href=\"https://man.page/2/getrlimit\">getrlimit(2)</a>, if the <b>RLIMIT_STACK</b> resource\nlimit is not supported.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\nis available in glibc since version 2.2.3.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n\n<p align=\"center\" style=\"margin-top: 1em\"><img src=\"grohtml-3296011.png\" alt=\"Image grohtml-3296011.png\"></p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This function\nis a nonstandard GNU extension; hence the suffix\n&quot;_np&quot; (nonportable) in the name.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow demonstrates the use of <b>pthread_getattr_np</b>().\nThe program creates a thread that then uses\n<b>pthread_getattr_np</b>() to retrieve and display its\nguard size, stack address, and stack size attributes.\nCommand-line arguments can be used to set these attributes\nto values other than the default when creating the thread.\nThe shell sessions below demonstrate the use of the\nprogram.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the first\nrun, on an x86-32 system, a thread is created using default\nattributes:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>ulimit\n-s</b> # No stack limit ==&gt; default stack size is 2 MB\n<br>\nunlimited <br>\n$ <b>./a.out</b> <br>\nAttributes of created thread: <br>\nGuard size = 4096 bytes <br>\nStack address = 0x40196000 (EOS = 0x40397000) <br>\nStack size = 0x201000 (2101248) bytes</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the\nfollowing run, we see that if a guard size is specified, it\nis rounded up to the next multiple of the system page size\n(4096 bytes on x86-32):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out -g\n4097</b> <br>\nThread attributes object after initializations: <br>\nGuard size = 4097 bytes <br>\nStack address = (nil) <br>\nStack size = 0x0 (0) bytes</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Attributes of\ncreated thread: <br>\nGuard size = 8192 bytes <br>\nStack address = 0x40196000 (EOS = 0x40397000) <br>\nStack size = 0x201000 (2101248) bytes</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the last\nrun, the program manually allocates a stack for the thread.\nIn this case, the guard size attribute is ignored.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>./a.out -g\n4096 -s 0x8000 -a</b> <br>\nAllocated thread stack at 0x804d000</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Thread\nattributes object after initializations: <br>\nGuard size = 4096 bytes <br>\nStack address = 0x804d000 (EOS = 0x8055000) <br>\nStack size = 0x8000 (32768) bytes</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Attributes of\ncreated thread: <br>\nGuard size = 0 bytes <br>\nStack address = 0x804d000 (EOS = 0x8055000) <br>\nStack size = 0x8000 (32768) bytes</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#define _GNU_SOURCE /* To get pthread_getattr_np()\ndeclaration */ <br>\n#include &lt;pthread.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt; <br>\n#include &lt;errno.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nhandle_error_en(en, msg) \\ <br>\ndo { errno = en; perror(msg); exit(EXIT_FAILURE); } while\n(0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\ndisplay_stack_related_attributes(pthread_attr_t *attr, char\n*prefix) <br>\n{ <br>\nint s; <br>\nsize_t stack_size, guard_size; <br>\nvoid *stack_addr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_attr_getguardsize(attr, &amp;guard_size); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_getguardsize&quot;);\n<br>\nprintf(&quot;%sGuard size = %zu bytes\\n&quot;, prefix,\nguard_size);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_attr_getstack(attr, &amp;stack_addr,\n&amp;stack_size); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_getstack&quot;); <br>\nprintf(&quot;%sStack address = %p&quot;, prefix,\nstack_addr); <br>\nif (stack_size &gt; 0) <br>\nprintf(&quot; (EOS = %p)&quot;, (char *) stack_addr +\nstack_size); <br>\nprintf(&quot;\\n&quot;); <br>\nprintf(&quot;%sStack size = %#zx (%zu) bytes\\n&quot;, <br>\nprefix, stack_size, stack_size); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\ndisplay_thread_attributes(pthread_t thread, char *prefix)\n<br>\n{ <br>\nint s; <br>\npthread_attr_t attr;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_getattr_np(thread, &amp;attr); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_getattr_np&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">display_stack_related_attributes(&amp;attr,\nprefix);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_attr_destroy(&amp;attr); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_destroy&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void *\n/* Start function for thread we create */ <br>\nthread_start(void *arg) <br>\n{ <br>\nprintf(&quot;Attributes of created thread:\\n&quot;); <br>\ndisplay_thread_attributes(pthread_self(),\n&quot;\\t&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n/* Terminate all threads */ <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static void\n<br>\nusage(char *pname, char *msg) <br>\n{ <br>\nif (msg != NULL) <br>\nfputs(msg, stderr); <br>\nfprintf(stderr, &quot;Usage: %s [-s stack-size [-a]]&quot;\n<br>\n&quot; [-g guard-size]\\n&quot;, pname); <br>\nfprintf(stderr, &quot;\\t\\t-a means program should allocate\nstack\\n&quot;); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">static\npthread_attr_t * /* Get thread attributes from command line\n*/ <br>\nget_thread_attributes_from_cl(int argc, char *argv[], <br>\npthread_attr_t *attrp) <br>\n{ <br>\nint s, opt, allocate_stack; <br>\nsize_t stack_size, guard_size; <br>\nvoid *stack_addr; <br>\npthread_attr_t *ret_attrp = NULL; /* Set to attrp if we\ninitialize <br>\na thread attributes object */ <br>\nallocate_stack = 0; <br>\nstack_size = -1; <br>\nguard_size = -1;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">while ((opt =\ngetopt(argc, argv, &quot;ag:s:&quot;)) != -1) { <br>\nswitch (opt) { <br>\ncase 'a': allocate_stack = 1; break; <br>\ncase 'g': guard_size = strtoul(optarg, NULL, 0); break; <br>\ncase 's': stack_size = strtoul(optarg, NULL, 0); break; <br>\ndefault: usage(argv[0], NULL); <br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(allocate_stack &amp;&amp; stack_size == -1) <br>\nusage(argv[0], &quot;Specifying -a without -s makes no\nsense\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc &gt;\noptind) <br>\nusage(argv[0], &quot;Extraneous command-line\narguments\\n&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (stack_size\n&gt;= 0 || guard_size &gt; 0) { <br>\nret_attrp = attrp;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_attr_init(attrp); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_init&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (stack_size\n&gt;= 0) { <br>\nif (!allocate_stack) { <br>\ns = pthread_attr_setstacksize(attrp, stack_size); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_setstacksize&quot;);\n<br>\n} else { <br>\ns = posix_memalign(&amp;stack_addr, sysconf(_SC_PAGESIZE),\n<br>\nstack_size); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;posix_memalign&quot;); <br>\nprintf(&quot;Allocated thread stack at %p\\n\\n&quot;,\nstack_addr);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_attr_setstack(attrp, stack_addr, stack_size); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_setstacksize&quot;);\n<br>\n} <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (guard_size\n&gt;= 0) { <br>\ns = pthread_attr_setguardsize(attrp, guard_size); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_setstacksize&quot;);\n<br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">return\nret_attrp; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint s; <br>\npthread_t thr; <br>\npthread_attr_t attr; <br>\npthread_attr_t *attrp = NULL; /* Set to &amp;attr if we\ninitialize <br>\na thread attributes object */</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">attrp =\nget_thread_attributes_from_cl(argc, argv, &amp;attr);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (attrp !=\nNULL) { <br>\nprintf(&quot;Thread attributes object after\ninitializations:\\n&quot;); <br>\ndisplay_stack_related_attributes(attrp, &quot;\\t&quot;);\n<br>\nprintf(&quot;\\n&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">s =\npthread_create(&amp;thr, attrp, &amp;thread_start, NULL);\n<br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_create&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (attrp !=\nNULL) { <br>\ns = pthread_attr_destroy(attrp); <br>\nif (s != 0) <br>\nhandle_error_en(s, &quot;pthread_attr_destroy&quot;); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">pause(); /*\nTerminates when other thread calls exit() */ <br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/pthread_attr_getaffinity_np\">pthread_attr_getaffinity_np(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getdetachstate\">pthread_attr_getdetachstate(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getguardsize\">pthread_attr_getguardsize(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getinheritsched\">pthread_attr_getinheritsched(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getschedparam\">pthread_attr_getschedparam(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getschedpolicy\">pthread_attr_getschedpolicy(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getscope\">pthread_attr_getscope(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getstack\">pthread_attr_getstack(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getstackaddr\">pthread_attr_getstackaddr(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_getstacksize\">pthread_attr_getstacksize(3)</a>,\n<a href=\"https://man.page/3/pthread_attr_init\">pthread_attr_init(3)</a>, <a href=\"https://man.page/3/pthread_create\">pthread_create(3)</a>,\n<a href=\"https://man.page/7/pthreads\">pthreads(7)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}