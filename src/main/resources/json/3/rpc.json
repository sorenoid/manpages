{"name":"rpc","description":"rpc - library routines for remote procedure calls","body":"\n\n<h1 align=\"center\">RPC</h1>\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">rpc - library\nroutines for remote procedure calls</p>\n\n<h2>SYNOPSIS AND DESCRIPTION\n<a name=\"SYNOPSIS AND DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These routines\nallow C programs to make procedure calls on other machines\nacross the network. First, the client calls a procedure to\nsend a data packet to the server. Upon receipt of the\npacket, the server calls a dispatch routine to perform the\nrequested service, and then sends back a reply. Finally, the\nprocedure call returns to the client.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To take use of\nthese routines, include the header file\n<i>&lt;rpc/rpc.h&gt;</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The prototypes\nbelow make use of the following types:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>typedef\nint</b> <i>bool_t</i><b>;</b></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>typedef\nbool_t (*</b><i>xdrproc_t</i><b>) (XDR *, void *,\n...);</b></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>typedef\nbool_t (*</b><i>resultproc_t</i><b>) (caddr_t</b>\n<i>resp</i><b>, <br>\nstruct sockaddr_in *</b><i>raddr</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the header\nfiles for the declarations of the <i>AUTH</i>,\n<i>CLIENT</i>, <i>SVCXPRT</i>, and <i>XDR</i> types.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nauth_destroy(AUTH *</b><i>auth</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\ndestroys the authentication information associated with\n<i>auth</i>. Destruction usually involves deallocation of\nprivate data structures. The use of <i>auth</i> is undefined\nafter calling <b>auth_destroy</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>AUTH\n*authnone_create(void);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Create and\nreturn an RPC authentication handle that passes nonusable\nauthentication information with each remote procedure call.\nThis is the default authentication used by RPC.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>AUTH\n*authunix_create(char *</b><i>host</i><b>, int</b>\n<i>uid</i><b>, int</b> <i>gid</i><b>, <br>\nint</b> <i>len</i><b>, int *</b><i>aup_gids</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Create and\nreturn an RPC authentication handle that contains\nauthentication information. The parameter <i>host</i> is the\nname of the machine on which the information was created;\n<i>uid</i> is the user&rsquo;s user ID; <i>gid</i> is the\nuser&rsquo;s current group ID; <i>len</i> and\n<i>aup_gids</i> refer to a counted array of groups to which\nthe user belongs. It is easy to impersonate a user.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>AUTH\n*authunix_create_default(void);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Calls\n<b>authunix_create</b>() with the appropriate\nparameters.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\ncallrpc(char *</b><i>host</i><b>, unsigned long</b>\n<i>prognum</i><b>, <br>\nunsigned long</b> <i>versnum</i><b>, unsigned long</b>\n<i>procnum</i><b>, <br>\nxdrproc_t</b> <i>inproc</i><b>, char *</b><i>in</i><b>, <br>\nxdrproc_t</b> <i>outproc</i><b>, char\n*</b><i>out</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Call the remote\nprocedure associated with <i>prognum</i>, <i>versnum</i>,\nand <i>procnum</i> on the machine, <i>host</i>. The\nparameter <i>in</i> is the address of the procedure&rsquo;s\nargument(s), and <i>out</i> is the address of where to place\nthe result(s); <i>inproc</i> is used to encode the\nprocedure&rsquo;s parameters, and <i>outproc</i> is used to\ndecode the procedure&rsquo;s results. This routine returns\nzero if it succeeds, or the value of <b>enum clnt_stat</b>\ncast to an integer if it fails. The routine\n<b>clnt_perrno</b>() is handy for translating failure\nstatuses into messages.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Warning:\ncalling remote procedures with this routine uses UDP/IP as a\ntransport; see <b>clntudp_create</b>() for restrictions. You\ndo not have control of timeouts or authentication using this\nroutine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>enum\nclnt_stat clnt_broadcast(unsigned long</b>\n<i>prognum</i><b>, <br>\nunsigned long</b> <i>versnum</i><b>, unsigned long</b>\n<i>procnum</i><b>, <br>\nxdrproc_t</b> <i>inproc</i><b>, char *</b><i>in</i><b>, <br>\nxdrproc_t</b> <i>outproc</i><b>, char *</b><i>out</i><b>,\n<br>\nresultproc_t</b> <i>eachresult</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Like\n<b>callrpc</b>(), except the call message is broadcast to\nall locally connected broadcast nets. Each time it receives\na response, this routine calls <b>eachresult</b>(), whose\nform is:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\"><b>eachresult(char\n*</b><i>out</i><b>, struct sockaddr_in\n*</b><i>addr</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">where\n<i>out</i> is the same as <i>out</i> passed to\n<b>clnt_broadcast</b>(), except that the remote\nprocedure&rsquo;s output is decoded there; <i>addr</i>\npoints to the address of the machine that sent the results.\nIf <b>eachresult</b>() returns zero, <b>clnt_broadcast</b>()\nwaits for more replies; otherwise it returns with\nappropriate status.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Warning:\nbroadcast sockets are limited in size to the maximum\ntransfer unit of the data link. For ethernet, this value is\n1500 bytes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>enum\nclnt_stat clnt_call(CLIENT *</b><i>clnt</i><b>, unsigned\nlong</b> <i>procnum</i><b>, <br>\nxdrproc_t</b> <i>inproc</i><b>, char *</b><i>in</i><b>, <br>\nxdrproc_t</b> <i>outproc</i><b>, char *</b><i>out</i><b>,\n<br>\nstruct timeval</b> <i>tout</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\ncalls the remote procedure <i>procnum</i> associated with\nthe client handle, <i>clnt</i>, which is obtained with an\nRPC client creation routine such as <b>clnt_create</b>().\nThe parameter <i>in</i> is the address of the\nprocedure&rsquo;s argument(s), and <i>out</i> is the address\nof where to place the result(s); <i>inproc</i> is used to\nencode the procedure&rsquo;s parameters, and <i>outproc</i>\nis used to decode the procedure&rsquo;s results; <i>tout</i>\nis the time allowed for results to come back.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clnt_destroy(CLIENT\n*</b><i>clnt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\ndestroys the client&rsquo;s RPC handle. Destruction usually\ninvolves deallocation of private data structures, including\n<i>clnt</i> itself. Use of <i>clnt</i> is undefined after\ncalling <b>clnt_destroy</b>(). If the RPC library opened the\nassociated socket, it will close it also. Otherwise, the\nsocket remains open.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CLIENT\n*clnt_create(char *</b><i>host</i><b>, unsigned long</b>\n<i>prog</i><b>, <br>\nunsigned long</b> <i>vers</i><b>, char\n*</b><i>proto</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Generic client\ncreation routine. <i>host</i> identifies the name of the\nremote host where the server is located. <i>proto</i>\nindicates which kind of transport protocol to use. The\ncurrently supported values for this field are\n&ldquo;udp&rdquo; and &ldquo;tcp&rdquo;. Default timeouts\nare set, but can be modified using\n<b>clnt_control</b>().</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Warning: using\nUDP has its shortcomings. Since UDP-based RPC messages can\nhold only up to 8 Kbytes of encoded data, this transport\ncannot be used for procedures that take large arguments or\nreturn huge results.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nclnt_control(CLIENT *</b><i>cl</i><b>, int</b>\n<i>req</i><b>, char *</b><i>info</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro used to\nchange or retrieve various information about a client\nobject. <i>req</i> indicates the type of operation, and\n<i>info</i> is a pointer to the information. For both UDP\nand TCP, the supported values of <i>req</i> and their\nargument types and what they do are:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\"><b>CLSET_TIMEOUT</b>\n<i>struct timeval</i> // set total timeout <b><br>\nCLGET_TIMEOUT</b> <i>struct timeval</i> // get total\ntimeout</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note: if you\nset the timeout using <b>clnt_control</b>(), the timeout\nparameter passed to <b>clnt_call</b>() will be ignored in\nall future calls.</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\"><b>CLGET_SERVER_ADDR</b>\n<i>struct sockaddr_in</i> // get server's address</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The following\noperations are valid for UDP only:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\"><b>CLSET_RETRY_TIMEOUT</b>\n<i>struct timeval</i> // set the retry timeout <b><br>\nCLGET_RETRY_TIMEOUT</b> <i>struct timeval</i> // get the\nretry timeout</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The retry\ntimeout is the time that &quot;UDP RPC&quot; waits for the\nserver to reply before retransmitting the request.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clnt_freeres(CLIENT\n*</b> <i>clnt</i><b>, xdrproc_t</b> <i>outproc</i><b>, char\n*</b><i>out</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\nfrees any data allocated by the RPC/XDR system when it\ndecoded the results of an RPC call. The parameter <i>out</i>\nis the address of the results, and <i>outproc</i> is the XDR\nroutine describing the results. This routine returns one if\nthe results were successfully freed, and zero otherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nclnt_geterr(CLIENT *</b><i>clnt</i><b>, struct rpc_err\n*</b><i>errp</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\ncopies the error structure out of the client handle to the\nstructure at address <i>errp</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nclnt_pcreateerror(char *</b><i>s</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Print a message\nto standard error indicating why a client RPC handle could\nnot be created. The message is prepended with string\n<i>s</i> and a colon. Used when a <b>clnt_create</b>(),\n<b>clntraw_create</b>(), <b>clnttcp_create</b>(), or\n<b>clntudp_create</b>() call fails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nclnt_perrno(enum clnt_stat</b> <i>stat</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Print a message\nto standard error corresponding to the condition indicated\nby <i>stat</i>. Used after <b>callrpc</b>().</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>clnt_perror(CLIENT\n*</b><i>clnt</i><b>, char *</b><i>s</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Print a message\nto standard error indicating why an RPC call failed;\n<i>clnt</i> is the handle used to do the call. The message\nis prepended with string <i>s</i> and a colon. Used after\n<b>clnt_call</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>char\n*clnt_spcreateerror(char *</b><i>s</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Like\n<b>clnt_pcreateerror</b>(), except that it returns a string\ninstead of printing to the standard error.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Bugs: returns\npointer to static data that is overwritten on each call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>char\n*clnt_sperrno(enum clnt_stat</b> <i>stat</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Take the same\narguments as <b>clnt_perrno</b>(), but instead of sending a\nmessage to the standard error indicating why an RPC call\nfailed, return a pointer to a string which contains the\nmessage. The string ends with a NEWLINE.</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>clnt_sperrno</b>()\nis used instead of <b>clnt_perrno</b>() if the program does\nnot have a standard error (as a program running as a server\nquite likely does not), or if the programmer does not want\nthe message to be output with <a href=\"https://man.page/3/printf\">printf(3)</a>, or if a\nmessage format different than that supported by\n<b>clnt_perrno</b>() is to be used. Note: unlike\n<b>clnt_sperror</b>() and <b>clnt_spcreateerror</b>(),\n<b>clnt_sperrno</b>() returns pointer to static data, but\nthe result will not get overwritten on each call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>char\n*clnt_sperror(CLIENT *</b><i>rpch</i><b>, char\n*</b><i>s</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Like\n<b>clnt_perror</b>(), except that (like\n<b>clnt_sperrno</b>()) it returns a string instead of\nprinting to standard error.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Bugs: returns\npointer to static data that is overwritten on each call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CLIENT\n*clntraw_create(unsigned long</b> <i>prognum</i><b>,\nunsigned long</b> <i>versnum</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\ncreates a toy RPC client for the remote program\n<i>prognum</i>, version <i>versnum</i>. The transport used\nto pass messages to the service is actually a buffer within\nthe process&rsquo;s address space, so the corresponding RPC\nserver should live in the same address space; see\n<b>svcraw_create</b>(). This allows simulation of RPC and\nacquisition of RPC overheads, such as round trip times,\nwithout any kernel interference. This routine returns NULL\nif it fails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CLIENT\n*clnttcp_create(struct sockaddr_in *</b><i>addr</i><b>, <br>\nunsigned long</b> <i>prognum</i><b>, unsigned long</b>\n<i>versnum</i><b>, <br>\nint *</b><i>sockp</i><b>, unsigned int</b> <i>sendsz</i><b>,\nunsigned int</b> <i>recvsz</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\ncreates an RPC client for the remote program <i>prognum</i>,\nversion <i>versnum</i>; the client uses TCP/IP as a\ntransport. The remote program is located at Internet address\n<i>*addr</i>. If <i>addr-&gt;sin_port</i> is zero, then it\nis set to the actual port that the remote program is\nlistening on (the remote <b>portmap</b> service is consulted\nfor this information). The parameter <i>sockp</i> is a\nsocket; if it is <b>RPC_ANYSOCK</b>, then this routine opens\na new one and sets <i>sockp</i>. Since TCP-based RPC uses\nbuffered I/O, the user may specify the size of the send and\nreceive buffers with the parameters <i>sendsz</i> and\n<i>recvsz</i>; values of zero choose suitable defaults. This\nroutine returns NULL if it fails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CLIENT\n*clntudp_create(struct sockaddr_in *</b><i>addr</i><b>, <br>\nunsigned long</b> <i>prognum</i><b>, unsigned long</b>\n<i>versnum</i><b>, <br>\nstruct timeval</b> <i>wait</i><b>, int\n*</b><i>sockp</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\ncreates an RPC client for the remote program <i>prognum</i>,\nversion <i>versnum</i>; the client uses use UDP/IP as a\ntransport. The remote program is located at Internet address\n<i>addr</i>. If <i>addr-&gt;sin_port</i> is zero, then it is\nset to actual port that the remote program is listening on\n(the remote <b>portmap</b> service is consulted for this\ninformation). The parameter <i>sockp</i> is a socket; if it\nis <b>RPC_ANYSOCK</b>, then this routine opens a new one and\nsets <i>sockp</i>. The UDP transport resends the call\nmessage in intervals of <i>wait</i> time until a response is\nreceived or until the call times out. The total time for the\ncall to time out is specified by <b>clnt_call</b>().</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Warning: since\nUDP-based RPC messages can hold only up to 8 Kbytes of\nencoded data, this transport cannot be used for procedures\nthat take large arguments or return huge results.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CLIENT\n*clntudp_bufcreate(struct sockaddr_in *</b><i>addr</i><b>,\n<br>\nunsigned long</b> <i>prognum</i><b>, unsigned long</b>\n<i>versnum</i><b>, <br>\nstruct timeval</b> <i>wait</i><b>, int *</b><i>sockp</i><b>,\n<br>\nunsigned int</b> <i>sendsize</i><b>, unsigned int</b>\n<i>recosize</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\ncreates an RPC client for the remote program <i>prognum</i>,\non <i>versnum</i>; the client uses use UDP/IP as a\ntransport. The remote program is located at Internet address\n<i>addr</i>. If <i>addr-&gt;sin_port</i> is zero, then it is\nset to actual port that the remote program is listening on\n(the remote <b>portmap</b> service is consulted for this\ninformation). The parameter <i>sockp</i> is a socket; if it\nis <b>RPC_ANYSOCK</b>, then this routine opens a new one and\nsets <i>sockp</i>. The UDP transport resends the call\nmessage in intervals of <i>wait</i> time until a response is\nreceived or until the call times out. The total time for the\ncall to time out is specified by <b>clnt_call</b>().</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This allows the\nuser to specify the maximum packet size for sending and\nreceiving UDP-based RPC messages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nget_myaddress(struct sockaddr_in\n*</b><i>addr</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Stuff the\nmachine&rsquo;s IP address into <i>*addr</i>, without\nconsulting the library routines that deal with\n<i>/etc/hosts</i>. The port number is always set to\n<b>htons(PMAPPORT)</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct\npmaplist *pmap_getmaps(struct sockaddr_in\n*</b><i>addr</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A user\ninterface to the <b>portmap</b> service, which returns a\nlist of the current RPC program-to-port mappings on the host\nlocated at IP address <i>*addr</i>. This routine can return\nNULL. The command <i>rpcinfo&nbsp;-p</i> uses this\nroutine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>unsigned\nshort pmap_getport(struct sockaddr_in *</b><i>addr</i><b>,\n<br>\nunsigned long</b> <i>prognum</i><b>, unsigned long</b>\n<i>versnum</i><b>, <br>\nunsigned int</b> <i>protocol</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A user\ninterface to the <b>portmap</b> service, which returns the\nport number on which waits a service that supports program\nnumber <i>prognum</i>, version <i>versnum</i>, and speaks\nthe transport protocol associated with <i>protocol</i>. The\nvalue of <i>protocol</i> is most likely <b>IPPROTO_UDP</b>\nor <b>IPPROTO_TCP</b>. A return value of zero means that the\nmapping does not exist or that the RPC system failed to\ncontact the remote <b>portmap</b> service. In the latter\ncase, the global variable <i>rpc_createerr</i> contains the\nRPC status.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>enum\nclnt_stat pmap_rmtcall(struct sockaddr_in\n*</b><i>addr</i><b>, <br>\nunsigned long</b> <i>prognum</i><b>, unsigned long</b>\n<i>versnum</i><b>, <br>\nunsigned long</b> <i>procnum</i><b>, <br>\nxdrproc_t</b> <i>inproc</i><b>, char *</b><i>in</i><b>, <br>\nxdrproc_t</b> <i>outproc</i><b>, char *</b><i>out</i><b>,\n<br>\nstruct timeval</b> <i>tout</i><b>, unsigned long\n*</b><i>portp</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A user\ninterface to the <b>portmap</b> service, which instructs\n<b>portmap</b> on the host at IP address <i>*addr</i> to\nmake an RPC call on your behalf to a procedure on that host.\nThe parameter <i>*portp</i> will be modified to the\nprogram&rsquo;s port number if the procedure succeeds. The\ndefinitions of other parameters are discussed in\n<b>callrpc</b>() and <b>clnt_call</b>(). This procedure\nshould be used for a &ldquo;ping&rdquo; and nothing else.\nSee also <b>clnt_broadcast</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\npmap_set(unsigned long</b> <i>prognum</i><b>, unsigned\nlong</b> <i>versnum</i><b>, <br>\nunsigned int</b> <i>protocol</i><b>, unsigned short</b>\n<i>port</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A user\ninterface to the <b>portmap</b> service, which establishes a\nmapping between the triple\n[<i>prognum</i>,<i>versnum</i>,<i>protocol</i>] and\n<i>port</i> on the machine&rsquo;s <b>portmap</b> service.\nThe value of <i>protocol</i> is most likely\n<b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>. This routine\nreturns one if it succeeds, zero otherwise. Automatically\ndone by <b>svc_register</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\npmap_unset(unsigned long</b> <i>prognum</i><b>, unsigned\nlong</b> <i>versnum</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A user\ninterface to the <b>portmap</b> service, which destroys all\nmapping between the triple\n[<i>prognum</i>,<i>versnum</i>,<i>*</i>] and <b>ports</b> on\nthe machine&rsquo;s <b>portmap</b> service. This routine\nreturns one if it succeeds, zero otherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nregisterrpc(unsigned long</b> <i>prognum</i><b>, unsigned\nlong</b> <i>versnum</i><b>, <br>\nunsigned long</b> <i>procnum</i><b>, char\n*(*</b><i>procname</i><b>)(char *), <br>\nxdrproc_t</b> <i>inproc</i><b>, xdrproc_t</b>\n<i>outproc</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Register\nprocedure <i>procname</i> with the RPC service package. If a\nrequest arrives for program <i>prognum</i>, version\n<i>versnum</i>, and procedure <i>procnum</i>,\n<i>procname</i> is called with a pointer to its\nparameter(s); <i>procname</i> should return a pointer to its\nstatic result(s); <i>inproc</i> is used to decode the\nparameters while <i>outproc</i> is used to encode the\nresults. This routine returns zero if the registration\nsucceeded, -1 otherwise.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Warning: remote\nprocedures registered in this form are accessed using the\nUDP/IP transport; see <b>svcudp_create</b>() for\nrestrictions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct\nrpc_createerr</b> <i>rpc_createerr</i><b>;</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A global\nvariable whose value is set by any RPC client creation\nroutine that does not succeed. Use the routine\n<b>clnt_pcreateerror</b>() to print the reason why.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvc_destroy(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\ndestroys the RPC service transport handle, <i>xprt</i>.\nDestruction usually involves deallocation of private data\nstructures, including <i>xprt</i> itself. Use of <i>xprt</i>\nis undefined after calling this routine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>fd_set</b>\n<i>svc_fdset</i><b>;</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A global\nvariable reflecting the RPC service side&rsquo;s read file\ndescriptor bit mask; it is suitable as a parameter to the\n<a href=\"https://man.page/2/select\">select(2)</a> system call. This is of interest only if a\nservice implementor does their own asynchronous event\nprocessing, instead of calling <b>svc_run</b>(). This\nvariable is read-only (do not pass its address to\n<a href=\"https://man.page/2/select\">select(2)</a>!), yet it may change after calls to\n<b>svc_getreqset</b>() or any creation routines.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int</b>\n<i>svc_fds</i><b>;</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Similar to\n<b>svc_fdset</b>, but limited to 32 file descriptors. This\ninterface is obsoleted by <b>svc_fdset</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>svc_freeargs(SVCXPRT\n*</b><i>xprt</i><b>, xdrproc_t</b> <i>inproc</i><b>, char\n*</b><i>in</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\nfrees any data allocated by the RPC/XDR system when it\ndecoded the arguments to a service procedure using\n<b>svc_getargs</b>(). This routine returns 1 if the results\nwere successfully freed, and zero otherwise.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>svc_getargs(SVCXPRT\n*</b><i>xprt</i><b>, xdrproc_t</b> <i>inproc</i><b>, char\n*</b><i>in</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A macro that\ndecodes the arguments of an RPC request associated with the\nRPC service transport handle, <i>xprt</i>. The parameter\n<i>in</i> is the address where the arguments will be placed;\n<i>inproc</i> is the XDR routine used to decode the\narguments. This routine returns one if decoding succeeds,\nand zero otherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>struct\nsockaddr_in *svc_getcaller(SVCXPRT\n*</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The approved\nway of getting the network address of the caller of a\nprocedure associated with the RPC service transport handle,\n<i>xprt</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvc_getreqset(fd_set *</b><i>rdfds</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine is\nof interest only if a service implementor does not call\n<b>svc_run</b>(), but instead implements custom asynchronous\nevent processing. It is called when the <a href=\"https://man.page/2/select\">select(2)</a>\nsystem call has determined that an RPC request has arrived\non some RPC socket(s); <i>rdfds</i> is the resultant read\nfile descriptor bit mask. The routine returns when all\nsockets associated with the value of <i>rdfds</i> have been\nserviced.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvc_getreq(int</b> <i>rdfds</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Similar to\n<b>svc_getreqset</b>(), but limited to 32 file descriptors.\nThis interface is obsoleted by <b>svc_getreqset</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nsvc_register(SVCXPRT *</b><i>xprt</i><b>, unsigned long</b>\n<i>prognum</i><b>, <br>\nunsigned long</b> <i>versnum</i><b>, <br>\nvoid (*</b><i>dispatch</i><b>)(svc_req *, SVCXPRT *), <br>\nunsigned long</b> <i>protocol</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Associates\n<i>prognum</i> and <i>versnum</i> with the service dispatch\nprocedure, <i>dispatch</i>. If <i>protocol</i> is zero, the\nservice is not registered with the <b>portmap</b> service.\nIf <i>protocol</i> is nonzero, then a mapping of the triple\n[<i>prognum</i>,<i>versnum</i>,<i>protocol</i>] to\n<i>xprt-&gt;xp_port</i> is established with the local\n<b>portmap</b> service (generally <i>protocol</i> is zero,\n<b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>). The procedure\n<i>dispatch</i> has the following form:</p>\n\n\n<p style=\"margin-left:28%; margin-top: 1em\">dispatch(struct\nsvc_req *request, SVCXPRT *xprt);</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<b>svc_register</b>() routine returns one if it succeeds,\nand zero otherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvc_run(void);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\nnever returns. It waits for RPC requests to arrive, and\ncalls the appropriate service procedure using\n<b>svc_getreq</b>() when one arrives. This procedure is\nusually waiting for a <a href=\"https://man.page/2/select\">select(2)</a> system call to\nreturn.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nsvc_sendreply(SVCXPRT *</b><i>xprt</i><b>, xdrproc_t</b>\n<i>outproc</i><b>, char *</b><i>out</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called by an\nRPC service&rsquo;s dispatch routine to send the results of\na remote procedure call. The parameter <i>xprt</i> is the\nrequest&rsquo;s associated transport handle; <i>outproc</i>\nis the XDR routine which is used to encode the results; and\n<i>out</i> is the address of the results. This routine\nreturns one if it succeeds, zero otherwise.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvc_unregister(unsigned long</b> <i>prognum</i><b>, unsigned\nlong</b> <i>versnum</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Remove all\nmapping of the double [<i>prognum</i>,<i>versnum</i>] to\ndispatch routines, and of the triple\n[<i>prognum</i>,<i>versnum</i>,<i>*</i>] to port number.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvcerr_auth(SVCXPRT *</b><i>xprt</i><b>, enum auth_stat</b>\n<i>why</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called by a\nservice dispatch routine that refuses to perform a remote\nprocedure call due to an authentication error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvcerr_decode(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called by a\nservice dispatch routine that cannot successfully decode its\nparameters. See also <b>svc_getargs</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvcerr_noproc(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called by a\nservice dispatch routine that does not implement the\nprocedure number that the caller requests.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvcerr_noprog(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called when the\ndesired program is not registered with the RPC package.\nService implementors usually do not need this routine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvcerr_progvers(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called when the\ndesired version of a program is not registered with the RPC\npackage. Service implementors usually do not need this\nroutine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvcerr_systemerr(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called by a\nservice dispatch routine when it detects a system error not\ncovered by any particular protocol. For example, if a\nservice can no longer allocate storage, it may call this\nroutine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nsvcerr_weakauth(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Called by a\nservice dispatch routine that refuses to perform a remote\nprocedure call due to insufficient authentication\nparameters. The routine calls <b>svcerr_auth(xprt,\nAUTH_TOOWEAK)</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SVCXPRT\n*svcfd_create(int</b> <i>fd</i><b>, unsigned int</b>\n<i>sendsize</i><b>, <br>\nunsigned int</b> <i>recvsize</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Create a\nservice on top of any open file descriptor. Typically, this\nfile descriptor is a connected socket for a stream protocol\nsuch as TCP. <i>sendsize</i> and <i>recvsize</i> indicate\nsizes for the send and receive buffers. If they are zero, a\nreasonable default is chosen.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SVCXPRT\n*svcraw_create(void);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\ncreates a toy RPC service transport, to which it returns a\npointer. The transport is really a buffer within the\nprocess&rsquo;s address space, so the corresponding RPC\nclient should live in the same address space; see\n<b>clntraw_create</b>(). This routine allows simulation of\nRPC and acquisition of RPC overheads (such as round trip\ntimes), without any kernel interference. This routine\nreturns NULL if it fails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SVCXPRT\n*svctcp_create(int</b> <i>sock</i><b>, unsigned int</b>\n<i>send_buf_size</i><b>, <br>\nunsigned int</b> <i>recv_buf_size</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\ncreates a TCP/IP-based RPC service transport, to which it\nreturns a pointer. The transport is associated with the\nsocket <i>sock</i>, which may be <b>RPC_ANYSOCK</b>, in\nwhich case a new socket is created. If the socket is not\nbound to a local TCP port, then this routine binds it to an\narbitrary port. Upon completion, <i>xprt-&gt;xp_sock</i> is\nthe transport&rsquo;s socket descriptor, and\n<i>xprt-&gt;xp_port</i> is the transport&rsquo;s port\nnumber. This routine returns NULL if it fails. Since\nTCP-based RPC uses buffered I/O, users may specify the size\nof buffers; values of zero choose suitable defaults.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SVCXPRT\n*svcudp_bufcreate(int</b> <i>sock</i><b>, unsigned int</b>\n<i>sendsize</i><b>, <br>\nunsigned int</b> <i>recosize</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This routine\ncreates a UDP/IP-based RPC service transport, to which it\nreturns a pointer. The transport is associated with the\nsocket <i>sock</i>, which may be <b>RPC_ANYSOCK</b>, in\nwhich case a new socket is created. If the socket is not\nbound to a local UDP port, then this routine binds it to an\narbitrary port. Upon completion, <i>xprt-&gt;xp_sock</i> is\nthe transport&rsquo;s socket descriptor, and\n<i>xprt-&gt;xp_port</i> is the transport&rsquo;s port\nnumber. This routine returns NULL if it fails.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This allows the\nuser to specify the maximum packet size for sending and\nreceiving UDP-based RPC messages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SVCXPRT\n*svcudp_create(int</b> <i>sock</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This call is\nequivalent to <i>svcudp_bufcreate(sock,SZ,SZ)</i> for some\ndefault size <i>SZ</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_accepted_reply(XDR *</b><i>xdrs</i><b>, struct\naccepted_reply *</b><i>ar</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\nencoding RPC reply messages. This routine is useful for\nusers who wish to generate RPC-style messages without using\nthe RPC package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_authunix_parms(XDR *</b><i>xdrs</i><b>, struct\nauthunix_parms *</b><i>aupp</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing UNIX credentials. This routine is useful for\nusers who wish to generate these credentials without using\nthe RPC authentication package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nxdr_callhdr(XDR *</b><i>xdrs</i><b>, struct rpc_msg\n*</b><i>chdr</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing RPC call header messages. This routine is useful\nfor users who wish to generate RPC-style messages without\nusing the RPC package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_callmsg(XDR *</b><i>xdrs</i><b>, struct rpc_msg\n*</b><i>cmsg</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing RPC call messages. This routine is useful for\nusers who wish to generate RPC-style messages without using\nthe RPC package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_opaque_auth(XDR *</b><i>xdrs</i><b>, struct opaque_auth\n*</b><i>ap</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing RPC authentication information messages. This\nroutine is useful for users who wish to generate RPC-style\nmessages without using the RPC package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_pmap(XDR *</b><i>xdrs</i><b>, struct pmap\n*</b><i>regs</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing parameters to various <b>portmap</b> procedures,\nexternally. This routine is useful for users who wish to\ngenerate these parameters without using the <b>pmap</b>\ninterface.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_pmaplist(XDR *</b><i>xdrs</i><b>, struct pmaplist\n**</b><i>rp</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing a list of port mappings, externally. This routine\nis useful for users who wish to generate these parameters\nwithout using the <b>pmap</b> interface.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_rejected_reply(XDR *</b><i>xdrs</i><b>, struct\nrejected_reply *</b><i>rr</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing RPC reply messages. This routine is useful for\nusers who wish to generate RPC-style messages without using\nthe RPC package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>bool_t\nxdr_replymsg(XDR *</b><i>xdrs</i><b>, struct rpc_msg\n*</b><i>rmsg</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Used for\ndescribing RPC reply messages. This routine is useful for\nusers who wish to generate RPC style messages without using\nthe RPC package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nxprt_register(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">After RPC\nservice transport handles are created, they should register\nthemselves with the RPC service package. This routine\nmodifies the global variable <i>svc_fds</i>. Service\nimplementors usually do not need this routine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>void\nxprt_unregister(SVCXPRT *</b><i>xprt</i><b>);</b></p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Before an RPC\nservice transport handle is destroyed, it should unregister\nitself with the RPC service package. This routine modifies\nthe global variable <i>svc_fds</i>. Service implementors\nusually do not need this routine.</p>\n\n<h2>ATTRIBUTES\n<a name=\"ATTRIBUTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">For an\nexplanation of the terms used in this section, see\n<a href=\"https://man.page/7/attributes\">attributes(7)</a>.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\">\n</td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"8%\">\n</td>\n<td width=\"8%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n</table>\n\n\n<p align=\"center\"><img src=\"grohtml-3289721.png\" alt=\"Image grohtml-3289721.png\"></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/xdr\">xdr(3)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmanuals:</p>\n\n<p style=\"margin-left:22%;\">Remote Procedure Calls:\nProtocol Specification <br>\nRemote Procedure Call Programming Guide <br>\nrpcgen Programming Guide</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>RPC: Remote\nProcedure Call Protocol Specification</i>, RFC&nbsp;1050,\nSun Microsystems, Inc., USC-ISI.</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS AND DESCRIPTION\">SYNOPSIS AND DESCRIPTION</a>","<a href=\"#ATTRIBUTES\">ATTRIBUTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}