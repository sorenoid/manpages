{"name":"glib::xsapi","body":"\n\n<h1 align=\"center\">Glib::xsapi</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Glib::xsapi -\ninternal API reference for GPerl.</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;gperl.h&gt;</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is the\nbinding developer&rsquo;s <small>API</small> reference for\nGPerl, automatically generated from the xs source files.\nThis header defines the public interface for use when\ncreating new Perl language bindings for GLib-based C\nlibraries.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">gperl.h\nincludes for you all the headers needed for writing XSUBs (\n<small>EXTERN</small> .h, perl.h, and <small>XSUB</small>\n.h), as well as all of GLib (via glib-object.h).</p>\n\n<h2>API\n<a name=\"API\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Miscellaneous</b>\n<br>\nVarious useful utilities defined in Glib.xs. <small><br>\nGPERL_CALL_BOOT</small> (name)</p>\n\n<p style=\"margin-left:17%;\">call the boot code of a module\nby symbol rather than by name.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">in a perl\nextension which uses several xs files but only one pm, you\nneed to bootstrap the other xs files in order to get their\nfunctions exported to perl. if the file has\n<small>MODULE</small> = Foo::Bar, the boot symbol would be\nboot_Foo__Bar.</p>\n\n<p style=\"margin-left:11%;\">void _gperl_call_XS (pTHX_ void\n(*subaddr) (pTHX_ <small>CV</small> *), <small>CV</small> *\ncv, <small>SV</small> ** <br>\nmark);</p>\n\n<p style=\"margin-left:17%;\">never use this function\ndirectly. see &quot;GPERL_CALL_BOOT&quot;.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for the\ncurious, this calls a perl sub by function pointer rather\nthan by name; call_sv requires that the xsub already be\nregistered, but we need this to call a function which will\nregister xsubs. this is an evil hack and should not be used\noutside of the <small>GPERL_CALL_BOOT</small> macro.\nit&rsquo;s implemented as a function to avoid code size\nbloat, and exported so that extension modules can pull the\nsame trick.</p>\n\n<p style=\"margin-left:11%;\">gpointer gperl_alloc_temp (int\nnbytes)</p>\n\n<p style=\"margin-left:17%;\">Allocate and return a pointer\nto an <i>nbytes</i>-long, zero-initialized, temporary buffer\nthat will be reaped at the next garbage collection sweep.\nThis is handy for allocating things that need to be\nalloc&rsquo;ed before a croak (since croak doesn&rsquo;t\nreturn and give you the chance to free them). The trick is\nthat the memory is allocated in a mortal perl scalar. See\nthe perl online manual for notes on using this\ntechnique.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Do <b>not</b>\nunder any circumstances attempt to call <b>g_free()</b>,\n<b>free()</b>, or any other deallocator on this pointer, or\nyou will crash the interpreter.</p>\n\n<p style=\"margin-left:11%;\">gchar *gperl_filename_from_sv (\n<small>SV</small> *sv)</p>\n\n<p style=\"margin-left:17%;\">Return a localized version of\nthe filename in the sv, using g_filename_from_utf8 (and\nconsequently this function might croak). The memory is\nallocated using gperl_alloc_temp.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small>\n*gperl_sv_from_filename (const gchar *filename)</p>\n\n<p style=\"margin-left:17%;\">Convert the filename into an\nutf8 string as used by gtk/glib and perl.</p>\n\n<p style=\"margin-left:11%;\">gboolean gperl_str_eq (const\nchar * a, const char * b);</p>\n\n<p style=\"margin-left:17%;\">Compare a pair of ascii\nstrings, considering &rsquo;-&rsquo; and &rsquo;_&rsquo; to\nbe equivalent. Used for things like enum value nicknames and\nsignal names.</p>\n\n<p style=\"margin-left:11%;\">guint gperl_str_hash\n(gconstpointer key)</p>\n\n<p style=\"margin-left:17%;\">Like <b>g_str_hash()</b>, but\nconsiders &rsquo;-&rsquo; and &rsquo;_&rsquo; to be\nequivalent.</p>\n\n<p style=\"margin-left:11%;\">GPerlArgv * gperl_argv_new\n()</p>\n\n<p style=\"margin-left:17%;\">Creates a new Perl argv object\nwhose members can then be passed to functions that request\nargc and argv style arguments.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the called\nfunction(s) modified argv, you can call gperl_argv_update to\nupdate Perl&rsquo;s @ARGV in the same way.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Remember to\ncall gperl_argv_free when you&rsquo;re done.</p>\n\n<p style=\"margin-left:11%;\">void gperl_argv_update\n(GPerlArgv *pargv)</p>\n\n<p style=\"margin-left:17%;\">Updates @ARGV to resemble the\nstored argv array.</p>\n\n<p style=\"margin-left:11%;\">void gperl_argv_free (GPerlArgv\n*pargv)</p>\n\n<p style=\"margin-left:17%;\">Frees any resources associated\nwith <i>pargv</i>.</p>\n\n<p style=\"margin-left:11%;\">char *\ngperl_format_variable_for_output ( <small>SV</small> *\nsv)</p>\n\n<p style=\"margin-left:17%;\">Formats the variable stored in\n<i>sv</i> for output in error messages. Like\n<b>SvPV_nolen()</b>, but ellipsizes real strings (i.e., not\nstringified references) at 20 chars to trim things down for\nerror messages.</p>\n\n<p style=\"margin-left:11%;\">gboolean gperl_sv_is_defined (\n<small>SV</small> *sv)</p>\n\n<p style=\"margin-left:17%;\">Checks the <small>SV</small>\n<i>sv</i> for definedness just like Perl&rsquo;s\n<b><i>defined()</i></b> would do. Most importantly, it\ncorrectly handles &quot;magical&quot; SVs, unlike bare\n<i>SvOK</i>. It&rsquo;s also NULL-safe.</p>\n\n<p style=\"margin-left:11%;\">void gperl_hv_take_sv (\n<small>HV</small> *hv, const char *key, size_t key_length,\n<small>SV</small> <br>\n*sv)</p>\n\n<p style=\"margin-left:17%;\">Tries to store <i>sv</i> in\n<i>hv</i>. Decreases <i>sv</i>&rsquo;s reference count if\nsomething goes wrong.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GError\nException Objects</b> <br>\nGError is a facility for propagating run-time error /\nexception information around in C, which is a language\nwithout native support for exceptions. GError uses a simple\nerror code, usually defined as an enum. Since the enums will\noverlap, GError includes the GQuark corresponding to a\nparticular error &quot;domain&quot; to tell you which error\ncodes will be used. There&rsquo;s also a string containing a\nspecific error message. The strings are arbitrary, and may\nbe translated, but the domains and codes are definite.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl has native\nsupport for exceptions, using &quot;eval&quot; as\n&quot;try&quot;, &quot;croak&quot; or &quot;die&quot; as\n&quot;throw&quot;, and &quot;if ($@)&quot; as\n&quot;catch&quot;. $@ may, in fact, be any scalar, including\nblessed objects.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">So, GPerl maps\nGLib&rsquo;s GError to Perl exceptions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since, as we\ndescribed above, error messages are not guaranteed to be\nunique everywhere, we need to support the use of the error\ndomains and codes. The obvious choice here is to use\nexception objects; however, to support blessed exception\nobjects, we must perform a little bit of black magic in the\nbindings. There is no built-in association between an error\ndomain quark and the GType of the corresponding error code\nenumeration, so the bindings supply both of these when\nspecifying the name of the package into which to bless\nexceptions of this domain. All GError-based exceptions\nderive from Glib::Error, of course, and this base class\nprovides all of the functionality, including\nstringification.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All\nyou&rsquo;ll really ever need to do is register error\ndomains with &quot;gperl_register_error_domain&quot;, and\nthrow errors with &quot;gperl_croak_gerror&quot;. <br>\nvoid gperl_register_error_domain (GQuark domain, GType\nerror_enum, <br>\nconst char * package)</p>\n\n<p style=\"margin-left:17%;\">Tell the bindings to bless\nGErrors with error-&gt;domain == <i>domain</i> into\n<i>package</i>, and use <i>error_enum</i> to find the\nnicknames for the error codes. This will call\n&quot;gperl_set_isa&quot; on <i>package</i> to add\n&quot;Glib::Error&quot; to <i>package</i>&rsquo;s @ISA.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>domain</i>\nmay not be 0, and <i>package</i> may not be\n<small>NULL</small> ; what would be the point?\n<i>error_enum</i> may be 0, in which case you&rsquo;ll get\nno fancy stringified error values.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_sv_from_gerror (GError * error)</p>\n\n<p style=\"margin-left:17%;\">You should rarely, if ever,\nneed to call this function. This is what turns a GError into\na Perl object.</p>\n\n<p style=\"margin-left:11%;\">gperl_gerror_from_sv (\n<small>SV</small> * sv, GError ** error)</p>\n\n<p style=\"margin-left:17%;\">You should rarely need this\nfunction. This parses a perl data structure into a GError.\nIf <i>sv</i> is undef (or the empty string), sets\n*<i>error</i> to <small>NULL,</small> otherwise, allocates a\nnew GError with &quot;g_error_new_literal()&quot; and writes\nthrough <i>error</i>; the caller is responsible for calling\n&quot;g_error_free()&quot;. (<b>gperl_croak_gerror()</b>\ndoes this, for example.)</p>\n\n<p style=\"margin-left:11%;\">void gperl_croak_gerror (const\nchar * ignored, GError * err)</p>\n\n<p style=\"margin-left:17%;\">Croak with an exception based\non <i>err</i>. <i>err</i> may not be <small>NULL.</small>\n<i>ignored</i> exists for backward compatibility, and is,\nwell, ignored. This function calls <b>croak()</b>, which\ndoes not return.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Since\n<b>croak()</b> does not return, this function handles the\nmagic behind not leaking the memory associated with the\n#GError. To use this you&rsquo;d do something like</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">PREINIT: <br>\nGError * error = NULL; <br>\nCODE: <br>\nif (!funtion_that_can_fail (something, &amp;error)) <br>\ngperl_croak_gerror (NULL, error);</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">It&rsquo;s just\nthat simple!</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GLog</b>\n<br>\nGLib has a message logging mechanism which it uses for the\n<b>g_return_if_fail()</b> assertion macros, etc.; it&rsquo;s\nreally versatile and allows you to set various levels to be\nfatal and whatnot. Libraries use these for various types of\nmessage reporting.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nlet you reroute those messages from Perl. By default, the\nwarning, critical, and message levels go through\nperl&rsquo;s <b>warn()</b>, and fatal ones go through\n<b>croak()</b>. [i&rsquo;m not sure that these get to\n<b>croak()</b> before GLib <b>abort()</b>s on them...] <br>\ngint gperl_handle_logs_for (const gchar * log_domain)</p>\n\n<p style=\"margin-left:17%;\">Route all g_logs for\n<i>log_domain</i> through gperl&rsquo;s log handling.\nYou&rsquo;ll have to register domains in each binding\nsubmodule, because there&rsquo;s no way we can know about\nthem down here.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">And,\ntechnically, this traps all the predefined log levels, not\nany of the ones you (or your library) may define for\nyourself.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GType /\nGEnum / GFlags</b> <br>\nvoid gperl_register_fundamental (GType gtype, const char *\npackage)</p>\n\n<p style=\"margin-left:17%;\">register a mapping between\n<i>gtype</i> and <i>package</i>. this is for\n&quot;fundamental&quot; types which have no other\nrequirements for metadata storage, such as GEnums, GFlags,\nor real GLib fundamental types like G_TYPE_INT,\nG_TYPE_FLOAT, etc.</p>\n\n<p style=\"margin-left:11%;\">void\ngperl_register_fundamental_alias (GType gtype, const char *\n<br>\npackage)</p>\n\n<p style=\"margin-left:17%;\">Makes <i>package</i> an alias\nfor <i>type</i>. This means that the package name specified\nby <i>package</i> will be mapped to <i>type</i> by\n<i>gperl_fundamental_type_from_package</i>, but\n<i>gperl_fundamental_package_from_type</i> won&rsquo;t map\n<i>type</i> to <i>package</i>. This is useful if you want to\nchange the canonical package name of a type while preserving\nbackwards compatibility with code which uses <i>package</i>\nto specify <i>type</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In order for\nthis to make sense, another package name should be\nregistered for <i>type</i> with\n<i>gperl_register_fundamental</i> or\n<i>gperl_register_fundamental_full</i>.</p>\n\n<p style=\"margin-left:11%;\">GPerlValueWrapperClass</p>\n\n<p style=\"margin-left:17%;\">Specifies the vtable that is to\nbe used to convert fundamental types to and from Perl\nvariables.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">typedef struct\n_GPerlValueWrapperClass GPerlValueWrapperClass; <br>\nstruct _GPerlValueWrapperClass { <br>\nGPerlValueWrapFunc wrap; <br>\nGPerlValueUnwrapFunc unwrap; <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The members are\nfunction pointers, each of which serves a specific purpose:\n<br>\nGPerlValueWrapFunc</p>\n\n<p style=\"margin-left:23%;\">Turns <i>value</i> into an\n<small>SV.</small> The caller assumes ownership of the\n<small>SV.</small> <i>value</i> is not to be modified.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">typedef SV*\n(*GPerlValueWrapFunc) (const GValue * value);</p>\n\n<p style=\"margin-left:17%;\">GPerlValueUnwrapFunc</p>\n\n<p style=\"margin-left:23%;\">Turns <i>sv</i> into its\nfundamental representation and stores the result in the\npre-configured <i>value</i>. <i>value</i> must not be\noverwritten; instead one of the various\n&quot;g_value_set_*()&quot; functions must be used or the\n&quot;value-&gt;data&quot; pointer must be modified\ndirectly.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">typedef void\n(*GPerlValueUnwrapFunc) (GValue * value, <br>\nSV * sv);</p>\n\n<p style=\"margin-left:11%;\">void\ngperl_register_fundamental_full (GType gtype, const char *\n<br>\npackage, GPerlValueWrapperClass * wrapper_class)</p>\n\n<p style=\"margin-left:17%;\">Like\ngperl_register_fundamental, registers a mapping between\n<i>gtype</i> and <i>package</i>. In addition, this also\ninstalls the function pointers in <i>wrapper_class</i> as\nthe handlers for the type. See GPerlValueWrapperClass.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>gperl_register_fundamental_full</i>\ndoes not copy the contents of <i>wrapper_class</i> -- it\nassumes that <i>wrapper_class</i> is statically allocated\nand that it will be valid for the whole lifetime of the\nprogram.</p>\n\n<p style=\"margin-left:11%;\">GType\ngperl_fundamental_type_from_package (const char *\npackage)</p>\n\n<p style=\"margin-left:17%;\">look up the GType corresponding\nto a <i>package</i> registered by\n<b>gperl_register_fundamental()</b>.</p>\n\n<p style=\"margin-left:11%;\">const char *\ngperl_fundamental_package_from_type (GType gtype)</p>\n\n<p style=\"margin-left:17%;\">look up the package\ncorresponding to a <i>gtype</i> registered by\n<b>gperl_register_fundamental()</b>.</p>\n\n<p style=\"margin-left:11%;\">GPerlValueWrapperClass *\ngperl_fundamental_wrapper_class_from_type <br>\n(GType gtype)</p>\n\n<p style=\"margin-left:17%;\">look up the wrapper class\ncorresponding to a <i>gtype</i> that has previously been\nregistered with\n<b>gperl_register_fundamental_full()</b>.</p>\n\n<p style=\"margin-left:11%;\">gboolean gperl_try_convert_enum\n(GType gtype, <small>SV</small> * sv, gint * val)</p>\n\n<p style=\"margin-left:17%;\">return <small>FALSE</small> if\n<i>sv</i> can&rsquo;t be mapped to a valid member of the\nregistered enum type <i>gtype</i>; otherwise, return\n<small>TRUE</small> write the new value to the int pointed\nto by <i>val</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">you&rsquo;ll\nneed this only in esoteric cases.</p>\n\n<p style=\"margin-left:11%;\">gint gperl_convert_enum (GType\ntype, <small>SV</small> * val)</p>\n\n<p style=\"margin-left:17%;\">croak if <i>val</i> is not part\nof <i>type</i>, otherwise return corresponding value</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_convert_back_enum_pass_unknown (GType type, gint\nval)</p>\n\n<p style=\"margin-left:17%;\">return a scalar containing the\nnickname of the enum value <i>val</i>, or the integer value\nof <i>val</i> if <i>val</i> is not a member of the enum\n<i>type</i>.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_convert_back_enum (GType type, gint val)</p>\n\n<p style=\"margin-left:17%;\">return a scalar which is the\nnickname of the enum value val, or croak if val is not a\nmember of the enum.</p>\n\n<p style=\"margin-left:11%;\">gboolean gperl_try_convert_flag\n(GType type, const char * val_p, gint * <br>\nval)</p>\n\n<p style=\"margin-left:17%;\">like\n<b>gperl_try_convert_enum()</b>, but for GFlags.</p>\n\n<p style=\"margin-left:11%;\">gint gperl_convert_flag_one\n(GType type, const char * val)</p>\n\n<p style=\"margin-left:17%;\">croak if <i>val</i> is not part\nof <i>type</i>, otherwise return corresponding value.</p>\n\n<p style=\"margin-left:11%;\">gint gperl_convert_flags (GType\ntype, <small>SV</small> * val)</p>\n\n<p style=\"margin-left:17%;\">collapse a list of strings to\nan integer with all the correct bits set, croak if anything\nis invalid.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_convert_back_flags (GType type, gint val)</p>\n\n<p style=\"margin-left:17%;\">convert a bitfield to a list of\nstrings.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Inheritance\nmanagement</b> <br>\nvoid gperl_set_isa (const char * child_package, const char *\n<br>\nparent_package)</p>\n\n<p style=\"margin-left:17%;\">tell perl that\n<i>child_package</i> inherits <i>parent_package</i>, after\nwhatever else is already there. equivalent to &quot;push\n@{$parent_package}::ISA, $child_package;&quot;</p>\n\n<p style=\"margin-left:11%;\">void gperl_prepend_isa (const\nchar * child_package, const char * <br>\nparent_package)</p>\n\n<p style=\"margin-left:17%;\">tell perl that\n<i>child_package</i> inherits <i>parent_package</i>, but\nbefore whatever else is already there. equivalent to\n&quot;unshift @{$parent_package}::ISA,\n$child_package;&quot;</p>\n\n<p style=\"margin-left:11%;\">GType gperl_type_from_package\n(const char * package)</p>\n\n<p style=\"margin-left:17%;\">Look up the GType associated\nwith <i>package</i>, regardless of how it was registered.\nReturns 0 if no mapping can be found.</p>\n\n<p style=\"margin-left:11%;\">const char *\ngperl_package_from_type (GType gtype)</p>\n\n<p style=\"margin-left:17%;\">Look up the name of the package\nassociated with <i>gtype</i>, regardless of how it was\nregistered. Returns <small>NULL</small> if no mapping can be\nfound.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Boxed type\nsupport for <small>SV</small></b> <br>\nIn order to allow GValues to hold perl SVs we need a GBoxed\nwrapper. <small><br>\nGPERL_TYPE_SV</small></p>\n\n<p style=\"margin-left:17%;\">Evaluates to the GType for SVs.\nThe bindings register a mapping between\n<small>GPERL_TYPE_SV</small> and the package\n&rsquo;Glib::Scalar&rsquo; with\n<b>gperl_register_boxed()</b>.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_sv_copy ( <small>SV</small> * sv)</p>\n\n<p style=\"margin-left:17%;\">implemented as &quot;newSVsv\n(sv)&quot;.</p>\n\n<p style=\"margin-left:11%;\">void gperl_sv_free (\n<small>SV</small> * sv)</p>\n\n<p style=\"margin-left:17%;\">implemented as\n&quot;SvREFCNT_dec (sv)&quot;.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>UTF-8</small>\nstrings with gchar</b> <br>\nBy convention, gchar* is assumed to point to\n<small>UTF8</small> string data, and char* points to ascii\nstring data. Here we define a pair of wrappers for the\nboilerplate of upgrading Perl strings. They are implemented\nas functions rather than macros, because comma expressions\nin macros are not supported by all compilers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nshould be used instead of newSVpv and SvPV_nolen in all\ncases which deal with gchar* types. <br>\ngchar * SvGChar ( <small>SV</small> * sv)</p>\n\n<p style=\"margin-left:17%;\">extract a <small>UTF8</small>\nstring from <i>sv</i>.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> * newSVGChar\n(const gchar * str)</p>\n\n<p style=\"margin-left:17%;\">copy a <small>UTF8</small>\nstring into a new <small>SV.</small> if str is\n<small>NULL,</small> returns &amp;PL_sv_undef.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>64 bit\nintegers</b> <br>\nOn 32 bit machines and even on some 64 bit machines,\nperl&rsquo;s <small>IV/UV</small> data type can only hold 32\nbit values. The following functions therefore convert 64 bit\nintegers to and from Perl strings if normal\n<small>IV/UV</small> conversion does not suffice. <br>\ngint64 SvGInt64 ( <small>SV</small> *sv)</p>\n\n<p style=\"margin-left:17%;\">Converts the string in\n<i>sv</i> to a signed 64 bit integer. If appropriate, uses\n&quot;SvIV&quot; instead.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> * newSVGInt64\n(gint64 value)</p>\n\n<p style=\"margin-left:17%;\">Creates a <small>PV</small>\nfrom the signed 64 bit integer in <i>value</i>. If\nappropriate, uses &quot;newSViv&quot; instead.</p>\n\n<p style=\"margin-left:11%;\">guint64 SvGUInt64 (\n<small>SV</small> *sv)</p>\n\n<p style=\"margin-left:17%;\">Converts the string in\n<i>sv</i> to an unsigned 64 bit integer. If appropriate,\nuses &quot;SvUV&quot; instead.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\nnewSVGUInt64 (guint64 value)</p>\n\n<p style=\"margin-left:17%;\">Creates a <small>PV</small>\nfrom the unsigned 64 bit integer in <i>value</i>. If\nappropriate, uses &quot;newSVuv&quot; instead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GBoxed</b>\n<br>\nGPerlBoxedWrapperClass</p>\n\n<p style=\"margin-left:17%;\">Specifies the vtable of\nfunctions to be used for bringing boxed types in and out of\nperl. The structure is defined like this:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">typedef struct\n_GPerlBoxedWrapperClass GPerlBoxedWrapperClass; <br>\nstruct _GPerlBoxedWrapperClass { <br>\nGPerlBoxedWrapFunc wrap; <br>\nGPerlBoxedUnwrapFunc unwrap; <br>\nGPerlBoxedDestroyFunc destroy; <br>\n};</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The members are\nfunction pointers, each of which serves a specific purpose:\n<br>\nGPerlBoxedWrapFunc</p>\n\n<p style=\"margin-left:23%;\">turn a boxed pointer into an\n<small>SV.</small> gtype is the type of the boxed pointer,\nand package is the package to which that gtype is registered\n(the lookup has already been done for you at this point). if\nown is true, the wrapper is responsible for freeing the\nobject; if it is false, some other code owns the object and\nyou must <small>NOT</small> free it.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">typedef SV*\n(*GPerlBoxedWrapFunc) (GType gtype, <br>\nconst char * package, <br>\ngpointer boxed, <br>\ngboolean own);</p>\n\n<p style=\"margin-left:17%;\">GPerlBoxedUnwrapFunc</p>\n\n<p style=\"margin-left:23%;\">turn an <small>SV</small> into\na boxed pointer. like GPerlBoxedWrapFunc, gtype and package\nare the registered type pair, already looked up for you (in\nthe process of finding the proper wrapper class). sv is the\nsv to unwrap.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">typedef\ngpointer (*GPerlBoxedUnwrapFunc) (GType gtype, <br>\nconst char * package, <br>\nSV * sv);</p>\n\n<p style=\"margin-left:17%;\">GPerlBoxedDestroyFunc</p>\n\n<p style=\"margin-left:23%;\">this will be called by\nGlib::Boxed::DESTROY, when the wrapper is destroyed. it is a\nhook that allows you to destroy an object owned by the\nwrapper; note, however, that you will have had to keep track\nyourself of whether the object was to be freed.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">typedef void\n(*GPerlBoxedDestroyFunc) (SV * sv);</p>\n\n<p style=\"margin-left:11%;\">void gperl_register_boxed\n(GType gtype, const char * package, <br>\nGPerlBoxedWrapperClass * wrapper_class)</p>\n\n<p style=\"margin-left:17%;\">Register a mapping between the\nGBoxed derivative <i>gtype</i> and <i>package</i>. The\nspecified, <i>wrapper_class</i> will be used to wrap and\nunwrap objects of this type; you may pass\n<small>NULL</small> to use the default wrapper (the same one\nreturned by <b>gperl_default_boxed_wrapper_class()</b>).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In normal\nusage, the standard opaque wrapper supplied by the library\nis sufficient and correct. In some cases, however, you want\na boxed type to map directly to a native perl type; for\nexample, some struct may be more appropriately represented\nas a hash in perl. Since the most necessary place for this\nconversion to happen is in <b>gperl_value_from_sv()</b> and\n<b>gperl_sv_from_value()</b>, the only reliable and robust\nway to implement this is a hook into\n<b>gperl_get_boxed_check()</b> and <b>gperl_new_boxed()</b>;\nthat is exactly the purpose of <i>wrapper_class</i>. See\n&quot;GPerlBoxedWrapperClass&quot;.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>gperl_register_boxed</i>\ndoes not copy the contents of <i>wrapper_class</i> -- it\nassumes that <i>wrapper_class</i> is statically allocated\nand that it will be valid for the whole lifetime of the\nprogram.</p>\n\n<p style=\"margin-left:11%;\">void gperl_register_boxed_alias\n(GType gtype, const char * package)</p>\n\n<p style=\"margin-left:17%;\">Makes <i>package</i> an alias\nfor <i>type</i>. This means that the package name specified\nby <i>package</i> will be mapped to <i>type</i> by\n<i>gperl_boxed_type_from_package</i>, but\n<i>gperl_boxed_package_from_type</i> won&rsquo;t map\n<i>type</i> to <i>package</i>. This is useful if you want to\nchange the canonical package name of a type while preserving\nbackwards compatibility with code which uses <i>package</i>\nto specify <i>type</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In order for\nthis to make sense, another package name should be\nregistered for <i>type</i> with\n<i>gperl_register_boxed</i>.</p>\n\n<p style=\"margin-left:11%;\">void\ngperl_register_boxed_synonym (GType registered_gtype, GType\n<br>\nsynonym_gtype)</p>\n\n<p style=\"margin-left:17%;\">Registers <i>synonym_gtype</i>\nas a synonym for <i>registered_gtype</i>. All boxed objects\nof type <i>synonym_gtype</i> will then be treated as if they\nwere of type <i>registered_gtype</i>, and\n<i>gperl_boxed_package_from_type</i> will return the package\nassociated with <i>registered_gtype</i>.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>registered_gtype</i>\nmust have been registered with <i>gperl_register_boxed</i>\nalready.</p>\n\n<p style=\"margin-left:11%;\">GType\ngperl_boxed_type_from_package (const char * package)</p>\n\n<p style=\"margin-left:17%;\">Look up the GType associated\nwith package <i>package</i>. Returns 0 if <i>type</i> is not\nregistered.</p>\n\n<p style=\"margin-left:11%;\">const char *\ngperl_boxed_package_from_type (GType type)</p>\n\n<p style=\"margin-left:17%;\">Look up the package associated\nwith GBoxed derivative <i>type</i>. Returns\n<small>NULL</small> if <i>type</i> is not registered.</p>\n\n<p style=\"margin-left:11%;\">GPerlBoxedWrapperClass *\ngperl_default_boxed_wrapper_class (void)</p>\n\n<p style=\"margin-left:17%;\">get a pointer to the default\nwrapper class; handy if you want to use the normal wrapper,\nwith minor modifications. note that you can just pass\n<small>NULL</small> to <b>gperl_register_boxed()</b>, so you\nreally only need this in fringe cases.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_new_boxed (gpointer boxed, GType gtype, gboolean\nown)</p>\n\n<p style=\"margin-left:17%;\">Export a GBoxed derivative to\nperl, according to whatever GPerlBoxedWrapperClass is\nregistered for <i>gtype</i>. In the default implementation,\nthis means wrapping an opaque perl object around the pointer\nto a small wrapper structure which stores some metadata,\nsuch as whether the boxed structure should be destroyed when\nthe wrapper is destroyed (controlled by <i>own</i>; if the\nwrapper owns the object, the wrapper is in charge of\ndestroying it&rsquo;s data).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This function\nmight end up calling other Perl code, so if you use it in\n<small>XS</small> code for a generic GType, make sure the\nstack pointer is set up correctly before the call, and\nrestore it after the call.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_new_boxed_copy (gpointer boxed, GType gtype)</p>\n\n<p style=\"margin-left:17%;\">Create a new copy of\n<i>boxed</i> and return an owner wrapper for it.\n<i>boxed</i> may not be <small>NULL.</small> See\n&quot;gperl_new_boxed&quot;.</p>\n\n<p style=\"margin-left:11%;\">gpointer gperl_get_boxed_check\n( <small>SV</small> * sv, GType gtype)</p>\n\n<p style=\"margin-left:17%;\">Extract the boxed pointer from\na wrapper; croaks if the wrapper <i>sv</i> is not blessed\ninto a derivative of the expected <i>gtype</i>. Does not\nallow undef.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GObject</b>\n<br>\nTo deal with the intricate interaction of the different\nreference-counting semantics of Perl objects versus\nGObjects, the bindings create a combined PerlObject+GObject,\nwith the GObject&rsquo;s pointer in magic attached to the\nPerl object, and the Perl object&rsquo;s pointer in the\nGObject&rsquo;s user data. Thus it&rsquo;s not really a\n&quot;wrapper&quot;, but we refer to it as one, because\n&quot;combined Perl object + GObject&quot; is a cumbersome\nand confusing mouthful.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">GObjects are\nrepresented as blessed hash references. The GObject user\ndata mechanism is not typesafe, and thus is used only for\nunsigned integer values; the Perl-level hash is available\nfor any type of user data. The combined nature of the\nwrapper means that data stored in the hash will stick around\nas long as the object is alive.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since the C\npointer is stored in attached magic, the C pointer is not\navailable to the Perl developer via the hash object, so\nthere&rsquo;s no need to worry about breaking it from\nperl.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Propers go to\nMarc Lehmann for dreaming most of this up. <br>\nvoid gperl_register_object (GType gtype, const char *\npackage)</p>\n\n<p style=\"margin-left:17%;\">tell the GPerl type subsystem\nwhat Perl package corresponds with a given GObject by GType.\nautomagically sets up @<i>package</i>::ISA for you.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">note that @ISA\nwill not be created for gtype until gtype&rsquo;s parent has\nbeen registered. if you are experiencing strange problems\nwith a class&rsquo; @ISA not being set up, change the order\nin which you register them.</p>\n\n<p style=\"margin-left:11%;\">void\ngperl_register_object_alias (GType gtype, const char *\npackage)</p>\n\n<p style=\"margin-left:17%;\">Makes <i>package</i> an alias\nfor <i>type</i>. This means that the package name specified\nby <i>package</i> will be mapped to <i>type</i> by\n<i>gperl_object_type_from_package</i>, but\n<i>gperl_object_package_from_type</i> won&rsquo;t map\n<i>type</i> to <i>package</i>. This is useful if you want to\nchange the canonical package name of a type while preserving\nbackwards compatibility with code which uses <i>package</i>\nto specify <i>type</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In order for\nthis to make sense, another package name should be\nregistered for <i>type</i> with\n<i>gperl_register_object</i>.</p>\n\n<p style=\"margin-left:11%;\">void gperl_register_sink_func\n(GType gtype, GPerlObjectSinkFunc func)</p>\n\n<p style=\"margin-left:17%;\">Tell <b>gperl_new_object()</b>\nto use <i>func</i> to claim ownership of objects derived\nfrom <i>gtype</i>.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>gperl_new_object()</b>\nalways refs a GObject when wrapping it for the first time.\nTo have the Perl wrapper claim ownership of a GObject as\npart of <b>gperl_new_object()</b>, you unref the object\nafter ref&rsquo;ing it. however, different GObject\nsubclasses have different ways to claim ownership; for\nexample, GtkObject simply requires you to call\n<b>gtk_object_sink()</b>. To make this concept generic, this\nfunction allows you to register a function to be called when\nthen wrapper should claim ownership of the object. The\n<i>func</i> registered for a given <i>type</i> will be\ncalled on any object for which &quot;g_type_isa\n(G_TYPE_OBJECT (object), type)&quot; succeeds.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If no sinkfunc\nis found for an object, <b>g_object_unref()</b> will be\nused.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Even though\nGObjects don&rsquo;t need sink funcs, we need to have them\nin Glib as a hook for upstream objects. If we create a\nGtkObject (or any other type of object which uses a\ndifferent way to claim ownership) via Glib::Object-&gt;new,\nany upstream wrappers, such as <b>gtk2perl_new_object()</b>,\nwill <b>not</b> be called. Having a sink func facility down\nhere enables us always to do the right thing.</p>\n\n<p style=\"margin-left:11%;\">void\ngperl_object_set_no_warn_unreg_subclass (GType gtype,\ngboolean <br>\nnowarn)</p>\n\n<p style=\"margin-left:17%;\">In versions 1.00 through 1.10x\nof Glib, the bindings required all types to be registered\nahead of time. Upon encountering an unknown type, the\nbindings would emit a warning to the effect of &quot;unknown\ntype &rsquo;Foo&rsquo;; representing as first known parent\ntype &rsquo;Bar&rsquo;&quot;. However, for some types, such\nas GtkStyle or GdkGC, the actual object returned is an\ninstance of a child type of a private implementation (e.g.,\na theme engine (&quot;BlueCurveStyle&quot;) or gdk backend\n(&quot;GdkGCX11&quot;)); we neither can nor should have\nregistered names for these types. Therefore, it is possible\nto tell the bindings not to warn about these unregistered\nsubclasses, and simply represent them as the parent\ntype.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">With 1.12x, the\nbindings will automatically register unknown classes into\nthe namespace Glib::Object::_Unregistered to avoid possible\nbreakage resulting from unknown ancestors of known children.\nTo preserve the old registered-as-unregistered behavior, the\nvalue installed by this function is used to prevent the\n_Unregistered mapping for such private backend classes.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note: this\nassumes <i>gtype</i> has already been registered with\n<b>gperl_register_object()</b>.</p>\n\n<p style=\"margin-left:11%;\">const char *\ngperl_object_package_from_type (GType gtype)</p>\n\n<p style=\"margin-left:17%;\">Get the package corresponding\nto <i>gtype</i>. If <i>gtype</i> is not a GObject or\nGInterface, returns <small>NULL.</small> If <i>gtype</i> is\nnot registered to a package name, a new name of the form\n&quot;Glib::Object::_Unregistered::$c_type_name&quot; will\nbe created, used to register the class, and then\nreturned.</p>\n\n<p style=\"margin-left:11%;\"><small>HV</small> *\ngperl_object_stash_from_type (GType gtype)</p>\n\n<p style=\"margin-left:17%;\">Get the stash corresponding to\n<i>gtype</i>; returns <small>NULL</small> if <i>gtype</i> is\nnot registered. The stash is useful for\n&quot;bless&quot;ing.</p>\n\n<p style=\"margin-left:11%;\">GType\ngperl_object_type_from_package (const char * package)</p>\n\n<p style=\"margin-left:17%;\">Inverse of\n<b>gperl_object_package_from_type()</b>, returns 0 if\n<i>package</i> is not registered.</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_new_object (GObject * object, gboolean own)</p>\n\n<p style=\"margin-left:17%;\">Use this function to get the\nperl part of a GObject. If <i>object</i> has never been seen\nby perl before, a new, empty perl object will be created and\nadded to a private key under <i>object</i>&rsquo;s qdata. If\n<i>object</i> already has a perl part, a new reference to it\nwill be created. The gobject + perl object together form a\ncombined object that is properly refcounted, i.e. both parts\nwill stay alive as long as at least one of them is alive,\nand only when both perl object and gobject are no longer\nreferenced will both be freed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The perl object\nwill be blessed into the package corresponding to the GType\nreturned by calling <b>G_OBJECT_TYPE()</b> on <i>object</i>;\nif that class has not been registered via\n<b>gperl_register_object()</b>, this function will emit a\nwarning to that effect (with <b>warn()</b>), and attempt to\nbless it into the first known class in the object&rsquo;s\nancestry. Since Glib::Object is already registered,\nyou&rsquo;ll get a Glib::Object if you are lazy, and thus\nthis function can fail only if <i>object</i> isn&rsquo;t\ndescended from GObject, in which case it croaks. (In\nreality, if you pass a non-GObject to this function,\nyou&rsquo;ll be lucky if you don&rsquo;t get a segfault, as\nthere&rsquo;s not really a way to trap that.) In practice\nthese warnings can be unavoidable, so you can use\n<b>gperl_object_set_no_warn_unreg_subclass()</b> to quell\nthem on a class-by-class basis.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">However, when\nperl code is calling a GObject constructor (any function\nwhich returns a new GObject), call <b>gperl_new_object()</b>\nwith <i>own</i> set to %TRUE; this will cause the first\nmatching sink function to be called on the GObject to claim\nownership of that object, so that it will be destroyed when\nthe perl object goes out of scope. The default sink func is\n<b>g_object_unref()</b>; other types should supply the\nproper function; e.g., GtkObject should use\n<b>gtk_object_sink()</b> here.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Returns the\nblessed perl object, or #&amp;PL_sv_undef if object was\n#NULL.</p>\n\n<p style=\"margin-left:11%;\">GObject * gperl_get_object (\n<small>SV</small> * sv)</p>\n\n<p style=\"margin-left:17%;\">retrieve the GObject pointer\nfrom a Perl object. Returns <small>NULL</small> if <i>sv</i>\nis not linked to a GObject.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note, this one\nis not safe -- in general you want to use\n<b>gperl_get_object_check()</b>.</p>\n\n<p style=\"margin-left:11%;\">GObject *\ngperl_get_object_check ( <small>SV</small> * sv, GType\ngtype);</p>\n\n<p style=\"margin-left:17%;\">croaks if <i>sv</i> is undef or\nis not blessed into the package corresponding to\n<i>gtype</i>. use this for bringing parameters into xsubs\nfrom perl. Returns the same as <b>gperl_get_object()</b>\n(provided it doesn&rsquo;t croak first).</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_object_check_type ( <small>SV</small> * sv, GType\ngtype)</p>\n\n<p style=\"margin-left:17%;\">Essentially the same as\n<b>gperl_get_object_check()</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This croaks if\nthe types aren&rsquo;t compatible.</p>\n\n<p style=\"margin-left:11%;\">typedef GObject GObject_noinc\n<br>\ntypedef GObject GObject_ornull <br>\nnewSVGObject(obj) <br>\nnewSVGObject_noinc(obj) <br>\nSvGObject(sv) <br>\nSvGObject_ornull(sv)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GValue</b>\n<br>\nGValue is GLib&rsquo;s generic value container, and it is\nbecause of GValue that the run time type handling of GObject\nparameters and GClosure marshaling can function, and most\nusages of these functions will be from those two points.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Client code\nwill run into uses for <b>gperl_sv_from_value()</b> and\n<b>gperl_value_from_sv()</b> when trying to convert lists of\nparameters into GValue arrays and the like. <br>\ngboolean gperl_value_from_sv (GValue * value,\n<small>SV</small> * sv)</p>\n\n<p style=\"margin-left:17%;\">set a <i>value</i> from a\nwhatever is in <i>sv</i>. <i>value</i> must be initialized\nso the code knows what kind of value to coerce out of\n<i>sv</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Return value is\nalways <small>TRUE</small> ; if the code knows how to\nperform the conversion, it croaks. (The return value is for\nbackward compatibility.) In reality, this really ought to\nalways succeed; a failed conversion should be considered a\nbug or unimplemented code!</p>\n\n<p style=\"margin-left:11%;\"><small>SV</small> *\ngperl_sv_from_value (const GValue * value)</p>\n\n<p style=\"margin-left:17%;\">Coerce whatever is in\n<i>value</i> into a perl scalar and return it.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Croaks if the\ncode doesn&rsquo;t know how to perform the conversion.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Might end up\ncalling other Perl code. So if you use this function in\n<small>XS</small> code for a generic GType, make sure the\nstack pointer is set up correctly before the call, and\nrestore it after the call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GClosure /\nGPerlClosure</b> <br>\nGPerlClosure is a wrapper around the gobject library&rsquo;s\nGClosure with special handling for marshalling perl\nsubroutines as callbacks. This is specially tuned for use\nwith GSignal and stuff like io watch, timeout, and idle\nhandlers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For generic\ncallback functions, which need parameters but do not get\nregistered with the type system, this is sometimes overkill.\nSee GPerlCallback, below. <br>\nGClosure * gperl_closure_new ( <small>SV</small> * callback,\n<small>SV</small> * data, gboolean swap)</p>\n\n<p style=\"margin-left:17%;\">Create and return a new\nGPerlClosure. <i>callback</i> and <i>data</i> will be copied\nfor storage; <i>callback</i> must not be\n<small>NULL.</small> If <i>swap</i> is <small>TRUE,</small>\n<i>data</i> will be swapped with the instance during\ninvocation (this is used to implement\n<b>g_signal_connect_swapped()</b>).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If compiled\nunder a thread-enabled perl, the closure will be created and\nmarshaled in such a way as to ensure that the same\ninterpreter which created the closure will be used to invoke\nit.</p>\n\n<p style=\"margin-left:11%;\">GClosure *\ngperl_closure_new_with_marshaller ( <small>SV</small> *\ncallback, <small>SV</small> * data, <br>\ngboolean swap, GClosureMarshal marshaller)</p>\n\n<p style=\"margin-left:17%;\">Like\n&quot;gperl_closure_new&quot;, but uses a caller-supplied\nmarshaller. This is provided for use in those sticky\ncircumstances when you just can&rsquo;t do it any other way;\nin general, you want to use the default marshaller, which\nyou get if you provide <small>NULL</small> for\n<i>marshaller</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you use you\nown marshaller, you need to take care of everything\nyourself, including swapping the instance and data if\n&quot;GPERL_CLOSURE_SWAP_DATA (closure)&quot; is true,\ncalling &quot;gperl_run_exception_handlers&quot; if\n<small>ERRSV</small> is true after invoking the perl sub,\nand ensuring that you properly use the\n&quot;marshal_data&quot; parameter as the perl interpreter\nwhen <small>PERL_IMPLICIT_CONTEXT</small> is defined. See\nthe implementation of the default marshaller,\n&quot;gperl_closure_marshal&quot;, in Glib/GClosure.xs for\ninspiration.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GPerlCallback</b>\n<br>\ngeneric callback functions usually get invoked directly, and\nare not passed parameter lists as GValues. we could very\neasily wrap up such generic callbacks with something that\nconverts the parameters to GValues and then channels\neverything through GClosure, but this has two problems: 1)\nthe above implementation of GClosure is tuned to marshalling\nsignal handlers, which always have an instance object, and\n2) it&rsquo;s more work than is strictly necessary.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">additionally,\ngeneric callbacks aren&rsquo;t always kind to the GClosure\nparadigm.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">so,\nhere&rsquo;s GPerlCallback, which is designed specifically\nto run generic callback functions. it reads parameters off\nthe C stack and converts them into parameters on the perl\nstack. (it uses the GValue to/from <small>SV</small>\nmechanism to do so, but doesn&rsquo;t allocate any temps on\nthe heap.) the callback object itself stores the parameter\ntype list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">unfortunately,\nsince the data element is always last, but the number of\narguments is not known until we have the callback object, we\ncan&rsquo;t pass gperl_callback_invoke directly to functions\nrequiring a callback; you&rsquo;ll have to write a proxy\ncallback which calls gperl_callback_invoke. <br>\nGPerlCallback * gperl_callback_new ( <small>SV</small> *\nfunc, <small>SV</small> * data, gint <br>\nn_params, GType param_types[], GType return_type)</p>\n\n<p style=\"margin-left:17%;\">Create and return a new\nGPerlCallback; use gperl_callback_destroy when you are\nfinished with it.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>func</i>:\nperl subroutine to call. this <small>SV</small> will be\ncopied, so don&rsquo;t worry about reference counts. must\n<b>not</b> be #NULL.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>data</i>:\nscalar to pass to <i>func</i> in addition to all other\narguments. the <small>SV</small> will be copied, so\ndon&rsquo;t worry about reference counts. may be #NULL.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>n_params</i>:\nthe number of elements in <i>param_types</i>.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>param_types</i>:\nthe #GType of each argument that should be passed from the\ninvocation to <i>func</i>. may be #NULL if <i>n_params</i>\nis zero, otherwise it must be <i>n_params</i> elements long\nor nasty things will happen. this array will be copied; see\n<b>gperl_callback_invoke()</b> for how it is used.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><i>return_type</i>:\nthe #GType of the return value, or 0 if the function has\nvoid return.</p>\n\n<p style=\"margin-left:11%;\">void gperl_callback_destroy\n(GPerlCallback * callback)</p>\n\n<p style=\"margin-left:17%;\">Dispose of <i>callback</i>.</p>\n\n<p style=\"margin-left:11%;\">void gperl_callback_invoke\n(GPerlCallback * callback, GValue * <br>\nreturn_value, ...)</p>\n\n<p style=\"margin-left:17%;\">Marshall the variadic\nparameters according to <i>callback</i>&rsquo;s param_types,\nand then invoke <i>callback</i>&rsquo;s subroutine in scalar\ncontext, or void context if the return type is G_TYPE_VOID.\nIf <i>return_value</i> is not <small>NULL,</small> then\nvalue returned (if any) will be copied into\n<i>return_value</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A typical\ncallback handler would look like this:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">static gint\n<br>\nreal_c_callback (Foo * f, Bar * b, int a, gpointer data)\n<br>\n{ <br>\nGPerlCallback * callback = (GPerlCallback*)data; <br>\nGValue return_value = {0,}; <br>\ngint retval; <br>\ng_value_init (&amp;return_value, callback-&gt;return_type);\n<br>\ngperl_callback_invoke (callback, &amp;return_value, <br>\nf, b, a); <br>\nretval = g_value_get_int (&amp;return_value); <br>\ng_value_unset (&amp;return_value); <br>\nreturn retval; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Exception\nHandling</b> <br>\nLike Event, Tk, and most other callback-using, event-based\nperl modules, Glib traps exceptions that happen in\ncallbacks. To enable your code to do something about these\nexceptions, Glib stores a list of exception handlers which\nwill be called on the trapped exceptions. This is completely\ndistinct from the $SIG{__DIE__} mechanism provided by Perl\nitself, for various reasons (not the least of which is that\nthe Perl docs and source code say that $SIG{__DIE__} is\nintended for running as the program is about to exit, and\nother behaviors may be removed in the future (apparently a\nsource of much debate on p5p)). <br>\nint gperl_install_exception_handler (GClosure * closure)</p>\n\n<p style=\"margin-left:17%;\">Install a GClosure to be\nexecuted when <b>gperl_closure_invoke()</b> traps an\nexception. The closure should return boolean (\n<small>TRUE</small> if the handler should remain installed)\nand expect to receive a perl scalar. This scalar will be a\nprivate copy of <small>ERRSV</small> ($@) which the handler\ncan mangle to its heart&rsquo;s content.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The return\nvalue is an integer id tag that may be passed to\n<b>gperl_removed_exception_handler()</b>.</p>\n\n<p style=\"margin-left:11%;\">void\ngperl_remove_exception_handler (guint tag)</p>\n\n<p style=\"margin-left:17%;\">Remove the exception handler\nidentified by <i>tag</i>, as returned by\n<b>gperl_install_exception_handler()</b>. If <i>tag</i>\ncannot be found, this does nothing.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>WARNING:</small>\nthis function locks a global data structure, so do\n<small>NOT</small> call it recursively. also, calling this\nfrom within an exception handler will result in a deadlock\nsituation. if you want to remove your handler just have it\nreturn <small>FALSE.</small></p>\n\n<p style=\"margin-left:11%;\">void\ngperl_run_exception_handlers (void)</p>\n\n<p style=\"margin-left:17%;\">Invoke whatever exception\nhandlers are installed. You will need this if you have\nwritten a custom marshaler. Uses the value of the global\n<small>ERRSV.</small></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GSignal</b>\n<br>\nvoid gperl_signal_set_marshaller_for (GType instance_type,\nchar * <br>\ndetailed_signal, GClosureMarshal marshaller)</p>\n\n<p style=\"margin-left:17%;\">You need this function only in\nrare cases, usually as workarounds for bad signal parameter\ntypes or to implement writable arguments. Use the given\n<i>marshaller</i> to marshal all handlers for\n<i>detailed_signal</i> on <i>instance_type</i>.\n&quot;gperl_signal_connect&quot; will look for marshallers\nregistered here, and apply them to the GPerlClosure it\ncreates for the given callback being connected.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A canonical\nform of <i>detailed_signal</i> will be used so that\n<i>marshaller</i> is applied for all possible spellings of\nthe signal name.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Use the helper\nmacros in gperl_marshal.h to help write your marshaller\nfunction. That header, which is installed with the Glib\nmodule but not #included through gperl.h, includes\ncommentary and examples which you should follow closely to\navoid nasty bugs. Use the Source, Luke.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><small>WARNING:</small>\nBend over backwards and turn your head around 720 degrees\nbefore attempting to write a GPerlClosure marshaller without\nusing the macros in gperl_marshal.h. If you absolutely\ncannot use those macros, be certain to understand what those\nmacros do so you can get the semantics correct, and keep\nyour code synchronized with them, or you may miss very\nimportant bugfixes.</p>\n\n<p style=\"margin-left:11%;\">gulong gperl_signal_connect (\n<small>SV</small> * instance, char * detailed_signal,\n<small>SV</small> <br>\n* callback, <small>SV</small> * data, GConnectFlags\nflags)</p>\n\n<p style=\"margin-left:17%;\">The actual workhorse behind\nGObject::signal_connect, the binding for g_signal_connect,\nfor use from within <small>XS.</small> This creates a\n&quot;GPerlClosure&quot; wrapper for the given\n<i>callback</i> and <i>data</i>, and connects that closure\nto the signal named <i>detailed_signal</i> on the given\nGObject <i>instance</i>. This is only good for named\nsignals. <i>flags</i> is the same as for\n<b>g_signal_connect()</b>. <i>data</i> may be\n<small>NULL,</small> but <i>callback</i> must not be.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Returns the id\nof the installed callback.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/perlapi\">perlapi(1)</a>,\n<a href=\"https://man.page/1/perlguts\">perlguts(1)</a>, GLib Reference Manual, <b>Glib</b>(3pm),\n<b>Glib::devel</b>(3pm).</p>\n\n<h2>AUTHORS\n<a name=\"AUTHORS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This file was\nautomatically generated from the source code of the Glib\nmodule, which is maintained by the gtk2-perl team.</p>\n\n<h2>LICENSE\n<a name=\"LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright (C)\n2003 by the gtk2-perl team (see the file\n<small>AUTHORS</small> for the full list)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the terms of the <small>GNU</small> Library General\nPublic License as published by the Free Software Foundation;\neither version 2.1 of the License, or (at your option) any\nlater version.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\ndistributed in the hope that it will be useful, but\n<small>WITHOUT ANY WARRANTY</small> ; without even the\nimplied warranty of <small>MERCHANTABILITY</small> or\n<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the\n<small>GNU</small> Library General Public License for more\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You should have\nreceived a copy of the <small>GNU</small> Library General\nPublic License along with this library; if not, write to the\nFree Software Foundation, Inc., 51 Franklin Street, Fifth\nFloor, Boston, <small>MA 02110-1301 USA.</small></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#API\">API</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHORS\">AUTHORS</a>","<a href=\"#LICENSE\">LICENSE</a>"],"level":3}