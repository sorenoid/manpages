{"name":"endian","description":"htobe16,\nhtole16, be16toh, le16toh, htobe32, htole32, be32toh,\nle32toh, htobe64, htole64, be64toh, le64toh - convert values\nbetween host and big-/little-endian byte order","body":"\n\n<h1 align=\"center\">ENDIAN</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">htobe16,\nhtole16, be16toh, le16toh, htobe32, htole32, be32toh,\nle32toh, htobe64, htole64, be64toh, le64toh - convert values\nbetween host and big-/little-endian byte order</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;endian.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>uint16_t\nhtobe16(uint16_t</b> <i>host_16bits</i><b>); <br>\nuint16_t htole16(uint16_t</b> <i>host_16bits</i><b>); <br>\nuint16_t be16toh(uint16_t</b> <i>big_endian_16bits</i><b>);\n<br>\nuint16_t le16toh(uint16_t</b>\n<i>little_endian_16bits</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>uint32_t\nhtobe32(uint32_t</b> <i>host_32bits</i><b>); <br>\nuint32_t htole32(uint32_t</b> <i>host_32bits</i><b>); <br>\nuint32_t be32toh(uint32_t</b> <i>big_endian_32bits</i><b>);\n<br>\nuint32_t le32toh(uint32_t</b>\n<i>little_endian_32bits</i><b>);</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>uint64_t\nhtobe64(uint64_t</b> <i>host_64bits</i><b>); <br>\nuint64_t htole64(uint64_t</b> <i>host_64bits</i><b>); <br>\nuint64_t be64toh(uint64_t</b> <i>big_endian_64bits</i><b>);\n<br>\nuint64_t le64toh(uint64_t</b>\n<i>little_endian_64bits</i><b>);</b></p>\n\n<p style=\"margin-left:5%; margin-top: 1em\">Feature Test\nMacro Requirements for glibc (see\n<a href=\"https://man.page/7/feature_test_macros\">feature_test_macros(7)</a>):</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>htobe16</b>(),\n<b>htole16</b>(), <b>be16toh</b>(), <b>le16toh</b>(),\n<b>htobe32</b>(), <b>htole32</b>(), <b>be32toh</b>(),\n<b>le32toh</b>(), <b>htobe64</b>(), <b>htole64</b>(),\n<b>be64toh</b>(), <b>le64toh</b>(): <br>\nSince glibc 2.19: <br>\n_DEFAULT_SOURCE <br>\nIn glibc up to and including 2.19: <br>\n_BSD_SOURCE</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nconvert the byte encoding of integer values from the byte\norder that the current CPU (the &quot;host&quot;) uses, to\nand from little-endian and big-endian byte order.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The number,\n<i>nn</i>, in the name of each function indicates the size\nof integer handled by the function, either 16, 32, or 64\nbits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\nwith names of the form &quot;htobe<i>nn</i>&quot; convert\nfrom host byte order to big-endian order.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\nwith names of the form &quot;htole<i>nn</i>&quot; convert\nfrom host byte order to little-endian order.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\nwith names of the form &quot;be<i>nn</i>toh&quot; convert\nfrom big-endian order to host byte order.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The functions\nwith names of the form &quot;le<i>nn</i>toh&quot; convert\nfrom little-endian order to host byte order.</p>\n\n<h2>VERSIONS\n<a name=\"VERSIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nwere added to glibc in version 2.9.</p>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nare nonstandard. Similar functions are present on the BSDs,\nwhere the required header file is\n<i>&lt;sys/endian.h&gt;</i> instead of\n<i>&lt;endian.h&gt;</i>. Unfortunately, NetBSD, FreeBSD, and\nglibc haven&rsquo;t followed the original OpenBSD naming\nconvention for these functions, whereby the <i>nn</i>\ncomponent always appears at the end of the function name\n(thus, for example, in NetBSD, FreeBSD, and glibc, the\nequivalent of OpenBSDs &quot;betoh32&quot; is\n&quot;be32toh&quot;).</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These functions\nare similar to the older <a href=\"https://man.page/3/byteorder\">byteorder(3)</a> family of\nfunctions. For example, <b>be32toh</b>() is identical to\n<b>ntohl</b>().</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The advantage\nof the <a href=\"https://man.page/3/byteorder\">byteorder(3)</a> functions is that they are\nstandard functions available on all UNIX systems. On the\nother hand, the fact that they were designed for use in the\ncontext of TCP/IP means that they lack the 64-bit and\nlittle-endian variants described in this page.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow display the results of converting an integer from host\nbyte order to both little-endian and big-endian byte order.\nSince host byte order is either little-endian or big-endian,\nonly one of these conversions will have an effect. When we\nrun this program on a little-endian system such as x86-32,\nwe see the following:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\n<b>./a.out</b> <br>\nx.u32 = 0x44332211 <br>\nhtole32(x.u32) = 0x44332211 <br>\nhtobe32(x.u32) = 0x11223344</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;endian.h&gt; <br>\n#include &lt;stdint.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nunion { <br>\nuint32_t u32; <br>\nuint8_t arr[4]; <br>\n} x;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n\n\n<p>x.arr[0] = 0x11;</p><td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"30%\"></td>\n<td width=\"8%\"></td>\n<td width=\"54%\">\n\n\n<p>/* Lowest-address byte */</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">x.arr[1] = 0x22; <br>\nx.arr[2] = 0x33;</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n\n\n<p>x.arr[3] = 0x44;</p><td width=\"17%\"></td>\n<td width=\"-9%\"></td>\n<td width=\"30%\"></td>\n<td width=\"8%\"></td>\n<td width=\"54%\">\n\n\n<p>/* Highest-address byte */</p></td></tr>\n</table>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">printf(&quot;x.u32\n= %#x\\n&quot;, x.u32); <br>\nprintf(&quot;htole32(x.u32) = %#x\\n&quot;, htole32(x.u32));\n<br>\nprintf(&quot;htobe32(x.u32) = %#x\\n&quot;,\nhtobe32(x.u32));</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/3/bswap\">bswap(3)</a>,\n<a href=\"https://man.page/3/byteorder\">byteorder(3)</a></p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#VERSIONS\">VERSIONS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":3}