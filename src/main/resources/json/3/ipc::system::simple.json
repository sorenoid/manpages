{"name":"ipc::system::simple","description":"IPC::System::Simple\n- Run commands simply, with detailed diagnostics","body":"\n\n<h1 align=\"center\">IPC::System::Simple</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">IPC::System::Simple\n- Run commands simply, with detailed diagnostics</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(system systemx capture capturex);\n<br>\nsystem(&quot;some_command&quot;); # Command succeeds or\ndies! <br>\nsystem(&quot;some_command&quot;,@args); # Succeeds or dies,\navoids shell if @args <br>\nsystemx(&quot;some_command&quot;,@args); # Succeeds or dies,\nNEVER uses the shell <br>\n# Capture the output of a command (just like backticks).\nDies on error. <br>\nmy $output = capture(&quot;some_command&quot;); <br>\n# Just like backticks in list context. Dies on error. <br>\nmy @output = capture(&quot;some_command&quot;); <br>\n# As above, but avoids the shell if @args is non-empty <br>\nmy $output = capture(&quot;some_command&quot;, @args); <br>\n# As above, but NEVER invokes the shell. <br>\nmy $output = capturex(&quot;some_command&quot;, @args); <br>\nmy @output = capturex(&quot;some_command&quot;, @args);</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Calling\nPerl&rsquo;s in-built &quot;system()&quot; function is easy,\ndetermining if it was successful is <i>hard</i>. Let&rsquo;s\nface it, $? isn&rsquo;t the nicest variable in the world to\nplay with, and even if you <i>do</i> check it, producing a\nwell-formatted error string takes a lot of work.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;IPC::System::Simple&quot;\ntakes the hard work out of calling external commands. In\nfact, if you want to be really lazy, you can just write:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(system);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and all of your\n&quot;system&quot; commands will either succeed (run to\ncompletion and return a zero exit value), or die with rich\ndiagnostic messages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;IPC::System::Simple&quot; module also provides a\nsimple replacement to Perl&rsquo;s backticks operator.\nSimply write:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(capture);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and then use\nthe &quot;<b>capture()</b>&quot; command just like\nyou&rsquo;d use backticks. If there&rsquo;s an error, it\nwill die with a detailed description of what went wrong.\nBetter still, you can even use &quot;capturex()&quot; to run\nthe equivalent of backticks, but without the shell:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(capturex); <br>\nmy $result = capturex($command, @args);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you want\nmore power than the basic interface, including the ability\nto specify which exit values are acceptable, trap errors, or\nprocess diagnostics, then read on!</p>\n\n<h2>ADVANCED SYNOPSIS\n<a name=\"ADVANCED SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw( <br>\ncapture capturex system systemx run runx $EXITVAL EXIT_ANY\n<br>\n); <br>\n# Run a command, throwing exception on failure <br>\nrun(&quot;some_command&quot;); <br>\nrunx(&quot;some_command&quot;,@args); # Run a command,\navoiding the shell <br>\n# Do the same thing, but with the drop-in system\nreplacement. <br>\nsystem(&quot;some_command&quot;); <br>\nsystemx(&quot;some_command&quot;, @args); <br>\n# Run a command which must return 0..5, avoid the shell, and\nget the <br>\n# exit value (we could also look at $EXITVAL) <br>\nmy $exit_value = runx([0..5], &quot;some_command&quot;,\n@args); <br>\n# The same, but any exit value will do. <br>\nmy $exit_value = runx(EXIT_ANY, &quot;some_command&quot;,\n@args); <br>\n# Capture output into $result and throw exception on failure\n<br>\nmy $result = capture(&quot;some_command&quot;); <br>\n# Check exit value from captured command <br>\nprint &quot;some_command exited with status\n$EXITVAL\\n&quot;; <br>\n# Captures into @lines, splitting on $/ <br>\nmy @lines = capture(&quot;some_command&quot;); <br>\n# Run a command which must return 0..5, capture the output\ninto <br>\n# @lines, and avoid the shell. <br>\nmy @lines = capturex([0..5], &quot;some_command&quot;,\n@args);</p>\n\n<h2>ADVANCED USAGE\n<a name=\"ADVANCED USAGE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>run() and\nsystem()</b> <br>\n&quot;IPC::System::Simple&quot; provides a subroutine called\n&quot;run&quot;, that executes a command using the same\nsemantics as Perl&rsquo;s built-in &quot;system&quot;:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(run); <br>\nrun(&quot;cat *.txt&quot;); # Execute command via the shell\n<br>\nrun(&quot;cat&quot;,&quot;/etc/motd&quot;); # Execute\ncommand without shell</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The primary\ndifference between Perl&rsquo;s in-built system and the\n&quot;run&quot; command is that &quot;run&quot; will throw\nan exception on failure, and allows a list of acceptable\nexit values to be set. See &quot;Exit values&quot; for\nfurther information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In fact, you\ncan even have &quot;IPC::System::Simple&quot; replace the\ndefault &quot;system&quot; function for your package so it\nhas the same behaviour:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(system); <br>\nsystem(&quot;cat *.txt&quot;); # system now succeeds or\ndies!</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;system&quot;\nand &quot;run&quot; are aliases to each other.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See also\n&quot;<b>runx()</b>, <b>systemx()</b> and\n<b>capturex()</b>&quot; for variants of &quot;system()&quot;\nand &quot;run()&quot; that never invoke the shell, even with\na single argument.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>capture()</b>\n<br>\nA second subroutine, named &quot;capture&quot; executes a\ncommand with the same semantics as Perl&rsquo;s built-in\nbackticks (and &quot;qx()&quot;):</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(capture); <br>\n# Capture text while invoking the shell. <br>\nmy $file = capture(&quot;cat /etc/motd&quot;); <br>\nmy @lines = capture(&quot;cat /etc/passwd&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However unlike\nregular backticks, which always use the shell,\n&quot;capture&quot; will bypass the shell when called with\nmultiple arguments:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"># Capture text\nwhile avoiding the shell. <br>\nmy $file = capture(&quot;cat&quot;, &quot;/etc/motd&quot;);\n<br>\nmy @lines = capture(&quot;cat&quot;,\n&quot;/etc/passwd&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See also\n&quot;<b>runx()</b>, <b>systemx()</b> and\n<b>capturex()</b>&quot; for a variant of\n&quot;capture()&quot; that never invokes the shell, even\nwith a single argument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>runx(),\nsystemx() and capturex()</b> <br>\nThe &quot;runx()&quot;, &quot;systemx()&quot; and\n&quot;capturex()&quot; commands are identical to the\nmulti-argument forms of &quot;run()&quot;,\n&quot;system()&quot; and &quot;capture()&quot; respectively,\nbut <i>never</i> invoke the shell, even when called with a\nsingle argument. These forms are particularly useful when a\ncommand&rsquo;s argument list <i>might</i> be empty, for\nexample:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">systemx($cmd,\n@args);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The use of\n&quot;systemx()&quot; here guarantees that the shell will\n<i>never</i> be invoked, even if @args is empty.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Exception\nhandling</b> <br>\nIn the case where the command returns an unexpected status,\nboth &quot;run&quot; and &quot;capture&quot; will throw an\nexception, which if not caught will terminate your program\nwith an error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Capturing the\nexception is easy:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">eval { <br>\nrun(&quot;cat *.txt&quot;); <br>\n}; <br>\nif ($@) { <br>\nprint &quot;Something went wrong - $@\\n&quot;; <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See the\ndiagnostics section below for more details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>Exception\ncases</i></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;IPC::System::Simple&quot;\nconsiders the following to be unexpected, and worthy of\nexception:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Failing to start entirely (eg, command not found,\npermission denied).</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Returning an exit value other than zero (but see\nbelow).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Being killed by a signal.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"5%\"></td>\n<td width=\"83%\">\n\n\n<p>Being passed tainted data (in taint mode).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Exit\nvalues</b> <br>\nTraditionally, system commands return a zero status for\nsuccess and a non-zero status for failure.\n&quot;IPC::System::Simple&quot; will default to throwing an\nexception if a non-zero exit value is returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You may specify\na range of values which are considered acceptable exit\nvalues by passing an <i>array reference</i> as the first\nargument. The special constant &quot;EXIT_ANY&quot; can be\nused to allow <i>any</i> exit value to be returned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(run system capture EXIT_ANY); <br>\nrun( [0..5], &quot;cat *.txt&quot;); # Exit values 0-5 are\nOK <br>\nsystem( [0..5], &quot;cat *.txt&quot;); # This works the\nsame way <br>\nmy @lines = capture( EXIT_ANY, &quot;cat *.txt&quot;); # Any\nexit is fine.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;run&quot; and replacement &quot;system&quot;\nsubroutines returns the exit value of the process:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">my $exit_value\n= run( [0..5], &quot;cat *.txt&quot;); <br>\n# OR: <br>\nmy $exit_value = system( [0..5] &quot;cat *.txt&quot;); <br>\nprint &quot;Program exited with value\n$exit_value\\n&quot;;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>$EXITVAL</i></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The exit value\nof any command executed by &quot;IPC::System::Simple&quot;\ncan always be retrieved from the\n$IPC::System::Simple::EXITVAL variable:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is\nparticularly useful when inspecting results from\n&quot;capture&quot;, which returns the captured text from\nthe command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">use\nIPC::System::Simple qw(capture $EXITVAL EXIT_ANY); <br>\nmy @enemies_defeated = capture(EXIT_ANY,\n&quot;defeat_evil&quot;, &quot;/dev/mordor&quot;); <br>\nprint &quot;Program exited with value $EXITVAL\\n&quot;;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">$EXITVAL will\nbe set to &quot;-1&quot; if the command did not exit\nnormally (eg, being terminated by a signal) or did not\nstart. In this situation an exception will also be\nthrown.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>WINDOWS-SPECIFIC\n<small>NOTES</small></b> <br>\nThe &quot;run&quot; subroutine make available the full\n32-bit exit value on Win32 systems. This has been true since\n&quot;IPC::System::Simple&quot; v0.06 when called with\nmultiple arguments, and since v1.25 when called with a\nsingle argument. This is different from the previous\nversions of &quot;IPC::System::Simple&quot; and from\nPerl&rsquo;s in-build &quot;system()&quot; function, which\ncan only handle 8-bit return values.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;capture&quot; subroutine always returns the 32-bit\nexit value under Windows. The &quot;capture&quot; subroutine\nalso never uses the shell, even when passed a single\nargument.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n&quot;run&quot; subroutine always uses a shell when passed a\nsingle argument. On <small>NT</small> systems, it uses\n&quot;cmd.exe&quot; in the system root, and on non-NT\nsystems it uses &quot;command.com&quot; in the system\nroot.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As of\n&quot;IPC::System::Simple&quot; v1.25, the &quot;runx&quot;\nand &quot;capturex&quot; subroutines, as well as\nmultiple-argument calls to the &quot;run&quot; and\n&quot;capture&quot; subroutines, have their arguments\nproperly quoted, so that arugments with spaces and the like\nwork properly. Unfortunately, this breaks any attempt to\ninvoke the shell itself. If you really need to execute\n&quot;cmd.exe&quot; or &quot;command.com&quot;, use the\nsingle-argument form. For single-argument calls to\n&quot;run&quot; and &quot;capture&quot;, the argument must\nbe properly shell-quoted in advance of the call.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Versions of\n&quot;IPC::System::Simple&quot; before v0.09 would not\nsearch the &quot;PATH&quot; environment variable when the\nmulti-argument form of &quot;run()&quot; was called.\nVersions from v0.09 onwards correctly search the path\nprovided the command is provided including the extension\n(eg, &quot;notepad.exe&quot; rather than just\n&quot;notepad&quot;, or &quot;gvim.bat&quot; rather than\njust &quot;gvim&quot;). If no extension is provided,\n&quot;.exe&quot; is assumed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Signals are not\nsupported on Windows systems. Sending a signal to a Windows\nprocess will usually cause it to exit with the signal number\nused.</p>\n\n<h2>DIAGNOSTICS\n<a name=\"DIAGNOSTICS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;%s&quot;\nfailed to start: &quot;%s&quot;</p>\n\n<p style=\"margin-left:17%;\">The command specified did not\neven start. It may not exist, or you may not have permission\nto use it. The reason it could not start (as determined from\n$!) will be provided.</p>\n\n<p style=\"margin-left:11%;\">&quot;%s&quot; unexpectedly\nreturned exit value %d</p>\n\n<p style=\"margin-left:17%;\">The command ran successfully,\nbut returned an exit value we did not expect. The value\nreturned is reported.</p>\n\n<p style=\"margin-left:11%;\">&quot;%s&quot; died to signal\n&quot;%s&quot; (%d) %s</p>\n\n<p style=\"margin-left:17%;\">The command was killed by a\nsignal. The name of the signal will be reported, or\n&quot;UNKNOWN&quot; if it cannot be determined. The signal\nnumber is always reported. If we detected that the process\ndumped core, then the string &quot;and dumped core&quot; is\nappended.</p>\n\n<p style=\"margin-left:11%;\">IPC::System::Simple::%s called\nwith no arguments</p>\n\n<p style=\"margin-left:17%;\">You attempted to call\n&quot;run&quot; or &quot;capture&quot; but did not provide\nany arguments at all. At the very lease you need to supply a\ncommand to run.</p>\n\n<p style=\"margin-left:11%;\">IPC::System::Simple::%s called\nwith no command</p>\n\n<p style=\"margin-left:17%;\">You called &quot;run&quot; or\n&quot;capture&quot; with a list of acceptable exit values,\nbut no actual command.</p>\n\n<p style=\"margin-left:11%;\">IPC::System::Simple::%s called\nwith tainted argument &quot;%s&quot;</p>\n\n<p style=\"margin-left:17%;\">You called &quot;run&quot; or\n&quot;capture&quot; with tainted (untrusted) arguments,\nwhich is almost certainly a bad idea. To untaint your\narguments you&rsquo;ll need to pass your data through a\nregular expression and use the resulting match variables.\nSee &quot;Laundering and Detecting Tainted Data&quot; in\nperlsec for more information.</p>\n\n<p style=\"margin-left:11%;\">IPC::System::Simple::%s called\nwith tainted environment $ENV{%s}</p>\n\n<p style=\"margin-left:17%;\">You called &quot;run&quot; or\n&quot;capture&quot; but part of your environment was tainted\n(untrusted). You should either delete the named environment\nvariable before calling &quot;run&quot;, or set it to an\nuntainted value (usually one set inside your program). See\n&quot;Cleaning Up Your Path&quot; in perlsec for more\ninformation.</p>\n\n<p style=\"margin-left:11%;\">Error in IPC::System::Simple\nplumbing: &quot;%s&quot; - &quot;%s&quot;</p>\n\n<p style=\"margin-left:17%;\">Implementing the\n&quot;capture&quot; command involves dark and terrible\nmagicks involving pipes, and one of them has sprung a leak.\nThis could be due to a lack of file descriptors, although\nthere are other possibilities.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you are able\nto reproduce this error, you are encouraged to submit a bug\nreport according to the &quot;Reporting bugs&quot; section\nbelow.</p>\n\n<p style=\"margin-left:11%;\">Internal error in\nIPC::System::Simple: &quot;%s&quot;</p>\n\n<p style=\"margin-left:17%;\">You&rsquo;ve found a bug in\n&quot;IPC::System::Simple&quot;. Please check to see if an\nupdated version of &quot;IPC::System::Simple&quot; is\navailable. If not, please file a bug report according to the\n&quot;Reporting bugs&quot; section below.</p>\n\n<p style=\"margin-left:11%;\">IPC::System::Simple::%s called\nwith undefined command</p>\n\n<p style=\"margin-left:17%;\">You&rsquo;ve passed the\nundefined value as a command to be executed. While this is a\nvery Zen-like action, it&rsquo;s not supported by\nPerl&rsquo;s current implementation.</p>\n\n<h2>DEPENDENCIES\n<a name=\"DEPENDENCIES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This module\ndepends upon Win32::Process when used on Win32 system.\n&quot;Win32::Process&quot; is bundled as a core module in\nActivePerl 5.6 and above.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are no\nnon-core dependencies on non-Win32 systems.</p>\n\n<h2>COMPARISON TO OTHER APIs\n<a name=\"COMPARISON TO OTHER APIs\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Perl provides a\nrange of in-built functions for handling external commands,\nand <small>CPAN</small> provides even more. The\n&quot;IPC::System::Simple&quot; differentiates itself from\nother options by providing: <br>\nExtremely detailed diagnostics</p>\n\n<p style=\"margin-left:17%;\">The diagnostics produced by\n&quot;IPC::System::Simple&quot; are designed to provide as\nmuch information as possible. Rather than requiring the\ndeveloper to inspect $?, &quot;IPC::System::Simple&quot;\ndoes the hard work for you.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If an odd exit\nstatus is provided, you&rsquo;re informed of what it is. If\na signal kills your process, you are informed of both its\nname and number. If tainted data or environment prevents\nyour command from running, you are informed of exactly which\ndata or environmental variable is tainted.</p>\n\n<p style=\"margin-left:11%;\">Exceptions on failure</p>\n\n\n<p style=\"margin-left:17%;\">&quot;IPC::System::Simple&quot;\ntakes an aggressive approach to error handling. Rather than\nallow commands to fail silently, exceptions are thrown when\nunexpected results are seen. This allows for easy\ndevelopment using a try/catch style, and avoids the\npossibility of accidentally continuing after a failed\ncommand.</p>\n\n<p style=\"margin-left:11%;\">Easy access to exit status</p>\n\n<p style=\"margin-left:17%;\">The &quot;run&quot;,\n&quot;system&quot; and &quot;capture&quot; commands all set\n$EXITVAL, making it easy to determine the exit status of a\ncommand. Additionally, the &quot;system&quot; and\n&quot;run&quot; interfaces return the exit status.</p>\n\n<p style=\"margin-left:11%;\">Consistent interfaces</p>\n\n<p style=\"margin-left:17%;\">When called with multiple\narguments, the &quot;run&quot;, &quot;system&quot; and\n&quot;capture&quot; interfaces <i>never</i> invoke the\nshell. This differs from the in-built Perl\n&quot;system&quot; command which may invoke the shell under\nWindows when called with multiple arguments. It differs from\nthe in-built Perl backticks operator which always invokes\nthe shell.</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n&quot;system&quot; is exported, the exotic form &quot;system\n{ $cmd } @args&quot; is not supported. Attemping to use the\nexotic form is a syntax error. This affects the calling\npackage <i>only</i>. Use &quot;CORE::system&quot; if you\nneed it, or consider using the autodie module to replace\n&quot;system&quot; with lexical scope.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Core dumps are\nonly checked for when a process dies due to a signal. It is\nnot believed there are any systems where processes can dump\ncore without dying to a signal.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;WIFSTOPPED&quot;\nstatus is not checked, as perl never spawns processes with\nthe &quot;WUNTRACED&quot; option.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Signals are not\nsupported under Win32 systems, since they don&rsquo;t work\nat all like Unix signals. Win32 signals cause commands to\nexit with a given exit value, which this modules <i>does</i>\ncapture.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reporting\nbugs</b> <br>\nBefore reporting a bug, please check to ensure you are using\nthe most recent version of &quot;IPC::System::Simple&quot;.\nYour problem may have already been fixed in a new\nrelease.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can find\nthe &quot;IPC::System::Simple&quot; bug-tracker at\n&lt;http://rt.cpan.org/Public/Dist/Display.html?Name=IPC-System-Simple&gt;\n. Please check to see if your bug has already been reported;\nif in doubt, report yours anyway.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Submitting a\npatch and/or failing test case will greatly expedite the\nfixing of bugs.</p>\n\n<h2>FEEDBACK\n<a name=\"FEEDBACK\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you find\nthis module useful, please consider rating it on the\n<small>CPAN</small> Ratings service at\n&lt;http://cpanratings.perl.org/rate/?distribution=IPC-System-Simple&gt;\n.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The module\nauthor loves to hear how &quot;IPC::System::Simple&quot; has\nmade your life better (or worse). Feedback can be sent to\n&lt;pjf@perltraining.com.au&gt;.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">autodie uses\n&quot;IPC::System::Simple&quot; to provide succeed-or-die\nreplacements to &quot;system&quot; (and other built-ins)\nwith lexical scope.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><small>POSIX</small>\n, IPC::Run::Simple, perlipc, perlport, IPC::Run, IPC::Run3,\nWin32::Process</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Paul Fenwick\n&lt;pjf@cpan.org&gt;</p>\n\n<h2>COPYRIGHT AND LICENSE\n<a name=\"COPYRIGHT AND LICENSE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Copyright (C)\n2006-2008 by Paul Fenwick</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This library is\nfree software; you can redistribute it and/or modify it\nunder the same terms as Perl itself, either Perl version\n5.6.0 or, at your option, any later version of Perl 5 you\nmay have available.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ADVANCED SYNOPSIS\">ADVANCED SYNOPSIS</a>","<a href=\"#ADVANCED USAGE\">ADVANCED USAGE</a>","<a href=\"#DIAGNOSTICS\">DIAGNOSTICS</a>","<a href=\"#DEPENDENCIES\">DEPENDENCIES</a>","<a href=\"#COMPARISON TO OTHER APIs\">COMPARISON TO OTHER APIs</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#FEEDBACK\">FEEDBACK</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#COPYRIGHT AND LICENSE\">COPYRIGHT AND LICENSE</a>"],"level":3}