{"name":"loop","body":"\n\n<h1 align=\"center\">LOOP</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">loop,\nloop-control - loop devices</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;linux/loop.h&gt;</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The loop device\nis a block device that maps its data blocks not to a\nphysical device such as a hard disk or optical disk drive,\nbut to the blocks of a regular file in a filesystem or to\nanother block device. This can be useful for example to\nprovide a block device for a filesystem image stored in a\nfile, so that it can be mounted with the <b>mount</b>(8)\ncommand. You could do</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>dd\nif=/dev/zero of=file.img bs=1MiB count=10</b> <br>\n$ <b>sudo losetup /dev/loop4 file.img</b> <br>\n$ <b>sudo mkfs -t ext4 /dev/loop4</b> <br>\n$ <b>sudo mkdir /myloopdev</b> <br>\n$ <b>sudo mount /dev/loop4 /myloopdev</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<b>losetup</b>(8) for another example.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A transfer\nfunction can be specified for each loop device for\nencryption and decryption purposes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operations are provided by the loop block\ndevice: <b><br>\nLOOP_SET_FD</b></p>\n\n<p style=\"margin-left:22%;\">Associate the loop device with\nthe open file whose file descriptor is passed as the (third)\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_CLR_FD</b></p>\n\n<p style=\"margin-left:22%;\">Disassociate the loop device\nfrom any file descriptor.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_SET_STATUS</b></p>\n\n<p style=\"margin-left:22%;\">Set the status of the loop\ndevice using the (third) <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument. This\nargument is a pointer to a <i>loop_info</i> structure,\ndefined in <i>&lt;linux/loop.h&gt;</i> as:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nloop_info { <br>\nint lo_number; /* ioctl r/o */ <br>\ndev_t lo_device; /* ioctl r/o */ <br>\nunsigned long lo_inode; /* ioctl r/o */ <br>\ndev_t lo_rdevice; /* ioctl r/o */ <br>\nint lo_offset; <br>\nint lo_encrypt_type; <br>\nint lo_encrypt_key_size; /* ioctl w/o */ <br>\nint lo_flags; /* ioctl r/w (r/o before <br>\nLinux 2.6.25) */ <br>\nchar lo_name[LO_NAME_SIZE]; <br>\nunsigned char lo_encrypt_key[LO_KEY_SIZE]; <br>\n/* ioctl w/o */ <br>\nunsigned long lo_init[2]; <br>\nchar reserved[4]; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The encryption\ntype (<i>lo_encrypt_type</i>) should be one of\n<b>LO_CRYPT_NONE</b>, <b>LO_CRYPT_XOR</b>,\n<b>LO_CRYPT_DES</b>, <b>LO_CRYPT_FISH2</b>,\n<b>LO_CRYPT_BLOW</b>, <b>LO_CRYPT_CAST128</b>,\n<b>LO_CRYPT_IDEA</b>, <b>LO_CRYPT_DUMMY</b>,\n<b>LO_CRYPT_SKIPJACK</b>, or (since Linux 2.6.0)\n<b>LO_CRYPT_CRYPTOAPI</b>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\n<i>lo_flags</i> field is a bit mask that can include zero or\nmore of the following: <b><br>\nLO_FLAGS_READ_ONLY</b></p>\n\n<p style=\"margin-left:32%;\">The loopback device is\nread-only.</p>\n\n<p style=\"margin-left:22%;\"><b>LO_FLAGS_AUTOCLEAR</b>\n(since Linux 2.6.25)</p>\n\n<p style=\"margin-left:32%;\">The loopback device will\nautodestruct on last close.</p>\n\n<p style=\"margin-left:22%;\"><b>LO_FLAGS_PARTSCAN</b> (since\nLinux 3.2)</p>\n\n<p style=\"margin-left:32%;\">Allow automatic partition\nscanning.</p>\n\n<p style=\"margin-left:22%;\"><b>LO_FLAGS_DIRECT_IO</b>\n(since Linux 4.10)</p>\n\n<p style=\"margin-left:32%;\">Use direct I/O mode to access\nthe backing file.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The only\n<i>lo_flags</i> that can be modified by\n<b>LOOP_SET_STATUS</b> are <b>LO_FLAGS_AUTOCLEAR</b> and\n<b>LO_FLAGS_PARTSCAN</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_GET_STATUS</b></p>\n\n<p style=\"margin-left:22%;\">Get the status of the loop\ndevice. The (third) <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument must be a\npointer to a <i>struct loop_info</i>.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_CHANGE_FD</b> (since\nLinux 2.6.5)</p>\n\n<p style=\"margin-left:22%;\">Switch the backing store of the\nloop device to the new file identified file descriptor\nspecified in the (third) <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument, which is\nan integer. This operation is possible only if the loop\ndevice is read-only and the new backing store is the same\nsize and type as the old backing store.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_SET_CAPACITY</b> (since\nLinux 2.6.30)</p>\n\n<p style=\"margin-left:22%;\">Resize a live loop device. One\ncan change the size of the underlying backing store and then\nuse this operation so that the loop driver learns about the\nnew size. This operation takes no argument.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_SET_DIRECT_IO</b>\n(since Linux 4.10)</p>\n\n<p style=\"margin-left:22%;\">Set DIRECT I/O mode on the loop\ndevice, so that it can be used to open backing file. The\n(third) <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument is an unsigned long value.\nA nonzero represents direct I/O mode.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_SET_BLOCK_SIZE</b>\n(since Linux 4.14)</p>\n\n<p style=\"margin-left:22%;\">Set the block size of the loop\ndevice. The (third) <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument is an unsigned\nlong value. This value must be a power of two in the range\n[512,pagesize]; otherwise, an <b>EINVAL</b> error\nresults.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_CONFIGURE</b> (since\nLinux 5.8)</p>\n\n<p style=\"margin-left:22%;\">Setup and configure all loop\ndevice parameters in a single step using the (third)\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument. This argument is a pointer to a\n<i>loop_config</i> structure, defined in\n<i>&lt;linux/loop.h&gt;</i> as:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nloop_config { <br>\n__u32 fd; <br>\n__u32 block_size; <br>\nstruct loop_info64 info; <br>\n__u64 __reserved[8]; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">In addition to\ndoing what <b>LOOP_SET_STATUS</b> can do,\n<b>LOOP_CONFIGURE</b> can also be used to do the\nfollowing:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"75%\">\n\n\n<p>set the correct block size immediately by setting\n<i>loop_config.block_size</i>;</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"75%\">\n\n\n<p>explicitly request direct I/O mode by setting\n<b>LO_FLAGS_DIRECT_IO</b> in\n<i>loop_config.info.lo_flags</i>; and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"2%\"></td>\n<td width=\"75%\">\n\n\n<p>explicitly request read-only mode by setting\n<b>LO_FLAGS_READ_ONLY</b> in\n<i>loop_config.info.lo_flags</i>.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since Linux\n2.6, there are two new <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> operations: <b><br>\nLOOP_SET_STATUS64</b>, <b>LOOP_GET_STATUS64</b></p>\n\n<p style=\"margin-left:22%;\">These are similar to\n<b>LOOP_SET_STATUS</b> and <b>LOOP_GET_STATUS</b> described\nabove but use the <i>loop_info64</i> structure, which has\nsome additional fields and a larger range for some other\nfields:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nloop_info64 { <br>\nuint64_t lo_device; /* ioctl r/o */ <br>\nuint64_t lo_inode; /* ioctl r/o */ <br>\nuint64_t lo_rdevice; /* ioctl r/o */ <br>\nuint64_t lo_offset; <br>\nuint64_t lo_sizelimit; /* bytes, 0 == max available */ <br>\nuint32_t lo_number; /* ioctl r/o */ <br>\nuint32_t lo_encrypt_type; <br>\nuint32_t lo_encrypt_key_size; /* ioctl w/o */ <br>\nuint32_t lo_flags; i /* ioctl r/w (r/o before <br>\nLinux 2.6.25) */ <br>\nuint8_t lo_file_name[LO_NAME_SIZE]; <br>\nuint8_t lo_crypt_name[LO_NAME_SIZE]; <br>\nuint8_t lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */ <br>\nuint64_t lo_init[2]; <br>\n};</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>/dev/loop-control</b>\n<br>\nSince Linux 3.1, the kernel provides the\n<i>/dev/loop-control</i> device, which permits an\napplication to dynamically find a free device, and to add\nand remove loop devices from the system. To perform these\noperations, one first opens <i>/dev/loop-control</i> and\nthen employs one of the following <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>\noperations: <b><br>\nLOOP_CTL_GET_FREE</b></p>\n\n<p style=\"margin-left:22%;\">Allocate or find a free loop\ndevice for use. On success, the device number is returned as\nthe result of the call. This operation takes no\nargument.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_CTL_ADD</b></p>\n\n<p style=\"margin-left:22%;\">Add the new loop device whose\ndevice number is specified as a long integer in the third\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument. On success, the device index is\nreturned as the result of the call. If the device is already\nallocated, the call fails with the error <b>EEXIST</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>LOOP_CTL_REMOVE</b></p>\n\n<p style=\"margin-left:22%;\">Remove the loop device whose\ndevice number is specified as a long integer in the third\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> argument. On success, the device number is\nreturned as the result of the call. If the device is in use,\nthe call fails with the error <b>EBUSY</b>.</p>\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>/dev/loop*</i></p>\n\n<p style=\"margin-left:22%;\">The loop block special device\nfiles.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The program\nbelow uses the <i>/dev/loop-control</i> device to find a\nfree loop device, opens the loop device, opens a file to be\nused as the underlying storage for the device, and then\nassociates the loop device with the backing store. The\nfollowing shell session demonstrates the use of the\nprogram:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>dd\nif=/dev/zero of=file.img bs=1MiB count=10</b> <br>\n10+0 records in <br>\n10+0 records out <br>\n10485760 bytes (10 MB) copied, 0.00609385 s, 1.7 GB/s <br>\n$ <b>sudo ./mnt_loop file.img</b> <br>\nloopname = /dev/loop5</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Program\nsource</b> <br>\n#include &lt;fcntl.h&gt; <br>\n#include &lt;linux/loop.h&gt; <br>\n#include &lt;sys/ioctl.h&gt; <br>\n#include &lt;stdio.h&gt; <br>\n#include &lt;stdlib.h&gt; <br>\n#include &lt;unistd.h&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#define\nerrExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ <br>\n} while (0)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">int <br>\nmain(int argc, char *argv[]) <br>\n{ <br>\nint loopctlfd, loopfd, backingfile; <br>\nlong devnr; <br>\nchar loopname[4096];</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if (argc != 2)\n{ <br>\nfprintf(stderr, &quot;Usage: %s backing-file\\n&quot;,\nargv[0]); <br>\nexit(EXIT_FAILURE); <br>\n}</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">loopctlfd =\nopen(&quot;/dev/loop-control&quot;, O_RDWR); <br>\nif (loopctlfd == -1) <br>\nerrExit(&quot;open: /dev/loop-control&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">devnr =\nioctl(loopctlfd, LOOP_CTL_GET_FREE); <br>\nif (devnr == -1) <br>\nerrExit(&quot;ioctl-LOOP_CTL_GET_FREE&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">sprintf(loopname,\n&quot;/dev/loop%ld&quot;, devnr); <br>\nprintf(&quot;loopname = %s\\n&quot;, loopname);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">loopfd =\nopen(loopname, O_RDWR); <br>\nif (loopfd == -1) <br>\nerrExit(&quot;open: loopname&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">backingfile =\nopen(argv[1], O_RDWR); <br>\nif (backingfile == -1) <br>\nerrExit(&quot;open: backing-file&quot;);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">if\n(ioctl(loopfd, LOOP_SET_FD, backingfile) == -1) <br>\nerrExit(&quot;ioctl-LOOP_SET_FD&quot;);</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">exit(EXIT_SUCCESS);\n<br>\n}</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>losetup</b>(8),\n<b>mount</b>(8)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#FILES\">FILES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":4}