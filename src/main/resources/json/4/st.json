{"name":"st","description":"st - SCSI tape\ndevice","body":"\n\n<h1 align=\"center\">ST</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">st - SCSI tape\ndevice</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;sys/mtio.h&gt;</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>int\nioctl(int</b> <i>fd</i><b>, int</b> <i>request</i> <b>[,\n(void *)</b><i>arg3</i><b>]); <br>\nint ioctl(int</b> <i>fd</i><b>, MTIOCTOP, (struct mtop\n*)</b><i>mt_cmd</i><b>); <br>\nint ioctl(int</b> <i>fd</i><b>, MTIOCGET, (struct mtget\n*)</b><i>mt_status</i><b>); <br>\nint ioctl(int</b> <i>fd</i><b>, MTIOCPOS, (struct mtpos\n*)</b><i>mt_pos</i><b>);</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <b>st</b>\ndriver provides the interface to a variety of SCSI tape\ndevices. Currently, the driver takes control of all detected\ndevices of type &ldquo;sequential-access&rdquo;. The\n<b>st</b> driver uses major device number 9.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Each device\nuses eight minor device numbers. The lowermost five bits in\nthe minor numbers are assigned sequentially in the order of\ndetection. In the 2.6 kernel, the bits above the eight\nlowermost bits are concatenated to the five lowermost bits\nto form the tape number. The minor numbers can be grouped\ninto two sets of four numbers: the principal (auto-rewind)\nminor device numbers, <i>n</i>, and the\n&ldquo;no-rewind&rdquo; device numbers, (<i>n</i> + 128).\nDevices opened using the principal device number will be\nsent a <b>REWIND</b> command when they are closed. Devices\nopened using the &ldquo;no-rewind&rdquo; device number will\nnot. (Note that using an auto-rewind device for positioning\nthe tape with, for instance, mt does not lead to the desired\nresult: the tape is rewound after the mt command and the\nnext command starts from the beginning of the tape).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Within each\ngroup, four minor numbers are available to define devices\nwith different characteristics (block size, compression,\ndensity, etc.) When the system starts up, only the first\ndevice is available. The other three are activated when the\ndefault characteristics are defined (see below). (By\nchanging compile-time constants, it is possible to change\nthe balance between the maximum number of tape drives and\nthe number of minor numbers for each drive. The default\nallocation allows control of 32 tape drives. For instance,\nit is possible to control up to 64 tape drives with two\nminor numbers for different options.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Devices are\ntypically created by:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">mknod -m 666\n/dev/st0 c 9 0 <br>\nmknod -m 666 /dev/st0l c 9 32 <br>\nmknod -m 666 /dev/st0m c 9 64 <br>\nmknod -m 666 /dev/st0a c 9 96 <br>\nmknod -m 666 /dev/nst0 c 9 128 <br>\nmknod -m 666 /dev/nst0l c 9 160 <br>\nmknod -m 666 /dev/nst0m c 9 192 <br>\nmknod -m 666 /dev/nst0a c 9 224</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is no\ncorresponding block device.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The driver uses\nan internal buffer that has to be large enough to hold at\nleast one tape block. In kernels before 2.1.121, the buffer\nis allocated as one contiguous block. This limits the block\nsize to the largest contiguous block of memory the kernel\nallocator can provide. The limit is currently 128&nbsp;kB\nfor 32-bit architectures and 256&nbsp;kB for 64-bit\narchitectures. In newer kernels the driver allocates the\nbuffer in several parts if necessary. By default, the\nmaximum number of parts is 16. This means that the maximum\nblock size is very large (2&nbsp;MB if allocation of 16\nblocks of 128&nbsp;kB succeeds).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\ndriver&rsquo;s internal buffer size is determined by a\ncompile-time constant which can be overridden with a kernel\nstartup option. In addition to this, the driver tries to\nallocate a larger temporary buffer at run time if necessary.\nHowever, run-time allocation of large contiguous blocks of\nmemory may fail and it is advisable not to rely too much on\ndynamic buffer allocation with kernels older than 2.1.121\n(this applies also to demand-loading the driver with kerneld\nor kmod).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The driver does\nnot specifically support any tape drive brand or model.\nAfter system start-up the tape device options are defined by\nthe drive firmware. For example, if the drive firmware\nselects fixed-block mode, the tape device uses fixed-block\nmode. The options can be changed with explicit\n<a href=\"https://man.page/2/ioctl\">ioctl(2)</a> calls and remain in effect when the device\nis closed and reopened. Setting the options affects both the\nauto-rewind and the nonrewind device.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Different\noptions can be specified for the different devices within\nthe subgroup of four. The options take effect when the\ndevice is opened. For example, the system administrator can\ndefine one device that writes in fixed-block mode with a\ncertain block size, and one which writes in variable-block\nmode (if the drive supports both modes).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The driver\nsupports <b>tape partitions</b> if they are supported by the\ndrive. (Note that the tape partitions have nothing to do\nwith disk partitions. A partitioned tape can be seen as\nseveral logical tapes within one medium.) Partition support\nhas to be enabled with an <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>. The tape location\nis preserved within each partition across partition changes.\nThe partition used for subsequent tape operations is\nselected with an <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>. The partition switch is\nexecuted together with the next tape operation in order to\navoid unnecessary tape movement. The maximum number of\npartitions on a tape is defined by a compile-time constant\n(originally four). The driver contains an <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>\nthat can format a tape with either one or two\npartitions.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Device\n<i>/dev/tape</i> is usually created as a hard or soft link\nto the default tape device on the system.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Starting from\nkernel 2.6.2, the driver exports in the sysfs directory\n<i>/sys/class/scsi_tape</i> the attached devices and some\nparameters assigned to the devices.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Data\ntransfer</b> <br>\nThe driver supports operation in both fixed-block mode and\nvariable-block mode (if supported by the drive). In\nfixed-block mode the drive writes blocks of the specified\nsize and the block size is not dependent on the byte counts\nof the write system calls. In variable-block mode one tape\nblock is written for each write call and the byte count\ndetermines the size of the corresponding tape block. Note\nthat the blocks on the tape don&rsquo;t contain any\ninformation about the writing mode: when reading, the only\nimportant thing is to use commands that accept the block\nsizes on the tape.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In\nvariable-block mode the read byte count does not have to\nmatch the tape block size exactly. If the byte count is\nlarger than the next block on tape, the driver returns the\ndata and the function returns the actual block size. If the\nblock size is larger than the byte count, an error is\nreturned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In fixed-block\nmode the read byte counts can be arbitrary if buffering is\nenabled, or a multiple of the tape block size if buffering\nis disabled. Kernels before 2.1.121 allow writes with\narbitrary byte count if buffering is enabled. In all other\ncases (kernel before 2.1.121 with buffering disabled or\nnewer kernel) the write byte count must be a multiple of the\ntape block size.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the 2.6\nkernel, the driver tries to use direct transfers between the\nuser buffer and the device. If this is not possible, the\ndriver&rsquo;s internal buffer is used. The reasons for not\nusing direct transfers include improper alignment of the\nuser buffer (default is 512 bytes but this can be changed by\nthe HBA driver), one or more pages of the user buffer not\nreachable by the SCSI adapter, and so on.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A filemark is\nautomatically written to tape if the last tape operation\nbefore close was a write.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a filemark\nis encountered while reading, the following happens. If\nthere are data remaining in the buffer when the filemark is\nfound, the buffered data is returned. The next read returns\nzero bytes. The following read returns data from the next\nfile. The end of recorded data is signaled by returning zero\nbytes for two consecutive read calls. The third read returns\nan error.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Ioctls</b>\n<br>\nThe driver supports three <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> requests. Requests\nnot recognized by the <b>st</b> driver are passed to the\n<b>SCSI</b> driver. The definitions below are from\n<i>/usr/include/linux/mtio.h</i>:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>MTIOCTOP\n&mdash; perform a tape operation</b> <br>\nThis request takes an argument of type <i>(struct\nmtop&nbsp;*)</i>. Not all drives support all operations. The\ndriver returns an <b>EIO</b> error if the drive rejects an\noperation.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* Structure\nfor MTIOCTOP - mag tape op command: */ <br>\nstruct mtop { <br>\nshort mt_op; /* operations defined below */ <br>\nint mt_count; /* how many of them */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Magnetic tape\noperations for normal tape use:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTBSF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Backward space over <i>mt_count</i> filemarks.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTBSFM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Backward space over <i>mt_count</i> filemarks.\nReposition the tape to the EOT side of the last\nfilemark.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTBSR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Backward space over <i>mt_count</i> records (tape\nblocks).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTBSS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Backward space over <i>mt_count</i> setmarks.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>MTCOMPRESSION</b></p>\n\n<p style=\"margin-left:22%;\">Enable compression of tape data\nwithin the drive if <i>mt_count</i> is nonzero and disable\ncompression if <i>mt_count</i> is zero. This command uses\nthe MODE page 15 supported by most DATs.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>MTEOM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Go to the end of the recorded media (for appending\nfiles).</p> </td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>MTERASE</b></p>\n\n<p style=\"margin-left:22%;\">Erase tape. With 2.6 kernel,\nshort erase (mark tape empty) is performed if the argument\nis zero. Otherwise, long erase (erase all) is done.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTFSF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Forward space over <i>mt_count</i> filemarks.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTFSFM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Forward space over <i>mt_count</i> filemarks. Reposition\nthe tape to the BOT side of the last filemark.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTFSR</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Forward space over <i>mt_count</i> records (tape\nblocks).</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTFSS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Forward space over <i>mt_count</i> setmarks.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTLOAD</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Execute the SCSI load command. A special case is\navailable for some HP autoloaders. If <i>mt_count</i> is the\nconstant <b>MT_ST_HPLOADER_OFFSET</b> plus a number, the\nnumber is sent to the drive to control the autoloader.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTLOCK</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Lock the tape drive door.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>MTMKPART</b></p>\n\n<p style=\"margin-left:22%;\">Format the tape into one or two\npartitions. If <i>mt_count</i> is positive, it gives the\nsize of partition 1 and partition 0 contains the rest of the\ntape. If <i>mt_count</i> is zero, the tape is formatted into\none partition. From kernel version 4.6, a negative\n<i>mt_count</i> specifies the size of partition 0 and the\nrest of the tape contains partition 1. The physical ordering\nof partitions depends on the drive. This command is not\nallowed for a drive unless the partition support is enabled\nfor the drive (see <b>MT_ST_CAN_PARTITIONS</b> below).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTNOP</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>No op&mdash;flushes the driver&rsquo;s buffer as a side\neffect. Should be used before reading status with\n<b>MTIOCGET</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTOFFL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Rewind and put the drive off line.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>MTRESET</b></p>\n\n<p style=\"margin-left:22%;\">Reset drive.</p>\n\n<p style=\"margin-left:11%;\"><b>MTRETEN</b></p>\n\n<p style=\"margin-left:22%;\">Re-tension tape.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTREW</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Rewind.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTSEEK</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Seek to the tape block number specified in\n<i>mt_count</i>. This operation requires either a SCSI-2\ndrive that supports the <b>LOCATE</b> command\n(device-specific address) or a Tandberg-compatible SCSI-1\ndrive (Tandberg, Archive Viper, Wangtek, ...). The block\nnumber should be one that was previously returned by\n<b>MTIOCPOS</b> if device-specific addresses are used.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>MTSETBLK</b></p>\n\n<p style=\"margin-left:22%;\">Set the drive&rsquo;s block\nlength to the value specified in <i>mt_count</i>. A block\nlength of zero sets the drive to variable block size\nmode.</p>\n\n<p style=\"margin-left:11%;\"><b>MTSETDENSITY</b></p>\n\n<p style=\"margin-left:22%;\">Set the tape density to the\ncode in <i>mt_count</i>. The density codes supported by a\ndrive can be found from the drive documentation.</p>\n\n<p style=\"margin-left:11%;\"><b>MTSETPART</b></p>\n\n<p style=\"margin-left:22%;\">The active partition is\nswitched to <i>mt_count</i>. The partitions are numbered\nfrom zero. This command is not allowed for a drive unless\nthe partition support is enabled for the drive (see\n<b>MT_ST_CAN_PARTITIONS</b> below).</p>\n\n<p style=\"margin-left:11%;\"><b>MTUNLOAD</b></p>\n\n<p style=\"margin-left:22%;\">Execute the SCSI unload command\n(does not eject the tape).</p>\n\n<p style=\"margin-left:11%;\"><b>MTUNLOCK</b></p>\n\n<p style=\"margin-left:22%;\">Unlock the tape drive door.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTWEOF</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"38%\">\n\n\n<p>Write <i>mt_count</i> filemarks.</p></td>\n<td width=\"40%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>MTWSM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"38%\">\n\n\n<p>Write <i>mt_count</i> setmarks.</p></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Magnetic tape\noperations for setting of device options (by the superuser):\n<b><br>\nMTSETDRVBUFFER</b></p>\n\n<p style=\"margin-left:22%;\">Set various drive and driver\noptions according to bits encoded in <i>mt_count</i>. These\nconsist of the drive&rsquo;s buffering mode, a set of\nBoolean driver options, the buffer write threshold, defaults\nfor the block size and density, and timeouts (only in\nkernels 2.1 and later). A single operation can affect only\none item in the list below (the Booleans counted as one\nitem.)</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">A value having\nzeros in the high-order 4 bits will be used to set the\ndrive&rsquo;s buffering mode. The buffering modes are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p>0</p></td>\n<td width=\"4%\"></td>\n<td width=\"65%\">\n\n\n<p>The drive will not report <b>GOOD</b> status on write\ncommands until the data blocks are actually written to the\nmedium.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p>1</p></td>\n<td width=\"4%\"></td>\n<td width=\"65%\">\n\n\n<p>The drive may report <b>GOOD</b> status on write\ncommands as soon as all the data has been transferred to the\ndrive&rsquo;s internal buffer.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"29%\"></td>\n<td width=\"2%\">\n\n\n<p>2</p></td>\n<td width=\"4%\"></td>\n<td width=\"65%\">\n\n\n<p>The drive may report <b>GOOD</b> status on write\ncommands as soon as (a) all the data has been transferred to\nthe drive&rsquo;s internal buffer, and (b) all buffered data\nfrom different initiators has been successfully written to\nthe medium.</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">To control the\nwrite threshold the value in <i>mt_count</i> must include\nthe constant <b>MT_ST_WRITE_THRESHOLD</b> bitwise ORed with\na block count in the low 28 bits. The block count refers to\n1024-byte blocks, not the physical block size on the tape.\nThe threshold cannot exceed the driver&rsquo;s internal\nbuffer size (see DESCRIPTION, above).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">To set and\nclear the Boolean options the value in <i>mt_count</i> must\ninclude one of the constants <b>MT_ST_BOOLEANS</b>,\n<b>MT_ST_SETBOOLEANS</b>, <b>MT_ST_CLEARBOOLEANS</b>, or\n<b>MT_ST_DEFBOOLEANS</b> bitwise ORed with whatever\ncombination of the following options is desired. Using\n<b>MT_ST_BOOLEANS</b> the options can be set to the values\ndefined in the corresponding bits. With\n<b>MT_ST_SETBOOLEANS</b> the options can be selectively set\nand with <b>MT_ST_DEFBOOLEANS</b> selectively cleared.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">The default options for a tape\ndevice are set with <b>MT_ST_DEFBOOLEANS</b>. A nonactive\ntape device (e.g., device with minor 32 or 160) is activated\nwhen the default options for it are defined the first time.\nAn activated device inherits from the device activated at\nstart-up the options not set explicitly.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p>The Boolean options are:</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_BUFFER_WRITES</b>\n(Default: true)</p>\n\n<p style=\"margin-left:32%;\">Buffer all write operations in\nfixed-block mode. If this option is false and the drive uses\na fixed block size, then all write operations must be for a\nmultiple of the block size. This option must be set false to\nwrite reliable multivolume archives.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_ASYNC_WRITES</b>\n(Default: true)</p>\n\n<p style=\"margin-left:32%;\">When this option is true, write\noperations return immediately without waiting for the data\nto be transferred to the drive if the data fits into the\ndriver&rsquo;s buffer. The write threshold determines how\nfull the buffer must be before a new SCSI write command is\nissued. Any errors reported by the drive will be held until\nthe next operation. This option must be set false to write\nreliable multivolume archives.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_READ_AHEAD</b>\n(Default: true)</p>\n\n<p style=\"margin-left:32%;\">This option causes the driver\nto provide read buffering and read-ahead in fixed-block\nmode. If this option is false and the drive uses a fixed\nblock size, then all read operations must be for a multiple\nof the block size.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_TWO_FM</b> (Default:\nfalse)</p>\n\n<p style=\"margin-left:32%;\">This option modifies the driver\nbehavior when a file is closed. The normal action is to\nwrite a single filemark. If the option is true, the driver\nwill write two filemarks and backspace over the second\none.</p>\n\n<p style=\"margin-left:32%; margin-top: 1em\">Note: This\noption should not be set true for QIC tape drives since they\nare unable to overwrite a filemark. These drives detect the\nend of recorded data by testing for blank tape rather than\ntwo consecutive filemarks. Most other current drives also\ndetect the end of recorded data and using two filemarks is\nusually necessary only when interchanging tapes with some\nother systems.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_DEBUGGING</b>\n(Default: false)</p>\n\n<p style=\"margin-left:32%;\">This option turns on various\ndebugging messages from the driver (effective only if the\ndriver was compiled with <b>DEBUG</b> defined nonzero).</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_FAST_EOM</b> (Default:\nfalse)</p>\n\n<p style=\"margin-left:32%;\">This option causes the\n<b>MTEOM</b> operation to be sent directly to the drive,\npotentially speeding up the operation but causing the driver\nto lose track of the current file number normally returned\nby the <b>MTIOCGET</b> request. If <b>MT_ST_FAST_EOM</b> is\nfalse, the driver will respond to an <b>MTEOM</b> request by\nforward spacing over files.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_AUTO_LOCK</b>\n(Default: false)</p>\n\n<p style=\"margin-left:32%;\">When this option is true, the\ndrive door is locked when the device file is opened and\nunlocked when it is closed.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_DEF_WRITES</b>\n(Default: false)</p>\n\n<p style=\"margin-left:32%;\">The tape options (block size,\nmode, compression, etc.) may change when changing from one\ndevice linked to a drive to another device linked to the\nsame drive depending on how the devices are defined. This\noption defines when the changes are enforced by the driver\nusing SCSI-commands and when the drives auto-detection\ncapabilities are relied upon. If this option is false, the\ndriver sends the SCSI-commands immediately when the device\nis changed. If the option is true, the SCSI-commands are not\nsent until a write is requested. In this case, the drive\nfirmware is allowed to detect the tape structure when\nreading and the SCSI-commands are used only to make sure\nthat a tape is written according to the correct\nspecification.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_CAN_BSR</b> (Default:\nfalse)</p>\n\n<p style=\"margin-left:32%;\">When read-ahead is used, the\ntape must sometimes be spaced backward to the correct\nposition when the device is closed and the SCSI command to\nspace backward over records is used for this purpose. Some\nolder drives can&rsquo;t process this command reliably and\nthis option can be used to instruct the driver not to use\nthe command. The end result is that, with read-ahead and\nfixed-block mode, the tape may not be correctly positioned\nwithin a file when the device is closed. With 2.6 kernel,\nthe default is true for drives supporting SCSI-3.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_NO_BLKLIMS</b>\n(Default: false)</p>\n\n<p style=\"margin-left:32%;\">Some drives don&rsquo;t accept\nthe <b>READ BLOCK LIMITS</b> SCSI command. If this is used,\nthe driver does not use the command. The drawback is that\nthe driver can&rsquo;t check before sending commands if the\nselected block size is acceptable to the drive.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_CAN_PARTITIONS</b>\n(Default: false)</p>\n\n<p style=\"margin-left:32%;\">This option enables support for\nseveral partitions within a tape. The option applies to all\ndevices linked to a drive.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_SCSI2LOGICAL</b>\n(Default: false)</p>\n\n<p style=\"margin-left:32%;\">This option instructs the\ndriver to use the logical block addresses defined in the\nSCSI-2 standard when performing the seek and tell operations\n(both with <b>MTSEEK</b> and <b>MTIOCPOS</b> commands and\nwhen changing tape partition). Otherwise, the\ndevice-specific addresses are used. It is highly advisable\nto set this option if the drive supports the logical\naddresses because they count also filemarks. There are some\ndrives that support only the logical block addresses.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_ST_SYSV</b> (Default:\nfalse)</p>\n\n<p style=\"margin-left:32%;\">When this option is enabled,\nthe tape devices use the System V semantics. Otherwise, the\nBSD semantics are used. The most important difference\nbetween the semantics is what happens when a device used for\nreading is closed: in System V semantics the tape is spaced\nforward past the next filemark if this has not happened\nwhile using the device. In BSD semantics the tape position\nis not changed.</p>\n\n<p style=\"margin-left:22%;\"><b>MT_NO_WAIT</b> (Default:\nfalse)</p>\n\n<p style=\"margin-left:32%;\">Enables immediate mode (i.e.,\ndon&rsquo;t wait for the command to finish) for some\ncommands (e.g., rewind).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">An example:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct mtop\nmt_cmd; <br>\nmt_cmd.mt_op = MTSETDRVBUFFER; <br>\nmt_cmd.mt_count = MT_ST_BOOLEANS | <br>\nMT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES; <br>\nioctl(fd, MTIOCTOP, mt_cmd);</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p>The default block size for a device can be set with\n<b>MT_ST_DEF_BLKSIZE</b> and the default density code can be\nset with <b>MT_ST_DEFDENSITY</b>. The values for the\nparameters are or&rsquo;ed with the operation code.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p>With kernels 2.1.x and later, the timeout values can be\nset with the subcommand <b>MT_ST_SET_TIMEOUT</b> ORed with\nthe timeout in seconds. The long timeout (used for rewinds\nand other commands that may take a long time) can be set\nwith <b>MT_ST_SET_LONG_TIMEOUT</b>. The kernel defaults are\nvery long to make sure that a successful command is not\ntimed out with any drive. Because of this, the driver may\nseem stuck even if it is only waiting for the timeout. These\ncommands can be used to set more practical values for a\nspecific drive. The timeouts set for one device apply for\nall devices linked to the same drive.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p>Starting from kernels 2.4.19 and 2.5.43, the driver\nsupports a status bit which indicates whether the drive\nrequests cleaning. The method used by the drive to return\ncleaning information is set using the <b>MT_ST_SEL_CLN</b>\nsubcommand. If the value is zero, the cleaning bit is always\nzero. If the value is one, the TapeAlert data defined in the\nSCSI-3 standard is used (not yet implemented). Values\n2&ndash;17 are reserved. If the lowest eight bits are &gt;=\n18, bits from the extended sense data are used. The bits\n9&ndash;16 specify a mask to select the bits to look at and\nthe bits 17&ndash;23 specify the bit pattern to look for. If\nthe bit pattern is zero, one or more bits under the mask\nindicate the cleaning request. If the pattern is nonzero,\nthe pattern must match the masked sense data byte.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>MTIOCGET\n&mdash; get status</b> <br>\nThis request takes an argument of type <i>(struct\nmtget&nbsp;*)</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* structure\nfor MTIOCGET - mag tape get status command */ <br>\nstruct mtget { <br>\nlong mt_type; <br>\nlong mt_resid; <br>\n/* the following registers are device dependent */ <br>\nlong mt_dsreg; <br>\nlong mt_gstat; <br>\nlong mt_erreg; <br>\n/* The next two fields are not always used */ <br>\ndaddr_t mt_fileno; <br>\ndaddr_t mt_blkno; <br>\n};</p>\n\n<p style=\"margin-left:11%;\"><i>mt_type</i></p>\n\n<p style=\"margin-left:22%;\">The header file defines many\nvalues for <i>mt_type</i>, but the current driver reports\nonly the generic types <b>MT_ISSCSI1</b> (Generic SCSI-1\ntape) and <b>MT_ISSCSI2</b> (Generic SCSI-2 tape).</p>\n\n<p style=\"margin-left:11%;\"><i>mt_resid</i></p>\n\n<p style=\"margin-left:22%;\">contains the current tape\npartition number.</p>\n\n<p style=\"margin-left:11%;\"><i>mt_dsreg</i></p>\n\n<p style=\"margin-left:22%;\">reports the drive&rsquo;s\ncurrent settings for block size (in the low 24 bits) and\ndensity (in the high 8 bits). These fields are defined by\n<b>MT_ST_BLKSIZE_SHIFT</b>, <b>MT_ST_BLKSIZE_MASK</b>,\n<b>MT_ST_DENSITY_SHIFT</b>, and\n<b>MT_ST_DENSITY_MASK</b>.</p>\n\n<p style=\"margin-left:11%;\"><i>mt_gstat</i></p>\n\n<p style=\"margin-left:22%;\">reports generic (device\nindependent) status information. The header file defines\nmacros for testing these status bits:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_EOF</b>(<i>x</i>): The\ntape is positioned just after a filemark (always false after\nan <b>MTSEEK</b></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">operation).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_BOT</b>(<i>x</i>): The\ntape is positioned at the beginning of the first file\n(always false after an <b>MTSEEK</b></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">operation).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_EOT</b>(<i>x</i>): A tape\noperation has reached the physical End Of Tape.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_SM</b>(<i>x</i>): The\ntape is currently positioned at a setmark (always false\nafter an <b>MTSEEK</b></p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">operation).</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_EOD</b>(<i>x</i>): The\ntape is positioned at the end of recorded data.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_WR_PROT</b>(<i>x</i>):\nThe drive is write-protected. For some drives this can also\nmean that the drive does not support writing on the current\nmedium type.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_ONLINE</b>(<i>x</i>): The\nlast <a href=\"https://man.page/2/open\">open(2)</a> found the drive with a tape in place and\nready for operation.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_D_6250</b>(<i>x</i>),\n<b>GMT_D_1600</b>(<i>x</i>), <b>GMT_D_800</b>(<i>x</i>):\nThis &ldquo;generic&rdquo; status information reports the\ncurrent density setting for 9-track &frac12;&quot; tape\ndrives only.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_DR_OPEN</b>(<i>x</i>):\nThe drive does not have a tape in place.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_IM_REP_EN</b>(<i>x</i>):\nImmediate report mode. This bit is set if there are no\nguarantees that the data has been physically written to the\ntape when the write call returns. It is set zero only when\nthe driver does not buffer data and the drive is set not to\nbuffer data.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\"><b>GMT_CLN</b>(<i>x</i>): The\ndrive has requested cleaning. Implemented in kernels since\n2.4.19 and 2.5.43.</p></td></tr>\n</table>\n\n<p><i>mt_erreg</i></p></table>\n\n<p style=\"margin-left:22%;\">The only field defined in\n<i>mt_erreg</i> is the recovered error count in the low 16\nbits (as defined by <b>MT_ST_SOFTERR_SHIFT</b> and\n<b>MT_ST_SOFTERR_MASK</b>). Due to inconsistencies in the\nway drives report recovered errors, this count is often not\nmaintained (most drives do not by default report soft errors\nbut this can be changed with a SCSI MODE SELECT\ncommand).</p>\n\n<p style=\"margin-left:11%;\"><i>mt_fileno</i></p>\n\n<p style=\"margin-left:22%;\">reports the current file number\n(zero-based). This value is set to -1 when the file number\nis unknown (e.g., after <b>MTBSS</b> or <b>MTSEEK</b>).</p>\n\n<p style=\"margin-left:11%;\"><i>mt_blkno</i></p>\n\n<p style=\"margin-left:22%;\">reports the block number\n(zero-based) within the current file. This value is set to\n-1 when the block number is unknown (e.g., after\n<b>MTBSF</b>, <b>MTBSS</b>, or <b>MTSEEK</b>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>MTIOCPOS\n&mdash; get tape position</b> <br>\nThis request takes an argument of type <i>(struct\nmtpos&nbsp;*)</i> and reports the drive&rsquo;s notion of\nthe current tape block number, which is not the same as\n<i>mt_blkno</i> returned by <b>MTIOCGET</b>. This drive must\nbe a SCSI-2 drive that supports the <b>READ POSITION</b>\ncommand (device-specific address) or a Tandberg-compatible\nSCSI-1 drive (Tandberg, Archive Viper, Wangtek, ... ).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* structure\nfor MTIOCPOS - mag tape get position command */ <br>\nstruct mtpos { <br>\nlong mt_blkno; /* current block number */ <br>\n};</p>\n\n<h2>RETURN VALUE\n<a name=\"RETURN VALUE\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>EACCES</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">An attempt was made to write or\nerase a write-protected tape. (This error is not detected\nduring <a href=\"https://man.page/2/open\">open(2)</a>.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EBUSY</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The device is already in use or the driver was unable to\nallocate a buffer.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EFAULT</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The command parameters point to memory not belonging to\nthe calling process.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>An <a href=\"https://man.page/2/ioctl\">ioctl(2)</a> had an invalid argument, or a\nrequested block size was invalid.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The requested operation could not be completed.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOMEM</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>The byte count in <a href=\"https://man.page/2/read\">read(2)</a> is smaller than the\nnext physical block on the tape. (Before 2.2.18 and 2.4.0\nthe extra bytes have been silently ignored.)</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSPC</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>A write operation could not be completed because the\ntape reached end-of-medium.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENOSYS</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Unknown <a href=\"https://man.page/2/ioctl\">ioctl(2)</a>.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>ENXIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>During opening, the tape device does not exist.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>EOVERFLOW</b></p>\n\n<p style=\"margin-left:22%;\">An attempt was made to read or\nwrite a variable-length block that is larger than the\ndriver&rsquo;s internal buffer.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>EROFS</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p>Open is attempted with <b>O_WRONLY</b> or <b>O_RDWR</b>\nwhen the tape in the drive is write-protected.</p></td></tr>\n</table>\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>/dev/st*</i></p>\n\n<p style=\"margin-left:22%;\">the auto-rewind SCSI tape\ndevices</p>\n\n<p style=\"margin-left:11%;\"><i>/dev/nst*</i></p>\n\n<p style=\"margin-left:22%;\">the nonrewind SCSI tape\ndevices</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p style=\"margin-top: 1em\">1.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p style=\"margin-top: 1em\">When exchanging data between\nsystems, both systems have to agree on the physical tape\nblock size. The parameters of a drive after startup are\noften not the ones most operating systems use with these\ndevices. Most systems use drives in variable-block mode if\nthe drive supports that mode. This applies to most modern\ndrives, including DATs, 8mm helical scan drives, DLTs, etc.\nIt may be advisable to use these drives in variable-block\nmode also in Linux (i.e., use <b>MTSETBLK</b> or\n<b>MTSETDEFBLK</b> at system startup to set the mode), at\nleast when exchanging data with a foreign system. The\ndrawback of this is that a fairly large tape block size has\nto be used to get acceptable data transfer rates on the SCSI\nbus.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>Many programs (e.g., <a href=\"https://man.page/1/tar\">tar(1)</a>) allow the user to\nspecify the blocking factor on the command line. Note that\nthis determines the physical block size on tape only in\nvariable-block mode.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>3.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>In order to use SCSI tape drives, the basic SCSI driver,\na SCSI-adapter driver and the SCSI tape driver must be\neither configured into the kernel or loaded as modules. If\nthe SCSI-tape driver is not present, the drive is recognized\nbut the tape support described in this page is not\navailable.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>4.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>The driver writes error messages to the console/log. The\nSENSE codes written into some messages are automatically\ntranslated to text if verbose SCSI messages are enabled in\nkernel configuration.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p>5.</p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>The driver&rsquo;s internal buffering allows good\nthroughput in fixed-block mode also with small\n<a href=\"https://man.page/2/read\">read(2)</a> and <a href=\"https://man.page/2/write\">write(2)</a> byte counts. With direct\ntransfers this is not possible and may cause a surprise when\nmoving to the 2.6 kernel. The solution is to tell the\nsoftware to use larger transfers (often telling it to use\nlarger blocks). If this is not possible, direct transfers\ncan be disabled.</p></td></tr>\n</table>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/mt\">mt(1)</a></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The file\n<i>drivers/scsi/README.st</i> or\n<i>Documentation/scsi/st.txt</i> (kernel &gt;= 2.6) in the\nLinux kernel source tree contains the most recent\ninformation about the driver and its configuration\npossibilities</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#RETURN VALUE\">RETURN VALUE</a>","<a href=\"#FILES\">FILES</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":4}