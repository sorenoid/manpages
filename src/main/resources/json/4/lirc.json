{"name":"lirc","body":"\n\n<h1 align=\"center\">LIRC</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">lirc - lirc\ndevices</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<i>/dev/lirc*</i> character devices provide a low-level\nbidirectional interface to infra-red (IR) remotes. Most of\nthese devices can receive, and some can send. When receiving\nor sending data, the driver works in two different modes\ndepending on the underlying hardware.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Some hardware\n(typically TV-cards) decodes the IR signal internally and\nprovides decoded button presses as scancode values. Drivers\nfor this kind of hardware work in <b>LIRC_MODE_SCANCODE</b>\nmode. Such hardware usually does not support sending IR\nsignals. Furthermore, such hardware can only decode a\nlimited set of IR protocols, usually only the protocol of\nthe specific remote which is bundled with, for example, a\nTV-card.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Other hardware\nprovides a stream of pulse/space durations. Such drivers\nwork in <b>LIRC_MODE_MODE2</b> mode. Sometimes, this kind of\nhardware also supports sending IR data. Such hardware can be\nused with (almost) any kind of remote. This type of hardware\ncan also be used in <b>LIRC_MODE_SCANCODE</b> mode, in which\ncase the kernel IR decoders will decode the IR. These\ndecoders can be written in extended BPF (see <a href=\"https://man.page/2/bpf\">bpf(2)</a>)\nand attached to the <b>lirc</b> device.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>LIRC_GET_FEATURES</b> ioctl (see below) allows probing\nfor whether receiving and sending is supported, and in which\nmodes, amongst other features.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading\ninput with the LIRC_MODE_MODE2 mode</b> <br>\nIn the <b>LIRC_MODE_MODE2 mode</b>, the data returned by\n<a href=\"https://man.page/2/read\">read(2)</a> provides 32-bit values representing a space\nor a pulse duration. The time of the duration (microseconds)\nis encoded in the lower 24 bits. The upper 8 bits indicate\nthe type of package: <b><br>\nLIRC_MODE2_SPACE</b></p>\n\n<p style=\"margin-left:17%;\">Value reflects a space duration\n(microseconds).</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_MODE2_PULSE</b></p>\n\n<p style=\"margin-left:17%;\">Value reflects a pulse duration\n(microseconds).</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_MODE2_FREQUENCY</b></p>\n\n<p style=\"margin-left:17%;\">Value reflects a frequency\n(Hz); see the <b>LIRC_SET_MEASURE_CARRIER_MODE</b>\nioctl.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_MODE2_TIMEOUT</b></p>\n\n<p style=\"margin-left:17%;\">Value reflects a space duration\n(microseconds). The package reflects a timeout; see the\n<b>LIRC_SET_REC_TIMEOUT_REPORTS</b> ioctl.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Reading\ninput with the LIRC_MODE_SCANCODE mode</b> <br>\nIn the <b>LIRC_MODE_SCANCODE</b> mode, the data returned by\n<a href=\"https://man.page/2/read\">read(2)</a> reflects decoded button presses, in the\nstruct <i>lirc_scancode</i>. The scancode is stored in the\n<i>scancode</i> field, and the IR protocol is stored in\n<i>rc_proto</i>. This field has one the values of the\n<i>enum rc_proto</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Writing\noutput with the LIRC_MODE_PULSE mode</b> <br>\nThe data written to the character device using\n<a href=\"https://man.page/2/write\">write(2)</a> is a pulse/space sequence of integer values.\nPulses and spaces are only marked implicitly by their\nposition. The data must start and end with a pulse, thus it\nmust always include an odd number of samples. The\n<a href=\"https://man.page/2/write\">write(2)</a> function blocks until the data has been\ntransmitted by the hardware. If more data is provided than\nthe hardware can send, the <a href=\"https://man.page/2/write\">write(2)</a> call fails with\nthe error <b>EINVAL</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Writing\noutput with the LIRC_MODE_SCANCODE mode</b> <br>\nThe data written to the character devices must be a single\nstruct <i>lirc_scancode</i>. The <i>scancode</i> and\n<i>rc_proto</i> fields must filled in, all other fields must\nbe 0. The kernel IR encoders will convert the scancode to\npulses and spaces. The protocol or scancode is invalid, or\nthe <b>lirc</b> device cannot transmit.</p>\n\n<h2>IOCTL COMMANDS\n<a name=\"IOCTL COMMANDS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The LIRC\ndevice&rsquo;s ioctl definition is bound by the ioctl\nfunction definition of <i>struct file_operations</i>,\nleaving us with an <i>unsigned int</i> for the ioctl command\nand an <i>unsigned long</i> for the argument. For the\npurposes of ioctl portability across 32-bit and 64-bit\narchitectures, these values are capped to their 32-bit\nsizes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">#include\n&lt;linux/lirc.h&gt; /* But see BUGS */ <br>\nint ioctl(int fd, int cmd, ...);</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nioctls can be used to probe or change specific <b>lirc</b>\nhardware settings. Many require a third argument, usually an\n<i>int</i>. referred to below as <i>val</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Always\nSupported Commands</b> <i><br>\n/dev/lirc*</i> devices always support the following\ncommands: <b><br>\nLIRC_GET_FEATURES</b> (<i>void</i>)</p>\n\n<p style=\"margin-left:17%;\">Returns a bit mask of combined\nfeatures bits; see FEATURES.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a device\nreturns an error code for <b>LIRC_GET_FEATURES</b>, it is\nsafe to assume it is not a <b>lirc</b> device.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Optional\nCommands</b> <br>\nSome <b>lirc</b> devices support the commands listed below.\nUnless otherwise stated, these fail with the error\n<b>ENOTTY</b> if the operation isn&rsquo;t supported, or\nwith the error <b>EINVAL</b> if the operation failed, or\ninvalid arguments were provided. If a driver does not\nannounce support of certain features, invoking the\ncorresponding ioctls will fail with the error <b>ENOTTY</b>.\n<b><br>\nLIRC_GET_REC_MODE</b> (<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">If the <b>lirc</b> device has\nno receiver, this operation fails with the error\n<b>ENOTTY</b>. Otherwise, it returns the receive mode, which\nwill be one of: <b><br>\nLIRC_MODE_MODE2</b></p>\n\n<p style=\"margin-left:32%;\">The driver returns a sequence\nof pulse/space durations.</p>\n\n<p style=\"margin-left:22%;\"><b>LIRC_MODE_SCANCODE</b></p>\n\n<p style=\"margin-left:32%;\">The driver returns struct\n<i>lirc_scancode</i> values, each of which represents a\ndecoded button press.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_REC_MODE</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the receive mode.\n<i>val</i> is either <b>LIRC_MODE_SCANCODE</b> or\n<b>LIRC_MODE_MODE2</b>. If the <b>lirc</b> device has no\nreceiver, this operation fails with the error\n<b>ENOTTY.</b></p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_GET_SEND_MODE</b>\n(<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Return the send mode.\n<b>LIRC_MODE_PULSE</b> or <b>LIRC_MODE_SCANCODE</b> is\nsupported. If the <b>lirc</b> device cannot send, this\noperation fails with the error <b>ENOTTY.</b></p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_SEND_MODE</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the send mode. <i>val</i>\nis either <b>LIRC_MODE_SCANCODE</b> or\n<b>LIRC_MODE_PULSE</b>. If the <b>lirc</b> device cannot\nsend, this operation fails with the error <b>ENOTTY</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_SEND_CARRIER</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the modulation frequency.\nThe argument is the frequency (Hz).</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_SEND_DUTY_CYCLE</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the carrier duty cycle.\n<i>val</i> is a number in the range [0,100] which describes\nthe pulse width as a percentage of the total cycle.\nCurrently, no special meaning is defined for 0 or 100, but\nthe values are reserved for future use.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_GET_MIN_TIMEOUT</b>\n(<i>void</i>)<b>, LIRC_GET_MAX_TIMEOUT</b> (<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Some devices have internal\ntimers that can be used to detect when there has been no IR\nactivity for a long time. This can help <b>lircd</b>(8) in\ndetecting that an IR signal is finished and can speed up the\ndecoding process. These operations return integer values\nwith the minimum/maximum timeout that can be set\n(microseconds). Some devices have a fixed timeout. For such\ndrivers, <b>LIRC_GET_MIN_TIMEOUT</b> and\n<b>LIRC_GET_MAX_TIMEOUT</b> will fail with the error\n<b>ENOTTY</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_REC_TIMEOUT</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the integer value for IR\ninactivity timeout (microseconds). To be accepted, the value\nmust be within the limits defined by\n<b>LIRC_GET_MIN_TIMEOUT</b> and <b>LIRC_GET_MAX_TIMEOUT</b>.\nA value of 0 (if supported by the hardware) disables all\nhardware timeouts and data should be reported as soon as\npossible. If the exact value cannot be set, then the next\npossible value <i>greater</i> than the given value should be\nset.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_GET_REC_TIMEOUT</b>\n(<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Return the current inactivity\ntimeout (microseconds). Available since Linux 4.18.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_REC_TIMEOUT_REPORTS</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Enable (<i>val</i> is 1) or\ndisable (<i>val</i> is 0) timeout packages in\n<b>LIRC_MODE_MODE2</b>. The behavior of this operation has\nvaried across kernel versions:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>Since Linux 4.16: each time the <b>lirc device is\nopened,</b> timeout reports are by default enabled for the\nresulting file descriptor. The <b>LIRC_SET_REC_TIMEOUT</b>\noperation can be used to disable (and, if desired, to later\nre-enable) the timeout on the file descriptor.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>In Linux 4.15 and earlier: timeout reports are disabled\nby default, and enabling them (via\n<b>LIRC_SET_REC_TIMEOUT</b>) on any file descriptor\nassociated with the <b>lirc</b> device has the effect of\nenabling timeouts for all file descriptors referring to that\ndevice (until timeouts are disabled again).</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_REC_CARRIER</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Set the upper bound of the\nreceive carrier frequency (Hz). See\n<b>LIRC_SET_REC_CARRIER_RANGE</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_REC_CARRIER_RANGE</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Sets the lower bound of the\nreceive carrier frequency (Hz). For this to take affect,\nfirst set the lower bound using the\n<b>LIRC_SET_REC_CARRIER_RANGE</b> ioctl, and then the upper\nbound using the <b>LIRC_SET_REC_CARRIER</b> ioctl.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_MEASURE_CARRIER_MODE</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Enable (<i>val</i> is 1) or\ndisable (<i>val</i> is 0) the measure mode. If enabled, from\nthe next key press on, the driver will send\n<b>LIRC_MODE2_FREQUENCY</b> packets. By default, this should\nbe turned off.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_GET_REC_RESOLUTION</b>\n(<i>void</i>)</p>\n\n<p style=\"margin-left:22%;\">Return the driver resolution\n(microseconds).</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_TRANSMITTER_MASK</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Enable the set of transmitters\nspecified in <i>val</i>, which contains a bit mask where\neach enabled transmitter is a 1. The first transmitter is\nencoded by the least significant bit, and so on. When an\ninvalid bit mask is given, for example a bit is set even\nthough the device does not have so many transmitters, this\noperation returns the number of available transmitters and\ndoes nothing otherwise.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_SET_WIDEBAND_RECEIVER</b>\n(<i>int</i>)</p>\n\n<p style=\"margin-left:22%;\">Some devices are equipped with\na special wide band receiver which is intended to be used to\nlearn the output of an existing remote. This ioctl can be\nused to enable (<i>val</i> equals 1) or disable (<i>val</i>\nequals 0) this functionality. This might be useful for\ndevices that otherwise have narrow band receivers that\nprevent them to be used with certain remotes. Wide band\nreceivers may also be more precise. On the other hand, their\ndisadvantage usually is reduced range of reception.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Note: wide band\nreceiver may be implicitly enabled if you enable carrier\nreports. In that case, it will be disabled as soon as you\ndisable carrier reports. Trying to disable a wide band\nreceiver while carrier reports are active will do\nnothing.</p>\n\n<h2>FEATURES\n<a name=\"FEATURES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">the\n<b>LIRC_GET_FEATURES</b> ioctl returns a bit mask describing\nfeatures of the driver. The following bits may be returned\nin the mask: <b><br>\nLIRC_CAN_REC_MODE2</b></p>\n\n<p style=\"margin-left:22%;\">The driver is capable of\nreceiving using <b>LIRC_MODE_MODE2</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_REC_SCANCODE</b></p>\n\n<p style=\"margin-left:22%;\">The driver is capable of\nreceiving using <b>LIRC_MODE_SCANCODE</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_SET_SEND_CARRIER</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports changing\nthe modulation frequency using\n<b>LIRC_SET_SEND_CARRIER</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_SET_SEND_DUTY_CYCLE</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports changing\nthe duty cycle using <b>LIRC_SET_SEND_DUTY_CYCLE</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_SET_TRANSMITTER_MASK</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports changing\nthe active transmitter(s) using\n<b>LIRC_SET_TRANSMITTER_MASK</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_SET_REC_CARRIER</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports setting the\nreceive carrier frequency using <b>LIRC_SET_REC_CARRIER</b>.\nAny <b>lirc</b> device since the drivers were merged in\nkernel release 2.6.36 must have\n<b>LIRC_CAN_SET_REC_CARRIER_RANGE</b> set if\n<b>LIRC_CAN_SET_REC_CARRIER</b> feature is set.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_SET_REC_CARRIER_RANGE</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports\n<b>LIRC_SET_REC_CARRIER_RANGE</b>. The lower bound of the\ncarrier must first be set using the\n<b>LIRC_SET_REC_CARRIER_RANGE</b> ioctl, before using the\n<b>LIRC_SET_REC_CARRIER</b> ioctl to set the upper\nbound.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_GET_REC_RESOLUTION</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports\n<b>LIRC_GET_REC_RESOLUTION</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_SET_REC_TIMEOUT</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports\n<b>LIRC_SET_REC_TIMEOUT</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_MEASURE_CARRIER</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports measuring\nof the modulation frequency using\n<b>LIRC_SET_MEASURE_CARRIER_MODE</b>.</p>\n\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_USE_WIDEBAND_RECEIVER</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports learning\nmode using <b>LIRC_SET_WIDEBAND_RECEIVER</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>LIRC_CAN_SEND_PULSE</b></p>\n\n<p style=\"margin-left:22%;\">The driver supports sending\nusing <b>LIRC_MODE_PULSE</b> or\n<b>LIRC_MODE_SCANCODE</b></p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using these\ndevices requires the kernel source header file\n<i>lirc.h</i>. This file is not available before kernel\nrelease 4.6. Users of older kernels could use the file\nbundled in\n<a href=\"http://www.lirc.org\">http://www.lirc.org</a>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/ir-ctl\">ir-ctl(1)</a>,\n<b>lircd</b>(8),&nbsp;<a href=\"https://man.page/2/bpf\">bpf(2)</a></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">https://www.kernel.org/doc/html/latest/media/uapi/rc/lirc-dev.html</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#IOCTL COMMANDS\">IOCTL COMMANDS</a>","<a href=\"#FEATURES\">FEATURES</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":4}