{"name":"cciss","body":"\n\n<h1 align=\"center\">CCISS</h1>\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">cciss - HP\nSmart Array block driver</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">modprobe cciss\n[ cciss_allow_hpsa=1 ]</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Note</b>:\nThis obsolete driver was removed from the kernel in version\n4.14, as it is superseded by the <a href=\"https://man.page/4/hpsa\">hpsa(4)</a> driver in\nnewer kernels.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>cciss</b> is\na block driver for older HP Smart Array RAID\ncontrollers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Options</b>\n<i><br>\ncciss_allow_hpsa=1</i>: This option prevents the\n<b>cciss</b> driver from attempting to drive any controllers\nthat the <a href=\"https://man.page/4/hpsa\">hpsa(4)</a> driver is capable of controlling,\nwhich is to say, the <b>cciss</b> driver is restricted by\nthis option to the following controllers:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Smart Array\n5300 <br>\nSmart Array 5i <br>\nSmart Array 532 <br>\nSmart Array 5312 <br>\nSmart Array 641 <br>\nSmart Array 642 <br>\nSmart Array 6400 <br>\nSmart Array 6400 EM <br>\nSmart Array 6i <br>\nSmart Array P600 <br>\nSmart Array P400i <br>\nSmart Array E200i <br>\nSmart Array E200 <br>\nSmart Array E200i <br>\nSmart Array E200i <br>\nSmart Array E200i <br>\nSmart Array E500</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Supported\nhardware</b> <br>\nThe <b>cciss</b> driver supports the following Smart Array\nboards:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Smart Array\n5300 <br>\nSmart Array 5i <br>\nSmart Array 532 <br>\nSmart Array 5312 <br>\nSmart Array 641 <br>\nSmart Array 642 <br>\nSmart Array 6400 <br>\nSmart Array 6400 U320 Expansion Module <br>\nSmart Array 6i <br>\nSmart Array P600 <br>\nSmart Array P800 <br>\nSmart Array E400 <br>\nSmart Array P400i <br>\nSmart Array E200 <br>\nSmart Array E200i <br>\nSmart Array E500 <br>\nSmart Array P700m <br>\nSmart Array P212 <br>\nSmart Array P410 <br>\nSmart Array P410i <br>\nSmart Array P411 <br>\nSmart Array P812 <br>\nSmart Array P712m <br>\nSmart Array P711m</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Configuration\ndetails</b> <br>\nTo configure HP Smart Array controllers, use the HP Array\nConfiguration Utility (either <b>hpacuxe</b>(8) or\n<b>hpacucli</b>(8)) or the Offline ROM-based Configuration\nUtility (ORCA) run from the Smart Array&rsquo;s option ROM\nat boot time.</p>\n\n<h2>FILES\n<a name=\"FILES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Device\nnodes</b> <br>\nThe device naming scheme is as follows:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Major\nnumbers:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">104 cciss0 <br>\n105 cciss1 <br>\n106 cciss2 <br>\n105 cciss3 <br>\n108 cciss4 <br>\n109 cciss5 <br>\n110 cciss6 <br>\n111 cciss7</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Minor\nnumbers:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">b7 b6 b5 b4 b3\nb2 b1 b0 <br>\n|----+----| |----+----| <br>\n| | <br>\n| +-------- Partition ID (0=wholedev, 1-15 partition) <br>\n| <br>\n+-------------------- Logical Volume number</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The device\nnaming scheme is:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"31%\"></td>\n<td width=\"7%\"></td>\n<td width=\"62%\">\n</td></tr>\n</table>\n\n\n<p align=\"center\"><img src=\"grohtml-3437621.png\" alt=\"Image grohtml-3437621.png\"></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Files in\n/proc</b> <br>\nThe files <i>/proc/driver/cciss/cciss[0-9]+</i> contain\ninformation about the configuration of each controller. For\nexample:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ <b>cd\n/proc/driver/cciss</b> <br>\n$ <b>ls -l</b> <br>\ntotal 0 <br>\n-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss0 <br>\n-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss1 <br>\n-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss2 <br>\n$ <b>cat cciss2</b> <br>\ncciss2: HP Smart Array P800 Controller <br>\nBoard ID: 0x3223103c <br>\nFirmware Version: 7.14 <br>\nIRQ: 16 <br>\nLogical drives: 1 <br>\nCurrent Q depth: 0 <br>\nCurrent # commands on controller: 0 <br>\nMax Q depth since init: 1 <br>\nMax # commands on controller since init: 2 <br>\nMax SG entries since init: 32 <br>\nSequential access devices: 0</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">cciss/c2d0:\n36.38GB RAID 0</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Files in\n/sys</b> <i><br>\n/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/model</i></p>\n\n<p style=\"margin-left:22%;\">Displays the SCSI INQUIRY page\n0 model for logical drive <i>Y</i> of controller\n<i>X</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/rev</i></p>\n\n<p style=\"margin-left:22%;\">Displays the SCSI INQUIRY page\n0 revision for logical drive <i>Y</i> of controller\n<i>X</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/unique_id</i></p>\n\n<p style=\"margin-left:22%;\">Displays the SCSI INQUIRY page\n83 serial number for logical drive <i>Y</i> of controller\n<i>X</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/vendor</i></p>\n\n<p style=\"margin-left:22%;\">Displays the SCSI INQUIRY page\n0 vendor for logical drive <i>Y</i> of controller\n<i>X</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/block:cciss!cXdY</i></p>\n\n<p style=\"margin-left:22%;\">A symbolic link to\n<i>/sys/block/cciss!cXdY</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/rescan</i></p>\n\n<p style=\"margin-left:22%;\">When this file is written to,\nthe driver rescans the controller to discover any new,\nremoved, or modified logical drives.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/resettable</i></p>\n\n<p style=\"margin-left:22%;\">A value of 1 displayed in this\nfile indicates that the &quot;reset_devices=1&quot; kernel\nparameter (used by <b>kdump</b>) is honored by this\ncontroller. A value of 0 indicates that the\n&quot;reset_devices=1&quot; kernel parameter will not be\nhonored. Some models of Smart Array are not able to honor\nthis parameter.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/lunid</i></p>\n\n<p style=\"margin-left:22%;\">Displays the 8-byte LUN ID used\nto address logical drive <i>Y</i> of controller\n<i>X</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/raid_level</i></p>\n\n<p style=\"margin-left:22%;\">Displays the RAID level of\nlogical drive <i>Y</i> of controller <i>X</i>.</p>\n\n\n<p style=\"margin-left:11%;\"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/usage_count</i></p>\n\n<p style=\"margin-left:22%;\">Displays the usage count\n(number of opens) of logical drive <i>Y</i> of controller\n<i>X</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCSI tape\ndrive and medium changer support</b> <br>\nSCSI sequential access devices and medium changer devices\nare supported and appropriate device nodes are automatically\ncreated (e.g., <i>/dev/st0</i>, <i>/dev/st1</i>, etc.; see\n<a href=\"https://man.page/4/st\">st(4)</a> for more details.) You must enable &quot;SCSI\ntape drive support for Smart Array 5xxx&quot; and &quot;SCSI\nsupport&quot; in your kernel configuration to be able to use\nSCSI tape drives with your Smart Array 5xxx controller.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additionally,\nnote that the driver will not engage the SCSI core at init\ntime. The driver must be directed to dynamically engage the\nSCSI core via the <i>/proc</i> filesystem entry, which the\n&quot;block&quot; side of the driver creates as\n<i>/proc/driver/cciss/cciss*</i> at run time. This is\nbecause at driver init time, the SCSI core may not yet be\ninitialized (because the driver is a block driver) and\nattempting to register it with the SCSI core in such a case\nwould cause a hang. This is best done via an initialization\nscript (typically in <i>/etc/init.d</i>, but could vary\ndepending on distribution). For example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">for x in\n/proc/driver/cciss/cciss[0-9]* <br>\ndo <br>\necho &quot;engage scsi&quot; &gt; $x <br>\ndone</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once the SCSI\ncore is engaged by the driver, it cannot be disengaged\n(except by unloading the driver, if it happens to be linked\nas a module.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note also that\nif no sequential access devices or medium changers are\ndetected, the SCSI core will not be engaged by the action of\nthe above script.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Hot plug\nsupport for SCSI tape drives</b> <br>\nHot plugging of SCSI tape drives is supported, with some\ncaveats. The <b>cciss</b> driver must be informed that\nchanges to the SCSI bus have been made. This may be done via\nthe <i>/proc</i> filesystem. For example:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">echo\n&quot;rescan&quot; &gt; /proc/scsi/cciss0/1</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This causes the\ndriver to:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>1.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>query the adapter about changes to the physical SCSI\nbuses and/or fiber channel arbitrated loop, and</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"3%\">\n\n\n<p>2.</p></td>\n<td width=\"1%\"></td>\n<td width=\"74%\">\n\n\n<p>make note of any new or removed sequential access\ndevices or medium changers.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The driver will\noutput messages indicating which devices have been added or\nremoved and the controller, bus, target, and lun used to\naddress each device. The driver then notifies the SCSI\nmidlayer of these changes.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nnaming convention of the <i>/proc</i> filesystem entries\ncontains a number in addition to the driver name (e.g.,\n&quot;cciss0&quot; instead of just &quot;cciss&quot;, which\nyou might expect).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note:\n<i>Only</i> sequential access devices and medium changers\nare presented as SCSI devices to the SCSI midlayer by the\n<b>cciss</b> driver. Specifically, physical SCSI disk drives\nare <i>not</i> presented to the SCSI midlayer. The only disk\ndevices that are presented to the kernel are logical drives\nthat the array controller constructs from regions on the\nphysical drives. The logical drives are presented to the\nblock layer (not to the SCSI midlayer). It is important for\nthe driver to prevent the kernel from accessing the physical\ndrives directly, since these drives are used by the array\ncontroller to construct the logical drives.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>SCSI error\nhandling for tape drives and medium changers</b> <br>\nThe Linux SCSI midlayer provides an error-handling protocol\nthat is initiated whenever a SCSI command fails to complete\nwithin a certain amount of time (which can vary depending on\nthe command). The <b>cciss</b> driver participates in this\nprotocol to some extent. The normal protocol is a four-step\nprocess:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p style=\"margin-top: 1em\">First, the device is told to\nabort the command.</p></td>\n<td width=\"5%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>If that doesn&rsquo;t work, the device is reset.</p></td>\n<td width=\"5%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>If that doesn&rsquo;t work, the SCSI bus is reset.</p></td>\n<td width=\"5%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"1%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"80%\">\n\n\n<p>If that doesn&rsquo;t work, the host bus adapter is\nreset.</p> </td>\n<td width=\"5%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>cciss</b> driver is a block driver as well as a SCSI\ndriver and only the tape drives and medium changers are\npresented to the SCSI midlayer. Furthermore, unlike more\nstraightforward SCSI drivers, disk I/O continues through the\nblock side during the SCSI error-recovery process.\nTherefore, the <b>cciss</b> driver implements only the first\ntwo of these actions, aborting the command, and resetting\nthe device. Note also that most tape drives will not oblige\nin aborting commands, and sometimes it appears they will not\neven obey a reset command, though in most circumstances they\nwill. If the command cannot be aborted and the device cannot\nbe reset, the device will be set offline.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the event\nthat the error-handling code is triggered and a tape drive\nis successfully reset or the tardy command is successfully\naborted, the tape drive may still not allow I/O to continue\nuntil some command is issued that positions the tape to a\nknown position. Typically you must rewind the tape (by\nissuing <i>mt -f /dev/st0 rewind</i> for example) before I/O\ncan proceed again to a tape drive that was reset.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/4/hpsa\">hpsa(4)</a>,\n<b>cciss_vol_status</b>(8), <b>hpacucli</b>(8),\n<b>hpacuxe</b>(8) <br>\n<a href=\"http://cciss.sf.net\">http://cciss.sf.net</a>, and\n<i>Documentation/blockdev/cciss.txt</i> and\n<i>Documentation/ABI/testing/sysfs-bus-pci-devices-cciss</i>\nin the Linux kernel source tree</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#FILES\">FILES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":4}