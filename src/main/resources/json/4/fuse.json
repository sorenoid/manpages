{"name":"fuse","description":"fuse -\nFilesystem in Userspace (FUSE) device","body":"\n\n<h1 align=\"center\">FUSE</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">fuse -\nFilesystem in Userspace (FUSE) device</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>#include\n&lt;linux/fuse.h&gt;</b></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This device is\nthe primary interface between the FUSE filesystem driver and\na user-space process wishing to provide the filesystem\n(referred to in the rest of this manual page as the\n<i>filesystem daemon</i>). This manual page is intended for\nthose interested in understanding the kernel interface\nitself. Those implementing a FUSE filesystem may wish to\nmake use of a user-space library such as <i>libfuse</i> that\nabstracts away the low-level interface.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">At its core,\nFUSE is a simple client-server protocol, in which the Linux\nkernel is the client and the daemon is the server. After\nobtaining a file descriptor for this device, the daemon may\n<a href=\"https://man.page/2/read\">read(2)</a> requests from that file descriptor and is\nexpected to <a href=\"https://man.page/2/write\">write(2)</a> back its replies. It is\nimportant to note that a file descriptor is associated with\na unique FUSE filesystem. In particular, opening a second\ncopy of this device, will not allow access to resources\ncreated through the first file descriptor (and vice\nversa).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>The basic\nprotocol</b> <br>\nEvery message that is read by the daemon begins with a\nheader described by the following structure:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfuse_in_header { <br>\nuint32_t len; /* Total length of the data, <br>\nincluding this header */ <br>\nuint32_t opcode; /* The kind of operation (see below) */\n<br>\nuint64_t unique; /* A unique identifier for this request */\n<br>\nuint64_t nodeid; /* ID of the filesystem object <br>\nbeing operated on */ <br>\nuint32_t uid; /* UID of the requesting process */ <br>\nuint32_t gid; /* GID of the requesting process */ <br>\nuint32_t pid; /* PID of the requesting process */ <br>\nuint32_t padding; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The header is\nfollowed by a variable-length data portion (which may be\nempty) specific to the requested operation (the requested\noperation is indicated by <i>opcode</i>).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The daemon\nshould then process the request and if applicable send a\nreply (almost all operations require a reply; if they do\nnot, this is documented below), by performing a\n<a href=\"https://man.page/2/write\">write(2)</a> to the file descriptor. All replies must\nstart with the following header:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">struct\nfuse_out_header { <br>\nuint32_t len; /* Total length of data written to <br>\nthe file descriptor */ <br>\nint32_t error; /* Any error that occurred (0 if none) */\n<br>\nuint64_t unique; /* The value from the <br>\ncorresponding request */ <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This header is\nalso followed by (potentially empty) variable-sized data\ndepending on the executed request. However, if the reply is\nan error reply (i.e., <i>error</i> is set), then no further\npayload data should be sent, independent of the request.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Exchanged\nmessages</b> <br>\nThis section should contain documentation for each of the\nmessages in the protocol. This manual page is currently\nincomplete, so not all messages are documented. For each\nmessage, first the struct sent by the kernel is given,\nfollowed by a description of the semantics of the message.\n<b><br>\nFUSE_INIT</b></p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_init_in { <br>\nuint32_t major; <br>\nuint32_t minor; <br>\nuint32_t max_readahead; /* Since protocol v7.6 */ <br>\nuint32_t flags; /* Since protocol v7.6 */ <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">This is the\nfirst request sent by the kernel to the daemon. It is used\nto negotiate the protocol version and other filesystem\nparameters. Note that the protocol version may affect the\nlayout of any structure in the protocol (including this\nstructure). The daemon must thus remember the negotiated\nversion and flags for each session. As of the writing of\nthis man page, the highest supported kernel protocol version\nis <i>7.26</i>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Users should be\naware that the descriptions in this manual page may be\nincomplete or incorrect for older or more recent protocol\nversions.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The reply for\nthis request has the following format:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_init_out { <br>\nuint32_t major; <br>\nuint32_t minor; <br>\nuint32_t max_readahead; /* Since v7.6 */ <br>\nuint32_t flags; /* Since v7.6; some flags bits <br>\nwere introduced later */ <br>\nuint16_t max_background; /* Since v7.13 */ <br>\nuint16_t congestion_threshold; /* Since v7.13 */ <br>\nuint32_t max_write; /* Since v7.5 */ <br>\nuint32_t time_gran; /* Since v7.6 */ <br>\nuint32_t unused[9]; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the major\nversion supported by the kernel is larger than that\nsupported by the daemon, the reply shall consist of only\n<i>uint32_t major</i> (following the usual header),\nindicating the largest major version supported by the\ndaemon. The kernel will then issue a new <b>FUSE_INIT</b>\nrequest conforming to the older version. In the reverse\ncase, the daemon should quietly fall back to the\nkernel&rsquo;s major version.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The negotiated\nminor version is considered to be the minimum of the minor\nversions provided by the daemon and the kernel and both\nparties should use the protocol corresponding to said minor\nversion.</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_GETATTR</b></p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_getattr_in { <br>\nuint32_t getattr_flags; <br>\nuint32_t dummy; <br>\nuint64_t fh; /* Set only if <br>\n(getattr_flags &amp; FUSE_GETATTR_FH) <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The requested\noperation is to compute the attributes to be returned by\n<a href=\"https://man.page/2/stat\">stat(2)</a> and similar operations for the given\nfilesystem object. The object for which the attributes\nshould be computed is indicated either by\n<i>header-&gt;nodeid</i> or, if the <b>FUSE_GETATTR_FH</b>\nflag is set, by the file handle <i>fh</i>. The latter case\nof operation is analogous to <a href=\"https://man.page/2/fstat\">fstat(2)</a>.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For performance\nreasons, these attributes may be cached in the kernel for a\nspecified duration of time. While the cache timeout has not\nbeen exceeded, the attributes will be served from the cache\nand will not cause additional <b>FUSE_GETATTR</b>\nrequests.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The computed\nattributes and the requested cache timeout should then be\nreturned in the following structure:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_attr_out { <br>\n/* Attribute cache duration (seconds + nanoseconds) */ <br>\nuint64_t attr_valid; <br>\nuint32_t attr_valid_nsec; <br>\nuint32_t dummy; <br>\nstruct fuse_attr { <br>\nuint64_t ino; <br>\nuint64_t size; <br>\nuint64_t blocks; <br>\nuint64_t atime; <br>\nuint64_t mtime; <br>\nuint64_t ctime; <br>\nuint32_t atimensec; <br>\nuint32_t mtimensec; <br>\nuint32_t ctimensec; <br>\nuint32_t mode; <br>\nuint32_t nlink; <br>\nuint32_t uid; <br>\nuint32_t gid; <br>\nuint32_t rdev; <br>\nuint32_t blksize; <br>\nuint32_t padding; <br>\n} attr; <br>\n};</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_ACCESS</b></p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_access_in { <br>\nuint32_t mask; <br>\nuint32_t padding; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">If the\n<i>default_permissions</i> mount options is not used, this\nrequest may be used for permissions checking. No reply data\nis expected, but errors may be indicated as usual by setting\nthe <i>error</i> field in the reply header (in particular,\naccess denied errors may be indicated by returning\n<b>-EACCES</b>).</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_OPEN</b> and\n<b>FUSE_OPENDIR</b></p>\n\n<p style=\"margin-left:28%;\">struct fuse_open_in { <br>\nuint32_t flags; /* The flags that were passed <br>\nto the open(2) */ <br>\nuint32_t unused; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The requested\noperation is to open the node indicated by\n<i>header-&gt;nodeid</i>. The exact semantics of what this\nmeans will depend on the filesystem being implemented.\nHowever, at the very least the filesystem should validate\nthat the requested <i>flags</i> are valid for the indicated\nresource and then send a reply with the following\nformat:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_open_out { <br>\nuint64_t fh; <br>\nuint32_t open_flags; <br>\nuint32_t padding; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The <i>fh</i>\nfield is an opaque identifier that the kernel will use to\nrefer to this resource The <i>open_flags</i> field is a bit\nmask of any number of the flags that indicate properties of\nthis file handle to the kernel:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"26%\">\n\n\n<p><b>FOPEN_DIRECT_IO</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"51%\">\n\n\n<p>Bypass page cache for this open file.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"26%\">\n\n\n<p><b>FOPEN_KEEP_CACHE</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"51%\">\n\n\n<p>Don&rsquo;t invalidate the data cache on open.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"26%\">\n\n\n<p><b>FOPEN_NONSEEKABLE</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"51%\">\n\n\n<p>The file is not seekable.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>FUSE_READ</b> and\n<b>FUSE_READDIR</b></p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_read_in { <br>\nuint64_t fh; <br>\nuint64_t offset; <br>\nuint32_t size; <br>\nuint32_t read_flags; <br>\nuint64_t lock_owner; <br>\nuint32_t flags; <br>\nuint32_t padding; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The requested\naction is to read up to <i>size</i> bytes of the file or\ndirectory, starting at <i>offset</i>. The bytes should be\nreturned directly following the usual reply header.</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_INTERRUPT</b></p>\n\n<p style=\"margin-left:28%;\">struct fuse_interrupt_in { <br>\nuint64_t unique; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The requested\naction is to cancel the pending operation indicated by\n<i>unique</i>. This request requires no response. However,\nreceipt of this message does not by itself cancel the\nindicated operation. The kernel will still expect a reply to\nsaid operation (e.g., an <i>EINTR</i> error or a short\nread). At most one <b>FUSE_INTERRUPT</b> request will be\nissued for a given operation. After issuing said operation,\nthe kernel will wait uninterruptibly for completion of the\nindicated request.</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_LOOKUP</b></p>\n\n<p style=\"margin-left:22%;\">Directly following the header\nis a filename to be looked up in the directory indicated by\n<i>header-&gt;nodeid</i>. The expected reply is of the\nform:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_entry_out { <br>\nuint64_t nodeid; /* Inode ID */ <br>\nuint64_t generation; /* Inode generation */ <br>\nuint64_t entry_valid; <br>\nuint64_t attr_valid; <br>\nuint32_t entry_valid_nsec; <br>\nuint32_t attr_valid_nsec; <br>\nstruct fuse_attr attr; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The combination\nof <i>nodeid</i> and <i>generation</i> must be unique for\nthe filesystem&rsquo;s lifetime.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The\ninterpretation of timeouts and <i>attr</i> is as for\n<b>FUSE_GETATTR</b>.</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_FLUSH</b></p>\n\n<p style=\"margin-left:28%;\">struct fuse_flush_in { <br>\nuint64_t fh; <br>\nuint32_t unused; <br>\nuint32_t padding; <br>\nuint64_t lock_owner; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">The requested\naction is to flush any pending changes to the indicated file\nhandle. No reply data is expected. However, an empty reply\nmessage still needs to be issued once the flush operation is\ncomplete.</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_RELEASE</b> and\n<b>FUSE_RELEASEDIR</b></p>\n\n<p style=\"margin-left:28%;\">struct fuse_release_in { <br>\nuint64_t fh; <br>\nuint32_t flags; <br>\nuint32_t release_flags; <br>\nuint64_t lock_owner; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">These are the\nconverse of <b>FUSE_OPEN</b> and <b>FUSE_OPENDIR</b>\nrespectively. The daemon may now free any resources\nassociated with the file handle <i>fh</i> as the kernel will\nno longer refer to it. There is no reply data associated\nwith this request, but a reply still needs to be issued once\nthe request has been completely processed.</p>\n\n<p style=\"margin-left:11%;\"><b>FUSE_STATFS</b></p>\n\n<p style=\"margin-left:22%;\">This operation implements\n<a href=\"https://man.page/2/statfs\">statfs(2)</a> for this filesystem. There is no input data\nassociated with this request. The expected reply data has\nthe following structure:</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_kstatfs { <br>\nuint64_t blocks; <br>\nuint64_t bfree; <br>\nuint64_t bavail; <br>\nuint64_t files; <br>\nuint64_t ffree; <br>\nuint32_t bsize; <br>\nuint32_t namelen; <br>\nuint32_t frsize; <br>\nuint32_t padding; <br>\nuint32_t spare[6]; <br>\n};</p>\n\n<p style=\"margin-left:28%; margin-top: 1em\">struct\nfuse_statfs_out { <br>\nstruct fuse_kstatfs st; <br>\n};</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">For the\ninterpretation of these fields, see <a href=\"https://man.page/2/statfs\">statfs(2)</a>.</p>\n\n<h2>ERRORS\n<a name=\"ERRORS\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p style=\"margin-top: 1em\"><b>E2BIG</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Returned from <a href=\"https://man.page/2/read\">read(2)</a>\noperations when the kernel&rsquo;s request is too large for\nthe provided buffer and the request was\n<b>FUSE_SETXATTR</b>.</p> </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EINVAL</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned from <a href=\"https://man.page/2/write\">write(2)</a> if validation of the reply\nfailed. Not all mistakes in replies will be caught by this\nvalidation. However, basic mistakes, such as short replies\nor an incorrect <i>unique</i> value, are detected.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"9%\">\n\n\n<p><b>EIO</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"78%\">\n\n\n<p>Returned from <a href=\"https://man.page/2/read\">read(2)</a> operations when the\nkernel&rsquo;s request is too large for the provided\nbuffer.</p> </td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><i>Note</i>:\nThere are various ways in which incorrect use of these\ninterfaces can cause operations on the provided\nfilesystem&rsquo;s files and directories to fail with\n<b>EIO</b>. Among the possible incorrect uses are:</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p style=\"margin-top: 1em\">changing <i>mode &amp;\nS_IFMT</i> for an inode that has previously been reported to\nthe kernel; or</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p>*</p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n\n\n<p>giving replies to the kernel that are shorter than what\nthe kernel expected.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"12%\">\n\n\n<p><b>ENODEV</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"74%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%; margin-top: 1em\">Returned from\n<a href=\"https://man.page/2/read\">read(2)</a> and <a href=\"https://man.page/2/write\">write(2)</a> if the FUSE filesystem\nwas unmounted.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>EPERM</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">Returned from operations on a\n<i>/dev/fuse</i> file descriptor that has not been\nmounted.</p> </td></tr>\n</table>\n\n<h2>CONFORMING TO\n<a name=\"CONFORMING TO\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The FUSE\nfilesystem is Linux-specific.</p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The following\nmessages are not yet documented in this manual page:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>FUSE_BATCH_FORGET\n<br>\nFUSE_BMAP <br>\nFUSE_CREATE <br>\nFUSE_DESTROY <br>\nFUSE_FALLOCATE <br>\nFUSE_FORGET <br>\nFUSE_FSYNC <br>\nFUSE_FSYNCDIR <br>\nFUSE_GETLK <br>\nFUSE_GETXATTR <br>\nFUSE_IOCTL <br>\nFUSE_LINK <br>\nFUSE_LISTXATTR <br>\nFUSE_LSEEK <br>\nFUSE_MKDIR <br>\nFUSE_MKNOD <br>\nFUSE_NOTIFY_REPLY <br>\nFUSE_POLL <br>\nFUSE_READDIRPLUS <br>\nFUSE_READLINK <br>\nFUSE_REMOVEXATTR <br>\nFUSE_RENAME <br>\nFUSE_RENAME2 <br>\nFUSE_RMDIR <br>\nFUSE_SETATTR <br>\nFUSE_SETLK <br>\nFUSE_SETLKW <br>\nFUSE_SYMLINK <br>\nFUSE_UNLINK <br>\nFUSE_WRITE</b></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/fusermount\">fusermount(1)</a>,\n<b>mount.fuse</b>(8)</p>\n\n<h2>COLOPHON\n<a name=\"COLOPHON\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This page is\npart of release 5.10 of the Linux <i>man-pages</i> project.\nA description of the project, information about reporting\nbugs, and the latest version of this page, can be found at\nhttps://www.kernel.org/doc/man-pages/.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#ERRORS\">ERRORS</a>","<a href=\"#CONFORMING TO\">CONFORMING TO</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#COLOPHON\">COLOPHON</a>"],"level":4}