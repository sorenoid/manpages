{"name":"dpkg-maintscript-helper","description":"dpkg-maintscript-helper\n- works around known dpkg limitations in maintainer\nscripts","body":"\n\n<h1 align=\"center\">dpkg-maintscript-helper</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">dpkg-maintscript-helper\n- works around known dpkg limitations in maintainer\nscripts</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dpkg-maintscript-helper</b>\n<i>command</i> [<i>parameter</i>...] <b>--</b>\n<i>maint-script-parameter</i>...</p>\n\n<h2>COMMANDS AND PARAMETERS\n<a name=\"COMMANDS AND PARAMETERS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>supports</b>\n<i>command</i> <b><br>\nrm_conffile</b> <i>conffile</i> [<i>prior-version</i>\n[<i>package</i>]] <b><br>\nmv_conffile</b> <i>old-conffile new-conffile</i>\n[<i>prior-version</i> [<i>package</i>]] <b><br>\nsymlink_to_dir</b> <i>pathname old-target</i>\n[<i>prior-version</i> [<i>package</i>]] <b><br>\ndir_to_symlink</b> <i>pathname new-target</i>\n[<i>prior-version</i> [<i>package</i>]]</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This program is\ndesigned to be run within maintainer scripts to achieve some\ntasks that <b>dpkg</b> can&rsquo;t (yet) handle natively\neither because of design decisions or due to current\nlimitations.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Many of those\ntasks require coordinated actions from several maintainer\nscripts (<b>preinst</b>, <b>postinst</b>, <b>prerm</b>,\n<b>postrm</b>). To avoid mistakes the same call simply needs\nto be put in all scripts and the program will automatically\nadapt its behaviour based on the environment variable\n<b><small>DPKG_MAINTSCRIPT_NAME</small></b> and on the\nmaintainer scripts arguments that you have to forward after\na double hyphen.</p>\n\n<h2>COMMON PARAMETERS\n<a name=\"COMMON PARAMETERS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>prior-version</i></p>\n\n<p style=\"margin-left:17%;\">Defines the latest version of\nthe package whose upgrade should trigger the operation. It\nis important to calculate <i>prior-version</i> correctly so\nthat the operations are correctly performed even if the user\nrebuilt the package with a local version. If\n<i>prior-version</i> is empty or omitted, then the operation\nis tried on every upgrade (note: it&rsquo;s safer to give\nthe version and have the operation tried only once).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the conffile\nhas not been shipped for several versions, and you are now\nmodifying the maintainer scripts to clean up the obsolete\nfile, <i>prior-version</i> should be based on the version of\nthe package that you are now preparing, not the first\nversion of the package that lacked the conffile. This\napplies to all other actions in the same way.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For example,\nfor a conffile removed in version <b>2.0-1</b> of a package,\n<i>prior-version</i> should be set to <b>2.0-1~</b>. This\nwill cause the conffile to be removed even if the user\nrebuilt the previous version <b>1.0-1</b> as\n<b>1.0-1local1</b>. Or a package switching a path from a\nsymlink (shipped in version <b>1.0-1</b>) to a directory\n(shipped in version <b>2.0-1</b>), but only performing the\nactual switch in the maintainer scripts in version\n<b>3.0-1</b>, should set <i>prior-version</i> to\n<b>3.0-1~</b>.</p>\n\n<p style=\"margin-left:11%;\"><i>package</i></p>\n\n<p style=\"margin-left:17%;\">The package name owning the\npathname(s). When the package is &ldquo;Multi-Arch:\nsame&rdquo; this parameter must include the architecture\nqualifier, otherwise it should <b>not</b> usually include\nthe architecture qualifier (as it would disallow\ncross-grades, or switching from being architecture specific\nto architecture <b>all</b> or vice versa). If the parameter\nis empty or omitted, the\n<b><small>DPKG_MAINTSCRIPT_PACKAGE</small></b> and\n<b><small>DPKG_MAINTSCRIPT_ARCH</small></b> environment\nvariables (as set by <b>dpkg</b> when running the maintainer\nscripts) will be used to generate an arch-qualified package\nname.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"3%\">\n\n\n<p><b>--</b></p></td>\n<td width=\"3%\"></td>\n<td width=\"83%\">\n\n\n<p>All the parameters of the maintainer scripts have to be\nforwarded to the program after <b>--</b>.</p></td></tr>\n</table>\n\n<h2>CONFFILE RELATED TASKS\n<a name=\"CONFFILE RELATED TASKS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When upgrading\na package, <b>dpkg</b> will not automatically remove a\nconffile (a configuration file for which <b>dpkg</b> should\npreserve user changes) if it is not present in the newer\nversion. There are two principal reasons for this; the first\nis that the conffile could&rsquo;ve been dropped by accident\nand the next version could restore it, users wouldn&rsquo;t\nwant their changes thrown away. The second is to allow\npackages to transition files from a dpkg-maintained conffile\nto a file maintained by the package&rsquo;s maintainer\nscripts, usually with a tool like debconf or ucf.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This means that\nif a package is intended to rename or remove a conffile, it\nmust explicitly do so and <b>dpkg-maintscript-helper</b> can\nbe used to implement graceful deletion and moving of\nconffiles within maintainer scripts.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Removing a\nconffile</b> <br>\nNote: This can be replaced in most cases by the\n&quot;remove-on-upgrade&quot; flag in\n<i>DEBIAN/conffiles</i> (since dpkg 1.20.6), see\n<a href=\"https://man.page/5/deb-conffiles\">deb-conffiles(5)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a conffile\nis completely removed, it should be removed from disk,\nunless the user has modified it. If there are local\nmodifications, they should be preserved. If the package\nupgrades aborts, the newly obsolete conffile should not\ndisappear.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All of this is\nimplemented by putting the following shell snippet in the\n<b>preinst</b>, <b>postinst</b> and <b>postrm</b> maintainer\nscripts:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">dpkg-maintscript-helper\nrm_conffile \\ <i><br>\nconffile prior-version package</i> -- &quot;$@&quot;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>conffile</i>\nis the filename of the conffile to remove.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Current\nimplementation: in the <b>preinst</b>, it checks if the\nconffile was modified and renames it either to\n<i>conffile</i><b>.dpkg-remove</b> (if not modified) or to\n<i>conffile</i><b>.dpkg-backup</b> (if modified). In the\n<b>postinst</b>, the latter file is renamed to\n<i>conffile</i><b>.dpkg-bak</b> and kept for reference as it\ncontains user modifications but the former will be removed.\nIf the package upgrade aborts, the <b>postrm</b> reinstalls\nthe original conffile. During purge, the <b>postrm</b> will\nalso delete the <b>.dpkg-bak</b> file kept up to now.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Renaming a\nconffile</b> <br>\nIf a conffile is moved from one location to another, you\nneed to make sure you move across any changes the user has\nmade. This may seem a simple change to the <b>preinst</b>\nscript at first, however that will result in the user being\nprompted by <b>dpkg</b> to approve the conffile edits even\nthough they are not responsible of them.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Graceful\nrenaming can be implemented by putting the following shell\nsnippet in the <b>preinst</b>, <b>postinst</b> and\n<b>postrm</b> maintainer scripts:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">dpkg-maintscript-helper\nmv_conffile \\ <i><br>\nold-conffile new-conffile prior-version package</i> --\n&quot;$@&quot;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>old-conffile</i>\nand <i>new-conffile</i> are the old and new name of the\nconffile to rename.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Current\nimplementation: the <b>preinst</b> checks if the conffile\nhas been modified, if yes it&rsquo;s left on place otherwise\nit&rsquo;s renamed to\n<i>old-conffile</i><b>.dpkg-remove</b>. On configuration,\nthe <b>postinst</b> removes\n<i>old-conffile</i><b>.dpkg-remove</b> and renames\n<i>old-conffile</i> to <i>new-conffile</i> if\n<i>old-conffile</i> is still available. On\nabort-upgrade/abort-install, the <b>postrm</b> renames\n<i>old-conffile</i><b>.dpkg-remove</b> back to\n<i>old-conffile</i> if required.</p>\n\n<h2>SYMLINK AND DIRECTORY SWITCHES\n<a name=\"SYMLINK AND DIRECTORY SWITCHES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When upgrading\na package, <b>dpkg</b> will not automatically switch a\nsymlink to a directory or vice-versa. Downgrades are not\nsupported and the path will be left as is.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Switching a\nsymlink to directory</b> <br>\nIf a symlink is switched to a real directory, you need to\nmake sure before unpacking that the symlink is removed. This\nmay seem a simple change to the <b>preinst</b> script at\nfirst, however that will result in some problems in case of\nadmin local customization of the symlink or when downgrading\nthe package.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Graceful\nrenaming can be implemented by putting the following shell\nsnippet in the <b>preinst</b>, <b>postinst</b> and\n<b>postrm</b> maintainer scripts:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">dpkg-maintscript-helper\nsymlink_to_dir \\ <i><br>\npathname old-target prior-version package</i> --\n&quot;$@&quot;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>pathname</i>\nis the absolute name of the old symlink (the path will be a\ndirectory at the end of the installation) and\n<i>old-target</i> is the target name of the former symlink\nat <i>pathname</i>. It can either be absolute or relative to\nthe directory containing <i>pathname</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Current\nimplementation: the <b>preinst</b> checks if the symlink\nexists and points to <i>old-target</i>, if not then\nit&rsquo;s left in place, otherwise it&rsquo;s renamed to\n<i>pathname</i><b>.dpkg-backup</b>. On configuration, the\n<b>postinst</b> removes <i>pathname</i><b>.dpkg-backup</b>\nif <i>pathname</i><b>.dpkg-backup</b> is still a symlink. On\nabort-upgrade/abort-install, the <b>postrm</b> renames\n<i>pathname</i><b>.dpkg-backup</b> back to <i>pathname</i>\nif required.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Switching a\ndirectory to symlink</b> <br>\nIf a real directory is switched to a symlink, you need to\nmake sure before unpacking that the directory is removed.\nThis may seem a simple change to the <b>preinst</b> script\nat first, however that will result in some problems in case\nthe directory contains conffiles, pathnames owned by other\npackages, locally created pathnames, or when downgrading the\npackage.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Graceful\nswitching can be implemented by putting the following shell\nsnippet in the <b>preinst</b>, <b>postinst</b> and\n<b>postrm</b> maintainer scripts:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">dpkg-maintscript-helper\ndir_to_symlink \\ <i><br>\npathname new-target prior-version package</i> --\n&quot;$@&quot;</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>pathname</i>\nis the absolute name of the old directory (the path will be\na symlink at the end of the installation) and\n<i>new-target</i> is the target of the new symlink at\n<i>pathname</i>. It can either be absolute or relative to\nthe directory containing <i>pathname</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Current\nimplementation: the <b>preinst</b> checks if the directory\nexists, does not contain conffiles, pathnames owned by other\npackages, or locally created pathnames, if not then\nit&rsquo;s left in place, otherwise it&rsquo;s renamed to\n<i>pathname</i><b>.dpkg-backup</b>, and an empty staging\ndirectory named <i>pathname</i> is created, marked with a\nfile so that dpkg can track it. On configuration, the\n<b>postinst</b> finishes the switch if\n<i>pathname</i><b>.dpkg-backup</b> is still a directory and\n<i>pathname</i> is the staging directory; it removes the\nstaging directory mark file, moves the newly created files\ninside the staging directory to the symlink target\n<i>new-target</i>/, replaces the now empty staging directory\n<i>pathname</i> with a symlink to <i>new-target</i>, and\nremoves <i>pathname</i><b>.dpkg-backup</b>. On\nabort-upgrade/abort-install, the <b>postrm</b> renames\n<i>pathname</i><b>.dpkg-backup</b> back to <i>pathname</i>\nif required.</p>\n\n<h2>INTEGRATION IN PACKAGES\n<a name=\"INTEGRATION IN PACKAGES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When using a\npackaging helper, please check if it has native\n<b>dpkg-maintscript-helper</b> integration, which might make\nyour life easier. See for example\n<a href=\"https://man.page/1/dh_installdeb\">dh_installdeb(1)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given that\n<b>dpkg-maintscript-helper</b> is used in the\n<b>preinst</b>, using it unconditionally requires a\npre-dependency to ensure that the required version of\n<b>dpkg</b> has been unpacked before. The required version\ndepends on the command used, for <b>rm_conffile</b> and\n<b>mv_conffile</b> it is 1.15.7.2, for <b>symlink_to_dir</b>\nand <b>dir_to_symlink</b> it is 1.17.14:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Pre-Depends:\ndpkg (&gt;= 1.17.14)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">But in many\ncases the operation done by the program is not critical for\nthe package, and instead of using a pre-dependency we can\ncall the program only if we know that the required command\nis supported by the currently installed <b>dpkg</b>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if\ndpkg-maintscript-helper supports <i>command</i>; then <br>\ndpkg-maintscript-helper <i>command</i> ... <br>\nfi</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The command\n<b>supports</b> will return 0 on success, 1 otherwise. The\n<b>supports</b> command will check if the environment\nvariables as set by dpkg and required by the script are\npresent, and will consider it a failure in case the\nenvironment is not sufficient.</p>\n\n<h2>ENVIRONMENT\n<a name=\"ENVIRONMENT\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><small>DPKG_ROOT</small></b></p>\n\n<p style=\"margin-left:17%;\">If set, it will be used as the\nfilesystem root directory.</p>\n\n\n<p style=\"margin-left:11%;\"><b><small>DPKG_ADMINDIR</small></b></p>\n\n<p style=\"margin-left:17%;\">If set, it will be used as the\n<b>dpkg</b> data directory.</p>\n\n\n<p style=\"margin-left:11%;\"><b><small>DPKG_COLORS</small></b></p>\n\n<p style=\"margin-left:17%;\">Sets the color mode (since dpkg\n1.19.1). The currently accepted values are: <b>auto</b>\n(default), <b>always</b> and <b>never</b>.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/dh_installdeb\">dh_installdeb(1)</a>.</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#COMMANDS AND PARAMETERS\">COMMANDS AND PARAMETERS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#COMMON PARAMETERS\">COMMON PARAMETERS</a>","<a href=\"#CONFFILE RELATED TASKS\">CONFFILE RELATED TASKS</a>","<a href=\"#SYMLINK AND DIRECTORY SWITCHES\">SYMLINK AND DIRECTORY SWITCHES</a>","<a href=\"#INTEGRATION IN PACKAGES\">INTEGRATION IN PACKAGES</a>","<a href=\"#ENVIRONMENT\">ENVIRONMENT</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>"]}