{"name":"git-bisect","description":"git-bisect -\nUse binary search to find the commit that introduced a\nbug","body":"\n\n<h1 align=\"center\">GIT-BISECT</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-bisect -\nUse binary search to find the commit that introduced a\nbug</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nbisect</i> &lt;subcommand&gt; &lt;options&gt;</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The command\ntakes various subcommands, and different options depending\non the subcommand:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git bisect\nstart [--term-{new,bad}=&lt;term&gt;\n--term-{old,good}=&lt;term&gt;] <br>\n[--no-checkout] [--first-parent] [&lt;bad&gt;\n[&lt;good&gt;...]] [--] [&lt;paths&gt;...] <br>\ngit bisect (bad|new|&lt;term-new&gt;) [&lt;rev&gt;] <br>\ngit bisect (good|old|&lt;term-old&gt;) [&lt;rev&gt;...] <br>\ngit bisect terms [--term-good | --term-bad] <br>\ngit bisect skip [(&lt;rev&gt;|&lt;range&gt;)...] <br>\ngit bisect reset [&lt;commit&gt;] <br>\ngit bisect (visualize|view) <br>\ngit bisect replay &lt;logfile&gt; <br>\ngit bisect log <br>\ngit bisect run &lt;cmd&gt;... <br>\ngit bisect help</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This command\nuses a binary search algorithm to find which commit in your\nproject&rsquo;s history introduced a bug. You use it by\nfirst telling it a &quot;bad&quot; commit that is known to\ncontain the bug, and a &quot;good&quot; commit that is known\nto be before the bug was introduced. Then <b>git bisect</b>\npicks a commit between those two endpoints and asks you\nwhether the selected commit is &quot;good&quot; or\n&quot;bad&quot;. It continues narrowing down the range until\nit finds the exact commit that introduced the change.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In fact, <b>git\nbisect</b> can be used to find the commit that changed\n<b>any</b> property of your project; e.g., the commit that\nfixed a bug, or the commit that caused a benchmark&rsquo;s\nperformance to improve. To support this more general usage,\nthe terms &quot;old&quot; and &quot;new&quot; can be used in\nplace of &quot;good&quot; and &quot;bad&quot;, or you can\nchoose your own terms. See section &quot;Alternate\nterms&quot; below for more information.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Basic bisect\ncommands: start, bad, good</b> <br>\nAs an example, suppose you are trying to find the commit\nthat broke a feature that was known to work in version\n<b>v2.6.13-rc2</b> of your project. You start a bisect\nsession as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nstart <br>\n$ git bisect bad # Current version is bad <br>\n$ git bisect good v2.6.13-rc2 # v2.6.13-rc2 is known to be\ngood</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Once you have\nspecified at least one bad and one good commit, <b>git\nbisect</b> selects a commit in the middle of that range of\nhistory, checks it out, and outputs something similar to the\nfollowing:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Bisecting: 675\nrevisions left to test after this (roughly 10 steps)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You should now\ncompile the checked-out version and test it. If that version\nworks correctly, type</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\ngood</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If that version\nis broken, type</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nbad</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then <b>git\nbisect</b> will respond with something like</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Bisecting: 337\nrevisions left to test after this (roughly 9 steps)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Keep repeating\nthe process: compile the tree, test it, and depending on\nwhether it is good or bad run <b>git bisect good</b> or\n<b>git bisect bad</b> to ask for the next commit that needs\ntesting.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Eventually\nthere will be no more revisions left to inspect, and the\ncommand will print out a description of the first bad\ncommit. The reference <b>refs/bisect/bad</b> will be left\npointing at that commit.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Bisect\nreset</b> <br>\nAfter a bisect session, to clean up the bisection state and\nreturn to the original HEAD, issue the following\ncommand:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nreset</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">By default,\nthis will return your tree to the commit that was checked\nout before <b>git bisect start</b>. (A new <b>git bisect\nstart</b> will also do that, as it cleans up the old\nbisection state.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With an\noptional argument, you can return to a different commit\ninstead:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nreset &lt;commit&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\n<b>git bisect reset bisect/bad</b> will check out the first\nbad revision, while <b>git bisect reset HEAD</b> will leave\nyou on the current bisection commit and avoid switching\ncommits at all.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Alternate\nterms</b> <br>\nSometimes you are not looking for the commit that introduced\na breakage, but rather for a commit that caused a change\nbetween some other &quot;old&quot; state and &quot;new&quot;\nstate. For example, you might be looking for the commit that\nintroduced a particular fix. Or you might be looking for the\nfirst commit in which the source-code filenames were finally\nall converted to your company&rsquo;s naming standard. Or\nwhatever.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In such cases\nit can be very confusing to use the terms &quot;good&quot;\nand &quot;bad&quot; to refer to &quot;the state before the\nchange&quot; and &quot;the state after the change&quot;. So\ninstead, you can use the terms &quot;old&quot; and\n&quot;new&quot;, respectively, in place of &quot;good&quot;\nand &quot;bad&quot;. (But note that you cannot mix\n&quot;good&quot; and &quot;bad&quot; with &quot;old&quot;\nand &quot;new&quot; in a single session.)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In this more\ngeneral usage, you provide <b>git bisect</b> with a\n&quot;new&quot; commit that has some property and an\n&quot;old&quot; commit that doesn&rsquo;t have that\nproperty. Each time <b>git bisect</b> checks out a commit,\nyou test if that commit has the property. If it does, mark\nthe commit as &quot;new&quot;; otherwise, mark it as\n&quot;old&quot;. When the bisection is done, <b>git\nbisect</b> will report which commit introduced the\nproperty.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To use\n&quot;old&quot; and &quot;new&quot; instead of\n&quot;good&quot; and bad, you must run <b>git bisect\nstart</b> without commits as argument and then run the\nfollowing commands to add the commits:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git bisect old\n[&lt;rev&gt;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">to indicate\nthat a commit was before the sought change, or</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git bisect new\n[&lt;rev&gt;...]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">to indicate\nthat it was after.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To get a\nreminder of the currently used terms, use</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git bisect\nterms</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can get\njust the old (respectively new) term with <b>git bisect\nterms --term-old</b> or <b>git bisect terms\n--term-good</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you would\nlike to use your own terms instead of\n&quot;bad&quot;/&quot;good&quot; or\n&quot;new&quot;/&quot;old&quot;, you can choose any names\nyou like (except existing bisect subcommands like\n<b>reset</b>, <b>start</b>, ...) by starting the bisection\nusing</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git bisect\nstart --term-old &lt;term-old&gt; --term-new\n&lt;term-new&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example, if\nyou are looking for a commit that introduced a performance\nregression, you might use</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git bisect\nstart --term-old fast --term-new slow</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Or if you are\nlooking for the commit that fixed a bug, you might use</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git bisect\nstart --term-new fixed --term-old broken</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then, use\n<b>git bisect &lt;term-old&gt;</b> and <b>git bisect\n&lt;term-new&gt;</b> instead of <b>git bisect good</b> and\n<b>git bisect bad</b> to mark commits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Bisect\nvisualize/view</b> <br>\nTo see the currently remaining suspects in <i>gitk</i>,\nissue the following command during the bisection process\n(the subcommand <b>view</b> can be used as an alternative to\n<b>visualize</b>):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nvisualize</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>DISPLAY</b> environment variable is not set, <i>git\nlog</i> is used instead. You can also give command-line\noptions such as <b>-p</b> and <b>--stat</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nvisualize --stat</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Bisect log\nand bisect replay</b> <br>\nAfter having marked revisions as good or bad, issue the\nfollowing command to show what has been done so far:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nlog</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you discover\nthat you made a mistake in specifying the status of a\nrevision, you can save the output of this command to a file,\nedit it to remove the incorrect entries, and then issue the\nfollowing commands to return to a corrected state:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nreset <br>\n$ git bisect replay that-file</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Avoiding\ntesting a commit</b> <br>\nIf, in the middle of a bisect session, you know that the\nsuggested revision is not a good one to test (e.g. it fails\nto build and you know that the failure does not have\nanything to do with the bug you are chasing), you can\nmanually select a nearby commit and test that one\ninstead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\nexample:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\ngood/bad # previous round was good or bad. <br>\nBisecting: 337 revisions left to test after this (roughly 9\nsteps) <br>\n$ git bisect visualize # oops, that is uninteresting. <br>\n$ git reset --hard HEAD~3 # try 3 revisions before what <br>\n# was suggested</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then compile\nand test the chosen revision, and afterwards mark the\nrevision as good or bad in the usual manner.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Bisect\nskip</b> <br>\nInstead of choosing a nearby commit by yourself, you can ask\nGit to do it for you by issuing the command:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nskip # Current version cannot be tested</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if you\nskip a commit adjacent to the one you are looking for, Git\nwill be unable to tell exactly which of those commits was\nthe first bad one.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can also\nskip a range of commits, instead of just one commit, using\nrange notation. For example:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nskip v2.5..v2.6</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This tells the\nbisect process that no commit after <b>v2.5</b>, up to and\nincluding <b>v2.6</b>, should be tested.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that if\nyou also want to skip the first commit of the range you\nwould issue the command:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nskip v2.5 v2.5..v2.6</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This tells the\nbisect process that the commits between <b>v2.5</b> and\n<b>v2.6</b> (inclusive) should be skipped.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Cutting down\nbisection by giving more parameters to bisect start</b> <br>\nYou can further cut down the number of trials, if you know\nwhat part of the tree is involved in the problem you are\ntracking down, by specifying path parameters when issuing\nthe <b>bisect start</b> command:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nstart -- arch/i386 include/asm-i386</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you know\nbeforehand more than one good commit, you can narrow the\nbisect space down by specifying all of the good commits\nimmediately after the bad commit when issuing the <b>bisect\nstart</b> command:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nstart v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 -- <br>\n# v2.6.20-rc6 is bad <br>\n# v2.6.20-rc4 and v2.6.20-rc1 are good</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Bisect\nrun</b> <br>\nIf you have a script that can tell if the current source\ncode is good or bad, you can bisect by issuing the\ncommand:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nrun my_script arguments</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nscript (<b>my_script</b> in the above example) should exit\nwith code 0 if the current source code is good/old, and exit\nwith a code between 1 and 127 (inclusive), except 125, if\nthe current source code is bad/new.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Any other exit\ncode will abort the bisect process. It should be noted that\na program that terminates via <b>exit(-1)</b> leaves $? =\n255, (see the exit(3) manual page), as the value is chopped\nwith <b>&amp; 0377</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The special\nexit code 125 should be used when the current source code\ncannot be tested. If the script exits with this code, the\ncurrent revision will be skipped (see <b>git bisect skip</b>\nabove). 125 was chosen as the highest sensible value to use\nfor this purpose, because 126 and 127 are used by POSIX\nshells to signal specific error status (127 is for command\nnot found, 126 is for command found but not\nexecutable&mdash;these details do not matter, as they are\nnormal errors in the script, as far as <b>bisect run</b> is\nconcerned).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You may often\nfind that during a bisect session you want to have temporary\nmodifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a\nheader file, or &quot;revision that does not have this\ncommit needs this patch applied to work around another\nproblem this bisection is not interested in&quot;) applied\nto the revision being tested.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To cope with\nsuch a situation, after the inner <i>git bisect</i> finds\nthe next revision to test, the script can apply the patch\nbefore compiling, run the real test, and afterwards decide\nif the revision (possibly with the needed patch) passed the\ntest and then rewind the tree to the pristine state. Finally\nthe script should exit with the status of the real test to\nlet the <b>git bisect run</b> command loop determine the\neventual outcome of the bisect session.</p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--no-checkout</p>\n\n<p style=\"margin-left:17%;\">Do not checkout the new working\ntree at each iteration of the bisection process. Instead\njust update a special reference named <b>BISECT_HEAD</b> to\nmake it point to the commit that should be tested.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This option may\nbe useful when the test you would perform in each step does\nnot require a checked out tree.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the\nrepository is bare, <b>--no-checkout</b> is assumed.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--first-parent</p>\n\n<p style=\"margin-left:17%;\">Follow only the first parent\ncommit upon seeing a merge commit.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In detecting\nregressions introduced through the merging of a branch, the\nmerge commit will be identified as introduction of the bug\nand its ancestors will be ignored.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This option is\nparticularly useful in avoiding false positives when a\nmerged branch contained broken or non-buildable commits, but\nthe merge itself was OK.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull;\nAutomatically bisect a broken build between v1.2 and\nHEAD:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git bisect\nstart HEAD v1.2 -- # HEAD is bad, v1.2 is good <br>\n$ git bisect run make # &quot;make&quot; builds the app <br>\n$ git bisect reset # quit the bisect session</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull;\nAutomatically bisect a test failure between origin and\nHEAD:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git bisect\nstart HEAD origin -- # HEAD is bad, origin is good <br>\n$ git bisect run make test # &quot;make test&quot; builds\nand tests <br>\n$ git bisect reset # quit the bisect session</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull;\nAutomatically bisect a broken test case:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ cat ~/test.sh\n<br>\n#!/bin/sh <br>\nmake || exit 125 # this skips broken builds <br>\n~/check_test_case.sh # does the test case pass? <br>\n$ git bisect start HEAD HEAD~10 -- # culprit is among the\nlast 10 <br>\n$ git bisect run ~/test.sh <br>\n$ git bisect reset # quit the bisect session</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Here we use a\n<b>test.sh</b> custom script. In this script, if <b>make</b>\nfails, we skip the current commit. <b>check_test_case.sh</b>\nshould <b>exit 0</b> if the test case passes, and <b>exit\n1</b> otherwise.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">It is safer if\nboth <b>test.sh</b> and <b>check_test_case.sh</b> are\noutside the repository to prevent interactions between the\nbisect, make and test processes and the scripts.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull;\nAutomatically bisect with temporary modifications\n(hot-fix):</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ cat ~/test.sh\n<br>\n#!/bin/sh</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"># tweak the\nworking tree by merging the hot-fix branch <br>\n# and then attempt a build <br>\nif git merge --no-commit --no-ff hot-fix &amp;&amp; <br>\nmake <br>\nthen <br>\n# run project specific test and report its status <br>\n~/check_test_case.sh <br>\nstatus=$? <br>\nelse <br>\n# tell the caller this is untestable <br>\nstatus=125 <br>\nfi</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"># undo the\ntweak to allow clean flipping to the next commit <br>\ngit reset --hard</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\"># return\ncontrol <br>\nexit $status</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This applies\nmodifications from a hot-fix branch before each test run,\ne.g. in case your build or test environment changed so that\nolder revisions may need a fix which newer ones have\nalready. (Make sure the hot-fix branch is based off a commit\nwhich is contained in all revisions which you are bisecting,\nso that the merge does not pull in too much, or use <b>git\ncherry-pick</b> instead of <b>git merge</b>.)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull;\nAutomatically bisect a broken test case:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git bisect\nstart HEAD HEAD~10 -- # culprit is among the last 10 <br>\n$ git bisect run sh -c &quot;make || exit 125;\n~/check_test_case.sh&quot; <br>\n$ git bisect reset # quit the bisect session</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This shows that\nyou can do without a run script if you write the test on a\nsingle line.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; Locate a\ngood region of the object graph in a damaged repository</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git bisect\nstart HEAD &lt;known-good-commit&gt; [\n&lt;boundary-commit&gt; ... ] --no-checkout <br>\n$ git bisect run sh -c ' <br>\nGOOD=$(git for-each-ref &quot;--format=%(objectname)&quot;\nrefs/bisect/good-*) &amp;&amp; <br>\ngit rev-list --objects BISECT_HEAD --not $GOOD &gt;tmp.$$\n&amp;&amp; <br>\ngit pack-objects --stdout &gt;/dev/null &lt;tmp.$$ <br>\nrc=$? <br>\nrm -f tmp.$$ <br>\ntest $rc = 0'</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git bisect\nreset # quit the bisect session</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">In this case,\nwhen <i>git bisect run</i> finishes, bisect/bad will refer\nto a commit that has at least one parent whose reachable\ngraph is fully traversable in the sense required by <i>git\npack objects</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; Look for\na fix instead of a regression in the code</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git bisect\nstart <br>\n$ git bisect new HEAD # current commit is marked as new <br>\n$ git bisect old HEAD~10 # the tenth commit from now is\nmarked as old</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">or:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git bisect\nstart --term-old broken --term-new fixed <br>\n$ git bisect fixed <br>\n$ git bisect broken HEAD~10</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Getting\nhelp</b> <br>\nUse <b>git bisect</b> to get a short usage description, and\n<b>git bisect help</b> or <b>git bisect -h</b> to get a long\nusage description.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b><font color=\"#0000FF\">Fighting\nregressions with git bisect</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">, <a href=\"https://man.page/1/git-blame\">git-blame(1)</a>.</font></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Part\nof the <a href=\"https://man.page/1/git\">git(1)</a> suite</font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">1.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"55%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">Fighting\nregressions with git bisect</font></p></td>\n<td width=\"28%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">file:///usr/share/doc/git/html/git-bisect-lk2009.html</font></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#GIT\">GIT</a>","<a href=\"#NOTES\">NOTES</a>"]}