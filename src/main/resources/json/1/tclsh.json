{"name":"tclsh","body":"\n\n<h1 align=\"center\">tclsh</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n\n<p>______________________________________________________________________________</p>\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">tclsh - Simple\nshell containing Tcl interpreter</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>tclsh</b>\n?<b>-encoding</b> <i>name</i>? ?<i>fileName arg arg ...</i>?\n______________________________________________________________________________</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Tclsh</b> is\na shell-like application that reads Tcl commands from its\nstandard input or from a file and evaluates them. If invoked\nwith no arguments then it runs interactively, reading Tcl\ncommands from standard input and printing command results\nand error messages to standard output. It runs until the\n<b>exit</b> command is invoked or until it reaches\nend-of-file on its standard input. If there exists a file\n<b>.tclshrc</b> (or <b>tclshrc.tcl</b> on the Windows\nplatforms) in the home directory of the user, interactive\n<b>tclsh</b> evaluates the file as a Tcl script just before\nreading the first command from standard input.</p>\n\n<h2>SCRIPT FILES\n<a name=\"SCRIPT FILES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <b>tclsh</b>\nis invoked with arguments then the first few arguments\nspecify the name of a script file, and, optionally, the\nencoding of the text data stored in that script file. Any\nadditional arguments are made available to the script as\nvariables (see below). Instead of reading commands from\nstandard input <b>tclsh</b> will read Tcl commands from the\nnamed file; <b>tclsh</b> will exit when it reaches the end\nof the file. The end of the file may be marked either by the\nphysical end of the medium, or by the character,\n&ldquo;\\032&rdquo; (&ldquo;\\u001a&rdquo;, control-Z). If\nthis character is present in the file, the <b>tclsh</b>\napplication will read text up to but not including the\ncharacter. An application that requires this character in\nthe file may safely encode it as &ldquo;\\032&rdquo;,\n&ldquo;\\x1A&rdquo;, or &ldquo;\\u001a&rdquo;; or may generate\nit by use of commands such as <b>format</b> or\n<b>binary</b>. There is no automatic evaluation of\n<b>.tclshrc</b> when the name of a script file is presented\non the <b>tclsh</b> command line, but the script file can\nalways <b>source</b> it if desired.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you create a\nTcl script in a file whose first line is</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>#!/usr/local/bin/tclsh</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then you can\ninvoke the script file directly from your shell if you mark\nthe file as executable. This assumes that <b>tclsh</b> has\nbeen installed in the default location in /usr/local/bin; if\nit is installed somewhere else then you will have to modify\nthe above line to match. Many UNIX systems do not allow the\n<b>#!</b> line to exceed about 30 characters in length, so\nbe sure that the <b>tclsh</b> executable can be accessed\nwith a short file name.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An even better\napproach is to start your script files with the following\nthree lines:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>#!/bin/sh\n<br>\n# the next line restarts using tclsh \\ <br>\nexec tclsh &quot;$0&quot; ${1+&quot;$@&quot;}</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This approach\nhas three advantages over the approach in the previous\nparagraph. First, the location of the <b>tclsh</b> binary\ndoes not have to be hard-wired into the script: it can be\nanywhere in your shell search path. Second, it gets around\nthe 30-character file name limit in the previous approach.\nThird, this approach will work even if <b>tclsh</b> is\nitself a shell script (this is done on some systems in order\nto handle multiple architectures or operating systems: the\n<b>tclsh</b> script selects one of several binaries to run).\nThe three lines cause both <b>sh</b> and <b>tclsh</b> to\nprocess the script, but the <b>exec</b> is only executed by\n<b>sh</b>. <b>sh</b> processes the script first; it treats\nthe second line as a comment and executes the third line.\nThe <b>exec</b> statement cause the shell to stop processing\nand instead to start up <b>tclsh</b> to reprocess the entire\nscript. When <b>tclsh</b> starts up, it treats all three\nlines as comments, since the backslash at the end of the\nsecond line causes the third line to be treated as part of\nthe comment on the second line.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You should note\nthat it is also common practice to install tclsh with its\nversion number as part of the name. This has the advantage\nof allowing multiple versions of Tcl to exist on the same\nsystem at once, but also the disadvantage of making it\nharder to write scripts that start up uniformly across\ndifferent versions of Tcl.</p>\n\n<h2>VARIABLES\n<a name=\"VARIABLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Tclsh</b>\nsets the following global Tcl variables in addition to those\ncreated by the Tcl library itself (such as <b>env</b>, which\nmaps environment variables such as <b>PATH</b> into\nTcl):</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>argc</b></p></td>\n<td width=\"16%\"></td>\n<td width=\"66%\">\n\n\n<p>Contains a count of the number of <i>arg</i> arguments\n(0 if none), not including the name of the script file.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>argv</b></p></td>\n<td width=\"16%\"></td>\n<td width=\"66%\">\n\n\n<p>Contains a Tcl list whose elements are the <i>arg</i>\narguments, in order, or an empty string if there are no\n<i>arg</i> arguments.</p></td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p><b>argv0</b></p></td>\n<td width=\"16%\"></td>\n<td width=\"66%\">\n\n\n<p>Contains <i>fileName</i> if it was specified. Otherwise,\ncontains the name by which <b>tclsh</b> was invoked.</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\"><b>tcl_interactive</b></p>\n\n<p style=\"margin-left:34%;\">Contains 1 if <b>tclsh</b> is\nrunning interactively (no <i>fileName</i> was specified and\nstandard input is a terminal-like device), 0 otherwise.</p>\n\n<h2>PROMPTS\n<a name=\"PROMPTS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When\n<b>tclsh</b> is invoked interactively it normally prompts\nfor each command with &ldquo;<b>%</b> &rdquo;. You can\nchange the prompt by setting the global variables\n<b>tcl_prompt1</b> and <b>tcl_prompt2</b>. If variable\n<b>tcl_prompt1</b> exists then it must consist of a Tcl\nscript to output a prompt; instead of outputting a prompt\n<b>tclsh</b> will evaluate the script in <b>tcl_prompt1</b>.\nThe variable <b>tcl_prompt2</b> is used in a similar way\nwhen a newline is typed but the current command is not yet\ncomplete; if <b>tcl_prompt2</b> is not set then no prompt is\noutput for incomplete commands.</p>\n\n<h2>STANDARD CHANNELS\n<a name=\"STANDARD CHANNELS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">See\n<b>Tcl_StandardChannels</b> for more explanations.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">auto_path(3tcl),\nencoding(3tcl), env(3tcl), fconfigure(3tcl)</p>\n\n<h2>KEYWORDS\n<a name=\"KEYWORDS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">application,\nargument, interpreter, prompt, script file, shell</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SCRIPT FILES\">SCRIPT FILES</a>","<a href=\"#VARIABLES\">VARIABLES</a>","<a href=\"#PROMPTS\">PROMPTS</a>","<a href=\"#STANDARD CHANNELS\">STANDARD CHANNELS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#KEYWORDS\">KEYWORDS</a>"]}