{"name":"dfu-programmer","description":"dfu-programmer\n- USB firmware upgrading for Atmel microcontrollers","body":"\n\n<h1 align=\"center\">DFU-PROGRAMMER</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">dfu-programmer\n- USB firmware upgrading for Atmel microcontrollers</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dfu-programmer</b>\ntarget[:usb-bus,usb-addr] command [options] [parameters]\n<b><br>\ndfu-programmer</b> --help <b><br>\ndfu-programmer</b> --targets <b><br>\ndfu-programmer</b> --version</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>dfu-programmer</b>\nis a multi-platform command line Device Firmware Upgrade\n(DFU) based programmer for the flash memory on Atmel AVR,\nAVR32, XMEGA and 8051 based microcontrollers which ship with\na USB boot loader. It supports In System Programming (ISP)\nfor developers and potentially product updates in the field.\nThose boot loaders are patterned after the standard USB DFU\n1.0 class specification, but depend on extensions defined by\nAtmel to the extent that standard DFU drivers will not\nwork.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To use it,\nfirst connect the device to be programmed and ensure that it\ncomes up in DFU mode. The microcontrollers come up in that\nmode as shipped by Atmel; or they may reenter that mode\nafter a special hardware reset. Then invoke this program to\nissue one or more DFU commands. You will normally need to\nstart by issuing the &quot;erase&quot; command; the default\nsecurity policies prevent extracting firmware, to prevent\nreverse engineering of what is usually proprietary code.</p>\n\n<h2>SUPPORTED MICROCONTROLLERS\n<a name=\"SUPPORTED MICROCONTROLLERS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">These chip\nnames are used as the command line &quot;target&quot;\nparameter. <br>\n8051 based controllers:</p>\n\n<p style=\"margin-left:22%;\">at89c51snd1c, at89c51snd2c,\nat89c5130, at89c5131, and at89c5132.</p>\n\n<p style=\"margin-left:11%;\">AVR based controllers:</p>\n\n<p style=\"margin-left:22%;\">at90usb1287, at90usb1286,\nat90usb647, at90usb646, at90usb162, at90usb82, atmega32u6,\natmega32u4, atmega32u2, atmega16u4, atmega16u2 and\natmega8u2.</p>\n\n<p style=\"margin-left:11%;\">AVR32 based controllers:</p>\n\n<p style=\"margin-left:22%;\">at32uc3a0128, at32uc3a1128,\nat32uc3a0256, at32uc3a1256, at32uc3a0512, at32uc3a1512,\nat32uc3a0512es, at32uc3a1512es, at32uc3a364, at32uc3a364s,\nat32uc3a3128, at32uc3a3128s, at32uc3a3256, at32uc3a3256s,\nat32uc3a4256s, at32uc3b064, at32uc3b164, at32uc3b0128,\nat32uc3b1128, at32uc3b0256, at32uc3b1256, at32uc3b0256es,\nat32uc3b1256es, at32uc3b1512, at32uc3b0512, at32uc3c064,\nat32uc3c0128, at32uc3c0256, at32uc3c0512, at32uc3c164,\nat32uc3c1128, at32uc3c1256, at32uc3c1512, at32uc3c264,\nat32uc3c2128, at32uc3c2256 and at32uc3c2512.</p>\n\n<p style=\"margin-left:11%;\">XMEGA based controllers:</p>\n\n<p style=\"margin-left:22%;\">atxmega64a1u, atxmega128a1u,\natxmega64a3u, atxmega128a3u, atxmega192a3u, atxmega256a3u,\natxmega16a4u, atxmega32a4u, atxmega64a4u, atxmega128a4u,\natxmega256a3bu, atxmega64b1, atxmega128b1, atxmega64b3,\natxmega128b3, atxmega64c3, atxmega128c3, atxmega256c3,\natxmega384c3</p>\n\n<h2>USAGE\n<a name=\"USAGE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">There are no\nmechanisms to implement gang programming. By default, the\nfirst device that matches the id codes for the given target\nis selected. Many targets share the same id codes.\nAccordingly, you will usually avoid connecting more than one\ndevice of a given family (AVR, XMEGA, AVR32 or 8051) at a\ntime.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The target may\nbe qualified with the USB bus and address number of the\ndevice you wish to program. This allows programming multiple\ndevices of the same family at the same time.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All of these\ncommands support the &quot;global options&quot;. Unless you\noverride it, commands which write to the microcontroller\nwill perform a validation step that rereads the data which\nwas written, compares it to the expected result, and reports\nany errors.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\nunlike Atmel&rsquo;s BatchISP program, dfu-programmer will\nonly perform a single operation at a time. Erasing and\nprogramming require separate commands.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p style=\"margin-top: 1em\"><b>configure</b></p></td>\n<td width=\"1%\"></td>\n<td width=\"57%\">\n\n\n<p style=\"margin-top: 1em\">register [--suppress-validation]\ndata</p> </td>\n<td width=\"17%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Bootloaders for 8051 based\ncontrollers support writing certain configuration bytes.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"6%\">\n\n\n<p style=\"margin-top: 1em\"><b>dump</b></p></td>\n<td width=\"83%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Reads all the available flash\nmemory, and writes it as binary data to stdout.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"17%\">\n\n\n<p style=\"margin-top: 1em\"><b>dump-eeprom</b></p></td>\n<td width=\"72%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Reads all the available eeprom\nmemory, and writes it as binary data to stdout.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p style=\"margin-top: 1em\"><b>dump-user</b></p></td>\n<td width=\"75%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Reads the user space flash on\nthe AVR32 chips and writes it as binary data to stdout.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>erase</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"35%\">\n\n\n<p style=\"margin-top: 1em\">[--suppress-validation]</p></td>\n<td width=\"45%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Erases all the flash memory.\nThis is required before the bootloader will perform other\ncommands.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>flash</b></p></td>\n<td width=\"4%\"></td>\n<td width=\"78%\">\n\n\n<p style=\"margin-top: 1em\">[--suppress-validation]\n[--suppress-bootloader-mem] [--serial=hexbytes:offset] file\nor STDIN</p></td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Writes flash memory. The input\nfile (or stdin) must use the &quot;ihex&quot; file format\nconvention for a memory image. --suppress-bootloader-mem\nignores any data written to the bootloader memory space when\nflashing the device. This option is particularly useful for\nthe AVR32 chips <b>trampoline</b> code.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--serial\nprovides a way to inject a serial number or other unique\nsequence of bytes into the memory image programmed into the\ndevice. This allows using a single .ihex file to program\nmultiple devices, and still give each device its own unique\nserial number. For example, --serial=ABCDEF01:0x6000 would\nprogram the byte at 0x6000 with the hex value AB, the byte\nat 0x6001 with the value CD, and so on. There must be an\neven number of hex digits, but the sequence can be any\nlength. The offset is assumed to be given in hex if it\nstarts with a &quot;0x&quot; prefix, octal if it begins with\na &quot;0&quot;, otherwise is it assumed to be decimal.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"15%\">\n\n\n<p style=\"margin-top: 1em\"><b>flash-user</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"72%\">\n\n\n<p style=\"margin-top: 1em\">[--suppress-validation]\n[--serial=hexbytes:offset] file or</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">STDIN</p>\n\n<p style=\"margin-left:22%;\">Writes to user space flash on\nthe AVR32 chips. This block of flash is out of the normal\nrange of flash blocks and is designed to contain\nconfiguration parameters. The input file (or stdin) must use\nthe &quot;ihex&quot; file format convention for a memory\nimage.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"18%\">\n\n\n<p style=\"margin-top: 1em\"><b>flash-eeprom</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"69%\">\n\n\n<p style=\"margin-top: 1em\">[--suppress-validation]\n[--serial=hexbytes:offset] file or</p></td></tr>\n</table>\n\n<p style=\"margin-left:11%;\">STDIN</p>\n\n<p style=\"margin-left:22%;\">Writes to eeprom memory. The\ninput file (or stdin) must use the &quot;ihex&quot; file\nformat convention for a memory image.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"14%\">\n\n\n<p style=\"margin-top: 1em\"><b>setsecure</b></p></td>\n<td width=\"75%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Sets the security bit on AVR32\nchips. This prevents the content being read back from the\nchip, except in the same session in which it was programmed.\nWhen the security fuse is set, almost nothing will work\nwithout first executing the erase command. The only way to\nclear the security fuse once set is to use a JTAG chip\nerase, which will also erase the bootloader.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"4%\">\n\n\n<p style=\"margin-top: 1em\"><b>get</b></p></td>\n<td width=\"2%\"></td>\n<td width=\"12%\">\n\n\n<p style=\"margin-top: 1em\">register</p></td>\n<td width=\"71%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Displays various product\nidentifier bytes.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>reset</b></p></td>\n<td width=\"82%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Resets microcontroller using\nwatchdog timer</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"11%\"></td>\n<td width=\"7%\">\n\n\n<p style=\"margin-top: 1em\"><b>start</b></p></td>\n<td width=\"82%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:22%;\">Starts the application firmware\nby having the microcontroller jump to address zero.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Global\nOptions</b> <br>\n--quiet - minimizes the output</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--debug level -\nenables verbose output at the specified level</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Configure\nRegisters</b> <br>\nThe standard bootloader for 8051 based chips supports\nwriting data bytes which are not relevant for the AVR based\nchips.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">BSB - boot\nstatus byte <br>\nSBV - software boot vector <br>\nSSB - software security byte <br>\nEB - extra byte <br>\nHSB - hardware security byte</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Get\nRegister</b> <br>\nbootloader-version - currently flashed bootloader version\n<br>\nID1 - device boot identification 1 <br>\nID2 - device boot identification 2 <br>\nmanufacturer - the hardware manufacturer code <br>\nfamily - the product family code <br>\nproduct-name - the product name <br>\nproduct-revision - the product revision <br>\nHSB - same as the configure_register version <br>\nBSB - same as the configure_register version <br>\nSBV - same as the configure_register version <br>\nSSB - same as the configure_register version <br>\nEB - same as the configure_register version</p>\n\n<h2>BUGS\n<a name=\"BUGS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">None known.</p>\n\n<h2>KNOWN ISSUES\n<a name=\"KNOWN ISSUES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The at90usb\nseries chips do not make available any read/write protect\nflags so the <b>dump</b> or <b>flash</b> command may fail\nwith a less than helpful error message.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To remove\n<b>any</b> write or read protection from any chips, a full\nchip erasure is required. For AVR32 chips an erase operation\nover USB will remove protection until the device is\nrebooted. To remove the protection more permanently requires\na JTAG erase (which will also erase the bootloader).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You may need to\nbe a member of the <b>uucp</b> group in order to have access\nto the device without needing to be root.</p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Weston Schmidt\n&lt;weston_schmidt@alumni.purdue.edu&gt;</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SUPPORTED MICROCONTROLLERS\">SUPPORTED MICROCONTROLLERS</a>","<a href=\"#USAGE\">USAGE</a>","<a href=\"#BUGS\">BUGS</a>","<a href=\"#KNOWN ISSUES\">KNOWN ISSUES</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>"]}