{"name":"git-checkout","description":"git-checkout - Switch branches or restore working tree files","body":"\n\n<h1 align=\"center\">GIT-CHECKOUT</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-checkout -\nSwitch branches or restore working tree files</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\ncheckout</i> [-q] [-f] [-m] [&lt;branch&gt;] <i><br>\ngit checkout</i> [-q] [-f] [-m] --detach [&lt;branch&gt;]\n<i><br>\ngit checkout</i> [-q] [-f] [-m] [--detach] &lt;commit&gt;\n<i><br>\ngit checkout</i> [-q] [-f] [-m] [[-b|-B|--orphan]\n&lt;new_branch&gt;] [&lt;start_point&gt;] <i><br>\ngit checkout</i>\n[-f|--ours|--theirs|-m|--conflict=&lt;style&gt;]\n[&lt;tree-ish&gt;] [--] &lt;pathspec&gt;... <i><br>\ngit checkout</i>\n[-f|--ours|--theirs|-m|--conflict=&lt;style&gt;]\n[&lt;tree-ish&gt;] --pathspec-from-file=&lt;file&gt;\n[--pathspec-file-nul] <i><br>\ngit checkout</i> (-p|--patch) [&lt;tree-ish&gt;] [--]\n[&lt;pathspec&gt;...]</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Updates files\nin the working tree to match the version in the index or the\nspecified tree. If no pathspec was given, <i>git\ncheckout</i> will also update <b>HEAD</b> to set the\nspecified branch as the current branch.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\ncheckout</i> [&lt;branch&gt;]</p>\n\n<p style=\"margin-left:17%;\">To prepare for working on\n<b>&lt;branch&gt;</b>, switch to it by updating the index\nand the files in the working tree, and by pointing\n<b>HEAD</b> at the branch. Local modifications to the files\nin the working tree are kept, so that they can be committed\nto the <b>&lt;branch&gt;</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If\n<b>&lt;branch&gt;</b> is not found but there does exist a\ntracking branch in exactly one remote (call it\n<b>&lt;remote&gt;</b>) with a matching name and\n<b>--no-guess</b> is not specified, treat as equivalent\nto</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\n-b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You could omit\n<b>&lt;branch&gt;</b>, in which case the command degenerates\nto &quot;check out the current branch&quot;, which is a\nglorified no-op with rather expensive side-effects to show\nonly the tracking information, if exists, for the current\nbranch.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\ncheckout</i> -b|-B &lt;new_branch&gt; [&lt;start\npoint&gt;]</p>\n\n<p style=\"margin-left:17%;\">Specifying <b>-b</b> causes a\nnew branch to be created as if <a href=\"https://man.page/1/git-branch\">git-branch(1)</a> were\ncalled and then checked out. In this case you can use the\n<b>--track</b> or <b>--no-track</b> options, which will be\npassed to <i>git branch</i>. As a convenience,\n<b>--track</b> without <b>-b</b> implies branch creation;\nsee the description of <b>--track</b> below.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If <b>-B</b> is\ngiven, <b>&lt;new_branch&gt;</b> is created if it\ndoesn&rsquo;t exist; otherwise, it is reset. This is the\ntransactional equivalent of</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git branch -f\n&lt;branch&gt; [&lt;start point&gt;] <br>\n$ git checkout &lt;branch&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">that is to say,\nthe branch is not reset/created unless &quot;git\ncheckout&quot; is successful.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\ncheckout</i> --detach [&lt;branch&gt;], <i>git checkout</i>\n[--detach] &lt;commit&gt;</p>\n\n<p style=\"margin-left:17%;\">Prepare to work on top of\n<b>&lt;commit&gt;</b>, by detaching <b>HEAD</b> at it (see\n&quot;DETACHED HEAD&quot; section), and updating the index\nand the files in the working tree. Local modifications to\nthe files in the working tree are kept, so that the\nresulting working tree will be the state recorded in the\ncommit plus the local modifications.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When the\n<b>&lt;commit&gt;</b> argument is a branch name, the\n<b>--detach</b> option can be used to detach <b>HEAD</b> at\nthe tip of the branch (<b>git checkout &lt;branch&gt;</b>\nwould check out that branch without detaching\n<b>HEAD</b>).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Omitting\n<b>&lt;branch&gt;</b> detaches <b>HEAD</b> at the tip of the\ncurrent branch.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\ncheckout</i>\n[-f|--ours|--theirs|-m|--conflict=&lt;style&gt;]\n[&lt;tree-ish&gt;] [--] &lt;pathspec&gt;..., <i>git\ncheckout</i>\n[-f|--ours|--theirs|-m|--conflict=&lt;style&gt;]\n[&lt;tree-ish&gt;] --pathspec-from-file=&lt;file&gt;\n[--pathspec-file-nul]</p>\n\n<p style=\"margin-left:17%;\">Overwrite the contents of the\nfiles that match the pathspec. When the\n<b>&lt;tree-ish&gt;</b> (most often a commit) is not given,\noverwrite working tree with the contents in the index. When\nthe <b>&lt;tree-ish&gt;</b> is given, overwrite both the\nindex and the working tree with the contents at the\n<b>&lt;tree-ish&gt;</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The index may\ncontain unmerged entries because of a previous failed merge.\nBy default, if you try to check out such an entry from the\nindex, the checkout operation will fail and nothing will be\nchecked out. Using <b>-f</b> will ignore these unmerged\nentries. The contents from a specific side of the merge can\nbe checked out of the index by using <b>--ours</b> or\n<b>--theirs</b>. With <b>-m</b>, changes made to the working\ntree file can be discarded to re-create the original\nconflicted merge result.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\ncheckout</i> (-p|--patch) [&lt;tree-ish&gt;] [--]\n[&lt;pathspec&gt;...]</p>\n\n<p style=\"margin-left:17%;\">This is similar to the previous\nmode, but lets you use the interactive interface to show the\n&quot;diff&quot; output and choose which hunks to use in the\nresult. See below for the description of <b>--patch</b>\noption.</p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-q, --quiet</p>\n\n<p style=\"margin-left:17%;\">Quiet, suppress feedback\nmessages.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--progress,\n--no-progress</p>\n\n<p style=\"margin-left:17%;\">Progress status is reported on\nthe standard error stream by default when it is attached to\na terminal, unless <b>--quiet</b> is specified. This flag\nenables progress reporting even if not attached to a\nterminal, regardless of <b>--quiet</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-f, --force</p>\n\n<p style=\"margin-left:17%;\">When switching branches,\nproceed even if the index or the working tree differs from\n<b>HEAD</b>, and even if there are untracked files in the\nway. This is used to throw away local changes and any\nuntracked files or directories that are in the way.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When checking\nout paths from the index, do not fail upon unmerged entries;\ninstead, unmerged entries are ignored.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--ours,\n--theirs</p>\n\n<p style=\"margin-left:17%;\">When checking out paths from\nthe index, check out stage #2 (<i>ours</i>) or #3\n(<i>theirs</i>) for unmerged paths.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\nduring <b>git rebase</b> and <b>git pull --rebase</b>,\n<i>ours</i> and <i>theirs</i> may appear swapped;\n<b>--ours</b> gives the version from the branch the changes\nare rebased onto, while <b>--theirs</b> gives the version\nfrom the branch that holds your work that is being\nrebased.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This is because\n<b>rebase</b> is used in a workflow that treats the history\nat the remote as the shared canonical one, and treats the\nwork done on the branch you are rebasing as the third-party\nwork to be integrated, and you are temporarily assuming the\nrole of the keeper of the canonical history during the\nrebase. As the keeper of the canonical history, you need to\nview the history from the remote as <b>ours</b> (i.e.\n&quot;our shared canonical history&quot;), while what you\ndid on your side branch as <b>theirs</b> (i.e. &quot;one\ncontributor&rsquo;s work on top of it&quot;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-b\n&lt;new_branch&gt;</p>\n\n<p style=\"margin-left:17%;\">Create a new branch named\n<b>&lt;new_branch&gt;</b> and start it at\n<b>&lt;start_point&gt;</b>; see <a href=\"https://man.page/1/git-branch\">git-branch(1)</a> for\ndetails.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-B\n&lt;new_branch&gt;</p>\n\n<p style=\"margin-left:17%;\">Creates the branch\n<b>&lt;new_branch&gt;</b> and start it at\n<b>&lt;start_point&gt;</b>; if it already exists, then reset\nit to <b>&lt;start_point&gt;</b>. This is equivalent to\nrunning &quot;git branch&quot; with &quot;-f&quot;; see\n<a href=\"https://man.page/1/git-branch\">git-branch(1)</a> for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-t, --track</p>\n\n<p style=\"margin-left:17%;\">When creating a new branch, set\nup &quot;upstream&quot; configuration. See\n&quot;--track&quot; in <a href=\"https://man.page/1/git-branch\">git-branch(1)</a> for details.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If no <b>-b</b>\noption is given, the name of the new branch will be derived\nfrom the remote-tracking branch, by looking at the local\npart of the refspec configured for the corresponding remote,\nand then stripping the initial part up to the &quot;*&quot;.\nThis would tell us to use <b>hack</b> as the local branch\nwhen branching off of <b>origin/hack</b> (or\n<b>remotes/origin/hack</b>, or even\n<b>refs/remotes/origin/hack</b>). If the given name has no\nslash, or the above guessing results in an empty name, the\nguessing is aborted. You can explicitly give a name with\n<b>-b</b> in such a case.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--no-track</p>\n\n<p style=\"margin-left:17%;\">Do not set up\n&quot;upstream&quot; configuration, even if the\n<b>branch.autoSetupMerge</b> configuration variable is\ntrue.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--guess,\n--no-guess</p>\n\n<p style=\"margin-left:17%;\">If <b>&lt;branch&gt;</b> is not\nfound but there does exist a tracking branch in exactly one\nremote (call it <b>&lt;remote&gt;</b>) with a matching name,\ntreat as equivalent to</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\n-b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If the branch\nexists in multiple remotes and one of them is named by the\n<b>checkout.defaultRemote</b> configuration variable,\nwe&rsquo;ll use that one for the purposes of disambiguation,\neven if the <b>&lt;branch&gt;</b> isn&rsquo;t unique across\nall remotes. Set it to e.g.\n<b>checkout.defaultRemote=origin</b> to always checkout\nremote branches from there if <b>&lt;branch&gt;</b> is\nambiguous but exists on the <i>origin</i> remote. See also\n<b>checkout.defaultRemote</b> in <a href=\"https://man.page/1/git-config\">git-config(1)</a>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>--guess</b>\nis the default behavior. Use <b>--no-guess</b> to disable\nit.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The default\nbehavior can be set via the <b>checkout.guess</b>\nconfiguration variable.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-l</p>\n\n<p style=\"margin-left:17%;\">Create the new branch&rsquo;s\nreflog; see <a href=\"https://man.page/1/git-branch\">git-branch(1)</a> for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-d,\n--detach</p>\n\n<p style=\"margin-left:17%;\">Rather than checking out a\nbranch to work on it, check out a commit for inspection and\ndiscardable experiments. This is the default behavior of\n<b>git checkout &lt;commit&gt;</b> when\n<b>&lt;commit&gt;</b> is not a branch name. See the\n&quot;DETACHED HEAD&quot; section below for details.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--orphan\n&lt;new_branch&gt;</p>\n\n<p style=\"margin-left:17%;\">Create a new <i>orphan</i>\nbranch, named <b>&lt;new_branch&gt;</b>, started from\n<b>&lt;start_point&gt;</b> and switch to it. The first\ncommit made on this new branch will have no parents and it\nwill be the root of a new history totally disconnected from\nall the other branches and commits.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">The index and\nthe working tree are adjusted as if you had previously run\n<b>git checkout &lt;start_point&gt;</b>. This allows you to\nstart a new history that records a set of paths similar to\n<b>&lt;start_point&gt;</b> by easily running <b>git commit\n-a</b> to make the root commit.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This can be\nuseful when you want to publish the tree from a commit\nwithout exposing its full history. You might want to do this\nto publish an open source branch of a project whose current\ntree is &quot;clean&quot;, but whose full history contains\nproprietary or otherwise encumbered bits of code.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you want to\nstart a disconnected history that records a set of paths\nthat is totally different from the one of\n<b>&lt;start_point&gt;</b>, then you should clear the index\nand the working tree right after creating the orphan branch\nby running <b>git rm -rf .</b> from the top level of the\nworking tree. Afterwards you will be ready to prepare your\nnew files, repopulating the working tree, by copying them\nfrom elsewhere, extracting a tarball, etc.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--ignore-skip-worktree-bits</p>\n\n<p style=\"margin-left:17%;\">In sparse checkout mode, <b>git\ncheckout -- &lt;paths&gt;</b> would update only entries\nmatched by <b>&lt;paths&gt;</b> and sparse patterns in\n<b>$GIT_DIR/info/sparse-checkout</b>. This option ignores\nthe sparse patterns and adds back any files in\n<b>&lt;paths&gt;</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-m, --merge</p>\n\n<p style=\"margin-left:17%;\">When switching branches, if you\nhave local modifications to one or more files that are\ndifferent between the current branch and the branch to which\nyou are switching, the command refuses to switch branches in\norder to preserve your modifications in context. However,\nwith this option, a three-way merge between the current\nbranch, your working tree contents, and the new branch is\ndone, and you will be on the new branch.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When a merge\nconflict happens, the index entries for conflicting paths\nare left unmerged, and you need to resolve the conflicts and\nmark the resolved paths with <b>git add</b> (or <b>git\nrm</b> if the merge should result in deletion of the\npath).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When checking\nout paths from the index, this option lets you recreate the\nconflicted merge in the specified paths.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When switching\nbranches with <b>--merge</b>, staged changes may be\nlost.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--conflict=&lt;style&gt;</p>\n\n<p style=\"margin-left:17%;\">The same as <b>--merge</b>\noption above, but changes the way the conflicting hunks are\npresented, overriding the <b>merge.conflictStyle</b>\nconfiguration variable. Possible values are\n&quot;merge&quot; (default) and &quot;diff3&quot; (in\naddition to what is shown by &quot;merge&quot; style, shows\nthe original contents).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-p, --patch</p>\n\n<p style=\"margin-left:17%;\">Interactively select hunks in\nthe difference between the <b>&lt;tree-ish&gt;</b> (or the\nindex, if unspecified) and the working tree. The chosen\nhunks are then applied in reverse to the working tree (and\nif a <b>&lt;tree-ish&gt;</b> was specified, the index).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This means that\nyou can use <b>git checkout -p</b> to selectively discard\nedits from your current working tree. See the\n&ldquo;Interactive Mode&rdquo; section of <a href=\"https://man.page/1/git-add\">git-add(1)</a>\nto learn how to operate the <b>--patch</b> mode.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that this\noption uses the no overlay mode by default (see also\n<b>--overlay</b>), and currently doesn&rsquo;t support\noverlay mode.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--ignore-other-worktrees</p>\n\n<p style=\"margin-left:17%;\"><b>git checkout</b> refuses\nwhen the wanted ref is already checked out by another\nworktree. This option makes it check the ref out anyway. In\nother words, the ref can be held by more than one\nworktree.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--overwrite-ignore,\n--no-overwrite-ignore</p>\n\n<p style=\"margin-left:17%;\">Silently overwrite ignored\nfiles when switching branches. This is the default behavior.\nUse <b>--no-overwrite-ignore</b> to abort the operation when\nthe new branch contains ignored files.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--recurse-submodules,\n--no-recurse-submodules</p>\n\n<p style=\"margin-left:17%;\">Using\n<b>--recurse-submodules</b> will update the content of all\nactive submodules according to the commit recorded in the\nsuperproject. If local modifications in a submodule would be\noverwritten the checkout will fail unless <b>-f</b> is used.\nIf nothing (or <b>--no-recurse-submodules</b>) is used,\nsubmodules working trees will not be updated. Just like\n<a href=\"https://man.page/1/git-submodule\">git-submodule(1)</a>, this will detach <b>HEAD</b> of the\nsubmodule.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--overlay,\n--no-overlay</p>\n\n<p style=\"margin-left:17%;\">In the default overlay mode,\n<b>git checkout</b> never removes files from the index or\nthe working tree. When specifying <b>--no-overlay</b>, files\nthat appear in the index and working tree, but not in\n<b>&lt;tree-ish&gt;</b> are removed, to make them match\n<b>&lt;tree-ish&gt;</b> exactly.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--pathspec-from-file=&lt;file&gt;</p>\n\n<p style=\"margin-left:17%;\">Pathspec is passed in\n<b>&lt;file&gt;</b> instead of commandline args. If\n<b>&lt;file&gt;</b> is exactly <b>-</b> then standard input\nis used. Pathspec elements are separated by LF or CR/LF.\nPathspec elements can be quoted as explained for the\nconfiguration variable <b>core.quotePath</b> (see\n<a href=\"https://man.page/1/git-config\">git-config(1)</a>). See also <b>--pathspec-file-nul</b>\nand global <b>--literal-pathspecs</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--pathspec-file-nul</p>\n\n<p style=\"margin-left:17%;\">Only meaningful with\n<b>--pathspec-from-file</b>. Pathspec elements are separated\nwith NUL character and all other characters are taken\nliterally (including newlines and quotes).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;branch&gt;</p>\n\n<p style=\"margin-left:17%;\">Branch to checkout; if it\nrefers to a branch (i.e., a name that, when prepended with\n&quot;refs/heads/&quot;, is a valid ref), then that branch\nis checked out. Otherwise, if it refers to a valid commit,\nyour <b>HEAD</b> becomes &quot;detached&quot; and you are no\nlonger on any branch (see below for details).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can use the\n<b>@{-N}</b> syntax to refer to the N-th last branch/commit\nchecked out using &quot;git checkout&quot; operation. You\nmay also specify <b>-</b> which is synonymous to\n<b>@{-1}</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">As a special\ncase, you may use <b>A...B</b> as a shortcut for the merge\nbase of <b>A</b> and <b>B</b> if there is exactly one merge\nbase. You can leave out at most one of <b>A</b> and\n<b>B</b>, in which case it defaults to <b>HEAD</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;new_branch&gt;</p>\n\n<p style=\"margin-left:17%;\">Name for the new branch.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;start_point&gt;</p>\n\n<p style=\"margin-left:17%;\">The name of a commit at which\nto start the new branch; see <a href=\"https://man.page/1/git-branch\">git-branch(1)</a> for\ndetails. Defaults to <b>HEAD</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">As a special\ncase, you may use <b>&quot;A...B&quot;</b> as a shortcut for\nthe merge base of <b>A</b> and <b>B</b> if there is exactly\none merge base. You can leave out at most one of <b>A</b>\nand <b>B</b>, in which case it defaults to <b>HEAD</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;tree-ish&gt;</p>\n\n<p style=\"margin-left:17%;\">Tree to checkout from (when\npaths are given). If not specified, the index will be\nused.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">As a special\ncase, you may use <b>&quot;A...B&quot;</b> as a shortcut for\nthe merge base of <b>A</b> and <b>B</b> if there is exactly\none merge base. You can leave out at most one of <b>A</b>\nand <b>B</b>, in which case it defaults to <b>HEAD</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--</p>\n\n<p style=\"margin-left:17%;\">Do not interpret any more\narguments as options.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;pathspec&gt;...</p>\n\n<p style=\"margin-left:17%;\">Limits the paths affected by\nthe operation.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For more\ndetails, see the <i>pathspec</i> entry in\n<a href=\"https://man.page/7/gitglossary\">gitglossary(7)</a>.</p>\n\n<h2>DETACHED HEAD\n<a name=\"DETACHED HEAD\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>HEAD</b>\nnormally refers to a named branch (e.g. <b>master</b>).\nMeanwhile, each branch refers to a specific commit.\nLet&rsquo;s look at a repo with three commits, one of them\ntagged, and with branch <b>master</b> checked out:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">HEAD (refers to\nbranch 'master') <br>\n| <br>\nv <br>\na---b---c branch 'master' (refers to commit 'c') <br>\n^ <br>\n| <br>\ntag 'v2.0' (refers to commit 'b')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When a commit\nis created in this state, the branch is updated to refer to\nthe new commit. Specifically, <i>git commit</i> creates a\nnew commit <b>d</b>, whose parent is commit <b>c</b>, and\nthen updates branch <b>master</b> to refer to new commit\n<b>d</b>. <b>HEAD</b> still refers to branch <b>master</b>\nand so indirectly now refers to commit <b>d</b>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ edit; git\nadd; git commit</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">HEAD (refers to\nbranch 'master') <br>\n| <br>\nv <br>\na---b---c---d branch 'master' (refers to commit 'd') <br>\n^ <br>\n| <br>\ntag 'v2.0' (refers to commit 'b')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is sometimes\nuseful to be able to checkout a commit that is not at the\ntip of any named branch, or even to create a new commit that\nis not referenced by a named branch. Let&rsquo;s look at\nwhat happens when we checkout commit <b>b</b> (here we show\ntwo ways this may be done):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git checkout\nv2.0 # or <br>\n$ git checkout master^^</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">HEAD (refers to\ncommit 'b') <br>\n| <br>\nv <br>\na---b---c---d branch 'master' (refers to commit 'd') <br>\n^ <br>\n| <br>\ntag 'v2.0' (refers to commit 'b')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Notice that\nregardless of which checkout command we use, <b>HEAD</b> now\nrefers directly to commit <b>b</b>. This is known as being\nin detached <b>HEAD</b> state. It means simply that\n<b>HEAD</b> refers to a specific commit, as opposed to\nreferring to a named branch. Let&rsquo;s see what happens\nwhen we create a commit:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ edit; git\nadd; git commit</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">HEAD (refers to\ncommit 'e') <br>\n| <br>\nv <br>\ne <br>\n/ <br>\na---b---c---d branch 'master' (refers to commit 'd') <br>\n^ <br>\n| <br>\ntag 'v2.0' (refers to commit 'b')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">There is now a\nnew commit <b>e</b>, but it is referenced only by\n<b>HEAD</b>. We can of course add yet another commit in this\nstate:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ edit; git\nadd; git commit</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">HEAD (refers to\ncommit 'f') <br>\n| <br>\nv <br>\ne---f <br>\n/ <br>\na---b---c---d branch 'master' (refers to commit 'd') <br>\n^ <br>\n| <br>\ntag 'v2.0' (refers to commit 'b')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In fact, we can\nperform all the normal Git operations. But, let&rsquo;s look\nat what happens when we then checkout <b>master</b>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git checkout\nmaster</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">HEAD (refers to\nbranch 'master') <br>\ne---f | <br>\n/ v <br>\na---b---c---d branch 'master' (refers to commit 'd') <br>\n^ <br>\n| <br>\ntag 'v2.0' (refers to commit 'b')</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is important\nto realize that at this point nothing refers to commit\n<b>f</b>. Eventually commit <b>f</b> (and by extension\ncommit <b>e</b>) will be deleted by the routine Git garbage\ncollection process, unless we create a reference before that\nhappens. If we have not yet moved away from commit <b>f</b>,\nany of these will create a reference to it:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git checkout\n-b foo <b>(1)</b> <br>\n$ git branch foo <b>(2)</b> <br>\n$ git tag foo <b>(3)</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>1.</b>\ncreates a new branch <b>foo</b>, which refers to commit\n<b>f</b>, and then updates <b>HEAD</b> to refer to branch\n<b>foo</b>. In other words, we&rsquo;ll no longer be in\ndetached <b>HEAD</b> state after this command. <b><br>\n2.</b> similarly creates a new branch <b>foo</b>, which\nrefers to commit <b>f</b>, but leaves <b>HEAD</b> detached.\n<b><br>\n3.</b> creates a new tag <b>foo</b>, which refers to commit\n<b>f</b>, leaving <b>HEAD</b> detached.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If we have\nmoved away from commit <b>f</b>, then we must first recover\nits object name (typically by using git reflog), and then we\ncan create a reference to it. For example, to see the last\ntwo commits to which <b>HEAD</b> referred, we can use either\nof these commands:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git reflog -2\nHEAD # or <br>\n$ git log -g -2 HEAD</p>\n\n<h2>ARGUMENT DISAMBIGUATION\n<a name=\"ARGUMENT DISAMBIGUATION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">When there is\nonly one argument given and it is not <b>--</b> (e.g. <b>git\ncheckout abc</b>), and when the argument is both a valid\n<b>&lt;tree-ish&gt;</b> (e.g. a branch <b>abc</b> exists)\nand a valid <b>&lt;pathspec&gt;</b> (e.g. a file or a\ndirectory whose name is &quot;abc&quot; exists), Git would\nusually ask you to disambiguate. Because checking out a\nbranch is so common an operation, however, <b>git checkout\nabc</b> takes &quot;abc&quot; as a <b>&lt;tree-ish&gt;</b>\nin such a situation. Use <b>git checkout --\n&lt;pathspec&gt;</b> if you want to checkout these paths out\nof the index.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">1. The\nfollowing sequence checks out the <b>master</b> branch,\nreverts the <b>Makefile</b> to two revisions back, deletes\n<b>hello.c</b> by mistake, and gets it back from the\nindex.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\nmaster <b>(1)</b> <br>\n$ git checkout master~2 Makefile <b>(2)</b> <br>\n$ rm -f hello.c <br>\n$ git checkout hello.c <b>(3)</b></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>1.</b>\nswitch branch <b><br>\n2.</b> take a file out of another commit <b><br>\n3.</b> restore <b>hello.c</b> from the index</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you want to\ncheck out <i>all</i> C source files out of the index, you\ncan say</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\n-- '*.c'</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note the quotes\naround <b>*.c</b>. The file <b>hello.c</b> will also be\nchecked out, even though it is no longer in the working\ntree, because the file globbing is used to match entries in\nthe index (not in the working tree by the shell).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">If you have an\nunfortunate branch that is named <b>hello.c</b>, this step\nwould be confused as an instruction to switch to that\nbranch. You should instead write:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\n-- hello.c</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">2. After\nworking in the wrong branch, switching to the correct branch\nwould be done using:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\nmytopic</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">However, your\n&quot;wrong&quot; branch and correct <b>mytopic</b> branch\nmay differ in files that you have modified locally, in which\ncase the above checkout would fail like this:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\nmytopic <br>\nerror: You have local changes to 'frotz'; not switching\nbranches.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You can give\nthe <b>-m</b> flag to the command, which would try a\nthree-way merge:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\n-m mytopic <br>\nAuto-merging frotz</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">After this\nthree-way merge, the local modifications are <i>not</i>\nregistered in your index file, so <b>git diff</b> would show\nyou what changes you made since the tip of the new\nbranch.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">3. When a merge\nconflict happens during switching branches with the\n<b>-m</b> option, you would see something like this:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ git checkout\n-m mytopic <br>\nAuto-merging frotz <br>\nERROR: Merge conflict in frotz <br>\nfatal: merge program failed</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">At this point,\n<b>git diff</b> shows the changes cleanly merged as in the\nprevious example, as well as the changes in the conflicted\nfiles. Edit and resolve the conflict and mark it resolved\nwith <b>git add</b> as usual:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">$ edit frotz\n<br>\n$ git add frotz</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/git-switch\">git-switch(1)</a>,\n<a href=\"https://man.page/1/git-restore\">git-restore(1)</a></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Part of the\n<a href=\"https://man.page/1/git\">git(1)</a> suite</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#DETACHED HEAD\">DETACHED HEAD</a>","<a href=\"#ARGUMENT DISAMBIGUATION\">ARGUMENT DISAMBIGUATION</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#GIT\">GIT</a>"]}