{"name":"git-rebase","body":"\n\n<h1 align=\"center\">GIT-REBASE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-rebase -\nReapply commits on top of another base tip</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nrebase</i> [-i | --interactive] [&lt;options&gt;] [--exec\n&lt;cmd&gt;] <br>\n[--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt;\n[&lt;branch&gt;]] <i><br>\ngit rebase</i> [-i | --interactive] [&lt;options&gt;]\n[--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;] <br>\n--root [&lt;branch&gt;] <i><br>\ngit rebase</i> (--continue | --skip | --abort | --quit |\n--edit-todo | --show-current-patch)</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n&lt;branch&gt; is specified, <i>git rebase</i> will perform\nan automatic <b>git switch &lt;branch&gt;</b> before doing\nanything else. Otherwise it remains on the current\nbranch.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If\n&lt;upstream&gt; is not specified, the upstream configured\nin branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge\noptions will be used (see <a href=\"https://man.page/1/git-config\">git-config(1)</a> for details)\nand the <b>--fork-point</b> option is assumed. If you are\ncurrently not on any branch or if the current branch does\nnot have a configured upstream, the rebase will abort.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">All changes\nmade by commits in the current branch but that are not in\n&lt;upstream&gt; are saved to a temporary area. This is the\nsame set of commits that would be shown by <b>git log\n&lt;upstream&gt;..HEAD</b>; or by <b>git log\n'fork_point'..HEAD</b>, if <b>--fork-point</b> is active\n(see the description on <b>--fork-point</b> below); or by\n<b>git log HEAD</b>, if the <b>--root</b> option is\nspecified.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The current\nbranch is reset to &lt;upstream&gt;, or &lt;newbase&gt; if\nthe --onto option was supplied. This has the exact same\neffect as <b>git reset --hard &lt;upstream&gt;</b> (or\n&lt;newbase&gt;). ORIG_HEAD is set to point at the tip of\nthe branch before the reset.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The commits\nthat were previously saved into the temporary area are then\nreapplied to the current branch, one by one, in order. Note\nthat any commits in HEAD which introduce the same textual\nchanges as a commit in HEAD..&lt;upstream&gt; are omitted\n(i.e., a patch already accepted upstream with a different\ncommit message or timestamp will be skipped).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">It is possible\nthat a merge failure will prevent this process from being\ncompletely automatic. You will have to resolve any such\nmerge failure and run <b>git rebase --continue</b>. Another\noption is to bypass the commit that caused the merge failure\nwith <b>git rebase --skip</b>. To check out the original\n&lt;branch&gt; and remove the .git/rebase-apply working\nfiles, use the command <b>git rebase --abort</b>\ninstead.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Assume the\nfollowing history exists and the current branch is\n&quot;topic&quot;:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A---B---C topic\n<br>\n/ <br>\nD---E---F---G master</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">From this\npoint, the result of either of the following commands:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git rebase\nmaster <br>\ngit rebase master topic</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">would be:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A'--B'--C'\ntopic <br>\n/ <br>\nD---E---F---G master</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>NOTE:</b>\nThe latter form is just a short-hand of <b>git checkout\ntopic</b> followed by <b>git rebase master</b>. When rebase\nexits <b>topic</b> will remain the checked-out branch.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the upstream\nbranch already contains a change you have made (e.g.,\nbecause you mailed a patch which was applied upstream), then\nthat commit will be skipped and warnings will be issued (if\nthe <b>merge</b> backend is used). For example, running\n<b>git rebase master</b> on the following history (in which\n<b>A'</b> and <b>A</b> introduce the same set of changes,\nbut have different committer information):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A---B---C topic\n<br>\n/ <br>\nD---E---A'---F master</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">will result\nin:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">B'---C' topic\n<br>\n/ <br>\nD---E---A'---F master</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Here is how you\nwould transplant a topic branch based on one branch to\nanother, to pretend that you forked the topic branch from\nthe latter branch, using <b>rebase --onto</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">First\nlet&rsquo;s assume your <i>topic</i> is based on branch\n<i>next</i>. For example, a feature developed in\n<i>topic</i> depends on some functionality which is found in\n<i>next</i>.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">o---o---o---o---o\nmaster <br>\n\\ <br>\no---o---o---o---o next <br>\n\\ <br>\no---o---o topic</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">We want to make\n<i>topic</i> forked from branch <i>master</i>; for example,\nbecause the functionality on which <i>topic</i> depends was\nmerged into the more stable <i>master</i> branch. We want\nour tree to look like this:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">o---o---o---o---o\nmaster <br>\n| \\ <br>\n| o'--o'--o' topic <br>\n\\ <br>\no---o---o---o---o next</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">We can get this\nusing the following command:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git rebase\n--onto master next topic</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another example\nof --onto option is to rebase part of a branch. If we have\nthe following situation:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">H---I---J\ntopicB <br>\n/ <br>\nE---F---G topicA <br>\n/ <br>\nA---B---C---D master</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then the\ncommand</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git rebase\n--onto master topicA topicB</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">would result\nin:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">H'--I'--J'\ntopicB <br>\n/ <br>\n| E---F---G topicA <br>\n|/ <br>\nA---B---C---D master</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is useful\nwhen topicB does not depend on topicA.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A range of\ncommits could also be removed with rebase. If we have the\nfollowing situation:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">E---F---G---H---I---J\ntopicA</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">then the\ncommand</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git rebase\n--onto topicA~5 topicA~3 topicA</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">would result in\nthe removal of commits F and G:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">E---H'---I'---J'\ntopicA</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is useful\nif F and G were flawed in some way, or should not be part of\ntopicA. Note that the argument to --onto and the\n&lt;upstream&gt; parameter can be any valid commit-ish.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In case of\nconflict, <i>git rebase</i> will stop at the first\nproblematic commit and leave conflict markers in the tree.\nYou can use <i>git diff</i> to locate the markers\n(&lt;&lt;&lt;&lt;&lt;&lt;) and make edits to resolve the\nconflict. For each file you edit, you need to tell Git that\nthe conflict has been resolved, typically this would be done\nwith</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git add\n&lt;filename&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After resolving\nthe conflict manually and updating the index with the\ndesired resolution, you can continue the rebasing process\nwith</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git rebase\n--continue</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Alternatively,\nyou can undo the <i>git rebase</i> with</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">git rebase\n--abort</p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--onto\n&lt;newbase&gt;</p>\n\n<p style=\"margin-left:17%;\">Starting point at which to\ncreate the new commits. If the --onto option is not\nspecified, the starting point is &lt;upstream&gt;. May be\nany valid commit, and not just an existing branch name.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">As a special\ncase, you may use &quot;A...B&quot; as a shortcut for the\nmerge base of A and B if there is exactly one merge base.\nYou can leave out at most one of A and B, in which case it\ndefaults to HEAD.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--keep-base</p>\n\n<p style=\"margin-left:17%;\">Set the starting point at which\nto create the new commits to the merge base of\n&lt;upstream&gt; &lt;branch&gt;. Running <i>git rebase\n--keep-base &lt;upstream&gt; &lt;branch&gt;</i> is\nequivalent to running <i>git rebase --onto\n&lt;upstream&gt;... &lt;upstream&gt;</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">This option is\nuseful in the case where one is developing a feature on top\nof an upstream branch. While the feature is being worked on,\nthe upstream branch may advance and it may not be the best\nidea to keep rebasing on top of the upstream but to keep the\nbase commit as-is.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Although both\nthis option and --fork-point find the merge base between\n&lt;upstream&gt; and &lt;branch&gt;, this option uses the\nmerge base as the <i>starting point</i> on which new commits\nwill be created, whereas --fork-point uses the merge base to\ndetermine the <i>set of commits</i> which will be\nrebased.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;upstream&gt;</p>\n\n<p style=\"margin-left:17%;\">Upstream branch to compare\nagainst. May be any valid commit, not just an existing\nbranch name. Defaults to the configured upstream for the\ncurrent branch.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;branch&gt;</p>\n\n<p style=\"margin-left:17%;\">Working branch; defaults to\nHEAD.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--continue</p>\n\n<p style=\"margin-left:17%;\">Restart the rebasing process\nafter having resolved a merge conflict.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--abort</p>\n\n<p style=\"margin-left:17%;\">Abort the rebase operation and\nreset HEAD to the original branch. If &lt;branch&gt; was\nprovided when the rebase operation was started, then HEAD\nwill be reset to &lt;branch&gt;. Otherwise HEAD will be\nreset to where it was when the rebase operation was\nstarted.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--quit</p>\n\n<p style=\"margin-left:17%;\">Abort the rebase operation but\nHEAD is not reset back to the original branch. The index and\nworking tree are also left unchanged as a result. If a\ntemporary stash entry was created using --autostash, it will\nbe saved to the stash list.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--apply</p>\n\n<p style=\"margin-left:17%;\">Use applying strategies to\nrebase (calling <b>git-am</b> internally). This option may\nbecome a no-op in the future once the merge backend handles\neverything the apply one does.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--empty={drop,keep,ask}</p>\n\n<p style=\"margin-left:17%;\">How to handle commits that are\nnot empty to start and are not clean cherry-picks of any\nupstream commit, but which become empty after rebasing\n(because they contain a subset of already upstream changes).\nWith drop (the default), commits that become empty are\ndropped. With keep, such commits are kept. With ask (implied\nby --interactive), the rebase will halt when an empty commit\nis applied allowing you to choose whether to drop it, edit\nfiles more, or just commit the empty changes. Other options,\nlike --exec, will use the default of drop unless\n-i/--interactive is explicitly specified.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\ncommits which start empty are kept (unless --no-keep-empty\nis specified), and commits which are clean cherry-picks (as\ndetermined by <b>git log --cherry-mark ...</b>) are detected\nand dropped as a preliminary step (unless\n--reapply-cherry-picks is passed).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--no-keep-empty,\n--keep-empty</p>\n\n<p style=\"margin-left:17%;\">Do not keep commits that start\nempty before the rebase (i.e. that do not change anything\nfrom its parent) in the result. The default is to keep\ncommits which start empty, since creating such commits\nrequires passing the --allow-empty override flag to <b>git\ncommit</b>, signifying that a user is very intentionally\ncreating such a commit and thus wants to keep it.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Usage of this\nflag will probably be rare, since you can get rid of commits\nthat start empty by just firing up an interactive rebase and\nremoving the lines corresponding to the commits you\ndon&rsquo;t want. This flag exists as a convenient shortcut,\nsuch as for cases where external tools generate many empty\ncommits and you want them all removed.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">For commits\nwhich do not start empty but become empty after rebasing,\nsee the --empty flag.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--reapply-cherry-picks,\n--no-reapply-cherry-picks</p>\n\n<p style=\"margin-left:17%;\">Reapply all clean cherry-picks\nof any upstream commit instead of preemptively dropping\nthem. (If these commits then become empty after rebasing,\nbecause they contain a subset of already upstream changes,\nthe behavior towards them is controlled by the\n<b>--empty</b> flag.)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">By default (or\nif <b>--no-reapply-cherry-picks</b> is given), these commits\nwill be automatically dropped. Because this necessitates\nreading all upstream commits, this can be expensive in repos\nwith a large number of upstream commits that need to be\nread. When using the <b>merge</b> backend, warnings will be\nissued for each dropped commit (unless <b>--quiet</b> is\ngiven). Advice will also be issued unless\n<b>advice.skippedCherryPicks</b> is set to false (see\n<a href=\"https://man.page/1/git-config\">git-config(1)</a>).</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b>--reapply-cherry-picks</b>\nallows rebase to forgo reading all upstream commits,\npotentially improving performance.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--allow-empty-message</p>\n\n<p style=\"margin-left:17%;\">No-op. Rebasing commits with an\nempty message used to fail and this option would override\nthat behavior, allowing commits with empty messages to be\nrebased. Now commits with an empty message do not cause\nrebasing to halt.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--skip</p>\n\n<p style=\"margin-left:17%;\">Restart the rebasing process by\nskipping the current patch.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--edit-todo</p>\n\n<p style=\"margin-left:17%;\">Edit the todo list during an\ninteractive rebase.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--show-current-patch</p>\n\n<p style=\"margin-left:17%;\">Show the current patch in an\ninteractive rebase or when rebase is stopped because of\nconflicts. This is the equivalent of <b>git show\nREBASE_HEAD</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-m, --merge</p>\n\n<p style=\"margin-left:17%;\">Using merging strategies to\nrebase (default).</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that a\nrebase merge works by replaying each commit from the working\nbranch on top of the &lt;upstream&gt; branch. Because of\nthis, when a merge conflict happens, the side reported as\n<i>ours</i> is the so-far rebased series, starting with\n&lt;upstream&gt;, and <i>theirs</i> is the working branch.\nIn other words, the sides are swapped.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-s\n&lt;strategy&gt;, --strategy=&lt;strategy&gt;</p>\n\n<p style=\"margin-left:17%;\">Use the given merge strategy,\ninstead of the default <b>ort</b>. This implies\n<b>--merge</b>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Because <i>git\nrebase</i> replays each commit from the working branch on\ntop of the &lt;upstream&gt; branch using the given strategy,\nusing the <i>ours</i> strategy simply empties all patches\nfrom the &lt;branch&gt;, which makes little sense.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-X\n&lt;strategy-option&gt;,\n--strategy-option=&lt;strategy-option&gt;</p>\n\n<p style=\"margin-left:17%;\">Pass the\n&lt;strategy-option&gt; through to the merge strategy. This\nimplies <b>--merge</b> and, if no strategy has been\nspecified, <b>-s ort</b>. Note the reversal of <i>ours</i>\nand <i>theirs</i> as noted above for the <b>-m</b>\noption.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--rerere-autoupdate,\n--no-rerere-autoupdate</p>\n\n<p style=\"margin-left:17%;\">Allow the rerere mechanism to\nupdate the index with the result of auto-conflict resolution\nif possible.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-S[&lt;keyid&gt;],\n--gpg-sign[=&lt;keyid&gt;], --no-gpg-sign</p>\n\n<p style=\"margin-left:17%;\">GPG-sign commits. The\n<b>keyid</b> argument is optional and defaults to the\ncommitter identity; if specified, it must be stuck to the\noption without a space. <b>--no-gpg-sign</b> is useful to\ncountermand both <b>commit.gpgSign</b> configuration\nvariable, and earlier <b>--gpg-sign</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-q, --quiet</p>\n\n<p style=\"margin-left:17%;\">Be quiet. Implies\n--no-stat.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-v,\n--verbose</p>\n\n<p style=\"margin-left:17%;\">Be verbose. Implies --stat.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--stat</p>\n\n<p style=\"margin-left:17%;\">Show a diffstat of what changed\nupstream since the last rebase. The diffstat is also\ncontrolled by the configuration option rebase.stat.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-n,\n--no-stat</p>\n\n<p style=\"margin-left:17%;\">Do not show a diffstat as part\nof the rebase process.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--no-verify</p>\n\n<p style=\"margin-left:17%;\">This option bypasses the\npre-rebase hook. See also <a href=\"https://man.page/5/githooks\">githooks(5)</a>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--verify</p>\n\n<p style=\"margin-left:17%;\">Allows the pre-rebase hook to\nrun, which is the default. This option can be used to\noverride --no-verify. See also <a href=\"https://man.page/5/githooks\">githooks(5)</a>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-C&lt;n&gt;</p>\n\n<p style=\"margin-left:17%;\">Ensure at least &lt;n&gt; lines\nof surrounding context match before and after each change.\nWhen fewer lines of surrounding context exist they all must\nmatch. By default no context is ever ignored. Implies\n--apply.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">See also\nINCOMPATIBLE OPTIONS below.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--no-ff,\n--force-rebase, -f</p>\n\n<p style=\"margin-left:17%;\">Individually replay all rebased\ncommits instead of fast-forwarding over the unchanged ones.\nThis ensures that the entire history of the rebased branch\nis composed of new commits.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">You may find\nthis helpful after reverting a topic branch merge, as this\noption recreates the topic branch with fresh commits so it\ncan be remerged successfully without needing to &quot;revert\nthe reversion&quot; (see the\n<b><font color=\"#0000FF\">revert-a-faulty-merge\nHow-To</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">for details).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--fork-point,\n--no-fork-point</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Use\nreflog to find a better common ancestor between\n&lt;upstream&gt; and &lt;branch&gt; when calculating which\ncommits have been introduced by &lt;branch&gt;.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">When\n--fork-point is active, <i>fork_point</i> will be used\ninstead of &lt;upstream&gt; to calculate the set of commits\nto rebase, where <i>fork_point</i> is the result of <b>git\nmerge-base --fork-point &lt;upstream&gt; &lt;branch&gt;</b>\ncommand (see <a href=\"https://man.page/1/git-merge-base\">git-merge-base(1)</a>). If <i>fork_point</i>\nends up being empty, the &lt;upstream&gt; will be used as a\nfallback.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\n&lt;upstream&gt; is given on the command line, then the\ndefault is <b>--no-fork-point</b>, otherwise the default is\n<b>--fork-point</b>. See also <b>rebase.forkpoint</b> in\n<a href=\"https://man.page/1/git-config\">git-config(1)</a>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\nyour branch was based on &lt;upstream&gt; but\n&lt;upstream&gt; was rewound and your branch contains\ncommits which were dropped, this option can be used with\n<b>--keep-base</b> in order to drop those commits from your\nbranch.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--ignore-whitespace</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Ignore\nwhitespace differences when trying to reconcile differences.\nCurrently, each backend implements an approximation of this\nbehavior:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">apply\nbackend: When applying a patch, ignore changes in whitespace\nin context lines. Unfortunately, this means that if the\n&quot;old&quot; lines being replaced by the patch differ\nonly in whitespace from the existing file, you will get a\nmerge conflict instead of a successful patch\napplication.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">merge\nbackend: Treat lines with only whitespace changes as\nunchanged when merging. Unfortunately, this means that any\npatch hunks that were intended to modify whitespace and\nnothing else will be dropped, even if the other side had no\nchanges that conflicted.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--whitespace=&lt;option&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This flag\nis passed to the <i>git apply</i> program (see\n<a href=\"https://man.page/1/git-apply\">git-apply(1)</a>) that applies the patch. Implies\n--apply.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--committer-date-is-author-date</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Instead\nof using the current time as the committer date, use the\nauthor date of the commit being rebased as the committer\ndate. This option implies <b>--force-rebase</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--ignore-date,\n--reset-author-date</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Instead\nof using the author date of the original commit, use the\ncurrent time as the author date of the rebased commit. This\noption implies <b>--force-rebase</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--signoff</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Add a\n<b>Signed-off-by</b> trailer to all the rebased commits.\nNote that if <b>--interactive</b> is given then only commits\nmarked to be picked, edited or reworded will have the\ntrailer added.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">-i,\n--interactive</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Make a\nlist of the commits which are about to be rebased. Let the\nuser edit that list before rebasing. This mode can also be\nused to split commits (see SPLITTING COMMITS\nbelow).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">The\ncommit list format can be changed by setting the\nconfiguration option rebase.instructionFormat. A customized\ninstruction format will automatically have the long commit\nhash prepended to the format.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">-r,\n--rebase-merges[=(rebase-cousins|no-rebase-cousins)]</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">By\ndefault, a rebase will simply drop merge commits from the\ntodo list, and put the rebased commits into a single, linear\nbranch. With <b>--rebase-merges</b>, the rebase will instead\ntry to preserve the branching structure within the commits\nthat are to be rebased, by recreating the merge commits. Any\nresolved merge conflicts or manual amendments in these merge\ncommits will have to be resolved/re-applied\nmanually.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">By\ndefault, or when <b>no-rebase-cousins</b> was specified,\ncommits which do not have <b>&lt;upstream&gt;</b> as direct\nancestor will keep their original branch point, i.e. commits\nthat would be excluded by <a href=\"https://man.page/1/git-log\">git-log(1)</a>'s\n<b>--ancestry-path</b> option will keep their original\nancestry by default. If the <b>rebase-cousins</b> mode is\nturned on, such commits are instead rebased onto\n<b>&lt;upstream&gt;</b> (or <b>&lt;onto&gt;</b>, if\nspecified).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">It\nis currently only possible to recreate the merge commits\nusing the <b>ort</b> merge strategy; different merge\nstrategies can be used only via explicit <b>exec git merge\n-s &lt;strategy&gt; [...]</b> commands.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso REBASING MERGES and INCOMPATIBLE OPTIONS\nbelow.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">-x\n&lt;cmd&gt;, --exec &lt;cmd&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Append\n&quot;exec &lt;cmd&gt;&quot; after each line creating a\ncommit in the final history. &lt;cmd&gt; will be interpreted\nas one or more shell commands. Any command that fails will\ninterrupt the rebase, with exit code 1.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">You\nmay execute several commands by either using one instance of\n<b>--exec</b> with several commands:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">git\nrebase -i --exec &quot;cmd1 &amp;&amp; cmd2 &amp;&amp;\n...&quot;</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">or\nby giving more than one <b>--exec</b>:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">git\nrebase -i --exec &quot;cmd1&quot; --exec &quot;cmd2&quot;\n--exec ...</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\n<b>--autosquash</b> is used, &quot;exec&quot; lines will not\nbe appended for the intermediate commits, and will only\nappear at the end of each squash/fixup series.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">This\nuses the <b>--interactive</b> machinery internally, but it\ncan be run without an explicit\n<b>--interactive</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--root</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Rebase\nall commits reachable from &lt;branch&gt;, instead of\nlimiting them with an &lt;upstream&gt;. This allows you to\nrebase the root commit(s) on a branch. When used with\n--onto, it will skip changes already contained in\n&lt;newbase&gt; (instead of &lt;upstream&gt;) whereas\nwithout --onto it will operate on every change.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--autosquash,\n--no-autosquash</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">When the\ncommit log message begins with &quot;squash! ...&quot; or\n&quot;fixup! ...&quot; or &quot;amend! ...&quot;, and there\nis already a commit in the todo list that matches the same\n<b>...</b>, automatically modify the todo list of <b>rebase\n-i</b>, so that the commit marked for squashing comes right\nafter the commit to be modified, and change the action of\nthe moved commit from <b>pick</b> to <b>squash</b> or\n<b>fixup</b> or <b>fixup -C</b> respectively. A commit\nmatches the <b>...</b> if the commit subject matches, or if\nthe <b>...</b> refers to the commit&rsquo;s hash. As a\nfall-back, partial matches of the commit subject work, too.\nThe recommended way to create fixup/amend/squash commits is\nby using the <b>--fixup</b>, <b>--fixup=amend:</b> or\n<b>--fixup=reword:</b> and <b>--squash</b> options\nrespectively of <a href=\"https://man.page/1/git-commit\">git-commit(1)</a>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\nthe <b>--autosquash</b> option is enabled by default using\nthe configuration variable <b>rebase.autoSquash</b>, this\noption can be used to override and disable this\nsetting.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">See\nalso INCOMPATIBLE OPTIONS below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--autostash,\n--no-autostash</font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Automatically\ncreate a temporary stash entry before the operation begins,\nand apply it after the operation ends. This means that you\ncan run rebase on a dirty worktree. However, use with care:\nthe final stash application after a successful rebase might\nresult in non-trivial conflicts.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--reschedule-failed-exec,\n--no-reschedule-failed-exec</font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Automatically\nreschedule <b>exec</b> commands that failed. This only makes\nsense in interactive mode (or when an <b>--exec</b> option\nwas provided).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Even\nthough this option applies once a rebase is started,\nit&rsquo;s set for the whole rebase at the start based on\neither the <b>rebase.rescheduleFailedExec</b> configuration\n(see <a href=\"https://man.page/1/git-config\">git-config(1)</a> or &quot;CONFIGURATION&quot;\nbelow) or whether this option is provided. Otherwise an\nexplicit <b>--no-reschedule-failed-exec</b> at the start\nwould be overridden by the presence of\n<b>rebase.rescheduleFailedExec=true</b>\nconfiguration.</font></p>\n\n<h2>INCOMPATIBLE OPTIONS\n<a name=\"INCOMPATIBLE OPTIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nfollowing options:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--apply</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--whitespace</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n-C</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">are\nincompatible with the following options:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--merge</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--strategy</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--strategy-option</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--allow-empty-message</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--[no-]autosquash</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--rebase-merges</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--interactive</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--exec</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--no-keep-empty</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--empty=</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--reapply-cherry-picks</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--edit-todo</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--root when used in combination with --onto</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">In\naddition, the following pairs of options are\nincompatible:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--keep-base and --onto</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--keep-base and --root</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\n--fork-point and --root</font></p>\n\n<h2>BEHAVIORAL DIFFERENCES\n<a name=\"BEHAVIORAL DIFFERENCES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">git\nrebase has two primary backends: apply and merge. (The apply\nbackend used to be known as the <i>am</i> backend, but the\nname led to confusion as it looks like a verb instead of a\nnoun. Also, the merge backend used to be known as the\ninteractive backend, but it is now used for non-interactive\ncases as well. Both were renamed based on lower-level\nfunctionality that underpinned each.) There are some subtle\ndifferences in how these two backends behave:</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Empty\ncommits</b> <br>\nThe apply backend unfortunately drops intentionally empty\ncommits, i.e. commits that started empty, though these are\nrare in practice. It also drops commits that become empty\nand has no option for controlling this behavior.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nmerge backend keeps intentionally empty commits by default\n(though with -i they are marked as empty in the todo list\neditor, or they can be dropped automatically with\n--no-keep-empty).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Similar\nto the apply backend, by default the merge backend drops\ncommits that become empty unless -i/--interactive is\nspecified (in which case it stops and asks the user what to\ndo). The merge backend also has an --empty={drop,keep,ask}\noption for changing the behavior of handling commits that\nbecome empty.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Directory\nrename detection</b> <br>\nDue to the lack of accurate tree information (arising from\nconstructing fake ancestors with the limited information\navailable in patches), directory rename detection is\ndisabled in the apply backend. Disabled directory rename\ndetection means that if one side of history renames a\ndirectory and the other adds new files to the old directory,\nthen the new files will be left behind in the old directory\nwithout any warning at the time of rebasing that you may\nwant to move these files into the new directory.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Directory\nrename detection works with the merge backend to provide you\nwarnings in such cases.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Context</b>\n<br>\nThe apply backend works by creating a sequence of patches\n(by calling <b>format-patch</b> internally), and then\napplying the patches in sequence (calling <b>am</b>\ninternally). Patches are composed of multiple hunks, each\nwith line numbers, a context region, and the actual changes.\nThe line numbers have to be taken with some fuzz, since the\nother side will likely have inserted or deleted lines\nearlier in the file. The context region is meant to help\nfind how to adjust the line numbers in order to apply the\nchanges to the right lines. However, if multiple areas of\nthe code have the same surrounding lines of context, the\nwrong one can be picked. There are real-world cases where\nthis has caused commits to be reapplied incorrectly with no\nconflicts reported. Setting diff.context to a larger value\nmay prevent such types of problems, but increases the chance\nof spurious conflicts (since it will require more lines of\nmatching context to apply).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nmerge backend works with a full copy of each relevant file,\ninsulating it from these types of problems.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Labelling\nof conflicts markers</b> <br>\nWhen there are content conflicts, the merge machinery tries\nto annotate each side&rsquo;s conflict markers with the\ncommits where the content came from. Since the apply backend\ndrops the original information about the rebased commits and\ntheir parents (and instead generates new fake commits based\noff limited information in the generated patches), those\ncommits cannot be identified; instead it has to fall back to\na commit summary. Also, when merge.conflictStyle is set to\ndiff3, the apply backend will use &quot;constructed merge\nbase&quot; to label the content from the merge base, and\nthus provide no information about the merge base commit\nwhatsoever.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nmerge backend works with the full commits on both sides of\nhistory and thus has no such limitations.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Hooks</b>\n<br>\nThe apply backend has not traditionally called the\npost-commit hook, while the merge backend has. Both have\ncalled the post-checkout hook, though the merge backend has\nsquelched its output. Further, both backends only call the\npost-checkout hook with the starting point commit of the\nrebase, not the intermediate commits nor the final commit.\nIn each case, the calling of these hooks was by accident of\nimplementation rather than by design (both backends were\noriginally implemented as shell scripts and happened to\ninvoke other commands like <i>git checkout</i> or <i>git\ncommit</i> that would call the hooks). Both backends should\nhave the same behavior, though it is not entirely clear\nwhich, if any, is correct. We will likely make rebase stop\ncalling either of these hooks in the future.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Interruptability</b>\n<br>\nThe apply backend has safety problems with an ill-timed\ninterrupt; if the user presses Ctrl-C at the wrong time to\ntry to abort the rebase, the rebase can enter a state where\nit cannot be aborted with a subsequent <b>git rebase\n--abort</b>. The merge backend does not appear to suffer\nfrom the same shortcoming. (See</font>\n<b><font color=\"#0000FF\">https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/</font></b>\n<font color=\"#000000\">for details.)</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Commit\nRewording</b> <br>\nWhen a conflict occurs while rebasing, rebase stops and asks\nthe user to resolve. Since the user may need to make notable\nchanges while resolving conflicts, after conflicts are\nresolved and the user has run <b>git rebase --continue</b>,\nthe rebase should open an editor and ask the user to update\nthe commit message. The merge backend does this, while the\napply backend blindly applies the original commit\nmessage.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Miscellaneous\ndifferences</b> <br>\nThere are a few more behavioral differences that most folks\nwould probably consider inconsequential but which are\nmentioned for completeness:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nReflog: The two backends will use different wording when\ndescribing the changes made in the reflog, though both will\nmake use of the word &quot;rebase&quot;.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nProgress, informational, and error messages: The two\nbackends provide slightly different progress and\ninformational messages. Also, the apply backend writes error\nmessages (such as &quot;Your files would be\noverwritten...&quot;) to stdout, while the merge backend\nwrites them to stderr.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nState directories: The two backends keep their state in\ndifferent directories under .git/</font></p>\n\n<h2>MERGE STRATEGIES\n<a name=\"MERGE STRATEGIES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nmerge mechanism (<b>git merge</b> and <b>git pull</b>\ncommands) allows the backend <i>merge strategies</i> to be\nchosen with <b>-s</b> option. Some strategies can also take\ntheir own options, which can be passed by giving\n<b>-X&lt;option&gt;</b> arguments to <b>git merge</b> and/or\n<b>git pull</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">ort</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nthe default merge strategy when pulling or merging one\nbranch. This strategy can only resolve two heads using a\n3-way merge algorithm. When there is more than one common\nancestor that can be used for 3-way merge, it creates a\nmerged tree of the common ancestors and uses that as the\nreference tree for the 3-way merge. This has been reported\nto result in fewer merge conflicts without causing mismerges\nby tests done on actual merge commits taken from Linux 2.6\nkernel development history. Additionally this strategy can\ndetect and handle merges involving renames. It does not make\nuse of detected copies. The name for this algorithm is an\nacronym (&quot;Ostensibly Recursive&rsquo;s Twin&quot;) and\ncame from the fact that it was written as a replacement for\nthe previous default algorithm, <b>recursive</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">The\n<i>ort</i> strategy can take the following\noptions:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">ours</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">This\noption forces conflicting hunks to be auto-resolved cleanly\nby favoring <i>our</i> version. Changes from the other tree\nthat do not conflict with our side are reflected in the\nmerge result. For a binary file, the entire contents are\ntaken from our side.</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">This\nshould not be confused with the <i>ours</i> merge strategy,\nwhich does not even look at what the other tree contains at\nall. It discards everything the other tree did, declaring\n<i>our</i> history contains all that happened in\nit.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">theirs</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">This is\nthe opposite of <i>ours</i>; note that, unlike <i>ours</i>,\nthere is no <i>theirs</i> merge strategy to confuse this\nmerge option with.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">ignore-space-change,\nignore-all-space, ignore-space-at-eol,\nignore-cr-at-eol</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">Treats\nlines with the indicated type of whitespace change as\nunchanged for the sake of a three-way merge. Whitespace\nchanges mixed with other changes to a line are not ignored.\nSee also <a href=\"https://man.page/1/git-diff\">git-diff(1)</a> <b>-b</b>, <b>-w</b>,\n<b>--ignore-space-at-eol</b>, and\n<b>--ignore-cr-at-eol</b>.</font></p>\n\n\n<p style=\"margin-left:29%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf <i>their</i> version only introduces whitespace changes\nto a line, <i>our</i> version is used;</font></p>\n\n\n<p style=\"margin-left:29%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf <i>our</i> version introduces whitespace changes but\n<i>their</i> version includes a substantial change,\n<i>their</i> version is used;</font></p>\n\n\n<p style=\"margin-left:29%; margin-top: 1em\"><font color=\"#000000\">&bull;\nOtherwise, the merge proceeds in the usual way.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">renormalize</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">This runs\na virtual check-out and check-in of all three stages of a\nfile when resolving a three-way merge. This option is meant\nto be used when merging branches with different clean\nfilters or end-of-line normalization rules. See\n&quot;Merging branches with differing checkin/checkout\nattributes&quot; in <a href=\"https://man.page/5/gitattributes\">gitattributes(5)</a> for\ndetails.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">no-renormalize</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">Disables\nthe <b>renormalize</b> option. This overrides the\n<b>merge.renormalize</b> configuration variable.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">find-renames[=&lt;n&gt;]</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">Turn on\nrename detection, optionally setting the similarity\nthreshold. This is the default. This overrides the\n<i>merge.renames</i> configuration variable. See also\n<a href=\"https://man.page/1/git-diff\">git-diff(1)</a> <b>--find-renames</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">rename-threshold=&lt;n&gt;</font></p>\n\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">Deprecated\nsynonym for <b>find-renames=&lt;n&gt;</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">subtree[=&lt;path&gt;]</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">This\noption is a more advanced form of <i>subtree</i> strategy,\nwhere the strategy makes a guess on how two trees must be\nshifted to match with each other when merging. Instead, the\nspecified path is prefixed (or stripped from the beginning)\nto make the shape of two trees to match.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">recursive</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This can\nonly resolve two heads using a 3-way merge algorithm. When\nthere is more than one common ancestor that can be used for\n3-way merge, it creates a merged tree of the common\nancestors and uses that as the reference tree for the 3-way\nmerge. This has been reported to result in fewer merge\nconflicts without causing mismerges by tests done on actual\nmerge commits taken from Linux 2.6 kernel development\nhistory. Additionally this can detect and handle merges\ninvolving renames. It does not make use of detected copies.\nThis was the default strategy for resolving two heads from\nGit v0.99.9k until v2.33.0.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">The\n<i>recursive</i> strategy takes the same options as\n<i>ort</i>. However, there are three additional options that\n<i>ort</i> ignores (not documented above) that are\npotentially useful with the <i>recursive</i>\nstrategy:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">patience</font></p>\n\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">Deprecated\nsynonym for <b>diff-algorithm=patience</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">diff-algorithm=[patience|minimal|histogram|myers]</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">Use a\ndifferent diff algorithm while merging, which can help avoid\nmismerges that occur due to unimportant matching lines (such\nas braces from distinct functions). See also\n<a href=\"https://man.page/1/git-diff\">git-diff(1)</a> <b>--diff-algorithm</b>. Note that\n<b>ort</b> specifically uses\n<b>diff-algorithm=histogram</b>, while <b>recursive</b>\ndefaults to the <b>diff.algorithm</b> config\nsetting.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">no-renames</font></p>\n\n<p style=\"margin-left:23%;\"><font color=\"#000000\">Turn off\nrename detection. This overrides the <b>merge.renames</b>\nconfiguration variable. See also <a href=\"https://man.page/1/git-diff\">git-diff(1)</a>\n<b>--no-renames</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">resolve</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This can\nonly resolve two heads (i.e. the current branch and another\nbranch you pulled from) using a 3-way merge algorithm. It\ntries to carefully detect criss-cross merge ambiguities. It\ndoes not handle renames.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">octopus</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\nresolves cases with more than two heads, but refuses to do a\ncomplex merge that needs manual resolution. It is primarily\nmeant to be used for bundling topic branch heads together.\nThis is the default merge strategy when pulling or merging\nmore than one branch.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">ours</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\nresolves any number of heads, but the resulting tree of the\nmerge is always that of the current branch head, effectively\nignoring all changes from all other branches. It is meant to\nbe used to supersede old development history of side\nbranches. Note that this is different from the -Xours option\nto the <i>recursive</i> merge strategy.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">subtree</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is a\nmodified <b>ort</b> strategy. When merging trees A and B, if\nB corresponds to a subtree of A, B is first adjusted to\nmatch the tree structure of A, instead of reading the trees\nat the same level. This adjustment is also done to the\ncommon ancestor tree.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">With\nthe strategies that use 3-way merge (including the default,\n<i>ort</i>), if a change is made on both branches, but later\nreverted on one of the branches, that change will be present\nin the merged result; some people find this behavior\nconfusing. It occurs because only the heads and the merge\nbase are considered when performing a merge, not the\nindividual commits. The merge algorithm therefore considers\nthe reverted change as no change at all, and substitutes the\nchanged version instead.</font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">You\nshould understand the implications of using <i>git\nrebase</i> on a repository that you share. See also\nRECOVERING FROM UPSTREAM REBASE below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">When\nthe git-rebase command is run, it will first execute a\n&quot;pre-rebase&quot; hook if one exists. You can use this\nhook to do sanity checks and reject the rebase if it\nisn&rsquo;t appropriate. Please see the template pre-rebase\nhook script for an example.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Upon\ncompletion, &lt;branch&gt; will be the current\nbranch.</font></p>\n\n<h2>INTERACTIVE MODE\n<a name=\"INTERACTIVE MODE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Rebasing\ninteractively means that you have a chance to edit the\ncommits which are rebased. You can reorder the commits, and\nyou can remove them (weeding out bad or otherwise unwanted\npatches).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\ninteractive mode is meant for this type of\nworkflow:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">1.\nhave a wonderful idea</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">2.\nhack on the code</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">3.\nprepare a series for submission</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">4.\nsubmit</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">where\npoint 2. consists of several instances of</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">a)\nregular use</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">1.\nfinish something worthy of a commit</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">2.\ncommit</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">b)\nindependent fixup</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">1.\nrealize that something does not work</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">2.\nfix that</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">3.\ncommit it</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Sometimes\nthe thing fixed in b.2. cannot be amended to the not-quite\nperfect commit it fixes, because that commit is buried\ndeeply in a patch series. That is exactly what interactive\nrebase is for: use it after plenty of &quot;a&quot;s and\n&quot;b&quot;s, by rearranging and editing commits, and\nsquashing multiple commits into one.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Start\nit with the last commit you want to retain as-is:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nrebase -i &lt;after-this-commit&gt;</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">An\neditor will be fired up with all the commits in your current\nbranch (ignoring merge commits), which come after the given\ncommit. You can reorder the commits in this list to your\nheart&rsquo;s content, and you can remove them. The list\nlooks more or less like this:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">pick\ndeadbee The oneline of this commit <br>\npick fa1afe1 The oneline of the next commit <br>\n...</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\noneline descriptions are purely for your pleasure; <i>git\nrebase</i> will not look at them but at the commit names\n(&quot;deadbee&quot; and &quot;fa1afe1&quot; in this\nexample), so do not delete or edit the names.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">By\nreplacing the command &quot;pick&quot; with the command\n&quot;edit&quot;, you can tell <i>git rebase</i> to stop\nafter applying that commit, so that you can edit the files\nand/or the commit message, amend the commit, and continue\nrebasing.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\ninterrupt the rebase (just like an &quot;edit&quot; command\nwould do, but without cherry-picking any commit first), use\nthe &quot;break&quot; command.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nyou just want to edit the commit message for a commit,\nreplace the command &quot;pick&quot; with the command\n&quot;reword&quot;.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\ndrop a commit, replace the command &quot;pick&quot; with\n&quot;drop&quot;, or just delete the matching\nline.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nyou want to fold two or more commits into one, replace the\ncommand &quot;pick&quot; for the second and subsequent\ncommits with &quot;squash&quot; or &quot;fixup&quot;. If the\ncommits had different authors, the folded commit will be\nattributed to the author of the first commit. The suggested\ncommit message for the folded commit is the concatenation of\nthe first commit&rsquo;s message with those identified by\n&quot;squash&quot; commands, omitting the messages of\ncommits identified by &quot;fixup&quot; commands, unless\n&quot;fixup -c&quot; is used. In that case the suggested\ncommit message is only the message of the &quot;fixup\n-c&quot; commit, and an editor is opened allowing you to\nedit the message. The contents (patch) of the &quot;fixup\n-c&quot; commit are still incorporated into the folded\ncommit. If there is more than one &quot;fixup -c&quot;\ncommit, the message from the final one is used. You can also\nuse &quot;fixup -C&quot; to get the same behavior as\n&quot;fixup -c&quot; except without opening an\neditor.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>git\nrebase</i> will stop when &quot;pick&quot; has been replaced\nwith &quot;edit&quot; or when a command fails due to merge\nerrors. When you are done editing and/or resolving conflicts\nyou can continue with <b>git rebase\n--continue</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">For\nexample, if you want to reorder the last 5 commits, such\nthat what was HEAD~4 becomes the new HEAD. To achieve that,\nyou would call <i>git rebase</i> like this:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngit rebase -i HEAD~5</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">And\nmove the first patch to the end of the list.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">You\nmight want to recreate merge commits, e.g. if you have a\nhistory like this:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">X\n<br>\n\\ <br>\nA---M---B <br>\n/ <br>\n---o---O---P---Q</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Suppose\nyou want to rebase the side branch starting at &quot;A&quot;\nto &quot;Q&quot;. Make sure that the current HEAD is\n&quot;B&quot;, and call</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngit rebase -i -r --onto Q O</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Reordering\nand editing commits usually creates untested intermediate\nsteps. You may want to check that your history editing did\nnot break anything by running a test, or at least\nrecompiling at intermediate points in history by using the\n&quot;exec&quot; command (shortcut &quot;x&quot;). You may\ndo so by creating a todo list like this one:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">pick\ndeadbee Implement feature XXX <br>\nfixup f1a5c00 Fix to feature XXX <br>\nexec make <br>\npick c0ffeee The oneline of the next commit <br>\nedit deadbab The oneline of the commit after <br>\nexec cd subdir; make test <br>\n...</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\ninteractive rebase will stop when a command fails (i.e.\nexits with non-0 status) to give you an opportunity to fix\nthe problem. You can continue with <b>git rebase\n--continue</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\n&quot;exec&quot; command launches the command in a shell\n(the one specified in <b>$SHELL</b>, or the default shell if\n<b>$SHELL</b> is not set), so you can use shell features\n(like &quot;cd&quot;, &quot;&gt;&quot;, &quot;;&quot; ...).\nThe command is run from the root of the working\ntree.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngit rebase -i --exec &quot;make test&quot;</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\ncommand lets you check that intermediate commits are\ncompilable. The todo list becomes like that:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">pick\n5928aea one <br>\nexec make test <br>\npick 04d0fda two <br>\nexec make test <br>\npick ba46169 three <br>\nexec make test <br>\npick f4593f9 four <br>\nexec make test</font></p>\n\n<h2>SPLITTING COMMITS\n<a name=\"SPLITTING COMMITS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">In\ninteractive mode, you can mark commits with the action\n&quot;edit&quot;. However, this does not necessarily mean\nthat <i>git rebase</i> expects the result of this edit to be\nexactly one commit. Indeed, you can undo the commit, or you\ncan add other commits. This can be used to split a commit\ninto two:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nStart an interactive rebase with <b>git rebase -i\n&lt;commit&gt;^</b>, where &lt;commit&gt; is the commit you\nwant to split. In fact, any commit range will do, as long as\nit contains that commit.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nMark the commit you want to split with the action\n&quot;edit&quot;.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nWhen it comes to editing that commit, execute <b>git reset\nHEAD^</b>. The effect is that the HEAD is rewound by one,\nand the index follows suit. However, the working tree stays\nthe same.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nNow add the changes to the index that you want to have in\nthe first commit. You can use <b>git add</b> (possibly\ninteractively) or <i>git gui</i> (or both) to do\nthat.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nCommit the now-current index with whatever commit message is\nappropriate now.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nRepeat the last two steps until your working tree is\nclean.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nContinue the rebase with <b>git rebase\n--continue</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nyou are not absolutely sure that the intermediate revisions\nare consistent (they compile, pass the testsuite, etc.) you\nshould use <i>git stash</i> to stash away the\nnot-yet-committed changes after each commit, test, and amend\nthe commit if fixes are necessary.</font></p>\n\n<h2>RECOVERING FROM UPSTREAM REBASE\n<a name=\"RECOVERING FROM UPSTREAM REBASE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Rebasing\n(or any other form of rewriting) a branch that others have\nbased work on is a bad idea: anyone downstream of it is\nforced to manually fix their history. This section explains\nhow to do the fix from the downstream&rsquo;s point of view.\nThe real fix, however, would be to avoid rebasing the\nupstream in the first place.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nillustrate, suppose you are in a situation where someone\ndevelops a <i>subsystem</i> branch, and you are working on a\n<i>topic</i> that is dependent on this <i>subsystem</i>. You\nmight end up with a history like the following:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">o---o---o---o---o---o---o---o\nmaster <br>\n\\ <br>\no---o---o---o---o subsystem <br>\n\\ <br>\n*---*---* topic</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\n<i>subsystem</i> is rebased against <i>master</i>, the\nfollowing happens:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">o---o---o---o---o---o---o---o\nmaster <br>\n\\ \\ <br>\no---o---o---o---o o'--o'--o'--o'--o' subsystem <br>\n\\ <br>\n*---*---* topic</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nyou now continue development as usual, and eventually merge\n<i>topic</i> to <i>subsystem</i>, the commits from\n<i>subsystem</i> will remain duplicated forever:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">o---o---o---o---o---o---o---o\nmaster <br>\n\\ \\ <br>\no---o---o---o---o o'--o'--o'--o'--o'--M subsystem <br>\n\\ / <br>\n*---*---*-..........-*--* topic</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Such\nduplicates are generally frowned upon because they clutter\nup history, making it harder to follow. To clean things up,\nyou need to transplant the commits on <i>topic</i> to the\nnew <i>subsystem</i> tip, i.e., rebase <i>topic</i>. This\nbecomes a ripple effect: anyone downstream from <i>topic</i>\nis forced to rebase too, and so on!</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">There\nare two kinds of fixes, discussed in the following\nsubsections:</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Easy\ncase: The changes are literally the same.</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\nhappens if the <i>subsystem</i> rebase was a simple rebase\nand had no conflicts.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Hard\ncase: The changes are not the same.</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\nhappens if the <i>subsystem</i> rebase had conflicts, or\nused <b>--interactive</b> to omit, edit, squash, or fixup\ncommits; or if the upstream used one of <b>commit\n--amend</b>, <b>reset</b>, or a full history rewriting\ncommand like</font>\n<b><font color=\"#0000FF\">filter-repo</font></b>\n<small><font color=\"#000000\">[2]</font></small>\n<font color=\"#000000\">.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>The\neasy case</b> <br>\nOnly works if the changes (patch IDs based on the diff\ncontents) on <i>subsystem</i> are literally the same before\nand after the rebase <i>subsystem</i> did.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">In\nthat case, the fix is easy because <i>git rebase</i> knows\nto skip changes that are already present in the new upstream\n(unless <b>--reapply-cherry-picks</b> is given). So if you\nsay (assuming you&rsquo;re on <i>topic</i>)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngit rebase subsystem</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">you\nwill end up with the fixed history</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">o---o---o---o---o---o---o---o\nmaster <br>\n\\ <br>\no'--o'--o'--o'--o' subsystem <br>\n\\ <br>\n*---*---* topic</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>The\nhard case</b> <br>\nThings get more complicated if the <i>subsystem</i> changes\ndo not exactly correspond to the ones before the\nrebase.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><b><big>Note</big></b>\n<br>\nWhile an &quot;easy case recovery&quot; sometimes appears to\nbe successful even in the hard case, it may have unintended\nconsequences. For example, a commit that was removed via\n<b>git rebase --interactive</b> will be\n<b>resurrected</b>!</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nidea is to manually tell <i>git rebase</i> &quot;where the\nold <i>subsystem</i> ended and your <i>topic</i>\nbegan&quot;, that is, what the old merge base between them\nwas. You will have to find a way to name the last commit of\nthe old <i>subsystem</i>, for example:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nWith the <i>subsystem</i> reflog: after <i>git fetch</i>,\nthe old tip of <i>subsystem</i> is at <b>subsystem@{1}</b>.\nSubsequent fetches will increase the number. (See\n<a href=\"https://man.page/1/git-reflog\">git-reflog(1)</a>.)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nRelative to the tip of <i>topic</i>: knowing that your\n<i>topic</i> has three commits, the old tip of\n<i>subsystem</i> must be <b>topic~3</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">You\ncan then transplant the old <b>subsystem..topic</b> to the\nnew tip by saying (for the reflog case, and assuming you are\non <i>topic</i> already):</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngit rebase --onto subsystem subsystem@{1}</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nripple effect of a &quot;hard case&quot; recovery is\nespecially bad: <i>everyone</i> downstream from <i>topic</i>\nwill now have to perform a &quot;hard case&quot; recovery\ntoo!</font></p>\n\n<h2>REBASING MERGES\n<a name=\"REBASING MERGES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>The\ninteractive rebase command was originally designed to handle\nindividual patch series. As such, it makes sense to exclude\nmerge commits from the todo list, as the developer may have\nmerged the then-current <b>master</b> while working on the\nbranch, only to rebase all the commits onto <b>master</b>\neventually (skipping the merge commits).</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>However,\nthere are legitimate reasons why a developer may want to\nrecreate merge commits: to keep the branch structure (or\n&quot;commit topology&quot;) when working on multiple,\ninter-related branches.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>In\nthe following example, the developer works on a topic branch\nthat refactors the way buttons are defined, and on another\ntopic branch that uses that refactoring to implement a\n&quot;Report a bug&quot; button. The output of <b>git log\n--graph --format=%s -5</b> may look like\nthis:</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>*\nMerge branch 'report-a-bug' <br>\n|\\ <br>\n| * Add the feedback button <br>\n* | Merge branch 'refactor-button' <br>\n|\\ \\ <br>\n| |/ <br>\n| * Use the Button class for all buttons <br>\n| * Extract a generic Button class from the DownloadButton\none</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>The\ndeveloper might want to rebase those commits to a newer\n<b>master</b> while keeping the branch topology, for example\nwhen the first topic branch is expected to be integrated\ninto <b>master</b> much earlier than the second one, say, to\nresolve merge conflicts with changes to the DownloadButton\nclass that made it into <b>master</b>.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>This\nrebase can be performed using the <b>--rebase-merges</b>\noption. It will generate a todo list looking like\nthis:</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>label\nonto</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>#\nBranch: refactor-button <br>\nreset onto <br>\npick 123456 Extract a generic Button class from the\nDownloadButton one <br>\npick 654321 Use the Button class for all buttons <br>\nlabel refactor-button</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>#\nBranch: report-a-bug <br>\nreset refactor-button # Use the Button class for all buttons\n<br>\npick abcdef Add the feedback button <br>\nlabel report-a-bug</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>reset\nonto <br>\nmerge -C a1b2c3 refactor-button # Merge 'refactor-button'\n<br>\nmerge -C 6f5e4d report-a-bug # Merge\n'report-a-bug'</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>In\ncontrast to a regular interactive rebase, there are\n<b>label</b>, <b>reset</b> and <b>merge</b> commands in\naddition to <b>pick</b> ones.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>The\n<b>label</b> command associates a label with the current\nHEAD when that command is executed. These labels are created\nas worktree-local refs (<b>refs/rewritten/&lt;label&gt;</b>)\nthat will be deleted when the rebase finishes. That way,\nrebase operations in multiple worktrees linked to the same\nrepository do not interfere with one another. If the\n<b>label</b> command fails, it is rescheduled immediately,\nwith a helpful message how to proceed.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>The\n<b>reset</b> command resets the HEAD, index and worktree to\nthe specified revision. It is similar to an <b>exec git\nreset --hard &lt;label&gt;</b>, but refuses to overwrite\nuntracked files. If the <b>reset</b> command fails, it is\nrescheduled immediately, with a helpful message how to edit\nthe todo list (this typically happens when a <b>reset</b>\ncommand was inserted into the todo list manually and\ncontains a typo).</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>The\n<b>merge</b> command will merge the specified revision(s)\ninto whatever is HEAD at that time. With <b>-C\n&lt;original-commit&gt;</b>, the commit message of the\nspecified merge commit will be used. When the <b>-C</b> is\nchanged to a lower-case <b>-c</b>, the message will be\nopened in an editor after a successful merge so that the\nuser can edit the message.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>If\na <b>merge</b> command fails for any reason other than merge\nconflicts (i.e. when the merge operation did not even\nstart), it is rescheduled immediately.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>By\ndefault, the <b>merge</b> command will use the <b>ort</b>\nmerge strategy for regular merges, and <b>octopus</b> for\noctopus merges. One can specify a default strategy for all\nmerges using the <b>--strategy</b> argument when invoking\nrebase, or can override specific merges in the interactive\nlist of commands by using an <b>exec</b> command to call\n<b>git merge</b> explicitly with a <b>--strategy</b>\nargument. Note that when calling <b>git merge</b> explicitly\nlike this, you can make use of the fact that the labels are\nworktree-local refs (the ref <b>refs/rewritten/onto</b>\nwould correspond to the label <b>onto</b>, for example) in\norder to refer to the branches you want to\nmerge.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>Note:\nthe first command (<b>label onto</b>) labels the revision\nonto which the commits are rebased; The name <b>onto</b> is\njust a convention, as a nod to the <b>--onto</b>\noption.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>It\nis also possible to introduce completely new merge commits\nfrom scratch by adding a command of the form <b>merge\n&lt;merge-head&gt;</b>. This form will generate a tentative\ncommit message and always open an editor to let the user\nedit it. This can be useful e.g. when a topic branch turns\nout to address more than a single concern and wants to be\nsplit into two or even more topic branches. Consider this\ntodo list:</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>pick\n192837 Switch from GNU Makefiles to CMake <br>\npick 5a6c7e Document the switch to CMake <br>\npick 918273 Fix detection of OpenSSL in CMake <br>\npick afbecd http: add support for TLS v1.3 <br>\npick fdbaec Fix detection of cURL in CMake on\nWindows</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>The\none commit in this list that is not related to CMake may\nvery well have been motivated by working on fixing all those\nbugs introduced by switching to CMake, but it addresses a\ndifferent concern. To split this branch into two topic\nbranches, the todo list could be edited like\nthis:</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>label\nonto</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>pick\nafbecd http: add support for TLS v1.3 <br>\nlabel tlsv1.3</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>reset\nonto <br>\npick 192837 Switch from GNU Makefiles to CMake <br>\npick 918273 Fix detection of OpenSSL in CMake <br>\npick fdbaec Fix detection of cURL in CMake on Windows <br>\npick 5a6c7e Document the switch to CMake <br>\nlabel cmake</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>reset\nonto <br>\nmerge tlsv1.3 <br>\nmerge cmake</big></font></p>\n\n<h2>CONFIGURATION\n<a name=\"CONFIGURATION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.backend</big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>Default\nbackend to use for rebasing. Possible choices are\n<i>apply</i> or <i>merge</i>. In the future, if the merge\nbackend gains all remaining capabilities of the apply\nbackend, this setting may become unused.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.stat</big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>Whether\nto show a diffstat of what changed upstream since the last\nrebase. False by default.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.autoSquash</big></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>If\nset to true enable <b>--autosquash</b> option by\ndefault.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.autoStash</big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>When\nset to true, automatically create a temporary stash entry\nbefore the operation begins, and apply it after the\noperation ends. This means that you can run rebase on a\ndirty worktree. However, use with care: the final stash\napplication after a successful rebase might result in\nnon-trivial conflicts. This option can be overridden by the\n<b>--no-autostash</b> and <b>--autostash</b> options of\n<a href=\"https://man.page/1/git-rebase\">git-rebase(1)</a>. Defaults to false.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.missingCommitsCheck</big></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>If\nset to &quot;warn&quot;, git rebase -i will print a warning\nif some commits are removed (e.g. a line was deleted),\nhowever the rebase will still proceed. If set to\n&quot;error&quot;, it will print the previous warning and\nstop the rebase, <i>git rebase --edit-todo</i> can then be\nused to correct the error. If set to &quot;ignore&quot;, no\nchecking is done. To drop a commit without warning or error,\nuse the <b>drop</b> command in the todo list. Defaults to\n&quot;ignore&quot;.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.instructionFormat</big></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>A\nformat string, as specified in <a href=\"https://man.page/1/git-log\">git-log(1)</a>, to be used\nfor the todo list during an interactive rebase. The format\nwill automatically have the long commit hash prepended to\nthe format.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.abbreviateCommands</big></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>If\nset to true, <b>git rebase</b> will use abbreviated command\nnames in the todo list resulting in something like\nthis:</big></font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\"><big>p\ndeadbee The oneline of the commit <br>\np fa1afe1 The oneline of the next commit <br>\n...</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>instead\nof:</big></font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\"><big>pick\ndeadbee The oneline of the commit <br>\npick fa1afe1 The oneline of the next commit <br>\n...</big></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><big>Defaults\nto false.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.rescheduleFailedExec</big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>Automatically\nreschedule <b>exec</b> commands that failed. This only makes\nsense in interactive mode (or when an <b>--exec</b> option\nwas provided). This is the same as specifying the\n<b>--reschedule-failed-exec</b> option.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>rebase.forkPoint</big></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>If\nset to false set <b>--no-fork-point</b> option by\ndefault.</big></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>sequence.editor</big></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>Text\neditor used by <b>git rebase -i</b> for editing the rebase\ninstruction file. The value is meant to be interpreted by\nthe shell when it is used. It can be overridden by the\n<b>GIT_SEQUENCE_EDITOR</b> environment variable. When not\nconfigured the default commit message editor is used\ninstead.</big></font></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>Part\nof the <a href=\"https://man.page/1/git\">git(1)</a> suite</big></font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\"><big>1.</big></font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"43%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\"><big>revert-a-faulty-merge\nHow-To</big></font></p> </td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>file:///usr/share/doc/git/html/howto/revert-a-faulty-merge.html</big></font></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\"><big>2.</big></font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\"><big><b>filter-repo</b></big></font></p> </td>\n<td width=\"66%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>https://github.com/newren/git-filter-repo</big></font></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#INCOMPATIBLE OPTIONS\">INCOMPATIBLE OPTIONS</a>","<a href=\"#BEHAVIORAL DIFFERENCES\">BEHAVIORAL DIFFERENCES</a>","<a href=\"#MERGE STRATEGIES\">MERGE STRATEGIES</a>","<a href=\"#NOTES\">NOTES</a>","<a href=\"#INTERACTIVE MODE\">INTERACTIVE MODE</a>","<a href=\"#SPLITTING COMMITS\">SPLITTING COMMITS</a>","<a href=\"#RECOVERING FROM UPSTREAM REBASE\">RECOVERING FROM UPSTREAM REBASE</a>","<a href=\"#REBASING MERGES\">REBASING MERGES</a>","<a href=\"#CONFIGURATION\">CONFIGURATION</a>","<a href=\"#GIT\">GIT</a>","<a href=\"#NOTES\">NOTES</a>"]}