{"name":"git-filter-branch","description":"git-filter-branch - Rewrite branches","body":"\n\n<h1 align=\"center\">GIT-FILTER-BRANCH</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-filter-branch\n- Rewrite branches</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nfilter-branch</i> [--setup &lt;command&gt;]\n[--subdirectory-filter &lt;directory&gt;] <br>\n[--env-filter &lt;command&gt;] [--tree-filter\n&lt;command&gt;] <br>\n[--index-filter &lt;command&gt;] [--parent-filter\n&lt;command&gt;] <br>\n[--msg-filter &lt;command&gt;] [--commit-filter\n&lt;command&gt;] <br>\n[--tag-name-filter &lt;command&gt;] [--prune-empty] <br>\n[--original &lt;namespace&gt;] [-d &lt;directory&gt;] [-f |\n--force] <br>\n[--state-branch &lt;branch&gt;] [--] [&lt;rev-list\noptions&gt;...]</p>\n\n<h2>WARNING\n<a name=\"WARNING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nfilter-branch</i> has a plethora of pitfalls that can\nproduce non-obvious manglings of the intended history\nrewrite (and can leave you with little time to investigate\nsuch problems since it has such abysmal performance). These\nsafety and performance issues cannot be backward compatibly\nfixed and as such, its use is not recommended. Please use an\nalternative history filtering tool such as\n<b><font color=\"#0000FF\">git filter-repo</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">. If you still need to use <i>git\nfilter-branch</i>, please carefully read the section called\n&ldquo;SAFETY&rdquo; (and the section called\n&ldquo;PERFORMANCE&rdquo;) to learn about the land mines of\nfilter-branch, and then vigilantly avoid as many of the\nhazards listed there as reasonably possible.</font></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Lets\nyou rewrite Git revision history by rewriting the branches\nmentioned in the &lt;rev-list options&gt;, applying custom\nfilters on each revision. Those filters can modify each tree\n(e.g. removing a file or running a perl rewrite on all\nfiles) or information about each commit. Otherwise, all\ninformation (including original commit times or merge\ninformation) will be preserved.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\ncommand will only rewrite the <i>positive</i> refs mentioned\nin the command line (e.g. if you pass <i>a..b</i>, only\n<i>b</i> will be rewritten). If you specify no filters, the\ncommits will be recommitted without any changes, which would\nnormally have no effect. Nevertheless, this may be useful in\nthe future for compensating for some Git bugs or such,\ntherefore such a usage is permitted.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>NOTE</b>:\nThis command honors <b>.git/info/grafts</b> file and refs in\nthe <b>refs/replace/</b> namespace. If you have any grafts\nor replacement refs defined, running this command will make\nthem permanent.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>WARNING</b>!\nThe rewritten history will have different object names for\nall the objects and will not converge with the original\nbranch. You will not be able to easily push and distribute\nthe rewritten branch on top of the original branch. Please\ndo not use this command if you do not know the full\nimplications, and avoid using it anyway, if a simple single\ncommit would suffice to fix your problem. (See the\n&quot;RECOVERING FROM UPSTREAM REBASE&quot; section in\n<a href=\"https://man.page/1/git-rebase\">git-rebase(1)</a> for further information about rewriting\npublished history.)</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Always\nverify that the rewritten version is correct: The original\nrefs, if different from the rewritten ones, will be stored\nin the namespace <i>refs/original/</i>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Note\nthat since this operation is very I/O expensive, it might be\na good idea to redirect the temporary directory off-disk\nwith the <b>-d</b> option, e.g. on tmpfs. Reportedly the\nspeedup is very noticeable.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Filters</b>\n<br>\nThe filters are applied in the order as listed below. The\n&lt;command&gt; argument is always evaluated in the shell\ncontext using the <i>eval</i> command (with the notable\nexception of the commit filter, for technical reasons).\nPrior to that, the <b>$GIT_COMMIT</b> environment variable\nwill be set to contain the id of the commit being rewritten.\nAlso, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE,\nGIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and\nGIT_COMMITTER_DATE are taken from the current commit and\nexported to the environment, in order to affect the author\nand committer identities of the replacement commit created\nby <a href=\"https://man.page/1/git-commit-tree\">git-commit-tree(1)</a> after the filters have\nrun.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nany evaluation of &lt;command&gt; returns a non-zero exit\nstatus, the whole operation will be aborted.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">A\n<i>map</i> function is available that takes an\n&quot;original sha1 id&quot; argument and outputs a\n&quot;rewritten sha1 id&quot; if the commit has been already\nrewritten, and &quot;original sha1 id&quot; otherwise; the\n<i>map</i> function can return several ids on separate lines\nif your commit filter emitted multiple commits.</font></p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--setup\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nnot a real filter executed for each commit but a one time\nsetup just before the loop. Therefore no commit-specific\nvariables are defined yet. Functions or variables defined\nhere can be used or modified in the following filter steps\nexcept the commit filter, for technical reasons.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--subdirectory-filter\n&lt;directory&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Only look\nat the history which touches the given subdirectory. The\nresult will contain that directory (and only that) as its\nproject root. Implies the section called &ldquo;Remap to\nancestor&rdquo;.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--env-filter\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\nfilter may be used if you only need to modify the\nenvironment in which the commit will be performed.\nSpecifically, you might want to rewrite the author/committer\nname/email/time environment variables (see\n<a href=\"https://man.page/1/git-commit-tree\">git-commit-tree(1)</a> for details).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--tree-filter\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nthe filter for rewriting the tree and its contents. The\nargument is evaluated in shell with the working directory\nset to the root of the checked out tree. The new tree is\nthen used as-is (new files are auto-added, disappeared files\nare auto-removed - neither .gitignore files nor any other\nignore rules <b>HAVE ANY EFFECT</b>!).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--index-filter\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nthe filter for rewriting the index. It is similar to the\ntree filter but does not check out the tree, which makes it\nmuch faster. Frequently used with <b>git rm --cached\n--ignore-unmatch ...</b>, see EXAMPLES below. For hairy\ncases, see <a href=\"https://man.page/1/git-update-index\">git-update-index(1)</a>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--parent-filter\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nthe filter for rewriting the commit&rsquo;s parent list. It\nwill receive the parent string on stdin and shall output the\nnew parent string on stdout. The parent string is in the\nformat described in <a href=\"https://man.page/1/git-commit-tree\">git-commit-tree(1)</a>: empty for the\ninitial commit, &quot;-p parent&quot; for a normal commit\nand &quot;-p parent1 -p parent2 -p parent3 ...&quot; for a\nmerge commit.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--msg-filter\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nthe filter for rewriting the commit messages. The argument\nis evaluated in the shell with the original commit message\non standard input; its standard output is used as the new\ncommit message.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--commit-filter\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nthe filter for performing the commit. If this filter is\nspecified, it will be called instead of the <i>git\ncommit-tree</i> command, with arguments of the form\n&quot;&lt;TREE_ID&gt; [(-p\n&lt;PARENT_COMMIT_ID&gt;)...]&quot; and the log message on\nstdin. The commit id is expected on stdout.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">As\na special extension, the commit filter may emit multiple\ncommit ids; in that case, the rewritten children of the\noriginal commit will have all of them as parents.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">You\ncan use the <i>map</i> convenience function in this filter,\nand other convenience functions, too. For example, calling\n<i>skip_commit &quot;$@&quot;</i> will leave out the current\ncommit (but not its changes! If you want that, use <i>git\nrebase</i> instead).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">You\ncan also use the <b>git_commit_non_empty_tree\n&quot;$@&quot;</b> instead of <b>git commit-tree\n&quot;$@&quot;</b> if you don&rsquo;t wish to keep commits\nwith a single parent and that makes no change to the\ntree.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--tag-name-filter\n&lt;command&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This is\nthe filter for rewriting tag names. When passed, it will be\ncalled for every tag ref that points to a rewritten object\n(or to a tag object which points to a rewritten object). The\noriginal tag name is passed via standard input, and the new\ntag name is expected on standard output.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">The\noriginal tags are not deleted, but can be overwritten; use\n&quot;--tag-name-filter cat&quot; to simply update the tags.\nIn this case, be very careful and make sure you have the old\ntags backed up in case the conversion has run\nafoul.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Nearly\nproper rewriting of tag objects is supported. If the tag has\na message attached, a new tag object will be created with\nthe same message, author, and timestamp. If the tag has a\nsignature attached, the signature will be stripped. It is by\ndefinition impossible to preserve signatures. The reason\nthis is &quot;nearly&quot; proper, is because ideally if the\ntag did not change (points to the same object, has the same\nname, etc.) it should retain any signature. That is not the\ncase, signatures will always be removed, buyer beware. There\nis also no support for changing the author or timestamp (or\nthe tag message for that matter). Tags which point to other\ntags will be rewritten to point to the underlying\ncommit.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--prune-empty</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Some\nfilters will generate empty commits that leave the tree\nuntouched. This option instructs git-filter-branch to remove\nsuch commits if they have exactly one or zero non-pruned\nparents; merge commits will therefore remain intact. This\noption cannot be used together with <b>--commit-filter</b>,\nthough the same effect can be achieved by using the provided\n<b>git_commit_non_empty_tree</b> function in a commit\nfilter.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--original\n&lt;namespace&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Use this\noption to set the namespace where the original commits will\nbe stored. The default value is\n<i>refs/original</i>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">-d\n&lt;directory&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Use this\noption to set the path to the temporary directory used for\nrewriting. When applying a tree filter, the command needs to\ntemporarily check out the tree to some directory, which may\nconsume considerable space in case of large projects. By\ndefault it does this in the <b>.git-rewrite/</b> directory\nbut you can override that choice by this\nparameter.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">-f,\n--force</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><i>git\nfilter-branch</i> refuses to start with an existing\ntemporary directory or when there are already refs starting\nwith <i>refs/original/</i>, unless forced.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">--state-branch\n&lt;branch&gt;</font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\noption will cause the mapping from old to new objects to be\nloaded from named branch upon startup and saved as a new\ncommit to that branch upon exit, enabling incremental of\nlarge trees. If <i>&lt;branch&gt;</i> does not exist it will\nbe created.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">&lt;rev-list\noptions&gt;...</font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Arguments\nfor <i>git rev-list</i>. All positive refs included by these\noptions are rewritten. You may also specify options such as\n<b>--all</b>, but you must use <b>--</b> to separate them\nfrom the <i>git filter-branch</i> options. Implies the\nsection called &ldquo;Remap to ancestor&rdquo;.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Remap\nto ancestor</b> <br>\nBy using <a href=\"https://man.page/1/git-rev-list\">git-rev-list(1)</a> arguments, e.g., path\nlimiters, you can limit the set of revisions which get\nrewritten. However, positive refs on the command line are\ndistinguished: we don&rsquo;t let them be excluded by such\nlimiters. For this purpose, they are instead rewritten to\npoint at the nearest ancestor that was not\nexcluded.</font></p>\n\n<h2>EXIT STATUS\n<a name=\"EXIT STATUS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">On\nsuccess, the exit status is <b>0</b>. If the filter\ncan&rsquo;t find any commits to rewrite, the exit status is\n<b>2</b>. On any other error, the exit status may be any\nother non-zero value.</font></p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Suppose\nyou want to remove a file (containing confidential\ninformation or copyright violation) from all\ncommits:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --tree-filter 'rm filename' HEAD</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">However,\nif the file is absent from the tree of some commit, a simple\n<b>rm filename</b> will fail for that tree and commit. Thus\nyou may instead want to use <b>rm -f filename</b> as the\nscript.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Using\n<b>--index-filter</b> with <i>git rm</i> yields a\nsignificantly faster version. Like with using <b>rm\nfilename</b>, <b>git rm --cached filename</b> will fail if\nthe file is absent from the tree of a commit. If you want to\n&quot;completely forget&quot; a file, it does not matter\nwhen it entered history, so we also add\n<b>--ignore-unmatch</b>:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --index-filter 'git rm --cached\n--ignore-unmatch filename' HEAD</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Now,\nyou will get the rewritten history saved in HEAD.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nrewrite the repository to look as if <b>foodir/</b> had been\nits project root, and discard all other history:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --subdirectory-filter foodir --\n--all</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Thus\nyou can, e.g., turn a library subdirectory into a repository\nof its own. Note the <b>--</b> that separates\n<i>filter-branch</i> options from revision options, and the\n<b>--all</b> to rewrite all branches and tags.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nset a commit (which typically is at the tip of another\nhistory) to be the parent of the current initial commit, in\norder to paste the other history behind the current\nhistory:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --parent-filter 'sed &quot;s/^\\$/-p\n&lt;graft-id&gt;/&quot;' HEAD</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">(if\nthe parent string is empty - which happens when we are\ndealing with the initial commit - add graftcommit as a\nparent). Note that this assumes history with a single root\n(that is, no merge without common ancestors happened). If\nthis is not the case, use:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --parent-filter \\ <br>\n'test $GIT_COMMIT = &lt;commit-id&gt; &amp;&amp; echo\n&quot;-p &lt;graft-id&gt;&quot; || cat' HEAD</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">or\neven simpler:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nreplace --graft $commit-id $graft-id <br>\ngit filter-branch $graft-id..HEAD</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nremove commits authored by &quot;Darl McBribe&quot; from the\nhistory:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --commit-filter ' <br>\nif [ &quot;$GIT_AUTHOR_NAME&quot; = &quot;Darl McBribe&quot;\n]; <br>\nthen <br>\nskip_commit &quot;$@&quot;; <br>\nelse <br>\ngit commit-tree &quot;$@&quot;; <br>\nfi' HEAD</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nfunction <i>skip_commit</i> is defined as\nfollows:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">skip_commit()\n<br>\n{ <br>\nshift; <br>\nwhile [ -n &quot;$1&quot; ]; <br>\ndo <br>\nshift; <br>\nmap &quot;$1&quot;; <br>\nshift; <br>\ndone; <br>\n}</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nshift magic first throws away the tree id and then the -p\nparameters. Note that this handles merges properly! In case\nDarl committed a merge between P1 and P2, it will be\npropagated properly and all children of the merge will\nbecome merge commits with P1,P2 as their parents instead of\nthe merge commit.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>NOTE</b>\nthe changes introduced by the commits, and which are not\nreverted by subsequent commits, will still be in the\nrewritten branch. If you want to throw out <i>changes</i>\ntogether with the commits, you should use the interactive\nmode of <i>git rebase</i>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">You\ncan rewrite the commit log messages using\n<b>--msg-filter</b>. For example, <i>git svn-id</i> strings\nin a repository created by <i>git svn</i> can be removed\nthis way:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --msg-filter ' <br>\nsed -e &quot;/^git-svn-id:/d&quot; <br>\n'</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nyou need to add <i>Acked-by</i> lines to, say, the last 10\ncommits (none of which is a merge), use this\ncommand:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --msg-filter ' <br>\ncat &amp;&amp; <br>\necho &quot;Acked-by: Bugs Bunny\n&lt;bunny@bugzilla.org&gt;&quot; <br>\n' HEAD~10..HEAD</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\n<b>--env-filter</b> option can be used to modify committer\nand/or author identity. For example, if you found out that\nyour commits have the wrong identity due to a misconfigured\nuser.email, you can make a correction, before publishing the\nproject, like this:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --env-filter ' <br>\nif test &quot;$GIT_AUTHOR_EMAIL&quot; =\n&quot;root@localhost&quot; <br>\nthen <br>\nGIT_AUTHOR_EMAIL=john@example.com <br>\nfi <br>\nif test &quot;$GIT_COMMITTER_EMAIL&quot; =\n&quot;root@localhost&quot; <br>\nthen <br>\nGIT_COMMITTER_EMAIL=john@example.com <br>\nfi <br>\n' -- --all</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nrestrict rewriting to only part of the history, specify a\nrevision range in addition to the new branch name. The new\nbranch name will point to the top-most revision that a\n<i>git rev-list</i> of this range will print.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Consider\nthis history:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">D--E--F--G--H\n<br>\n/ / <br>\nA--B-----C</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nrewrite only commits D,E,F,G,H, but leave A, B and C alone,\nuse:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch ... C..H</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nrewrite commits E,F,G,H, use one of these:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch ... C..H --not D <br>\ngit filter-branch ... D..H --not C</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\nmove the whole tree into a subdirectory, or remove it from\nthere:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">git\nfilter-branch --index-filter \\ <br>\n'git ls-files -s | sed\n&quot;s-\\t\\&quot;*-&amp;newsubdir/-&quot; | <br>\nGIT_INDEX_FILE=$GIT_INDEX_FILE.new \\ <br>\ngit update-index --index-info &amp;&amp; <br>\nmv &quot;$GIT_INDEX_FILE.new&quot;\n&quot;$GIT_INDEX_FILE&quot;' HEAD</font></p>\n\n<h2>CHECKLIST FOR SHRINKING A REPOSITORY\n<a name=\"CHECKLIST FOR SHRINKING A REPOSITORY\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">git-filter-branch\ncan be used to get rid of a subset of files, usually with\nsome combination of <b>--index-filter</b> and\n<b>--subdirectory-filter</b>. People expect the resulting\nrepository to be smaller than the original, but you need a\nfew more steps to actually make it smaller, because Git\ntries hard not to lose your objects until you tell it to.\nFirst make sure that:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nYou really removed all variants of a filename, if a blob was\nmoved over its lifetime. <b>git log --name-only --follow\n--all -- filename</b> can help you find renames.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nYou really filtered all refs: use <b>--tag-name-filter cat\n-- --all</b> when calling git-filter-branch.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Then\nthere are two ways to get a smaller repository. A safer way\nis to clone, that keeps your original intact.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nClone it with <b>git clone file:///path/to/repo</b>. The\nclone will not have the removed objects. See\n<a href=\"https://man.page/1/git-clone\">git-clone(1)</a>. (Note that cloning with a plain path\njust hardlinks everything!)</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nyou really don&rsquo;t want to clone it, for whatever\nreasons, check the following points instead (in this order).\nThis is a very destructive approach, so <b>make a backup</b>\nor go back to cloning it. You have been warned.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nRemove the original refs backed up by git-filter-branch: say\n<b>git for-each-ref --format=&quot;%(refname)&quot;\nrefs/original/ | xargs -n 1 git update-ref\n-d</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nExpire all reflogs with <b>git reflog expire --expire=now\n--all</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nGarbage collect all unreferenced objects with <b>git gc\n--prune=now</b> (or if your git-gc is not new enough to\nsupport arguments to <b>--prune</b>, use <b>git repack -ad;\ngit prune</b> instead).</font></p>\n\n<h2>PERFORMANCE\n<a name=\"PERFORMANCE\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nperformance of git-filter-branch is glacially slow; its\ndesign makes it impossible for a backward-compatible\nimplementation to ever be fast:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIn editing files, git-filter-branch by design checks out\neach and every commit as it existed in the original repo. If\nyour repo has <b>10^5</b> files and <b>10^5</b> commits, but\neach commit only modifies five files, then git-filter-branch\nwill make you do <b>10^10</b> modifications, despite only\nhaving (at most) <b>5*10^5</b> unique blobs.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf you try and cheat and try to make git-filter-branch only\nwork on files modified in a commit, then two things\nhappen</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nyou run into problems with deletions whenever the user is\nsimply trying to rename files (because attempting to delete\nfiles that don&rsquo;t exist looks like a no-op; it takes\nsome chicanery to remap deletes across file renames when the\nrenames happen via arbitrary user-provided shell)</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\neven if you succeed at the map-deletes-for-renames\nchicanery, you still technically violate backward\ncompatibility because users are allowed to filter files in\nways that depend upon topology of commits instead of\nfiltering solely based on file contents or names (though\nthis has not been observed in the wild).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nEven if you don&rsquo;t need to edit files but only want to\ne.g. rename or remove some and thus can avoid checking out\neach file (i.e. you can use --index-filter), you still are\npassing shell snippets for your filters. This means that for\nevery commit, you have to have a prepared git repo where\nthose filters can be run. That&rsquo;s a significant\nsetup.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nFurther, several additional files are created or updated per\ncommit by git-filter-branch. Some of these are for\nsupporting the convenience functions provided by\ngit-filter-branch (such as map()), while others are for\nkeeping track of internal state (but could have also been\naccessed by user filters; one of git-filter-branch&rsquo;s\nregression tests does so). This essentially amounts to using\nthe filesystem as an IPC mechanism between git-filter-branch\nand the user-provided filters. Disks tend to be a slow IPC\nmechanism, and writing these files also effectively\nrepresents a forced synchronization point between separate\nprocesses that we hit with every commit.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nThe user-provided shell commands will likely involve a\npipeline of commands, resulting in the creation of many\nprocesses per commit. Creating and running another process\ntakes a widely varying amount of time between operating\nsystems, but on any platform it is very slow relative to\ninvoking a function.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\ngit-filter-branch itself is written in shell, which is kind\nof slow. This is the one performance issue that could be\nbackward-compatibly fixed, but compared to the above\nproblems that are intrinsic to the design of\ngit-filter-branch, the language of the tool itself is a\nrelatively minor issue.</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nSide note: Unfortunately, people tend to fixate on the\nwritten-in-shell aspect and periodically ask if\ngit-filter-branch could be rewritten in another language to\nfix the performance issues. Not only does that ignore the\nbigger intrinsic problems with the design, it&rsquo;d help\nless than you&rsquo;d expect: if git-filter-branch itself\nwere not shell, then the convenience functions (map(),\nskip_commit(), etc) and the <b>--setup</b> argument could no\nlonger be executed once at the beginning of the program but\nwould instead need to be prepended to every user filter (and\nthus re-executed with every commit).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The</font>\n<b><font color=\"#0000FF\">git filter-repo</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">tool is an alternative to\ngit-filter-branch which does not suffer from these\nperformance problems or the safety problems (mentioned\nbelow). For those with existing tooling which relies upon\ngit-filter-branch, <i>git filter-repo</i> also\nprovides</font>\n<b><font color=\"#0000FF\">filter-lamely</font></b>\n<small><font color=\"#000000\">[2]</font></small>\n<font color=\"#000000\">, a drop-in git-filter-branch\nreplacement (with a few caveats). While filter-lamely\nsuffers from all the same safety issues as\ngit-filter-branch, it at least ameliorates the performance\nissues a little.</font></p>\n\n<h2>SAFETY\n<a name=\"SAFETY\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">git-filter-branch\nis riddled with gotchas resulting in various ways to easily\ncorrupt repos or end up with a mess worse than what you\nstarted with:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nSomeone can have a set of &quot;working and tested\nfilters&quot; which they document or provide to a coworker,\nwho then runs them on a different OS where the same commands\nare not working/tested (some examples in the\ngit-filter-branch manpage are also affected by this). BSD\nvs. GNU userland differences can really bite. If lucky,\nerror messages are spewed. But just as likely, the commands\neither don&rsquo;t do the filtering requested, or silently\ncorrupt by making some unwanted change. The unwanted change\nmay only affect a few commits, so it&rsquo;s not necessarily\nobvious either. (The fact that problems won&rsquo;t\nnecessarily be obvious means they are likely to go unnoticed\nuntil the rewritten history is in use for quite a while, at\nwhich point it&rsquo;s really hard to justify another\nflag-day for another rewrite.)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nFilenames with spaces are often mishandled by shell snippets\nsince they cause problems for shell pipelines. Not everyone\nis familiar with find -print0, xargs -0, git-ls-files -z,\netc. Even people who are familiar with these may assume such\nflags are not relevant because someone else renamed any such\nfiles in their repo back before the person doing the\nfiltering joined the project. And often, even those familiar\nwith handling arguments with spaces may not do so just\nbecause they aren&rsquo;t in the mindset of thinking about\neverything that could possibly go wrong.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nNon-ascii filenames can be silently removed despite being in\na desired directory. Keeping only wanted paths is often done\nusing pipelines like <b>git ls-files | grep -v ^WANTED_DIR/\n| xargs git rm</b>. ls-files will only quote filenames if\nneeded, so folks may not notice that one of the files\ndidn&rsquo;t match the regex (at least not until it&rsquo;s\nmuch too late). Yes, someone who knows about core.quotePath\ncan avoid this (unless they have other special characters\nlike \\t, \\n, or &quot;), and people who use ls-files -z with\nsomething other than grep can avoid this, but that\ndoesn&rsquo;t mean they will.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nSimilarly, when moving files around, one can find that\nfilenames with non-ascii or special characters end up in a\ndifferent directory, one that includes a double quote\ncharacter. (This is technically the same issue as above with\nquoting, but perhaps an interesting different way that it\ncan and has manifested as a problem.)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIt&rsquo;s far too easy to accidentally mix up old and new\nhistory. It&rsquo;s still possible with any tool, but\ngit-filter-branch almost invites it. If lucky, the only\ndownside is users getting frustrated that they don&rsquo;t\nknow how to shrink their repo and remove the old stuff. If\nunlucky, they merge old and new history and end up with\nmultiple &quot;copies&quot; of each commit, some of which\nhave unwanted or sensitive files and others which\ndon&rsquo;t. This comes about in multiple different\nways:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nthe default to only doing a partial history rewrite\n(<i>--all</i> is not the default and few examples show\nit)</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nthe fact that there&rsquo;s no automatic post-run\ncleanup</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nthe fact that --tag-name-filter (when used to rename tags)\ndoesn&rsquo;t remove the old tags but just adds new ones\nwith the new name</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nthe fact that little educational information is provided to\ninform users of the ramifications of a rewrite and how to\navoid mixing old and new history. For example, this man page\ndiscusses how users need to understand that they need to\nrebase their changes for all their branches on top of new\nhistory (or delete and reclone), but that&rsquo;s only one\nof multiple concerns to consider. See the\n&quot;DISCUSSION&quot; section of the git filter-repo manual\npage for more details.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nAnnotated tags can be accidentally converted to lightweight\ntags, due to either of two issues:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nSomeone can do a history rewrite, realize they messed up,\nrestore from the backups in refs/original/, and then redo\ntheir git-filter-branch command. (The backup in\nrefs/original/ is not a real backup; it dereferences tags\nfirst.)</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nRunning git-filter-branch with either --tags or --all in\nyour &lt;rev-list options&gt;. In order to retain annotated\ntags as annotated, you must use --tag-name-filter (and must\nnot have restored from refs/original/ in a previously\nbotched rewrite).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nAny commit messages that specify an encoding will become\ncorrupted by the rewrite; git-filter-branch ignores the\nencoding, takes the original bytes, and feeds it to\ncommit-tree without telling it the proper encoding. (This\nhappens whether or not --msg-filter is used.)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nCommit messages (even if they are all UTF-8) by default\nbecome corrupted due to not being updated &mdash; any\nreferences to other commit hashes in commit messages will\nnow refer to no-longer-extant commits.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nThere are no facilities for helping users find what unwanted\ncrud they should delete, which means they are much more\nlikely to have incomplete or partial cleanups that sometimes\nresult in confusion and people wasting time trying to\nunderstand. (For example, folks tend to just look for big\nfiles to delete instead of big directories or extensions,\nand once they do so, then sometime later folks using the new\nrepository who are going through history will notice a build\nartifact directory that has some files but not others, or a\ncache of dependencies (node_modules or similar) which\ncouldn&rsquo;t have ever been functional since it&rsquo;s\nmissing some files.)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf --prune-empty isn&rsquo;t specified, then the filtering\nprocess can create hoards of confusing empty\ncommits</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf --prune-empty is specified, then intentionally placed\nempty commits from before the filtering operation are also\npruned instead of just pruning commits that became empty due\nto filtering rules.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf --prune-empty is specified, sometimes empty commits are\nmissed and left around anyway (a somewhat rare bug, but it\nhappens...)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nA minor issue, but users who have a goal to update all names\nand emails in a repository may be led to --env-filter which\nwill only update authors and committers, missing\ntaggers.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf the user provides a --tag-name-filter that maps multiple\ntags to the same name, no warning or error is provided;\ngit-filter-branch simply overwrites each tag in some\nundocumented pre-defined order resulting in only one tag at\nthe end. (A git-filter-branch regression test requires this\nsurprising behavior.)</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Also,\nthe poor performance of git-filter-branch often leads to\nsafety issues:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nComing up with the correct shell snippet to do the filtering\nyou want is sometimes difficult unless you&rsquo;re just\ndoing a trivial modification such as deleting a couple\nfiles. Unfortunately, people often learn if the snippet is\nright or wrong by trying it out, but the rightness or\nwrongness can vary depending on special circumstances\n(spaces in filenames, non-ascii filenames, funny author\nnames or emails, invalid timezones, presence of grafts or\nreplace objects, etc.), meaning they may have to wait a long\ntime, hit an error, then restart. The performance of\ngit-filter-branch is so bad that this cycle is painful,\nreducing the time available to carefully re-check (to say\nnothing about what it does to the patience of the person\ndoing the rewrite even if they do technically have more time\navailable). This problem is extra compounded because errors\nfrom broken filters may not be shown for a long time and/or\nget lost in a sea of output. Even worse, broken filters\noften just result in silent incorrect rewrites.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nTo top it all off, even when users finally find working\ncommands, they naturally want to share them. But they may be\nunaware that their repo didn&rsquo;t have some special cases\nthat someone else&rsquo;s does. So, when someone else with a\ndifferent repository runs the same commands, they get hit by\nthe problems above. Or, the user just runs commands that\nreally were vetted for special cases, but they run it on a\ndifferent OS where it doesn&rsquo;t work, as noted\nabove.</font></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Part\nof the <a href=\"https://man.page/1/git\">git(1)</a> suite</font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">1.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"23%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">git\nfilter-repo</font></p> </td>\n<td width=\"60%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://github.com/newren/git-filter-repo/</font></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">2.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"20%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">filter-lamely</font></p> </td>\n<td width=\"63%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely</font></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#WARNING\">WARNING</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#EXIT STATUS\">EXIT STATUS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#CHECKLIST FOR SHRINKING A REPOSITORY\">CHECKLIST FOR SHRINKING A REPOSITORY</a>","<a href=\"#PERFORMANCE\">PERFORMANCE</a>","<a href=\"#SAFETY\">SAFETY</a>","<a href=\"#GIT\">GIT</a>","<a href=\"#NOTES\">NOTES</a>"]}