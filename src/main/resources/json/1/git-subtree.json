{"name":"git-subtree","body":"\n\n<h1 align=\"center\">GIT-SUBTREE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-subtree -\nMerge subtrees together and split repository into\nsubtrees</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nsubtree</i> [&lt;options&gt;] -P &lt;prefix&gt; add\n&lt;local-commit&gt; <i><br>\ngit subtree</i> [&lt;options&gt;] -P &lt;prefix&gt; add\n&lt;repository&gt; &lt;remote-ref&gt; <i><br>\ngit subtree</i> [&lt;options&gt;] -P &lt;prefix&gt; merge\n&lt;local-commit&gt; <i><br>\ngit subtree</i> [&lt;options&gt;] -P &lt;prefix&gt; split\n[&lt;local-commit&gt;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nsubtree</i> [&lt;options&gt;] -P &lt;prefix&gt; pull\n&lt;repository&gt; &lt;remote-ref&gt; <i><br>\ngit subtree</i> [&lt;options&gt;] -P &lt;prefix&gt; push\n&lt;repository&gt; &lt;refspec&gt;</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Subtrees allow\nsubprojects to be included within a subdirectory of the main\nproject, optionally including the subproject&rsquo;s entire\nhistory.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nyou could include the source code for a library as a\nsubdirectory of your application.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Subtrees are\nnot to be confused with submodules, which are meant for the\nsame task. Unlike submodules, subtrees do not need any\nspecial constructions (like <i>.gitmodules</i> files or\ngitlinks) be present in your repository, and do not force\nend-users of your repository to do anything special or to\nunderstand how subtrees work. A subtree is just a\nsubdirectory that can be committed to, branched, and merged\nalong with your project in any way you want.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">They are also\nnot to be confused with using the subtree merge strategy.\nThe main difference is that, besides merging the other\nproject as a subdirectory, you can also extract the entire\nhistory of a subdirectory from your project and make it into\na standalone project. Unlike the subtree merge strategy you\ncan alternate back and forth between these two operations.\nIf the standalone library gets updated, you can\nautomatically merge the changes into your project; if you\nupdate the library inside your project, you can\n&quot;split&quot; the changes back out again and merge them\nback into the library project.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example, if\na library you made for one application ends up being useful\nelsewhere, you can extract its entire history and publish\nthat as its own git repository, without accidentally\nintermingling the history of your application project.</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><b><big>Tip</big></b>\n<br>\nIn order to keep your commit messages clean, we recommend\nthat people split their commits between the subtrees and the\nmain project as much as possible. That is, if you make a\nchange that affects both the library and the main\napplication, commit it in two pieces. That way, when you\nsplit the library commits out later, their descriptions will\nstill make sense. But if this isn&rsquo;t important to you,\nit&rsquo;s not <b>necessary</b>. <i>git subtree</i> will\nsimply leave out the non-library-related parts of the commit\nwhen it splits it out into the subproject later.</p>\n\n<h2>COMMANDS\n<a name=\"COMMANDS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>add\n&lt;local-commit&gt;, add &lt;repository&gt;\n&lt;remote-ref&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>Create the &lt;prefix&gt;\nsubtree by importing its contents from the given\n&lt;local-commit&gt; or &lt;repository&gt; and\n&lt;remote-ref&gt;. A new commit is created automatically,\njoining the imported project&rsquo;s history with your own.\nWith <i>--squash</i>, import only a single commit from the\nsubproject, rather than its entire history.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>merge\n&lt;local-commit&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>Merge recent changes up to\n&lt;local-commit&gt; into the &lt;prefix&gt; subtree. As\nwith normal <i>git merge</i>, this doesn&rsquo;t remove your\nown local changes; it just merges those changes into the\nlatest &lt;local-commit&gt;. With <i>--squash</i>, create\nonly one commit that contains all the changes, rather than\nmerging in the entire history.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>If you use\n<i>--squash</i>, the merge direction doesn&rsquo;t always\nhave to be forward; you can use this command to go back in\ntime from v2.5 to v2.4, for example. If your merge\nintroduces a conflict, you can resolve it in the usual\nways.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>split\n[&lt;local-commit&gt;]</big></p>\n\n<p style=\"margin-left:17%;\"><big>Extract a new, synthetic\nproject history from the history of the &lt;prefix&gt;\nsubtree of &lt;local-commit&gt;, or of HEAD if no\n&lt;local-commit&gt; is given. The new history includes only\nthe commits (including merges) that affected &lt;prefix&gt;,\nand each of those commits now has the contents of\n&lt;prefix&gt; at the root of the project instead of in a\nsubdirectory. Thus, the newly created history is suitable\nfor export as a separate git repository.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>After\nsplitting successfully, a single commit ID is printed to\nstdout. This corresponds to the HEAD of the newly created\ntree, which you can manipulate however you want.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Repeated\nsplits of exactly the same history are guaranteed to be\nidentical (i.e. to produce the same commit IDs) as long as\nthe settings passed to <i>split</i> (such as\n<i>--annotate</i>) are the same. Because of this, if you add\nnew commits and then re-split, the new commits will be\nattached as commits on top of the history you generated last\ntime, so <i>git merge</i> and friends will work as\nexpected.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>pull\n&lt;repository&gt; &lt;remote-ref&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>Exactly like <i>merge</i>,\nbut parallels <i>git pull</i> in that it fetches the given\nref from the specified remote repository.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>push\n&lt;repository&gt;\n[+][&lt;local-commit&gt;:]&lt;remote-ref&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>Does a <i>split</i> using\nthe &lt;prefix&gt; subtree of &lt;local-commit&gt; and then\ndoes a <i>git push</i> to push the result to the\n&lt;repository&gt; and &lt;remote-ref&gt;. This can be used\nto push your subtree to different branches of the remote\nrepository. Just as with <i>split</i>, if no\n&lt;local-commit&gt; is given, then HEAD is used. The\noptional leading <i>+</i> is ignored.</big></p>\n\n<h2>OPTIONS FOR ALL COMMANDS\n<a name=\"OPTIONS FOR ALL COMMANDS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>-q,\n--quiet</big></p>\n\n<p style=\"margin-left:17%;\"><big>Suppress unnecessary\noutput messages on stderr.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>-d,\n--debug</big></p>\n\n<p style=\"margin-left:17%;\"><big>Produce even more\nunnecessary output messages on stderr.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>-P\n&lt;prefix&gt;, --prefix=&lt;prefix&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>Specify the path in the\nrepository to the subtree you want to manipulate. This\noption is mandatory for all commands.</big></p>\n\n<h2>OPTIONS FOR ADD AND MERGE (ALSO: PULL, SPLIT --REJOIN, AND PUSH --REJOIN)\n<a name=\"OPTIONS FOR ADD AND MERGE (ALSO: PULL, SPLIT --REJOIN, AND PUSH --REJOIN)\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>These\noptions for <i>add</i> and <i>merge</i> may also be given to\n<i>pull</i> (which wraps <i>merge</i>), <i>split\n--rejoin</i> (which wraps either <i>add</i> or <i>merge</i>\nas appropriate), and <i>push --rejoin</i> (which wraps\n<i>split --rejoin</i>).</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>--squash</big></p>\n\n<p style=\"margin-left:17%;\"><big>Instead of merging the\nentire history from the subtree project, produce only a\nsingle commit that contains all the differences you want to\nmerge, and then merge that new commit into your\nproject.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Using this\noption helps to reduce log clutter. People rarely want to\nsee every change that happened between v1.0 and v1.1 of the\nlibrary they&rsquo;re using, since none of the interim\nversions were ever included in their application.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Using\n<i>--squash</i> also helps avoid problems when the same\nsubproject is included multiple times in the same project,\nor is removed and then re-added. In such a case, it\ndoesn&rsquo;t make sense to combine the histories anyway,\nsince it&rsquo;s unclear which part of the history belongs\nto which subtree.</big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Furthermore,\nwith <i>--squash</i>, you can switch back and forth between\ndifferent versions of a subtree, rather than strictly\nforward. <i>git subtree merge --squash</i> always adjusts\nthe subtree to match the exactly specified commit, even if\ngetting to that commit would require undoing some changes\nthat were added earlier.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Whether or\nnot you use <i>--squash</i>, changes made in your local\nrepository remain intact and can be later split and send\nupstream to the subproject.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>-m\n&lt;message&gt;, --message=&lt;message&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>Specify &lt;message&gt; as\nthe commit message for the merge commit.</big></p>\n\n<h2>OPTIONS FOR SPLIT (ALSO: PUSH)\n<a name=\"OPTIONS FOR SPLIT (ALSO: PUSH)\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>These\noptions for <i>split</i> may also be given to <i>push</i>\n(which wraps <i>split</i>).</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>--annotate=&lt;annotation&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>When generating synthetic\nhistory, add &lt;annotation&gt; as a prefix to each commit\nmessage. Since we&rsquo;re creating new commits with the\nsame commit message, but possibly different content, from\nthe original commits, this can help to differentiate them\nand avoid confusion.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Whenever\nyou split, you need to use the same &lt;annotation&gt;, or\nelse you don&rsquo;t have a guarantee that the new\nre-created history will be identical to the old one. That\nwill prevent merging from working correctly. git subtree\ntries to make it work anyway, particularly if you use\n<i>--rejoin</i>, but it may not always be\neffective.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>-b\n&lt;branch&gt;, --branch=&lt;branch&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>After generating the\nsynthetic history, create a new branch called &lt;branch&gt;\nthat contains the new history. This is suitable for\nimmediate pushing upstream. &lt;branch&gt; must not already\nexist.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>--ignore-joins</big></p>\n\n<p style=\"margin-left:17%;\"><big>If you use\n<i>--rejoin</i>, git subtree attempts to optimize its\nhistory reconstruction to generate only the new commits\nsince the last <i>--rejoin</i>. <i>--ignore-joins</i>\ndisables this behavior, forcing it to regenerate the entire\nhistory. In a large project, this can take a long\ntime.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>--onto=&lt;onto&gt;</big></p>\n\n<p style=\"margin-left:17%;\"><big>If your subtree was\noriginally imported using something other than git subtree,\nits history may not match what git subtree is expecting. In\nthat case, you can specify the commit ID &lt;onto&gt; that\ncorresponds to the first revision of the subproject&rsquo;s\nhistory that was imported into your project, and git subtree\nwill attempt to build its history from there.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>If you\nused <i>git subtree add</i>, you should never need this\noption.</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>--rejoin</big></p>\n\n<p style=\"margin-left:17%;\"><big>After splitting, merge the\nnewly created synthetic history back into your main project.\nThat way, future splits can search only the part of history\nthat has been added since the most recent\n<i>--rejoin</i>.</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>If your\nsplit commits end up merged into the upstream subproject,\nand then you want to get the latest upstream version, this\nwill allow git&rsquo;s merge algorithm to more intelligently\navoid conflicts (since it knows these synthetic commits are\nalready part of the upstream repository).</big></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>Unfortunately,\nusing this option results in <i>git log</i> showing an extra\ncopy of every new commit that was created (the original, and\nthe synthetic one).</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>If you do\nall your merges with <i>--squash</i>, make sure you also use\n<i>--squash</i> when you <i>split --rejoin</i>.</big></p>\n\n<h2>EXAMPLE 1. ADD COMMAND\n<a name=\"EXAMPLE 1. ADD COMMAND\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Let&rsquo;s\nassume that you have a local repository that you would like\nto add an external vendor library to. In this case we will\nadd the git-subtree repository as a subdirectory of your\nalready existing git-extensions repository in\n~/git-extensions/:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nsubtree add --prefix=git-subtree --squash \\ <br>\ngit://github.com/apenwarr/git-subtree.git master</big></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big><i>master</i>\nneeds to be a valid remote ref and can be a different branch\nname</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>You can\nomit the <i>--squash</i> flag, but doing so will increase\nthe number of commits that are included in your local\nrepository.</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>We now\nhave a ~/git-extensions/git-subtree directory containing\ncode from the master branch of\ngit://github.com/apenwarr/git-subtree.git in our\ngit-extensions repository.</big></p>\n\n<h2>EXAMPLE 2. EXTRACT A SUBTREE USING COMMIT, MERGE AND PULL\n<a name=\"EXAMPLE 2. EXTRACT A SUBTREE USING COMMIT, MERGE AND PULL\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Let&rsquo;s\nuse the repository for the git source code as an example.\nFirst, get your own copy of the git.git\nrepository:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nclone git://git.kernel.org/pub/scm/git/git.git test-git <br>\n$ cd test-git</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>gitweb\n(commit 1130ef3) was merged into git as of commit 0a8f4f0,\nafter which it was no longer maintained separately. But\nimagine it had been maintained separately, and we wanted to\nextract git&rsquo;s changes to gitweb since that time, to\nshare with the upstream. You could do this:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nsubtree split --prefix=gitweb --annotate='(split) ' \\ <br>\n0a8f4f0^.. --onto=1130ef3 --rejoin \\ <br>\n--branch gitweb-latest <br>\n$ gitk gitweb-latest <br>\n$ git push git@github.com:whatever/gitweb.git\ngitweb-latest:master</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>(We use\n<i>0a8f4f0^..</i> because that means &quot;all the changes\nfrom 0a8f4f0 to the current version, including 0a8f4f0\nitself.&quot;)</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>If gitweb\nhad originally been merged using <i>git subtree add</i> (or\na previous split had already been done with <i>--rejoin</i>\nspecified) then you can do all your splits without having to\nremember any weird commit IDs:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nsubtree split --prefix=gitweb --annotate='(split) ' --rejoin\n\\ <br>\n--branch gitweb-latest2</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>And you\ncan merge changes back in from the upstream project just as\neasily:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nsubtree pull --prefix=gitweb \\ <br>\ngit@github.com:whatever/gitweb.git master</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Or, using\n<i>--squash</i>, you can actually rewind to an earlier\nversion of gitweb:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nsubtree merge --prefix=gitweb --squash\ngitweb-latest~10</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Then make\nsome changes:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ date\n&gt;gitweb/myfile <br>\n$ git add gitweb/myfile <br>\n$ git commit -m 'created myfile'</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>And fast\nforward again:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nsubtree merge --prefix=gitweb --squash\ngitweb-latest</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>And notice\nthat your change is still intact:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ ls -l\ngitweb/myfile</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>And you\ncan split it out and look at your changes versus the\nstandard gitweb:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>git log\ngitweb-latest..$(git subtree split\n--prefix=gitweb)</big></p>\n\n<h2>EXAMPLE 3. EXTRACT A SUBTREE USING A BRANCH\n<a name=\"EXAMPLE 3. EXTRACT A SUBTREE USING A BRANCH\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Suppose\nyou have a source directory with many files and\nsubdirectories, and you want to extract the lib directory to\nits own git project. Here&rsquo;s a short way to do\nit:</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>First,\nmake the new repository wherever you want:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ &lt;go\nto the new location&gt; <br>\n$ git init --bare</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Back in\nyour original directory:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git\nsubtree split --prefix=lib --annotate=&quot;(split)&quot; -b\nsplit</big></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Then push\nthe new branch onto the new empty repository:</big></p>\n\n<p style=\"margin-left:17%; margin-top: 1em\"><big>$ git push\n&lt;new-repo&gt; split:master</big></p>\n\n<h2>AUTHOR\n<a name=\"AUTHOR\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><big>Written by\nAvery Pennarun\n&lt;<b><font color=\"#0000FF\">apenwarr@gmail.com</font></b></big>\n<font color=\"#000000\">[1] <big>&gt;</big></font></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><big>Part\nof the <a href=\"https://man.page/1/git\">git(1)</a> suite</big></font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\"><big>1.</big></font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"28%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\"><big>apenwarr@gmail.com</big></font></p> </td>\n<td width=\"55%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\"><big>mailto:apenwarr@gmail.com</big></font></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#COMMANDS\">COMMANDS</a>","<a href=\"#OPTIONS FOR ALL COMMANDS\">OPTIONS FOR ALL COMMANDS</a>","<a href=\"#OPTIONS FOR ADD AND MERGE (ALSO: PULL, SPLIT --REJOIN, AND PUSH --REJOIN)\">OPTIONS FOR ADD AND MERGE (ALSO: PULL, SPLIT --REJOIN, AND PUSH --REJOIN)</a>","<a href=\"#OPTIONS FOR SPLIT (ALSO: PUSH)\">OPTIONS FOR SPLIT (ALSO: PUSH)</a>","<a href=\"#EXAMPLE 1. ADD COMMAND\">EXAMPLE 1. ADD COMMAND</a>","<a href=\"#EXAMPLE 2. EXTRACT A SUBTREE USING COMMIT, MERGE AND PULL\">EXAMPLE 2. EXTRACT A SUBTREE USING COMMIT, MERGE AND PULL</a>","<a href=\"#EXAMPLE 3. EXTRACT A SUBTREE USING A BRANCH\">EXAMPLE 3. EXTRACT A SUBTREE USING A BRANCH</a>","<a href=\"#AUTHOR\">AUTHOR</a>","<a href=\"#GIT\">GIT</a>","<a href=\"#NOTES\">NOTES</a>"]}