{"name":"git-fast-export","body":"\n\n<h1 align=\"center\">GIT-FAST-EXPORT</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-fast-export\n- Git data exporter</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nfast-export [&lt;options&gt;]</i> | <i>git\nfast-import</i></p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">This program\ndumps the given revisions in a form suitable to be piped\ninto <i>git fast-import</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can use it\nas a human-readable bundle replacement (see\n<a href=\"https://man.page/1/git-bundle\">git-bundle(1)</a>), or as a format that can be edited\nbefore being fed to <i>git fast-import</i> in order to do\nhistory rewrites (an ability relied on by tools like <i>git\nfilter-repo</i>).</p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--progress=&lt;n&gt;</p>\n\n<p style=\"margin-left:17%;\">Insert <i>progress</i>\nstatements every &lt;n&gt; objects, to be shown by <i>git\nfast-import</i> during import.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--signed-tags=(verbatim|warn|warn-strip|strip|abort)</p>\n\n<p style=\"margin-left:17%;\">Specify how to handle signed\ntags. Since any transformation after the export can change\nthe tag names (which can also happen when excluding\nrevisions) the signatures will not match.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When asking to\n<i>abort</i> (which is the default), this program will die\nwhen encountering a signed tag. With <i>strip</i>, the tags\nwill silently be made unsigned, with <i>warn-strip</i> they\nwill be made unsigned but a warning will be displayed, with\n<i>verbatim</i>, they will be silently exported and with\n<i>warn</i>, they will be exported, but you will see a\nwarning.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--tag-of-filtered-object=(abort|drop|rewrite)</p>\n\n<p style=\"margin-left:17%;\">Specify how to handle tags\nwhose tagged object is filtered out. Since revisions and\nfiles to export can be limited by path, tagged objects may\nbe filtered completely.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">When asking to\n<i>abort</i> (which is the default), this program will die\nwhen encountering such a tag. With <i>drop</i> it will omit\nsuch tags from the output. With <i>rewrite</i>, if the\ntagged object is a commit, it will rewrite the tag to tag an\nancestor commit (via parent rewriting; see\n<a href=\"https://man.page/1/git-rev-list\">git-rev-list(1)</a>)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-M, -C</p>\n\n<p style=\"margin-left:17%;\">Perform move and/or copy\ndetection, as described in the <a href=\"https://man.page/1/git-diff\">git-diff(1)</a> manual\npage, and use it to generate rename and copy commands in the\noutput dump.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Note that\nearlier versions of this command did not complain and\nproduced incorrect results if you gave these options.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--export-marks=&lt;file&gt;</p>\n\n<p style=\"margin-left:17%;\">Dumps the internal marks table\nto &lt;file&gt; when complete. Marks are written one per\nline as <b>:markid SHA-1</b>. Only marks for revisions are\ndumped; marks for blobs are ignored. Backends can use this\nfile to validate imports after they have been completed, or\nto save the marks table across incremental runs. As\n&lt;file&gt; is only opened and truncated at completion, the\nsame path can also be safely given to --import-marks. The\nfile will not be written if no new object has been\nmarked/exported.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--import-marks=&lt;file&gt;</p>\n\n<p style=\"margin-left:17%;\">Before processing any input,\nload the marks specified in &lt;file&gt;. The input file\nmust exist, must be readable, and must use the same format\nas produced by --export-marks.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--mark-tags</p>\n\n<p style=\"margin-left:17%;\">In addition to labelling blobs\nand commits with mark ids, also label tags. This is useful\nin conjunction with <b>--export-marks</b> and\n<b>--import-marks</b>, and is also useful (and necessary)\nfor exporting of nested tags. It does not hurt other cases\nand would be the default, but many fast-import frontends are\nnot prepared to accept tags with mark identifiers.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">Any commits (or\ntags) that have already been marked will not be exported\nagain. If the backend uses a similar --import-marks file,\nthis allows for incremental bidirectional exporting of the\nrepository by keeping the marks the same across runs.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--fake-missing-tagger</p>\n\n<p style=\"margin-left:17%;\">Some old repositories have tags\nwithout a tagger. The fast-import protocol was pretty strict\nabout that, and did not allow that. So fake a tagger to be\nable to fast-import the output.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--use-done-feature</p>\n\n<p style=\"margin-left:17%;\">Start the stream with a\n<i>feature done</i> stanza, and terminate it with a\n<i>done</i> command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--no-data</p>\n\n<p style=\"margin-left:17%;\">Skip output of blob objects and\ninstead refer to blobs via their original SHA-1 hash. This\nis useful when rewriting the directory structure or history\nof a repository without touching the contents of individual\nfiles. Note that the resulting stream can only be used by a\nrepository which already contains the necessary objects.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--full-tree</p>\n\n<p style=\"margin-left:17%;\">This option will cause\nfast-export to issue a &quot;deleteall&quot; directive for\neach commit followed by a full list of all files in the\ncommit (as opposed to just listing the files which are\ndifferent from the commit&rsquo;s first parent).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--anonymize</p>\n\n<p style=\"margin-left:17%;\">Anonymize the contents of the\nrepository while still retaining the shape of the history\nand stored tree. See the section on <b>ANONYMIZING</b>\nbelow.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--anonymize-map=&lt;from&gt;[:&lt;to&gt;]</p>\n\n<p style=\"margin-left:17%;\">Convert token\n<b>&lt;from&gt;</b> to <b>&lt;to&gt;</b> in the anonymized\noutput. If <b>&lt;to&gt;</b> is omitted, map\n<b>&lt;from&gt;</b> to itself (i.e., do not anonymize it).\nSee the section on <b>ANONYMIZING</b> below.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--reference-excluded-parents</p>\n\n<p style=\"margin-left:17%;\">By default, running a command\nsuch as <b>git fast-export master~5..master</b> will not\ninclude the commit master~5 and will make master~4 no longer\nhave master~5 as a parent (though both the old master~4 and\nnew master~4 will have all the same files). Use\n--reference-excluded-parents to instead have the stream\nrefer to commits in the excluded range of history by their\nsha1sum. Note that the resulting stream can only be used by\na repository which already contains the necessary parent\ncommits.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--show-original-ids</p>\n\n<p style=\"margin-left:17%;\">Add an extra directive to the\noutput for commits and blobs, <b>original-oid\n&lt;SHA1SUM&gt;</b>. While such directives will likely be\nignored by importers such as git-fast-import, it may be\nuseful for intermediary filters (e.g. for rewriting commit\nmessages which refer to older commits, or for stripping\nblobs by id).</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--reencode=(yes|no|abort)</p>\n\n<p style=\"margin-left:17%;\">Specify how to handle\n<b>encoding</b> header in commit objects. When asking to\n<i>abort</i> (which is the default), this program will die\nwhen encountering such a commit object. With <i>yes</i>, the\ncommit message will be re-encoded into UTF-8. With\n<i>no</i>, the original encoding will be preserved.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--refspec</p>\n\n<p style=\"margin-left:17%;\">Apply the specified refspec to\neach ref exported. Multiple of them can be specified.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">[&lt;git-rev-list-args&gt;...]</p>\n\n<p style=\"margin-left:17%;\">A list of arguments, acceptable\nto <i>git rev-parse</i> and <i>git rev-list</i>, that\nspecifies the specific objects and references to export. For\nexample, <b>master~10..master</b> causes the current master\nreference to be exported along with all objects added since\nits 10th ancestor commit and (unless the\n--reference-excluded-parents option is specified) all files\ncommon to master~9 and master~10.</p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git\nfast-export --all | (cd /empty/repository &amp;&amp; git\nfast-import)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This will\nexport the whole repository and import it into the existing\nempty repository. Except for reencoding commits that are not\nin UTF-8, it would be a one-to-one mirror.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git\nfast-export master~5..master | <br>\nsed &quot;s|refs/heads/master|refs/heads/other|&quot; | <br>\ngit fast-import</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This makes a\nnew branch called <i>other</i> from <i>master~5..master</i>\n(i.e. if <i>master</i> has linear history, it will take the\nlast 5 commits).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that this\nassumes that none of the blobs and commit messages\nreferenced by that revision range contains the string\n<i>refs/heads/master</i>.</p>\n\n<h2>ANONYMIZING\n<a name=\"ANONYMIZING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\n<b>--anonymize</b> option is given, git will attempt to\nremove all identifying information from the repository while\nstill retaining enough of the original tree and history\npatterns to reproduce some bugs. The goal is that a git bug\nwhich is found on a private repository will persist in the\nanonymized repository, and the latter can be shared with git\ndevelopers to help solve the bug.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">With this\noption, git will replace all refnames, paths, blob contents,\ncommit and tag messages, names, and email addresses in the\noutput with anonymized data. Two instances of the same\nstring will be replaced equivalently (e.g., two commits with\nthe same author will have the same anonymized author in the\noutput, but bear no resemblance to the original author\nstring). The relationship between commits, branches, and\ntags is retained, as well as the commit timestamps (but the\ncommit messages and refnames bear no resemblance to the\noriginals). The relative makeup of the tree is retained\n(e.g., if you have a root tree with 10 files and 3 trees, so\nwill the output), but their names and the contents of the\nfiles will be replaced.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If you think\nyou have found a git bug, you can start by exporting an\nanonymized stream of the whole repository:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git\nfast-export --anonymize --all &gt;anon-stream</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then confirm\nthat the bug persists in a repository created from that\nstream (many bugs will not, as they really do depend on the\nexact repository contents):</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git init\nanon-repo <br>\n$ cd anon-repo <br>\n$ git fast-import &lt;../anon-stream <br>\n$ ... test your bug ...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If the\nanonymized repository shows the bug, it may be worth sharing\n<b>anon-stream</b> along with a regular bug report. Note\nthat the anonymized stream compresses very well, so gzipping\nit is encouraged. If you want to examine the stream to see\nthat it does not contain any private data, you can peruse it\ndirectly before sending. You may also want to try:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ perl -pe\n's/\\d+/X/g' &lt;anon-stream | sort -u | less</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">which shows all\nof the unique lines (with numbers converted to\n&quot;X&quot;, to collapse &quot;User 0&quot;, &quot;User\n1&quot;, etc into &quot;User X&quot;). This produces a much\nsmaller output, and it is usually easy to quickly confirm\nthat there is no private data in the stream.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Reproducing\nsome bugs may require referencing particular commits or\npaths, which becomes challenging after refnames and paths\nhave been anonymized. You can ask for a particular token to\nbe left as-is or mapped to a new value. For example, if you\nhave a bug which reproduces with <b>git rev-list sensitive\n-- secret.c</b>, you can run:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git\nfast-export --anonymize --all \\ <br>\n--anonymize-map=sensitive:foo \\ <br>\n--anonymize-map=secret.c:bar.c \\ <br>\n&gt;stream</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">After importing\nthe stream, you can then run <b>git rev-list foo --\nbar.c</b> in the anonymized repository.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that paths\nand refnames are split into tokens at slash boundaries. The\ncommand above would anonymize <b>subdir/secret.c</b> as\nsomething like <b>path123/bar.c</b>; you could then search\nfor <b>bar.c</b> in the anonymized repository to determine\nthe final pathname.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To make\nreferencing the final pathname simpler, you can map each\npath component; so if you also anonymize <b>subdir</b> to\n<b>publicdir</b>, then the final pathname would be\n<b>publicdir/bar.c</b>.</p>\n\n<h2>LIMITATIONS\n<a name=\"LIMITATIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Since <i>git\nfast-import</i> cannot tag trees, you will not be able to\nexport the linux.git repository completely, as it contains a\ntag referencing a tree instead of a commit.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/git-fast-import\">git-fast-import(1)</a></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Part of the\n<a href=\"https://man.page/1/git\">git(1)</a> suite</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#ANONYMIZING\">ANONYMIZING</a>","<a href=\"#LIMITATIONS\">LIMITATIONS</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#GIT\">GIT</a>"]}