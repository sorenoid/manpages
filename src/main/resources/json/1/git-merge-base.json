{"name":"git-merge-base","body":"\n\n<h1 align=\"center\">GIT-MERGE-BASE</h1>\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-merge-base\n- Find as good common ancestors as possible for a merge</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nmerge-base</i> [-a|--all] &lt;commit&gt; &lt;commit&gt;...\n<i><br>\ngit merge-base</i> [-a|--all] --octopus &lt;commit&gt;...\n<i><br>\ngit merge-base</i> --is-ancestor &lt;commit&gt;\n&lt;commit&gt; <i><br>\ngit merge-base</i> --independent &lt;commit&gt;... <i><br>\ngit merge-base</i> --fork-point &lt;ref&gt;\n[&lt;commit&gt;]</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nmerge-base</i> finds best common ancestor(s) between two\ncommits to use in a three-way merge. One common ancestor is\n<i>better</i> than another common ancestor if the latter is\nan ancestor of the former. A common ancestor that does not\nhave any better common ancestor is a <i>best common\nancestor</i>, i.e. a <i>merge base</i>. Note that there can\nbe more than one merge base for a pair of commits.</p>\n\n<h2>OPERATION MODES\n<a name=\"OPERATION MODES\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">As the most\ncommon special case, specifying only two commits on the\ncommand line means computing the merge base between the\ngiven two commits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">More generally,\namong the two commits to compute the merge base from, one is\nspecified by the first commit argument on the command line;\nthe other commit is a (possibly hypothetical) commit that is\na merge across all the remaining commits on the command\nline.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">As a\nconsequence, the <i>merge base</i> is not necessarily\ncontained in each of the commit arguments if more than two\ncommits are specified. This is different from\n<a href=\"https://man.page/1/git-show-branch\">git-show-branch(1)</a> when used with the\n<b>--merge-base</b> option.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--octopus</p>\n\n<p style=\"margin-left:17%;\">Compute the best common\nancestors of all supplied commits, in preparation for an\nn-way merge. This mimics the behavior of <i>git show-branch\n--merge-base</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--independent</p>\n\n<p style=\"margin-left:17%;\">Instead of printing merge\nbases, print a minimal subset of the supplied commits with\nthe same ancestors. In other words, among the commits given,\nlist those which cannot be reached from any other. This\nmimics the behavior of <i>git show-branch\n--independent</i>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--is-ancestor</p>\n\n<p style=\"margin-left:17%;\">Check if the first\n&lt;commit&gt; is an ancestor of the second &lt;commit&gt;,\nand exit with status 0 if true, or with status 1 if not.\nErrors are signaled by a non-zero status that is not 1.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--fork-point</p>\n\n<p style=\"margin-left:17%;\">Find the point at which a\nbranch (or any history that leads to &lt;commit&gt;) forked\nfrom another branch (or any reference) &lt;ref&gt;. This\ndoes not just look for the common ancestor of the two\ncommits, but also takes into account the reflog of\n&lt;ref&gt; to see if the history leading to &lt;commit&gt;\nforked from an earlier incarnation of the branch &lt;ref&gt;\n(see discussion on this mode below).</p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-a, --all</p>\n\n<p style=\"margin-left:17%;\">Output all merge bases for the\ncommits, instead of just one.</p>\n\n<h2>DISCUSSION\n<a name=\"DISCUSSION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given two\ncommits <i>A</i> and <i>B</i>, <b>git merge-base A B</b>\nwill output a commit which is reachable from both <i>A</i>\nand <i>B</i> through the parent relationship.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For example,\nwith this topology:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">o---o---o---B\n<br>\n/ <br>\n---o---1---o---o---o---A</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the merge base\nbetween <i>A</i> and <i>B</i> is <i>1</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Given three\ncommits <i>A</i>, <i>B</i> and <i>C</i>, <b>git merge-base A\nB C</b> will compute the merge base between <i>A</i> and a\nhypothetical commit <i>M</i>, which is a merge between\n<i>B</i> and <i>C</i>. For example, with this topology:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">o---o---o---o---C\n<br>\n/ <br>\n/ o---o---o---B <br>\n/ / <br>\n---2---1---o---o---o---A</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">the result of\n<b>git merge-base A B C</b> is <i>1</i>. This is because the\nequivalent topology with a merge commit <i>M</i> between\n<i>B</i> and <i>C</i> is:</p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\">o---o---o---o---o\n<br>\n/ \\ <br>\n/ o---o---o---o---M <br>\n/ / <br>\n---2---1---o---o---o---A</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and the result\nof <b>git merge-base A M</b> is <i>1</i>. Commit <i>2</i> is\nalso a common ancestor between <i>A</i> and <i>M</i>, but\n<i>1</i> is a better common ancestor, because <i>2</i> is an\nancestor of <i>1</i>. Hence, <i>2</i> is not a merge\nbase.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The result of\n<b>git merge-base --octopus A B C</b> is <i>2</i>, because\n<i>2</i> is the best common ancestor of all commits.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When the\nhistory involves criss-cross merges, there can be more than\none <i>best</i> common ancestor for two commits. For\nexample, with this topology:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">---1---o---A\n<br>\n\\ / <br>\nX <br>\n/ \\ <br>\n---2---o---o---B</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">both <i>1</i>\nand <i>2</i> are merge-bases of A and B. Neither one is\nbetter than the other (both are <i>best</i> merge bases).\nWhen the <b>--all</b> option is not given, it is unspecified\nwhich best one is output.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A common idiom\nto check &quot;fast-forward-ness&quot; between two commits A\nand B is (or at least used to be) to compute the merge base\nbetween A and B, and check if it is the same as A, in which\ncase, A is an ancestor of B. You will see this idiom used\noften in older scripts.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">A=$(git\nrev-parse --verify A) <br>\nif test &quot;$A&quot; = &quot;$(git merge-base A B)&quot;\n<br>\nthen <br>\n... A is an ancestor of B ... <br>\nfi</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In modern git,\nyou can say this in a more direct way:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">if git\nmerge-base --is-ancestor A B <br>\nthen <br>\n... A is an ancestor of B ... <br>\nfi</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">instead.</p>\n\n<h2>DISCUSSION ON FORK-POINT MODE\n<a name=\"DISCUSSION ON FORK-POINT MODE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">After working\non the <b>topic</b> branch created with <b>git switch -c\ntopic origin/master</b>, the history of remote-tracking\nbranch <b>origin/master</b> may have been rewound and\nrebuilt, leading to a history of this shape:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">o---B2 <br>\n/ <br>\n---o---o---B1--o---o---o---B (origin/master) <br>\n\\ <br>\nB0 <br>\n\\ <br>\nD0---D1---D (topic)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">where\n<b>origin/master</b> used to point at commits B0, B1, B2 and\nnow it points at B, and your <b>topic</b> branch was started\non top of it back when <b>origin/master</b> was at B0, and\nyou built three commits, D0, D1, and D, on top of it.\nImagine that you now want to rebase the work you did on the\ntopic on top of the updated origin/master.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In such a case,\n<b>git merge-base origin/master topic</b> would return the\nparent of B0 in the above picture, but B0^..D is <b>not</b>\nthe range of commits you would want to replay on top of B\n(it includes B0, which is not what you wrote; it is a commit\nthe other side discarded when it moved its tip from B0 to\nB1).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>git\nmerge-base --fork-point origin/master topic</b> is designed\nto help in such a case. It takes not only B but also B0, B1,\nand B2 (i.e. old tips of the remote-tracking branches your\nrepository&rsquo;s reflog knows about) into account to see\non which commit your topic branch was built and finds B0,\nallowing you to replay only the commits on your topic,\nexcluding the commits the other side later discarded.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Hence</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$\nfork_point=$(git merge-base --fork-point origin/master\ntopic)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">will find B0,\nand</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git rebase\n--onto origin/master $fork_point topic</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">will replay D0,\nD1 and D on top of B to create a new history of this\nshape:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">o---B2 <br>\n/ <br>\n---o---o---B1--o---o---o---B (origin/master) <br>\n\\ \\ <br>\nB0 D0'--D1'--D' (topic - updated) <br>\n\\ <br>\nD0---D1---D (topic - old)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A caveat is\nthat older reflog entries in your repository may be expired\nby <b>git gc</b>. If B0 no longer appears in the reflog of\nthe remote-tracking branch <b>origin/master</b>, the\n<b>--fork-point</b> mode obviously cannot find it and fails,\navoiding to give a random and useless result (such as the\nparent of B0, like the same command without the\n<b>--fork-point</b> option gives).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Also, the\nremote-tracking branch you use the <b>--fork-point</b> mode\nwith must be the one your topic forked from its tip. If you\nforked from an older commit than the tip, this mode would\nnot find the fork point (imagine in the above sample history\nB0 did not exist, origin/master started at B1, moved to B2\nand then B, and you forked your topic at origin/master^ when\norigin/master was B1; the shape of the history would be the\nsame as above, without B0, and the parent of B1 is what\n<b>git merge-base origin/master topic</b> correctly finds,\nbut the <b>--fork-point</b> mode will not, because it is not\none of the commits that used to be at the tip of\norigin/master).</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/git-rev-list\">git-rev-list(1)</a>,\n<a href=\"https://man.page/1/git-show-branch\">git-show-branch(1)</a>, <a href=\"https://man.page/1/git-merge\">git-merge(1)</a></p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Part of the\n<a href=\"https://man.page/1/git\">git(1)</a> suite</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OPERATION MODES\">OPERATION MODES</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#DISCUSSION\">DISCUSSION</a>","<a href=\"#DISCUSSION ON FORK-POINT MODE\">DISCUSSION ON FORK-POINT MODE</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#GIT\">GIT</a>"]}