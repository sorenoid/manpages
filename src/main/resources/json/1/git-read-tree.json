{"name":"git-read-tree","description":"git-read-tree -\nReads tree information into the index","body":"\n\n<h1 align=\"center\">GIT-READ-TREE</h1>\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">git-read-tree -\nReads tree information into the index</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nread-tree</i> [[-m [--trivial] [--aggressive] | --reset |\n--prefix=&lt;prefix&gt;] <br>\n[-u | -i]] [--index-output=&lt;file&gt;]\n[--no-sparse-checkout] <br>\n(--empty | &lt;tree-ish1&gt; [&lt;tree-ish2&gt;\n[&lt;tree-ish3&gt;]])</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Reads the tree\ninformation given by &lt;tree-ish&gt; into the index, but\ndoes not actually <b>update</b> any of the files it\n&quot;caches&quot;. (see: <a href=\"https://man.page/1/git-checkout-index\">git-checkout-index(1)</a>)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Optionally, it\ncan merge a tree into the index, perform a fast-forward\n(i.e. 2-way) merge, or a 3-way merge, with the <b>-m</b>\nflag. When used with <b>-m</b>, the <b>-u</b> flag causes it\nto also update the files in the work tree with the result of\nthe merge.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Trivial merges\nare done by <i>git read-tree</i> itself. Only conflicting\npaths will be in unmerged state when <i>git read-tree</i>\nreturns.</p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">-m</p>\n\n<p style=\"margin-left:17%;\">Perform a merge, not just a\nread. The command will refuse to run if your index file has\nunmerged entries, indicating that you have not finished\nprevious merge you started.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--reset</p>\n\n<p style=\"margin-left:17%;\">Same as -m, except that\nunmerged entries are discarded instead of failing. When used\nwith <b>-u</b>, updates leading to loss of working tree\nchanges or untracked files or directories will not abort the\noperation.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-u</p>\n\n<p style=\"margin-left:17%;\">After a successful merge,\nupdate the files in the work tree with the result of the\nmerge.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-i</p>\n\n<p style=\"margin-left:17%;\">Usually a merge requires the\nindex file as well as the files in the working tree to be up\nto date with the current head commit, in order not to lose\nlocal changes. This flag disables the check with the working\ntree and is meant to be used when creating a merge of trees\nthat are not directly related to the current working tree\nstatus into a temporary index file.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-n,\n--dry-run</p>\n\n<p style=\"margin-left:17%;\">Check if the command would\nerror out, without updating the index or the files in the\nworking tree for real.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-v</p>\n\n<p style=\"margin-left:17%;\">Show the progress of checking\nfiles out.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--trivial</p>\n\n<p style=\"margin-left:17%;\">Restrict three-way merge by\n<i>git read-tree</i> to happen only if there is no\nfile-level merging required, instead of resolving merge for\ntrivial cases and leaving conflicting files unresolved in\nthe index.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--aggressive</p>\n\n<p style=\"margin-left:17%;\">Usually a three-way merge by\n<i>git read-tree</i> resolves the merge for really trivial\ncases and leaves other cases unresolved in the index, so\nthat porcelains can implement different merge policies. This\nflag makes the command resolve a few more cases\ninternally:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&bull; when one\nside removes a path and the other side leaves the path\nunmodified. The resolution is to remove that path.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&bull; when\nboth sides remove a path. The resolution is to remove that\npath.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&bull; when\nboth sides add a path identically. The resolution is to add\nthat path.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--prefix=&lt;prefix&gt;</p>\n\n<p style=\"margin-left:17%;\">Keep the current index\ncontents, and read the contents of the named tree-ish under\nthe directory at <b>&lt;prefix&gt;</b>. The command will\nrefuse to overwrite entries that already existed in the\noriginal index file.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--index-output=&lt;file&gt;</p>\n\n<p style=\"margin-left:17%;\">Instead of writing the results\nout to <b>$GIT_INDEX_FILE</b>, write the resulting index in\nthe named file. While the command is operating, the original\nindex file is locked with the same mechanism as usual. The\nfile must allow to be rename(2)ed into from a temporary file\nthat is created next to the usual index file; typically this\nmeans it needs to be on the same filesystem as the index\nfile itself, and you need write permission to the\ndirectories the index file and index output file are located\nin.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--[no-]recurse-submodules</p>\n\n<p style=\"margin-left:17%;\">Using --recurse-submodules will\nupdate the content of all active submodules according to the\ncommit recorded in the superproject by calling read-tree\nrecursively, also setting the submodules' HEAD to be\ndetached at that commit.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">--no-sparse-checkout</p>\n\n<p style=\"margin-left:17%;\">Disable sparse checkout support\neven if <b>core.sparseCheckout</b> is true.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--empty</p>\n\n<p style=\"margin-left:17%;\">Instead of reading tree\nobject(s) into the index, just empty it.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-q, --quiet</p>\n\n<p style=\"margin-left:17%;\">Quiet, suppress feedback\nmessages.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&lt;tree-ish#&gt;</p>\n\n<p style=\"margin-left:17%;\">The id of the tree object(s) to\nbe read/merged.</p>\n\n<h2>MERGING\n<a name=\"MERGING\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">If <b>-m</b> is\nspecified, <i>git read-tree</i> can perform 3 kinds of\nmerge, a single tree merge if only 1 tree is given, a\nfast-forward merge with 2 trees, or a 3-way merge if 3 or\nmore trees are provided.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Single Tree\nMerge</b> <br>\nIf only 1 tree is specified, <i>git read-tree</i> operates\nas if the user did not specify <b>-m</b>, except that if the\noriginal index has an entry for a given pathname, and the\ncontents of the path match with the tree being read, the\nstat info from the index is used. (In other words, the\nindex&rsquo;s stat()s take precedence over the merged\ntree&rsquo;s).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">That means that\nif you do a <b>git read-tree -m &lt;newtree&gt;</b> followed\nby a <b>git checkout-index -f -u -a</b>, the <i>git\ncheckout-index</i> only checks out the stuff that really\nchanged.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is used to\navoid unnecessary false hits when <i>git diff-files</i> is\nrun after <i>git read-tree</i>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Two Tree\nMerge</b> <br>\nTypically, this is invoked as <b>git read-tree -m $H $M</b>,\nwhere $H is the head commit of the current repository, and\n$M is the head of a foreign tree, which is simply ahead of\n$H (i.e. we are in a fast-forward situation).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When two trees\nare specified, the user is telling <i>git read-tree</i> the\nfollowing:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">1. The current\nindex and work tree is derived from $H, but the user may\nhave local changes in them since $H.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">2. The user\nwants to fast-forward to $M.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In this case,\nthe <b>git read-tree -m $H $M</b> command makes sure that no\nlocal change is lost as the result of this\n&quot;merge&quot;. Here are the &quot;carry forward&quot;\nrules, where &quot;I&quot; denotes the index,\n&quot;clean&quot; means that index and work tree coincide,\nand &quot;exists&quot;/&quot;nothing&quot; refer to the\npresence of a path in the specified commit:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">I H M Result\n<br>\n------------------------------------------------------- <br>\n0 nothing nothing nothing (does not happen) <br>\n1 nothing nothing exists use M <br>\n2 nothing exists nothing remove path from index <br>\n3 nothing exists exists, use M if &quot;initial\ncheckout&quot;, <br>\nH == M keep index otherwise <br>\nexists, fail <br>\nH != M</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">clean I==H I==M\n<br>\n------------------ <br>\n4 yes N/A N/A nothing nothing keep index <br>\n5 no N/A N/A nothing nothing keep index</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">6 yes N/A yes\nnothing exists keep index <br>\n7 no N/A yes nothing exists keep index <br>\n8 yes N/A no nothing exists fail <br>\n9 no N/A no nothing exists fail</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">10 yes yes N/A\nexists nothing remove path from index <br>\n11 no yes N/A exists nothing fail <br>\n12 yes no N/A exists nothing fail <br>\n13 no no N/A exists nothing fail</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">clean (H==M)\n<br>\n------ <br>\n14 yes exists exists keep index <br>\n15 no exists exists keep index</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">clean I==H I==M\n(H!=M) <br>\n------------------ <br>\n16 yes no no exists exists fail <br>\n17 no no no exists exists fail <br>\n18 yes no yes exists exists keep index <br>\n19 no no yes exists exists keep index <br>\n20 yes yes no exists exists use M <br>\n21 no yes no exists exists fail</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In all\n&quot;keep index&quot; cases, the index entry stays as in\nthe original index file. If the entry is not up to date,\n<i>git read-tree</i> keeps the copy in the work tree intact\nwhen operating under the -u flag.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When this form\nof <i>git read-tree</i> returns successfully, you can see\nwhich of the &quot;local changes&quot; that you made were\ncarried forward by running <b>git diff-index --cached\n$M</b>. Note that this does not necessarily match what\n<b>git diff-index --cached $H</b> would have produced before\nsuch a two tree merge. This is because of cases 18 and 19\n--- if you already had the changes in $M (e.g. maybe you\npicked it up via e-mail in a patch form), <b>git diff-index\n--cached $H</b> would have told you about the change before\nthis merge, but it would not show in <b>git diff-index\n--cached $M</b> output after the two-tree merge.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Case 3 is\nslightly tricky and needs explanation. The result from this\nrule logically should be to remove the path if the user\nstaged the removal of the path and then switching to a new\nbranch. That however will prevent the initial checkout from\nhappening, so the rule is modified to use M (new tree) only\nwhen the content of the index is empty. Otherwise the\nremoval of the path is kept as long as $H and $M are the\nsame.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>3-Way\nMerge</b> <br>\nEach &quot;index&quot; entry has two bits worth of\n&quot;stage&quot; state. stage 0 is the normal one, and is\nthe only one you&rsquo;d see in any kind of normal use.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, when\nyou do <i>git read-tree</i> with three trees, the\n&quot;stage&quot; starts out at 1.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This means that\nyou can do</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git read-tree\n-m &lt;tree1&gt; &lt;tree2&gt; &lt;tree3&gt;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">and you will\nend up with an index with all of the &lt;tree1&gt; entries\nin &quot;stage1&quot;, all of the &lt;tree2&gt; entries in\n&quot;stage2&quot; and all of the &lt;tree3&gt; entries in\n&quot;stage3&quot;. When performing a merge of another\nbranch into the current branch, we use the common ancestor\ntree as &lt;tree1&gt;, the current branch head as\n&lt;tree2&gt;, and the other branch head as\n&lt;tree3&gt;.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Furthermore,\n<i>git read-tree</i> has special-case logic that says: if\nyou see a file that matches in all respects in the following\nstates, it &quot;collapses&quot; back to\n&quot;stage0&quot;:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; stage 2\nand 3 are the same; take one or the other (it makes no\ndifference - the same work has been done on our branch in\nstage 2 and their branch in stage 3)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; stage 1\nand stage 2 are the same and stage 3 is different; take\nstage 3 (our branch in stage 2 did not do anything since the\nancestor in stage 1 while their branch in stage 3 worked on\nit)</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; stage 1\nand stage 3 are the same and stage 2 is different take stage\n2 (we did something while they did nothing)</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <i>git\nwrite-tree</i> command refuses to write a nonsensical tree,\nand it will complain about unmerged entries if it sees a\nsingle entry that is not stage 0.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">OK, this all\nsounds like a collection of totally nonsensical rules, but\nit&rsquo;s actually exactly what you want in order to do a\nfast merge. The different stages represent the &quot;result\ntree&quot; (stage 0, aka &quot;merged&quot;), the original\ntree (stage 1, aka &quot;orig&quot;), and the two trees you\nare trying to merge (stage 2 and 3 respectively).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The order of\nstages 1, 2 and 3 (hence the order of three &lt;tree-ish&gt;\ncommand-line arguments) are significant when you start a\n3-way merge with an index file that is already populated.\nHere is an outline of how the algorithm works:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; if a\nfile exists in identical format in all three trees, it will\nautomatically collapse to &quot;merged&quot; state by <i>git\nread-tree</i>.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; a file\nthat has <i>any</i> difference what-so-ever in the three\ntrees will stay as separate entries in the index. It&rsquo;s\nup to &quot;porcelain policy&quot; to determine how to\nremove the non-0 stages, and insert a merged version.</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">&bull; the\nindex file saves and restores with all this information, so\nyou can merge things incrementally, but as long as it has\nentries in stages 1/2/3 (i.e., &quot;unmerged entries&quot;)\nyou can&rsquo;t write the result. So now the merge algorithm\nends up being really simple:</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&bull; you walk\nthe index in order, and ignore all entries of stage 0, since\nthey&rsquo;ve already been done.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&bull; if you\nfind a &quot;stage1&quot;, but no matching\n&quot;stage2&quot; or &quot;stage3&quot;, you know\nit&rsquo;s been removed from both trees (it only existed in\nthe original tree), and you remove that entry.</p>\n\n<p style=\"margin-left:23%; margin-top: 1em\">&bull; if you\nfind a matching &quot;stage2&quot; and &quot;stage3&quot;\ntree, you remove one of them, and turn the other into a\n&quot;stage0&quot; entry. Remove any matching\n&quot;stage1&quot; entry if it exists too. .. all the normal\ntrivial rules ..</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You would\nnormally use <i>git merge-index</i> with supplied <i>git\nmerge-one-file</i> to do this last step. The script updates\nthe files in the working tree as it merges each path and at\nthe end of a successful merge.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">When you start\na 3-way merge with an index file that is already populated,\nit is assumed that it represents the state of the files in\nyour work tree, and you can even have files with changes\nunrecorded in the index file. It is further assumed that\nthis state is &quot;derived&quot; from the stage 2 tree. The\n3-way merge refuses to run if it finds an entry in the\noriginal index file that does not match stage 2.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This is done to\nprevent you from losing your work-in-progress changes, and\nmixing your random changes in an unrelated merge commit. To\nillustrate, suppose you start from what has been committed\nlast to your repository:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ JC=&rsquo;git\nrev-parse --verify &quot;HEAD^0&quot;&rsquo; <br>\n$ git checkout-index -f -u -a $JC</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You do random\nedits, without running <i>git update-index</i>. And then you\nnotice that the tip of your &quot;upstream&quot; tree has\nadvanced since you pulled from him:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git fetch\ngit://.... linus <br>\n$ LT=&rsquo;git rev-parse FETCH_HEAD&rsquo;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Your work tree\nis still based on your HEAD ($JC), but you have some edits\nsince. Three-way merge makes sure that you have not added or\nmodified index entries since $JC, and if you haven&rsquo;t,\nthen does the right thing. So with the following\nsequence:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">$ git read-tree\n-m -u &rsquo;git merge-base $JC $LT&rsquo; $JC $LT <br>\n$ git merge-index git-merge-one-file -a <br>\n$ echo &quot;Merge with Linus&quot; | \\ <br>\ngit commit-tree &rsquo;git write-tree&rsquo; -p $JC -p\n$LT</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">what you would\ncommit is a pure merge between $JC and $LT without your\nwork-in-progress changes, and your work tree would be\nupdated to the result of the merge.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">However, if you\nhave local changes in the working tree that would be\noverwritten by this merge, <i>git read-tree</i> will refuse\nto run to prevent your changes from being lost.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In other words,\nthere is no need to worry about what exists only in the\nworking tree. When you have local changes in a part of the\nproject that is not involved in the merge, your changes do\nnot interfere with the merge, and are kept intact. When they\n<b>do</b> interfere, the merge does not even start (<i>git\nread-tree</i> complains loudly and fails without modifying\nanything). In such a case, you can simply continue doing\nwhat you were in the middle of doing, and when your working\ntree is ready (i.e. you have finished your\nwork-in-progress), attempt the merge again.</p>\n\n<h2>SPARSE CHECKOUT\n<a name=\"SPARSE CHECKOUT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">&quot;Sparse\ncheckout&quot; allows populating the working directory\nsparsely. It uses the skip-worktree bit (see\n<a href=\"https://man.page/1/git-update-index\">git-update-index(1)</a>) to tell Git whether a file in\nthe working directory is worth looking at.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>git\nread-tree</i> and other merge-based commands (<i>git\nmerge</i>, <i>git checkout</i>...) can help maintaining the\nskip-worktree bitmap and working directory update.\n<b>$GIT_DIR/info/sparse-checkout</b> is used to define the\nskip-worktree reference bitmap. When <i>git read-tree</i>\nneeds to update the working directory, it resets the\nskip-worktree bit in the index based on this file, which\nuses the same syntax as .gitignore files. If an entry\nmatches a pattern in this file, skip-worktree will not be\nset on that entry. Otherwise, skip-worktree will be set.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then it\ncompares the new skip-worktree value with the previous one.\nIf skip-worktree turns from set to unset, it will add the\ncorresponding file back. If it turns from unset to set, that\nfile will be removed.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">While\n<b>$GIT_DIR/info/sparse-checkout</b> is usually used to\nspecify what files are in, you can also specify what files\nare <i>not</i> in, using negate patterns. For example, to\nremove the file <b>unwanted</b>:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/* <br>\n!unwanted</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Another tricky\nthing is fully repopulating the working directory when you\nno longer want sparse checkout. You cannot just disable\n&quot;sparse checkout&quot; because skip-worktree bits are\nstill in the index and your working directory is still\nsparsely populated. You should re-populate the working\ndirectory with the <b>$GIT_DIR/info/sparse-checkout</b> file\ncontent as follows:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">/*</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then you can\ndisable sparse checkout. Sparse checkout support in <i>git\nread-tree</i> and similar commands is disabled by default.\nYou need to turn <b>core.sparseCheckout</b> on in order to\nhave sparse checkout support.</p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><a href=\"https://man.page/1/git-write-tree\">git-write-tree(1)</a>;\n<a href=\"https://man.page/1/git-ls-files\">git-ls-files(1)</a>; <a href=\"https://man.page/5/gitignore\">gitignore(5)</a>;\n<a href=\"https://man.page/1/git-sparse-checkout\">git-sparse-checkout(1)</a>;</p>\n\n<h2>GIT\n<a name=\"GIT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Part of the\n<a href=\"https://man.page/1/git\">git(1)</a> suite</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#MERGING\">MERGING</a>","<a href=\"#SPARSE CHECKOUT\">SPARSE CHECKOUT</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#GIT\">GIT</a>"]}