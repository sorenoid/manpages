{"name":"org.freedesktop.machine1","description":"org.freedesktop.machine1\n- The D-Bus interface of systemd-machined\n\n<h2>INTRODUCTION\n<a name=\"INTRODUCTION\"></a>\n</h2>\n\n\n\n<b>systemd-machined.service</b>(8)\nis a system service that keeps track of locally running\nvirtual machines and containers. This page describes the\nD-Bus interface.\n\n<h2>THE MANAGER OBJECT\n<a name=\"THE MANAGER OBJECT\"></a>\n</h2>\n\n\nThe service\nexposes the following interfaces on the Manager object on\nthe bus:\n\n<p style=\"margin-left:17%; margin-top: 1em\">node\n/org/freedesktop/machine1 { <br>\ninterface org.freedesktop.machine1.Manager { <br>\nmethods: <br>\nGetMachine(in s name, <br>\nout o machine); <br>\nGetImage(in s name, <br>\nout o image); <br>\nGetMachineByPID(in u pid, <br>\nout o machine); <br>\nListMachines(out a(ssso) machines); <br>\nListImages(out a(ssbttto) images); <br>\nCreateMachine(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nin a(sv) scope_properties, <br>\nout o path); <br>\nCreateMachineWithNetwork(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nin ai ifindices, <br>\nin a(sv) scope_properties, <br>\nout o path); <br>\nRegisterMachine(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nout o path); <br>\nRegisterMachineWithNetwork(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nin ai ifindices, <br>\nout o path); <br>\nUnregisterMachine(in s name); <br>\nTerminateMachine(in s id); <br>\nKillMachine(in s name, <br>\nin s who, <br>\nin i signal); <br>\nGetMachineAddresses(in s name, <br>\nout a(iay) addresses); <br>\nGetMachineOSRelease(in s name, <br>\nout a{ss} fields); <br>\nOpenMachinePTY(in s name, <br>\nout h pty, <br>\nout s pty_path); <br>\nOpenMachineLogin(in s name, <br>\nout h pty, <br>\nout s pty_path); <br>\nOpenMachineShell(in s name, <br>\nin s user, <br>\nin s path, <br>\nin as args, <br>\nin as environment, <br>\nout h pty, <br>\nout s pty_path); <br>\nBindMountMachine(in s name, <br>\nin s source, <br>\nin s destination, <br>\nin b read_only, <br>\nin b mkdir); <br>\nCopyFromMachine(in s name, <br>\nin s source, <br>\nin s destination); <br>\nCopyToMachine(in s name, <br>\nin s source, <br>\nin s destination); <br>\nOpenMachineRootDirectory(in s name, <br>\nout h fd); <br>\nGetMachineUIDShift(in s name, <br>\nout u shift); <br>\nRemoveImage(in s name); <br>\nRenameImage(in s name, <br>\nin s new_name); <br>\nCloneImage(in s name, <br>\nin s new_name, <br>\nin b read_only); <br>\nMarkImageReadOnly(in s name, <br>\nin b read_only); <br>\nGetImageHostname(in s name, <br>\nout s hostname); <br>\nGetImageMachineID(in s name, <br>\nout ay id); <br>\nGetImageMachineInfo(in s name, <br>\nout a{ss} machine_info); <br>\nGetImageOSRelease(in s name, <br>\nout a{ss} os_release); <br>\nSetPoolLimit(in t size); <br>\nSetImageLimit(in s name, <br>\nin t size); <br>\nCleanPool(in s mode, <br>\nout a(st) images); <br>\nMapFromMachineUser(in s name, <br>\nin u uid_inner, <br>\nout u uid_outer); <br>\nMapToMachineUser(in u uid_outer, <br>\nout s machine_name, <br>\nout o machine_path, <br>\nout u uid_inner); <br>\nMapFromMachineGroup(in s name, <br>\nin u gid_inner, <br>\nout u gid_outer); <br>\nMapToMachineGroup(in u gid_outer, <br>\nout s machine_name, <br>\nout o machine_path, <br>\nout u gid_inner); <br>\nsignals: <br>\nMachineNew(s machine, <br>\no path); <br>\nMachineRemoved(s machine, <br>\no path); <br>\nproperties: <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly s PoolPath = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly t PoolUsage = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly t PoolLimit = ...; <br>\n}; <br>\ninterface org.freedesktop.DBus.Peer { ... }; <br>\ninterface org.freedesktop.DBus.Introspectable { ... }; <br>\ninterface org.freedesktop.DBus.Properties { ... }; <br>\n};\n\n<b>Methods <br>\nGetMachine()</b> may be used to get the machine object path\nfor the machine with the specified name. Similarly,\n<b>GetMachineByPID()</b> gets the machine object the\nspecified PID belongs to if there is any.\n\n\n<b>GetImage()</b>\nmay be used to get the image object path of the image with\nthe specified name.\n\n\n<b>ListMachines()</b>\nreturns an array of all currently registered machines. The\nstructures in the array consist of the following fields:\nmachine name, machine class, an identifier for the service\nthat registered the machine and the machine object path.\n\n\n<b>ListImages()</b>\nreturns an array of all currently known images. The\nstructures in the array consist of the following fields:\nimage name, type, read-only flag, creation time,\nmodification time, current disk space, and image object\npath.\n\n\n<b>CreateMachine()</b>\nmay be used to register a new virtual machine or container\nwith <b>systemd-machined</b>, creating a scope unit for it.\nIt accepts the following arguments: a machine name chosen by\nthe registrar, an optional UUID as a 32 byte array, a string\nthat identifies the service that registers the machine, a\nclass string, the PID of the leader process of the machine,\nan optional root directory of the container, and an array of\nadditional properties to use for the scope registration. The\nvirtual machine name must be suitable as a hostname, and\nhence should follow the usual DNS hostname rules, as well as\nthe Linux hostname restrictions. Specifically, only 7 bit\nASCII is permitted, a maximum length of 64 characters is\nenforced, only characters from the set\n&quot;a-zA-Z0-9-_.&quot; are allowed, the name may not begin\nwith a dot, and it may not contain two dots immediately\nfollowing each other. Container and VM managers should\nideally use the hostname used internally in the machine for\nthis parameter. This recommendation is made in order to make\nthe machine name naturally resolvable using\n<b>nss-mymachines</b>(8). If a container manager needs to\nembed characters outside of the indicated range, escaping is\nrequired, possibly using &quot;_&quot; as the escape\ncharacter. Another (somewhat natural) option would be to\nutilize Internet IDNA encoding. The UUID is passed as a 32\nbyte array or, if no suitable UUID is available, an empty\narray (zero length) or zeroed out array shall be passed. The\nUUID should identify the virtual machine/container uniquely\nand should ideally be the same UUID that /etc/machine-id in\nthe VM/container is initialized from. The service string can\nbe free-form, but it is recommended to pass a short\nlowercase identifier like &quot;systemd-nspawn&quot;,\n&quot;libvirt-lxc&quot; or similar. The class string should\nbe either &quot;container&quot; or &quot;vm&quot; indicating\nwhether the machine to register is of the respective class.\nThe leader PID should be the host PID of the init process of\nthe container or the encapsulating process of the VM. If the\nroot directory of the container is known and available in\nthe host's hierarchy, it should be passed. Otherwise, pass\nthe empty string instead. Finally, the scope properties are\npassed as array in the same way as to PID1's\n<b>StartTransientUnit()</b> method. Calling this method will\ninternally register a transient scope unit for the calling\nclient (utilizing the passed scope_properties) and move the\nleader PID into it. The method returns an object path for\nthe registered machine object that implements the\norg.freedesktop.machine1.Machine interface (see below). Also\nsee the <b><font color=\"#0000FF\">New Control Group\nInterfaces</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">for details about scope units and how\nto alter resource control settings on the created machine at\nruntime.</font>\n\n\n<font color=\"#000000\"><b>RegisterMachine()</b>\nis similar to <b>CreateMachine()</b>. However, it only\nregisters a machine and does not create a scope unit for it.\nInstead, the caller's unit is registered. We recommend to\nonly use this method for container or VM managers that are\nrun multiple times, one instance for each container/VM they\nmanage, and are invoked as system services.</font>\n\n\n<font color=\"#000000\"><b>CreateMachineWithNetwork()</b>\nand <b>RegisterMachineWithNetwork()</b> are similar to\n<b>CreateMachine()</b> and <b>RegisterMachine()</b> but take\nan extra argument: an array of network interface indices\nthat point towards the virtual machine or container. The\ninterface indices should reference one or more network\ninterfaces on the host that can be used to communicate with\nthe guest. Commonly, the passed interface index refers to\nthe host side of a &quot;veth&quot; link (in case of\ncontainers), a &quot;tun&quot;/&quot;tap&quot; link (in case\nof VMs), or the host side of a bridge interface that bridges\naccess to the VM/container interfaces. Specifying this\ninformation is useful to enable support for link-local IPv6\ncommunication to the machines since the scope field of\nsockaddr_in6 can be initialized by the specified ifindex.\n<b>nss-mymachines</b>(8) makes use of this\ninformation.</font>\n\n\n<font color=\"#000000\"><b>KillMachine()</b>\nsends a UNIX signal to the machine's processes. As its\narguments, it takes a machine name (as originally passed to\n<b>CreateMachine()</b> or returned by\n<b>ListMachines()</b>), an identifier that specifies what\nprecisely to send the signal to (either &quot;leader&quot;\nor &quot;all&quot;), and a numeric UNIX signal\ninteger.</font>\n\n\n<font color=\"#000000\"><b>TerminateMachine()</b>\nterminates a virtual machine, killing its processes. It\ntakes a machine name as its only argument.</font>\n\n\n<font color=\"#000000\"><b>GetMachineAddresses()</b>\nretrieves the IP addresses of a container. This method\nreturns an array of pairs consisting of an address family\nspecifier (<b>AF_INET</b> or <b>AF_INET6</b>) and a byte\narray containing the addresses. This is only supported for\ncontainers that make use of network namespacing.</font>\n\n\n<font color=\"#000000\"><b>GetMachineOSRelease()</b>\nretrieves the OS release information of a container. This\nmethod returns an array of key value pairs read from the\n<a href=\"https://man.page/5/os-release\">os-release(5)</a> file in the container and is useful to\nidentify the operating system used in a\ncontainer.</font>\n\n\n<font color=\"#000000\"><b>OpenMachinePTY()</b>\nallocates a pseudo TTY in the container and returns a file\ndescriptor and its path. This is equivalent to transitioning\ninto the container and invoking\n<a href=\"https://man.page/3/posix_openpt\">posix_openpt(3)</a>.</font>\n\n\n<font color=\"#000000\"><b>OpenMachineLogin()</b>\nallocates a pseudo TTY in the container and ensures that a\ngetty login prompt of the container is running on the other\nend. It returns the file descriptor of the PTY and the PTY\npath. This is useful for acquiring a pty with a login prompt\nfrom the container.</font>\n\n\n<font color=\"#000000\"><b>OpenMachineShell()</b>\nallocates a pseudo TTY in the container, as the specified\nuser, and invokes the executable at the specified path with\na list of arguments (starting from argv[0]) and an\nenvironment block. It then returns the file descriptor of\nthe PTY and the PTY path.</font>\n\n\n<font color=\"#000000\"><b>BindMountMachine()</b>\nbind mounts a file or directory from the host into the\ncontainer. Its arguments consist of a machine name, the\nsource directory on the host, the destination directory in\nthe container, and two booleans, one indicating whether the\nbind mount shall be read-only, the other indicating whether\nthe destination mount point shall be created first, if it is\nmissing.</font>\n\n\n<font color=\"#000000\"><b>CopyFromMachine()</b>\ncopies files or directories from a container into the host.\nIt takes a container name, a source directory in the\ncontainer and a destination directory on the host as\narguments. <b>CopyToMachine()</b> does the opposite and\ncopies files from a source directory on the host into a\ndestination directory in the container.</font>\n\n\n<font color=\"#000000\"><b>RemoveImage()</b>\nremoves the image with the specified name.</font>\n\n\n<font color=\"#000000\"><b>RenameImage()</b>\nrenames the specified image.</font>\n\n\n<font color=\"#000000\"><b>CloneImage()</b>\nclones the specified image under a new name. It also takes a\nboolean argument indicating whether the resulting image\nshall be read-only or not.</font>\n\n\n<font color=\"#000000\"><b>MarkImageReadOnly()</b>\ntoggles the read-only flag of an image.</font>\n\n\n<font color=\"#000000\"><b>SetPoolLimit()</b>\nsets an overall quota limit on the pool of\nimages.</font>\n\n\n<font color=\"#000000\"><b>SetImageLimit()</b>\nsets a per-image quota limit.</font>\n\n\n<font color=\"#000000\"><b>MapFromMachineUser()</b>,\n<b>MapToMachineUser()</b>, <b>MapFromMachineGroup()</b>, and\n<b>MapToMachineGroup()</b> may be used to map UIDs/GIDs from\nthe host user namespace to a container user namespace or\nvice versa.</font>\n\n\n<font color=\"#000000\"><b>Signals\n<br>\nMachineNew</b> and <b>MachineRemoved</b> are sent whenever a\nnew machine is registered or removed. These signals carry\nthe machine name and the object path to the corresponding\norg.freedesktop.machine1.Machine interface (see\nbelow).</font>\n\n\n<font color=\"#000000\"><b>Properties</b>\n<i><br>\nPoolPath</i> specifies the file system path where images are\nwritten to.</font>\n\n\n<font color=\"#000000\"><i>PoolUsage</i>\nspecifies the current usage size of the image pool in\nbytes.</font>\n\n\n<font color=\"#000000\"><i>PoolLimit</i>\nspecifies the size limit of the image pool in\nbytes.</font>\n\n<h2>MACHINE OBJECTS\n<a name=\"MACHINE OBJECTS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">node\n/org/freedesktop/machine1/machine/rawhide { <br>\ninterface org.freedesktop.machine1.Machine { <br>\nmethods: <br>\nTerminate(); <br>\nKill(in s who, <br>\nin i signal); <br>\nGetAddresses(out a(iay) addresses); <br>\nGetOSRelease(out a{ss} fields); <br>\nGetUIDShift(out u shift); <br>\nOpenPTY(out h pty, <br>\nout s pty_path); <br>\nOpenLogin(out h pty, <br>\nout s pty_path); <br>\nOpenShell(in s user, <br>\nin s path, <br>\nin as args, <br>\nin as environment, <br>\nout h pty, <br>\nout s pty_path); <br>\nBindMount(in s source, <br>\nin s destination, <br>\nin b read_only, <br>\nin b mkdir); <br>\nCopyFrom(in s source, <br>\nin s destination); <br>\nCopyTo(in s source, <br>\nin s destination); <br>\nOpenRootDirectory(out h fd); <br>\nproperties: <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Name = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly ay Id = [...]; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly t Timestamp = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly t TimestampMonotonic = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Service = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Unit = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly u Leader = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Class = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s RootDirectory = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly ai NetworkInterfaces = [...]; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly s State = '...'; <br>\n}; <br>\ninterface org.freedesktop.DBus.Peer { ... }; <br>\ninterface org.freedesktop.DBus.Introspectable { ... }; <br>\ninterface org.freedesktop.DBus.Properties { ... }; <br>\n};</font>\n\n\n<font color=\"#000000\"><b>Methods\n<br>\nTerminate()</b> and <b>Kill()</b> terminate/kill the\nmachine. These methods take the same arguments as\n<b>TerminateMachine()</b> and <b>KillMachine()</b> on the\nManager interface, respectively.</font>\n\n\n<font color=\"#000000\"><b>GetAddresses()</b>\nand <b>GetOSRelease()</b> get the IP address and OS release\ninformation from the machine. These methods take the same\narguments as <b>GetMachineAddresses()</b> and\n<b>GetMachineOSRelease()</b> of the Manager interface,\nrespectively.</font>\n\n\n<font color=\"#000000\"><b>Properties</b>\n<i><br>\nName</i> is the machine name as it was passed in during\nregistration with <b>CreateMachine()</b> on the manager\nobject.</font>\n\n\n<font color=\"#000000\"><i>Id</i>\nis the machine UUID.</font>\n\n\n<font color=\"#000000\"><i>Timestamp</i>\nand <i>TimestampMonotonic</i> are the realtime and monotonic\ntimestamps when the virtual machines where created in\nmicroseconds since the epoch.</font>\n\n\n<font color=\"#000000\"><i>Service</i>\ncontains a short string identifying the registering service\nas passed in during registration of the machine.</font>\n\n\n<font color=\"#000000\"><i>Unit</i>\nis the systemd scope or service unit name for the\nmachine.</font>\n\n\n<font color=\"#000000\"><i>Leader</i>\nis the PID of the leader process of the machine.</font>\n\n\n<font color=\"#000000\"><i>Class</i>\nis the class of the machine and is either the string\n&quot;vm&quot; (for real VMs based on virtualized hardware)\nor &quot;container&quot; (for light-weight userspace\nvirtualization sharing the same kernel as the\nhost).</font>\n\n\n<font color=\"#000000\"><i>RootDirectory</i>\nis the root directory of the container if it is known and\napplicable or the empty string.</font>\n\n\n<font color=\"#000000\"><i>NetworkInterfaces</i>\ncontains an array of network interface indices that point\ntowards the container, the VM or the host. For details about\nthis information see the description of\n<b>CreateMachineWithNetwork()</b> above.</font>\n\n\n<font color=\"#000000\"><i>State</i>\nis the state of the machine and is one of\n&quot;opening&quot;, &quot;running&quot;, or\n&quot;closing&quot;. Note that the state machine is not\nconsidered part of the API and states might be removed or\nadded without this being considered API breakage.</font>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n\n<font color=\"#000000\"><b>Example&nbsp;1.&nbsp;Introspect\norg.freedesktop.machine1.Manager on the bus</b></font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngdbus introspect --system \\ <br>\n--dest org.freedesktop.machine1 \\ <br>\n--object-path /org/freedesktop/machine1</font>\n\n\n<font color=\"#000000\"><b>Example&nbsp;2.&nbsp;Introspect\norg.freedesktop.machine1.Machine on the bus</b></font>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngdbus introspect --system \\ <br>\n--dest org.freedesktop.machine1 \\ <br>\n--object-path\n/org/freedesktop/machine1/machine/rawhide</font>\n\n<h2>VERSIONING\n<a name=\"VERSIONING\"></a>\n</h2>\n\n\n\n<font color=\"#000000\">These\nD-Bus interfaces follow</font> <b><font color=\"#0000FF\">the\nusual interface versioning guidelines</font></b>\n<small><font color=\"#000000\">[2]</font></small>\n<font color=\"#000000\">.</font>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">1.</font> </td>\n<td width=\"2%\"></td>\n<td width=\"43%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">New\nControl Group Interfaces</font></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://www.freedesktop.org/wiki/Software/systemd/ControlGroupInterface/</font>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">2.</font> </td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">the usual\ninterface versioning guidelines</font></td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">http://0pointer.de/blog/projects/versioning-dbus.html</font>","body":"\n\n<h1 align=\"center\">ORG.FREEDESKTOP.MACHINE1</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">org.freedesktop.machine1\n- The D-Bus interface of systemd-machined</p>\n\n<h2>INTRODUCTION\n<a name=\"INTRODUCTION\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>systemd-machined.service</b>(8)\nis a system service that keeps track of locally running\nvirtual machines and containers. This page describes the\nD-Bus interface.</p>\n\n<h2>THE MANAGER OBJECT\n<a name=\"THE MANAGER OBJECT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The service\nexposes the following interfaces on the Manager object on\nthe bus:</p>\n\n<p style=\"margin-left:17%; margin-top: 1em\">node\n/org/freedesktop/machine1 { <br>\ninterface org.freedesktop.machine1.Manager { <br>\nmethods: <br>\nGetMachine(in s name, <br>\nout o machine); <br>\nGetImage(in s name, <br>\nout o image); <br>\nGetMachineByPID(in u pid, <br>\nout o machine); <br>\nListMachines(out a(ssso) machines); <br>\nListImages(out a(ssbttto) images); <br>\nCreateMachine(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nin a(sv) scope_properties, <br>\nout o path); <br>\nCreateMachineWithNetwork(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nin ai ifindices, <br>\nin a(sv) scope_properties, <br>\nout o path); <br>\nRegisterMachine(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nout o path); <br>\nRegisterMachineWithNetwork(in s name, <br>\nin ay id, <br>\nin s service, <br>\nin s class, <br>\nin u leader, <br>\nin s root_directory, <br>\nin ai ifindices, <br>\nout o path); <br>\nUnregisterMachine(in s name); <br>\nTerminateMachine(in s id); <br>\nKillMachine(in s name, <br>\nin s who, <br>\nin i signal); <br>\nGetMachineAddresses(in s name, <br>\nout a(iay) addresses); <br>\nGetMachineOSRelease(in s name, <br>\nout a{ss} fields); <br>\nOpenMachinePTY(in s name, <br>\nout h pty, <br>\nout s pty_path); <br>\nOpenMachineLogin(in s name, <br>\nout h pty, <br>\nout s pty_path); <br>\nOpenMachineShell(in s name, <br>\nin s user, <br>\nin s path, <br>\nin as args, <br>\nin as environment, <br>\nout h pty, <br>\nout s pty_path); <br>\nBindMountMachine(in s name, <br>\nin s source, <br>\nin s destination, <br>\nin b read_only, <br>\nin b mkdir); <br>\nCopyFromMachine(in s name, <br>\nin s source, <br>\nin s destination); <br>\nCopyToMachine(in s name, <br>\nin s source, <br>\nin s destination); <br>\nOpenMachineRootDirectory(in s name, <br>\nout h fd); <br>\nGetMachineUIDShift(in s name, <br>\nout u shift); <br>\nRemoveImage(in s name); <br>\nRenameImage(in s name, <br>\nin s new_name); <br>\nCloneImage(in s name, <br>\nin s new_name, <br>\nin b read_only); <br>\nMarkImageReadOnly(in s name, <br>\nin b read_only); <br>\nGetImageHostname(in s name, <br>\nout s hostname); <br>\nGetImageMachineID(in s name, <br>\nout ay id); <br>\nGetImageMachineInfo(in s name, <br>\nout a{ss} machine_info); <br>\nGetImageOSRelease(in s name, <br>\nout a{ss} os_release); <br>\nSetPoolLimit(in t size); <br>\nSetImageLimit(in s name, <br>\nin t size); <br>\nCleanPool(in s mode, <br>\nout a(st) images); <br>\nMapFromMachineUser(in s name, <br>\nin u uid_inner, <br>\nout u uid_outer); <br>\nMapToMachineUser(in u uid_outer, <br>\nout s machine_name, <br>\nout o machine_path, <br>\nout u uid_inner); <br>\nMapFromMachineGroup(in s name, <br>\nin u gid_inner, <br>\nout u gid_outer); <br>\nMapToMachineGroup(in u gid_outer, <br>\nout s machine_name, <br>\nout o machine_path, <br>\nout u gid_inner); <br>\nsignals: <br>\nMachineNew(s machine, <br>\no path); <br>\nMachineRemoved(s machine, <br>\no path); <br>\nproperties: <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly s PoolPath = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly t PoolUsage = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly t PoolLimit = ...; <br>\n}; <br>\ninterface org.freedesktop.DBus.Peer { ... }; <br>\ninterface org.freedesktop.DBus.Introspectable { ... }; <br>\ninterface org.freedesktop.DBus.Properties { ... }; <br>\n};</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>Methods <br>\nGetMachine()</b> may be used to get the machine object path\nfor the machine with the specified name. Similarly,\n<b>GetMachineByPID()</b> gets the machine object the\nspecified PID belongs to if there is any.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>GetImage()</b>\nmay be used to get the image object path of the image with\nthe specified name.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ListMachines()</b>\nreturns an array of all currently registered machines. The\nstructures in the array consist of the following fields:\nmachine name, machine class, an identifier for the service\nthat registered the machine and the machine object path.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ListImages()</b>\nreturns an array of all currently known images. The\nstructures in the array consist of the following fields:\nimage name, type, read-only flag, creation time,\nmodification time, current disk space, and image object\npath.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CreateMachine()</b>\nmay be used to register a new virtual machine or container\nwith <b>systemd-machined</b>, creating a scope unit for it.\nIt accepts the following arguments: a machine name chosen by\nthe registrar, an optional UUID as a 32 byte array, a string\nthat identifies the service that registers the machine, a\nclass string, the PID of the leader process of the machine,\nan optional root directory of the container, and an array of\nadditional properties to use for the scope registration. The\nvirtual machine name must be suitable as a hostname, and\nhence should follow the usual DNS hostname rules, as well as\nthe Linux hostname restrictions. Specifically, only 7 bit\nASCII is permitted, a maximum length of 64 characters is\nenforced, only characters from the set\n&quot;a-zA-Z0-9-_.&quot; are allowed, the name may not begin\nwith a dot, and it may not contain two dots immediately\nfollowing each other. Container and VM managers should\nideally use the hostname used internally in the machine for\nthis parameter. This recommendation is made in order to make\nthe machine name naturally resolvable using\n<b>nss-mymachines</b>(8). If a container manager needs to\nembed characters outside of the indicated range, escaping is\nrequired, possibly using &quot;_&quot; as the escape\ncharacter. Another (somewhat natural) option would be to\nutilize Internet IDNA encoding. The UUID is passed as a 32\nbyte array or, if no suitable UUID is available, an empty\narray (zero length) or zeroed out array shall be passed. The\nUUID should identify the virtual machine/container uniquely\nand should ideally be the same UUID that /etc/machine-id in\nthe VM/container is initialized from. The service string can\nbe free-form, but it is recommended to pass a short\nlowercase identifier like &quot;systemd-nspawn&quot;,\n&quot;libvirt-lxc&quot; or similar. The class string should\nbe either &quot;container&quot; or &quot;vm&quot; indicating\nwhether the machine to register is of the respective class.\nThe leader PID should be the host PID of the init process of\nthe container or the encapsulating process of the VM. If the\nroot directory of the container is known and available in\nthe host's hierarchy, it should be passed. Otherwise, pass\nthe empty string instead. Finally, the scope properties are\npassed as array in the same way as to PID1's\n<b>StartTransientUnit()</b> method. Calling this method will\ninternally register a transient scope unit for the calling\nclient (utilizing the passed scope_properties) and move the\nleader PID into it. The method returns an object path for\nthe registered machine object that implements the\norg.freedesktop.machine1.Machine interface (see below). Also\nsee the <b><font color=\"#0000FF\">New Control Group\nInterfaces</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">for details about scope units and how\nto alter resource control settings on the created machine at\nruntime.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>RegisterMachine()</b>\nis similar to <b>CreateMachine()</b>. However, it only\nregisters a machine and does not create a scope unit for it.\nInstead, the caller's unit is registered. We recommend to\nonly use this method for container or VM managers that are\nrun multiple times, one instance for each container/VM they\nmanage, and are invoked as system services.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>CreateMachineWithNetwork()</b>\nand <b>RegisterMachineWithNetwork()</b> are similar to\n<b>CreateMachine()</b> and <b>RegisterMachine()</b> but take\nan extra argument: an array of network interface indices\nthat point towards the virtual machine or container. The\ninterface indices should reference one or more network\ninterfaces on the host that can be used to communicate with\nthe guest. Commonly, the passed interface index refers to\nthe host side of a &quot;veth&quot; link (in case of\ncontainers), a &quot;tun&quot;/&quot;tap&quot; link (in case\nof VMs), or the host side of a bridge interface that bridges\naccess to the VM/container interfaces. Specifying this\ninformation is useful to enable support for link-local IPv6\ncommunication to the machines since the scope field of\nsockaddr_in6 can be initialized by the specified ifindex.\n<b>nss-mymachines</b>(8) makes use of this\ninformation.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>KillMachine()</b>\nsends a UNIX signal to the machine's processes. As its\narguments, it takes a machine name (as originally passed to\n<b>CreateMachine()</b> or returned by\n<b>ListMachines()</b>), an identifier that specifies what\nprecisely to send the signal to (either &quot;leader&quot;\nor &quot;all&quot;), and a numeric UNIX signal\ninteger.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>TerminateMachine()</b>\nterminates a virtual machine, killing its processes. It\ntakes a machine name as its only argument.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>GetMachineAddresses()</b>\nretrieves the IP addresses of a container. This method\nreturns an array of pairs consisting of an address family\nspecifier (<b>AF_INET</b> or <b>AF_INET6</b>) and a byte\narray containing the addresses. This is only supported for\ncontainers that make use of network namespacing.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>GetMachineOSRelease()</b>\nretrieves the OS release information of a container. This\nmethod returns an array of key value pairs read from the\n<a href=\"https://man.page/5/os-release\">os-release(5)</a> file in the container and is useful to\nidentify the operating system used in a\ncontainer.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>OpenMachinePTY()</b>\nallocates a pseudo TTY in the container and returns a file\ndescriptor and its path. This is equivalent to transitioning\ninto the container and invoking\n<a href=\"https://man.page/3/posix_openpt\">posix_openpt(3)</a>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>OpenMachineLogin()</b>\nallocates a pseudo TTY in the container and ensures that a\ngetty login prompt of the container is running on the other\nend. It returns the file descriptor of the PTY and the PTY\npath. This is useful for acquiring a pty with a login prompt\nfrom the container.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>OpenMachineShell()</b>\nallocates a pseudo TTY in the container, as the specified\nuser, and invokes the executable at the specified path with\na list of arguments (starting from argv[0]) and an\nenvironment block. It then returns the file descriptor of\nthe PTY and the PTY path.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>BindMountMachine()</b>\nbind mounts a file or directory from the host into the\ncontainer. Its arguments consist of a machine name, the\nsource directory on the host, the destination directory in\nthe container, and two booleans, one indicating whether the\nbind mount shall be read-only, the other indicating whether\nthe destination mount point shall be created first, if it is\nmissing.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>CopyFromMachine()</b>\ncopies files or directories from a container into the host.\nIt takes a container name, a source directory in the\ncontainer and a destination directory on the host as\narguments. <b>CopyToMachine()</b> does the opposite and\ncopies files from a source directory on the host into a\ndestination directory in the container.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>RemoveImage()</b>\nremoves the image with the specified name.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>RenameImage()</b>\nrenames the specified image.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>CloneImage()</b>\nclones the specified image under a new name. It also takes a\nboolean argument indicating whether the resulting image\nshall be read-only or not.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>MarkImageReadOnly()</b>\ntoggles the read-only flag of an image.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>SetPoolLimit()</b>\nsets an overall quota limit on the pool of\nimages.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>SetImageLimit()</b>\nsets a per-image quota limit.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>MapFromMachineUser()</b>,\n<b>MapToMachineUser()</b>, <b>MapFromMachineGroup()</b>, and\n<b>MapToMachineGroup()</b> may be used to map UIDs/GIDs from\nthe host user namespace to a container user namespace or\nvice versa.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Signals\n<br>\nMachineNew</b> and <b>MachineRemoved</b> are sent whenever a\nnew machine is registered or removed. These signals carry\nthe machine name and the object path to the corresponding\norg.freedesktop.machine1.Machine interface (see\nbelow).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Properties</b>\n<i><br>\nPoolPath</i> specifies the file system path where images are\nwritten to.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>PoolUsage</i>\nspecifies the current usage size of the image pool in\nbytes.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>PoolLimit</i>\nspecifies the size limit of the image pool in\nbytes.</font></p>\n\n<h2>MACHINE OBJECTS\n<a name=\"MACHINE OBJECTS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">node\n/org/freedesktop/machine1/machine/rawhide { <br>\ninterface org.freedesktop.machine1.Machine { <br>\nmethods: <br>\nTerminate(); <br>\nKill(in s who, <br>\nin i signal); <br>\nGetAddresses(out a(iay) addresses); <br>\nGetOSRelease(out a{ss} fields); <br>\nGetUIDShift(out u shift); <br>\nOpenPTY(out h pty, <br>\nout s pty_path); <br>\nOpenLogin(out h pty, <br>\nout s pty_path); <br>\nOpenShell(in s user, <br>\nin s path, <br>\nin as args, <br>\nin as environment, <br>\nout h pty, <br>\nout s pty_path); <br>\nBindMount(in s source, <br>\nin s destination, <br>\nin b read_only, <br>\nin b mkdir); <br>\nCopyFrom(in s source, <br>\nin s destination); <br>\nCopyTo(in s source, <br>\nin s destination); <br>\nOpenRootDirectory(out h fd); <br>\nproperties: <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Name = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly ay Id = [...]; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly t Timestamp = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly t TimestampMonotonic = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Service = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Unit = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly u Leader = ...; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s Class = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly s RootDirectory = '...'; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)\n<br>\nreadonly ai NetworkInterfaces = [...]; <br>\n\n@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)\n<br>\nreadonly s State = '...'; <br>\n}; <br>\ninterface org.freedesktop.DBus.Peer { ... }; <br>\ninterface org.freedesktop.DBus.Introspectable { ... }; <br>\ninterface org.freedesktop.DBus.Properties { ... }; <br>\n};</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Methods\n<br>\nTerminate()</b> and <b>Kill()</b> terminate/kill the\nmachine. These methods take the same arguments as\n<b>TerminateMachine()</b> and <b>KillMachine()</b> on the\nManager interface, respectively.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>GetAddresses()</b>\nand <b>GetOSRelease()</b> get the IP address and OS release\ninformation from the machine. These methods take the same\narguments as <b>GetMachineAddresses()</b> and\n<b>GetMachineOSRelease()</b> of the Manager interface,\nrespectively.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Properties</b>\n<i><br>\nName</i> is the machine name as it was passed in during\nregistration with <b>CreateMachine()</b> on the manager\nobject.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Id</i>\nis the machine UUID.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Timestamp</i>\nand <i>TimestampMonotonic</i> are the realtime and monotonic\ntimestamps when the virtual machines where created in\nmicroseconds since the epoch.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Service</i>\ncontains a short string identifying the registering service\nas passed in during registration of the machine.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Unit</i>\nis the systemd scope or service unit name for the\nmachine.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Leader</i>\nis the PID of the leader process of the machine.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Class</i>\nis the class of the machine and is either the string\n&quot;vm&quot; (for real VMs based on virtualized hardware)\nor &quot;container&quot; (for light-weight userspace\nvirtualization sharing the same kernel as the\nhost).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>RootDirectory</i>\nis the root directory of the container if it is known and\napplicable or the empty string.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>NetworkInterfaces</i>\ncontains an array of network interface indices that point\ntowards the container, the VM or the host. For details about\nthis information see the description of\n<b>CreateMachineWithNetwork()</b> above.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>State</i>\nis the state of the machine and is one of\n&quot;opening&quot;, &quot;running&quot;, or\n&quot;closing&quot;. Note that the state machine is not\nconsidered part of the API and states might be removed or\nadded without this being considered API breakage.</font></p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;1.&nbsp;Introspect\norg.freedesktop.machine1.Manager on the bus</b></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngdbus introspect --system \\ <br>\n--dest org.freedesktop.machine1 \\ <br>\n--object-path /org/freedesktop/machine1</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;2.&nbsp;Introspect\norg.freedesktop.machine1.Machine on the bus</b></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">$\ngdbus introspect --system \\ <br>\n--dest org.freedesktop.machine1 \\ <br>\n--object-path\n/org/freedesktop/machine1/machine/rawhide</font></p>\n\n<h2>VERSIONING\n<a name=\"VERSIONING\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">These\nD-Bus interfaces follow</font> <b><font color=\"#0000FF\">the\nusual interface versioning guidelines</font></b>\n<small><font color=\"#000000\">[2]</font></small>\n<font color=\"#000000\">.</font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">1.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"43%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">New\nControl Group Interfaces</font></p></td>\n<td width=\"40%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://www.freedesktop.org/wiki/Software/systemd/ControlGroupInterface/</font></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">2.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"63%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">the usual\ninterface versioning guidelines</font></p></td>\n<td width=\"20%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">http://0pointer.de/blog/projects/versioning-dbus.html</font></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#INTRODUCTION\">INTRODUCTION</a>","<a href=\"#THE MANAGER OBJECT\">THE MANAGER OBJECT</a>","<a href=\"#MACHINE OBJECTS\">MACHINE OBJECTS</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#VERSIONING\">VERSIONING</a>","<a href=\"#NOTES\">NOTES</a>"],"level":5}