{"name":"dockerfile","body":"\n\n<h1 align=\"center\">DOCKERFILE</h1>\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">Dockerfile -\nautomate the steps of creating a Docker image</p>\n\n<h2>INTRODUCTION\n<a name=\"INTRODUCTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>Dockerfile</b> is a configuration file that automates the\nsteps of creating a Docker image. It is similar to a\nMakefile. Docker reads instructions from the\n<b>Dockerfile</b> to automate the steps otherwise performed\nmanually to create an image. To build an image, create a\nfile called <b>Dockerfile</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>Dockerfile</b> describes the steps taken to assemble the\nimage. When the <b>Dockerfile</b> has been created, call the\n<tt>docker build</tt> command, using the path of directory\nthat contains <b>Dockerfile</b> as the argument.</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">INSTRUCTION\narguments</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">For\nexample:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">FROM image</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A Dockerfile is\na file that automates the steps of creating a Docker image.\nA Dockerfile is similar to a Makefile.</p>\n\n<h2>USAGE\n<a name=\"USAGE\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">docker build\n.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- Runs the\nsteps and commits them, building a final image. <br>\nThe path to the source repository defines where to find the\ncontext of the <br>\nbuild. The build is run by the Docker daemon, not the CLI.\nThe whole <br>\ncontext must be transferred to the daemon. The Docker CLI\nreports <tt><br>\n&quot;Sending build context to Docker daemon&quot;</tt> when\nthe context is sent to the <br>\ndaemon.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">docker build -t\nrepository/tag .</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- specifies a\nrepository and tag at which to save the new image if the\nbuild <br>\nsucceeds. The Docker daemon runs the steps one-by-one,\ncommitting the result <br>\nto a new image if necessary, before finally outputting the\nID of the new <br>\nimage. The Docker daemon automatically cleans up the context\nit is given.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Docker re-uses\nintermediate images whenever possible. This significantly\n<br>\naccelerates the <i>docker build</i> process.</p>\n\n<h2>FORMAT\n<a name=\"FORMAT\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><tt>FROM\nimage</tt></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><tt>FROM\nimage:tag</tt></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><tt>FROM\nimage@digest</tt></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- The\n<b>FROM</b> instruction sets the base image for subsequent\ninstructions. A <br>\nvalid Dockerfile must have <b>FROM</b> as its first\ninstruction. The image can be any <br>\nvalid image. It is easy to start by pulling an image from\nthe public <br>\nrepositories.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- <b>FROM</b>\nmust be the first non-comment instruction in Dockerfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- <b>FROM</b>\nmay appear multiple times within a single Dockerfile in\norder to create <br>\nmultiple images. Make a note of the last image ID output by\nthe commit before <br>\neach new <b>FROM</b> command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- If no tag is\ngiven to the <b>FROM</b> instruction, Docker applies the\n<tt><br>\nlatest</tt> tag. If the used tag does not exist, an error is\nreturned.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- If no digest\nis given to the <b>FROM</b> instruction, Docker applies the\n<tt><br>\nlatest</tt> tag. If the used tag does not exist, an error is\nreturned.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>MAINTAINER</b>\n<br>\n-- <b>MAINTAINER</b> sets the Author field for the generated\nimages. <br>\nUseful for providing users with an email or url for\nsupport.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>RUN</b> <br>\n-- <b>RUN</b> has two forms:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># the command\nis run in a shell - /bin/sh -c <br>\nRUN &lt;command&gt;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># Executable\nform <br>\nRUN [&quot;executable&quot;, &quot;param1&quot;,\n&quot;param2&quot;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- The\n<b>RUN</b> instruction executes any commands in a new layer\non top of the current <br>\nimage and commits the results. The committed image is used\nfor the next step in <br>\nDockerfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- Layering\n<b>RUN</b> instructions and generating commits conforms to\nthe core <br>\nconcepts of Docker where commits are cheap and containers\ncan be created from <br>\nany point in the history of an image. This is similar to\nsource control. The <br>\nexec form makes it possible to avoid shell string munging.\nThe exec form makes <br>\nit possible to <b>RUN</b> commands using a base image that\ndoes not contain <tt>/bin/sh</tt>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nexec form is parsed as a JSON array, which means that you\nmust <br>\nuse double-quotes (&quot;) around words not single-quotes\n(&rsquo;).</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>CMD</b> <br>\n-- <b>CMD</b> has three forms:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># Executable\nform <br>\nCMD [&quot;executable&quot;, &quot;param1&quot;,\n&quot;param2&quot;]&rsquo;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># Provide\ndefault arguments to ENTRYPOINT <br>\nCMD [&quot;param1&quot;, &quot;param2&quot;]&rsquo;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># the command\nis run in a shell - /bin/sh -c <br>\nCMD command param1 param2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- There should\nbe only one <b>CMD</b> in a Dockerfile. If more than one\n<b>CMD</b> is listed, only <br>\nthe last <b>CMD</b> takes effect. <br>\nThe main purpose of a <b>CMD</b> is to provide defaults for\nan executing container. <br>\nThese defaults may include an executable, or they can omit\nthe executable. If <br>\nthey omit the executable, an <b>ENTRYPOINT</b> must be\nspecified. <br>\nWhen used in the shell or exec formats, the <b>CMD</b>\ninstruction sets the command to <br>\nbe executed when running the image. <br>\nIf you use the shell form of the <b>CMD</b>, the\n<tt>&lt;command&gt;</tt> executes in <tt>/bin/sh\n-c</tt>:</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that the\nexec form is parsed as a JSON array, which means that you\nmust <br>\nuse double-quotes (&quot;) around words not single-quotes\n(&rsquo;).</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">FROM ubuntu\n<br>\nCMD echo &quot;This is a test.&quot; | wc -</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- If you run\n<b>command</b> without a shell, then you must express the\ncommand as a <br>\nJSON array and give the full path to the executable. This\narray form is the <br>\npreferred form of <b>CMD</b>. All additional parameters must\nbe individually expressed <br>\nas strings in the array:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">FROM ubuntu\n<br>\nCMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- To make the\ncontainer run the same executable every time, use\n<b>ENTRYPOINT</b> in <br>\ncombination with <b>CMD</b>. <br>\nIf the user specifies arguments to <tt>docker run</tt>, the\nspecified commands <br>\noverride the default in <b>CMD</b>. <br>\nDo not confuse <b>RUN</b> with <b>CMD</b>. <b>RUN</b> runs a\ncommand and commits the result. <b><br>\nCMD</b> executes nothing at build time, but specifies the\nintended command for <br>\nthe image.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>LABEL</b>\n<br>\n-- <tt>LABEL &lt;key&gt;=&lt;value&gt;\n[&lt;key&gt;=&lt;value&gt; ...]</tt>or</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">LABEL\n&lt;key&gt;[ &lt;value&gt;] <br>\nLABEL &lt;key&gt;[ &lt;value&gt;] <br>\n...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<b>LABEL</b> instruction adds metadata to an image. A\n<b>LABEL</b> is a <br>\nkey-value pair. To specify a <b>LABEL</b> without a value,\nsimply use an empty <br>\nstring. To include spaces within a <b>LABEL</b> value, use\nquotes and <br>\nbackslashes as you would in command-line parsing.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">LABEL\ncom.example.vendor=&quot;ACME Incorporated&quot; <br>\nLABEL com.example.vendor &quot;ACME Incorporated&quot; <br>\nLABEL com.example.vendor.is-beta &quot;&quot; <br>\nLABEL com.example.vendor.is-beta= <br>\nLABEL com.example.vendor.is-beta=&quot;&quot;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An image can\nhave more than one label. To specify multiple labels,\nseparate <br>\neach key-value pair by a space.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Labels are\nadditive including <tt>LABEL</tt>s in <tt>FROM</tt> images.\nAs the system <br>\nencounters and then applies a new label, new <tt>key</tt>s\noverride any previous <br>\nlabels with identical keys.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To display an\nimage&rsquo;s labels, use the <tt>docker inspect</tt>\ncommand.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>STOPSIGNAL</b></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">--\n<tt>STOPSIGNAL &lt;signal&gt;</tt> <br>\nThe <b>STOPSIGNAL</b> instruction sets the system call\nsignal that will be sent <br>\nto the container to exit. This signal can be a signal name\nin the format <b><br>\nSIG</b>, for instance <b>SIGKILL</b>, or an unsigned number\nthat matches a <br>\nposition in the kernel&rsquo;s syscall table, for instance\n<b>9</b>. The default is <b><br>\nSIGTERM</b> if not defined.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\nimage&rsquo;s default stopsignal can be overridden per\ncontainer, using the <b><br>\n--stop-signal</b> flag on <b>docker-run(1)</b> and\n<b>docker-create(1)</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>EXPOSE</b>\n<br>\n-- <tt>EXPOSE &lt;port&gt; [&lt;port&gt;...]</tt> <br>\nThe <b>EXPOSE</b> instruction informs Docker that the\ncontainer listens on the <br>\nspecified network ports at runtime. Docker uses this\ninformation to <br>\ninterconnect containers using links and to set up port\nredirection on the host <br>\nsystem.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ENV</b> <br>\n-- <tt>ENV &lt;key&gt; &lt;value&gt;</tt> <br>\nThe <b>ENV</b> instruction sets the environment variable to\n<br>\nthe value <tt>&lt;value&gt;</tt>. This value is passed to\nall future <b><br>\nRUN</b>, <b>ENTRYPOINT</b>, and <b>CMD</b> instructions.\nThis is <br>\nfunctionally equivalent to prefixing the command with\n<tt>&lt;key&gt;=&lt;value&gt;</tt>. The <br>\nenvironment variables that are set with <b>ENV</b> persist\nwhen a container is run <br>\nfrom the resulting image. Use <tt>docker inspect</tt> to\ninspect these values, and <br>\nchange them using <tt>docker run --env\n&lt;key&gt;=&lt;value&gt;</tt>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Note that\nsetting &quot;<tt>ENV\nDEBIAN_FRONTEND=noninteractive</tt>&quot; may cause <br>\nunintended consequences, because it will persist when the\ncontainer is run <br>\ninteractively, as with the following command: <tt>docker run\n-t -i image bash</tt></p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ADD</b> <br>\n-- <b>ADD</b> has two forms:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">ADD &lt;src&gt;\n&lt;dest&gt;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># Required for\npaths with whitespace <br>\nADD [&quot;&lt;src&gt;&quot;,...\n&quot;&lt;dest&gt;&quot;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <b>ADD</b>\ninstruction copies new files, directories <br>\nor remote file URLs to the filesystem of the container at\npath <tt>&lt;dest&gt;</tt>. <br>\nMultiple <tt>&lt;src&gt;</tt> resources may be specified but\nif they are files or directories <br>\nthen they must be relative to the source directory that is\nbeing built <br>\n(the context of the build). The <tt>&lt;dest&gt;</tt> is the\nabsolute path, or path relative <br>\nto <b>WORKDIR</b>, into which the source is copied inside\nthe target container. <br>\nIf the <tt>&lt;src&gt;</tt> argument is a local file in a\nrecognized compression format <br>\n(tar, gzip, bzip2, etc) then it is unpacked at the specified\n<tt>&lt;dest&gt;</tt> in the <br>\ncontainer&rsquo;s filesystem. Note that only local\ncompressed files will be unpacked, <br>\ni.e., the URL download and archive unpacking features cannot\nbe used together. <br>\nAll new directories are created with mode 0755 and with the\nuid and gid of <b>0</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>COPY</b>\n<br>\n-- <b>COPY</b> has two forms:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">COPY\n&lt;src&gt; &lt;dest&gt;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># Required for\npaths with whitespace <br>\nCOPY [&quot;&lt;src&gt;&quot;,...\n&quot;&lt;dest&gt;&quot;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <b>COPY</b>\ninstruction copies new files from <tt>&lt;src&gt;</tt> and\n<br>\nadds them to the filesystem of the container at path . The\n<tt>&lt;src&gt;</tt> must be <br>\nthe path to a file or directory relative to the source\ndirectory that is <br>\nbeing built (the context of the build) or a remote file URL.\nThe <tt>&lt;dest&gt;</tt> is an <br>\nabsolute path, or a path relative to <b>WORKDIR</b>, into\nwhich the source will <br>\nbe copied inside the target container. If you <b>COPY</b> an\narchive file it will <br>\nland in the container exactly as it appears in the build\ncontext without any <br>\nattempt to unpack it. All new files and directories are\ncreated with mode <b>0755</b> <br>\nand with the uid and gid of <b>0</b>.</p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ENTRYPOINT</b>\n<br>\n-- <b>ENTRYPOINT</b> has two forms:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># executable\nform <br>\nENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,\n&quot;param2&quot;]&rsquo;</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\"># run command\nin a shell - /bin/sh -c <br>\nENTRYPOINT command param1 param2</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- An\n<b>ENTRYPOINT</b> helps you configure a <br>\ncontainer that can be run as an executable. When you specify\nan <b>ENTRYPOINT</b>, <br>\nthe whole container runs as if it was only that executable.\nThe <b>ENTRYPOINT</b> <br>\ninstruction adds an entry command that is not overwritten\nwhen arguments are <br>\npassed to docker run. This is different from the behavior of\n<b>CMD</b>. This allows <br>\narguments to be passed to the entrypoint, for instance\n<tt>docker run &lt;image&gt; -d</tt> <br>\npasses the -d argument to the <b>ENTRYPOINT</b>. Specify\nparameters either in the <b><br>\nENTRYPOINT</b> JSON array (as in the preferred exec form\nabove), or by using a <b>CMD</b> <br>\nstatement. Parameters in the <b>ENTRYPOINT</b> are not\noverwritten by the docker run <br>\narguments. Parameters specified via <b>CMD</b> are\noverwritten by docker run <br>\narguments. Specify a plain string for the <b>ENTRYPOINT</b>,\nand it will execute in <tt><br>\n/bin/sh -c</tt>, like a <b>CMD</b> instruction:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">FROM ubuntu\n<br>\nENTRYPOINT wc -l -</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This means that\nthe Dockerfile&rsquo;s image always takes stdin as input\n(that&rsquo;s <br>\nwhat &quot;-&quot; means), and prints the number of lines\n(that&rsquo;s what &quot;-l&quot; means). To <br>\nmake this optional but default, use a <b>CMD</b>:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">FROM ubuntu\n<br>\nCMD [&quot;-l&quot;, &quot;-&quot;] <br>\nENTRYPOINT [&quot;/usr/bin/wc&quot;]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>VOLUME</b>\n<br>\n-- <tt>VOLUME [&quot;/data&quot;]</tt> <br>\nThe <b>VOLUME</b> instruction creates a mount point with the\nspecified name and marks <br>\nit as holding externally-mounted volumes from the native\nhost or from other <br>\ncontainers.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>USER</b>\n<br>\n-- <tt>USER daemon</tt> <br>\nSets the username or UID used for running subsequent\ncommands.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The <b>USER</b>\ninstruction can optionally be used to set the group or GID.\nThe <br>\nfollowings examples are all valid: <br>\nUSER [user | user:group | uid | uid:gid | user:gid |\nuid:group ]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Until the\n<b>USER</b> instruction is set, instructions will be run as\nroot. The USER <br>\ninstruction can be used any number of times in a Dockerfile,\nand will only affect <br>\nsubsequent commands.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>WORKDIR</b>\n<br>\n-- <tt>WORKDIR /path/to/workdir</tt> <br>\nThe <b>WORKDIR</b> instruction sets the working directory\nfor the <b>RUN</b>, <b>CMD</b>, <b><br>\nENTRYPOINT</b>, <b>COPY</b> and <b>ADD</b> Dockerfile\ncommands that follow it. It can <br>\nbe used multiple times in a single Dockerfile. Relative\npaths are defined <br>\nrelative to the path of the previous <b>WORKDIR</b>\ninstruction. For example:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">WORKDIR /a <br>\nWORKDIR b <br>\nWORKDIR c <br>\nRUN pwd</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In the above\nexample, the output of the <b>pwd</b> command is\n<b>a/b/c</b>.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ARG</b> <br>\n-- ARG [=]</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<tt>ARG</tt> instruction defines a variable that users can\npass at build-time to <br>\nthe builder with the <tt>docker build</tt> command using the\n<tt>--build-arg <br>\n&lt;varname&gt;=&lt;value&gt;</tt> flag. If a user specifies\na build argument that was not <br>\ndefined in the Dockerfile, the build outputs a warning.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">[Warning] One\nor more build-args [foo] were not consumed</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The Dockerfile\nauthor can define a single variable by specifying\n<tt>ARG</tt> once or many <br>\nvariables by specifying <tt>ARG</tt> more than once. For\nexample, a valid Dockerfile:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">FROM busybox\n<br>\nARG user1 <br>\nARG buildno <br>\n...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A Dockerfile\nauthor may optionally specify a default value for an\n<tt>ARG</tt> instruction:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">FROM busybox\n<br>\nARG user1=someuser <br>\nARG buildno=1 <br>\n...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If an\n<tt>ARG</tt> value has a default and if there is no value\npassed at build-time, the <br>\nbuilder uses the default.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">An <tt>ARG</tt>\nvariable definition comes into effect from the line on which\nit is <br>\ndefined in the <tt>Dockerfile</tt> not from the\nargument&rsquo;s use on the command-line or <br>\nelsewhere. For example, consider this Dockerfile:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">1 FROM busybox\n<br>\n2 USER ${user:-some_user} <br>\n3 ARG user <br>\n4 USER $user <br>\n...</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">A user builds\nthis file by calling:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">$ docker build\n--build-arg user=what_user Dockerfile</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The\n<tt>USER</tt> at line 2 evaluates to <tt>some_user</tt> as\nthe <tt>user</tt> variable is defined on the <br>\nsubsequent line 3. The <tt>USER</tt> at line 4 evaluates to\n<tt>what_user</tt> as <tt>user</tt> is <br>\ndefined and the <tt>what_user</tt> value was passed on the\ncommand line. Prior to its definition by an <tt><br>\nARG</tt> instruction, any use of a variable results in an\nempty string.</p>\n\n\n<p style=\"margin-left:22%; margin-top: 1em\"><b>Warning:</b>\nIt is not recommended to use build-time variables for <br>\npassing secrets like github keys, user credentials etc.\nBuild-time variable <br>\nvalues are visible to any user of the image with the\n<tt>docker history</tt> command.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can use an\n<tt>ARG</tt> or an <tt>ENV</tt> instruction to specify\nvariables that are <br>\navailable to the <tt>RUN</tt> instruction. Environment\nvariables defined using the <tt><br>\nENV</tt> instruction always override an <tt>ARG</tt>\ninstruction of the same name. Consider <br>\nthis Dockerfile with an <tt>ENV</tt> and <tt>ARG</tt>\ninstruction.</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">1 FROM ubuntu\n<br>\n2 ARG CONT_IMG_VER <br>\n3 ENV CONT_IMG_VER=v1.0.0 <br>\n4 RUN echo $CONT_IMG_VER</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Then, assume\nthis image is built with this command:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">$ docker build\n--build-arg CONT_IMG_VER=v2.0.1 Dockerfile</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">In this case,\nthe <tt>RUN</tt> instruction uses <tt>v1.0.0</tt> instead of\nthe <tt>ARG</tt> setting <br>\npassed by the user:<tt>v2.0.1</tt> This behavior is similar\nto a shell <br>\nscript where a locally scoped variable overrides the\nvariables passed as <br>\narguments or inherited from environment, from its point of\ndefinition.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using the\nexample above but a different <tt>ENV</tt> specification you\ncan create more <br>\nuseful interactions between <tt>ARG</tt> and <tt>ENV</tt>\ninstructions:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">1 FROM ubuntu\n<br>\n2 ARG CONT_IMG_VER <br>\n3 ENV CONT_IMG_VER=${CONT_IMG_VER:-v1.0.0} <br>\n4 RUN echo $CONT_IMG_VER</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Unlike an\n<tt>ARG</tt> instruction, <tt>ENV</tt> values are always\npersisted in the built <br>\nimage. Consider a docker build without the --build-arg\nflag:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">$ docker build\nDockerfile</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Using this\nDockerfile example, <tt>CONT_IMG_VER</tt> is still persisted\nin the image but <br>\nits value would be <tt>v1.0.0</tt> as it is the default set\nin line 3 by the <tt>ENV</tt> instruction.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">The variable\nexpansion technique in this example allows you to pass\narguments <br>\nfrom the command line and persist them in the final image by\nleveraging the <tt><br>\nENV</tt> instruction. Variable expansion is only supported\nfor a limited set of <br>\nDockerfile instructions. &lang;\n#environment-replacement&rang;</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Docker has a\nset of predefined <tt>ARG</tt> variables that you can use\nwithout a <br>\ncorresponding <tt>ARG</tt> instruction in the\nDockerfile.</p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>HTTP_PROXY</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>http_proxy</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>HTTPS_PROXY</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>https_proxy</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>FTP_PROXY</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>ftp_proxy</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>NO_PROXY</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>no_proxy</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>ALL_PROXY</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n<tr valign=\"top\" align=\"left\">\n<td width=\"22%\"></td>\n<td width=\"1%\">\n\n\n<p>&bull;</p></td>\n<td width=\"2%\"></td>\n<td width=\"17%\">\n\n\n<p><tt>all_proxy</tt></p></td>\n<td width=\"58%\">\n</td></tr>\n</table>\n\n<p style=\"margin-left:11%; margin-top: 1em\">To use these,\npass them on the command line using <tt>--build-arg</tt>\nflag, for <br>\nexample:</p>\n\n<p style=\"margin-left:22%; margin-top: 1em\">$ docker build\n--build-arg HTTPS_PROXY=https://my-proxy.example.com .</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\"><b>ONBUILD</b>\n<br>\n-- <tt>ONBUILD [INSTRUCTION]</tt> <br>\nThe <b>ONBUILD</b> instruction adds a trigger instruction to\nan image. The <br>\ntrigger is executed at a later time, when the image is used\nas the base for <br>\nanother build. Docker executes the trigger in the context of\nthe downstream <br>\nbuild, as if the trigger existed immediately after the\n<b>FROM</b> instruction in <br>\nthe downstream Dockerfile.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">You can\nregister any build instruction as a trigger. A trigger is\nuseful if <br>\nyou are defining an image to use as a base for building\nother images. For <br>\nexample, if you are defining an application build\nenvironment or a daemon that <br>\nis customized with a user-specific configuration.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Consider an\nimage intended as a reusable python application builder. It\nmust <br>\nadd application source code to a particular directory, and\nmight need a build <br>\nscript called after that. You can&rsquo;t just call\n<b>ADD</b> and <b>RUN</b> now, because <br>\nyou don&rsquo;t yet have access to the application source\ncode, and it is different <br>\nfor each application build.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">-- Providing\napplication developers with a boilerplate Dockerfile to\ncopy-paste <br>\ninto their application is inefficient, error-prone, and <br>\ndifficult to update because it mixes with\napplication-specific code. <br>\nThe solution is to use <b>ONBUILD</b> to register\ninstructions in advance, to <br>\nrun later, during the next build stage.</p>\n\n<h2>HISTORY\n<a name=\"HISTORY\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">*May 2014,\nCompiled by Zac Dover (zdover at redhat dot com) based on\ndocker.com Dockerfile documentation. *Feb 2015, updated by\nBrian Goff (cpuguy83@gmail.com) for readability *Sept 2015,\nupdated by Sally O&rsquo;Malley (somalley@redhat.com) *Oct\n2016, updated by Addam Hardy (addam.hardy@gmail.com)</p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#INTRODUCTION\">INTRODUCTION</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#USAGE\">USAGE</a>","<a href=\"#FORMAT\">FORMAT</a>","<a href=\"#HISTORY\">HISTORY</a>"],"level":5}