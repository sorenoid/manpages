{"name":"systemd.service","description":"systemd.service - Service unit configuration","body":"\n\n<h1 align=\"center\">SYSTEMD.SERVICE</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n<hr>\n\n\n<h2>NAME\n<a name=\"NAME\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">systemd.service\n- Service unit configuration</p>\n\n<h2>SYNOPSIS\n<a name=\"SYNOPSIS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><i>service</i>.service</p>\n\n<h2>DESCRIPTION\n<a name=\"DESCRIPTION\"></a>\n</h2>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\">A unit\nconfiguration file whose name ends in &quot;.service&quot;\nencodes information about a process controlled and\nsupervised by systemd.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">This man page\nlists the configuration options specific to this unit type.\nSee <b>systemd.unit</b>(5) for the common options of all\nunit configuration files. The common configuration items are\nconfigured in the generic [Unit] and [Install] sections. The\nservice specific configuration options are configured in the\n[Service] section.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">Additional\noptions are listed in <b>systemd.exec</b>(5), which define\nthe execution environment the commands are executed in, and\nin <b>systemd.kill</b>(5), which define the way the\nprocesses of the service are terminated, and in\n<b>systemd.resource-control</b>(5), which configure resource\ncontrol settings for the processes of the service.</p>\n\n<p style=\"margin-left:11%; margin-top: 1em\">If a service is\nrequested under a certain name but no unit configuration\nfile is found, systemd looks for a SysV init script by the\nsame name (with the .service suffix removed) and dynamically\ncreates a service unit from that script. This is useful for\ncompatibility with SysV. Note that this compatibility is\nquite comprehensive but not 100%. For details about the\nincompatibilities, see the\n<b><font color=\"#0000FF\">Incompatibilities with\nSysV</font></b>\n<small><font color=\"#000000\">[1]</font></small>\n<font color=\"#000000\">document.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\n<a href=\"https://man.page/1/systemd-run\">systemd-run(1)</a> command allows creating .service and\n.scope units dynamically and transiently from the command\nline.</font></p>\n\n<h2>SERVICE TEMPLATES\n<a name=\"SERVICE TEMPLATES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">It\nis possible for <b>systemd</b> services to take a single\nargument via the\n&quot;<i>service</i>@<i>argument</i>.service&quot; syntax.\nSuch services are called &quot;instantiated&quot; services,\nwhile the unit definition without the <i>argument</i>\nparameter is called a &quot;template&quot;. An example could\nbe a dhcpcd@.service service template which takes a network\ninterface as a parameter to form an instantiated service.\nWithin the service file, this parameter or &quot;instance\nname&quot; can be accessed with %-specifiers. See\n<b>systemd.unit</b>(5) for details.</font></p>\n\n<h2>AUTOMATIC DEPENDENCIES\n<a name=\"AUTOMATIC DEPENDENCIES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Implicit\nDependencies</b> <br>\nThe following dependencies are implicitly added:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nServices with <i>Type=dbus</i> set automatically acquire\ndependencies of type <i>Requires=</i> and <i>After=</i> on\ndbus.socket.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nSocket activated services are automatically ordered after\ntheir activating .socket units via an automatic\n<i>After=</i> dependency. Services also pull in all .socket\nunits listed in <i>Sockets=</i> via automatic <i>Wants=</i>\nand <i>After=</i> dependencies.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Additional\nimplicit dependencies may be added as result of execution\nand resource control parameters as documented in\n<b>systemd.exec</b>(5) and\n<b>systemd.resource-control</b>(5).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Default\nDependencies</b> <br>\nThe following dependencies are added unless\n<i>DefaultDependencies=no</i> is set:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nService units will have dependencies of type\n<i>Requires=</i> and <i>After=</i> on sysinit.target, a\ndependency of type <i>After=</i> on basic.target as well as\ndependencies of type <i>Conflicts=</i> and <i>Before=</i> on\nshutdown.target. These ensure that normal service units pull\nin basic system initialization, and are terminated cleanly\nprior to system shutdown. Only services involved with early\nboot or late system shutdown should disable this\noption.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&bull;\nInstanced service units (i.e. service units with an\n&quot;@&quot; in their name) are assigned by default a\nper-template slice unit (see <b>systemd.slice</b>(5)), named\nafter the template unit, containing all instances of the\nspecific template. This slice is normally stopped at\nshutdown, together with all template instances. If that is\nnot desired, set <i>DefaultDependencies=no</i> in the\ntemplate unit, and either define your own per-template slice\nunit file that also sets <i>DefaultDependencies=no</i>, or\nset <i>Slice=system.slice</i> (or another suitable slice) in\nthe template unit. Also see\n<b>systemd.resource-control</b>(5).</font></p>\n\n<h2>OPTIONS\n<a name=\"OPTIONS\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Service\nfiles must include a [Service] section, which carries\ninformation about the service and the process it supervises.\nA number of options that may be used in this section are\nshared with other unit types. These options are documented\nin <b>systemd.exec</b>(5), <b>systemd.kill</b>(5) and\n<b>systemd.resource-control</b>(5). The options specific to\nthe [Service] section of service units are the\nfollowing:</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Type=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configures\nthe process start-up type for this service unit. One of\n<b>simple</b>, <b>exec</b>, <b>forking</b>, <b>oneshot</b>,\n<b>dbus</b>, <b>notify</b> or <b>idle</b>:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf set to <b>simple</b> (the default if <i>ExecStart=</i> is\nspecified but neither <i>Type=</i> nor <i>BusName=</i> are),\nthe service manager will consider the unit started\nimmediately after the main service process has been forked\noff. It is expected that the process configured with\n<i>ExecStart=</i> is the main process of the service. In\nthis mode, if the process offers functionality to other\nprocesses on the system, its communication channels should\nbe installed before the service is started up (e.g. sockets\nset up by systemd, via socket activation), as the service\nmanager will immediately proceed starting follow-up units,\nright after creating the main service process, and before\nexecuting the service's binary. Note that this means\n<b>systemctl start</b> command lines for <b>simple</b>\nservices will report success even if the service's binary\ncannot be invoked successfully (for example because the\nselected <i>User=</i> doesn't exist, or the service binary\nis missing).</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nThe <b>exec</b> type is similar to <b>simple</b>, but the\nservice manager will consider the unit started immediately\nafter the main service binary has been executed. The service\nmanager will delay starting of follow-up units until that\npoint. (Or in other words: <b>simple</b> proceeds with\nfurther jobs right after <b>fork()</b> returns, while\n<b>exec</b> will not proceed before both <b>fork()</b> and\n<b>execve()</b> in the service process succeeded.) Note that\nthis means <b>systemctl start</b> command lines for\n<b>exec</b> services will report failure when the service's\nbinary cannot be invoked successfully (for example because\nthe selected <i>User=</i> doesn't exist, or the service\nbinary is missing).</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nIf set to <b>forking</b>, it is expected that the process\nconfigured with <i>ExecStart=</i> will call <b>fork()</b> as\npart of its start-up. The parent process is expected to exit\nwhen start-up is complete and all communication channels are\nset up. The child continues to run as the main service\nprocess, and the service manager will consider the unit\nstarted when the parent process exits. This is the behavior\nof traditional UNIX services. If this setting is used, it is\nrecommended to also use the <i>PIDFile=</i> option, so that\nsystemd can reliably identify the main process of the\nservice. systemd will proceed with starting follow-up units\nas soon as the parent process exits.</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nBehavior of <b>oneshot</b> is similar to <b>simple</b>;\nhowever, the service manager will consider the unit up after\nthe main process exits. It will then start follow-up units.\n<i>RemainAfterExit=</i> is particularly useful for this type\nof service. <i>Type=</i><b>oneshot</b> is the implied\ndefault if neither <i>Type=</i> nor <i>ExecStart=</i> are\nspecified. Note that if this option is used without\n<i>RemainAfterExit=</i> the service will never enter\n&quot;active&quot; unit state, but directly transition from\n&quot;activating&quot; to &quot;deactivating&quot; or\n&quot;dead&quot; since no process is configured that shall\nrun continuously. In particular this means that after a\nservice of this type ran (and which has\n<i>RemainAfterExit=</i> not set) it will not show up as\nstarted afterwards, but as dead.</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nBehavior of <b>dbus</b> is similar to <b>simple</b>;\nhowever, it is expected that the service acquires a name on\nthe D-Bus bus, as configured by <i>BusName=</i>. systemd\nwill proceed with starting follow-up units after the D-Bus\nbus name has been acquired. Service units with this option\nconfigured implicitly gain dependencies on the dbus.socket\nunit. This type is the default if <i>BusName=</i> is\nspecified. A service unit of this type is considered to be\nin the activating state until the specified bus name is\nacquired. It is considered activated while the bus name is\ntaken. Once the bus name is released the service is\nconsidered being no longer functional which has the effect\nthat the service manager attempts to terminate any remaining\nprocesses belonging to the service. Services that drop their\nbus name as part of their shutdown logic thus should be\nprepared to receive a <b>SIGTERM</b> (or whichever signal is\nconfigured in <i>KillSignal=</i>) as result.</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nBehavior of <b>notify</b> is similar to <b>exec</b>;\nhowever, it is expected that the service sends a\nnotification message via <a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a> or an\nequivalent call when it has finished starting up. systemd\nwill proceed with starting follow-up units after this\nnotification message has been sent. If this option is used,\n<i>NotifyAccess=</i> (see below) should be set to open\naccess to the notification socket provided by systemd. If\n<i>NotifyAccess=</i> is missing or set to <b>none</b>, it\nwill be forcibly set to <b>main</b>.</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nBehavior of <b>idle</b> is very similar to <b>simple</b>;\nhowever, actual execution of the service program is delayed\nuntil all active jobs are dispatched. This may be used to\navoid interleaving of output of shell services with the\nstatus output on the console. Note that this type is useful\nonly to improve console output, it is not useful as a\ngeneral unit ordering tool, and the effect of this service\ntype is subject to a 5s timeout, after which the service\nprogram is invoked anyway.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">It\nis generally recommended to use <i>Type=</i><b>simple</b>\nfor long-running services whenever possible, as it is the\nsimplest and fastest option. However, as this service type\nwon't propagate service start-up failures and doesn't allow\nordering of other units against completion of initialization\nof the service (which for example is useful if clients need\nto connect to the service through some form of IPC, and the\nIPC channel is only established by the service itself\n&mdash; in contrast to doing this ahead of time through\nsocket or bus activation or similar), it might not be\nsufficient for many cases. If so, <b>notify</b> or\n<b>dbus</b> (the latter only in case the service provides a\nD-Bus interface) are the preferred options as they allow\nservice program code to precisely schedule when to consider\nthe service started up successfully and when to proceed with\nfollow-up units. The <b>notify</b> service type requires\nexplicit support in the service codebase (as\n<b>sd_notify()</b> or an equivalent API needs to be invoked\nby the service at the appropriate time) &mdash; if it's not\nsupported, then <b>forking</b> is an alternative: it\nsupports the traditional UNIX service start-up protocol.\nFinally, <b>exec</b> might be an option for cases where it\nis enough to ensure the service binary is invoked, and where\nthe service binary itself executes no or little\ninitialization on its own (and its initialization is\nunlikely to fail). Note that using any type other than\n<b>simple</b> possibly delays the boot process, as the\nservice manager needs to wait for service initialization to\ncomplete. It is hence recommended not to needlessly use any\ntypes other than <b>simple</b>. (Also note it is generally\nnot recommended to use <b>idle</b> or <b>oneshot</b> for\nlong-running services.)</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>RemainAfterExit=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\nboolean value that specifies whether the service shall be\nconsidered active even when all its processes exited.\nDefaults to <b>no</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>GuessMainPID=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\nboolean value that specifies whether systemd should try to\nguess the main PID of a service if it cannot be determined\nreliably. This option is ignored unless <b>Type=forking</b>\nis set and <b>PIDFile=</b> is unset because for the other\ntypes or with an explicitly configured PID file, the main\nPID is always known. The guessing algorithm might come to\nincorrect conclusions if a daemon consists of more than one\nprocess. If the main PID cannot be determined, failure\ndetection and automatic restarting of a service will not\nwork reliably. Defaults to <b>yes</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>PIDFile=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\npath referring to the PID file of the service. Usage of this\noption is recommended for services where <i>Type=</i> is set\nto <b>forking</b>. The path specified typically points to a\nfile below /run/. If a relative path is specified it is\nhence prefixed with /run/. The service manager will read the\nPID of the main process of the service from this file after\nstart-up of the service. The service manager will not write\nto the file configured here, although it will remove the\nfile after the service has shut down if it still exists. The\nPID file does not need to be owned by a privileged user, but\nif it is owned by an unprivileged user additional safety\nrestrictions are enforced: the file may not be a symlink to\na file owned by a different user (neither directly nor\nindirectly), and the PID file must refer to a process\nalready belonging to the service.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat PID files should be avoided in modern projects. Use\n<b>Type=notify</b> or <b>Type=simple</b> where possible,\nwhich does not require use of PID files to determine the\nmain process of a service and avoids needless\nforking.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>BusName=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\nD-Bus destination name that this service shall use. This\noption is mandatory for services where <i>Type=</i> is set\nto <b>dbus</b>. It is recommended to always set this\nproperty if known to make it easy to map the service name to\nthe D-Bus destination. In particular, <b>systemctl\nservice-log-level/service-log-target</b> verbs make use of\nthis.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>ExecStart=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Commands\nwith their arguments that are executed when this service is\nstarted. The value is split into zero or more command lines\naccording to the rules described below (see section\n&quot;Command Lines&quot; below).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Unless\n<i>Type=</i> is <b>oneshot</b>, exactly one command must be\ngiven. When <i>Type=oneshot</i> is used, zero or more\ncommands may be specified. Commands may be specified by\nproviding multiple command lines in the same directive, or\nalternatively, this directive may be specified more than\nonce with the same effect. If the empty string is assigned\nto this option, the list of commands to start is reset,\nprior assignments of this option will have no effect. If no\n<i>ExecStart=</i> is specified, then the service must have\n<i>RemainAfterExit=yes</i> and at least one <i>ExecStop=</i>\nline set. (Services lacking both <i>ExecStart=</i> and\n<i>ExecStop=</i> are not valid.)</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">For\neach of the specified commands, the first argument must be\neither an absolute path to an executable or a simple file\nname without any slashes. Optionally, this filename may be\nprefixed with a number of special characters:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><b>Table&nbsp;1.&nbsp;Special\nexecutable prefixes</b></font></p>\n\n\n<p align=\"center\"><font color=\"#000000\"><b><img src=\"grohtml-3491401.png\" alt=\"Image grohtml-3491401.png\"></b></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">&quot;@&quot;,\n&quot;-&quot;, &quot;:&quot;, and one of\n&quot;+&quot;/&quot;!&quot;/&quot;!!&quot; may be used\ntogether and they can appear in any order. However, only one\nof &quot;+&quot;, &quot;!&quot;, &quot;!!&quot; may be used\nat a time. Note that these prefixes are also supported for\nthe other command line settings, i.e. <i>ExecStartPre=</i>,\n<i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>\nand <i>ExecStopPost=</i>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\nmore than one command is specified, the commands are invoked\nsequentially in the order they appear in the unit file. If\none of the commands fails (and is not prefixed with\n&quot;-&quot;), other lines are not executed, and the unit\nis considered failed.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Unless\n<i>Type=forking</i> is set, the process started via this\ncommand line will be considered the main process of the\ndaemon.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>ExecStartPre=</i>,\n<i>ExecStartPost=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Additional\ncommands that are executed before or after the command in\n<i>ExecStart=</i>, respectively. Syntax is the same as for\n<i>ExecStart=</i>, except that multiple command lines are\nallowed and the commands are executed one after the other,\nserially.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\nany of those commands (not prefixed with &quot;-&quot;)\nfail, the rest are not executed and the unit is considered\nfailed.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><i>ExecStart=</i>\ncommands are only run after all <i>ExecStartPre=</i>\ncommands that were not prefixed with a &quot;-&quot; exit\nsuccessfully.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><i>ExecStartPost=</i>\ncommands are only run after the commands specified in\n<i>ExecStart=</i> have been invoked successfully, as\ndetermined by <i>Type=</i> (i.e. the process has been\nstarted for <i>Type=simple</i> or <i>Type=idle</i>, the last\n<i>ExecStart=</i> process exited successfully for\n<i>Type=oneshot</i>, the initial process exited successfully\nfor <i>Type=forking</i>, &quot;READY=1&quot; is sent for\n<i>Type=notify</i>, or the <i>BusName=</i> has been taken\nfor <i>Type=dbus</i>).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat <i>ExecStartPre=</i> may not be used to start\nlong-running processes. All processes forked off by\nprocesses invoked via <i>ExecStartPre=</i> will be killed\nbefore the next service process is run.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat if any of the commands specified in\n<i>ExecStartPre=</i>, <i>ExecStart=</i>, or\n<i>ExecStartPost=</i> fail (and are not prefixed with\n&quot;-&quot;, see above) or time out before the service is\nfully up, execution continues with commands specified in\n<i>ExecStopPost=</i>, the commands in <i>ExecStop=</i> are\nskipped.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat the execution of <i>ExecStartPost=</i> is taken into\naccount for the purpose of <i>Before=</i>/<i>After=</i>\nordering constraints.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>ExecCondition=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Optional\ncommands that are executed before the command(s) in\n<i>ExecStartPre=</i>. Syntax is the same as for\n<i>ExecStart=</i>, except that multiple command lines are\nallowed and the commands are executed one after the other,\nserially.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">The\nbehavior is like an <i>ExecStartPre=</i> and condition check\nhybrid: when an <i>ExecCondition=</i> command exits with\nexit code 1 through 254 (inclusive), the remaining commands\nare skipped and the unit is <i>not</i> marked as failed.\nHowever, if an <i>ExecCondition=</i> command exits with 255\nor abnormally (e.g. timeout, killed by a signal, etc.), the\nunit will be considered failed (and remaining commands will\nbe skipped). Exit code of 0 or those matching\n<i>SuccessExitStatus=</i> will continue execution to the\nnext command(s).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">The\nsame recommendations about not running long-running\nprocesses in <i>ExecStartPre=</i> also applies to\n<i>ExecCondition=</i>. <i>ExecCondition=</i> will also run\nthe commands in <i>ExecStopPost=</i>, as part of stopping\nthe service, in the case of any non-zero or abnormal exits,\nlike the ones described above.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>ExecReload=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Commands\nto execute to trigger a configuration reload in the service.\nThis argument takes multiple command lines, following the\nsame scheme as described for <i>ExecStart=</i> above. Use of\nthis setting is optional. Specifier and environment variable\nsubstitution is supported here following the same scheme as\nfor <i>ExecStart=</i>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">One\nadditional, special environment variable is set: if known,\n<i>$MAINPID</i> is set to the main process of the daemon,\nand may be used for command lines like the\nfollowing:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">ExecReload=kill\n-HUP $MAINPID</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nhowever that reloading a daemon by sending a signal (as with\nthe example line above) is usually not a good choice,\nbecause this is an asynchronous operation and hence not\nsuitable to order reloads of multiple services against each\nother. It is strongly recommended to set <i>ExecReload=</i>\nto a command that not only triggers a configuration reload\nof the daemon, but also synchronously waits for it to\ncomplete. For example, <a href=\"https://man.page/1/dbus-broker\">dbus-broker(1)</a> uses the\nfollowing:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">ExecReload=busctl\ncall org.freedesktop.DBus \\ <br>\n/org/freedesktop/DBus org.freedesktop.DBus \\ <br>\nReloadConfig</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>ExecStop=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Commands\nto execute to stop the service started via\n<i>ExecStart=</i>. This argument takes multiple command\nlines, following the same scheme as described for\n<i>ExecStart=</i> above. Use of this setting is optional.\nAfter the commands configured in this option are run, it is\nimplied that the service is stopped, and any processes\nremaining for it are terminated according to the\n<i>KillMode=</i> setting (see <b>systemd.kill</b>(5)). If\nthis option is not specified, the process is terminated by\nsending the signal specified in <i>KillSignal=</i> or\n<i>RestartKillSignal=</i> when service stop is requested.\nSpecifier and environment variable substitution is supported\n(including <i>$MAINPID</i>, see above).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat it is usually not sufficient to specify a command for\nthis setting that only asks the service to terminate (for\nexample, by sending some form of termination signal to it),\nbut does not wait for it to do so. Since the remaining\nprocesses of the services are killed according to\n<i>KillMode=</i> and <i>KillSignal=</i> or\n<i>RestartKillSignal=</i> as described above immediately\nafter the command exited, this may not result in a clean\nstop. The specified command should hence be a synchronous\noperation, not an asynchronous one.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat the commands specified in <i>ExecStop=</i> are only\nexecuted when the service started successfully first. They\nare not invoked if the service was never started at all, or\nin case its start-up failed, for example because any of the\ncommands specified in <i>ExecStart=</i>,\n<i>ExecStartPre=</i> or <i>ExecStartPost=</i> failed (and\nweren't prefixed with &quot;-&quot;, see above) or timed\nout. Use <i>ExecStopPost=</i> to invoke commands when a\nservice failed to start up correctly and is shut down again.\nAlso note that the stop operation is always performed if the\nservice started successfully, even if the processes in the\nservice terminated on their own or were killed. The stop\ncommands must be prepared to deal with that case.\n<i>$MAINPID</i> will be unset if systemd knows that the main\nprocess exited by the time the stop commands are\ncalled.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Service\nrestart requests are implemented as stop operations followed\nby start operations. This means that <i>ExecStop=</i> and\n<i>ExecStopPost=</i> are executed during a service restart\noperation.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">It\nis recommended to use this setting for commands that\ncommunicate with the service requesting clean termination.\nFor post-mortem clean-up steps use <i>ExecStopPost=</i>\ninstead.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>ExecStopPost=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Additional\ncommands that are executed after the service is stopped.\nThis includes cases where the commands configured in\n<i>ExecStop=</i> were used, where the service does not have\nany <i>ExecStop=</i> defined, or where the service exited\nunexpectedly. This argument takes multiple command lines,\nfollowing the same scheme as described for\n<i>ExecStart=</i>. Use of these settings is optional.\nSpecifier and environment variable substitution is\nsupported. Note that &ndash; unlike <i>ExecStop=</i> &ndash;\ncommands specified with this setting are invoked when a\nservice failed to start up correctly and is shut down\nagain.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">It\nis recommended to use this setting for clean-up operations\nthat shall be executed even when the service failed to start\nup correctly. Commands configured with this setting need to\nbe able to operate even if the service failed starting up\nhalf-way and left incompletely initialized data around. As\nthe service's processes have been terminated already when\nthe commands specified with this setting are executed they\nshould not attempt to communicate with them.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat all commands that are configured with this setting are\ninvoked with the result code of the service, as well as the\nmain process' exit code and status, set in the\n<i>$SERVICE_RESULT</i>, <i>$EXIT_CODE</i> and\n<i>$EXIT_STATUS</i> environment variables, see\n<b>systemd.exec</b>(5) for details.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat the execution of <i>ExecStopPost=</i> is taken into\naccount for the purpose of <i>Before=</i>/<i>After=</i>\nordering constraints.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>RestartSec=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configures\nthe time to sleep before restarting a service (as configured\nwith <i>Restart=</i>). Takes a unit-less value in seconds,\nor a time span value such as &quot;5min 20s&quot;. Defaults\nto 100ms.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>TimeoutStartSec=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configures\nthe time to wait for start-up. If a daemon service does not\nsignal start-up completion within the configured time, the\nservice will be considered failed and will be shut down\nagain. The precise action depends on the\n<i>TimeoutStartFailureMode=</i> option. Takes a unit-less\nvalue in seconds, or a time span value such as &quot;5min\n20s&quot;. Pass &quot;infinity&quot; to disable the timeout\nlogic. Defaults to <i>DefaultTimeoutStartSec=</i> from the\nmanager configuration file, except when <i>Type=oneshot</i>\nis used, in which case the timeout is disabled by default\n(see <b>systemd-system.conf</b>(5)).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\na service of <i>Type=notify</i> sends\n&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the\nstart time to be extended beyond <i>TimeoutStartSec=</i>.\nThe first receipt of this message must occur before\n<i>TimeoutStartSec=</i> is exceeded, and once the start time\nhas extended beyond <i>TimeoutStartSec=</i>, the service\nmanager will allow the service to continue to start,\nprovided the service repeats\n&quot;EXTEND_TIMEOUT_USEC=...&quot; within the interval\nspecified until the service startup status is finished by\n&quot;READY=1&quot;. (see <a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a>).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>TimeoutStopSec=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\noption serves two purposes. First, it configures the time to\nwait for each <i>ExecStop=</i> command. If any of them times\nout, subsequent <i>ExecStop=</i> commands are skipped and\nthe service will be terminated by <b>SIGTERM</b>. If no\n<i>ExecStop=</i> commands are specified, the service gets\nthe <b>SIGTERM</b> immediately. This default behavior can be\nchanged by the <i>TimeoutStopFailureMode=</i> option.\nSecond, it configures the time to wait for the service\nitself to stop. If it doesn't terminate in the specified\ntime, it will be forcibly terminated by <b>SIGKILL</b> (see\n<i>KillMode=</i> in <b>systemd.kill</b>(5)). Takes a\nunit-less value in seconds, or a time span value such as\n&quot;5min 20s&quot;. Pass &quot;infinity&quot; to disable\nthe timeout logic. Defaults to <i>DefaultTimeoutStopSec=</i>\nfrom the manager configuration file (see\n<b>systemd-system.conf</b>(5)).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\na service of <i>Type=notify</i> sends\n&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the stop\ntime to be extended beyond <i>TimeoutStopSec=</i>. The first\nreceipt of this message must occur before\n<i>TimeoutStopSec=</i> is exceeded, and once the stop time\nhas extended beyond <i>TimeoutStopSec=</i>, the service\nmanager will allow the service to continue to stop, provided\nthe service repeats &quot;EXTEND_TIMEOUT_USEC=...&quot;\nwithin the interval specified, or terminates itself (see\n<a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a>).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>TimeoutAbortSec=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">This\noption configures the time to wait for the service to\nterminate when it was aborted due to a watchdog timeout (see\n<i>WatchdogSec=</i>). If the service has a short\n<i>TimeoutStopSec=</i> this option can be used to give the\nsystem more time to write a core dump of the service. Upon\nexpiration the service will be forcibly terminated by\n<b>SIGKILL</b> (see <i>KillMode=</i> in\n<b>systemd.kill</b>(5)). The core file will be truncated in\nthis case. Use <i>TimeoutAbortSec=</i> to set a sensible\ntimeout for the core dumping per service that is large\nenough to write all expected data while also being short\nenough to handle the service failure in due time.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Takes\na unit-less value in seconds, or a time span value such as\n&quot;5min 20s&quot;. Pass an empty value to skip the\ndedicated watchdog abort timeout handling and fall back\n<i>TimeoutStopSec=</i>. Pass &quot;infinity&quot; to disable\nthe timeout logic. Defaults to\n<i>DefaultTimeoutAbortSec=</i> from the manager\nconfiguration file (see\n<b>systemd-system.conf</b>(5)).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\na service of <i>Type=notify</i> handles <b>SIGABRT</b>\nitself (instead of relying on the kernel to write a core\ndump) it can send &quot;EXTEND_TIMEOUT_USEC=...&quot; to\nextended the abort time beyond <i>TimeoutAbortSec=</i>. The\nfirst receipt of this message must occur before\n<i>TimeoutAbortSec=</i> is exceeded, and once the abort time\nhas extended beyond <i>TimeoutAbortSec=</i>, the service\nmanager will allow the service to continue to abort,\nprovided the service repeats\n&quot;EXTEND_TIMEOUT_USEC=...&quot; within the interval\nspecified, or terminates itself (see\n<a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a>).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>TimeoutSec=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">A\nshorthand for configuring both <i>TimeoutStartSec=</i> and\n<i>TimeoutStopSec=</i> to the specified value.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>TimeoutStartFailureMode=</i>,\n<i>TimeoutStopFailureMode=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">These\noptions configure the action that is taken in case a daemon\nservice does not signal start-up within its configured\n<i>TimeoutStartSec=</i>, respectively if it does not stop\nwithin <i>TimeoutStopSec=</i>. Takes one of\n<b>terminate</b>, <b>abort</b> and <b>kill</b>. Both options\ndefault to <b>terminate</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\n<b>terminate</b> is set the service will be gracefully\nterminated by sending the signal specified in\n<i>KillSignal=</i> (defaults to <b>SIGTERM</b>, see\n<b>systemd.kill</b>(5)). If the service does not terminate\nthe <i>FinalKillSignal=</i> is sent after\n<i>TimeoutStopSec=</i>. If <b>abort</b> is set,\n<i>WatchdogSignal=</i> is sent instead and\n<i>TimeoutAbortSec=</i> applies before sending\n<i>FinalKillSignal=</i>. This setting may be used to analyze\nservices that fail to start-up or shut-down intermittently.\nBy using <b>kill</b> the service is immediately terminated\nby sending <i>FinalKillSignal=</i> without any further\ntimeout. This setting can be used to expedite the shutdown\nof failing services.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>RuntimeMaxSec=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configures\na maximum time for the service to run. If this is used and\nthe service has been active for longer than the specified\ntime it is terminated and put into a failure state. Note\nthat this setting does not have any effect on\n<i>Type=oneshot</i> services, as they terminate immediately\nafter activation completed. Pass &quot;infinity&quot; (the\ndefault) to configure no runtime limit.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\na service of <i>Type=notify</i> sends\n&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the\nruntime to be extended beyond <i>RuntimeMaxSec=</i>. The\nfirst receipt of this message must occur before\n<i>RuntimeMaxSec=</i> is exceeded, and once the runtime has\nextended beyond <i>RuntimeMaxSec=</i>, the service manager\nwill allow the service to continue to run, provided the\nservice repeats &quot;EXTEND_TIMEOUT_USEC=...&quot; within\nthe interval specified until the service shutdown is\nachieved by &quot;STOPPING=1&quot; (or termination). (see\n<a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a>).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>WatchdogSec=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configures\nthe watchdog timeout for a service. The watchdog is\nactivated when the start-up is completed. The service must\ncall <a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a> regularly with\n&quot;WATCHDOG=1&quot; (i.e. the &quot;keep-alive\nping&quot;). If the time between two such calls is larger\nthan the configured time, then the service is placed in a\nfailed state and it will be terminated with <b>SIGABRT</b>\n(or the signal specified by <i>WatchdogSignal=</i>). By\nsetting <i>Restart=</i> to <b>on-failure</b>,\n<b>on-watchdog</b>, <b>on-abnormal</b> or <b>always</b>, the\nservice will be automatically restarted. The time configured\nhere will be passed to the executed service process in the\n<i>WATCHDOG_USEC=</i> environment variable. This allows\ndaemons to automatically enable the keep-alive pinging logic\nif watchdog support is enabled for the service. If this\noption is used, <i>NotifyAccess=</i> (see below) should be\nset to open access to the notification socket provided by\nsystemd. If <i>NotifyAccess=</i> is not set, it will be\nimplicitly set to <b>main</b>. Defaults to 0, which disables\nthis feature. The service can check whether the service\nmanager expects watchdog keep-alive notifications. See\n<a href=\"https://man.page/3/sd_watchdog_enabled\">sd_watchdog_enabled(3)</a> for details.\n<a href=\"https://man.page/3/sd_event_set_watchdog\">sd_event_set_watchdog(3)</a> may be used to enable\nautomatic watchdog notification support.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Restart=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configures\nwhether the service shall be restarted when the service\nprocess exits, is killed, or a timeout is reached. The\nservice process may be the main service process, but it may\nalso be one of the processes specified with\n<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,\n<i>ExecStop=</i>, <i>ExecStopPost=</i>, or\n<i>ExecReload=</i>. When the death of the process is a\nresult of systemd operation (e.g. service stop or restart),\nthe service will not be restarted. Timeouts include missing\nthe watchdog &quot;keep-alive ping&quot; deadline and a\nservice start, reload, and stop operation\ntimeouts.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Takes\none of <b>no</b>, <b>on-success</b>, <b>on-failure</b>,\n<b>on-abnormal</b>, <b>on-watchdog</b>, <b>on-abort</b>, or\n<b>always</b>. If set to <b>no</b> (the default), the\nservice will not be restarted. If set to <b>on-success</b>,\nit will be restarted only when the service process exits\ncleanly. In this context, a clean exit means any of the\nfollowing:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nexit code of 0;</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nfor types other than <i>Type=oneshot</i>, one of the signals\n<b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM</b>, or\n<b>SIGPIPE</b>;</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">&bull;\nexit statuses and signals specified in\n<i>SuccessExitStatus=</i>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">If\nset to <b>on-failure</b>, the service will be restarted when\nthe process exits with a non-zero exit code, is terminated\nby a signal (including on core dump, but excluding the\naforementioned four signals), when an operation (such as\nservice reload) times out, and when the configured watchdog\ntimeout is triggered. If set to <b>on-abnormal</b>, the\nservice will be restarted when the process is terminated by\na signal (including on core dump, excluding the\naforementioned four signals), when an operation times out,\nor when the watchdog timeout is triggered. If set to\n<b>on-abort</b>, the service will be restarted only if the\nservice process exits due to an uncaught signal not\nspecified as a clean exit status. If set to\n<b>on-watchdog</b>, the service will be restarted only if\nthe watchdog timeout for the service expires. If set to\n<b>always</b>, the service will be restarted regardless of\nwhether it exited cleanly or not, got terminated abnormally\nby a signal, or hit a timeout.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><b>Table&nbsp;2.&nbsp;Exit\ncauses and the effect of the</b> <i>Restart=</i> settings\n<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp;</font></p>\n\n\n<p align=\"center\"><font color=\"#000000\"><img src=\"grohtml-3491402.png\" alt=\"Image grohtml-3491402.png\"></font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">As\nexceptions to the setting above, the service will not be\nrestarted if the exit code or signal is specified in\n<i>RestartPreventExitStatus=</i> (see below) or the service\nis stopped with <b>systemctl stop</b> or an equivalent\noperation. Also, the services will always be restarted if\nthe exit code or signal is specified in\n<i>RestartForceExitStatus=</i> (see below).</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat service restart is subject to unit start rate limiting\nconfigured with <i>StartLimitIntervalSec=</i> and\n<i>StartLimitBurst=</i>, see <b>systemd.unit</b>(5) for\ndetails. A restarted service enters the failed state only\nafter the start limits are reached.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Setting\nthis to <b>on-failure</b> is the recommended choice for\nlong-running services, in order to increase reliability by\nattempting automatic recovery from errors. For services that\nshall be able to terminate on their own choice (and avoid\nimmediate restarting), <b>on-abnormal</b> is an alternative\nchoice.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>SuccessExitStatus=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\nlist of exit status definitions that, when returned by the\nmain service process, will be considered successful\ntermination, in addition to the normal successful exit\nstatus 0 and, except for <i>Type=oneshot</i>, the signals\n<b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM</b>, and\n<b>SIGPIPE</b>. Exit status definitions can be numeric\ntermination statuses, termination status names, or\ntermination signal names, separated by spaces. See the\nProcess Exit Codes section in <b>systemd.exec</b>(5) for a\nlist of termination status names (for this setting only the\npart without the &quot;EXIT_&quot; or &quot;EX_&quot; prefix\nshould be used). See <a href=\"https://man.page/7/signal\">signal(7)</a> for a list of signal\nnames.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat this setting does not change the mapping between\nnumeric exit statuses and their names, i.e. regardless how\nthis setting is used 0 will still be mapped to\n&quot;SUCCESS&quot; (and thus typically shown as\n&quot;0/SUCCESS&quot; in tool outputs) and 1 to\n&quot;FAILURE&quot; (and thus typically shown as\n&quot;1/FAILURE&quot;), and so on. It only controls what\nhappens as effect of these exit statuses, and how it\npropagates to the state of the service as a\nwhole.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">This\noption may appear more than once, in which case the list of\nsuccessful exit statuses is merged. If the empty string is\nassigned to this option, the list is reset, all prior\nassignments of this option will have no effect.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;1.&nbsp;A\nservice with the</b> <i>SuccessExitStatus=</i>\nsetting</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">SuccessExitStatus=TEMPFAIL\n250 SIGKILL</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Exit\nstatus 75 (<b>TEMPFAIL</b>), 250, and the termination signal\n<b>SIGKILL</b> are considered clean service\nterminations.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note:\n<b>systemd-analyze exit-status</b> may be used to list exit\nstatuses and translate between numerical status values and\nnames.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>RestartPreventExitStatus=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\nlist of exit status definitions that, when returned by the\nmain service process, will prevent automatic service\nrestarts, regardless of the restart setting configured with\n<i>Restart=</i>. Exit status definitions can either be\nnumeric exit codes or termination signal names, and are\nseparated by spaces. Defaults to the empty list, so that, by\ndefault, no exit status is excluded from the configured\nrestart logic. For example:</font></p>\n\n\n<p style=\"margin-left:23%; margin-top: 1em\"><font color=\"#000000\">RestartPreventExitStatus=1\n6 SIGABRT</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">ensures\nthat exit codes 1 and 6 and the termination signal\n<b>SIGABRT</b> will not result in automatic service\nrestarting. This option may appear more than once, in which\ncase the list of restart-preventing statuses is merged. If\nthe empty string is assigned to this option, the list is\nreset and all prior assignments of this option will have no\neffect.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat this setting has no effect on processes configured via\n<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,\n<i>ExecStop=</i>, <i>ExecStopPost=</i> or\n<i>ExecReload=</i>, but only on the main service process,\ni.e. either the one invoked by <i>ExecStart=</i> or\n(depending on <i>Type=</i>, <i>PIDFile=</i>, ...) the\notherwise configured main process.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>RestartForceExitStatus=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\nlist of exit status definitions that, when returned by the\nmain service process, will force automatic service restarts,\nregardless of the restart setting configured with\n<i>Restart=</i>. The argument format is similar to\n<i>RestartPreventExitStatus=</i>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>RootDirectoryStartOnly=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Takes a\nboolean argument. If true, the root directory, as configured\nwith the <i>RootDirectory=</i> option (see\n<b>systemd.exec</b>(5) for more information), is only\napplied to the process started with <i>ExecStart=</i>, and\nnot to the various other <i>ExecStartPre=</i>,\n<i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>,\nand <i>ExecStopPost=</i> commands. If false, the setting is\napplied to all configured commands the same way. Defaults to\nfalse.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>NonBlocking=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Set the\n<b>O_NONBLOCK</b> flag for all file descriptors passed via\nsocket-based activation. If true, all file descriptors &gt;=\n3 (i.e. all except stdin, stdout, stderr), excluding those\npassed in via the file descriptor storage logic (see\n<i>FileDescriptorStoreMax=</i> for details), will have the\n<b>O_NONBLOCK</b> flag set and hence are in non-blocking\nmode. This option is only useful in conjunction with a\nsocket unit, as described in <b>systemd.socket</b>(5) and\nhas no effect on file descriptors which were previously\nsaved in the file-descriptor store for example. Defaults to\nfalse.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>NotifyAccess=</i></font></p>\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Controls\naccess to the service status notification socket, as\naccessible via the <a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a> call. Takes one of\n<b>none</b> (the default), <b>main</b>, <b>exec</b> or\n<b>all</b>. If <b>none</b>, no daemon status updates are\naccepted from the service processes, all status update\nmessages are ignored. If <b>main</b>, only service updates\nsent from the main process of the service are accepted. If\n<b>exec</b>, only service updates sent from any of the main\nor control processes originating from one of the\n<i>Exec*=</i> commands are accepted. If <b>all</b>, all\nservices updates from all members of the service's control\ngroup are accepted. This option should be set to open access\nto the notification socket when using <i>Type=notify</i> or\n<i>WatchdogSec=</i> (see above). If those options are used\nbut <i>NotifyAccess=</i> is not configured, it will be\nimplicitly set to <b>main</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat <b>sd_notify()</b> notifications may be attributed to\nunits correctly only if either the sending process is still\naround at the time PID 1 processes the message, or if the\nsending process is explicitly runtime-tracked by the service\nmanager. The latter is the case if the service manager\noriginally forked off the process, i.e. on all processes\nthat match <b>main</b> or <b>exec</b>. Conversely, if an\nauxiliary process of the unit sends an <b>sd_notify()</b>\nmessage and immediately exits, the service manager might not\nbe able to properly attribute the message to the unit, and\nthus will ignore it, even if <i>NotifyAccess=</i><b>all</b>\nis set for it.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Hence,\nto eliminate all race conditions involving lookup of the\nclient's unit and attribution of notifications to units\ncorrectly, <b>sd_notify_barrier()</b> may be used. This call\nacts as a synchronization point and ensures all\nnotifications sent before this call have been picked up by\nthe service manager when it returns successfully. Use of\n<b>sd_notify_barrier()</b> is needed for clients which are\nnot invoked by the service manager, otherwise this\nsynchronization mechanism is unnecessary for attribution of\nnotifications to the unit.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Sockets=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Specifies\nthe name of the socket units this service shall inherit\nsocket file descriptors from when the service is started.\nNormally, it should not be necessary to use this setting, as\nall socket file descriptors whose unit shares the same name\nas the service (subject to the different unit name suffix of\ncourse) are passed to the spawned process.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Note\nthat the same socket file descriptors may be passed to\nmultiple processes simultaneously. Also note that a\ndifferent service may be activated on incoming socket\ntraffic than the one which is ultimately configured to\ninherit the socket file descriptors. Or, in other words: the\n<i>Service=</i> setting of .socket units does not have to\nmatch the inverse of the <i>Sockets=</i> setting of the\n.service it refers to.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">This\noption may appear more than once, in which case the list of\nsocket units is merged. Note that once set, clearing the\nlist of sockets again (for example, by assigning the empty\nstring to this option) is not supported.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>FileDescriptorStoreMax=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configure\nhow many file descriptors may be stored in the service\nmanager for the service using\n<a href=\"https://man.page/3/sd_pid_notify_with_fds\">sd_pid_notify_with_fds(3)</a>'s &quot;FDSTORE=1&quot;\nmessages. This is useful for implementing services that can\nrestart after an explicit request or a crash without losing\nstate. Any open sockets and other file descriptors which\nshould not be closed during the restart may be stored this\nway. Application state can either be serialized to a file in\n/run/, or better, stored in a <a href=\"https://man.page/2/memfd_create\">memfd_create(2)</a> memory\nfile descriptor. Defaults to 0, i.e. no file descriptors may\nbe stored in the service manager. All file descriptors\npassed to the service manager from a specific service are\npassed back to the service's main process on the next\nservice restart (see <a href=\"https://man.page/3/sd_listen_fds\">sd_listen_fds(3)</a> for details\nabout the precise protocol used and the order in which the\nfile descriptors are passed). Any file descriptors passed to\nthe service manager are automatically closed when\n<b>POLLHUP</b> or <b>POLLERR</b> is seen on them, or when\nthe service is fully stopped and no job is queued or being\nexecuted for it. If this option is used,\n<i>NotifyAccess=</i> (see above) should be set to open\naccess to the notification socket provided by systemd. If\n<i>NotifyAccess=</i> is not set, it will be implicitly set\nto <b>main</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>USBFunctionDescriptors=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configure\nthe location of a file containing</font>\n<b><font color=\"#0000FF\">USB FunctionFS</font></b>\n<small><font color=\"#000000\">[2]</font></small>\n<font color=\"#000000\">descriptors, for implementation of USB\ngadget functions. This is used only in conjunction with a\nsocket unit with <i>ListenUSBFunction=</i> configured. The\ncontents of this file are written to the ep0 file after it\nis opened.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>USBFunctionStrings=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configure\nthe location of a file containing USB FunctionFS strings.\nBehavior is similar to <i>USBFunctionDescriptors=</i>\nabove.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>OOMPolicy=</i></font></p>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">Configure\nthe Out-Of-Memory (OOM) killer policy. On Linux, when memory\nbecomes scarce the kernel might decide to kill a running\nprocess in order to free up memory and reduce memory\npressure. This setting takes one of <b>continue</b>,\n<b>stop</b> or <b>kill</b>. If set to <b>continue</b> and a\nprocess of the service is killed by the kernel's OOM killer\nthis is logged but the service continues running. If set to\n<b>stop</b> the event is logged but the service is\nterminated cleanly by the service manager. If set to\n<b>kill</b> and one of the service's processes is killed by\nthe OOM killer the kernel is instructed to kill all\nremaining processes of the service, too. Defaults to the\nsetting <i>DefaultOOMPolicy=</i> in\n<b>systemd-system.conf</b>(5) is set to, except for services\nwhere <i>Delegate=</i> is turned on, where it defaults to\n<b>continue</b>.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Use\nthe <i>OOMScoreAdjust=</i> setting to configure whether\nprocesses of the unit shall be considered preferred or less\npreferred candidates for process termination by the Linux\nOOM killer logic. See <b>systemd.exec</b>(5) for\ndetails.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Check\n<b>systemd.exec</b>(5) and <b>systemd.kill</b>(5) for more\nsettings.</font></p>\n\n<h2>COMMAND LINES\n<a name=\"COMMAND LINES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\nsection describes command line parsing and variable and\nspecifier substitutions for <i>ExecStart=</i>,\n<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,\n<i>ExecReload=</i>, <i>ExecStop=</i>, and\n<i>ExecStopPost=</i> options.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Multiple\ncommand lines may be concatenated in a single directive by\nseparating them with semicolons (these semicolons must be\npassed as separate words). Lone semicolons may be escaped as\n&quot;\\;&quot;.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Each\ncommand line is unquoted using the rules described in\n&quot;Quoting&quot; section in <b>systemd.syntax</b>(7). The\nfirst item becomes the command to execute, and the\nsubsequent items the arguments.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\nsyntax is inspired by shell syntax, but only the\nmeta-characters and expansions described in the following\nparagraphs are understood, and the expansion of variables is\ndifferent. Specifically, redirection using &quot;&lt;&quot;,\n&quot;&lt;&lt;&quot;, &quot;&gt;&quot;, and\n&quot;&gt;&gt;&quot;, pipes using &quot;|&quot;, running\nprograms in the background using &quot;&amp;&quot;, and\n<i>other elements of shell syntax are not\nsupported</i>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\ncommand to execute may contain spaces, but control\ncharacters are not allowed.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\ncommand line accepts &quot;%&quot; specifiers as described\nin <b>systemd.unit</b>(5).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Basic\nenvironment variable substitution is supported. Use\n&quot;${FOO}&quot; as part of a word, or as a word of its\nown, on the command line, in which case it will be erased\nand replaced by the exact value of the environment variable\n(if any) including all whitespace it contains, always\nresulting in exactly a single argument. Use &quot;$FOO&quot;\nas a separate word on the command line, in which case it\nwill be replaced by the value of the environment variable\nsplit at whitespace, resulting in zero or more arguments.\nFor this type of expansion, quotes are respected when\nsplitting into words, and afterwards removed.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">If\nthe command is not a full (absolute) path, it will be\nresolved to a full path using a fixed search path determined\nat compilation time. Searched directories include\n/usr/local/bin/, /usr/bin/, /bin/ on systems using split\n/usr/bin/ and /bin/ directories, and their sbin/\ncounterparts on systems using split bin/ and sbin/. It is\nthus safe to use just the executable name in case of\nexecutables located in any of the &quot;standard&quot;\ndirectories, and an absolute path must be used in other\ncases. Using an absolute path is recommended to avoid\nambiguity. Hint: this search path may be queried using\n<b>systemd-path search-binaries-default</b>.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Example:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Environment=&quot;ONE=one&quot;\n'TWO=two two' <br>\nExecStart=echo $ONE $TWO ${TWO}</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\nwill execute <b>/bin/echo</b> with four arguments:\n&quot;one&quot;, &quot;two&quot;, &quot;two&quot;, and\n&quot;two two&quot;.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Example:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">Environment=ONE='one'\n&quot;TWO='two&nbsp;two'&nbsp;too&quot; THREE= <br>\nExecStart=/bin/echo ${ONE} ${TWO} ${THREE} <br>\nExecStart=/bin/echo $ONE $TWO $THREE</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\nresults in /bin/echo being called twice, the first time with\narguments &quot;'one'&quot;,\n&quot;'two&nbsp;two'&nbsp;too&quot;, &quot;&quot;, and the\nsecond time with arguments &quot;one&quot;,\n&quot;two&nbsp;two&quot;, &quot;too&quot;.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">To\npass a literal dollar sign, use &quot;$$&quot;. Variables\nwhose value is not known at expansion time are treated as\nempty strings. Note that the first argument (i.e. the\nprogram to execute) may not be a variable.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Variables\nto be used in this fashion may be defined through\n<i>Environment=</i> and <i>EnvironmentFile=</i>. In\naddition, variables listed in the section &quot;Environment\nvariables in spawned processes&quot; in\n<b>systemd.exec</b>(5), which are considered &quot;static\nconfiguration&quot;, may be used (this includes e.g.\n<i>$USER</i>, but not <i>$TERM</i>).</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Note\nthat shell command lines are not directly supported. If\nshell command lines are to be used, they need to be passed\nexplicitly to a shell implementation of some kind.\nExample:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">ExecStart=sh\n-c 'dmesg | tac'</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Example:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">ExecStart=echo\none ; echo &quot;two two&quot;</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\nwill execute <b>echo</b> two times, each time with one\nargument: &quot;one&quot; and &quot;two two&quot;,\nrespectively. Because two commands are specified,\n<i>Type=oneshot</i> must be used.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Example:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">ExecStart=echo\n/ &gt;/dev/null &amp; \\; \\ <br>\nls</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">This\nwill execute <b>echo</b> with five arguments: &quot;/&quot;,\n&quot;&gt;/dev/null&quot;, &quot;&amp;&quot;, &quot;;&quot;,\nand &quot;ls&quot;.</font></p>\n\n<h2>EXAMPLES\n<a name=\"EXAMPLES\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;2.&nbsp;Simple\nservice</b></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nfollowing unit file creates a service that will execute\n/usr/sbin/foo-daemon. Since no <i>Type=</i> is specified,\nthe default <i>Type=</i><b>simple</b> will be assumed.\nsystemd will assume the unit to be started immediately after\nthe program has begun executing.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Unit]\n<br>\nDescription=Foo</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Service]\n<br>\nExecStart=/usr/sbin/foo-daemon</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Install]\n<br>\nWantedBy=multi-user.target</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Note\nthat systemd assumes here that the process started by\nsystemd will continue running until the service terminates.\nIf the program daemonizes itself (i.e. forks), please use\n<i>Type=</i><b>forking</b> instead.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Since\nno <i>ExecStop=</i> was specified, systemd will send SIGTERM\nto all processes started from this service, and after a\ntimeout also SIGKILL. This behavior can be modified, see\n<b>systemd.kill</b>(5) for details.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Note\nthat this unit type does not include any type of\nnotification when a service has completed initialization.\nFor this, you should use other unit types, such as\n<i>Type=</i><b>notify</b> if the service understands\nsystemd's notification protocol, <i>Type=</i><b>forking</b>\nif the service can background itself or\n<i>Type=</i><b>dbus</b> if the unit acquires a DBus name\nonce initialization is complete. See below.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;3.&nbsp;Oneshot\nservice</b></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Sometimes,\nunits should just execute an action without keeping active\nprocesses, such as a filesystem check or a cleanup action on\nboot. For this, <i>Type=</i><b>oneshot</b> exists. Units of\nthis type will wait until the process specified terminates\nand then fall back to being inactive. The following unit\nwill perform a cleanup action:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Unit]\n<br>\nDescription=Cleanup old Foo data</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Service]\n<br>\nType=oneshot <br>\nExecStart=/usr/sbin/foo-cleanup</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Install]\n<br>\nWantedBy=multi-user.target</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Note\nthat systemd will consider the unit to be in the state\n&quot;starting&quot; until the program has terminated, so\nordered dependencies will wait for the program to finish\nbefore starting themselves. The unit will revert to the\n&quot;inactive&quot; state after the execution is done,\nnever reaching the &quot;active&quot; state. That means\nanother request to start the unit will perform the action\nagain.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Type=</i><b>oneshot</b>\nare the only service units that may have more than one\n<i>ExecStart=</i> specified. For units with multiple\ncommands (<i>Type=oneshot</i>), all commands will be run\nagain.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">For\n<i>Type=oneshot</i>, <i>Restart=</i><b>always</b> and\n<i>Restart=</i><b>on-success</b> are <i>not</i>\nallowed.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;4.&nbsp;Stoppable\noneshot service</b></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Similarly\nto the oneshot services, there are sometimes units that need\nto execute a program to set up something and then execute\nanother to shut it down, but no process remains active while\nthey are considered &quot;started&quot;. Network\nconfiguration can sometimes fall into this category. Another\nuse case is if a oneshot service shall not be executed each\ntime when they are pulled in as a dependency, but only the\nfirst time.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">For\nthis, systemd knows the setting\n<i>RemainAfterExit=</i><b>yes</b>, which causes systemd to\nconsider the unit to be active if the start action exited\nsuccessfully. This directive can be used with all types, but\nis most useful with <i>Type=</i><b>oneshot</b> and\n<i>Type=</i><b>simple</b>. With <i>Type=</i><b>oneshot</b>,\nsystemd waits until the start action has completed before it\nconsiders the unit to be active, so dependencies start only\nafter the start action has succeeded. With\n<i>Type=</i><b>simple</b>, dependencies will start\nimmediately after the start action has been dispatched. The\nfollowing unit provides an example for a simple static\nfirewall.</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Unit]\n<br>\nDescription=Simple firewall</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Service]\n<br>\nType=oneshot <br>\nRemainAfterExit=yes <br>\nExecStart=/usr/local/sbin/simple-firewall-start <br>\nExecStop=/usr/local/sbin/simple-firewall-stop</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Install]\n<br>\nWantedBy=multi-user.target</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Since\nthe unit is considered to be running after the start action\nhas exited, invoking <b>systemctl start</b> on that unit\nagain will cause no action to be taken.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;5.&nbsp;Traditional\nforking services</b></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Many\ntraditional daemons/services background (i.e. fork,\ndaemonize) themselves when starting. Set\n<i>Type=</i><b>forking</b> in the service's unit file to\nsupport this mode of operation. systemd will consider the\nservice to be in the process of initialization while the\noriginal program is still running. Once it exits\nsuccessfully and at least a process remains (and\n<i>RemainAfterExit=</i><b>no</b>), the service is considered\nstarted.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Often,\na traditional daemon only consists of one process.\nTherefore, if only one process is left after the original\nprocess terminates, systemd will consider that process the\nmain process of the service. In that case, the\n<i>$MAINPID</i> variable will be available in\n<i>ExecReload=</i>, <i>ExecStop=</i>, etc.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">In\ncase more than one process remains, systemd will be unable\nto determine the main process, so it will not assume there\nis one. In that case, <i>$MAINPID</i> will not expand to\nanything. However, if the process decides to write a\ntraditional PID file, systemd will be able to read the main\nPID from there. Please set <i>PIDFile=</i> accordingly. Note\nthat the daemon should write that file before finishing with\nits initialization. Otherwise, systemd might try to read the\nfile before it exists.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">The\nfollowing example shows a simple daemon that forks and just\nstarts one process in the background:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Unit]\n<br>\nDescription=Some simple daemon</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Service]\n<br>\nType=forking <br>\nExecStart=/usr/sbin/my-simple-daemon -d</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Install]\n<br>\nWantedBy=multi-user.target</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Please\nsee <b>systemd.kill</b>(5) for details on how you can\ninfluence the way systemd terminates the service.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;6.&nbsp;DBus\nservices</b></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">For\nservices that acquire a name on the DBus system bus, use\n<i>Type=</i><b>dbus</b> and set <i>BusName=</i> accordingly.\nThe service should not fork (daemonize). systemd will\nconsider the service to be initialized once the name has\nbeen acquired on the system bus. The following example shows\na typical DBus service:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Unit]\n<br>\nDescription=Simple DBus service</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Service]\n<br>\nType=dbus <br>\nBusName=org.example.simple-dbus-service <br>\nExecStart=/usr/sbin/simple-dbus-service</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Install]\n<br>\nWantedBy=multi-user.target</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">For\n<i>bus-activatable</i> services, do not include a [Install]\nsection in the systemd service file, but use the\n<i>SystemdService=</i> option in the corresponding DBus\nservice file, for example\n(/usr/share/dbus-1/system-services/org.example.simple-dbus-service.service):</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[D-BUS\nService] <br>\nName=org.example.simple-dbus-service <br>\nExec=/usr/sbin/simple-dbus-service <br>\nUser=root <br>\nSystemdService=simple-dbus-service.service</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Please\nsee <b>systemd.kill</b>(5) for details on how you can\ninfluence the way systemd terminates the service.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><b>Example&nbsp;7.&nbsp;Services\nthat notify systemd about their\ninitialization</b></font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><i>Type=</i><b>simple</b>\nservices are really easy to write, but have the major\ndisadvantage of systemd not being able to tell when\ninitialization of the given service is complete. For this\nreason, systemd supports a simple notification protocol that\nallows daemons to make systemd aware that they are done\ninitializing. Use <i>Type=</i><b>notify</b> for this. A\ntypical service file for such a daemon would look like\nthis:</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Unit]\n<br>\nDescription=Simple notifying service</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Service]\n<br>\nType=notify <br>\nExecStart=/usr/sbin/simple-notifying-service</font></p>\n\n\n<p style=\"margin-left:17%; margin-top: 1em\"><font color=\"#000000\">[Install]\n<br>\nWantedBy=multi-user.target</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Note\nthat the daemon has to support systemd's notification\nprotocol, else systemd will think the service has not\nstarted yet and kill it after a timeout. For an example of\nhow to update daemons to support this protocol\ntransparently, take a look at <a href=\"https://man.page/3/sd_notify\">sd_notify(3)</a>. systemd\nwill consider the unit to be in the 'starting' state until a\nreadiness notification has arrived.</font></p>\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\">Please\nsee <b>systemd.kill</b>(5) for details on how you can\ninfluence the way systemd terminates the service.</font></p>\n\n<h2>SEE ALSO\n<a name=\"SEE ALSO\"></a>\n</h2>\n\n\n\n<p style=\"margin-left:11%; margin-top: 1em\"><font color=\"#000000\"><a href=\"https://man.page/1/systemd\">systemd(1)</a>,\n<a href=\"https://man.page/1/systemctl\">systemctl(1)</a>, <b>systemd-system.conf</b>(5),\n<b>systemd.unit</b>(5), <b>systemd.exec</b>(5),\n<b>systemd.resource-control</b>(5), <b>systemd.kill</b>(5),\n<b>systemd.directives</b>(7),\n<a href=\"https://man.page/1/systemd-run\">systemd-run(1)</a></font></p>\n\n<h2>NOTES\n<a name=\"NOTES\"></a>\n</h2>\n\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">1.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"41%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">Incompatibilities\nwith SysV</font></p></td>\n<td width=\"42%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://www.freedesktop.org/wiki/Software/systemd/Incompatibilities</font></p>\n\n<table width=\"100%\" border=\"0\" rules=\"none\" frame=\"void\"\n       cellspacing=\"0\" cellpadding=\"0\">\n<tr valign=\"top\" align=\"left\">\n<td width=\"12%\"></td>\n<td width=\"3%\">\n\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">2.</font></p> </td>\n<td width=\"2%\"></td>\n<td width=\"21%\">\n\n\n<p style=\"margin-top: 1em\"><font color=\"#000000\">USB\nFunctionFS</font></p> </td>\n<td width=\"62%\">\n</td></tr>\n</table>\n\n\n<p style=\"margin-left:17%;\"><font color=\"#000000\">https://www.kernel.org/doc/Documentation/usb/functionfs.txt</font></p>\n<hr>\n","headings":["<a href=\"#NAME\">NAME</a>","<a href=\"#SYNOPSIS\">SYNOPSIS</a>","<a href=\"#DESCRIPTION\">DESCRIPTION</a>","<a href=\"#SERVICE TEMPLATES\">SERVICE TEMPLATES</a>","<a href=\"#AUTOMATIC DEPENDENCIES\">AUTOMATIC DEPENDENCIES</a>","<a href=\"#OPTIONS\">OPTIONS</a>","<a href=\"#COMMAND LINES\">COMMAND LINES</a>","<a href=\"#EXAMPLES\">EXAMPLES</a>","<a href=\"#SEE ALSO\">SEE ALSO</a>","<a href=\"#NOTES\">NOTES</a>"],"level":5}