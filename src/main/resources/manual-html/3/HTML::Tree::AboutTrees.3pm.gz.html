<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:46 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HTML::Tree::AboutTrees</title>

</head>
<body>

<h1 align="center">HTML::Tree::AboutTrees</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Trees">Trees</a><br>
<a href="#BACK">BACK</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">HTML::Tree::AboutTrees
-- article on tree-shaped data structures in Perl</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"># This an
article, not a module.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
article by Sean M. Burke first appeared in <i>The Perl
Journal</i> #18 and is copyright 2000 The Perl Journal. It
appears courtesy of Jon Orwant and The Perl Journal. This
document may be distributed under the same terms as Perl
itself.</p>

<h2>Trees
<a name="Trees"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">-- Sean M.
Burke</p>


<p style="margin-left:17%; margin-top: 1em">&quot;AaaAAAaauugh!
Watch out for that tree!&quot; <br>
-- <i>George of the Jungle theme</i></p>

<p style="margin-left:11%; margin-top: 1em">Perl&rsquo;s
facility with references, combined with its automatic
management of memory allocation, makes it straightforward to
write programs that store data in structures of arbitrary
form and complexity.</p>

<p style="margin-left:11%; margin-top: 1em">But I&rsquo;ve
noticed that many programmers, especially those who started
out with more restrictive languages, seem at home with
complex but uniform data structures -- N-dimensional arrays,
or more struct-like things like
hashes-of-arrays(-of-hashes(-of-hashes), etc.) -- but
they&rsquo;re often uneasy with building more freeform, less
tabular structures, like tree-shaped data structures.</p>

<p style="margin-left:11%; margin-top: 1em">But trees are
easy to build and manage in Perl, as I&rsquo;ll demonstrate
by showing off how the HTML::Element class manages elements
in an <small>HTML</small> document tree, and by walking you
through a from-scratch implementation of game trees. But
first we need to nail down what we mean by a
&quot;tree&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Socratic
Dialogues: &quot;What is a Tree?&quot;</b> <br>
My first brush with tree-shaped structures was in
linguistics classes, where tree diagrams are used to
describe the syntax underlying natural language sentences.
After learning my way around <i>those</i> trees, I started
to wonder -- are what I&rsquo;m used to calling
&quot;trees&quot; the same as what programmers call
&quot;trees&quot;? So I asked lots of helpful and patient
programmers how they would define a tree. Many replied with
a answer in jargon that they could not really explain
(understandable, since explaining things, especially
defining things, is harder than people think):</p>

<p style="margin-left:17%; margin-top: 1em">-- So what
<i>is</i> a &quot;tree&quot;, a tree-shaped data
structure?</p>

<p style="margin-left:17%; margin-top: 1em">-- A tree is a
special case of an acyclic directed graph!</p>

<p style="margin-left:17%; margin-top: 1em">-- What&rsquo;s
a &quot;graph&quot;?</p>

<p style="margin-left:17%; margin-top: 1em">-- Um...
lines... and... you draw it... with... arcs! nodes!
um...</p>

<p style="margin-left:11%; margin-top: 1em">The most
helpful were folks who couldn&rsquo;t explain directly, but
with whom I could get into a rather Socratic dialog (where
<i>I</i> asked the half-dim half-earnest questions), often
with much doodling of illustrations...</p>

<p style="margin-left:11%; margin-top: 1em">Question: so
what&rsquo;s a tree?</p>

<p style="margin-left:11%; margin-top: 1em">Answer: A tree
is a collection of nodes that are linked together in a,
well, tree-like way! Like this <i>[drawing on a
napkin]:</i></p>

<p style="margin-left:11%; margin-top: 1em">A <br>
/ \ <br>
B C <br>
/ | \ <br>
D E F</p>

<p style="margin-left:11%; margin-top: 1em">Q: So what do
these letters represent?</p>

<p style="margin-left:11%; margin-top: 1em">A: Each is a
different node, a bunch of data. Maybe C is a bunch of data
that stores a number, maybe a hash table, maybe nothing at
all besides the fact that it links to D, E, and F (which are
other nodes).</p>

<p style="margin-left:11%; margin-top: 1em">Q: So
what&rsquo;re the lines between the nodes?</p>

<p style="margin-left:11%; margin-top: 1em">A: Links. Also
called &quot;arcs&quot;. They just symbolize the fact that
each node holds a list of nodes it links to.</p>

<p style="margin-left:11%; margin-top: 1em">Q: So what if I
draw nodes and links, like this...</p>

<p style="margin-left:11%; margin-top: 1em">B -- E <br>
/ \ / \ <br>
A C <br>
\ / <br>
E</p>

<p style="margin-left:11%; margin-top: 1em">Is that still a
tree?</p>

<p style="margin-left:11%; margin-top: 1em">A: No, not at
all. There&rsquo;s a lot of un-treelike things about that.
First off, E has a link coming off of it going into nowhere.
You can&rsquo;t have a link to nothing -- you can only link
to another node. Second off, I don&rsquo;t know what that
sideways link between B and E means...</p>

<p style="margin-left:11%; margin-top: 1em">Q: Okay,
let&rsquo;s work our way up from something simpler. Is this
a tree...?</p>

<p style="margin-left:11%; margin-top: 1em">A</p>

<p style="margin-left:11%; margin-top: 1em">A: Yes, I
suppose. It&rsquo;s a tree of just one node.</p>

<p style="margin-left:11%; margin-top: 1em">Q: And how
about...</p>

<p style="margin-left:11%; margin-top: 1em">A <br>
B</p>

<p style="margin-left:11%; margin-top: 1em">A: No, you
can&rsquo;t just have nodes floating there, unattached.</p>

<p style="margin-left:11%; margin-top: 1em">Q: Okay,
I&rsquo;ll link A and B. How&rsquo;s this?</p>

<p style="margin-left:11%; margin-top: 1em">A <br>
| <br>
B</p>

<p style="margin-left:11%; margin-top: 1em">A: Yup,
that&rsquo;s a tree. There&rsquo;s a node A, and a node B,
and they&rsquo;re linked.</p>

<p style="margin-left:11%; margin-top: 1em">Q: How is that
tree any different from this one...?</p>

<p style="margin-left:11%; margin-top: 1em">B <br>
| <br>
A</p>

<p style="margin-left:11%; margin-top: 1em">A: Well, in
both cases A and B are linked. But it&rsquo;s in a different
direction.</p>

<p style="margin-left:11%; margin-top: 1em">Q: Direction?
What does the direction mean?</p>

<p style="margin-left:11%; margin-top: 1em">A: Well, it
depends what the tree represents. If it represents a
categorization, like this:</p>

<p style="margin-left:11%; margin-top: 1em">citrus <br>
/ | \ <br>
orange lemon kumquat ...</p>

<p style="margin-left:11%; margin-top: 1em">then you mean
to say that oranges, lemons, kumquats, etc., are a kind of
citrus. But if you drew it upside down, you&rsquo;d be
saying, falsely, that citrus is a kind of kumquat, a kind of
lemon, and a kind of orange. If the tree represented
cause-and-effect (or at least what situations could follow
others), or represented what&rsquo;s a part of what, you
wouldn&rsquo;t want to get those backwards, either. So with
the nodes you draw together on paper, one has to be over the
other, so you can tell which way the relationship in the
tree works.</p>

<p style="margin-left:11%; margin-top: 1em">Q: So are these
two trees the same?</p>

<p style="margin-left:11%; margin-top: 1em">A A <br>
/ \ / \ <br>
B C B \ <br>
C</p>

<p style="margin-left:11%; margin-top: 1em">A: Yes,
although by convention we often try to line up things in the
same generation, like it is in the diagram on the left.</p>

<p style="margin-left:11%; margin-top: 1em">Q:
&quot;generation&quot;? This is a family tree?</p>

<p style="margin-left:11%; margin-top: 1em">A: No, not
unless it&rsquo;s a family tree for just yeast cells or
something else that reproduces asexually. But for sake of
having lots of terms to use, we just pretend that links in
the tree represent the &quot;is a child of&quot;
relationship, instead of &quot;is a kind of&quot; or
&quot;is a part of&quot;, or &quot;could result from&quot;,
or whatever the real relationship is. So we get to borrow a
lot of kinship words for describing trees -- B and C are
&quot;children&quot; (or &quot;daughters&quot;) of A; A is
the &quot;parent&quot; (or &quot;mother&quot;) of B and C.
Node C is a &quot;sibling&quot; (or &quot;sister&quot;) of
node C; and so on, with terms like &quot;descendants&quot;
(a node&rsquo;s children, children&rsquo;s children, etc.),
and &quot;generation&quot; (all the nodes at the same
&quot;level&quot; in the tree, i.e., are either all
grandchildren of the top node, or all great-grand-children,
etc.), and &quot;lineage&quot; or &quot;ancestors&quot;
(parents, and parent&rsquo;s parents, etc., all the way to
the topmost node).</p>

<p style="margin-left:11%; margin-top: 1em">So then we get
to express rules in terms like &quot;<b>A node cannot have
more than one parent</b>&quot;, which means that this is not
a valid tree:</p>

<p style="margin-left:11%; margin-top: 1em">A <br>
/ \ <br>
B C <br>
\ / <br>
E</p>

<p style="margin-left:11%; margin-top: 1em">And: &quot;<b>A
node can&rsquo;t be its own parent</b>&quot;, which excludes
this looped-up connection:</p>

<p style="margin-left:11%; margin-top: 1em">/\ <br>
A | <br>
\/</p>

<p style="margin-left:11%; margin-top: 1em">Or, put more
generally: &quot;<b>A node can&rsquo;t be its own
ancestor</b>&quot;, which excludes the above loop, as well
as the one here:</p>

<p style="margin-left:11%; margin-top: 1em">/\ <br>
Z | <br>
/ | <br>
A | <br>
/ \ | <br>
B C | <br>
\/</p>

<p style="margin-left:11%; margin-top: 1em">That tree is
excluded because A is a child of Z, and Z is a child of C,
and C is a child of A, which means A is its own
great-grandparent. So this whole network can&rsquo;t be a
tree, because it breaks the sort of meta-rule: <b>once any
node in the supposed tree breaks the rules for trees, you
don&rsquo;t have a tree anymore.</b></p>

<p style="margin-left:11%; margin-top: 1em">Q: Okay, now,
are these two trees the same?</p>

<p style="margin-left:11%; margin-top: 1em">A A <br>
/ | \ / | \ <br>
B C D D C B</p>

<p style="margin-left:11%; margin-top: 1em">A: It depends
whether you&rsquo;re basing your concept of trees on each
node having a set (unordered list) of children, or an
(ordered) list of children. It&rsquo;s a question of whether
ordering is important for what you&rsquo;re doing. With my
diagram of citrus types, ordering isn&rsquo;t important, so
these tree diagrams express the same thing:</p>

<p style="margin-left:11%; margin-top: 1em">citrus <br>
/ | \ <br>
orange lemon kumquat <br>
citrus <br>
/ | \ <br>
kumquat orange lemon</p>

<p style="margin-left:11%; margin-top: 1em">because it
doesn&rsquo;t make sense to say that oranges are
&quot;before&quot; or &quot;after&quot; kumquats in the
whole botanical scheme of things. (Unless, of course, you
<i>are</i> using ordering to mean something, like a degree
of genetic similarity.)</p>

<p style="margin-left:11%; margin-top: 1em">But consider a
tree that&rsquo;s a diagram of what steps are comprised in
an activity, to some degree of specificity:</p>

<p style="margin-left:11%; margin-top: 1em">make tea <br>
/ | \ <br>
pour infuse serve <br>
hot water / \ <br>
in cup/pot / \ <br>
add let <br>
tea sit <br>
leaves</p>

<p style="margin-left:11%; margin-top: 1em">This means that
making tea consists of putting hot water in a cup or put,
infusing it (which itself consists of adding tea leaves and
letting it sit), then serving it -- <i>in that order</i>. If
you serve an empty dry pot (sipping from empty cups, etc.),
let it sit, add tea leaves, and pour in hot water, then what
you&rsquo;re doing is performance art, not tea
preparation:</p>

<p style="margin-left:11%; margin-top: 1em">performance
<br>
art <br>
/ | \ <br>
serve infuse pour <br>
/ \ hot water <br>
/ \ in cup/pot <br>
let add <br>
sit tea <br>
leaves</p>

<p style="margin-left:11%; margin-top: 1em">Except for my
having renamed the root, this tree is the same as the
making-tea tree as far as what&rsquo;s under what, but it
differs in order, and what the tree means makes the order
important.</p>

<p style="margin-left:11%; margin-top: 1em">Q: Wait --
&quot;root&quot;? What&rsquo;s a root?</p>

<p style="margin-left:11%; margin-top: 1em">A: Besides
kinship terms like &quot;mother&quot; and
&quot;daughter&quot;, the jargon for tree parts also has
terms from real-life tree parts: the part that everything
else grows from is called the root; and nodes that
don&rsquo;t have nodes attached to them (i.e., childless
nodes) are called &quot;leaves&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Q: But
you&rsquo;ve been drawing all your trees with the root at
the top and leaves at the bottom.</p>

<p style="margin-left:11%; margin-top: 1em">A: Yes, but for
some reason, that&rsquo;s the way everyone seems to think of
trees. They can draw trees as above; or they can draw them
sort of sideways with indenting representing what nodes are
children of what:</p>

<p style="margin-left:11%; margin-top: 1em">* make tea <br>
* pour hot water in cup/pot <br>
* infuse <br>
* add tea leaves <br>
* let sit <br>
* serve</p>

<p style="margin-left:11%; margin-top: 1em">...but folks
almost never seem to draw trees with the root at the bottom.
So imagine it&rsquo;s based on spider plant in a hanging
pot. Unfortunately, spider plants <i>aren&rsquo;t</i>
botanically trees, they&rsquo;re plants; but &quot;spider
plant diagram&quot; is rather a mouthful, so let&rsquo;s
just call them trees.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Trees
Defined Formally</b> <br>
In time, I digested all these assorted facts about
programmers&rsquo; ideas of trees (which turned out to be
just a more general case of linguistic ideas of trees) into
a single rule:</p>

<p style="margin-left:11%; margin-top: 1em">* A node is an
item that contains (&quot;is over&quot;, &quot;is parent
of&quot;, etc.) zero or more other nodes.</p>

<p style="margin-left:11%; margin-top: 1em">From this you
can build up formal definitions for useful terms, like
so:</p>

<p style="margin-left:11%; margin-top: 1em">* A
node&rsquo;s <b>descendants</b> are defined as all its
children, and all their children, and so on. Or, stated
recursively: a node&rsquo;s descendants are all its
children, and all its children&rsquo;s descendants. (And if
it has no children, it has no descendants.)</p>

<p style="margin-left:11%; margin-top: 1em">* A
node&rsquo;s <b>ancestors</b> consist of its parent, and its
parent&rsquo;s parent, etc, up to the root. Or, recursively:
a node&rsquo;s ancestors consist of its parent and its
parent&rsquo;s ancestors. (If it has no parent, it has no
ancestors.)</p>

<p style="margin-left:11%; margin-top: 1em">* A <b>tree</b>
is a root node and all the root&rsquo;s descendants.</p>

<p style="margin-left:11%; margin-top: 1em">And you can add
a proviso or two to clarify exactly what I impute to the
word &quot;other&quot; in &quot;other nodes&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">* A node cannot
contain itself, or contain any node that contains it, etc.
Looking at it the other way: a node cannot be its own parent
or ancestor.</p>

<p style="margin-left:11%; margin-top: 1em">* A node can be
root (i.e., no other node contains it) or can be contained
by only one parent; no node can be the child of two or more
parents.</p>

<p style="margin-left:11%; margin-top: 1em">Add to this the
idea that children are sometimes ordered, and sometimes not,
and that&rsquo;s about all you need to know about defining
what a tree is. From there it&rsquo;s a matter of using
them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Markup
Language Trees: HTML-Tree</b> <br>
While not <i>all</i> markup languages are inherently
tree-like, the best-known family of markup languages,
<small>HTML, SGML,</small> and <small>XML,</small> are about
as tree-like as you can get. In these languages, a document
consists of elements and character data in a tree structure
where there is one root element, and elements can contain
either other elements, or character data.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: For
sake of simplicity, I&rsquo;m glossing over comments
(&lt;!-- ... --&gt;), processing instructions (&lt;?xml
version=&rsquo;1.0&rsquo;&gt;), and declarations
(&lt;!ELEMENT ...&gt;, &lt;!DOCTYPE ...&gt;). And I&rsquo;m
not bothering to distinguish entity references (&amp;lt;,
&amp;#64;) or <small>CDATA</small> sections (&lt;![CDATA[
...]]&gt;) from normal text.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
consider this <small>HTML</small> document:</p>

<p style="margin-left:11%; margin-top: 1em">&lt;html
lang=&quot;en-US&quot;&gt; <br>
&lt;head&gt; <br>
&lt;title&gt; <br>
Blank Document! <br>
&lt;/title&gt; <br>
&lt;/head&gt; <br>
&lt;body bgcolor=&quot;#d010ff&quot;&gt; <br>
I've got <br>
&lt;em&gt; <br>
something to saaaaay <br>
&lt;/em&gt; <br>
! <br>
&lt;/body&gt; <br>
&lt;/html&gt;</p>

<p style="margin-left:11%; margin-top: 1em">I&rsquo;ve
indented this to point out what nodes (elements or text
items) are children of what, with each node on a line of its
own.</p>

<p style="margin-left:11%; margin-top: 1em">The
HTML::TreeBuilder module (in the <small>CPAN</small>
distribution HTML-Tree) does the work of taking
<small>HTML</small> source and building in memory the tree
that the document source represents.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: it
requires the HTML::Parser module, which tokenizes the source
-- i.e., identifies each tag, bit of text, comment, etc.</p>

<p style="margin-left:11%; margin-top: 1em">The trees
structures that it builds represent bits of text with normal
Perl scalar string values; but elements are represented with
objects -- that is, chunks of data that belong to a class
(in this case, HTML::Element), a class that provides methods
(routines) for accessing the pieces of data in each element,
and otherwise doing things with elements. (See my article in
TPJ#17 for a quick explanation of objects, the
<small>POD</small> document &quot;perltoot&quot; for a
longer explanation, or Damian Conway&rsquo;s excellent book
<i>Object-Oriented Perl</i> for the full story.)</p>

<p style="margin-left:11%; margin-top: 1em">Each
HTML::Element object contains a number of pieces of
data:</p>

<p style="margin-left:11%; margin-top: 1em">* its element
name (&quot;html&quot;, &quot;h1&quot;, etc., accessed as
$element-&gt;tag)</p>

<p style="margin-left:11%; margin-top: 1em">* a list of
elements (or text segments) that it contains, if any
(accessed as $element-&gt;content_list or
$element-&gt;content, depending on whether you want a list,
or an arrayref)</p>

<p style="margin-left:11%; margin-top: 1em">* what element,
if any, contains it (accessed as $element-&gt;parent)</p>

<p style="margin-left:11%; margin-top: 1em">* and any
<small>SGML</small> attributes that the element has, such as
&quot;lang=&quot;en-US&quot;&quot;,
&quot;align=&quot;center&quot;&quot;, etc. (accessed as
$element-&gt;attr(&rsquo;lang&rsquo;),
$element-&gt;attr(&rsquo;center&rsquo;), etc.)</p>

<p style="margin-left:11%; margin-top: 1em">So, for
example, when HTML::TreeBuilder builds the tree for the
above <small>HTML</small> document source, the object for
the &quot;body&quot; element has these pieces of data:</p>

<p style="margin-left:11%; margin-top: 1em">* element name:
&quot;body&quot; <br>
* nodes it contains: <br>
the string &quot;I've got &quot; <br>
the object for the &quot;em&quot; element <br>
the string &quot;!&quot; <br>
* its parent: <br>
the object for the &quot;html&quot; element <br>
* bgcolor: &quot;#d010ff&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Now, once you
have this tree of objects, almost anything you&rsquo;d want
to do with it starts with searching the tree for some bit of
information in some element.</p>

<p style="margin-left:11%; margin-top: 1em">Accessing a
piece of information in, say, a hash of hashes of hashes, is
straightforward:</p>


<p style="margin-left:11%; margin-top: 1em">$password{'sean'}{'sburke1'}{'hpux'}</p>

<p style="margin-left:11%; margin-top: 1em">because you
know that all data points in that structure are accessible
with that syntax, but with just different keys. Now, the
&quot;em&quot; element in the above <small>HTML</small> tree
does happen to be accessible as the root&rsquo;s child
#1&rsquo;s child #1:</p>


<p style="margin-left:11%; margin-top: 1em">$root-&gt;content-&gt;[1]-&gt;content-&gt;[1]</p>

<p style="margin-left:11%; margin-top: 1em">But with trees,
you typically don&rsquo;t know the exact location (via
indexes) of the data you&rsquo;re looking for. Instead,
finding what you want will typically involve searching
through the tree, seeing if every node is the kind you want.
Searching the whole tree is simple enough -- look at a given
node, and if it&rsquo;s not what you want, look at its
children, and so on. HTML-Tree provides several methods that
do this for you, such as &quot;find_by_tag_name&quot;, which
returns the elements (or the first element, if called in
scalar context) under a given node (typically the root)
whose tag name is whatever you specify.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
that &quot;em&quot; node can be found as:</p>

<p style="margin-left:11%; margin-top: 1em">my $that_em =
$root-&gt;find_by_tag_name('em');</p>

<p style="margin-left:11%; margin-top: 1em">or as:</p>

<p style="margin-left:11%; margin-top: 1em">@ems =
$root-&gt;find_by_tag_name('em'); <br>
# will only have one element for this particular tree</p>

<p style="margin-left:11%; margin-top: 1em">Now, given an
<small>HTML</small> document of whatever structure and
complexity, if you wanted to do something like change
every</p>


<p style="margin-left:17%; margin-top: 1em">&lt;em&gt;<i>stuff</i>&lt;/em&gt;</p>

<p style="margin-left:11%; margin-top: 1em">to</p>

<p style="margin-left:17%; margin-top: 1em">&lt;em
class=&quot;funky&quot;&gt; <b>&lt;b&gt;[-&lt;/b&gt;</b>
<i>stuff</i> <b>&lt;b&gt;-]&lt;/b&gt;</b> &lt;/em&gt;</p>

<p style="margin-left:11%; margin-top: 1em">the first step
is to frame this operation in terms of what you&rsquo;re
doing to the tree. You&rsquo;re changing this:</p>

<p style="margin-left:11%; margin-top: 1em">em <br>
| <br>
...</p>

<p style="margin-left:11%; margin-top: 1em">to this:</p>

<p style="margin-left:11%; margin-top: 1em">em <br>
/ | \ <br>
b ... b <br>
| | <br>
&quot;[-&quot; &quot;-]&quot;</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
you&rsquo;re finding all elements whose tag name is
&quot;em&quot;, setting its class attribute to
&quot;funky&quot;, and adding one child to the start of its
content list -- a new &quot;b&quot; element whose content is
the text string &quot;[-&quot; -- and one to the end of its
content list -- a new &quot;b&quot; element whose content is
the text string &quot;-]&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Once
you&rsquo;ve got it in these terms, it&rsquo;s just a matter
of running to the HTML::Element documentation, and coding
this up with calls to the appropriate methods, like so:</p>

<p style="margin-left:11%; margin-top: 1em">use
HTML::Element 1.53; <br>
use HTML::TreeBuilder 2.96; <br>
# Build the tree by parsing the document <br>
my $root = HTML::TreeBuilder-&gt;new; <br>
$root-&gt;parse_file('whatever.html'); # source file <br>
# Now make new nodes where needed <br>
foreach my $em ($root-&gt;find_by_tag_name('em')) { <br>
$em-&gt;attr('class', 'funky'); # Set that attribute <br>
# Make the two new B nodes <br>
my $new1 = HTML::Element-&gt;new('b'); <br>
my $new2 = HTML::Element-&gt;new('b'); <br>
# Give them content (they have none at first) <br>
$new1-&gt;push_content('[-'); <br>
$new2-&gt;push_content('-]'); <br>
# And put 'em in place! <br>
$em-&gt;unshift_content($new1); <br>
$em-&gt;push_content($new2); <br>
} <br>
print <br>
&quot;&lt;!-- Looky see what I did! --&gt;\n&quot;, <br>
$root-&gt;as_HTML(), &quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The class
HTML::Element provides just about every method I can image
you needing, for manipulating trees made of HTML::Element
objects. (And what it doesn&rsquo;t directly provide, it
will give you the components to build it with.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Building
Your Own Trees</b> <br>
Theoretically, any tree is pretty much like any other tree,
so you could use HTML::Element for anything you&rsquo;d ever
want to do with tree-arranged objects. However, as its name
implies, HTML::Element is basically <i>for</i>
<small>HTML</small> elements; it has lots of features that
make sense only for <small>HTML</small> elements (like the
idea that every element must have a tag-name). And it lacks
some features that might be useful for general applications
-- such as any sort of checking to make sure that
you&rsquo;re not trying to arrange objects in a non-treelike
way. For a general-purpose tree class that does have such
features, you can use Tree::DAG_Node, also available from
<small>CPAN.</small></p>

<p style="margin-left:11%; margin-top: 1em">However, if
your task is simple enough, you might find it overkill to
bother using Tree::DAG_Node. And, in any case, I find that
the best way to learn how something works is to implement it
(or something like it, but simpler) yourself. So I&rsquo;ll
here discuss how you&rsquo;d implement a tree structure,
<i>without</i> using any of the existing classes for tree
nodes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Implementation:
Game Trees for Alak</b> <br>
Suppose that the task at hand is to write a program that can
play against a human opponent at a strategic board game (as
opposed to a board game where there&rsquo;s an element of
chance). For most such games, a &quot;game tree&quot; is an
essential part of the program (as I will argue, below), and
this will be our test case for implementing a tree structure
from scratch.</p>

<p style="margin-left:11%; margin-top: 1em">For sake of
simplicity, our game is not chess or backgammon, but instead
a much simpler game called Alak. Alak was invented by the
mathematician A. K. Dewdney, and described in his 1984 book
<i>Planiverse</i>. The rules of Alak are simple:</p>

<p style="margin-left:17%; margin-top: 1em">Footnote:
Actually, I&rsquo;m describing only my interpretation of the
rules Dewdney describes in <i>Planiverse</i>. Many other
interpretations are possible.</p>

<p style="margin-left:11%; margin-top: 1em">* Alak is a
two-player game played on a one-dimensional board with
eleven slots on it. Each slot can hold at most one piece at
a time. There&rsquo;s two kinds of pieces, which I represent
here as &quot;x&quot; and &quot;o&quot; -- x&rsquo;s belong
to one player (called X), o&rsquo;s to the other (called
O).</p>

<p style="margin-left:11%; margin-top: 1em">* The initial
configuration of the board is:</p>


<p style="margin-left:11%; margin-top: 1em">xxxx___oooo</p>

<p style="margin-left:11%; margin-top: 1em">For sake of the
article, the slots are numbered from 1 (on the left) to 11
(on the right), and X always has the first move.</p>

<p style="margin-left:11%; margin-top: 1em">* The players
take turns moving. At each turn, each player can move only
one piece, once. (This unlike checkers, where you move one
piece per move but get to keep moving it if you jump an your
opponent&rsquo;s piece.) A player cannot pass up on his
turn. A player can move any one of his pieces to the next
unoccupied slot to its right or left, which may involve
jumping over occupied slots. A player cannot move a piece
off the side of the board.</p>

<p style="margin-left:11%; margin-top: 1em">* If a move
creates a pattern where the opponent&rsquo;s pieces are
surrounded, on both sides, by two pieces of the
mover&rsquo;s color (with no intervening unoccupied blank
slot), then those surrounded pieces are removed from the
board.</p>

<p style="margin-left:11%; margin-top: 1em">* The goal of
the game is to remove all of your opponent&rsquo;s pieces,
at which point the game ends. Removing all-but-one ends the
game as well, since the opponent can&rsquo;t surround you
with one piece, and so will always lose within a few moves
anyway.</p>

<p style="margin-left:11%; margin-top: 1em">Consider, then,
this rather short game where X starts:</p>

<p style="margin-left:11%; margin-top: 1em">xxxx___oooo
<br>
^ Move 1: X moves from 3 (shown with caret) to 5 <br>
(Note that any of X's pieces could move, but <br>
that the only place they could move to is 5.) <br>
xx_xx__oooo <br>
^ Move 2: O moves from 9 to 7. <br>
xx_xx_oo_oo <br>
^ Move 3: X moves from 4 to 6. <br>
xx__xxoo_oo <br>
^ Move 4: O (stupidly) moves from 10 to 9. <br>
xx__xxooo_o <br>
^ Move 5: X moves from 5 to 10, making the board <br>
&quot;xx___xoooxo&quot;. The three o's that X just <br>
surrounded are removed. <br>
xx___x___xo <br>
O has only one piece, so has lost.</p>

<p style="margin-left:11%; margin-top: 1em">Now, move 4
could have gone quite the other way:</p>

<p style="margin-left:11%; margin-top: 1em">xx__xxoo_oo
<br>
Move 4: O moves from 8 to 4, making the board <br>
&quot;xx_oxxo__oo&quot;. The surrounded x's are removed.
<br>
xx_o__o__oo <br>
^ Move 5: X moves from 1 to 2. <br>
_xxo__o__oo <br>
^ Move 6: O moves from 7 to 6. <br>
_xxo_o___oo <br>
^ Move 7: X moves from 2 to 5, removing the o at 4. <br>
__x_xo___oo <br>
...and so on.</p>

<p style="margin-left:11%; margin-top: 1em">To teach a
computer program to play Alak (as player X, say), it needs
to be able to look at the configuration of the board, figure
out what moves it can make, and weigh the benefit or costs,
immediate or eventual, of those moves.</p>

<p style="margin-left:11%; margin-top: 1em">So consider the
board from just before move 3, and figure all the possible
moves X could make. X has pieces in slots 1, 2, 4, and 5.
The leftmost two x&rsquo;s (at 1 and 2) are up against the
end of the board, so they can move only right. The other two
x&rsquo;s (at 4 and 5) can move either right or left:</p>

<p style="margin-left:11%; margin-top: 1em">Starting board:
xx_xx_oo_oo <br>
moving 1 to 3 gives _xxxx_oo_oo <br>
moving 2 to 3 gives x_xxx_oo_oo <br>
moving 4 to 3 gives xxx_x_oo_oo <br>
moving 5 to 3 gives xxxx__oo_oo <br>
moving 4 to 6 gives xx__xxoo_oo <br>
moving 5 to 6 gives xx_x_xoo_oo</p>

<p style="margin-left:11%; margin-top: 1em">For the
computer to decide which of these is the best move to make,
it needs to quantify the benefit of these moves as a number
-- call that the &quot;payoff&quot;. The payoff of a move
can be figured as just the number of x pieces removed by the
most recent move, minus the number of o pieces removed by
the most recent move. (It so happens that the rules of the
game mean that no move can delete both o&rsquo;s and
x&rsquo;s, but the formula still applies.) Since none of
these moves removed any pieces, all these moves have the
same immediate payoff: 0.</p>

<p style="margin-left:11%; margin-top: 1em">Now, we could
race ahead and write an Alak-playing program that could use
the immediate payoff to decide which is the best move to
make. And when there&rsquo;s more than one best move (as
here, where all the moves are equally good), it could choose
randomly between the good alternatives. This strategy is
simple to implement; but it makes for a very dumb program.
Consider what O&rsquo;s response to each of the potential
moves (above) could be. Nothing immediately suggests itself
for the first four possibilities (X having moved something
to position 3), but either of the last two (illustrated
below) are pretty perilous, because in either case O has the
obvious option (which he would be foolish to pass up) of
removing x&rsquo;s from the board:</p>

<p style="margin-left:11%; margin-top: 1em">xx_xx_oo_oo
<br>
^ X moves 4 to 6. <br>
xx__xxoo_oo <br>
^ O moves 8 to 4, giving &quot;xx_oxxo__oo&quot;. The two
<br>
surrounded x's are removed. <br>
xx_o__o__oo</p>

<p style="margin-left:11%; margin-top: 1em">or</p>

<p style="margin-left:11%; margin-top: 1em">xx_xx_oo_oo
<br>
^ X moves 5 to 6. <br>
xx_x_xoo_oo <br>
^ O moves 8 to 5, giving &quot;xx_xoxo__oo&quot;. The one
<br>
surrounded x is removed. <br>
xx_xo_o__oo</p>

<p style="margin-left:11%; margin-top: 1em">Both
contingencies are quite bad for X -- but this is not
captured by the fact that they start out with X thinking his
move will be harmless, having a payoff of zero.</p>

<p style="margin-left:11%; margin-top: 1em">So what&rsquo;s
needed is for X to think <i>more</i> than one step ahead --
to consider not merely what it can do in this move, and what
the payoff is, but to consider what O might do in response,
and the payoff of those potential moves, and so on with
X&rsquo;s possible responses to those cases could be. All
these possibilities form a game tree -- a tree where each
node is a board, and its children are successors of that
node -- i.e., the boards that could result from every move
possible, given the parent&rsquo;s board.</p>

<p style="margin-left:11%; margin-top: 1em">But how to
represent the tree, and how to represent the nodes?</p>

<p style="margin-left:11%; margin-top: 1em">Well, consider
that a node holds several pieces of data:</p>

<p style="margin-left:11%; margin-top: 1em">1) the
configuration of the board, which, being nice and simple and
one-dimensional, can be stored as just a string, like
&quot;xx_xx_oo_oo&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">2) whose turn
it is, X or O. (Or: who moved last, from which we can figure
whose turn it is).</p>

<p style="margin-left:11%; margin-top: 1em">3) the
successors (child nodes).</p>

<p style="margin-left:11%; margin-top: 1em">4) the
immediate payoff of having moved to this board position from
its predecessor (parent node).</p>

<p style="margin-left:11%; margin-top: 1em">5) and what
move gets us from our predecessor node to here. (Granted,
knowing the board configuration before and after the move,
it&rsquo;s easy to figure out the move; but it&rsquo;s
easier still to store it as one is figuring out a
node&rsquo;s successors.)</p>

<p style="margin-left:11%; margin-top: 1em">6) whatever
else we might want to add later.</p>

<p style="margin-left:11%; margin-top: 1em">These could be
stored equally well in an array or in a hash, but it&rsquo;s
my experience that hashes are best for cases where you have
more than just two or three bits of data, or especially when
you might need to add new bits of data. Moreover, hash key
names are mnemonic --
$node-&gt;{&rsquo;last_move_payoff&rsquo;} is plain as day,
whereas it&rsquo;s not so easy having to remember with an
array that $node-&gt;[3] is where you decided to keep the
payoff.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: Of
course, there are ways around that problem: just swear
you&rsquo;ll never use a real numeric index to access data
in the array, and instead use constants with mnemonic
names:</p>

<p style="margin-left:17%; margin-top: 1em">use strict;
<br>
use constant idx_PAYOFF =&gt; 3; <br>
... <br>
$n-&gt;[idx_PAYOFF]</p>

<p style="margin-left:17%; margin-top: 1em">Or use a
pseudohash. But I prefer to keep it simple, and use a
hash.</p>

<p style="margin-left:17%; margin-top: 1em">These are,
incidentally, the same arguments that people weigh when
trying to decide whether their object-oriented modules
should be based on blessed hashes, blessed arrays, or what.
Essentially the only difference here is that we&rsquo;re not
blessing our nodes or talking in terms of classes and
methods.</p>

<p style="margin-left:17%; margin-top: 1em">[end
footnote]</p>

<p style="margin-left:11%; margin-top: 1em">So, we might as
well represent nodes like so:</p>

<p style="margin-left:11%; margin-top: 1em">$node = { #
hashref <br>
'board' =&gt; ...board string, e.g., &quot;xx_x_xoo_oo&quot;
<br>
'last_move_payoff' =&gt; ...payoff of the move <br>
that got us here. <br>
'last_move_from' =&gt; ...the start... <br>
'last_move_to' =&gt; ...and end point of the move <br>
that got us here. E.g., 5 and 6, <br>
representing a move from 5 to 6. <br>
'whose_turn' =&gt; ...whose move it then becomes. <br>
just an 'x' or 'o'. <br>
'successors' =&gt; ...the successors <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Note that we
could have a field called something like
&rsquo;last_move_who&rsquo; to denote who last moved, but
since turns in Alak always alternate (and no-one can pass),
storing whose move it is now <i>and</i> who last moved is
redundant -- if X last moved, it&rsquo;s O turn now, and
vice versa. I chose to have a &rsquo;whose_turn&rsquo; field
instead of a &rsquo;last_move_who&rsquo;, but it
doesn&rsquo;t really matter. Either way, we&rsquo;ll end up
inferring one from the other at several points in the
program.</p>

<p style="margin-left:11%; margin-top: 1em">When we want to
store the successors of a node, should we use an array or a
hash? On the one hand, the successors to $node aren&rsquo;t
essentially ordered, so there&rsquo;s no reason to use an
array per se; on the other hand, if we used a hash, with
successor nodes as values, we don&rsquo;t have anything
particularly meaningful to use as keys. (And we can&rsquo;t
use the successors themselves as keys, since the nodes are
referred to by hash references, and you can&rsquo;t use a
reference as a hash key.) Given no particularly compelling
reason to do otherwise, I choose to just use an array to
store all a node&rsquo;s successors, although the order is
never actually used for anything:</p>

<p style="margin-left:11%; margin-top: 1em">$node = { <br>
... <br>
'successors' =&gt; [ ...nodes... ], <br>
... <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">In any case,
now that we&rsquo;ve settled on what should be in a node,
let&rsquo;s make a little sample tree out of a few nodes and
see what we can do with it:</p>

<p style="margin-left:11%; margin-top: 1em"># Board just
before move 3 in above game <br>
my $n0 = { <br>
'board' =&gt; 'xx_xx_oo_oo', <br>
'last_move_payoff' =&gt; 0, <br>
'last_move_from' =&gt; 9, <br>
'last_move_to' =&gt; 7, <br>
'whose_turn' =&gt; 'x', <br>
'successors' =&gt; [], <br>
}; <br>
# And, for now, just two of the successors: <br>
# X moves 4 to 6, giving xx__xxoo_oo <br>
my $n1 = { <br>
'board' =&gt; 'xx__xxoo_oo', <br>
'last_move_payoff' =&gt; 0, <br>
'last_move_from' =&gt; 4, <br>
'last_move_to' =&gt; 6, <br>
'whose_turn' =&gt; 'o', <br>
'successors' =&gt; [], <br>
}; <br>
# or X moves 5 to 6, giving xx_x_xoo_oo <br>
my $n2 = { <br>
'board' =&gt; 'xx_x_xoo_oo', <br>
'last_move_payoff' =&gt; 0, <br>
'last_move_from' =&gt; 5, <br>
'last_move_to' =&gt; 6, <br>
'whose_turn' =&gt; 'o', <br>
'successors' =&gt; [], <br>
}; <br>
# Now connect them... <br>
push @{$n0-&gt;{'successors'}}, $n1, $n2;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Digression:
Links to Parents</b> <br>
In comparing what we store in an Alak game tree node to what
HTML::Element stores in <small>HTML</small> element nodes,
you&rsquo;ll note one big difference: every HTML::Element
node contains a link to its parent, whereas we don&rsquo;t
have our Alak nodes keeping a link to theirs.</p>

<p style="margin-left:11%; margin-top: 1em">The reason this
can be an important difference is because it can affect how
Perl knows when you&rsquo;re not using pieces of memory
anymore. Consider the tree we just built, above:</p>

<p style="margin-left:11%; margin-top: 1em">node 0 <br>
/ \ <br>
node 1 node 2</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
two ways Perl knows you&rsquo;re using a piece of memory: 1)
it&rsquo;s memory that belongs directly to a variable (i.e.,
is necessary to hold that variable&rsquo;s value, or
value<i>s</i> in the case of a hash or array), or 2)
it&rsquo;s a piece of memory that something holds a
reference to. In the above code, Perl knows that the hash
for node 0 (for board &quot;xx_xx_oo_oo&quot;) is in use
because something (namely, the variable $n0) holds a
reference to it. Now, even if you followed the above code
with this:</p>

<p style="margin-left:11%; margin-top: 1em">$n1 = $n2 =
'whatever';</p>

<p style="margin-left:11%; margin-top: 1em">to make your
variables $n1 and $n2 stop holding references to the hashes
for the two successors of node 0, Perl would still know that
those hashes are still in use, because node 0&rsquo;s
successors array holds a reference to those hashes. And Perl
knows that node 0 is still in use because something still
holds a reference to it. Now, if you added:</p>

<p style="margin-left:11%; margin-top: 1em">my $root =
$n0;</p>

<p style="margin-left:11%; margin-top: 1em">This would
change nothing -- there&rsquo;s just be <i>two</i> things
holding a reference to the node 0 hash, which in turn holds
a reference to the node 1 and node 2 hashes. And if you then
added:</p>

<p style="margin-left:11%; margin-top: 1em">$n0 =
'stuff';</p>

<p style="margin-left:11%; margin-top: 1em">still nothing
would change, because something ($root) still holds a
reference to the node 0 hash. But once <i>nothing</i> holds
a reference to the node 0 hash, Perl will know it can
destroy that hash (and reclaim the memory for later use,
say), and once it does that, nothing will hold a reference
to the node 1 or the node 2 hashes, and those will be
destroyed too.</p>

<p style="margin-left:11%; margin-top: 1em">But consider if
the node 1 and node 2 hashes each had an attribute
&quot;parent&quot; (or &quot;predecessor&quot;) that held a
reference to node 0. If your program stopped holding a
reference to the node 0 hash, Perl could <i>not</i> then say
that <i>nothing</i> holds a reference to node 0 -- because
node 1 and node 2 still do. So, the memory for nodes 0, 1,
and 2 would never get reclaimed (until your program ended,
at which point Perl destroys <i>everything</i>). If your
program grew and discarded lots of nodes in the game tree,
but didn&rsquo;t let Perl know it could reclaim their
memory, your program could grow to use immense amounts of
memory -- never a nice thing to have happen. There&rsquo;s
three ways around this:</p>

<p style="margin-left:11%; margin-top: 1em">1) When
you&rsquo;re finished with a node, delete the reference each
of its children have to it (in this case, deleting
$n1-&gt;{&rsquo;parent&rsquo;}, say). When you&rsquo;re
finished with a whole tree, just go through the whole tree
erasing links that children have to their children.</p>

<p style="margin-left:11%; margin-top: 1em">2) Reconsider
whether you really need to have each node hold a reference
to its parent. Just not having those links will avoid the
whole problem.</p>

<p style="margin-left:11%; margin-top: 1em">3) use the
WeakRef module with Perl 5.6 or later. This allows you to
&quot;weaken&quot; some references (like the references that
node 1 and 2 could hold to their parent) so that they
don&rsquo;t count when Perl goes asking whether anything
holds a reference to a given piece of memory. This wonderful
new module eliminates the headaches that can often crop up
with either of the two previous methods.</p>

<p style="margin-left:11%; margin-top: 1em">It so happens
that our Alak program is simple enough that we don&rsquo;t
need for our nodes to have links to their parents, so the
second solution is fine. But in a more advanced program, the
first or third solutions might be unavoidable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Recursively
Printing the Tree</b> <br>
I don&rsquo;t like working blind -- if I have any kind of a
complex data structure in memory for a program I&rsquo;m
working on, the first thing I do is write something that can
dump that structure to the screen so I can make sure that
what I <i>think</i> is in memory really <i>is</i>
what&rsquo;s in memory. Now, I could just use the
&quot;x&quot; pretty-printer command in Perl&rsquo;s
interactive debugger, or I could have the program use the
&quot;Data::Dumper&quot; module. But in this case, I think
the output from those is rather too verbose. Once we have
trees with dozens of nodes in them, we&rsquo;ll really want
a dump of the tree to be as concise as possible, hopefully
just one line per node. What I&rsquo;d like is something
that can print $n0 and its successors (see above) as
something like:</p>

<p style="margin-left:11%; margin-top: 1em">xx_xx_oo_oo (O
moved 9 to 7, 0 payoff) <br>
xx__xxoo_oo (X moved 4 to 6, 0 payoff) <br>
xx_x_xoo_oo (X moved 5 to 6, 0 payoff)</p>

<p style="margin-left:11%; margin-top: 1em">A subroutine to
print a line for a given node, and then do that again for
each successor, would look something like:</p>

<p style="margin-left:11%; margin-top: 1em">sub dump_tree {
<br>
my $n = $_[0]; # &quot;n&quot; is for node <br>
print <br>
...something expressing $n'n content... <br>
foreach my $s (@{$n-&gt;{'successors'}}) { <br>
# &quot;s for successor <br>
dump($s); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">And we could
just start that out with a call to
&quot;dump_tree($n0)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Since this
routine...</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: I
first wrote this routine starting out with &quot;sub dump
{&quot;. But when I tried actually calling
&quot;dump($n0)&quot;, Perl would dump core! Imagine my
shock when I discovered that this is absolutely to be
expected -- Perl provides a built-in function called
&quot;dump&quot;, the purpose of which is to, yes, make Perl
dump core. Calling our routine &quot;dump_tree&quot; instead
of &quot;dump&quot; neatly avoids that problem.</p>

<p style="margin-left:11%; margin-top: 1em">...does its
work (dumping the subtree at and under the given node) by
calling itself, it&rsquo;s <b>recursive</b>. However,
there&rsquo;s a special term for this kind of recursion
across a tree: traversal. To <b>traverse</b> a tree means to
do something to a node, and to traverse its children.
There&rsquo;s two prototypical ways to do this, depending on
what happens when:</p>

<p style="margin-left:11%; margin-top: 1em">traversing X in
pre-order: <br>
* do something to X <br>
* then traverse X's children <br>
traversing X in post-order: <br>
* traverse X's children <br>
* then do something to X</p>

<p style="margin-left:11%; margin-top: 1em">Dumping the
tree to the screen the way we want it happens to be a matter
of pre-order traversal, since the thing we do (print a
description of the node) happens before we recurse into the
successors.</p>

<p style="margin-left:11%; margin-top: 1em">When we try
writing the &quot;print&quot; statement for our above
&quot;dump_tree&quot;, we can get something like:</p>

<p style="margin-left:11%; margin-top: 1em">sub dump_tree {
<br>
my $n = $_[0]; <br>
# &quot;xx_xx_oo_oo (O moved 9 to 7, 0 payoff)&quot; <br>
print <br>
$n-&gt;{'board'}, &quot; (&quot;, <br>
($n-&gt;{'whose_turn'} eq 'o' ? 'X' : 'O'), <br>
# Infer who last moved from whose turn it is now. <br>
&quot; moved &quot;, $n-&gt;{'last_move_from'}, <br>
&quot; to &quot;, $n-&gt;{'last_move_to'}, <br>
&quot;, &quot;, $n-&gt;{'last_move_payoff'}, <br>
&quot; payoff)\n&quot;, <br>
; <br>
foreach my $s (@{$n-&gt;{'successors'}}) { <br>
dump_tree($s); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If we run this
on $n0 from above, we get this:</p>

<p style="margin-left:11%; margin-top: 1em">xx_xx_oo_oo (O
moved 9 to 7, 0 payoff) <br>
xx__xxoo_oo (X moved 4 to 6, 0 payoff) <br>
xx_x_xoo_oo (X moved 5 to 6, 0 payoff)</p>

<p style="margin-left:11%; margin-top: 1em">Each line on
its own is fine, but we forget to allow for indenting, and
without that we can&rsquo;t tell what&rsquo;s a child of
what. (Imagine if the first successor had successors of its
own -- you wouldn&rsquo;t be able to tell if it were a
child, or a sibling.) To get indenting, we&rsquo;ll need to
have the instances of the &quot;dump_tree&quot; routine know
how far down in the tree they&rsquo;re being called, by
passing a depth parameter between them:</p>

<p style="margin-left:11%; margin-top: 1em">sub dump_tree {
<br>
my $n = $_[0]; <br>
my $depth = $_[1]; <br>
$depth = 0 unless defined $depth; <br>
print <br>
&quot; &quot; x $depth, <br>
...stuff... <br>
foreach my $s (@{$n-&gt;{'successors'}}) { <br>
dump_tree($s, $depth + 1); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">When we call
&quot;dump_tree($n0)&quot;, $depth (from $_[1]) is
undefined, so gets set to 0, which translates into an
indenting of no spaces. But when &quot;dump_tree&quot;
invokes itself on $n0&rsquo;s children, those instances see
$depth + 1 as their $_[1], giving appropriate indenting.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote:
Passing values around between different invocations of a
recursive routine, as shown, is a decent way to share the
data. Another way to share the data is by keeping it in a
global variable, like $Depth, initially set to 0. Each time
&quot;dump_tree&quot; is about to recurse, it must
&quot;++$Depth&quot;, and when it&rsquo;s back, it must
&quot;--$Depth&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Or, if the
reader is familiar with closures, consider this
approach:</p>

<p style="margin-left:17%; margin-top: 1em">sub dump_tree {
<br>
# A wrapper around calls to a recursive closure: <br>
my $start_node = $_[0]; <br>
my $depth = 0; <br>
# to be shared across calls to $recursor. <br>
my $recursor; <br>
$recursor = sub { <br>
my $n = $_[0]; <br>
print &quot; &quot; x $depth, <br>
...stuff... <br>
++$depth; <br>
foreach my $s (@{$n-&gt;{'successors'}}) { <br>
$recursor-&gt;($s); <br>
} <br>
--$depth; <br>
} <br>
$recursor-&gt;($start_node); # start recursing <br>
undef $recursor; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">The reader with
an advanced understanding of Perl&rsquo;s
reference-count-based garbage collection is invited to
consider why it is currently necessary to undef $recursor
(or otherwise change its value) after all recursion is
done.</p>

<p style="margin-left:17%; margin-top: 1em">The reader
whose mind is perverse in other ways is invited to consider
how (or when!) passing a depth parameter around is
unnecessary because of information that Perl&rsquo;s
caller(N) function reports!</p>

<p style="margin-left:17%; margin-top: 1em">[end
footnote]</p>

<p style="margin-left:11%; margin-top: 1em"><b>Growing the
Tree</b> <br>
Our &quot;dump_tree&quot; routine works fine for the sample
tree we&rsquo;ve got, so now we should get the program
working on making its own trees, starting from a given
board.</p>

<p style="margin-left:11%; margin-top: 1em">In
&quot;Games::Alak&quot; (the CPAN-released version of Alak
that uses essentially the same code that we&rsquo;re
currently discussing the tree-related parts of), there is a
routine called &quot;figure_successors&quot; that, given one
childless node, will figure out all its possible successors.
That is, it looks at the current board, looks at every piece
belonging to the player whose turn it is, and considers the
effect of moving each piece every possible way -- notably,
it figures out the immediate payoff, and if that move would
end the game, it notes that by setting an
&quot;endgame&quot; entry in that node&rsquo;s hash. (That
way, we know that that&rsquo;s a node that
<i>can&rsquo;t</i> have successors.)</p>

<p style="margin-left:11%; margin-top: 1em">In the code for
&quot;Games::Alak&quot;, &quot;figure_successors&quot; does
all these things, in a rather straightforward way. I
won&rsquo;t walk you through the details of the
&quot;figure_successors&quot; code I&rsquo;ve written, since
the code has nothing much to do with trees, and is all just
implementation of the Alak rules for what can move where,
with what result. Especially interested readers can puzzle
over that part of code in the source listing in the archive
from <small>CPAN,</small> but others can just assume that it
works as described above.</p>

<p style="margin-left:11%; margin-top: 1em">But consider
that &quot;figure_successors&quot;, regardless of its inner
workings, does not grow the <i>tree</i>; it only makes one
set of successors for one node at a time. It has to be up to
a different routine to call &quot;figure_successors&quot;,
and to keep applying it as needed, in order to make a nice
big tree that our game-playing program can base its
decisions on.</p>

<p style="margin-left:11%; margin-top: 1em">Now, we could
do this by just starting from one node, applying
&quot;figure_successors&quot; to it, then applying
&quot;figure_successors&quot; on all the resulting children,
and so on:</p>

<p style="margin-left:11%; margin-top: 1em">sub grow { #
Just a first attempt at this! <br>
my $n = $_[0]; <br>
figure_successors($n); <br>
unless <br>
@{$n-&gt;{'successors'}} <br>
# already has successors. <br>
or $n-&gt;{'endgame'} <br>
# can't have successors. <br>
} <br>
foreach my $s (@{$n-&gt;{'successors'}}) { <br>
grow($s); # recurse <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If you have a
game tree for tic-tac-toe, and you grow it without
limitation (as above), you will soon enough have a fully
&quot;solved&quot; tree, where every node that <i>can</i>
have successors <i>does</i>, and all the leaves of the tree
are <i>all</i> the possible endgames (where, in each case,
the board is filled). But a game of Alak is different from
tic-tac-toe, because it can, in theory, go on forever. For
example, the following sequence of moves is quite
possible:</p>

<p style="margin-left:11%; margin-top: 1em">xxxx___oooo
<br>
xxx_x__oooo <br>
xxx_x_o_ooo <br>
xxxx__o_ooo (x moved back) <br>
xxxx___oooo (o moved back) <br>
...repeat forever...</p>

<p style="margin-left:11%; margin-top: 1em">So if you tried
using our above attempt at a &quot;grow&quot; routine, Perl
would happily start trying to construct an infinitely deep
tree, containing an infinite number of nodes, consuming an
infinite amount of memory, and requiring an infinite amount
of time. As the old saying goes: &quot;You can&rsquo;t have
everything -- where would you put it?&quot; So we have to
place limits on how much we&rsquo;ll grow the tree.</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
more than one way to do this:</p>

<p style="margin-left:11%; margin-top: 1em">1. We could
grow the tree until we hit some limit on the number of nodes
we&rsquo;ll allow in the tree.</p>

<p style="margin-left:11%; margin-top: 1em">2. We could
grow the tree until we hit some limit on the amount of time
we&rsquo;re willing to spend.</p>

<p style="margin-left:11%; margin-top: 1em">3. Or we could
grow the tree until it is fully fleshed out to a certain
depth.</p>

<p style="margin-left:11%; margin-top: 1em">Since we
already know to track depth (as we did in writing
&quot;dump_tree&quot;), we&rsquo;ll do it that way, the
third way. The implementation for that third approach is
also pretty straightforward:</p>

<p style="margin-left:11%; margin-top: 1em">$Max_depth = 3;
<br>
sub grow { <br>
my $n = $_[0]; <br>
my $depth = $_[1] || 0; <br>
figure_successors($n) <br>
unless <br>
$depth &gt;= $Max_depth <br>
or @{$n-&gt;{'successors'}} <br>
or $n-&gt;{'endgame'} <br>
} <br>
foreach my $s (@{$n-&gt;{'successors'}}) { <br>
grow($s, $depth + 1); <br>
} <br>
# If we're at $Max_depth, then figure_successors <br>
# didn't get called, so there's no successors <br>
# to recurse under -- that's what stops recursion. <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If we start
from a single node (whether it&rsquo;s a node for the
starting board &quot;xxxx___oooo&quot;, or for whatever
board the computer is faced with), set $Max_depth to 4, and
apply &quot;grow&quot; to it, it will grow the tree to
include several hundred nodes.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: If at
each move there are four pieces that can move, and they can
each move right or left, the &quot;branching factor&quot; of
the tree is eight, giving a tree with 1 (depth 0) + 8 (depth
1) + 8 ** 2 + 8 ** 3 + 8 ** 4 = 4681 nodes in it. But, in
practice, not all pieces can move in both directions (none
of the x pieces in &quot;xxxx___oooo&quot; can move left,
for example), and there may be fewer than four pieces, if
some were lost. For example, there are 801 nodes in a tree
of depth four starting from &quot;xxxx___oooo&quot;,
suggesting an average branching factor of about five (801 **
(1/4) is about 5.3), not eight.</p>

<p style="margin-left:11%; margin-top: 1em">What we need to
derive from that tree is the information about what are the
best moves for X. The simplest way to consider the payoff of
different successors is to just average them -- but what we
average isn&rsquo;t always their immediate payoffs (because
that&rsquo;d leave us using only one generation of
information), but the average payoff of <i>their</i>
successors, if any. We can formalize this as:</p>

<p style="margin-left:11%; margin-top: 1em">To figure a
node's average payoff: <br>
If the node has successors: <br>
Figure each successor's average payoff. <br>
My average payoff is the average of theirs. <br>
Otherwise: <br>
My average payoff is my immediate payoff.</p>

<p style="margin-left:11%; margin-top: 1em">Since this
involves recursing into the successors <i>before</i> doing
anything with the current node, this will traverse the tree
<i>in post-order</i>.</p>

<p style="margin-left:11%; margin-top: 1em">We could work
that up as a routine of its own, and apply that to the tree
after we&rsquo;ve applied &quot;grow&quot; to it. But since
we&rsquo;d never grow the tree without also figuring the
average benefit, we might as well make that figuring part of
the &quot;grow&quot; routine itself:</p>

<p style="margin-left:11%; margin-top: 1em">$Max_depth = 3;
<br>
sub grow { <br>
my $n = $_[0]; <br>
my $depth = $_[1] || 0; <br>
figure_successors($n); <br>
unless <br>
$depth &gt;= $Max_depth <br>
or @{$n-&gt;{'successors'}} <br>
or $n-&gt;{'endgame'} <br>
} <br>
if(@{$n-&gt;{'successors'}}) { <br>
my $a_payoff_sum = 0; <br>
foreach my $s (@{$n-&gt;{'successors'}}) { <br>
grow($s, $depth + 1); # RECURSE <br>
$a_payoff_sum += $s-&gt;{'average_payoff'}; <br>
} <br>
$n-&gt;{'average_payoff'} <br>
= $a_payoff_sum / @{$n-&gt;{'successors'}}; <br>
} else { <br>
$n-&gt;{'average_payoff'} <br>
= $n-&gt;{'last_move_payoff'}; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">So, by time
&quot;grow&quot; has applied to a node (wherever in the tree
it is), it will have figured successors if possible (which,
in turn, sets &quot;last_move_payoff&quot; for each node it
creates), and will have set &quot;average_benefit&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Beyond this,
all that&rsquo;s needed is to start the board out with a
root note of &quot;xxxx___oooo&quot;, and have the computer
(X) take turns with the user (O) until someone wins.
Whenever it&rsquo;s O&rsquo;s turn, &quot;Games::Alak&quot;
presents a prompt to the user, letting him know the state of
the current board, and asking what move he selects. When
it&rsquo;s X&rsquo;s turn, the computer grows the game tree
as necessary (using just the &quot;grow&quot; routine from
above), then selects the move with the highest average
payoff (or one of the highest, in case of a tie).</p>

<p style="margin-left:11%; margin-top: 1em">In either case,
&quot;selecting&quot; a move means just setting that
move&rsquo;s node as the new root of the program&rsquo;s
game tree. Its sibling nodes and their descendants (the
boards that <i>didn&rsquo;t</i> get selected) and its parent
node will be erased from memory, since they will no longer
be in use (as Perl can tell by the fact that nothing holds
references to them anymore).</p>

<p style="margin-left:11%; margin-top: 1em">The interface
code in &quot;Games::Alak&quot; (the code that prompts the
user for his move) actually supports quite a few options
besides just moving -- including dumping the game tree to a
specified depth (using a slightly fancier version of
&quot;dump_tree&quot;, above), resetting the game, changing
$Max_depth in the middle of the game, and quitting the game.
Like &quot;figure_successors&quot;, it&rsquo;s a bit too
long to print here, but interested users are welcome to
peruse (and freely modify) the code, as well as to enjoy
just playing the game.</p>

<p style="margin-left:11%; margin-top: 1em">Now, in
practice, there&rsquo;s more to game trees than this: for
games with a larger branching factor than Alak has (which is
most!), game trees of depth four or larger would contain too
many nodes to be manageable, most of those nodes being
strategically quite uninteresting for either player; dealing
with game trees specifically is therefore a matter of
recognizing uninteresting contingencies and not bothering to
grow the tree under them.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: For
example, to choose a straightforward case: if O has a choice
between moves that put him in immediate danger of X winning
and moves that don&rsquo;t, then O won&rsquo;t ever choose
the dangerous moves (and if he does, the computer will know
enough to end the game), so there&rsquo;s no point in
growing the tree any further beneath those nodes.</p>

<p style="margin-left:11%; margin-top: 1em">But this sample
implementation should illustrate the basics of how to build
and manipulate a simple tree structure in memory. And once
you&rsquo;ve understood the basics of tree storage here, you
should be ready to better understand the complexities and
peculiarities of other systems for creating, accessing, and
changing trees, including Tree::DAG_Node, HTML::Element,
<small>XML::DOM,</small> or related formalisms like XPath
and <small>XSL.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>[end body of
article]</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>[Author
Credit]</b> <br>
Sean M. Burke (&quot;sburke@cpan.org&quot;) is a
tree-dwelling hominid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>References</b>
<br>
Dewdney, A[lexander] K[eewatin]. 1984. <i>Planiverse:
Computer Contact with a Two-Dimensional World.</i> Poseidon
Press, New York.</p>

<p style="margin-left:11%; margin-top: 1em">Knuth, Donald
Ervin. 1997. <i>Art of Computer Programming, Volume 1, Third
Edition: Fundamental Algorithms</i>. Addison-Wesley,
Reading, <small>MA.</small></p>

<p style="margin-left:11%; margin-top: 1em">Wirth, Niklaus.
1976. <i>Algorithms + Data Structures = Programs</i>
Prentice-Hall, Englewood Cliffs, <small>NJ.</small></p>

<p style="margin-left:11%; margin-top: 1em">Worth, Stan and
Allman Sheldon. Circa 1967. <i>George of the Jungle</i>
theme. [music by Jay Ward.]</p>

<p style="margin-left:11%; margin-top: 1em">Wirth&rsquo;s
classic, currently and lamentably out of print, has a good
section on trees. I find it clearer than Knuth&rsquo;s (if
not quite as encyclopedic), probably because Wirth&rsquo;s
example code is in a block-structured high-level language
(basically Pascal), instead of in assembler (
<small>MIX</small> ). I believe the book was re-issued in
the 1980s under the titles <i>Algorithms and Data
Structures</i> and, in a German edition, <i>Algorithmen und
Datenstrukturen</i>. Cheap copies of these editions should
be available through used book services such as
&quot;abebooks.com&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Worth&rsquo;s
classic, however, is available on the soundtrack to the 1997
<i>George of the Jungle</i> movie, as performed by The
Presidents of the United States of America.</p>

<h2>BACK
<a name="BACK"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Return to the
HTML::Tree docs.</p>
<hr>
</body>
</html>
