<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:38:03 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HTTP::Request::Common</title>

</head>
<body>

<h1 align="center">HTTP::Request::Common</h1>

<a href="#NAME">NAME</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">HTTP::Request::Common
- Construct common HTTP::Request objects</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">version
6.36</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
HTTP::Request::Common; <br>
$ua = LWP::UserAgent-&gt;new; <br>
$ua-&gt;request(GET 'http://www.sn.no/'); <br>
$ua-&gt;request(POST 'http://somewhere/foo', foo =&gt; bar,
bar =&gt; foo); <br>
$ua-&gt;request(PATCH 'http://somewhere/foo', foo =&gt; bar,
bar =&gt; foo); <br>
$ua-&gt;request(PUT 'http://somewhere/foo', foo =&gt; bar,
bar =&gt; foo); <br>
$ua-&gt;request(OPTIONS 'http://somewhere/foo', foo =&gt;
bar, bar =&gt; foo);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module
provides functions that return newly created
&quot;HTTP::Request&quot; objects. These functions are
usually more convenient to use than the standard
&quot;HTTP::Request&quot; constructor for the most common
requests.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
LWP::UserAgent has several convenience methods, including
&quot;get&quot;, &quot;head&quot;, &quot;delete&quot;,
&quot;post&quot; and &quot;put&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions are provided: <small><br>
GET</small> $url <small><br>
GET</small> $url, Header =&gt; Value,...</p>

<p style="margin-left:17%;">The &quot;GET&quot; function
returns an HTTP::Request object initialized with the &quot;
<small>GET&quot;</small> method and the specified
<small>URL.</small> It is roughly equivalent to the
following call</p>


<p style="margin-left:17%; margin-top: 1em">HTTP::Request-&gt;new(
<br>
GET =&gt; $url, <br>
HTTP::Headers-&gt;new(Header =&gt; Value,...), <br>
)</p>

<p style="margin-left:17%; margin-top: 1em">but is less
cluttered. What is different is that a header named
&quot;Content&quot; will initialize the content part of the
request instead of setting a header field. Note that
<small>GET</small> requests should normally not have a
content, so this hack makes more sense for the
&quot;PUT&quot;, &quot;PATCH&quot; <br>
and &quot;POST&quot; functions described below.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;get(...)&quot; method of LWP::UserAgent exists as a
shortcut for &quot;$ua-&gt;request(GET ...)&quot;.</p>

<p style="margin-left:11%;"><small>HEAD</small> $url
<small><br>
HEAD</small> $url, Header =&gt; Value,...</p>

<p style="margin-left:17%;">Like <b><small>GET</small>
()</b> but the method in the request is &quot;
<small>HEAD&quot;.</small></p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;head(...)&quot; method of LWP::UserAgent exists as a
shortcut for &quot;$ua-&gt;request(HEAD ...)&quot;.</p>

<p style="margin-left:11%;"><small>DELETE</small> $url
<small><br>
DELETE</small> $url, Header =&gt; Value,...</p>

<p style="margin-left:17%;">Like &quot;GET&quot; but the
method in the request is &quot;DELETE&quot;. This function
is not exported by default.</p>

<p style="margin-left:11%;"><small>PATCH</small> $url
<small><br>
PATCH</small> $url, Header =&gt; Value,... <small><br>
PATCH</small> $url, $form_ref, Header =&gt; Value,...
<small><br>
PATCH</small> $url, Header =&gt; Value,..., Content =&gt;
$form_ref <small><br>
PATCH</small> $url, Header =&gt; Value,..., Content =&gt;
$content</p>

<p style="margin-left:17%;">The same as &quot;POST&quot;
below, but the method in the request is
&quot;PATCH&quot;.</p>

<p style="margin-left:11%;"><small>PUT</small> $url
<small><br>
PUT</small> $url, Header =&gt; Value,... <small><br>
PUT</small> $url, $form_ref, Header =&gt; Value,...
<small><br>
PUT</small> $url, Header =&gt; Value,..., Content =&gt;
$form_ref <small><br>
PUT</small> $url, Header =&gt; Value,..., Content =&gt;
$content</p>

<p style="margin-left:17%;">The same as &quot;POST&quot;
below, but the method in the request is &quot;PUT&quot;</p>

<p style="margin-left:11%;"><small>OPTIONS</small> $url
<small><br>
OPTIONS</small> $url, Header =&gt; Value,... <small><br>
OPTIONS</small> $url, $form_ref, Header =&gt; Value,...
<small><br>
OPTIONS</small> $url, Header =&gt; Value,..., Content =&gt;
$form_ref <small><br>
OPTIONS</small> $url, Header =&gt; Value,..., Content =&gt;
$content</p>

<p style="margin-left:17%;">The same as &quot;POST&quot;
below, but the method in the request is
&quot;OPTIONS&quot;</p>

<p style="margin-left:11%;"><small>POST</small> $url
<small><br>
POST</small> $url, Header =&gt; Value,... <small><br>
POST</small> $url, $form_ref, Header =&gt; Value,...
<small><br>
POST</small> $url, Header =&gt; Value,..., Content =&gt;
$form_ref <small><br>
POST</small> $url, Header =&gt; Value,..., Content =&gt;
$content</p>

<p style="margin-left:17%;">&quot;POST&quot;,
&quot;PATCH&quot; and &quot;PUT&quot; all work with the same
parameters.</p>

<p style="margin-left:17%; margin-top: 1em">%data = ( title
=&gt; 'something', body =&gt; something else' ); <br>
$ua = LWP::UserAgent-&gt;new(); <br>
$request = HTTP::Request::Common::POST( $url, [ %data ] );
<br>
$response = $ua-&gt;request($request);</p>

<p style="margin-left:17%; margin-top: 1em">They take a
second optional array or hash reference parameter $form_ref.
The content can also be specified directly using the
&quot;Content&quot; pseudo-header, and you may also provide
the $form_ref this way.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;Content&quot; pseudo-header steals a bit of the header
field namespace as there is no way to directly specify a
header that is actually called &quot;Content&quot;. If you
really need this you must update the request returned in a
separate statement.</p>

<p style="margin-left:17%; margin-top: 1em">The $form_ref
argument can be used to pass key/value pairs for the form
content. By default we will initialize a request using the
&quot;application/x-www-form-urlencoded&quot; content type.
This means that you can emulate an <small>HTML</small>
&lt;form&gt; POSTing like this:</p>

<p style="margin-left:17%; margin-top: 1em">POST
'http://www.perl.org/survey.cgi', <br>
[ name =&gt; 'Gisle Aas', <br>
email =&gt; 'gisle@aas.no', <br>
gender =&gt; 'M', <br>
born =&gt; '1964', <br>
perc =&gt; '3%', <br>
];</p>

<p style="margin-left:17%; margin-top: 1em">This will
create an HTTP::Request object that looks like this:</p>

<p style="margin-left:17%; margin-top: 1em">POST
http://www.perl.org/survey.cgi <br>
Content-Length: 66 <br>
Content-Type: application/x-www-form-urlencoded <br>

name=Gisle%20Aas&amp;email=gisle%40aas.no&amp;gender=M&amp;born=1964&amp;perc=3%25</p>

<p style="margin-left:17%; margin-top: 1em">Multivalued
form fields can be specified by either repeating the field
name or by passing the value as an array reference.</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>POST</small> method also supports the
&quot;multipart/form-data&quot; content used for
<i>Form-based File Upload</i> as specified in <small>RFC
1867.</small> You trigger this content format by specifying
a content type of 'form-data' as one of the request headers.
If one of the values in the $form_ref is an array reference,
then it is treated as a file part specification with the
following interpretation:</p>

<p style="margin-left:17%; margin-top: 1em">[ $file,
$filename, Header =&gt; Value... ] <br>
[ undef, $filename, Header =&gt; Value,..., Content =&gt;
$content ]</p>

<p style="margin-left:17%; margin-top: 1em">The first value
in the array ($file) is the name of a file to open. This
file will be read and its content placed in the request. The
routine will croak if the file can&rsquo;t be opened. Use an
&quot;undef&quot; as $file value if you want to specify the
content directly with a &quot;Content&quot; header. The
$filename is the filename to report in the request. If this
value is undefined, then the basename of the $file will be
used. You can specify an empty string as $filename if you
want to suppress sending the filename when you provide a
$file value.</p>

<p style="margin-left:17%; margin-top: 1em">If a $file is
provided by no &quot;Content-Type&quot; header, then
&quot;Content-Type&quot; and &quot;Content-Encoding&quot;
will be filled in automatically with the values returned by
&quot;LWP::MediaTypes::guess_media_type()&quot;</p>

<p style="margin-left:17%; margin-top: 1em">Sending my
<i>~/.profile</i> to the survey used as example above can be
achieved by this:</p>

<p style="margin-left:17%; margin-top: 1em">POST
'http://www.perl.org/survey.cgi', <br>
Content_Type =&gt; 'form-data', <br>
Content =&gt; [ name =&gt; 'Gisle Aas', <br>
email =&gt; 'gisle@aas.no', <br>
gender =&gt; 'M', <br>
born =&gt; '1964', <br>
init =&gt; [&quot;$ENV{HOME}/.profile&quot;], <br>
]</p>

<p style="margin-left:17%; margin-top: 1em">This will
create an HTTP::Request object that almost looks this (the
boundary and the content of your <i>~/.profile</i> is likely
to be different):</p>

<p style="margin-left:17%; margin-top: 1em">POST
http://www.perl.org/survey.cgi <br>
Content-Length: 388 <br>
Content-Type: multipart/form-data; boundary=&quot;6G+f&quot;
<br>
--6G+f <br>
Content-Disposition: form-data; name=&quot;name&quot; <br>
Gisle Aas <br>
--6G+f <br>
Content-Disposition: form-data; name=&quot;email&quot; <br>
gisle@aas.no <br>
--6G+f <br>
Content-Disposition: form-data; name=&quot;gender&quot; <br>
M <br>
--6G+f <br>
Content-Disposition: form-data; name=&quot;born&quot; <br>
1964 <br>
--6G+f <br>
Content-Disposition: form-data; name=&quot;init&quot;;
filename=&quot;.profile&quot; <br>
Content-Type: text/plain <br>
PATH=/local/perl/bin:$PATH <br>
export PATH <br>
--6G+f--</p>

<p style="margin-left:17%; margin-top: 1em">If you set the
$DYNAMIC_FILE_UPLOAD variable (exportable) to some
<small>TRUE</small> value, then you get back a request
object with a subroutine closure as the content attribute.
This subroutine will read the content of any files on demand
and return it in suitable chunks. This allow you to upload
arbitrary big files without using lots of memory. You can
even upload infinite files like <i>/dev/audio</i> if you
wish; however, if the file is not a plain file, there will
be no &quot;Content-Length&quot; header defined for the
request. Not all servers (or server applications) like this.
Also, if the file(s) change in size between the time the
&quot;Content-Length&quot; is calculated and the time that
the last chunk is delivered, the subroutine will
&quot;Croak&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;post(...)&quot; method of LWP::UserAgent exists as a
shortcut for &quot;$ua-&gt;request(POST ...)&quot;.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">HTTP::Request,
LWP::UserAgent</p>

<p style="margin-left:11%; margin-top: 1em">Also, there are
some examples in &quot; <small>EXAMPLES&quot;</small> in
HTTP::Request that you might find useful. For example, batch
requests are explained there.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Gisle Aas
&lt;gisle@activestate.com&gt;</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This software
is copyright (c) 1994 by Gisle Aas.</p>

<p style="margin-left:11%; margin-top: 1em">This is free
software; you can redistribute it and/or modify it under the
same terms as the Perl 5 programming language system
itself.</p>
<hr>
</body>
</html>
