<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:36 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>RPC_CLNT_CREATE(3) BSD Library Functions Manual
RPC_CLNT_CREATE(3)</p>

<p style="margin-top: 1em"><b>NAME</b></p>

<p style="margin-left:6%;"><b>rpc_clnt_create</b>,
<b>clnt_control</b>, <b>clnt_create</b>,
<b>clnt_create_timed</b>, <b>clnt_create_vers</b>,
<b>clnt_create_vers_timed</b>, <b>clnt_destroy</b>,
<b>clnt_dg_create</b>, <b>clnt_pcreateerror</b>,
<b>clnt_raw_create</b>, <b>clnt_spcreateerror</b>,
<b>clnt_tli_create</b>, <b>clnt_tp_create</b>,
<b>clnt_tp_create_timed</b>, <b>clnt_vc_create</b>,
<b>rpc_createerr</b> &mdash; library routines for dealing
with creation and manipulation of <i>CLIENT</i> handles</p>

<p style="margin-top: 1em"><b>SYNOPSIS</b></p>

<p style="margin-left:6%;"><b>#include
&lt;rpc/rpc.h&gt;</b></p>


<p style="margin-left:6%; margin-top: 1em"><i>bool_t</i></p>


<p style="margin-left:12%;"><b>clnt_control</b>(<i>CLIENT&nbsp;*clnt</i>,
<i>const&nbsp;u_int&nbsp;req</i>,
<i>char&nbsp;*info</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_create</b>(<i>const&nbsp;char&nbsp;*&nbsp;host</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>,
<i>const&nbsp;char&nbsp;*nettype</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_create_timed</b>(<i>const&nbsp;char&nbsp;*&nbsp;host</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>,
<i>const&nbsp;char&nbsp;*nettype</i>,
<i>const&nbsp;struct&nbsp;timeval&nbsp;*timeout</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_create_vers</b>(<i>const&nbsp;char&nbsp;*&nbsp;host</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>rpcvers_t&nbsp;*vers_outp</i>,
<i>const&nbsp;rpcvers_t&nbsp;vers_low</i>,
<i>const&nbsp;rpcvers_t&nbsp;vers_high</i>,
<i>const&nbsp;char&nbsp;*nettype</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_create_vers_timed</b>(<i>const&nbsp;char&nbsp;*&nbsp;host</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>rpcvers_t&nbsp;*vers_outp</i>,
<i>const&nbsp;rpcvers_t&nbsp;vers_low</i>,
<i>const&nbsp;rpcvers_t&nbsp;vers_high</i>,
<i>char&nbsp;*nettype</i>,
<i>const&nbsp;struct&nbsp;timeval&nbsp;*timeout</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>void</i></p>


<p style="margin-left:12%;"><b>clnt_destroy</b>(<i>CLIENT&nbsp;*clnt</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_dg_create</b>(<i>const&nbsp;int&nbsp;fildes</i>,
<i>const&nbsp;struct&nbsp;netbuf&nbsp;*svcaddr</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>,
<i>const&nbsp;u_int&nbsp;sendsz</i>,
<i>const&nbsp;u_int&nbsp;recvsz</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>void</i></p>


<p style="margin-left:12%;"><b>clnt_pcreateerror</b>(<i>const&nbsp;char&nbsp;*s</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>char
*</i></p>


<p style="margin-left:12%;"><b>clnt_spcreateerror</b>(<i>const&nbsp;char&nbsp;*s</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_raw_create</b>(<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_tli_create</b>(<i>const&nbsp;int&nbsp;fildes</i>,
<i>const&nbsp;struct&nbsp;netconfig&nbsp;*netconf</i>,
<i>const&nbsp;struct&nbsp;netbuf&nbsp;*svcaddr</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>,
<i>const&nbsp;u_int&nbsp;sendsz</i>,
<i>const&nbsp;u_int&nbsp;recvsz</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_tp_create</b>(<i>const&nbsp;char&nbsp;*&nbsp;host</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>,
<i>const&nbsp;struct&nbsp;netconfig&nbsp;*netconf</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_tp_create_timed</b>(<i>const&nbsp;char&nbsp;*&nbsp;host</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>,
<i>const&nbsp;struct&nbsp;netconfig&nbsp;*netconf</i>,
<i>const&nbsp;struct&nbsp;timeval&nbsp;*timeout</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>CLIENT
*</i></p>


<p style="margin-left:12%;"><b>clnt_vc_create</b>(<i>const&nbsp;int&nbsp;fildes</i>,
<i>const&nbsp;struct&nbsp;netbuf&nbsp;*svcaddr</i>,
<i>const&nbsp;rpcprog_t&nbsp;prognum</i>,
<i>const&nbsp;rpcvers_t&nbsp;versnum</i>,
<i>u_int&nbsp;sendsz</i>, <i>u_int&nbsp;recvsz</i>);</p>

<p style="margin-top: 1em"><b>DESCRIPTION</b></p>

<p style="margin-left:6%;">RPC library routines allow C
language programs to make procedure calls on other machines
across the network. First a <i>CLIENT</i> handle is created
and then the client calls a procedure to send a request to
the server. On receipt of the request, the server calls a
dispatch routine to perform the requested service, and then
sends a reply.</p>

<p style="margin-top: 1em"><b>Routines <br>
clnt_control</b>()</p>

<p style="margin-left:18%;">A function macro to change or
retrieve various information about a client object. The
<i>req</i> argument indicates the type of operation, and
<i>info</i> is a pointer to the information. For both
connectionless and connection-oriented transports, the
supported values of <i>req</i> and their argument types and
what they do are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLSET_TIMEOUT</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>struct timeval *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>set total timeout</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLGET_TIMEOUT</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>struct timeval *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>get total timeout</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Note: if you
set the timeout using <b>clnt_control</b>(), the timeout
argument passed by <b>clnt_call</b>() is ignored in all
subsequent calls.</p>

<p style="margin-left:18%; margin-top: 1em">Note: If you
set the timeout value to 0, <b>clnt_control</b>()
immediately returns an error (RPC_TIMEDOUT). Set the timeout
argument to 0 for batching calls.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLGET_SVC_ADDR</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>struct netbuf *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>get servers address</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLGET_FD</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>int *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>get fd from handle</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLSET_FD_CLOSE</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>void</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>close fd on destroy</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLSET_FD_NCLOSE</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>void</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>don&rsquo;t close fd on destroy</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLGET_VERS</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>u_int32_t *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>get RPC program version</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLSET_VERS</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>u_int32_t *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>set RPC program version</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLGET_XID</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>u_int32_t *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>get XID of previous call</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLSET_XID</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>u_int32_t *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>set XID of next call</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The following
operations are valid for connectionless transports only:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLSET_RETRY_TIMEOUT</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>struct timeval *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>set the retry timeout</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLGET_RETRY_TIMEOUT</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>struct timeval *</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>get the retry timeout</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>CLSET_CONNECT</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p><i>int *</i></p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p>use connect(2)</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The retry
timeout is the time that RPC waits for the server to reply
before retransmitting the request. The <b>clnt_control</b>()
function returns TRUE on success and FALSE on failure.</p>

<p style="margin-top: 1em"><b>clnt_create</b>()</p>

<p style="margin-left:18%;">Generic client creation routine
for program <i>prognum</i> and version <i>versnum</i>. The
<i>host</i> argument identifies the name of the remote host
where the server is located. The <i>nettype</i> argument
indicates the class of transport protocol to use. The
transports are tried in left to right order in NETPATH
environment variable or in top to bottom order in the
netconfig database. The <b>clnt_create</b>() function tries
all the transports of the <i>nettype</i> class available
from the NETPATH environment variable and the netconfig
database, and chooses the first successful one. A default
timeout is set and can be modified using
<b>clnt_control</b>(). This routine returns NULL if it
fails. The <b>clnt_pcreateerror</b>() routine can be used to
print the reason for failure.</p>

<p style="margin-left:18%; margin-top: 1em">Note:
<b>clnt_create</b>() returns a valid client handle even if
the particular version number supplied to
<b>clnt_create</b>() is not registered with the rpcbind(8)
service. This mismatch will be discovered by a
<b>clnt_call</b>() later (see rpc_clnt_calls(3)).</p>

<p style="margin-top: 1em"><b>clnt_create_timed</b>()</p>

<p style="margin-left:18%;">Generic client creation routine
which is similar to <b>clnt_create</b>() but which also has
the additional argument <i>timeout</i> that specifies the
maximum amount of time allowed for each transport class
tried. In all other respects, the <b>clnt_create_timed</b>()
call behaves exactly like the <b>clnt_create</b>() call.</p>

<p style="margin-top: 1em"><b>clnt_create_vers</b>()</p>

<p style="margin-left:18%;">Generic client creation routine
which is similar to <b>clnt_create</b>() but which also
checks for the version availability. The <i>host</i>
argument identifies the name of the remote host where the
server is located. The <i>nettype</i> argument indicates the
class transport protocols to be used. If the routine is
successful it returns a client handle created for the
highest version between <i>vers_low</i> and <i>vers_high</i>
that is supported by the server. The <i>vers_outp</i>
argument is set to this value. That is, after a successful
return <i>vers_low</i> &lt;= <i>*vers_outp</i> &lt;=
<i>vers_high</i>. If no version between <i>vers_low</i> and
<i>vers_high</i> is supported by the server then the routine
fails and returns NULL. A default timeout is set and can be
modified using <b>clnt_control</b>(). This routine returns
NULL if it fails. The <b>clnt_pcreateerror</b>() routine can
be used to print the reason for failure. Note:
<b>clnt_create</b>() returns a valid client handle even if
the particular version number supplied to
<b>clnt_create</b>() is not registered with the rpcbind(8)
service. This mismatch will be discovered by a
<b>clnt_call</b>() later (see rpc_clnt_calls(3)). However,
<b>clnt_create_vers</b>() does this for you and returns a
valid handle only if a version within the range supplied is
supported by the server.</p>


<p style="margin-top: 1em"><b>clnt_create_vers_timed</b>()</p>

<p style="margin-left:18%;">Generic client creation routine
which is similar to <b>clnt_create_vers</b>() but which also
has the additional argument <i>timeout</i> that specifies
the maximum amount of time allowed for each transport class
tried. In all other respects, the
<b>clnt_create_vers_timed</b>() call behaves exactly like
the <b>clnt_create_vers</b>() call.</p>

<p style="margin-top: 1em"><b>clnt_destroy</b>()</p>

<p style="margin-left:18%;">A function macro that destroys
the client&rsquo;s RPC handle. Destruction usually involves
deallocation of private data structures, including
<i>clnt</i> itself. Use of <i>clnt</i> is undefined after
calling <b>clnt_destroy</b>(). If the RPC library opened the
associated file descriptor, or CLSET_FD_CLOSE was set using
<b>clnt_control</b>(), the file descriptor will be closed.
The caller should call
<b>auth_destroy</b>(<i>clnt-&gt;cl_auth</i>) (before calling
<b>clnt_destroy</b>()) to destroy the associated <i>AUTH</i>
structure (see rpc_clnt_auth(3)).</p>

<p style="margin-top: 1em"><b>clnt_dg_create</b>()</p>

<p style="margin-left:18%;">This routine creates an RPC
client for the remote program <i>prognum</i> and version
<i>versnum</i>; the client uses a connectionless transport.
The remote program is located at address <i>svcaddr</i>. The
<i>fildes</i> argument is an open and bound file descriptor.
This routine will resend the call message in intervals of 15
seconds until a response is received or until the call times
out. The total time for the call to time out is specified by
<b>clnt_call</b>() (see <b>clnt_call</b>() in
rpc_clnt_calls(3)). The retry time out and the total time
out periods can be changed using <b>clnt_control</b>(). The
user may set the size of the send and receive buffers with
the <i>sendsz</i> and <i>recvsz</i> arguments; values of 0
choose suitable defaults. This routine returns NULL if it
fails.</p>

<p style="margin-top: 1em"><b>clnt_pcreateerror</b>()</p>

<p style="margin-left:18%;">Print a message to standard
error indicating why a client RPC handle could not be
created. The message is prepended with the string <i>s</i>
and a colon, and appended with a newline.</p>

<p style="margin-top: 1em"><b>clnt_spcreateerror</b>()</p>

<p style="margin-left:18%;">Like
<b>clnt_pcreateerror</b>(), except that it returns a string
instead of printing to the standard error. A newline is not
appended to the message in this case. Warning: returns a
pointer to a buffer that is overwritten on each call.</p>

<p style="margin-top: 1em"><b>clnt_raw_create</b>()</p>

<p style="margin-left:18%;">This routine creates an RPC
client handle for the remote program <i>prognum</i> and
version <i>versnum</i>. The transport used to pass messages
to the service is a buffer within the process&rsquo;s
address space, so the corresponding RPC server should live
in the same address space; (see <b>svc_raw_create</b>() in
rpc_svc_create(3)). This allows simulation of RPC and
measurement of RPC overheads, such as round trip times,
without any kernel or networking interference. This routine
returns NULL if it fails. The <b>clnt_raw_create</b>()
function should be called after <b>svc_raw_create</b>().</p>

<p style="margin-top: 1em"><b>clnt_tli_create</b>()</p>

<p style="margin-left:18%;">This routine creates an RPC
client handle for the remote program <i>prognum</i> and
version <i>versnum</i>. The remote program is located at
address <i>svcaddr</i>. If <i>svcaddr</i> is NULL and it is
connection-oriented, it is assumed that the file descriptor
is connected. For connectionless transports, if
<i>svcaddr</i> is NULL, RPC_UNKNOWNADDR error is set. The
<i>fildes</i> argument is a file descriptor which may be
open, bound and connected. If it is RPC_ANYFD, it opens a
file descriptor on the transport specified by
<i>netconf</i>. If <i>fildes</i> is RPC_ANYFD and
<i>netconf</i> is NULL, a RPC_UNKNOWNPROTO error is set. If
<i>fildes</i> is unbound, then it will attempt to bind the
descriptor. The user may specify the size of the buffers
with the <i>sendsz</i> and <i>recvsz</i> arguments; values
of 0 choose suitable defaults. Depending upon the type of
the transport (connection-oriented or connectionless),
<b>clnt_tli_create</b>() calls appropriate client creation
routines. This routine returns NULL if it fails. The
<b>clnt_pcreateerror</b>() routine can be used to print the
reason for failure. The remote rpcbind service (see
rpcbind(8)) is not consulted for the address of the remote
service.</p>

<p style="margin-top: 1em"><b>clnt_tp_create</b>()</p>

<p style="margin-left:18%;">Like <b>clnt_create</b>()
except <b>clnt_tp_create</b>() tries only one transport
specified through <i>netconf</i>. The
<b>clnt_tp_create</b>() function creates a client handle for
the program <i>prognum</i>, the version <i>versnum</i>, and
for the transport specified by <i>netconf</i>. Default
options are set, which can be changed using
<b>clnt_control</b>() calls. The remote rpcbind service on
the host <i>host</i> is consulted for the address of the
remote service. This routine returns NULL if it fails. The
<b>clnt_pcreateerror</b>() routine can be used to print the
reason for failure.</p>


<p style="margin-top: 1em"><b>clnt_tp_create_timed</b>()</p>

<p style="margin-left:18%;">Like <b>clnt_tp_create</b>()
except <b>clnt_tp_create_timed</b>() has the extra argument
<i>timeout</i> which specifies the maximum time allowed for
the creation attempt to succeed. In all other respects, the
<b>clnt_tp_create_timed</b>() call behaves exactly like the
<b>clnt_tp_create</b>() call.</p>

<p style="margin-top: 1em"><b>clnt_vc_create</b>()</p>

<p style="margin-left:18%;">This routine creates an RPC
client for the remote program <i>prognum</i> and version
<i>versnum</i>; the client uses a connection-oriented
transport. The remote program is located at address
<i>svcaddr</i>. The <i>fildes</i> argument is an open and
bound file descriptor. The user may specify the size of the
send and receive buffers with the <i>sendsz</i> and
<i>recvsz</i> arguments; values of 0 choose suitable
defaults. This routine returns NULL if it fails. The address
<i>svcaddr</i> should not be NULL and should point to the
actual address of the remote program. The
<b>clnt_vc_create</b>() function does not consult the remote
rpcbind service for this information.</p>

<p style="margin-top: 1em"><i>struct rpc_createerr
rpc_createerr</i>;</p>

<p style="margin-left:18%;">A global variable whose value
is set by any RPC client handle creation routine that fails.
It is used by the routine <b>clnt_pcreateerror</b>() to
print the reason for the failure.</p>

<p style="margin-top: 1em"><b>AVAILABILITY</b></p>

<p style="margin-left:6%;">These functions are part of
libtirpc.</p>

<p style="margin-top: 1em"><b>SEE ALSO</b></p>

<p style="margin-left:6%;">rpc(3), rpc_clnt_auth(3),
rpc_clnt_calls(3), rpcbind(8)</p>

<p style="margin-left:6%; margin-top: 1em">BSD May&nbsp;7,
1993 BSD</p>
<hr>
</body>
</html>
