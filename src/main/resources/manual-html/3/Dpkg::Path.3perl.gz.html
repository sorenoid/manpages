<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:46 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Dpkg::Path</title>

</head>
<body>

<h1 align="center">Dpkg::Path</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#FUNCTIONS">FUNCTIONS</a><br>
<a href="#CHANGES">CHANGES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Dpkg::Path -
some common path handling functions</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">It provides
some functions to handle various path.</p>

<h2>FUNCTIONS
<a name="FUNCTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">get_pkg_root_dir($file)</p>

<p style="margin-left:23%;">This function will scan upwards
the hierarchy of directory to find out the directory which
contains the &quot; <small>DEBIAN&quot;</small>
sub-directory and it will return its path. This directory is
the root directory of a package being built.</p>

<p style="margin-left:23%; margin-top: 1em">If no
<small>DEBIAN</small> subdirectory is found, it will return
undef.</p>


<p style="margin-left:11%;">relative_to_pkg_root($file)</p>

<p style="margin-left:23%;">Returns the filename relative
to get_pkg_root_dir($file).</p>

<p style="margin-left:11%;">guess_pkg_root_dir($file)</p>

<p style="margin-left:23%;">This function tries to guess
the root directory of the package build tree. It will first
use <b>get_pkg_root_dir()</b>, but it will fallback to a
more imprecise check: namely it will use the parent
directory that is a sub-directory of the debian
directory.</p>

<p style="margin-left:23%; margin-top: 1em">It can still
return undef if a file outside of the debian sub-directory
is provided.</p>


<p style="margin-left:11%;">check_files_are_the_same($file1,
$file2, $resolve_symlink)</p>

<p style="margin-left:23%;">This function verifies that
both files are the same by checking that the device numbers
and the inode numbers returned by
<b>stat()</b>/<b>lstat()</b> are the same. If
$resolve_symlink is true then <b>stat()</b> is used,
otherwise <b>lstat()</b> is used.</p>

<p style="margin-left:11%;">canonpath($file)</p>

<p style="margin-left:23%;">This function returns a cleaned
path. It simplifies double //, and remove /./ and /../
intelligently. For /../ it simplifies the path only if the
previous element is not a symlink. Thus it should only be
used on real filenames.</p>

<p style="margin-left:11%;">$newpath =
resolve_symlink($symlink)</p>

<p style="margin-left:23%;">Return the filename of the file
pointed by the symlink. The new name is canonicalized by
<b>canonpath()</b>.</p>


<p style="margin-left:11%;">check_directory_traversal($basedir,
$dir)</p>

<p style="margin-left:23%;">This function verifies that the
directory $dir does not contain any symlink that goes beyond
$basedir (which should be either equal or a parent of
$dir).</p>

<p style="margin-left:11%;">$cmdpath =
find_command($command)</p>

<p style="margin-left:23%;">Return the path of the command
if defined and available on an absolute or relative path or
on the $PATH, undef otherwise.</p>

<p style="margin-left:11%;">$control_file =
get_control_path($pkg, $filetype)</p>

<p style="margin-left:23%;">Return the path of the control
file of type $filetype for the given package.</p>

<p style="margin-left:11%;">@control_files =
get_control_path($pkg)</p>

<p style="margin-left:23%;">Return the path of all
available control files for the given package.</p>

<p style="margin-left:11%;">$file =
find_build_file($basename)</p>

<p style="margin-left:23%;">Selects the right variant of
the given file: the arch-specific variant
(&quot;$basename.$arch&quot;) has priority over the
OS-specific variant (&quot;$basename.$os&quot;) which has
priority over the default variant (&quot;$basename&quot;).
If none of the files exists, then it returns undef.</p>

<p style="margin-left:11%;">@files =
find_build_file($basename)</p>

<p style="margin-left:23%;">Return the available variants
of the given file. Returns an empty list if none of the
files exists.</p>

<h2>CHANGES
<a name="CHANGES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Version 1.05
(dpkg 1.20.4)</b> <br>
New function: <b>check_directory_traversal()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Version 1.04
(dpkg 1.17.11)</b> <br>
Update semantics: <b>find_command()</b> now handles an empty
or undef argument.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Version 1.03
(dpkg 1.16.1)</b> <br>
New function: <b>find_build_file()</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Version 1.02
(dpkg 1.16.0)</b> <br>
New function: <b>get_control_path()</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Version 1.01
(dpkg 1.15.8)</b> <br>
New function: <b>find_command()</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Version 1.00
(dpkg 1.15.6)</b> <br>
Mark the module as public.</p>
<hr>
</body>
</html>
