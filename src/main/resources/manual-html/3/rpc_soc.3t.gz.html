<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:18 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>RPC_SOC(3) BSD Library Functions Manual RPC_SOC(3)</p>

<p style="margin-top: 1em"><b>NAME</b></p>

<p style="margin-left:6%;"><b>rpc_soc</b>,
<b>auth_destroy</b>, <b>authnone_create</b>,
<b>authunix_create</b>, <b>authunix_create_default</b>,
<b>callrpc</b>, <b>clnt_broadcast</b>, <b>clnt_call</b>,
<b>clnt_control</b>, <b>clnt_create</b>,
<b>clnt_destroy</b>, <b>clnt_freeres</b>,
<b>clnt_geterr</b>, <b>clnt_pcreateerror</b>,
<b>clnt_perrno</b>, <b>clnt_perror</b>,
<b>clnt_spcreateerror</b>, <b>clnt_sperrno</b>,
<b>clnt_sperror</b>, <b>clntraw_create</b>,
<b>clnttcp_create</b>, <b>clntudp_bufcreate</b>,
<b>clntudp_create</b>, <b>clntunix_create</b>,
<b>get_myaddress</b>, <b>pmap_getmaps</b>,
<b>pmap_getport</b>, <b>pmap_rmtcall</b>, <b>pmap_set</b>,
<b>pmap_unset</b>, <b>registerrpc</b>, <b>rpc_createerr</b>,
<b>svc_destroy</b>, <b>svc_fds</b>, <b>svc_fdset</b>,
<b>svc_getargs</b>, <b>svc_getcaller</b>, <b>svc_getreq</b>,
<b>svc_getreqset</b>, <b>svc_register</b>, <b>svc_run</b>,
<b>svc_sendreply</b>, <b>svc_unregister</b>,
<b>svcerr_auth</b>, <b>svcerr_decode</b>,
<b>svcerr_noproc</b>, <b>svcerr_noprog</b>,
<b>svcerr_progvers</b>, <b>svcerr_systemerr</b>,
<b>svcerr_weakauth</b>, <b>svcfd_create</b>,
<b>svcunixfd_create</b>, <b>svcraw_create</b>,
<b>svcunix_create</b>, <b>xdr_accepted_reply</b>,
<b>xdr_authunix_parms</b>, <b>xdr_callhdr</b>,
<b>xdr_callmsg</b>, <b>xdr_opaque_auth</b>, <b>xdr_pmap</b>,
<b>xdr_pmaplist</b>, <b>xdr_rejected_reply</b>,
<b>xdr_replymsg</b>, <b>xprt_register</b>,
<b>xprt_unregister</b> &mdash; library routines for remote
procedure calls</p>

<p style="margin-top: 1em"><b>SYNOPSIS</b></p>

<p style="margin-left:6%;"><b>#include
&lt;rpc/rpc.h&gt;</b></p>

<p style="margin-left:6%; margin-top: 1em">See
<i>DESCRIPTION</i> for function declarations.</p>

<p style="margin-top: 1em"><b>DESCRIPTION</b></p>

<p style="margin-left:6%;"><b>The svc_*</b>() <b>and
clnt_*</b>() <b>functions described in this page are the
old, TS-RPC interface to the XDR and RPC library, and exist
for backward compatibility. The new interface is described
in the pages referenced from</b> rpc(<b>3</b>)<b>.</b></p>

<p style="margin-left:6%; margin-top: 1em">These routines
allow C programs to make procedure calls on other machines
across the network. First, the client calls a procedure to
send a data packet to the server. Upon receipt of the
packet, the server calls a dispatch routine to perform the
requested service, and then sends back a reply. Finally, the
procedure call returns to the client.</p>

<p style="margin-left:6%; margin-top: 1em">Routines that
are used for Secure RPC (DES authentication) are described
in rpc_secure(3). Secure RPC can be used only if DES
encryption is available.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
auth_destroy</b>(<i>AUTH *auth</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
destroys the authentication information associated with
<i>auth</i>. Destruction usually involves deallocation of
private data structures. The use of <i>auth</i> is undefined
after calling <b>auth_destroy</b>().</p>

<p style="margin-top: 1em"><i>AUTH *</i> <b><br>
authnone_create</b>()</p>

<p style="margin-left:17%; margin-top: 1em">Create and
return an RPC authentication handle that passes nonusable
authentication information with each remote procedure call.
This is the default authentication used by RPC.</p>

<p style="margin-top: 1em"><i>AUTH *</i> <b><br>
authunix_create</b>(<i>char *host</i>, <i>int uid</i>,
<i>int gid</i>, <i>int len</i>, <i>int *aup_gids</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Create and
return an RPC authentication handle that contains UNIX
authentication information. The <i>host</i> argument is the
name of the machine on which the information was created;
<i>uid</i> is the user&rsquo;s user ID; <i>gid</i> is the
user&rsquo;s current group ID; <i>len</i> and
<i>aup_gids</i> refer to a counted array of groups to which
the user belongs. It is easy to impersonate a user.</p>

<p style="margin-top: 1em"><i>AUTH *</i> <b><br>
authunix_create_default</b>()</p>

<p style="margin-left:17%; margin-top: 1em">Calls
<b>authunix_create</b>() with the appropriate arguments.</p>

<p style="margin-top: 1em"><i>int</i> <b><br>
callrpc</b>(<i>char&nbsp;*host</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>u_long&nbsp;procnum</i>, <i>xdrproc_t&nbsp;inproc</i>,
<i>void&nbsp;*in</i>, <i>xdrproc_t&nbsp;outproc</i>,
<i>void&nbsp;*out</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Call the remote
procedure associated with <i>prognum</i>, <i>versnum</i>,
and <i>procnum</i> on the machine <i>host</i>. The <i>in</i>
argument is the address of the procedure&rsquo;s
argument(s), and <i>out</i> is the address of where to place
the result(s); <i>inproc</i> is used to encode the
procedure&rsquo;s arguments, and <i>outproc</i> is used to
decode the procedure&rsquo;s results. This routine returns
zero if it succeeds, or the value of <i>enum clnt_stat</i>
cast to an integer if it fails. The routine
<b>clnt_perrno</b>() is handy for translating failure
statuses into messages.</p>

<p style="margin-left:17%; margin-top: 1em">Warning:
calling remote procedures with this routine uses UDP/IP as a
transport; see <b>clntudp_create</b>() for restrictions. You
do not have control of timeouts or authentication using this
routine.</p>

<p style="margin-top: 1em"><i>enum clnt_stat</i> <b><br>
clnt_broadcast</b>(<i>u_long&nbsp;prognum</i>,
<i>u_long&nbsp;versnum</i>, <i>u_long&nbsp;procnum</i>,
<i>xdrproc_t&nbsp;inproc</i>, <i>char&nbsp;*in</i>,
<i>xdrproc_t&nbsp;outproc</i>, <i>char&nbsp;*out</i>,
<i>bool_t&nbsp;(*eachresult)(caddr_t,&nbsp;struct&nbsp;sockaddr_in&nbsp;*)</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Like
<b>callrpc</b>(), except the call message is broadcast to
all locally connected broadcast nets. Each time it receives
a response, this routine calls <b>eachresult</b>(), whose
form is:</p>

<p style="margin-left:24%; margin-top: 1em"><i>bool_t</i>
<b>eachresult</b>(<i>caddr_t out</i>, <i>struct sockaddr_in
*addr</i>)</p>

<p style="margin-left:17%; margin-top: 1em">where
<i>out</i> is the same as <i>out</i> passed to
<b>clnt_broadcast</b>(), except that the remote
procedure&rsquo;s output is decoded there; <i>addr</i>
points to the address of the machine that sent the results.
If <b>eachresult</b>() returns zero, <b>clnt_broadcast</b>()
waits for more replies; otherwise it returns with
appropriate status.</p>

<p style="margin-left:17%; margin-top: 1em">Warning:
broadcast sockets are limited in size to the maximum
transfer unit of the data link. For ethernet, this value is
1500 bytes.</p>

<p style="margin-top: 1em"><i>enum clnt_stat</i> <b><br>
clnt_call</b>(<i>CLIENT&nbsp;*clnt</i>,
<i>u_long&nbsp;procnum</i>, <i>xdrproc_t&nbsp;inproc</i>,
<i>char&nbsp;*in</i>, <i>xdrproc_t&nbsp;outproc</i>,
<i>char&nbsp;*out</i>,
<i>struct&nbsp;timeval&nbsp;tout</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
calls the remote procedure <i>procnum</i> associated with
the client handle, <i>clnt</i>, which is obtained with an
RPC client creation routine such as <b>clnt_create</b>().
The <i>in</i> argument is the address of the
procedure&rsquo;s argument(s), and <i>out</i> is the address
of where to place the result(s); <i>inproc</i> is used to
encode the procedure&rsquo;s arguments, and <i>outproc</i>
is used to decode the procedure&rsquo;s results; <i>tout</i>
is the time allowed for results to come back.</p>

<p style="margin-top: 1em"><i>void</i>
<b>clnt_destroy</b>(<i>CLIENT *clnt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
destroys the client&rsquo;s RPC handle. Destruction usually
involves deallocation of private data structures, including
<i>clnt</i> itself. Use of <i>clnt</i> is undefined after
calling <b>clnt_destroy</b>(). If the RPC library opened the
associated socket, it will close it also. Otherwise, the
socket remains open.</p>

<p style="margin-top: 1em"><i>CLIENT *</i> <b><br>
clnt_create</b>(<i>char *host</i>, <i>u_long prog</i>,
<i>u_long vers</i>, <i>char *proto</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Generic client
creation routine. The <i>host</i> argument identifies the
name of the remote host where the server is located. The
<i>proto</i> argument indicates which kind of transport
protocol to use. The currently supported values for this
field are &quot;udp&quot; and &quot;tcp&quot;. Default
timeouts are set, but can be modified using
<b>clnt_control</b>().</p>

<p style="margin-left:17%; margin-top: 1em">Warning: Using
UDP has its shortcomings. Since UDP-based RPC messages can
only hold up to 8 Kbytes of encoded data, this transport
cannot be used for procedures that take large arguments or
return huge results.</p>

<p style="margin-top: 1em"><i>bool_t</i> <b><br>
clnt_control</b>(<i>CLIENT *cl</i>, <i>u_int req</i>,
<i>char *info</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro used to
change or retrieve various information about a client
object. The <i>req</i> argument indicates the type of
operation, and <i>info</i> is a pointer to the information.
For both UDP and TCP, the supported values of <i>req</i> and
their argument types and what they do are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>CLSET_TIMEOUT</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p><i>struct timeval</i></p></table>

<p>set total timeout</p>

<p style="margin-left:74%;">CLGET_TIMEOUT</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p><i>struct timeval</i></p></table>

<p>get total timeout</p>

<p style="margin-left:17%; margin-top: 1em">Note: if you
set the timeout using <b>clnt_control</b>(), the timeout
argument passed to <b>clnt_call</b>() will be ignored in all
future calls.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>CLGET_SERVER_ADDR</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p><i>struct sockaddr_in</i></p></table>

<p>get server&rsquo;s address</p>

<p style="margin-left:17%; margin-top: 1em">The following
operations are valid for UDP only:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>CLSET_RETRY_TIMEOUT</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p><i>struct timeval</i></p></table>

<p>set the retry timeout</p>

<p style="margin-left:74%;">CLGET_RETRY_TIMEOUT</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p><i>struct timeval</i></p></table>

<p>get the retry timeout</p>

<p style="margin-left:17%; margin-top: 1em">The retry
timeout is the time that UDP RPC waits for the server to
reply before retransmitting the request.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>clnt_freeres</b>(<i>CLIENT *clnt</i>, <i>xdrproc_t
outproc</i>, <i>char *out</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
frees any data allocated by the RPC/XDR system when it
decoded the results of an RPC call. The <i>out</i> argument
is the address of the results, and <i>outproc</i> is the XDR
routine describing the results. This routine returns one if
the results were successfully freed, and zero otherwise.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
clnt_geterr</b>(<i>CLIENT *clnt</i>, <i>struct rpc_err
*errp</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
copies the error structure out of the client handle to the
structure at address <i>errp</i>.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
clnt_pcreateerror</b>(<i>char *s</i>)</p>

<p style="margin-left:17%; margin-top: 1em">prints a
message to standard error indicating why a client RPC handle
could not be created. The message is prepended with string
<i>s</i> and a colon. A newline is appended at the end of
the message. Used when a <b>clnt_create</b>(),
<b>clntraw_create</b>(), <b>clnttcp_create</b>(), or
<b>clntudp_create</b>() call fails.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
clnt_perrno</b>(<i>enum clnt_stat stat</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Print a message
to standard error corresponding to the condition indicated
by <i>stat</i>. A newline is appended at the end of the
message. Used after <b>callrpc</b>().</p>

<p style="margin-top: 1em"><i>void</i>
<b>clnt_perror</b>(<i>CLIENT *clnt</i>, <i>char *s</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Print a message
to standard error indicating why an RPC call failed;
<i>clnt</i> is the handle used to do the call. The message
is prepended with string <i>s</i> and a colon. A newline is
appended at the end of the message. Used after
<b>clnt_call</b>().</p>

<p style="margin-top: 1em"><i>char *</i> <b><br>
clnt_spcreateerror</b>(<i>char *s</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Like
<b>clnt_pcreateerror</b>(), except that it returns a string
instead of printing to the standard error.</p>

<p style="margin-left:17%; margin-top: 1em">Bugs: returns
pointer to static data that is overwritten on each call.</p>

<p style="margin-top: 1em"><i>char *</i> <b><br>
clnt_sperrno</b>(<i>enum clnt_stat stat</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Take the same
arguments as <b>clnt_perrno</b>(), but instead of sending a
message to the standard error indicating why an RPC call
failed, return a pointer to a string which contains the
message.</p>

<p style="margin-left:17%; margin-top: 1em">The
<b>clnt_sperrno</b>() function is used instead of
<b>clnt_perrno</b>() if the program does not have a standard
error (as a program running as a server quite likely does
not), or if the programmer does not want the message to be
output with <b>printf</b>(), or if a message format
different from that supported by <b>clnt_perrno</b>() is to
be used.</p>

<p style="margin-left:17%; margin-top: 1em">Note: unlike
<b>clnt_sperror</b>() and <b>clnt_spcreateerror</b>(),
<b>clnt_sperrno</b>() returns pointer to static data, but
the result will not get overwritten on each call.</p>

<p style="margin-top: 1em"><i>char *</i> <b><br>
clnt_sperror</b>(<i>CLIENT *rpch</i>, <i>char *s</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Like
<b>clnt_perror</b>(), except that (like
<b>clnt_sperrno</b>()) it returns a string instead of
printing to standard error.</p>

<p style="margin-left:17%; margin-top: 1em">Bugs: returns
pointer to static data that is overwritten on each call.</p>

<p style="margin-top: 1em"><i>CLIENT *</i> <b><br>
clntraw_create</b>(<i>u_long prognum</i>, <i>u_long
versnum</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates a toy RPC client for the remote program
<i>prognum</i>, version <i>versnum</i>. The transport used
to pass messages to the service is actually a buffer within
the process&rsquo;s address space, so the corresponding RPC
server should live in the same address space; see
<b>svcraw_create</b>(). This allows simulation of RPC and
acquisition of RPC overheads, such as round trip times,
without any kernel interference. This routine returns NULL
if it fails.</p>

<p style="margin-top: 1em"><i>CLIENT *</i> <b><br>

clnttcp_create</b>(<i>struct&nbsp;sockaddr_in&nbsp;*addr</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>int&nbsp;*sockp</i>, <i>u_int&nbsp;sendsz</i>,
<i>u_int&nbsp;recvsz</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates an RPC client for the remote program <i>prognum</i>,
version <i>versnum</i>; the client uses TCP/IP as a
transport. The remote program is located at Internet address
<i>addr</i>. If <i>addr-&gt;sin_port</i> is zero, then it is
set to the actual port that the remote program is listening
on (the remote rpcbind(8) service is consulted for this
information). The <i>sockp</i> argument is a socket; if it
is RPC_ANYSOCK, then this routine opens a new one and sets
<i>sockp</i>. Since TCP-based RPC uses buffered I/O, the
user may specify the size of the send and receive buffers
with the <i>sendsz</i> and <i>recvsz</i> arguments; values
of zero choose suitable defaults. This routine returns NULL
if it fails.</p>

<p style="margin-top: 1em"><i>CLIENT *</i> <b><br>

clntudp_create</b>(<i>struct&nbsp;sockaddr_in&nbsp;*addr</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>struct&nbsp;timeval&nbsp;wait</i>,
<i>int&nbsp;*sockp</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates an RPC client for the remote program <i>prognum</i>,
version <i>versnum</i>; the client uses UDP/IP as a
transport. The remote program is located at Internet address
<i>addr</i>. If <i>addr-&gt;sin_port</i> is zero, then it is
set to actual port that the remote program is listening on
(the remote rpcbind(8) service is consulted for this
information). The <i>sockp</i> argument is a socket; if it
is RPC_ANYSOCK, then this routine opens a new one and sets
<i>sockp</i>. The UDP transport resends the call message in
intervals of <i>wait</i> time until a response is received
or until the call times out. The total time for the call to
time out is specified by <b>clnt_call</b>().</p>

<p style="margin-left:17%; margin-top: 1em">Warning: since
UDP-based RPC messages can only hold up to 8 Kbytes of
encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.</p>

<p style="margin-top: 1em"><i>CLIENT *</i> <b><br>

clntudp_bufcreate</b>(<i>struct&nbsp;sockaddr_in&nbsp;*addr</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>struct&nbsp;timeval&nbsp;wait</i>,
<i>int&nbsp;*sockp</i>,
<i>unsigned&nbsp;int&nbsp;sendsize</i>,
<i>unsigned&nbsp;int&nbsp;recosize</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates an RPC client for the remote program <i>prognum</i>,
on <i>versnum</i>; the client uses UDP/IP as a transport.
The remote program is located at Internet address
<i>addr</i>. If <i>addr-&gt;sin_port</i> is zero, then it is
set to actual port that the remote program is listening on
(the remote rpcbind(8) service is consulted for this
information). The <i>sockp</i> argument is a socket; if it
is RPC_ANYSOCK, then this routine opens a new one and sets
<i>sockp</i>. The UDP transport resends the call message in
intervals of <i>wait</i> time until a response is received
or until the call times out. The total time for the call to
time out is specified by <b>clnt_call</b>().</p>

<p style="margin-left:17%; margin-top: 1em">This allows the
user to specify the maximum packet size for sending and
receiving UDP-based RPC messages.</p>

<p style="margin-top: 1em"><i>CLIENT *</i> <b><br>

clntunix_create</b>(<i>struct&nbsp;sockaddr_un&nbsp;*raddr</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>int&nbsp;*sockp</i>, <i>u_int&nbsp;sendsz</i>,
<i>u_int&nbsp;recvsz</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates an RPC client for the local program <i>prognum</i>,
version <i>versnum</i>; the client uses UNIX-domain sockets
as a transport. The local program is located at the
<i>*raddr</i>. The <i>sockp</i> argument is a socket; if it
is RPC_ANYSOCK, then this routine opens a new one and sets
<i>sockp</i>. Since UNIX-based RPC uses buffered I/O, the
user may specify the size of the send and receive buffers
with the <i>sendsz</i> and <i>recvsz</i> arguments; values
of zero choose suitable defaults. This routine returns NULL
if it fails.</p>

<p style="margin-top: 1em"><i>int</i> <b><br>
get_myaddress</b>(<i>struct sockaddr_in *addr</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Stuff the
machine&rsquo;s IP address into <i>addr</i>, without
consulting the library routines that deal with
<i>/etc/hosts</i>. The port number is always set to
<b>htons</b>(<i>PMAPPORT</i>). Returns zero on success,
non-zero on failure.</p>

<p style="margin-top: 1em"><i>struct pmaplist *</i> <b><br>
pmap_getmaps</b>(<i>struct sockaddr_in *addr</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A user
interface to the rpcbind(8) service, which returns a list of
the current RPC program-to-port mappings on the host located
at IP address <i>addr</i>. This routine can return NULL. The
command &ldquo;<b>rpcinfo -p</b>&rdquo; uses this
routine.</p>

<p style="margin-top: 1em"><i>u_short</i> <b><br>
pmap_getport</b>(<i>struct&nbsp;sockaddr_in&nbsp;*addr</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>u_long&nbsp;protocol</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A user
interface to the rpcbind(8) service, which returns the port
number on which waits a service that supports program number
<i>prognum</i>, version <i>versnum</i>, and speaks the
transport protocol associated with <i>protocol</i>. The
value of <i>protocol</i> is most likely IPPROTO_UDP or
IPPROTO_TCP. A return value of zero means that the mapping
does not exist or that the RPC system failed to contact the
remote rpcbind(8) service. In the latter case, the global
variable <i>rpc_createerr</i> contains the RPC status.</p>

<p style="margin-top: 1em"><i>enum clnt_stat</i> <b><br>
pmap_rmtcall</b>(<i>struct&nbsp;sockaddr_in&nbsp;*addr</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>u_long&nbsp;procnum</i>, <i>xdrproc_t&nbsp;inproc</i>,
<i>char&nbsp;*in</i>, <i>xdrproc_t&nbsp;outproc</i>,
<i>char&nbsp;*out</i>, <i>struct&nbsp;timeval&nbsp;tout</i>,
<i>u_long&nbsp;*portp</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A user
interface to the rpcbind(8) service, which instructs
rpcbind(8) on the host at IP address <i>addr</i> to make an
RPC call on your behalf to a procedure on that host. The
<i>portp</i> argument will be modified to the
program&rsquo;s port number if the procedure succeeds. The
definitions of other arguments are discussed in
<b>callrpc</b>() and <b>clnt_call</b>(). This procedure
should be used for a &ldquo;ping&rdquo; and nothing else.
See also <b>clnt_broadcast</b>().</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>pmap_set</b>(<i>u_long prognum</i>, <i>u_long
versnum</i>, <i>u_long protocol</i>, <i>u_short
port</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A user
interface to the rpcbind(8) service, which establishes a
mapping between the triple (<i>prognum</i>, <i>versnum</i>,
<i>protocol</i>) and <i>port</i> on the machine&rsquo;s
rpcbind(8) service. The value of <i>protocol</i> is most
likely IPPROTO_UDP or IPPROTO_TCP. This routine returns one
if it succeeds, zero otherwise. Automatically done by
<b>svc_register</b>().</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>pmap_unset</b>(<i>u_long prognum</i>, <i>u_long
versnum</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A user
interface to the rpcbind(8) service, which destroys all
mapping between the triple (<i>prognum</i>, <i>versnum</i>,
<i>*</i>) and <i>ports</i> on the machine&rsquo;s rpcbind(8)
service. This routine returns one if it succeeds, zero
otherwise.</p>

<p style="margin-top: 1em"><i>bool_t</i> <b><br>
registerrpc</b>(<i>u_long&nbsp;prognum</i>,
<i>u_long&nbsp;versnum</i>, <i>u_long&nbsp;procnum</i>,
<i>char&nbsp;*(*procname)(void)</i>,
<i>xdrproc_t&nbsp;inproc</i>,
<i>xdrproc_t&nbsp;outproc</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Register
procedure <i>procname</i> with the RPC service package. If a
request arrives for program <i>prognum</i>, version
<i>versnum</i>, and procedure <i>procnum</i>,
<i>procname</i> is called with a pointer to its argument(s);
<i>progname</i> should return a pointer to its static
result(s); <i>inproc</i> is used to decode the arguments
while <i>outproc</i> is used to encode the results. This
routine returns zero if the registration succeeded, -1
otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">Warning: remote
procedures registered in this form are accessed using the
UDP/IP transport; see <b>svcudp_create</b>() for
restrictions.</p>

<p style="margin-top: 1em"><i>struct rpc_createerr
rpc_createerr</i>;</p>

<p style="margin-left:17%; margin-top: 1em">A global
variable whose value is set by any RPC client creation
routine that does not succeed. Use the routine
<b>clnt_pcreateerror</b>() to print the reason why.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>svc_destroy</b>(<i>SVCXPRT * xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
destroys the RPC service transport handle, <i>xprt</i>.
Destruction usually involves deallocation of private data
structures, including <i>xprt</i> itself. Use of <i>xprt</i>
is undefined after calling this routine.</p>

<p style="margin-top: 1em"><i>fd_set svc_fdset</i>;</p>

<p style="margin-left:17%; margin-top: 1em">A global
variable reflecting the RPC service side&rsquo;s read file
descriptor bit mask; it is suitable as a template argument
to the select(2) system call. This is only of interest if a
service implementor does not call <b>svc_run</b>(), but
rather does his own asynchronous event processing. This
variable is read-only (do not pass its address to
select(2)!), yet it may change after calls to
<b>svc_getreqset</b>() or any creation routines. As well,
note that if the process has descriptor limits which are
extended beyond FD_SETSIZE, this variable will only be
usable for the first FD_SETSIZE descriptors.</p>

<p style="margin-top: 1em"><i>int svc_fds</i>;</p>

<p style="margin-left:17%; margin-top: 1em">Similar to
<i>svc_fdset</i>, but limited to 32 descriptors. This
interface is obsoleted by <i>svc_fdset</i>.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>svc_freeargs</b>(<i>SVCXPRT *xprt</i>, <i>xdrproc_t
inproc</i>, <i>char *in</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
frees any data allocated by the RPC/XDR system when it
decoded the arguments to a service procedure using
<b>svc_getargs</b>(). This routine returns 1 if the results
were successfully freed, and zero otherwise.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>svc_getargs</b>(<i>SVCXPRT *xprt</i>, <i>xdrproc_t
inproc</i>, <i>char *in</i>)</p>

<p style="margin-left:17%; margin-top: 1em">A macro that
decodes the arguments of an RPC request associated with the
RPC service transport handle, <i>xprt</i>. The <i>in</i>
argument is the address where the arguments will be placed;
<i>inproc</i> is the XDR routine used to decode the
arguments. This routine returns one if decoding succeeds,
and zero otherwise.</p>

<p style="margin-top: 1em"><i>struct sockaddr_in *</i>
<b><br>
svc_getcaller</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">The approved
way of getting the network address of the caller of a
procedure associated with the RPC service transport handle,
<i>xprt</i>.</p>

<p style="margin-top: 1em"><i>void</i>
<b>svc_getreqset</b>(<i>fd_set *rdfds</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine is
only of interest if a service implementor does not call
<b>svc_run</b>(), but instead implements custom asynchronous
event processing. It is called when the select(2) system
call has determined that an RPC request has arrived on some
RPC socket(s); <i>rdfds</i> is the resultant read file
descriptor bit mask. The routine returns when all sockets
associated with the value of <i>rdfds</i> have been
serviced.</p>

<p style="margin-top: 1em"><i>void</i>
<b>svc_getreq</b>(<i>int rdfds</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Similar to
<b>svc_getreqset</b>(), but limited to 32 descriptors. This
interface is obsoleted by <b>svc_getreqset</b>().</p>

<p style="margin-top: 1em"><i>bool_t</i> <b><br>
svc_register</b>(<i>SVCXPRT&nbsp;*xprt</i>,
<i>u_long&nbsp;prognum</i>, <i>u_long&nbsp;versnum</i>,
<i>void&nbsp;(*dispatch)(struct&nbsp;svc_req&nbsp;*,&nbsp;SVCXPRT&nbsp;*)</i>,
<i>int&nbsp;protocol</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Associates
<i>prognum</i> and <i>versnum</i> with the service dispatch
procedure, <b>dispatch</b>(). If <i>protocol</i> is zero,
the service is not registered with the rpcbind(8) service.
If <i>protocol</i> is non-zero, then a mapping of the triple
(<i>prognum</i>, <i>versnum</i>, <i>protocol</i>) to
<i>xprt-&gt;xp_port</i> is established with the local
rpcbind(8) service (generally <i>protocol</i> is zero,
IPPROTO_UDP or IPPROTO_TCP). The procedure <b>dispatch</b>()
has the following form:</p>

<p style="margin-left:24%; margin-top: 1em"><i>bool_t</i>
<b>dispatch</b>(<i>struct svc_req *request</i>, <i>SVCXPRT
*xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">The
<b>svc_register</b>() routine returns one if it succeeds,
and zero otherwise.</p>

<p style="margin-top: 1em"><b>svc_run</b>()</p>

<p style="margin-left:17%; margin-top: 1em">This routine
never returns. It waits for RPC requests to arrive, and
calls the appropriate service procedure using
<b>svc_getreq</b>() when one arrives. This procedure is
usually waiting for a select(2) system call to return.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>svc_sendreply</b>(<i>SVCXPRT *xprt</i>, <i>xdrproc_t
outproc</i>, <i>char *out</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called by an
RPC service&rsquo;s dispatch routine to send the results of
a remote procedure call. The <i>xprt</i> argument is the
request&rsquo;s associated transport handle; <i>outproc</i>
is the XDR routine which is used to encode the results; and
<i>out</i> is the address of the results. This routine
returns one if it succeeds, zero otherwise.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svc_unregister</b>(<i>u_long prognum</i>, <i>u_long
versnum</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Remove all
mapping of the double (<i>prognum</i>, <i>versnum</i>) to
dispatch routines, and of the triple (<i>prognum</i>,
<i>versnum</i>, <i>*</i>) to port number.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svcerr_auth</b>(<i>SVCXPRT *xprt</i>, <i>enum auth_stat
why</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called by a
service dispatch routine that refuses to perform a remote
procedure call due to an authentication error.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svcerr_decode</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called by a
service dispatch routine that cannot successfully decode its
arguments. See also <b>svc_getargs</b>().</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svcerr_noproc</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called by a
service dispatch routine that does not implement the
procedure number that the caller requests.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svcerr_noprog</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called when the
desired program is not registered with the RPC package.
Service implementors usually do not need this routine.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svcerr_progvers</b>(<i>SVCXPRT *xprt</i>, <i>u_long
low_vers</i>, <i>u_long high_vers</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called when the
desired version of a program is not registered with the RPC
package. Service implementors usually do not need this
routine.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svcerr_systemerr</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called by a
service dispatch routine when it detects a system error not
covered by any particular protocol. For example, if a
service can no longer allocate storage, it may call this
routine.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
svcerr_weakauth</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Called by a
service dispatch routine that refuses to perform a remote
procedure call due to insufficient authentication arguments.
The routine calls <b>svcerr_auth</b>(<i>xprt</i>,
<i>AUTH_TOOWEAK</i>).</p>

<p style="margin-top: 1em"><i>SVCXPRT *</i> <b><br>
svcraw_create</b>(<i>void</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates a toy RPC service transport, to which it returns a
pointer. The transport is really a buffer within the
process&rsquo;s address space, so the corresponding RPC
client should live in the same address space; see
<b>clntraw_create</b>(). This routine allows simulation of
RPC and acquisition of RPC overheads (such as round trip
times), without any kernel interference. This routine
returns NULL if it fails.</p>

<p style="margin-top: 1em"><i>SVCXPRT *</i> <b><br>
svctcp_create</b>(<i>int sock</i>, <i>u_int
send_buf_size</i>, <i>u_int recv_buf_size</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates a TCP/IP-based RPC service transport, to which it
returns a pointer. The transport is associated with the
socket <i>sock</i>, which may be RPC_ANYSOCK, in which case
a new socket is created. If the socket is not bound to a
local TCP port, then this routine binds it to an arbitrary
port. Upon completion, <i>xprt-&gt;xp_fd</i> is the
transport&rsquo;s socket descriptor, and
<i>xprt-&gt;xp_port</i> is the transport&rsquo;s port
number. This routine returns NULL if it fails. Since
TCP-based RPC uses buffered I/O, users may specify the size
of buffers; values of zero choose suitable defaults.</p>

<p style="margin-top: 1em"><i>SVCXPRT *</i> <b><br>
svcunix_create</b>(<i>int sock</i>, <i>u_int
send_buf_size</i>, <i>u_int recv_buf_size</i>, <i>char
*path</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates a UNIX-based RPC service transport, to which it
returns a pointer. The transport is associated with the
socket <i>sock</i>, which may be RPC_ANYSOCK, in which case
a new socket is created. The <i>*path</i> argument is a
variable-length file system pathname of at most 104
characters. This file is <i>not</i> removed when the socket
is closed. The unlink(2) system call must be used to remove
the file. Upon completion, <i>xprt-&gt;xp_fd</i> is the
transport&rsquo;s socket descriptor. This routine returns
NULL if it fails. Since UNIX-based RPC uses buffered I/O,
users may specify the size of buffers; values of zero choose
suitable defaults.</p>

<p style="margin-top: 1em"><i>SVCXPRT *</i> <b><br>
svcunixfd_create</b>(<i>int fd</i>, <i>u_int sendsize</i>,
<i>u_int recvsize</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Create a
service on top of any open descriptor. The <i>sendsize</i>
and <i>recvsize</i> arguments indicate sizes for the send
and receive buffers. If they are zero, a reasonable default
is chosen.</p>

<p style="margin-top: 1em"><i>SVCXPRT *</i> <b><br>
svcfd_create</b>(<i>int fd</i>, <i>u_int sendsize</i>,
<i>u_int recvsize</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Create a
service on top of any open descriptor. Typically, this
descriptor is a connected socket for a stream protocol such
as TCP. The <i>sendsize</i> and <i>recvsize</i> arguments
indicate sizes for the send and receive buffers. If they are
zero, a reasonable default is chosen.</p>

<p style="margin-top: 1em"><i>SVCXPRT *</i> <b><br>
svcudp_bufcreate</b>(<i>int sock</i>, <i>u_int sendsize</i>,
<i>u_int recvsize</i>)</p>

<p style="margin-left:17%; margin-top: 1em">This routine
creates a UDP/IP-based RPC service transport, to which it
returns a pointer. The transport is associated with the
socket <i>sock</i>, which may be RPC_ANYSOCK, in which case
a new socket is created. If the socket is not bound to a
local UDP port, then this routine binds it to an arbitrary
port. Upon completion, <i>xprt-&gt;xp_fd</i> is the
transport&rsquo;s socket descriptor, and
<i>xprt-&gt;xp_port</i> is the transport&rsquo;s port
number. This routine returns NULL if it fails.</p>

<p style="margin-left:17%; margin-top: 1em">This allows the
user to specify the maximum packet size for sending and
receiving UDP-based RPC messages.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>xdr_accepted_reply</b>(<i>XDR *xdrs</i>, <i>struct
accepted_reply *ar</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
encoding RPC reply messages. This routine is useful for
users who wish to generate RPC-style messages without using
the RPC package.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>xdr_authunix_parms</b>(<i>XDR *xdrs</i>, <i>struct
authunix_parms *aupp</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing UNIX credentials. This routine is useful for
users who wish to generate these credentials without using
the RPC authentication package.</p>

<p style="margin-top: 1em"><i>void <br>
bool_t</i> <b>xdr_callhdr</b>(<i>XDR *xdrs</i>, <i>struct
rpc_msg *chdr</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing RPC call header messages. This routine is useful
for users who wish to generate RPC-style messages without
using the RPC package.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>xdr_callmsg</b>(<i>XDR *xdrs</i>, <i>struct rpc_msg
*cmsg</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing RPC call messages. This routine is useful for
users who wish to generate RPC-style messages without using
the RPC package.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>xdr_opaque_auth</b>(<i>XDR *xdrs</i>, <i>struct
opaque_auth *ap</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing RPC authentication information messages. This
routine is useful for users who wish to generate RPC-style
messages without using the RPC package.</p>

<p style="margin-top: 1em"><i>struct pmap</i>; <i><br>
bool_t</i> <b>xdr_pmap</b>(<i>XDR *xdrs</i>, <i>struct pmap
*regs</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing arguments to various rpcbind(8) procedures,
externally. This routine is useful for users who wish to
generate these arguments without using the <b>pmap_*</b>()
interface.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>xdr_pmaplist</b>(<i>XDR *xdrs</i>, <i>struct pmaplist
**rp</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing a list of port mappings, externally. This routine
is useful for users who wish to generate these arguments
without using the <b>pmap_*</b>() interface.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>xdr_rejected_reply</b>(<i>XDR *xdrs</i>, <i>struct
rejected_reply *rr</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing RPC reply messages. This routine is useful for
users who wish to generate RPC-style messages without using
the RPC package.</p>

<p style="margin-top: 1em"><i>bool_t</i>
<b>xdr_replymsg</b>(<i>XDR *xdrs</i>, <i>struct rpc_msg
*rmsg</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Used for
describing RPC reply messages. This routine is useful for
users who wish to generate RPC style messages without using
the RPC package.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
xprt_register</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">After RPC
service transport handles are created, they should register
themselves with the RPC service package. This routine
modifies the global variable <i>svc_fds</i>. Service
implementors usually do not need this routine.</p>

<p style="margin-top: 1em"><i>void</i> <b><br>
xprt_unregister</b>(<i>SVCXPRT *xprt</i>)</p>

<p style="margin-left:17%; margin-top: 1em">Before an RPC
service transport handle is destroyed, it should unregister
itself with the RPC service package. This routine modifies
the global variable <i>svc_fds</i>. Service implementors
usually do not need this routine.</p>

<p style="margin-top: 1em"><b>AVAILABILITY</b></p>

<p style="margin-left:6%;">These functions are part of
libtirpc.</p>

<p style="margin-top: 1em"><b>SEE ALSO</b></p>

<p style="margin-left:6%;">rpc_secure(3), xdr(3)</p>

<p style="margin-top: 1em"><i>Remote Procedure Calls:
Protocol Specification</i></p>

<p style="margin-left:6%;">.</p>

<p style="margin-top: 1em"><i>Remote Procedure Call
Programming Guide</i></p>

<p style="margin-left:6%;">.</p>

<p style="margin-top: 1em"><i>rpcgen Programming
Guide</i></p>

<p style="margin-left:6%;">.</p>

<p style="margin-top: 1em"><i>RPC: Remote Procedure Call
Protocol Specification</i></p>

<p style="margin-left:6%;">,</p>

<p>Sun Microsystems, Inc., USC-ISI , <br>
RFC1050 .</p>

<p style="margin-left:6%; margin-top: 1em">BSD
February&nbsp;16, 1988 BSD</p>
<hr>
</body>
</html>
