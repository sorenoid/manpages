<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:48 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PRINTF</title>

</head>
<body>

<h1 align="center">PRINTF</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ATTRIBUTES">ATTRIBUTES</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">printf,
fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf,
vdprintf, vsprintf, vsnprintf - formatted output
conversion</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;stdio.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
printf(const char *</b><i>format</i><b>, ...); <br>
int fprintf(FILE *</b><i>stream</i><b>, const char
*</b><i>format</i><b>, ...); <br>
int dprintf(int</b> <i>fd</i><b>, const char
*</b><i>format</i><b>, ...); <br>
int sprintf(char *</b><i>str</i><b>, const char
*</b><i>format</i><b>, ...); <br>
int snprintf(char *</b><i>str</i><b>, size_t</b>
<i>size</i><b>, const char *</b><i>format</i><b>,
...);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;stdarg.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
vprintf(const char *</b><i>format</i><b>, va_list</b>
<i>ap</i><b>); <br>
int vfprintf(FILE *</b><i>stream</i><b>, const char
*</b><i>format</i><b>, va_list</b> <i>ap</i><b>); <br>
int vdprintf(int</b> <i>fd</i><b>, const char
*</b><i>format</i><b>, va_list</b> <i>ap</i><b>); <br>
int vsprintf(char *</b><i>str</i><b>, const char
*</b><i>format</i><b>, va_list</b> <i>ap</i><b>); <br>
int vsnprintf(char *</b><i>str</i><b>, size_t</b>
<i>size</i><b>, const char *</b><i>format</i><b>,
va_list</b> <i>ap</i><b>);</b></p>

<p style="margin-left:5%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<a href="https://man.page/7/feature_test_macros">feature_test_macros(7)</a>):</p>


<p style="margin-left:11%; margin-top: 1em"><b>snprintf</b>(),
<b>vsnprintf</b>():</p>


<p style="margin-left:17%;">_XOPEN_SOURCE&nbsp;&gt;=&nbsp;500
|| _ISOC99_SOURCE || <br>
|| /* Glibc versions &lt;= 2.19: */ _BSD_SOURCE</p>


<p style="margin-left:11%; margin-top: 1em"><b>dprintf</b>(),
<b>vdprintf</b>():</p>

<p style="margin-left:17%;">Since glibc 2.10:</p>


<p style="margin-left:23%;">_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200809L</p>

<p style="margin-left:17%;">Before glibc 2.10:</p>

<p style="margin-left:23%;">_GNU_SOURCE</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The functions
in the <b>printf</b>() family produce output according to a
<i>format</i> as described below. The functions
<b>printf</b>() and <b>vprintf</b>() write output to
<i>stdout</i>, the standard output stream; <b>fprintf</b>()
and <b>vfprintf</b>() write output to the given output
<i>stream</i>; <b>sprintf</b>(), <b>snprintf</b>(),
<b>vsprintf</b>(), and <b>vsnprintf</b>() write to the
character string <i>str</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The function
<b>dprintf</b>() is the same as <b>fprintf</b>() except that
it outputs to a file descriptor, <i>fd</i>, instead of to a
<i>stdio</i> stream.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>snprintf</b>() and <b>vsnprintf</b>() write at most
<i>size</i> bytes (including the terminating null byte
('\0')) to <i>str</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>vprintf</b>(), <b>vfprintf</b>(), <b>vdprintf</b>(),
<b>vsprintf</b>(), <b>vsnprintf</b>() are equivalent to the
functions <b>printf</b>(), <b>fprintf</b>(),
<b>dprintf</b>(), <b>sprintf</b>(), <b>snprintf</b>(),
respectively, except that they are called with a
<i>va_list</i> instead of a variable number of arguments.
These functions do not call the <i>va_end</i> macro. Because
they invoke the <i>va_arg</i> macro, the value of <i>ap</i>
is undefined after the call. See <a href="https://man.page/3/stdarg">stdarg(3)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">All of these
functions write the output under the control of a
<i>format</i> string that specifies how subsequent arguments
(or arguments accessed via the variable-length argument
facilities of <a href="https://man.page/3/stdarg">stdarg(3)</a>) are converted for
output.</p>

<p style="margin-left:11%; margin-top: 1em">C99 and
POSIX.1-2001 specify that the results are undefined if a
call to <b>sprintf</b>(), <b>snprintf</b>(),
<b>vsprintf</b>(), or <b>vsnprintf</b>() would cause copying
to take place between objects that overlap (e.g., if the
target string array and one of the supplied input arguments
refer to the same buffer). See NOTES.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Format of
the format string</b> <br>
The format string is a character string, beginning and
ending in its initial shift state, if any. The format string
is composed of zero or more directives: ordinary characters
(not <b>%</b>), which are copied unchanged to the output
stream; and conversion specifications, each of which results
in fetching zero or more subsequent arguments. Each
conversion specification is introduced by the character
<b>%</b>, and ends with a <i>conversion specifier</i>. In
between there may be (in this order) zero or more
<i>flags</i>, an optional minimum <i>field width</i>, an
optional <i>precision</i> and an optional <i>length
modifier</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
must correspond properly (after type promotion) with the
conversion specifier. By default, the arguments are used in
the order given, where each '*' (see <i>Field width</i> and
<i>Precision</i> below) and each conversion specifier asks
for the next argument (and it is an error if insufficiently
many arguments are given). One can also specify explicitly
which argument is taken, at each place where an argument is
required, by writing &quot;%m$&quot; instead of '%' and
&quot;*m$&quot; instead of '*', where the decimal integer
<i>m</i> denotes the position in the argument list of the
desired argument, indexed starting from 1. Thus,</p>


<p style="margin-left:17%; margin-top: 1em">printf(&quot;%*d&quot;,
width, num);</p>

<p style="margin-left:11%; margin-top: 1em">and</p>


<p style="margin-left:17%; margin-top: 1em">printf(&quot;%2$*1$d&quot;,
width, num);</p>

<p style="margin-left:11%; margin-top: 1em">are equivalent.
The second style allows repeated references to the same
argument. The C99 standard does not include the style using
'$', which comes from the Single UNIX Specification. If the
style using '$' is used, it must be used throughout for all
conversions taking an argument and all width and precision
arguments, but it may be mixed with &quot;%%&quot; formats,
which do not consume an argument. There may be no gaps in
the numbers of arguments specified using '$'; for example,
if arguments 1 and 3 are specified, argument 2 must also be
specified somewhere in the format string.</p>

<p style="margin-left:11%; margin-top: 1em">For some
numeric conversions a radix character (&quot;decimal
point&quot;) or thousands&rsquo; grouping character is used.
The actual character used depends on the <b>LC_NUMERIC</b>
part of the locale. (See <a href="https://man.page/3/setlocale">setlocale(3)</a>.) The POSIX
locale uses '.' as radix character, and does not have a
grouping character. Thus,</p>


<p style="margin-left:17%; margin-top: 1em">printf(&quot;%'.2f&quot;,
1234567.89);</p>

<p style="margin-left:11%; margin-top: 1em">results in
&quot;1234567.89&quot; in the POSIX locale, in
&quot;1234567,89&quot; in the nl_NL locale, and in
&quot;1.234.567,89&quot; in the da_DK locale.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Flag
characters</b> <br>
The character % is followed by zero or more of the following
flags:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>#</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The value should be converted to an &quot;alternate
form&quot;. For <b>o</b> conversions, the first character of
the output string is made zero (by prefixing a 0 if it was
not zero already). For <b>x</b> and <b>X</b> conversions, a
nonzero result has the string &quot;0x&quot; (or
&quot;0X&quot; for <b>X</b> conversions) prepended to it.
For <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>,
<b>F</b>, <b>g</b>, and <b>G</b> conversions, the result
will always contain a decimal point, even if no digits
follow it (normally, a decimal point appears in the results
of those conversions only if a digit follows). For <b>g</b>
and <b>G</b> conversions, trailing zeros are not removed
from the result as they would otherwise be. For other
conversions, the result is undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>0</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The value should be zero padded. For <b>d</b>, <b>i</b>,
<b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, <b>a</b>, <b>A</b>,
<b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, and
<b>G</b> conversions, the converted value is padded on the
left with zeros rather than blanks. If the <b>0</b> and
<b>-</b> flags both appear, the <b>0</b> flag is ignored. If
a precision is given with a numeric conversion (<b>d</b>,
<b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, and <b>X</b>), the
<b>0</b> flag is ignored. For other conversions, the
behavior is undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>-</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The converted value is to be left adjusted on the field
boundary. (The default is right justification.) The
converted value is padded on the right with blanks, rather
than on the left with blanks or zeros. A <b>-</b> overrides
a <b>0</b> if both are given.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>' '</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>(a space) A blank should be left before a positive
number (or empty string) produced by a signed
conversion.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>+</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>A sign (+ or -) should always be placed before a number
produced by a signed conversion. By default, a sign is used
only for negative numbers. A <b>+</b> overrides a space if
both are used.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The five flag
characters above are defined in the C99 standard. The Single
UNIX Specification specifies one further flag character.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>'</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">For decimal conversion
(<b>i</b>, <b>d</b>, <b>u</b>, <b>f</b>, <b>F</b>, <b>g</b>,
<b>G</b>) the output is to be grouped with thousands&rsquo;
grouping characters if the locale information indicates any.
(See <a href="https://man.page/3/setlocale">setlocale(3)</a>.) Note that many versions of
<a href="https://man.page/1/gcc">gcc(1)</a> cannot parse this option and will issue a
warning. (SUSv2 did not include <i>%'F</i>, but SUSv3 added
it.)</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">glibc 2.2 adds
one further flag character.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>I</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">For decimal integer conversion
(<b>i</b>, <b>d</b>, <b>u</b>) the output uses the
locale&rsquo;s alternative output digits, if any. For
example, since glibc 2.2.3 this will give Arabic-Indic
digits in the Persian (&quot;fa_IR&quot;) locale.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Field
width</b> <br>
An optional decimal digit string (with nonzero first digit)
specifying a minimum field width. If the converted value has
fewer characters than the field width, it will be padded
with spaces on the left (or right, if the left-adjustment
flag has been given). Instead of a decimal digit string one
may write &quot;*&quot; or &quot;*m$&quot; (for some decimal
integer <i>m</i>) to specify that the field width is given
in the next argument, or in the <i>m</i>-th argument,
respectively, which must be of type <i>int</i>. A negative
field width is taken as a '-' flag followed by a positive
field width. In no case does a nonexistent or small field
width cause truncation of a field; if the result of a
conversion is wider than the field width, the field is
expanded to contain the conversion result.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precision</b>
<br>
An optional precision, in the form of a period ('.')
followed by an optional decimal digit string. Instead of a
decimal digit string one may write &quot;*&quot; or
&quot;*m$&quot; (for some decimal integer <i>m</i>) to
specify that the precision is given in the next argument, or
in the <i>m</i>-th argument, respectively, which must be of
type <i>int</i>. If the precision is given as just '.', the
precision is taken to be zero. A negative precision is taken
as if the precision were omitted. This gives the minimum
number of digits to appear for <b>d</b>, <b>i</b>, <b>o</b>,
<b>u</b>, <b>x</b>, and <b>X</b> conversions, the number of
digits to appear after the radix character for <b>a</b>,
<b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, and <b>F</b>
conversions, the maximum number of significant digits for
<b>g</b> and <b>G</b> conversions, or the maximum number of
characters to be printed from a string for <b>s</b> and
<b>S</b> conversions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Length
modifier</b> <br>
Here, &quot;integer conversion&quot; stands for <b>d</b>,
<b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b>
conversion.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>hh</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">A following integer conversion
corresponds to a <i>signed char</i> or <i>unsigned char</i>
argument, or a following <b>n</b> conversion corresponds to
a pointer to a <i>signed char</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>h</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to a
<i>short</i> or <i>unsigned short</i> argument, or a
following <b>n</b> conversion corresponds to a pointer to a
<i>short</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>l</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>(ell) A following integer conversion corresponds to a
<i>long</i> or <i>unsigned long</i> argument, or a following
<b>n</b> conversion corresponds to a pointer to a
<i>long</i> argument, or a following <b>c</b> conversion
corresponds to a <i>wint_t</i> argument, or a following
<b>s</b> conversion corresponds to a pointer to
<i>wchar_t</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>ll</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>(ell-ell). A following integer conversion corresponds to
a <i>long long</i> or <i>unsigned long long</i> argument, or
a following <b>n</b> conversion corresponds to a pointer to
a <i>long long</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>q</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A synonym for <b>ll</b>. This is a nonstandard
extension, derived from BSD; avoid its use in new code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>L</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>,
<b>f</b>, <b>F</b>, <b>g</b>, or <b>G</b> conversion
corresponds to a <i>long double</i> argument. (C99 allows
%LF, but SUSv2 does not.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>j</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to an
<i>intmax_t</i> or <i>uintmax_t</i> argument, or a following
<b>n</b> conversion corresponds to a pointer to an
<i>intmax_t</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>z</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to a
<i>size_t</i> or <i>ssize_t</i> argument, or a following
<b>n</b> conversion corresponds to a pointer to a
<i>size_t</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>Z</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A nonstandard synonym for <b>z</b> that predates the
appearance of <b>z</b>. Do not use in new code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>t</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to a
<i>ptrdiff_t</i> argument, or a following <b>n</b>
conversion corresponds to a pointer to a <i>ptrdiff_t</i>
argument.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">SUSv3 specifies
all of the above, except for those modifiers explicitly
noted as being nonstandard extensions. SUSv2 specified only
the length modifiers <b>h</b> (in <b>hd</b>, <b>hi</b>,
<b>ho</b>, <b>hx</b>, <b>hX</b>, <b>hn</b>) and <b>l</b> (in
<b>ld</b>, <b>li</b>, <b>lo</b>, <b>lx</b>, <b>lX</b>,
<b>ln</b>, <b>lc</b>, <b>ls</b>) and <b>L</b> (in <b>Le</b>,
<b>LE</b>, <b>Lf</b>, <b>Lg</b>, <b>LG</b>).</p>

<p style="margin-left:11%; margin-top: 1em">As a
nonstandard extension, the GNU implementations treats
<b>ll</b> and <b>L</b> as synonyms, so that one can, for
example, write <b>llg</b> (as a synonym for the
standards-compliant <b>Lg</b>) and <b>Ld</b> (as a synonym
for the standards compliant <b>lld</b>). Such usage is
nonportable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Conversion
specifiers</b> <br>
A character that specifies the type of conversion to be
applied. The conversion specifiers and their meanings
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>d</b>, <b>i</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">The <i>int</i> argument is
converted to signed decimal notation. The precision, if any,
gives the minimum number of digits that must appear; if the
converted value requires fewer digits, it is padded on the
left with zeros. The default precision is 1. When 0 is
printed with an explicit precision 0, the output is
empty.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>o</b>, <b>u</b>, <b>x</b>,
<b>X</b></p>

<p style="margin-left:22%;">The <i>unsigned int</i>
argument is converted to unsigned octal (<b>o</b>), unsigned
decimal (<b>u</b>), or unsigned hexadecimal (<b>x</b> and
<b>X</b>) notation. The letters <b>abcdef</b> are used for
<b>x</b> conversions; the letters <b>ABCDEF</b> are used for
<b>X</b> conversions. The precision, if any, gives the
minimum number of digits that must appear; if the converted
value requires fewer digits, it is padded on the left with
zeros. The default precision is 1. When 0 is printed with an
explicit precision 0, the output is empty.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>e</b>, <b>E</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>double</i> argument is rounded and converted in
the style [-]d<b>.</b>ddd<b>e</b>&plusmn;dd where there is
one digit (which is nonzero if the argument is nonzero)
before the decimal-point character and the number of digits
after it is equal to the precision; if the precision is
missing, it is taken as 6; if the precision is zero, no
decimal-point character appears. An <b>E</b> conversion uses
the letter <b>E</b> (rather than <b>e</b>) to introduce the
exponent. The exponent always contains at least two digits;
if the value is zero, the exponent is 00.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>f</b>, <b>F</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>double</i> argument is rounded and converted to
decimal notation in the style [-]ddd<b>.</b>ddd, where the
number of digits after the decimal-point character is equal
to the precision specification. If the precision is missing,
it is taken as 6; if the precision is explicitly zero, no
decimal-point character appears. If a decimal point appears,
at least one digit appears before it.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(SUSv2 does not
know about <b>F</b> and says that character string
representations for infinity and NaN may be made available.
SUSv3 adds a specification for <b>F</b>. The C99 standard
specifies &quot;[-]inf&quot; or &quot;[-]infinity&quot; for
infinity, and a string starting with &quot;nan&quot; for
NaN, in the case of <b>f</b> conversion, and
&quot;[-]INF&quot; or &quot;[-]INFINITY&quot; or
&quot;NAN&quot; in the case of <b>F</b> conversion.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>g</b>, <b>G</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">The <i>double</i> argument is
converted in style <b>f</b> or <b>e</b> (or <b>F</b> or
<b>E</b> for <b>G</b> conversions). The precision specifies
the number of significant digits. If the precision is
missing, 6 digits are given; if the precision is zero, it is
treated as 1. Style <b>e</b> is used if the exponent from
its conversion is less than -4 or greater than or equal to
the precision. Trailing zeros are removed from the
fractional part of the result; a decimal point appears only
if it is followed by at least one digit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>a</b>, <b>A</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>(C99; not in SUSv2, but added in SUSv3) For <b>a</b>
conversion, the <i>double</i> argument is converted to
hexadecimal notation (using the letters abcdef) in the style
[-]<b>0x</b>h<b>.</b>hhhh<b>p</b>&plusmn;d; for <b>A</b>
conversion the prefix <b>0X</b>, the letters ABCDEF, and the
exponent separator <b>P</b> is used. There is one
hexadecimal digit before the decimal point, and the number
of digits after it is equal to the precision. The default
precision suffices for an exact representation of the value
if an exact representation in base 2 exists and otherwise is
sufficiently large to distinguish values of type
<i>double</i>. The digit before the decimal point is
unspecified for nonnormalized numbers, and nonzero but
otherwise unspecified for normalized numbers. The exponent
always contains at least one digit; if the value is zero,
the exponent is 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>c</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>If no <b>l</b> modifier is present, the <i>int</i>
argument is converted to an <i>unsigned char</i>, and the
resulting character is written. If an <b>l</b> modifier is
present, the <i>wint_t</i> (wide character) argument is
converted to a multibyte sequence by a call to the
<a href="https://man.page/3/wcrtomb">wcrtomb(3)</a> function, with a conversion state starting
in the initial state, and the resulting multibyte string is
written.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>s</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>If no <b>l</b> modifier is present: the <i>const
char&nbsp;*</i> argument is expected to be a pointer to an
array of character type (pointer to a string). Characters
from the array are written up to (but not including) a
terminating null byte ('\0'); if a precision is specified,
no more than the number specified are written. If a
precision is given, no null byte need be present; if the
precision is not specified, or is greater than the size of
the array, the array must contain a terminating null
byte.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">If an <b>l</b>
modifier is present: the <i>const wchar_t&nbsp;*</i>
argument is expected to be a pointer to an array of wide
characters. Wide characters from the array are converted to
multibyte characters (each by a call to the
<a href="https://man.page/3/wcrtomb">wcrtomb(3)</a> function, with a conversion state starting
in the initial state before the first wide character), up to
and including a terminating null wide character. The
resulting multibyte characters are written up to (but not
including) the terminating null byte. If a precision is
specified, no more bytes than the number specified are
written, but no partial multibyte characters are written.
Note that the precision determines the number of
<i>bytes</i> written, not the number of <i>wide
characters</i> or <i>screen positions</i>. The array must
contain a terminating null wide character, unless a
precision is given and it is so small that the number of
bytes written exceeds it before the end of the array is
reached.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>C</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">(Not in C99 or C11, but in
SUSv2, SUSv3, and SUSv4.) Synonym for <b>lc</b>. Don&rsquo;t
use.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>S</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)
Synonym for <b>ls</b>. Don&rsquo;t use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>p</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>The <i>void&nbsp;*</i> pointer argument is printed in
hexadecimal (as if by <b>%#x</b> or <b>%#lx</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>n</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>The number of characters written so far is stored into
the integer pointed to by the corresponding argument. That
argument shall be an <i>int&nbsp;*</i>, or variant whose
size matches the (optionally) supplied integer length
modifier. No argument is converted. (This specifier is not
supported by the bionic C library.) The behavior is
undefined if the conversion specification includes any
flags, a field width, or a precision.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>m</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>(Glibc extension; supported by uClibc and musl.) Print
output of <i>strerror(errno)</i>. No argument is
required.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>%</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>A '%' is written. No argument is converted. The complete
conversion specification is '%%'.</p></td></tr>
</table>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Upon successful
return, these functions return the number of characters
printed (excluding the null byte used to end output to
strings).</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>snprintf</b>() and <b>vsnprintf</b>() do not write more
than <i>size</i> bytes (including the terminating null byte
('\0')). If the output was truncated due to this limit, then
the return value is the number of characters (excluding the
terminating null byte) which would have been written to the
final string if enough space had been available. Thus, a
return value of <i>size</i> or more means that the output
was truncated. (See also below under NOTES.)</p>

<p style="margin-left:11%; margin-top: 1em">If an output
error is encountered, a negative value is returned.</p>

<h2>ATTRIBUTES
<a name="ATTRIBUTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For an
explanation of the terms used in this section, see
<a href="https://man.page/7/attributes">attributes(7)</a>.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3345961.png" alt="Image grohtml-3345961.png"></p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>fprintf</b>(),
<b>printf</b>(), <b>sprintf</b>(), <b>vprintf</b>(),
<b>vfprintf</b>(), <b>vsprintf</b>(): POSIX.1-2001,
POSIX.1-2008, C89, C99.</p>


<p style="margin-left:11%; margin-top: 1em"><b>snprintf</b>(),
<b>vsnprintf</b>(): POSIX.1-2001, POSIX.1-2008, C99.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>dprintf</b>() and <b>vdprintf</b>() functions were
originally GNU extensions that were later standardized in
POSIX.1-2008.</p>

<p style="margin-left:11%; margin-top: 1em">Concerning the
return value of <b>snprintf</b>(), SUSv2 and C99 contradict
each other: when <b>snprintf</b>() is called with
<i>size</i>=0 then SUSv2 stipulates an unspecified return
value less than 1, while C99 allows <i>str</i> to be NULL in
this case, and gives the return value (as always) as the
number of characters that would have been written in case
the output string has been large enough. POSIX.1-2001 and
later align their specification of <b>snprintf</b>() with
C99.</p>

<p style="margin-left:11%; margin-top: 1em">glibc 2.1 adds
length modifiers <b>hh</b>, <b>j</b>, <b>t</b>, and <b>z</b>
and conversion characters <b>a</b> and <b>A</b>.</p>

<p style="margin-left:11%; margin-top: 1em">glibc 2.2 adds
the conversion character <b>F</b> with C99 semantics, and
the flag character <b>I</b>.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Some programs
imprudently rely on code such as the following</p>

<p style="margin-left:11%; margin-top: 1em">sprintf(buf,
&quot;%s some further text&quot;, buf);</p>

<p style="margin-left:11%; margin-top: 1em">to append text
to <i>buf</i>. However, the standards explicitly note that
the results are undefined if source and destination buffers
overlap when calling <b>sprintf</b>(), <b>snprintf</b>(),
<b>vsprintf</b>(), and <b>vsnprintf</b>(). Depending on the
version of <a href="https://man.page/1/gcc">gcc(1)</a> used, and the compiler options
employed, calls such as the above will <b>not</b> produce
the expected results.</p>

<p style="margin-left:11%; margin-top: 1em">The glibc
implementation of the functions <b>snprintf</b>() and
<b>vsnprintf</b>() conforms to the C99 standard, that is,
behaves as described above, since glibc version 2.1. Until
glibc 2.0.6, they would return -1 when the output was
truncated.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Because
<b>sprintf</b>() and <b>vsprintf</b>() assume an arbitrarily
long string, callers must be careful not to overflow the
actual space; this is often impossible to assure. Note that
the length of the strings produced is locale-dependent and
difficult to predict. Use <b>snprintf</b>() and
<b>vsnprintf</b>() instead (or <a href="https://man.page/3/asprintf">asprintf(3)</a> and
<a href="https://man.page/3/vasprintf">vasprintf(3)</a>).</p>

<p style="margin-left:11%; margin-top: 1em">Code such as
<b>printf(</b><i>foo</i><b>);</b> often indicates a bug,
since <i>foo</i> may contain a % character. If <i>foo</i>
comes from untrusted user input, it may contain <b>%n</b>,
causing the <b>printf</b>() call to write to memory and
creating a security hole.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To print
<i>Pi</i> to five decimal places:</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;math.h&gt; <br>
#include &lt;stdio.h&gt; <br>
fprintf(stdout, &quot;pi = %.5f\n&quot;, 4 * atan(1.0));</p>

<p style="margin-left:11%; margin-top: 1em">To print a date
and time in the form &quot;Sunday, July 3, 10:02&quot;,
where <i>weekday</i> and <i>month</i> are pointers to
strings:</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
fprintf(stdout, &quot;%s, %s %d, %.2d:%.2d\n&quot;, <br>
weekday, month, day, hour, min);</p>

<p style="margin-left:11%; margin-top: 1em">Many countries
use the day-month-year order. Hence, an internationalized
version must be able to print the arguments in an order
specified by the format:</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
fprintf(stdout, format, <br>
weekday, month, day, hour, min);</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>format</i> depends on locale, and may permute the
arguments. With the value:</p>

<p style="margin-left:17%; margin-top: 1em">&quot;%1$s,
%3$d. %2$s, %4$d:%5$.2d\n&quot;</p>

<p style="margin-left:11%; margin-top: 1em">one might
obtain &quot;Sonntag, 3. Juli, 10:02&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To allocate a
sufficiently large string and print into it (code correct
for both glibc 2.0 and glibc 2.1):</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;stdarg.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">char * <br>
make_message(const char *fmt, ...) <br>
{ <br>
int n = 0; <br>
size_t size = 0; <br>
char *p = NULL; <br>
va_list ap;</p>

<p style="margin-left:11%; margin-top: 1em">/* Determine
required size */</p>

<p style="margin-left:11%; margin-top: 1em">va_start(ap,
fmt); <br>
n = vsnprintf(p, size, fmt, ap); <br>
va_end(ap);</p>

<p style="margin-left:11%; margin-top: 1em">if (n &lt; 0)
<br>
return NULL;</p>

<p style="margin-left:11%; margin-top: 1em">/* One extra
byte for '\0' */</p>

<p style="margin-left:11%; margin-top: 1em">size = (size_t)
n + 1; <br>
p = malloc(size); <br>
if (p == NULL) <br>
return NULL;</p>

<p style="margin-left:11%; margin-top: 1em">va_start(ap,
fmt); <br>
n = vsnprintf(p, size, fmt, ap); <br>
va_end(ap);</p>

<p style="margin-left:11%; margin-top: 1em">if (n &lt; 0) {
<br>
free(p); <br>
return NULL; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">return p; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If truncation
occurs in glibc versions prior to 2.0.6, this is treated as
an error instead of being handled gracefully.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/1/printf">printf(1)</a>,
<a href="https://man.page/3/asprintf">asprintf(3)</a>, <a href="https://man.page/3/puts">puts(3)</a>, <a href="https://man.page/3/scanf">scanf(3)</a>,
<a href="https://man.page/3/setlocale">setlocale(3)</a>, <a href="https://man.page/3/strfromd">strfromd(3)</a>, <a href="https://man.page/3/wcrtomb">wcrtomb(3)</a>,
<a href="https://man.page/3/wprintf">wprintf(3)</a>, <a href="https://man.page/5/locale">locale(5)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
