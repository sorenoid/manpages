<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:01 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CLONE</title>

</head>
<body>

<h1 align="center">CLONE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">clone,
__clone2, clone3 - create a child process</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">/* Prototype
for the glibc wrapper function */</p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
_GNU_SOURCE <br>
#include &lt;sched.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
clone(int (*</b><i>fn</i><b>)(void *), void
*</b><i>stack</i><b>, int</b> <i>flags</i><b>, void
*</b><i>arg</i><b>, ... <br>
/* pid_t *</b><i>parent_tid</i><b>, void *</b><i>tls</i><b>,
pid_t *</b><i>child_tid</i> <b>*/ );</b></p>

<p style="margin-left:11%; margin-top: 1em">/* For the
prototype of the raw clone() system call, see NOTES */</p>

<p style="margin-left:11%; margin-top: 1em"><b>long
clone3(struct clone_args *</b><i>cl_args</i><b>, size_t</b>
<i>size</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>Note</i>:
There is not yet a glibc wrapper for <b>clone3</b>(); see
NOTES.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These system
calls create a new (&quot;child&quot;) process, in a manner
similar to <a href="https://man.page/2/fork">fork(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">By contrast
with <a href="https://man.page/2/fork">fork(2)</a>, these system calls provide more precise
control over what pieces of execution context are shared
between the calling process and the child process. For
example, using these system calls, the caller can control
whether or not the two processes share the virtual address
space, the table of file descriptors, and the table of
signal handlers. These system calls also allow the new child
process to be placed in separate <a href="https://man.page/7/namespaces">namespaces(7)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
this manual page, &quot;calling process&quot; normally
corresponds to &quot;parent process&quot;. But see the
descriptions of <b>CLONE_PARENT</b> and <b>CLONE_THREAD</b>
below.</p>

<p style="margin-left:11%; margin-top: 1em">This page
describes the following interfaces:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The glibc <b>clone</b>() wrapper function and the
underlying system call on which it is based. The main text
describes the wrapper function; the differences for the raw
system call are described toward the end of this page.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The newer <b>clone3</b>() system call.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In the
remainder of this page, the terminology &quot;the clone
call&quot; is used when noting details that apply to all of
these interfaces,</p>

<p style="margin-left:11%; margin-top: 1em"><b>The clone()
wrapper function</b> <br>
When the child process is created with the <b>clone</b>()
wrapper function, it commences execution by calling the
function pointed to by the argument <i>fn</i>. (This differs
from <a href="https://man.page/2/fork">fork(2)</a>, where execution continues in the child
from the point of the <a href="https://man.page/2/fork">fork(2)</a> call.) The <i>arg</i>
argument is passed as the argument of the function
<i>fn</i>.</p>

<p style="margin-left:11%; margin-top: 1em">When the
<i>fn</i>(<i>arg</i>) function returns, the child process
terminates. The integer returned by <i>fn</i> is the exit
status for the child process. The child process may also
terminate explicitly by calling <a href="https://man.page/2/exit">exit(2)</a> or after
receiving a fatal signal.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>stack</i> argument specifies the location of the stack
used by the child process. Since the child and calling
process may share memory, it is not possible for the child
process to execute in the same stack as the calling process.
The calling process must therefore set up memory space for
the child stack and pass a pointer to this space to
<b>clone</b>(). Stacks grow downward on all processors that
run Linux (except the HP PA processors), so <i>stack</i>
usually points to the topmost address of the memory space
set up for the child stack. Note that <b>clone</b>() does
not provide a means whereby the caller can inform the kernel
of the size of the stack area.</p>

<p style="margin-left:11%; margin-top: 1em">The remaining
arguments to <b>clone</b>() are discussed below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clone3()</b>
<br>
The <b>clone3</b>() system call provides a superset of the
functionality of the older <b>clone</b>() interface. It also
provides a number of API improvements, including: space for
additional flags bits; cleaner separation in the use of
various arguments; and the ability to specify the size of
the child&rsquo;s stack area.</p>

<p style="margin-left:11%; margin-top: 1em">As with
<a href="https://man.page/2/fork">fork(2)</a>, <b>clone3</b>() returns in both the parent
and the child. It returns 0 in the child process and returns
the PID of the child in the parent.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>cl_args</i> argument of <b>clone3</b>() is a structure of
the following form:</p>

<p style="margin-left:17%; margin-top: 1em">struct
clone_args { <br>
u64 flags; /* Flags bit mask */ <br>
u64 pidfd; /* Where to store PID file descriptor <br>
(<i>pid_t *</i>) */ <br>
u64 child_tid; /* Where to store child TID, <br>
in child's memory (<i>pid_t *</i>) */ <br>
u64 parent_tid; /* Where to store child TID, <br>
in parent's memory (<i>int *</i>) */ <br>
u64 exit_signal; /* Signal to deliver to parent on <br>
child termination */ <br>
u64 stack; /* Pointer to lowest byte of stack */ <br>
u64 stack_size; /* Size of stack */ <br>
u64 tls; /* Location of new TLS */ <br>
u64 set_tid; /* Pointer to a <i>pid_t</i> array <br>
(since Linux 5.5) */ <br>
u64 set_tid_size; /* Number of elements in <i>set_tid</i>
<br>
(since Linux 5.5) */ <br>
u64 cgroup; /* File descriptor for target cgroup <br>
of child (since Linux 5.7) */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The <i>size</i>
argument that is supplied to <b>clone3</b>() should be
initialized to the size of this structure. (The existence of
the <i>size</i> argument permits future extensions to the
<i>clone_args</i> structure.)</p>

<p style="margin-left:11%; margin-top: 1em">The stack for
the child process is specified via <i>cl_args.stack</i>,
which points to the lowest byte of the stack area, and
<i>cl_args.stack_size</i>, which specifies the size of the
stack in bytes. In the case where the <b>CLONE_VM</b> flag
(see below) is specified, a stack must be explicitly
allocated and specified. Otherwise, these two fields can be
specified as NULL and 0, which causes the child to use the
same stack area as the parent (in the child&rsquo;s own
virtual address space).</p>

<p style="margin-left:11%; margin-top: 1em">The remaining
fields in the <i>cl_args</i> argument are discussed
below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Equivalence
between clone() and clone3() arguments</b> <br>
Unlike the older <b>clone</b>() interface, where arguments
are passed individually, in the newer <b>clone3</b>()
interface the arguments are packaged into the
<i>clone_args</i> structure shown above. This structure
allows for a superset of the information passed via the
<b>clone</b>() arguments.</p>

<p style="margin-left:11%; margin-top: 1em">The following
table shows the equivalence between the arguments of
<b>clone</b>() and the fields in the <i>clone_args</i>
argument supplied to <b>clone3</b>():</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3253871.png" alt="Image grohtml-3253871.png"></p>

<p style="margin-left:11%; margin-top: 1em"><b>The child
termination signal</b> <br>
When the child process terminates, a signal may be sent to
the parent. The termination signal is specified in the low
byte of <i>flags</i> (<b>clone</b>()) or in
<i>cl_args.exit_signal</i> (<b>clone3</b>()). If this signal
is specified as anything other than <b>SIGCHLD</b>, then the
parent process must specify the <b>__WALL</b> or
<b>__WCLONE</b> options when waiting for the child with
<a href="https://man.page/2/wait">wait(2)</a>. If no signal (i.e., zero) is specified, then
the parent process is not signaled when the child
terminates.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The set_tid
array</b> <br>
By default, the kernel chooses the next sequential PID for
the new process in each of the PID namespaces where it is
present. When creating a process with <b>clone3</b>(), the
<i>set_tid</i> array (available since Linux 5.5) can be used
to select specific PIDs for the process in some or all of
the PID namespaces where it is present. If the PID of the
newly created process should be set only for the current PID
namespace or in the newly created PID namespace (if
<i>flags</i> contains <b>CLONE_NEWPID</b>) then the first
element in the <i>set_tid</i> array has to be the desired
PID and <i>set_tid_size</i> needs to be 1.</p>

<p style="margin-left:11%; margin-top: 1em">If the PID of
the newly created process should have a certain value in
multiple PID namespaces, then the <i>set_tid</i> array can
have multiple entries. The first entry defines the PID in
the most deeply nested PID namespace and each of the
following entries contains the PID in the corresponding
ancestor PID namespace. The number of PID namespaces in
which a PID should be set is defined by <i>set_tid_size</i>
which cannot be larger than the number of currently nested
PID namespaces.</p>

<p style="margin-left:11%; margin-top: 1em">To create a
process with the following PIDs in a PID namespace
hierarchy:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3253872.png" alt="Image grohtml-3253872.png"></p>

<p style="margin-left:11%; margin-top: 1em">Set the array
to:</p>

<p style="margin-left:17%; margin-top: 1em">set_tid[0] = 7;
<br>
set_tid[1] = 42; <br>
set_tid[2] = 31496; <br>
set_tid_size = 3;</p>

<p style="margin-left:11%; margin-top: 1em">If only the
PIDs in the two innermost PID namespaces need to be
specified, set the array to:</p>

<p style="margin-left:17%; margin-top: 1em">set_tid[0] = 7;
<br>
set_tid[1] = 42; <br>
set_tid_size = 2;</p>

<p style="margin-left:11%; margin-top: 1em">The PID in the
PID namespaces outside the two innermost PID namespaces will
be selected the same way as any other PID is selected.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>set_tid</i> feature requires <b>CAP_SYS_ADMIN</b> or
(since Linux 5.9) <b>CAP_CHECKPOINT_RESTORE</b> in all
owning user namespaces of the target PID namespaces.</p>

<p style="margin-left:11%; margin-top: 1em">Callers may
only choose a PID greater than 1 in a given PID namespace if
an <b>init</b> process (i.e., a process with PID 1) already
exists in that namespace. Otherwise the PID entry for this
PID namespace must be 1.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The flags
mask</b> <br>
Both <b>clone</b>() and <b>clone3</b>() allow a flags bit
mask that modifies their behavior and allows the caller to
specify what is shared between the calling process and the
child process. This bit mask&mdash;the <i>flags</i> argument
of <b>clone</b>() or the <i>cl_args.flags</i> field passed
to <b>clone3</b>()&mdash;is referred to as the <i>flags</i>
mask in the remainder of this page.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> mask is specified as a bitwise-OR of zero or
more of the constants listed below. Except as noted below,
these flags are available (and have the same effect) in both
<b>clone</b>() and <b>clone3</b>(). <b><br>
CLONE_CHILD_CLEARTID</b> (since Linux 2.5.49)</p>

<p style="margin-left:22%;">Clear (zero) the child thread
ID at the location pointed to by <i>child_tid</i>
(<b>clone</b>()) or <i>cl_args.child_tid</i>
(<b>clone3</b>()) in child memory when the child exits, and
do a wakeup on the futex at that address. The address
involved may be changed by the <a href="https://man.page/2/set_tid_address">set_tid_address(2)</a>
system call. This is used by threading libraries.</p>

<p style="margin-left:11%;"><b>CLONE_CHILD_SETTID</b>
(since Linux 2.5.49)</p>

<p style="margin-left:22%;">Store the child thread ID at
the location pointed to by <i>child_tid</i> (<b>clone</b>())
or <i>cl_args.child_tid</i> (<b>clone3</b>()) in the
child&rsquo;s memory. The store operation completes before
the clone call returns control to user space in the child
process. (Note that the store operation may not have
completed before the clone call returns in the parent
process, which will be relevant if the <b>CLONE_VM</b> flag
is also employed.)</p>

<p style="margin-left:11%;"><b>CLONE_CLEAR_SIGHAND</b>
(since Linux 5.5)</p>

<p style="margin-left:22%;">By default, signal dispositions
in the child thread are the same as in the parent. If this
flag is specified, then all signals that are handled in the
parent are reset to their default dispositions
(<b>SIG_DFL</b>) in the child.</p>

<p style="margin-left:22%; margin-top: 1em">Specifying this
flag together with <b>CLONE_SIGHAND</b> is nonsensical and
disallowed.</p>

<p style="margin-left:11%;"><b>CLONE_DETACHED</b>
(historical)</p>

<p style="margin-left:22%;">For a while (during the Linux
2.5 development series) there was a <b>CLONE_DETACHED</b>
flag, which caused the parent not to receive a signal when
the child terminated. Ultimately, the effect of this flag
was subsumed under the <b>CLONE_THREAD</b> flag and by the
time Linux 2.6.0 was released, this flag had no effect.
Starting in Linux 2.6.2, the need to give this flag together
with <b>CLONE_THREAD</b> disappeared.</p>

<p style="margin-left:22%; margin-top: 1em">This flag is
still defined, but it is usually ignored when calling
<b>clone</b>(). However, see the description of
<b>CLONE_PIDFD</b> for some exceptions.</p>

<p style="margin-left:11%;"><b>CLONE_FILES</b> (since Linux
2.0)</p>

<p style="margin-left:22%;">If <b>CLONE_FILES</b> is set,
the calling process and the child process share the same
file descriptor table. Any file descriptor created by the
calling process or by the child process is also valid in the
other process. Similarly, if one of the processes closes a
file descriptor, or changes its associated flags (using the
<a href="https://man.page/2/fcntl">fcntl(2)</a> <b>F_SETFD</b> operation), the other process
is also affected. If a process sharing a file descriptor
table calls <a href="https://man.page/2/execve">execve(2)</a>, its file descriptor table is
duplicated (unshared).</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_FILES</b> is not set, the child process inherits a
copy of all file descriptors opened in the calling process
at the time of the clone call. Subsequent operations that
open or close file descriptors, or change file descriptor
flags, performed by either the calling process or the child
process do not affect the other process. Note, however, that
the duplicated file descriptors in the child refer to the
same open file descriptions as the corresponding file
descriptors in the calling process, and thus share file
offsets and file status flags (see <a href="https://man.page/2/open">open(2)</a>).</p>

<p style="margin-left:11%;"><b>CLONE_FS</b> (since Linux
2.0)</p>

<p style="margin-left:22%;">If <b>CLONE_FS</b> is set, the
caller and the child process share the same filesystem
information. This includes the root of the filesystem, the
current working directory, and the umask. Any call to
<a href="https://man.page/2/chroot">chroot(2)</a>, <a href="https://man.page/2/chdir">chdir(2)</a>, or <a href="https://man.page/2/umask">umask(2)</a>
performed by the calling process or the child process also
affects the other process.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_FS</b> is not set, the child process works on a
copy of the filesystem information of the calling process at
the time of the clone call. Calls to <a href="https://man.page/2/chroot">chroot(2)</a>,
<a href="https://man.page/2/chdir">chdir(2)</a>, or <a href="https://man.page/2/umask">umask(2)</a> performed later by one
of the processes do not affect the other process.</p>

<p style="margin-left:11%;"><b>CLONE_INTO_CGROUP</b> (since
Linux 5.7)</p>

<p style="margin-left:22%;">By default, a child process is
placed in the same version 2 cgroup as its parent. The
<b>CLONE_INTO_CGROUP</b> flag allows the child process to be
created in a different version 2 cgroup. (Note that
<b>CLONE_INTO_CGROUP</b> has effect only for version 2
cgroups.)</p>

<p style="margin-left:22%; margin-top: 1em">In order to
place the child process in a different cgroup, the caller
specifies <b>CLONE_INTO_CGROUP</b> in <i>cl_args.flags</i>
and passes a file descriptor that refers to a version 2
cgroup in the <i>cl_args.cgroup</i> field. (This file
descriptor can be obtained by opening a cgroup v2 directory
using either the <b>O_RDONLY</b> or the <b>O_PATH</b> flag.)
Note that all of the usual restrictions (described in
<a href="https://man.page/7/cgroups">cgroups(7)</a>) on placing a process into a version 2
cgroup apply.</p>

<p style="margin-left:22%; margin-top: 1em">Among the
possible use cases for <b>CLONE_INTO_CGROUP</b> are the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Spawning a process into a cgroup different from the
parent&rsquo;s cgroup makes it possible for a service
manager to directly spawn new services into dedicated
cgroups. This eliminates the accounting jitter that would be
caused if the child process was first created in the same
cgroup as the parent and then moved into the target cgroup.
Furthermore, spawning the child process directly into a
target cgroup is significantly cheaper than moving the child
process into the target cgroup after it has been
created.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>The <b>CLONE_INTO_CGROUP</b> flag also allows the
creation of frozen child processes by spawning them into a
frozen cgroup. (See <a href="https://man.page/7/cgroups">cgroups(7)</a> for a description of
the freezer controller.)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>For threaded applications (or even thread
implementations which make use of cgroups to limit
individual threads), it is possible to establish a fixed
cgroup layout before spawning each thread directly into its
target cgroup.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CLONE_IO</b> (since Linux
2.6.25)</p>

<p style="margin-left:22%;">If <b>CLONE_IO</b> is set, then
the new process shares an I/O context with the calling
process. If this flag is not set, then (as with
<a href="https://man.page/2/fork">fork(2)</a>) the new process has its own I/O context.</p>

<p style="margin-left:22%; margin-top: 1em">The I/O context
is the I/O scope of the disk scheduler (i.e., what the I/O
scheduler uses to model scheduling of a process&rsquo;s
I/O). If processes share the same I/O context, they are
treated as one by the I/O scheduler. As a consequence, they
get to share disk time. For some I/O schedulers, if two
processes share an I/O context, they will be allowed to
interleave their disk access. If several threads are doing
I/O on behalf of the same process (<a href="https://man.page/3/aio_read">aio_read(3)</a>, for
instance), they should employ <b>CLONE_IO</b> to get better
I/O performance.</p>

<p style="margin-left:22%; margin-top: 1em">If the kernel
is not configured with the <b>CONFIG_BLOCK</b> option, this
flag is a no-op.</p>

<p style="margin-left:11%;"><b>CLONE_NEWCGROUP</b> (since
Linux 4.6)</p>

<p style="margin-left:22%;">Create the process in a new
cgroup namespace. If this flag is not set, then (as with
<a href="https://man.page/2/fork">fork(2)</a>) the process is created in the same cgroup
namespaces as the calling process.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on cgroup namespaces, see
<a href="https://man.page/7/cgroup_namespaces">cgroup_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Only a
privileged process (<b>CAP_SYS_ADMIN</b>) can employ
<b>CLONE_NEWCGROUP</b>.</p>

<p style="margin-left:11%;"><b>CLONE_NEWIPC</b> (since
Linux 2.6.19)</p>

<p style="margin-left:22%;">If <b>CLONE_NEWIPC</b> is set,
then create the process in a new IPC namespace. If this flag
is not set, then (as with <a href="https://man.page/2/fork">fork(2)</a>), the process is
created in the same IPC namespace as the calling
process.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on IPC namespaces, see
<a href="https://man.page/7/ipc_namespaces">ipc_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Only a
privileged process (<b>CAP_SYS_ADMIN</b>) can employ
<b>CLONE_NEWIPC</b>. This flag can&rsquo;t be specified in
conjunction with <b>CLONE_SYSVSEM</b>.</p>

<p style="margin-left:11%;"><b>CLONE_NEWNET</b> (since
Linux 2.6.24)</p>

<p style="margin-left:22%;">(The implementation of this
flag was completed only by about kernel version 2.6.29.)</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_NEWNET</b> is set, then create the process in a new
network namespace. If this flag is not set, then (as with
<a href="https://man.page/2/fork">fork(2)</a>) the process is created in the same network
namespace as the calling process.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on network namespaces, see
<a href="https://man.page/7/network_namespaces">network_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Only a
privileged process (<b>CAP_SYS_ADMIN</b>) can employ
<b>CLONE_NEWNET</b>.</p>

<p style="margin-left:11%;"><b>CLONE_NEWNS</b> (since Linux
2.4.19)</p>

<p style="margin-left:22%;">If <b>CLONE_NEWNS</b> is set,
the cloned child is started in a new mount namespace,
initialized with a copy of the namespace of the parent. If
<b>CLONE_NEWNS</b> is not set, the child lives in the same
mount namespace as the parent.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on mount namespaces, see <a href="https://man.page/7/namespaces">namespaces(7)</a>
and <a href="https://man.page/7/mount_namespaces">mount_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Only a
privileged process (<b>CAP_SYS_ADMIN</b>) can employ
<b>CLONE_NEWNS</b>. It is not permitted to specify both
<b>CLONE_NEWNS</b> and <b>CLONE_FS</b> in the same clone
call.</p>

<p style="margin-left:11%;"><b>CLONE_NEWPID</b> (since
Linux 2.6.24)</p>

<p style="margin-left:22%;">If <b>CLONE_NEWPID</b> is set,
then create the process in a new PID namespace. If this flag
is not set, then (as with <a href="https://man.page/2/fork">fork(2)</a>) the process is
created in the same PID namespace as the calling
process.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on PID namespaces, see <a href="https://man.page/7/namespaces">namespaces(7)</a> and
<a href="https://man.page/7/pid_namespaces">pid_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Only a
privileged process (<b>CAP_SYS_ADMIN</b>) can employ
<b>CLONE_NEWPID</b>. This flag can&rsquo;t be specified in
conjunction with <b>CLONE_THREAD</b> or
<b>CLONE_PARENT</b>.</p>

<p style="margin-left:11%;"><b>CLONE_NEWUSER</b></p>

<p style="margin-left:22%;">(This flag first became
meaningful for <b>clone</b>() in Linux 2.6.23, the current
<b>clone</b>() semantics were merged in Linux 3.5, and the
final pieces to make the user namespaces completely usable
were merged in Linux 3.8.)</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_NEWUSER</b> is set, then create the process in a
new user namespace. If this flag is not set, then (as with
<a href="https://man.page/2/fork">fork(2)</a>) the process is created in the same user
namespace as the calling process.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on user namespaces, see <a href="https://man.page/7/namespaces">namespaces(7)</a> and
<a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Before Linux
3.8, use of <b>CLONE_NEWUSER</b> required that the caller
have three capabilities: <b>CAP_SYS_ADMIN</b>,
<b>CAP_SETUID</b>, and <b>CAP_SETGID</b>. Starting with
Linux 3.8, no privileges are needed to create a user
namespace.</p>

<p style="margin-left:22%; margin-top: 1em">This flag
can&rsquo;t be specified in conjunction with
<b>CLONE_THREAD</b> or <b>CLONE_PARENT</b>. For security
reasons, <b>CLONE_NEWUSER</b> cannot be specified in
conjunction with <b>CLONE_FS</b>.</p>

<p style="margin-left:11%;"><b>CLONE_NEWUTS</b> (since
Linux 2.6.19)</p>

<p style="margin-left:22%;">If <b>CLONE_NEWUTS</b> is set,
then create the process in a new UTS namespace, whose
identifiers are initialized by duplicating the identifiers
from the UTS namespace of the calling process. If this flag
is not set, then (as with <a href="https://man.page/2/fork">fork(2)</a>) the process is
created in the same UTS namespace as the calling
process.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on UTS namespaces, see
<a href="https://man.page/7/uts_namespaces">uts_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Only a
privileged process (<b>CAP_SYS_ADMIN</b>) can employ
<b>CLONE_NEWUTS</b>.</p>

<p style="margin-left:11%;"><b>CLONE_PARENT</b> (since
Linux 2.3.12)</p>

<p style="margin-left:22%;">If <b>CLONE_PARENT</b> is set,
then the parent of the new child (as returned by
<a href="https://man.page/2/getppid">getppid(2)</a>) will be the same as that of the calling
process.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_PARENT</b> is not set, then (as with
<a href="https://man.page/2/fork">fork(2)</a>) the child&rsquo;s parent is the calling
process.</p>

<p style="margin-left:22%; margin-top: 1em">Note that it is
the parent process, as returned by <a href="https://man.page/2/getppid">getppid(2)</a>, which
is signaled when the child terminates, so that if
<b>CLONE_PARENT</b> is set, then the parent of the calling
process, rather than the calling process itself, will be
signaled.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>CLONE_PARENT</b> flag can&rsquo;t be used in clone calls
by the global init process (PID 1 in the initial PID
namespace) and init processes in other PID namespaces. This
restriction prevents the creation of multi-rooted process
trees as well as the creation of unreapable zombies in the
initial PID namespace.</p>

<p style="margin-left:11%;"><b>CLONE_PARENT_SETTID</b>
(since Linux 2.5.49)</p>

<p style="margin-left:22%;">Store the child thread ID at
the location pointed to by <i>parent_tid</i>
(<b>clone</b>()) or <i>cl_args.parent_tid</i>
(<b>clone3</b>()) in the parent&rsquo;s memory. (In Linux
2.5.32-2.5.48 there was a flag <b>CLONE_SETTID</b> that did
this.) The store operation completes before the clone call
returns control to user space.</p>

<p style="margin-left:11%;"><b>CLONE_PID</b> (Linux 2.0 to
2.5.15)</p>

<p style="margin-left:22%;">If <b>CLONE_PID</b> is set, the
child process is created with the same process ID as the
calling process. This is good for hacking the system, but
otherwise of not much use. From Linux 2.3.21 onward, this
flag could be specified only by the system boot process (PID
0). The flag disappeared completely from the kernel sources
in Linux 2.5.16. Subsequently, the kernel silently ignored
this bit if it was specified in the <i>flags</i> mask. Much
later, the same bit was recycled for use as the
<b>CLONE_PIDFD</b> flag.</p>

<p style="margin-left:11%;"><b>CLONE_PIDFD</b> (since Linux
5.2)</p>

<p style="margin-left:22%;">If this flag is specified, a
PID file descriptor referring to the child process is
allocated and placed at a specified location in the
parent&rsquo;s memory. The close-on-exec flag is set on this
new file descriptor. PID file descriptors can be used for
the purposes described in <a href="https://man.page/2/pidfd_open">pidfd_open(2)</a>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>When using <b>clone3</b>(), the PID file descriptor is
placed at the location pointed to by
<i>cl_args.pidfd</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>When using <b>clone</b>(), the PID file descriptor is
placed at the location pointed to by <i>parent_tid</i>.
Since the <i>parent_tid</i> argument is used to return the
PID file descriptor, <b>CLONE_PIDFD</b> cannot be used with
<b>CLONE_PARENT_SETTID</b> when calling <b>clone</b>().</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">It is currently
not possible to use this flag together with
<b>CLONE_THREAD.</b> This means that the process identified
by the PID file descriptor will always be a thread group
leader.</p>

<p style="margin-left:22%; margin-top: 1em">If the obsolete
<b>CLONE_DETACHED</b> flag is specified alongside
<b>CLONE_PIDFD</b> when calling <b>clone</b>(), an error is
returned. An error also results if <b>CLONE_DETACHED</b> is
specified when calling <b>clone3</b>(). This error behavior
ensures that the bit corresponding to <b>CLONE_DETACHED</b>
can be reused for further PID file descriptor features in
the future.</p>

<p style="margin-left:11%;"><b>CLONE_PTRACE</b> (since
Linux 2.2)</p>

<p style="margin-left:22%;">If <b>CLONE_PTRACE</b> is
specified, and the calling process is being traced, then
trace the child also (see <a href="https://man.page/2/ptrace">ptrace(2)</a>).</p>

<p style="margin-left:11%;"><b>CLONE_SETTLS</b> (since
Linux 2.5.32)</p>

<p style="margin-left:22%;">The TLS (Thread Local Storage)
descriptor is set to <i>tls</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The
interpretation of <i>tls</i> and the resulting effect is
architecture dependent. On x86, <i>tls</i> is interpreted as
a <i>struct user_desc&nbsp;*</i> (see
<a href="https://man.page/2/set_thread_area">set_thread_area(2)</a>). On x86-64 it is the new value to
be set for the %fs base register (see the <b>ARCH_SET_FS</b>
argument to <a href="https://man.page/2/arch_prctl">arch_prctl(2)</a>). On architectures with a
dedicated TLS register, it is the new value of that
register.</p>

<p style="margin-left:22%; margin-top: 1em">Use of this
flag requires detailed knowledge and generally it should not
be used except in libraries implementing threading.</p>

<p style="margin-left:11%;"><b>CLONE_SIGHAND</b> (since
Linux 2.0)</p>

<p style="margin-left:22%;">If <b>CLONE_SIGHAND</b> is set,
the calling process and the child process share the same
table of signal handlers. If the calling process or child
process calls <a href="https://man.page/2/sigaction">sigaction(2)</a> to change the behavior
associated with a signal, the behavior is changed in the
other process as well. However, the calling process and
child processes still have distinct signal masks and sets of
pending signals. So, one of them may block or unblock
signals using <a href="https://man.page/2/sigprocmask">sigprocmask(2)</a> without affecting the
other process.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_SIGHAND</b> is not set, the child process inherits
a copy of the signal handlers of the calling process at the
time of the clone call. Calls to <a href="https://man.page/2/sigaction">sigaction(2)</a>
performed later by one of the processes have no effect on
the other process.</p>

<p style="margin-left:22%; margin-top: 1em">Since Linux
2.6.0, the <i>flags</i> mask must also include
<b>CLONE_VM</b> if <b>CLONE_SIGHAND</b> is specified</p>

<p style="margin-left:11%;"><b>CLONE_STOPPED</b> (since
Linux 2.6.0)</p>

<p style="margin-left:22%;">If <b>CLONE_STOPPED</b> is set,
then the child is initially stopped (as though it was sent a
<b>SIGSTOP</b> signal), and must be resumed by sending it a
<b>SIGCONT</b> signal.</p>

<p style="margin-left:22%; margin-top: 1em">This flag was
<i>deprecated</i> from Linux 2.6.25 onward, and was
<i>removed</i> altogether in Linux 2.6.38. Since then, the
kernel silently ignores it without error. Starting with
Linux 4.6, the same bit was reused for the
<b>CLONE_NEWCGROUP</b> flag.</p>

<p style="margin-left:11%;"><b>CLONE_SYSVSEM</b> (since
Linux 2.5.10)</p>

<p style="margin-left:22%;">If <b>CLONE_SYSVSEM</b> is set,
then the child and the calling process share a single list
of System V semaphore adjustment (<i>semadj</i>) values (see
<a href="https://man.page/2/semop">semop(2)</a>). In this case, the shared list accumulates
<i>semadj</i> values across all processes sharing the list,
and semaphore adjustments are performed only when the last
process that is sharing the list terminates (or ceases
sharing the list using <a href="https://man.page/2/unshare">unshare(2)</a>). If this flag is
not set, then the child has a separate <i>semadj</i> list
that is initially empty.</p>

<p style="margin-left:11%;"><b>CLONE_THREAD</b> (since
Linux 2.4.0)</p>

<p style="margin-left:22%;">If <b>CLONE_THREAD</b> is set,
the child is placed in the same thread group as the calling
process. To make the remainder of the discussion of
<b>CLONE_THREAD</b> more readable, the term
&quot;thread&quot; is used to refer to the processes within
a thread group.</p>

<p style="margin-left:22%; margin-top: 1em">Thread groups
were a feature added in Linux 2.4 to support the POSIX
threads notion of a set of threads that share a single PID.
Internally, this shared PID is the so-called thread group
identifier (TGID) for the thread group. Since Linux 2.4,
calls to <a href="https://man.page/2/getpid">getpid(2)</a> return the TGID of the caller.</p>

<p style="margin-left:22%; margin-top: 1em">The threads
within a group can be distinguished by their (system-wide)
unique thread IDs (TID). A new thread&rsquo;s TID is
available as the function result returned to the caller, and
a thread can obtain its own TID using <a href="https://man.page/2/gettid">gettid(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">When a clone
call is made without specifying <b>CLONE_THREAD</b>, then
the resulting thread is placed in a new thread group whose
TGID is the same as the thread&rsquo;s TID. This thread is
the <i>leader</i> of the new thread group.</p>

<p style="margin-left:22%; margin-top: 1em">A new thread
created with <b>CLONE_THREAD</b> has the same parent process
as the process that made the clone call (i.e., like
<b>CLONE_PARENT</b>), so that calls to <a href="https://man.page/2/getppid">getppid(2)</a>
return the same value for all of the threads in a thread
group. When a <b>CLONE_THREAD</b> thread terminates, the
thread that created it is not sent a <b>SIGCHLD</b> (or
other termination) signal; nor can the status of such a
thread be obtained using <a href="https://man.page/2/wait">wait(2)</a>. (The thread is said
to be <i>detached</i>.)</p>

<p style="margin-left:22%; margin-top: 1em">After all of
the threads in a thread group terminate the parent process
of the thread group is sent a <b>SIGCHLD</b> (or other
termination) signal.</p>

<p style="margin-left:22%; margin-top: 1em">If any of the
threads in a thread group performs an <a href="https://man.page/2/execve">execve(2)</a>, then
all threads other than the thread group leader are
terminated, and the new program is executed in the thread
group leader.</p>

<p style="margin-left:22%; margin-top: 1em">If one of the
threads in a thread group creates a child using
<a href="https://man.page/2/fork">fork(2)</a>, then any thread in the group can
<a href="https://man.page/2/wait">wait(2)</a> for that child.</p>

<p style="margin-left:22%; margin-top: 1em">Since Linux
2.5.35, the <i>flags</i> mask must also include
<b>CLONE_SIGHAND</b> if <b>CLONE_THREAD</b> is specified
(and note that, since Linux 2.6.0, <b>CLONE_SIGHAND</b> also
requires <b>CLONE_VM</b> to be included).</p>

<p style="margin-left:22%; margin-top: 1em">Signal
dispositions and actions are process-wide: if an unhandled
signal is delivered to a thread, then it will affect
(terminate, stop, continue, be ignored in) all members of
the thread group.</p>

<p style="margin-left:22%; margin-top: 1em">Each thread has
its own signal mask, as set by <a href="https://man.page/2/sigprocmask">sigprocmask(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">A signal may be
process-directed or thread-directed. A process-directed
signal is targeted at a thread group (i.e., a TGID), and is
delivered to an arbitrarily selected thread from among those
that are not blocking the signal. A signal may be
process-directed because it was generated by the kernel for
reasons other than a hardware exception, or because it was
sent using <a href="https://man.page/2/kill">kill(2)</a> or <a href="https://man.page/3/sigqueue">sigqueue(3)</a>. A
thread-directed signal is targeted at (i.e., delivered to) a
specific thread. A signal may be thread directed because it
was sent using <a href="https://man.page/2/tgkill">tgkill(2)</a> or
<a href="https://man.page/3/pthread_sigqueue">pthread_sigqueue(3)</a>, or because the thread executed a
machine language instruction that triggered a hardware
exception (e.g., invalid memory access triggering
<b>SIGSEGV</b> or a floating-point exception triggering
<b>SIGFPE</b>).</p>

<p style="margin-left:22%; margin-top: 1em">A call to
<a href="https://man.page/2/sigpending">sigpending(2)</a> returns a signal set that is the union
of the pending process-directed signals and the signals that
are pending for the calling thread.</p>

<p style="margin-left:22%; margin-top: 1em">If a
process-directed signal is delivered to a thread group, and
the thread group has installed a handler for the signal,
then the handler will be invoked in exactly one, arbitrarily
selected member of the thread group that has not blocked the
signal. If multiple threads in a group are waiting to accept
the same signal using <a href="https://man.page/2/sigwaitinfo">sigwaitinfo(2)</a>, the kernel will
arbitrarily select one of these threads to receive the
signal.</p>

<p style="margin-left:11%;"><b>CLONE_UNTRACED</b> (since
Linux 2.5.46)</p>

<p style="margin-left:22%;">If <b>CLONE_UNTRACED</b> is
specified, then a tracing process cannot force
<b>CLONE_PTRACE</b> on this child process.</p>

<p style="margin-left:11%;"><b>CLONE_VFORK</b> (since Linux
2.2)</p>

<p style="margin-left:22%;">If <b>CLONE_VFORK</b> is set,
the execution of the calling process is suspended until the
child releases its virtual memory resources via a call to
<a href="https://man.page/2/execve">execve(2)</a> or <a href="https://man.page/2/_exit">_exit(2)</a> (as with
<a href="https://man.page/2/vfork">vfork(2)</a>).</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_VFORK</b> is not set, then both the calling process
and the child are schedulable after the call, and an
application should not rely on execution occurring in any
particular order.</p>

<p style="margin-left:11%;"><b>CLONE_VM</b> (since Linux
2.0)</p>

<p style="margin-left:22%;">If <b>CLONE_VM</b> is set, the
calling process and the child process run in the same memory
space. In particular, memory writes performed by the calling
process or by the child process are also visible in the
other process. Moreover, any memory mapping or unmapping
performed with <a href="https://man.page/2/mmap">mmap(2)</a> or <a href="https://man.page/2/munmap">munmap(2)</a> by the
child or calling process also affects the other process.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>CLONE_VM</b> is not set, the child process runs in a
separate copy of the memory space of the calling process at
the time of the clone call. Memory writes or file
mappings/unmappings performed by one of the processes do not
affect the other, as with <a href="https://man.page/2/fork">fork(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>CLONE_VM</b> flag is specified and the <b>CLONE_VM</b>
flag is not specified, then any alternate signal stack that
was established by <a href="https://man.page/2/sigaltstack">sigaltstack(2)</a> is cleared in the
child process.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success, the
thread ID of the child process is returned in the
caller&rsquo;s thread of execution. On failure, -1 is
returned in the caller&rsquo;s context, no child process
will be created, and <i>errno</i> will be set
appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Too many processes are already
running; see <a href="https://man.page/2/fork">fork(2)</a>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EBUSY</b> (<b>clone3</b>()
only)</p>

<p style="margin-left:22%;"><b>CLONE_INTO_CGROUP</b> was
specified in <i>cl_args.flags</i>, but the file descriptor
specified in <i>cl_args.cgroup</i> refers to a version 2
cgroup in which a domain controller is enabled.</p>

<p style="margin-left:11%;"><b>EEXIST</b> (<b>clone3</b>()
only)</p>

<p style="margin-left:22%;">One (or more) of the PIDs
specified in <i>set_tid</i> already exists in the
corresponding PID namespace.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Both <b>CLONE_SIGHAND</b> and <b>CLONE_CLEAR_SIGHAND</b>
were specified in the <i>flags</i> mask.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_SIGHAND</b> was specified in the <i>flags</i>
mask, but <b>CLONE_VM</b> was not. (Since Linux 2.6.0.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_THREAD</b> was specified in the <i>flags</i>
mask, but <b>CLONE_SIGHAND</b> was not. (Since Linux
2.5.35.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_THREAD</b> was specified in the <i>flags</i>
mask, but the current process previously called
<a href="https://man.page/2/unshare">unshare(2)</a> with the <b>CLONE_NEWPID</b> flag or used
<a href="https://man.page/2/setns">setns(2)</a> to reassociate itself with a PID
namespace.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Both <b>CLONE_FS</b> and <b>CLONE_NEWNS</b> were
specified in the <i>flags</i> mask.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EINVAL</b> (since Linux
3.9)</p>

<p style="margin-left:22%;">Both <b>CLONE_NEWUSER</b> and
<b>CLONE_FS</b> were specified in the <i>flags</i> mask.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Both <b>CLONE_NEWIPC</b> and <b>CLONE_SYSVSEM</b> were
specified in the <i>flags</i> mask.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>One (or both) of <b>CLONE_NEWPID</b> or
<b>CLONE_NEWUSER</b> and one (or both) of
<b>CLONE_THREAD</b> or <b>CLONE_PARENT</b> were specified in
the <i>flags</i> mask.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EINVAL</b> (since Linux
2.6.32)</p>

<p style="margin-left:22%;"><b>CLONE_PARENT</b> was
specified, and the caller is an init process.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned by the glibc <b>clone</b>() wrapper function
when <i>fn</i> or <i>stack</i> is specified as NULL.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_NEWIPC</b> was specified in the <i>flags</i>
mask, but the kernel was not configured with the
<b>CONFIG_SYSVIPC</b> and <b>CONFIG_IPC_NS</b> options.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_NEWNET</b> was specified in the <i>flags</i>
mask, but the kernel was not configured with the
<b>CONFIG_NET_NS</b> option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_NEWPID</b> was specified in the <i>flags</i>
mask, but the kernel was not configured with the
<b>CONFIG_PID_NS</b> option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_NEWUSER</b> was specified in the <i>flags</i>
mask, but the kernel was not configured with the
<b>CONFIG_USER_NS</b> option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_NEWUTS</b> was specified in the <i>flags</i>
mask, but the kernel was not configured with the
<b>CONFIG_UTS_NS</b> option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>stack</i> is not aligned to a suitable boundary for
this architecture. For example, on aarch64, <i>stack</i>
must be a multiple of 16.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EINVAL</b> (<b>clone3</b>()
only)</p>

<p style="margin-left:22%;"><b>CLONE_DETACHED</b> was
specified in the <i>flags</i> mask.</p>

<p style="margin-left:11%;"><b>EINVAL</b> (<b>clone</b>()
only)</p>

<p style="margin-left:22%;"><b>CLONE_PIDFD</b> was
specified together with <b>CLONE_DETACHED</b> in the
<i>flags</i> mask.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>CLONE_PIDFD</b> was specified together with
<b>CLONE_THREAD</b> in the <i>flags</i> mask.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EINVAL</b> (<b>clone</b>()
only)</p>

<p style="margin-left:22%;"><b>CLONE_PIDFD</b> was
specified together with <b>CLONE_PARENT_SETTID</b> in the
<i>flags</i> mask.</p>

<p style="margin-left:11%;"><b>EINVAL</b> (<b>clone3</b>()
only)</p>

<p style="margin-left:22%;"><i>set_tid_size</i> is greater
than the number of nested PID namespaces.</p>

<p style="margin-left:11%;"><b>EINVAL</b> (<b>clone3</b>()
only)</p>

<p style="margin-left:22%;">One of the PIDs specified in
<i>set_tid</i> was an invalid.</p>

<p style="margin-left:11%;"><b>EINVAL</b> (AArch64 only,
Linux 4.6 and earlier)</p>

<p style="margin-left:22%;"><i>stack</i> was not aligned to
a 126-bit boundary.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Cannot allocate sufficient memory to allocate a task
structure for the child, or to copy those parts of the
caller&rsquo;s context that need to be copied.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENOSPC</b> (since Linux
3.7)</p>

<p style="margin-left:22%;"><b>CLONE_NEWPID</b> was
specified in the <i>flags</i> mask, but the limit on the
nesting depth of PID namespaces would have been exceeded;
see <a href="https://man.page/7/pid_namespaces">pid_namespaces(7)</a>.</p>

<p style="margin-left:11%;"><b>ENOSPC</b> (since Linux 4.9;
beforehand <b>EUSERS</b>)</p>

<p style="margin-left:22%;"><b>CLONE_NEWUSER</b> was
specified in the <i>flags</i> mask, and the call would cause
the limit on the number of nested user namespaces to be
exceeded. See <a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">From Linux 3.11
to Linux 4.8, the error diagnosed in this case was
<b>EUSERS</b>.</p>

<p style="margin-left:11%;"><b>ENOSPC</b> (since Linux
4.9)</p>

<p style="margin-left:22%;">One of the values in the
<i>flags</i> mask specified the creation of a new user
namespace, but doing so would have caused the limit defined
by the corresponding file in <i>/proc/sys/user</i> to be
exceeded. For further details, see <a href="https://man.page/7/namespaces">namespaces(7)</a>.</p>

<p style="margin-left:11%;"><b>EOPNOTSUPP</b>
(<b>clone3</b>() only)</p>

<p style="margin-left:22%;"><b>CLONE_INTO_CGROUP</b> was
specified in <i>cl_args.flags</i>, but the file descriptor
specified in <i>cl_args.cgroup</i> refers to a version 2
cgroup that is in the <i>domain invalid</i> state.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p><b>CLONE_NEWCGROUP</b>, <b>CLONE_NEWIPC</b>,
<b>CLONE_NEWNET</b>, <b>CLONE_NEWNS</b>,
<b>CLONE_NEWPID</b>, or <b>CLONE_NEWUTS</b> was specified by
an unprivileged process (process without
<b>CAP_SYS_ADMIN</b>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p><b>CLONE_PID</b> was specified by a process other than
process 0. (This error occurs only on Linux 2.5.15 and
earlier.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p><b>CLONE_NEWUSER</b> was specified in the <i>flags</i>
mask, but either the effective user ID or the effective
group ID of the caller does not have a mapping in the parent
namespace (see <a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EPERM</b> (since Linux
3.9)</p>

<p style="margin-left:22%;"><b>CLONE_NEWUSER</b> was
specified in the <i>flags</i> mask and the caller is in a
chroot environment (i.e., the caller&rsquo;s root directory
does not match the root directory of the mount namespace in
which it resides).</p>

<p style="margin-left:11%;"><b>EPERM</b> (<b>clone3</b>()
only)</p>

<p style="margin-left:22%;"><i>set_tid_size</i> was greater
than zero, and the caller lacks the <b>CAP_SYS_ADMIN</b>
capability in one or more of the user namespaces that own
the corresponding PID namespaces.</p>

<p style="margin-left:11%;"><b>ERESTARTNOINTR</b> (since
Linux 2.6.17)</p>

<p style="margin-left:22%;">System call was interrupted by
a signal and will be restarted. (This can be seen only
during a trace.)</p>

<p style="margin-left:11%;"><b>EUSERS</b> (Linux 3.11 to
Linux 4.8)</p>

<p style="margin-left:22%;"><b>CLONE_NEWUSER</b> was
specified in the <i>flags</i> mask, and the limit on the
number of nested user namespaces would be exceeded. See the
discussion of the <b>ENOSPC</b> error above.</p>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>clone3</b>() system call first appeared in Linux 5.3.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These system
calls are Linux-specific and should not be used in programs
intended to be portable.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">One use of
these systems calls is to implement threads: multiple flows
of control in a program that run concurrently in a shared
address space.</p>

<p style="margin-left:11%; margin-top: 1em">Glibc does not
provide a wrapper for <b>clone3</b>(); call it using
<a href="https://man.page/2/syscall">syscall(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
glibc <b>clone</b>() wrapper function makes some changes in
the memory pointed to by <i>stack</i> (changes required to
set the stack up correctly for the child) <i>before</i>
invoking the <b>clone</b>() system call. So, in cases where
<b>clone</b>() is used to recursively create children, do
not use the buffer employed for the parent&rsquo;s stack as
the stack of the child.</p>

<p style="margin-left:11%; margin-top: 1em">The
<a href="https://man.page/2/kcmp">kcmp(2)</a> system call can be used to test whether two
processes share various resources such as a file descriptor
table, System V semaphore undo operations, or a virtual
address space.</p>

<p style="margin-left:11%; margin-top: 1em">Handlers
registered using <a href="https://man.page/3/pthread_atfork">pthread_atfork(3)</a> are not executed
during a clone call.</p>

<p style="margin-left:11%; margin-top: 1em">In the Linux
2.4.x series, <b>CLONE_THREAD</b> generally does not make
the parent of the new thread the same as the parent of the
calling process. However, for kernel versions 2.4.7 to
2.4.18 the <b>CLONE_THREAD</b> flag implied the
<b>CLONE_PARENT</b> flag (as in Linux 2.6.0 and later).</p>

<p style="margin-left:11%; margin-top: 1em">On i386,
<b>clone</b>() should not be called through vsyscall, but
directly through <i>int $0x80</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>C
library/kernel differences</b> <br>
The raw <b>clone</b>() system call corresponds more closely
to <a href="https://man.page/2/fork">fork(2)</a> in that execution in the child continues
from the point of the call. As such, the <i>fn</i> and
<i>arg</i> arguments of the <b>clone</b>() wrapper function
are omitted.</p>

<p style="margin-left:11%; margin-top: 1em">In contrast to
the glibc wrapper, the raw <b>clone</b>() system call
accepts NULL as a <i>stack</i> argument (and <b>clone3</b>()
likewise allows <i>cl_args.stack</i> to be NULL). In this
case, the child uses a duplicate of the parent&rsquo;s
stack. (Copy-on-write semantics ensure that the child gets
separate copies of stack pages when either process modifies
the stack.) In this case, for correct operation, the
<b>CLONE_VM</b> option should not be specified. (If the
child <i>shares</i> the parent&rsquo;s memory because of the
use of the <b>CLONE_VM</b> flag, then no copy-on-write
duplication occurs and chaos is likely to result.)</p>

<p style="margin-left:11%; margin-top: 1em">The order of
the arguments also differs in the raw system call, and there
are variations in the arguments across architectures, as
detailed in the following paragraphs.</p>

<p style="margin-left:11%; margin-top: 1em">The raw system
call interface on x86-64 and some other architectures
(including sh, tile, and alpha) is:</p>

<p style="margin-left:17%; margin-top: 1em"><b>long
clone(unsigned long</b> <i>flags</i><b>, void
*</b><i>stack</i><b>, <br>
int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,
<br>
unsigned long</b> <i>tls</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">On x86-32, and
several other common architectures (including score, ARM,
ARM 64, PA-RISC, arc, Power PC, xtensa, and MIPS), the order
of the last two arguments is reversed:</p>

<p style="margin-left:17%; margin-top: 1em"><b>long
clone(unsigned long</b> <i>flags</i><b>, void
*</b><i>stack</i><b>, <br>
int *</b><i>parent_tid</i><b>, unsigned long</b>
<i>tls</i><b>, <br>
int *</b><i>child_tid</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">On the cris and
s390 architectures, the order of the first two arguments is
reversed:</p>

<p style="margin-left:17%; margin-top: 1em"><b>long
clone(void *</b><i>stack</i><b>, unsigned long</b>
<i>flags</i><b>, <br>
int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,
<br>
unsigned long</b> <i>tls</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">On the
microblaze architecture, an additional argument is
supplied:</p>

<p style="margin-left:17%; margin-top: 1em"><b>long
clone(unsigned long</b> <i>flags</i><b>, void
*</b><i>stack</i><b>, <br>
int</b> <i>stack_size</i><b>,</b> /* Size of stack */
<b><br>
int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,
<br>
unsigned long</b> <i>tls</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>blackfin,
m68k, and sparc</b> <br>
The argument-passing conventions on blackfin, m68k, and
sparc are different from the descriptions above. For
details, see the kernel (and glibc) source.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ia64</b>
<br>
On ia64, a different interface is used:</p>

<p style="margin-left:17%; margin-top: 1em"><b>int
__clone2(int (*</b><i>fn</i><b>)(void *), <br>
void *</b><i>stack_base</i><b>, size_t</b>
<i>stack_size</i><b>, <br>
int</b> <i>flags</i><b>, void *</b><i>arg</i><b>, ... <br>
/* pid_t *</b><i>parent_tid</i><b>, struct user_desc
*</b><i>tls</i><b>, <br>
pid_t *</b><i>child_tid</i> <b>*/ );</b></p>

<p style="margin-left:11%; margin-top: 1em">The prototype
shown above is for the glibc wrapper function; for the
system call itself, the prototype can be described as
follows (it is identical to the <b>clone</b>() prototype on
microblaze):</p>

<p style="margin-left:17%; margin-top: 1em"><b>long
clone2(unsigned long</b> <i>flags</i><b>, void
*</b><i>stack_base</i><b>, <br>
int</b> <i>stack_size</i><b>,</b> /* Size of stack */
<b><br>
int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,
<br>
unsigned long</b> <i>tls</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>__clone2</b>()
operates in the same way as <b>clone</b>(), except that
<i>stack_base</i> points to the lowest address of the
child&rsquo;s stack area, and <i>stack_size</i> specifies
the size of the stack pointed to by <i>stack_base</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Linux 2.4
and earlier</b> <br>
In Linux 2.4 and earlier, <b>clone</b>() does not take
arguments <i>parent_tid</i>, <i>tls</i>, and
<i>child_tid</i>.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">GNU C library
versions 2.3.4 up to and including 2.24 contained a wrapper
function for <a href="https://man.page/2/getpid">getpid(2)</a> that performed caching of
PIDs. This caching relied on support in the glibc wrapper
for <b>clone</b>(), but limitations in the implementation
meant that the cache was not up to date in some
circumstances. In particular, if a signal was delivered to
the child immediately after the <b>clone</b>() call, then a
call to <a href="https://man.page/2/getpid">getpid(2)</a> in a handler for the signal could
return the PID of the calling process (&quot;the
parent&quot;), if the clone wrapper had not yet had a chance
to update the PID cache in the child. (This discussion
ignores the case where the child was created using
<b>CLONE_THREAD</b>, when <a href="https://man.page/2/getpid">getpid(2)</a> <i>should</i>
return the same value in the child and in the process that
called <b>clone</b>(), since the caller and the child are in
the same thread group. The stale-cache problem also does not
occur if the <i>flags</i> argument includes
<b>CLONE_VM</b>.) To get the truth, it was sometimes
necessary to use code such as the following:</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;syscall.h&gt;</p>

<p style="margin-left:17%; margin-top: 1em">pid_t
mypid;</p>

<p style="margin-left:17%; margin-top: 1em">mypid =
syscall(SYS_getpid);</p>

<p style="margin-left:11%; margin-top: 1em">Because of the
stale-cache problem, as well as other problems noted in
<a href="https://man.page/2/getpid">getpid(2)</a>, the PID caching feature was removed in
glibc 2.25.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
program demonstrates the use of <b>clone</b>() to create a
child process that executes in a separate UTS namespace. The
child changes the hostname in its UTS namespace. Both parent
and child then display the system hostname, making it
possible to see that the hostname differs in the UTS
namespaces of the parent and child. For an example of the
use of this program, see <a href="https://man.page/2/setns">setns(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Within the
sample program, we allocate the memory that is to be used
for the child&rsquo;s stack using <a href="https://man.page/2/mmap">mmap(2)</a> rather than
<a href="https://man.page/3/malloc">malloc(3)</a> for the following reasons:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p><a href="https://man.page/2/mmap">mmap(2)</a> allocates a block of memory that starts
on a page boundary and is a multiple of the page size. This
is useful if we want to establish a guard page (a page with
protection <b>PROT_NONE</b>) at the end of the stack using
<a href="https://man.page/2/mprotect">mprotect(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>We can specify the <b>MAP_STACK</b> flag to request a
mapping that is suitable for a stack. For the moment, this
flag is a no-op on Linux, but it exists and has effect on
some other systems, so we should include it for
portability.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
#define _GNU_SOURCE <br>
#include &lt;sys/wait.h&gt; <br>
#include &lt;sys/utsname.h&gt; <br>
#include &lt;sched.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;stdint.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;sys/mman.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">#define
errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \ <br>
} while (0)</p>

<p style="margin-left:11%; margin-top: 1em">static int /*
Start function for cloned child */ <br>
childFunc(void *arg) <br>
{ <br>
struct utsname uts;</p>

<p style="margin-left:11%; margin-top: 1em">/* Change
hostname in UTS namespace of child */</p>

<p style="margin-left:11%; margin-top: 1em">if
(sethostname(arg, strlen(arg)) == -1) <br>
errExit(&quot;sethostname&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Retrieve and
display hostname */</p>

<p style="margin-left:11%; margin-top: 1em">if
(uname(&amp;uts) == -1) <br>
errExit(&quot;uname&quot;); <br>
printf(&quot;uts.nodename in child: %s\n&quot;,
uts.nodename);</p>

<p style="margin-left:11%; margin-top: 1em">/* Keep the
namespace open for a while, by sleeping. <br>
This allows some experimentation--for example, another <br>
process might join the namespace. */</p>


<p style="margin-left:11%; margin-top: 1em">sleep(200);</p>

<p style="margin-left:11%; margin-top: 1em">return 0; /*
Child terminates now */ <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">#define
STACK_SIZE (1024 * 1024) /* Stack size for cloned child
*/</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
char *stack; /* Start of stack buffer */ <br>
char *stackTop; /* End of stack buffer */ <br>
pid_t pid; <br>
struct utsname uts;</p>

<p style="margin-left:11%; margin-top: 1em">if (argc &lt;
2) { <br>
fprintf(stderr, &quot;Usage: %s
&lt;child-hostname&gt;\n&quot;, argv[0]); <br>
exit(EXIT_SUCCESS); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Allocate
memory to be used for the stack of the child */</p>

<p style="margin-left:11%; margin-top: 1em">stack =
mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, <br>
MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0); <br>
if (stack == MAP_FAILED) <br>
errExit(&quot;mmap&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">stackTop =
stack + STACK_SIZE; /* Assume stack grows downward */</p>

<p style="margin-left:11%; margin-top: 1em">/* Create child
that has its own UTS namespace; <br>
child commences execution in childFunc() */</p>

<p style="margin-left:11%; margin-top: 1em">pid =
clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);
<br>
if (pid == -1) <br>
errExit(&quot;clone&quot;); <br>
printf(&quot;clone() returned %jd\n&quot;, (intmax_t)
pid);</p>

<p style="margin-left:11%; margin-top: 1em">/* Parent falls
through to here */</p>

<p style="margin-left:11%; margin-top: 1em">sleep(1); /*
Give child time to change its hostname */</p>

<p style="margin-left:11%; margin-top: 1em">/* Display
hostname in parent's UTS namespace. This will be <br>
different from hostname in child's UTS namespace. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(uname(&amp;uts) == -1) <br>
errExit(&quot;uname&quot;); <br>
printf(&quot;uts.nodename in parent: %s\n&quot;,
uts.nodename);</p>

<p style="margin-left:11%; margin-top: 1em">if
(waitpid(pid, NULL, 0) == -1) /* Wait for child */ <br>
errExit(&quot;waitpid&quot;); <br>
printf(&quot;child has terminated\n&quot;);</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/fork">fork(2)</a>,
<a href="https://man.page/2/futex">futex(2)</a>, <a href="https://man.page/2/getpid">getpid(2)</a>, <a href="https://man.page/2/gettid">gettid(2)</a>,
<a href="https://man.page/2/kcmp">kcmp(2)</a>, <a href="https://man.page/2/mmap">mmap(2)</a>, <a href="https://man.page/2/pidfd_open">pidfd_open(2)</a>,
<a href="https://man.page/2/set_thread_area">set_thread_area(2)</a>, <a href="https://man.page/2/set_tid_address">set_tid_address(2)</a>,
<a href="https://man.page/2/setns">setns(2)</a>, <a href="https://man.page/2/tkill">tkill(2)</a>, <a href="https://man.page/2/unshare">unshare(2)</a>,
<a href="https://man.page/2/wait">wait(2)</a>, <a href="https://man.page/7/capabilities">capabilities(7)</a>,
<a href="https://man.page/7/namespaces">namespaces(7)</a>, <a href="https://man.page/7/pthreads">pthreads(7)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
