<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:09 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SETUID</title>

</head>
<body>

<h1 align="center">SETUID</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">setuid - set
user identity</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/types.h&gt; <br>
#include &lt;unistd.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
setuid(uid_t</b> <i>uid</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>setuid</b>()
sets the effective user ID of the calling process. If the
calling process is privileged (more precisely: if the
process has the <b>CAP_SETUID</b> capability in its user
namespace), the real UID and saved set-user-ID are also
set.</p>

<p style="margin-left:11%; margin-top: 1em">Under Linux,
<b>setuid</b>() is implemented like the POSIX version with
the <b>_POSIX_SAVED_IDS</b> feature. This allows a
set-user-ID (other than root) program to drop all of its
user privileges, do some un-privileged work, and then
reengage the original effective user ID in a secure
manner.</p>

<p style="margin-left:11%; margin-top: 1em">If the user is
root or the program is set-user-ID-root, special care must
be taken: <b>setuid</b>() checks the effective user ID of
the caller and if it is the superuser, all process-related
user ID&rsquo;s are set to <i>uid</i>. After this has
occurred, it is impossible for the program to regain root
privileges.</p>

<p style="margin-left:11%; margin-top: 1em">Thus, a
set-user-ID-root program wishing to temporarily drop root
privileges, assume the identity of an unprivileged user, and
then regain root privileges afterward cannot use
<b>setuid</b>(). You can accomplish this with
<a href="https://man.page/2/seteuid">seteuid(2)</a>.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
zero is returned. On error, -1 is returned, and <i>errno</i>
is set appropriately.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Note</i>:
there are cases where <b>setuid</b>() can fail even when the
caller is UID 0; it is a grave security error to omit
checking for a failure return from <b>setuid</b>().</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">The call would change the
caller&rsquo;s real UID (i.e., <i>uid</i> does not match the
caller&rsquo;s real UID), but there was a temporary failure
allocating the necessary kernel data structures.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>uid</i> does not match the real user ID of the caller
and this call would bring the number of processes belonging
to the real user ID <i>uid</i> over the caller&rsquo;s
<b>RLIMIT_NPROC</b> resource limit. Since Linux 3.1, this
error case no longer occurs (but robust applications should
check for this error); see the description of <b>EAGAIN</b>
in <a href="https://man.page/2/execve">execve(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The user ID specified in <i>uid</i> is not valid in this
user namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The user is not privileged (Linux: does not have the
<b>CAP_SETUID</b> capability in its user namespace) and
<i>uid</i> does not match the real UID or saved set-user-ID
of the calling process.</p></td></tr>
</table>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1-2001,
POSIX.1-2008, SVr4. Not quite compatible with the 4.4BSD
call, which sets all of the real, saved, and effective user
IDs.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Linux has the
concept of the filesystem user ID, normally equal to the
effective user ID. The <b>setuid</b>() call also sets the
filesystem user ID of the calling process. See
<a href="https://man.page/2/setfsuid">setfsuid(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>uid</i>
is different from the old effective UID, the process will be
forbidden from leaving core dumps.</p>

<p style="margin-left:11%; margin-top: 1em">The original
Linux <b>setuid</b>() system call supported only 16-bit user
IDs. Subsequently, Linux 2.4 added <b>setuid32</b>()
supporting 32-bit IDs. The glibc <b>setuid</b>() wrapper
function transparently deals with the variation across
kernel versions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>C
library/kernel differences</b> <br>
At the kernel level, user IDs and group IDs are a per-thread
attribute. However, POSIX requires that all threads in a
process share the same credentials. The NPTL threading
implementation handles the POSIX requirements by providing
wrapper functions for the various system calls that change
process UIDs and GIDs. These wrapper functions (including
the one for <b>setuid</b>()) employ a signal-based technique
to ensure that when one thread changes credentials, all of
the other threads in the process also change their
credentials. For details, see <a href="https://man.page/7/nptl">nptl(7)</a>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/getuid">getuid(2)</a>,
<a href="https://man.page/2/seteuid">seteuid(2)</a>, <a href="https://man.page/2/setfsuid">setfsuid(2)</a>, <a href="https://man.page/2/setreuid">setreuid(2)</a>,
<a href="https://man.page/7/capabilities">capabilities(7)</a>, <a href="https://man.page/7/credentials">credentials(7)</a>,
<a href="https://man.page/7/user_namespaces">user_namespaces(7)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
