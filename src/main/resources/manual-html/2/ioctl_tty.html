<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:36:54 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IOCTL_TTY</title>

</head>
<body>

<h1 align="center">IOCTL_TTY</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ioctl_tty -
ioctls for terminals and serial lines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;termios.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ioctl(int</b> <i>fd</i><b>, int</b> <i>cmd</i><b>,
...);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>ioctl</b>(2) call for terminals and serial ports accepts
many possible command arguments. Most require a third
argument, of varying type, here called <i>argp</i> or
<i>arg</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Use of
<i>ioctl</i> makes for nonportable programs. Use the POSIX
interface described in <b>termios</b>(3) whenever
possible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Get and set
terminal attributes</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCGETS</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcgetattr(fd,
argp)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Get the current
serial port settings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCSETS</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcsetattr(fd,
TCSANOW, argp)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Set the current
serial port settings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCSETSW</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcsetattr(fd,
TCSADRAIN, argp)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Allow the
output buffer to drain, and set the current serial port
settings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCSETSF</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcsetattr(fd,
TCSAFLUSH, argp)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Allow the
output buffer to drain, discard pending input, and set the
current serial port settings.</p>

<p style="margin-left:11%; margin-top: 1em">The following
four ioctls are just like <b>TCGETS</b>, <b>TCSETS</b>,
<b>TCSETSW</b>, <b>TCSETSF</b>, except that they take a
<i>struct termio&nbsp;*</i> instead of a <i>struct
termios&nbsp;*</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCGETA</b></p></td>
<td width="77%">


<p><b>struct termio *</b><i>argp</i></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCSETA</b></p></td>
<td width="77%">


<p><b>const struct termio *</b><i>argp</i></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCSETAW</b></p></td>
<td width="77%">


<p><b>const struct termio *</b><i>argp</i></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCSETAF</b></p></td>
<td width="77%">


<p><b>const struct termio *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Locking the
termios structure</b> <br>
The <i>termios</i> structure of a terminal can be locked.
The lock is itself a <i>termios</i> structure, with nonzero
bits or fields indicating a locked value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCGLCKTRMIOS</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Gets the locking status of the
<i>termios</i> structure of the terminal.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCSLCKTRMIOS</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Sets the locking status of the
<i>termios</i> structure of the terminal. Only a process
with the <b>CAP_SYS_ADMIN</b> capability can do this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Get and set
window size</b> <br>
Window sizes are kept in the kernel, but not used by the
kernel (except in the case of virtual consoles, where the
kernel will update the window size when the size of the
virtual console changes, for example, by loading a new
font).</p>

<p style="margin-left:11%; margin-top: 1em">The following
constants and structure are defined in
<i>&lt;sys/ioctl.h&gt;</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCGWINSZ</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>struct winsize *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Get window size.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCSWINSZ</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>const struct winsize *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Set window size.</p>

<p style="margin-left:11%; margin-top: 1em">The struct used
by these ioctls is defined as</p>

<p style="margin-left:17%; margin-top: 1em">struct winsize
{ <br>
unsigned short ws_row; <br>
unsigned short ws_col; <br>
unsigned short ws_xpixel; /* unused */ <br>
unsigned short ws_ypixel; /* unused */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">When the window
size changes, a <b>SIGWINCH</b> signal is sent to the
foreground process group.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Sending a
break <br>
TCSBRK int</b> <i>arg</i></p>

<p style="margin-left:22%;">Equivalent to
<i>tcsendbreak(fd, arg)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">If the terminal
is using asynchronous serial data transmission, and
<i>arg</i> is zero, then send a break (a stream of zero
bits) for between 0.25 and 0.5 seconds. If the terminal is
not using asynchronous serial data transmission, then either
a break is sent, or the function returns without doing
anything. When <i>arg</i> is nonzero, nobody knows what will
happen.</p>

<p style="margin-left:22%; margin-top: 1em">(SVr4,
UnixWare, Solaris, Linux treat <i>tcsendbreak(fd,arg)</i>
with nonzero <i>arg</i> like <i>tcdrain(fd)</i>. SunOS
treats <i>arg</i> as a multiplier, and sends a stream of
bits <i>arg</i> times as long as done for zero <i>arg</i>.
DG/UX and AIX treat <i>arg</i> (when nonzero) as a time
interval measured in milliseconds. HP-UX ignores
<i>arg</i>.)</p>

<p style="margin-left:11%;"><b>TCSBRKP int</b>
<i>arg</i></p>

<p style="margin-left:22%;">So-called &quot;POSIX
version&quot; of <b>TCSBRK</b>. It treats nonzero <i>arg</i>
as a time interval measured in deciseconds, and does nothing
when the driver does not support breaks.</p>

<p style="margin-left:11%;"><b>TIOCSBRK void</b></p>

<p style="margin-left:22%;">Turn break on, that is, start
sending zero bits.</p>

<p style="margin-left:11%;"><b>TIOCCBRK void</b></p>

<p style="margin-left:22%;">Turn break off, that is, stop
sending zero bits.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Software
flow control <br>
TCXONC int</b> <i>arg</i></p>

<p style="margin-left:22%;">Equivalent to <i>tcflow(fd,
arg)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">See
<b>tcflow</b>(3) for the argument values <b>TCOOFF</b>,
<b>TCOON</b>, <b>TCIOFF</b>, <b>TCION</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Buffer count
and flushing <br>
FIONREAD int *</b><i>argp</i></p>

<p style="margin-left:22%;">Get the number of bytes in the
input buffer.</p>

<p style="margin-left:11%;"><b>TIOCINQ int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Same as <b>FIONREAD</b>.</p>

<p style="margin-left:11%;"><b>TIOCOUTQ int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Get the number of bytes in the
output buffer.</p>

<p style="margin-left:11%;"><b>TCFLSH int</b>
<i>arg</i></p>

<p style="margin-left:22%;">Equivalent to <i>tcflush(fd,
arg)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">See
<b>tcflush</b>(3) for the argument values <b>TCIFLUSH</b>,
<b>TCOFLUSH</b>, <b>TCIOFLUSH</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Faking input
<br>
TIOCSTI const char *</b><i>argp</i></p>

<p style="margin-left:22%;">Insert the given byte in the
input queue.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Redirecting
console output <br>
TIOCCONS void</b></p>

<p style="margin-left:22%;">Redirect output that would have
gone to <i>/dev/console</i> or <i>/dev/tty0</i> to the given
terminal. If that was a pseudoterminal master, send it to
the slave. In Linux before version 2.6.10, anybody can do
this as long as the output was not redirected yet; since
version 2.6.10, only a process with the <b>CAP_SYS_ADMIN</b>
capability may do this. If output was redirected already,
then <b>EBUSY</b> is returned, but redirection can be
stopped by using this ioctl with <i>fd</i> pointing at
<i>/dev/console</i> or <i>/dev/tty0</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Controlling
terminal <br>
TIOCSCTTY int</b> <i>arg</i></p>

<p style="margin-left:22%;">Make the given terminal the
controlling terminal of the calling process. The calling
process must be a session leader and not have a controlling
terminal already. For this case, <i>arg</i> should be
specified as zero.</p>

<p style="margin-left:22%; margin-top: 1em">If this
terminal is already the controlling terminal of a different
session group, then the ioctl fails with <b>EPERM</b>,
unless the caller has the <b>CAP_SYS_ADMIN</b> capability
and <i>arg</i> equals 1, in which case the terminal is
stolen, and all processes that had it as controlling
terminal lose it.</p>

<p style="margin-left:11%;"><b>TIOCNOTTY void</b></p>

<p style="margin-left:22%;">If the given terminal was the
controlling terminal of the calling process, give up this
controlling terminal. If the process was session leader,
then send <b>SIGHUP</b> and <b>SIGCONT</b> to the foreground
process group and all processes in the current session lose
their controlling terminal.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Process
group and session ID <br>
TIOCGPGRP pid_t *</b><i>argp</i></p>

<p style="margin-left:22%;">When successful, equivalent to
<i>*argp = tcgetpgrp(fd)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Get the process
group ID of the foreground process group on this
terminal.</p>

<p style="margin-left:11%;"><b>TIOCSPGRP const pid_t
*</b><i>argp</i></p>

<p style="margin-left:22%;">Equivalent to <i>tcsetpgrp(fd,
*argp)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Set the
foreground process group ID of this terminal.</p>

<p style="margin-left:11%;"><b>TIOCGSID pid_t
*</b><i>argp</i></p>

<p style="margin-left:22%;">Get the session ID of the given
terminal. This fails with the error <b>ENOTTY</b> if the
terminal is not a master pseudoterminal and not our
controlling terminal. Strange.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exclusive
mode <br>
TIOCEXCL void</b></p>

<p style="margin-left:22%;">Put the terminal into exclusive
mode. No further <b>open</b>(2) operations on the terminal
are permitted. (They fail with <b>EBUSY</b>, except for a
process with the <b>CAP_SYS_ADMIN</b> capability.)</p>

<p style="margin-left:11%;"><b>TIOCGEXCL int
*</b><i>argp</i></p>

<p style="margin-left:22%;">(since Linux 3.8) If the
terminal is currently in exclusive mode, place a nonzero
value in the location pointed to by <i>argp</i>; otherwise,
place zero in <i>*argp</i>.</p>

<p style="margin-left:11%;"><b>TIOCNXCL void</b></p>

<p style="margin-left:22%;">Disable exclusive mode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Line
discipline <br>
TIOCGETD int *</b><i>argp</i></p>

<p style="margin-left:22%;">Get the line discipline of the
terminal.</p>

<p style="margin-left:11%;"><b>TIOCSETD const int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Set the line discipline of the
terminal.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Pseudoterminal
ioctls <br>
TIOCPKT const int *</b><i>argp</i></p>

<p style="margin-left:22%;">Enable (when *<i>argp</i> is
nonzero) or disable packet mode. Can be applied to the
master side of a pseudoterminal only (and will return
<b>ENOTTY</b> otherwise). In packet mode, each subsequent
<b>read</b>(2) will return a packet that either contains a
single nonzero control byte, or has a single byte containing
zero ('\0') followed by data written on the slave side of
the pseudoterminal. If the first byte is not
<b>TIOCPKT_DATA</b> (0), it is an OR of one or more of the
following bits:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3242411.png" alt="Image grohtml-3242411.png"></p>

<p style="margin-left:22%; margin-top: 1em">While packet
mode is in use, the presence of control status information
to be read from the master side may be detected by a
<b>select</b>(2) for exceptional conditions or a
<b>poll</b>(2) for the <b>POLLPRI</b> event.</p>

<p style="margin-left:22%; margin-top: 1em">This mode is
used by <b>rlogin</b>(1) and <b>rlogind</b>(8) to implement
a remote-echoed, locally <b>^S</b>/<b>^Q</b> flow-controlled
remote login.</p>

<p style="margin-left:11%;"><b>TIOCGPKT const int
*</b><i>argp</i></p>

<p style="margin-left:22%;">(since Linux 3.8) Return the
current packet mode setting in the integer pointed to by
<i>argp</i>.</p>

<p style="margin-left:11%;"><b>TIOCSPTLCK int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Set (if <i>*argp</i> is
nonzero) or remove (if <i>*argp</i> is zero) the lock on the
pseudoterminal slave device. (See also
<b>unlockpt</b>(3).)</p>

<p style="margin-left:11%;"><b>TIOCGPTLCK int
*</b><i>argp</i></p>

<p style="margin-left:22%;">(since Linux 3.8) Place the
current lock state of the pseudoterminal slave device in the
location pointed to by <i>argp</i>.</p>

<p style="margin-left:11%;"><b>TIOCGPTPEER int</b>
<i>flags</i></p>

<p style="margin-left:22%;">(since Linux 4.13) Given a file
descriptor in <i>fd</i> that refers to a pseudoterminal
master, open (with the given <b>open</b>(2)-style
<i>flags</i>) and return a new file descriptor that refers
to the peer pseudoterminal slave device. This operation can
be performed regardless of whether the pathname of the slave
device is accessible through the calling process&rsquo;s
mount namespace.</p>


<p style="margin-left:22%; margin-top: 1em">Security-conscious
programs interacting with namespaces may wish to use this
operation rather than <b>open</b>(2) with the pathname
returned by <b>ptsname</b>(3), and similar library functions
that have insecure APIs. (For example, confusion can occur
in some cases using <b>ptsname</b>(3) with a pathname where
a devpts filesystem has been mounted in a different mount
namespace.)</p>

<p style="margin-left:11%; margin-top: 1em">The BSD ioctls
<b>TIOCSTOP</b>, <b>TIOCSTART</b>, <b>TIOCUCNTL</b>,
<b>TIOCREMOTE</b> have not been implemented under Linux.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Modem
control <br>
TIOCMGET int *</b><i>argp</i></p>

<p style="margin-left:22%;">Get the status of modem
bits.</p>

<p style="margin-left:11%;"><b>TIOCMSET const int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Set the status of modem
bits.</p>

<p style="margin-left:11%;"><b>TIOCMBIC const int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Clear the indicated modem
bits.</p>

<p style="margin-left:11%;"><b>TIOCMBIS const int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Set the indicated modem
bits.</p>

<p style="margin-left:11%; margin-top: 1em">The following
bits are used by the above ioctls:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3242412.png" alt="Image grohtml-3242412.png"></p>

<p style="margin-left:11%;"><b>TIOCMIWAIT int</b>
<i>arg</i></p>

<p style="margin-left:22%;">Wait for any of the 4 modem
bits (DCD, RI, DSR, CTS) to change. The bits of interest are
specified as a bit mask in <i>arg</i>, by ORing together any
of the bit values, <b>TIOCM_RNG</b>, <b>TIOCM_DSR</b>,
<b>TIOCM_CD</b>, and <b>TIOCM_CTS</b>. The caller should use
<b>TIOCGICOUNT</b> to see which bit has changed.</p>

<p style="margin-left:11%;"><b>TIOCGICOUNT struct
serial_icounter_struct *</b><i>argp</i></p>

<p style="margin-left:22%;">Get counts of input serial line
interrupts (DCD, RI, DSR, CTS). The counts are written to
the <i>serial_icounter_struct</i> structure pointed to by
<i>argp</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Note: both
1-&gt;0 and 0-&gt;1 transitions are counted, except for RI,
where only 0-&gt;1 transitions are counted.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Marking a
line as local <br>
TIOCGSOFTCAR int *</b><i>argp</i></p>

<p style="margin-left:22%;">(&quot;Get software carrier
flag&quot;) Get the status of the CLOCAL flag in the c_cflag
field of the <i>termios</i> structure.</p>

<p style="margin-left:11%;"><b>TIOCSSOFTCAR const int
*</b><i>argp</i></p>

<p style="margin-left:22%;">(&quot;Set software carrier
flag&quot;) Set the CLOCAL flag in the <i>termios</i>
structure when *<i>argp</i> is nonzero, and clear it
otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>CLOCAL</b> flag for a line is off, the hardware carrier
detect (DCD) signal is significant, and an <b>open</b>(2) of
the corresponding terminal will block until DCD is asserted,
unless the <b>O_NONBLOCK</b> flag is given. If <b>CLOCAL</b>
is set, the line behaves as if DCD is always asserted. The
software carrier flag is usually turned on for local
devices, and is off for lines with modems.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Linux-specific</b>
<br>
For the <b>TIOCLINUX</b> ioctl, see
<b>ioctl_console</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Kernel
debugging <br>
#include &lt;linux/tty.h&gt; <br>
TIOCTTYGSTRUCT struct tty_struct *</b><i>argp</i></p>

<p style="margin-left:22%;">Get the <i>tty_struct</i>
corresponding to <i>fd</i>. This command was removed in
Linux 2.5.67.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>ioctl</b>(2) system call returns 0 on success. On error,
it returns -1 and sets <i>errno</i> appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em">Invalid command parameter.</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ENOIOCTLCMD</b></p>

<p style="margin-left:22%;">Unknown command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOTTY</b></p></td>
<td width="2%"></td>
<td width="36%">


<p>Inappropriate <i>fd</i>.</p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="36%">


<p>Insufficient permission.</p></td>
<td width="42%">
</td></tr>
</table>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Check the
condition of DTR on the serial port.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;termios.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;sys/ioctl.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(void) <br>
{ <br>
int fd, serial;</p>

<p style="margin-left:11%; margin-top: 1em">fd =
open(&quot;/dev/ttyS0&quot;, O_RDONLY); <br>
ioctl(fd, TIOCMGET, &amp;serial); <br>
if (serial &amp; TIOCM_DTR) <br>
puts(&quot;TIOCM_DTR is set&quot;); <br>
else <br>
puts(&quot;TIOCM_DTR is not set&quot;); <br>
close(fd); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ldattach</b>(1),
<b>ioctl</b>(2), <b>ioctl_console</b>(2), <b>termios</b>(3),
<b>pty</b>(7)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
