<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:36:58 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>OPEN</title>

</head>
<body>

<h1 align="center">OPEN</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">open, openat,
creat - open and possibly create a file</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/types.h&gt; <br>
#include &lt;sys/stat.h&gt; <br>
#include &lt;fcntl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
open(const char *</b><i>pathname</i><b>, int</b>
<i>flags</i><b>); <br>
int open(const char *</b><i>pathname</i><b>, int</b>
<i>flags</i><b>, mode_t</b> <i>mode</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
creat(const char *</b><i>pathname</i><b>, mode_t</b>
<i>mode</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
openat(int</b> <i>dirfd</i><b>, const char
*</b><i>pathname</i><b>, int</b> <i>flags</i><b>); <br>
int openat(int</b> <i>dirfd</i><b>, const char
*</b><i>pathname</i><b>, int</b> <i>flags</i><b>, mode_t</b>
<i>mode</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">/* Documented
separately, in <a href="https://man.page/2/openat2">openat2(2)</a>: */ <b><br>
int openat2(int</b> <i>dirfd</i><b>, const char
*</b><i>pathname</i><b>, <br>
const struct open_how *</b><i>how</i><b>, size_t</b>
<i>size</i><b>);</b></p>

<p style="margin-left:5%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<a href="https://man.page/7/feature_test_macros">feature_test_macros(7)</a>):</p>


<p style="margin-left:11%; margin-top: 1em"><b>openat</b>():</p>

<p style="margin-left:17%;">Since glibc 2.10:</p>


<p style="margin-left:23%;">_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200809L</p>

<p style="margin-left:17%;">Before glibc 2.10:</p>

<p style="margin-left:23%;">_ATFILE_SOURCE</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>open</b>() system call opens the file specified by
<i>pathname</i>. If the specified file does not exist, it
may optionally (if <b>O_CREAT</b> is specified in
<i>flags</i>) be created by <b>open</b>().</p>

<p style="margin-left:11%; margin-top: 1em">The return
value of <b>open</b>() is a file descriptor, a small,
nonnegative integer that is used in subsequent system calls
(<a href="https://man.page/2/read">read(2)</a>, <a href="https://man.page/2/write">write(2)</a>, <a href="https://man.page/2/lseek">lseek(2)</a>,
<a href="https://man.page/2/fcntl">fcntl(2)</a>, etc.) to refer to the open file. The file
descriptor returned by a successful call will be the
lowest-numbered file descriptor not currently open for the
process.</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
new file descriptor is set to remain open across an
<a href="https://man.page/2/execve">execve(2)</a> (i.e., the <b>FD_CLOEXEC</b> file
descriptor flag described in <a href="https://man.page/2/fcntl">fcntl(2)</a> is initially
disabled); the <b>O_CLOEXEC</b> flag, described below, can
be used to change this default. The file offset is set to
the beginning of the file (see <a href="https://man.page/2/lseek">lseek(2)</a>).</p>

<p style="margin-left:11%; margin-top: 1em">A call to
<b>open</b>() creates a new <i>open file description</i>, an
entry in the system-wide table of open files. The open file
description records the file offset and the file status
flags (see below). A file descriptor is a reference to an
open file description; this reference is unaffected if
<i>pathname</i> is subsequently removed or modified to refer
to a different file. For further details on open file
descriptions, see NOTES.</p>

<p style="margin-left:11%; margin-top: 1em">The argument
<i>flags</i> must include one of the following <i>access
modes</i>: <b>O_RDONLY</b>, <b>O_WRONLY</b>, or
<b>O_RDWR</b>. These request opening the file read-only,
write-only, or read/write, respectively.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
zero or more file creation flags and file status flags can
be bitwise-<i>or</i>&rsquo;d in <i>flags</i>. The <i>file
creation flags</i> are <b>O_CLOEXEC</b>, <b>O_CREAT</b>,
<b>O_DIRECTORY</b>, <b>O_EXCL</b>, <b>O_NOCTTY</b>,
<b>O_NOFOLLOW</b>, <b>O_TMPFILE</b>, and <b>O_TRUNC</b>. The
<i>file status flags</i> are all of the remaining flags
listed below. The distinction between these two groups of
flags is that the file creation flags affect the semantics
of the open operation itself, while the file status flags
affect the semantics of subsequent I/O operations. The file
status flags can be retrieved and (in some cases) modified;
see <a href="https://man.page/2/fcntl">fcntl(2)</a> for details.</p>

<p style="margin-left:11%; margin-top: 1em">The full list
of file creation flags and file status flags is as follows:
<b><br>
O_APPEND</b></p>

<p style="margin-left:22%;">The file is opened in append
mode. Before each <a href="https://man.page/2/write">write(2)</a>, the file offset is
positioned at the end of the file, as if with
<a href="https://man.page/2/lseek">lseek(2)</a>. The modification of the file offset and the
write operation are performed as a single atomic step.</p>


<p style="margin-left:22%; margin-top: 1em"><b>O_APPEND</b>
may lead to corrupted files on NFS filesystems if more than
one process appends data to a file at once. This is because
NFS does not support appending to a file, so the client
kernel has to simulate it, which can&rsquo;t be done without
a race condition.</p>

<p style="margin-left:11%;"><b>O_ASYNC</b></p>

<p style="margin-left:22%;">Enable signal-driven I/O:
generate a signal (<b>SIGIO</b> by default, but this can be
changed via <a href="https://man.page/2/fcntl">fcntl(2)</a>) when input or output becomes
possible on this file descriptor. This feature is available
only for terminals, pseudoterminals, sockets, and (since
Linux 2.6) pipes and FIFOs. See <a href="https://man.page/2/fcntl">fcntl(2)</a> for further
details. See also BUGS, below.</p>

<p style="margin-left:11%;"><b>O_CLOEXEC</b> (since Linux
2.6.23)</p>

<p style="margin-left:22%;">Enable the close-on-exec flag
for the new file descriptor. Specifying this flag permits a
program to avoid additional <a href="https://man.page/2/fcntl">fcntl(2)</a> <b>F_SETFD</b>
operations to set the <b>FD_CLOEXEC</b> flag.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
use of this flag is essential in some multithreaded
programs, because using a separate <a href="https://man.page/2/fcntl">fcntl(2)</a>
<b>F_SETFD</b> operation to set the <b>FD_CLOEXEC</b> flag
does not suffice to avoid race conditions where one thread
opens a file descriptor and attempts to set its
close-on-exec flag using <a href="https://man.page/2/fcntl">fcntl(2)</a> at the same time as
another thread does a <a href="https://man.page/2/fork">fork(2)</a> plus <a href="https://man.page/2/execve">execve(2)</a>.
Depending on the order of execution, the race may lead to
the file descriptor returned by <b>open</b>() being
unintentionally leaked to the program executed by the child
process created by <a href="https://man.page/2/fork">fork(2)</a>. (This kind of race is in
principle possible for any system call that creates a file
descriptor whose close-on-exec flag should be set, and
various other Linux system calls provide an equivalent of
the <b>O_CLOEXEC</b> flag to deal with this problem.)</p>

<p style="margin-left:11%;"><b>O_CREAT</b></p>

<p style="margin-left:22%;">If <i>pathname</i> does not
exist, create it as a regular file.</p>

<p style="margin-left:22%; margin-top: 1em">The owner (user
ID) of the new file is set to the effective user ID of the
process.</p>

<p style="margin-left:22%; margin-top: 1em">The group
ownership (group ID) of the new file is set either to the
effective group ID of the process (System V semantics) or to
the group ID of the parent directory (BSD semantics). On
Linux, the behavior depends on whether the set-group-ID mode
bit is set on the parent directory: if that bit is set, then
BSD semantics apply; otherwise, System V semantics apply.
For some filesystems, the behavior also depends on the
<i>bsdgroups</i> and <i>sysvgroups</i> mount options
described in <b>mount</b>(8).</p>

<p style="margin-left:22%; margin-top: 1em">The <i>mode</i>
argument specifies the file mode bits to be applied when a
new file is created. If neither <b>O_CREAT</b> nor
<b>O_TMPFILE</b> is specified in <i>flags</i>, then
<i>mode</i> is ignored (and can thus be specified as 0, or
simply omitted). The <i>mode</i> argument <b>must</b> be
supplied if <b>O_CREAT</b> or <b>O_TMPFILE</b> is specified
in <i>flags</i>; if it is not supplied, some arbitrary bytes
from the stack will be applied as the file mode.</p>

<p style="margin-left:22%; margin-top: 1em">The effective
mode is modified by the process&rsquo;s <i>umask</i> in the
usual way: in the absence of a default ACL, the mode of the
created file is <i>(mode&nbsp;&amp;&nbsp;~umask)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Note that
<i>mode</i> applies only to future accesses of the newly
created file; the <b>open</b>() call that creates a
read-only file may well return a read/write file
descriptor.</p>

<p style="margin-left:22%; margin-top: 1em">The following
symbolic constants are provided for <i>mode</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IRWXU</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00700 user (file owner) has read, write, and execute
permission</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IRUSR</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00400 user has read permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IWUSR</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00200 user has write permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IXUSR</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00100 user has execute permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IRWXG</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00070 group has read, write, and execute permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IRGRP</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00040 group has read permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IWGRP</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00020 group has write permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IXGRP</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00010 group has execute permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IRWXO</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00007 others have read, write, and execute
permission</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IROTH</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00004 others have read permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IWOTH</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00002 others have write permission</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_IXOTH</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>00001 others have execute permission</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">According to
POSIX, the effect when other bits are set in <i>mode</i> is
unspecified. On Linux, the following bits are also honored
in <i>mode</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p style="margin-top: 1em"><b>S_ISUID</b></p></td>
<td width="3%"></td>
<td width="62%">


<p style="margin-top: 1em">0004000 set-user-ID bit</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_ISGID</b></p></td>
<td width="3%"></td>
<td width="62%">


<p>0002000 set-group-ID bit (see <a href="https://man.page/7/inode">inode(7)</a>).</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>S_ISVTX</b></p></td>
<td width="3%"></td>
<td width="62%">


<p>0001000 sticky bit (see <a href="https://man.page/7/inode">inode(7)</a>).</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>O_DIRECT</b> (since Linux
2.4.10)</p>

<p style="margin-left:22%;">Try to minimize cache effects
of the I/O to and from this file. In general this will
degrade performance, but it is useful in special situations,
such as when applications do their own caching. File I/O is
done directly to/from user-space buffers. The
<b>O_DIRECT</b> flag on its own makes an effort to transfer
data synchronously, but does not give the guarantees of the
<b>O_SYNC</b> flag that data and necessary metadata are
transferred. To guarantee synchronous I/O, <b>O_SYNC</b>
must be used in addition to <b>O_DIRECT</b>. See NOTES below
for further discussion.</p>

<p style="margin-left:22%; margin-top: 1em">A semantically
similar (but deprecated) interface for block devices is
described in <b>raw</b>(8).</p>

<p style="margin-left:11%;"><b>O_DIRECTORY</b></p>

<p style="margin-left:22%;">If <i>pathname</i> is not a
directory, cause the open to fail. This flag was added in
kernel version 2.1.126, to avoid denial-of-service problems
if <a href="https://man.page/3/opendir">opendir(3)</a> is called on a FIFO or tape device.</p>

<p style="margin-left:11%;"><b>O_DSYNC</b></p>

<p style="margin-left:22%;">Write operations on the file
will complete according to the requirements of synchronized
I/O <i>data</i> integrity completion.</p>

<p style="margin-left:22%; margin-top: 1em">By the time
<a href="https://man.page/2/write">write(2)</a> (and similar) return, the output data has
been transferred to the underlying hardware, along with any
file metadata that would be required to retrieve that data
(i.e., as though each <a href="https://man.page/2/write">write(2)</a> was followed by a call
to <a href="https://man.page/2/fdatasync">fdatasync(2)</a>). <i>See NOTES below</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>O_EXCL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Ensure that this call creates the file: if this flag is
specified in conjunction with <b>O_CREAT</b>, and
<i>pathname</i> already exists, then <b>open</b>() fails
with the error <b>EEXIST</b>.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When these two
flags are specified, symbolic links are not followed: if
<i>pathname</i> is a symbolic link, then <b>open</b>() fails
regardless of where the symbolic link points.</p>

<p style="margin-left:22%; margin-top: 1em">In general, the
behavior of <b>O_EXCL</b> is undefined if it is used without
<b>O_CREAT</b>. There is one exception: on Linux 2.6 and
later, <b>O_EXCL</b> can be used without <b>O_CREAT</b> if
<i>pathname</i> refers to a block device. If the block
device is in use by the system (e.g., mounted),
<b>open</b>() fails with the error <b>EBUSY</b>.</p>

<p style="margin-left:22%; margin-top: 1em">On NFS,
<b>O_EXCL</b> is supported only when using NFSv3 or later on
kernel 2.6 or later. In NFS environments where <b>O_EXCL</b>
support is not provided, programs that rely on it for
performing locking tasks will contain a race condition.
Portable programs that want to perform atomic file locking
using a lockfile, and need to avoid reliance on NFS support
for <b>O_EXCL</b>, can create a unique file on the same
filesystem (e.g., incorporating hostname and PID), and use
<a href="https://man.page/2/link">link(2)</a> to make a link to the lockfile. If
<a href="https://man.page/2/link">link(2)</a> returns 0, the lock is successful. Otherwise,
use <a href="https://man.page/2/stat">stat(2)</a> on the unique file to check if its link
count has increased to 2, in which case the lock is also
successful.</p>

<p style="margin-left:11%;"><b>O_LARGEFILE</b></p>

<p style="margin-left:22%;">(LFS) Allow files whose sizes
cannot be represented in an <i>off_t</i> (but can be
represented in an <i>off64_t</i>) to be opened. The
<b>_LARGEFILE64_SOURCE</b> macro must be defined (before
including <i>any</i> header files) in order to obtain this
definition. Setting the <b>_FILE_OFFSET_BITS</b> feature
test macro to 64 (rather than using <b>O_LARGEFILE</b>) is
the preferred method of accessing large files on 32-bit
systems (see <a href="https://man.page/7/feature_test_macros">feature_test_macros(7)</a>).</p>

<p style="margin-left:11%;"><b>O_NOATIME</b> (since Linux
2.6.8)</p>

<p style="margin-left:22%;">Do not update the file last
access time (<i>st_atime</i> in the inode) when the file is
<a href="https://man.page/2/read">read(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">This flag can
be employed only if one of the following conditions is
true:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>The effective UID of the process matches the owner UID
of the file.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>The calling process has the <b>CAP_FOWNER</b> capability
in its user namespace and the owner UID of the file has a
mapping in the namespace.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This flag is
intended for use by indexing or backup programs, where its
use can significantly reduce the amount of disk activity.
This flag may not be effective on all filesystems. One
example is NFS, where the server maintains the access
time.</p>

<p style="margin-left:11%;"><b>O_NOCTTY</b></p>

<p style="margin-left:22%;">If <i>pathname</i> refers to a
terminal device&mdash;see <a href="https://man.page/4/tty">tty(4)</a>&mdash;it will not
become the process&rsquo;s controlling terminal even if the
process does not have one.</p>

<p style="margin-left:11%;"><b>O_NOFOLLOW</b></p>

<p style="margin-left:22%;">If the trailing component
(i.e., basename) of <i>pathname</i> is a symbolic link, then
the open fails, with the error <b>ELOOP</b>. Symbolic links
in earlier components of the pathname will still be
followed. (Note that the <b>ELOOP</b> error that can occur
in this case is indistinguishable from the case where an
open fails because there are too many symbolic links found
while resolving components in the prefix part of the
pathname.)</p>

<p style="margin-left:22%; margin-top: 1em">This flag is a
FreeBSD extension, which was added to Linux in version
2.1.126, and has subsequently been standardized in
POSIX.1-2008.</p>

<p style="margin-left:22%; margin-top: 1em">See also
<b>O_PATH</b> below.</p>

<p style="margin-left:11%;"><b>O_NONBLOCK</b> or
<b>O_NDELAY</b></p>

<p style="margin-left:22%;">When possible, the file is
opened in nonblocking mode. Neither the <b>open</b>() nor
any subsequent I/O operations on the file descriptor which
is returned will cause the calling process to wait.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
setting of this flag has no effect on the operation of
<a href="https://man.page/2/poll">poll(2)</a>, <a href="https://man.page/2/select">select(2)</a>, <a href="https://man.page/7/epoll">epoll(7)</a>, and
similar, since those interfaces merely inform the caller
about whether a file descriptor is &quot;ready&quot;,
meaning that an I/O operation performed on the file
descriptor with the <b>O_NONBLOCK</b> flag <i>clear</i>
would not block.</p>

<p style="margin-left:22%; margin-top: 1em">Note that this
flag has no effect for regular files and block devices; that
is, I/O operations will (briefly) block when device activity
is required, regardless of whether <b>O_NONBLOCK</b> is set.
Since <b>O_NONBLOCK</b> semantics might eventually be
implemented, applications should not depend upon blocking
behavior when specifying this flag for regular files and
block devices.</p>

<p style="margin-left:22%; margin-top: 1em">For the
handling of FIFOs (named pipes), see also <a href="https://man.page/7/fifo">fifo(7)</a>.
For a discussion of the effect of <b>O_NONBLOCK</b> in
conjunction with mandatory file locks and with file leases,
see <a href="https://man.page/2/fcntl">fcntl(2)</a>.</p>

<p style="margin-left:11%;"><b>O_PATH</b> (since Linux
2.6.39)</p>

<p style="margin-left:22%;">Obtain a file descriptor that
can be used for two purposes: to indicate a location in the
filesystem tree and to perform operations that act purely at
the file descriptor level. The file itself is not opened,
and other file operations (e.g., <a href="https://man.page/2/read">read(2)</a>,
<a href="https://man.page/2/write">write(2)</a>, <a href="https://man.page/2/fchmod">fchmod(2)</a>, <a href="https://man.page/2/fchown">fchown(2)</a>,
<a href="https://man.page/2/fgetxattr">fgetxattr(2)</a>, <a href="https://man.page/2/ioctl">ioctl(2)</a>, <a href="https://man.page/2/mmap">mmap(2)</a>) fail
with the error <b>EBADF</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The following
operations <i>can</i> be performed on the resulting file
descriptor:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><a href="https://man.page/2/close">close(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><a href="https://man.page/2/fchdir">fchdir(2)</a>, if the file descriptor refers to a
directory (since Linux 3.5).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><a href="https://man.page/2/fstat">fstat(2)</a> (since Linux 3.6).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><a href="https://man.page/2/fstatfs">fstatfs(2)</a> (since Linux 3.12).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Duplicating the file descriptor (<a href="https://man.page/2/dup">dup(2)</a>,
<a href="https://man.page/2/fcntl">fcntl(2)</a> <b>F_DUPFD</b>, etc.).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Getting and setting file descriptor flags
(<a href="https://man.page/2/fcntl">fcntl(2)</a> <b>F_GETFD</b> and <b>F_SETFD</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Retrieving open file status flags using the
<a href="https://man.page/2/fcntl">fcntl(2)</a> <b>F_GETFL</b> operation: the returned flags
will include the bit <b>O_PATH</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Passing the file descriptor as the <i>dirfd</i> argument
of <b>openat</b>() and the other &quot;*at()&quot; system
calls. This includes <a href="https://man.page/2/linkat">linkat(2)</a> with
<b>AT_EMPTY_PATH</b> (or via procfs using
<b>AT_SYMLINK_FOLLOW</b>) even if the file is not a
directory.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Passing the file descriptor to another process via a
UNIX domain socket (see <b>SCM_RIGHTS</b> in
<a href="https://man.page/7/unix">unix(7)</a>).</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When
<b>O_PATH</b> is specified in <i>flags</i>, flag bits other
than <b>O_CLOEXEC</b>, <b>O_DIRECTORY</b>, and
<b>O_NOFOLLOW</b> are ignored.</p>

<p style="margin-left:22%; margin-top: 1em">Opening a file
or directory with the <b>O_PATH</b> flag requires no
permissions on the object itself (but does require execute
permission on the directories in the path prefix). Depending
on the subsequent operation, a check for suitable file
permissions may be performed (e.g., <a href="https://man.page/2/fchdir">fchdir(2)</a>
requires execute permission on the directory referred to by
its file descriptor argument). By contrast, obtaining a
reference to a filesystem object by opening it with the
<b>O_RDONLY</b> flag requires that the caller have read
permission on the object, even when the subsequent operation
(e.g., <a href="https://man.page/2/fchdir">fchdir(2)</a>, <a href="https://man.page/2/fstat">fstat(2)</a>) does not require
read permission on the object.</p>

<p style="margin-left:22%; margin-top: 1em">If
<i>pathname</i> is a symbolic link and the <b>O_NOFOLLOW</b>
flag is also specified, then the call returns a file
descriptor referring to the symbolic link. This file
descriptor can be used as the <i>dirfd</i> argument in calls
to <a href="https://man.page/2/fchownat">fchownat(2)</a>, <a href="https://man.page/2/fstatat">fstatat(2)</a>, <a href="https://man.page/2/linkat">linkat(2)</a>,
and <a href="https://man.page/2/readlinkat">readlinkat(2)</a> with an empty pathname to have the
calls operate on the symbolic link.</p>

<p style="margin-left:22%; margin-top: 1em">If
<i>pathname</i> refers to an automount point that has not
yet been triggered, so no other filesystem is mounted on it,
then the call returns a file descriptor referring to the
automount directory without triggering a mount.
<a href="https://man.page/2/fstatfs">fstatfs(2)</a> can then be used to determine if it is, in
fact, an untriggered automount point (<b>.f_type ==
AUTOFS_SUPER_MAGIC</b>).</p>

<p style="margin-left:22%; margin-top: 1em">One use of
<b>O_PATH</b> for regular files is to provide the equivalent
of POSIX.1&rsquo;s <b>O_EXEC</b> functionality. This permits
us to open a file for which we have execute permission but
not read permission, and then execute that file, with steps
something like the following:</p>

<p style="margin-left:28%; margin-top: 1em">char
buf[PATH_MAX]; <br>
fd = open(&quot;some_prog&quot;, O_PATH); <br>
snprintf(buf, PATH_MAX, &quot;/proc/self/fd/%d&quot;, fd);
<br>
execl(buf, &quot;some_prog&quot;, (char *) NULL);</p>

<p style="margin-left:22%; margin-top: 1em">An
<b>O_PATH</b> file descriptor can also be passed as the
argument of <a href="https://man.page/3/fexecve">fexecve(3)</a>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>O_SYNC</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Write operations on the file
will complete according to the requirements of synchronized
I/O <i>file</i> integrity completion (by contrast with the
synchronized I/O <i>data</i> integrity completion provided
by <b>O_DSYNC</b>.)</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">By the time
<a href="https://man.page/2/write">write(2)</a> (or similar) returns, the output data and
associated file metadata have been transferred to the
underlying hardware (i.e., as though each <a href="https://man.page/2/write">write(2)</a>
was followed by a call to <a href="https://man.page/2/fsync">fsync(2)</a>). <i>See NOTES
below</i>.</p>

<p style="margin-left:11%;"><b>O_TMPFILE</b> (since Linux
3.11)</p>

<p style="margin-left:22%;">Create an unnamed temporary
regular file. The <i>pathname</i> argument specifies a
directory; an unnamed inode will be created in that
directory&rsquo;s filesystem. Anything written to the
resulting file will be lost when the last file descriptor is
closed, unless the file is given a name.</p>


<p style="margin-left:22%; margin-top: 1em"><b>O_TMPFILE</b>
must be specified with one of <b>O_RDWR</b> or
<b>O_WRONLY</b> and, optionally, <b>O_EXCL</b>. If
<b>O_EXCL</b> is not specified, then <a href="https://man.page/2/linkat">linkat(2)</a> can be
used to link the temporary file into the filesystem, making
it permanent, using code like the following:</p>

<p style="margin-left:28%; margin-top: 1em">char
path[PATH_MAX]; <br>
fd = open(&quot;/path/to/dir&quot;, O_TMPFILE | O_RDWR, <br>
S_IRUSR | S_IWUSR);</p>

<p style="margin-left:28%; margin-top: 1em">/* File I/O on
'fd'... */</p>

<p style="margin-left:28%; margin-top: 1em">linkat(fd,
NULL, AT_FDCWD, &quot;/path/for/file&quot;,
AT_EMPTY_PATH);</p>

<p style="margin-left:28%; margin-top: 1em">/* If the
caller doesn't have the CAP_DAC_READ_SEARCH <br>
capability (needed to use AT_EMPTY_PATH with linkat(2)),
<br>
and there is a proc(5) filesystem mounted, then the <br>
linkat(2) call above can be replaced with:</p>

<p style="margin-left:28%; margin-top: 1em">snprintf(path,
PATH_MAX, &quot;/proc/self/fd/%d&quot;, fd); <br>
linkat(AT_FDCWD, path, AT_FDCWD, &quot;/path/for/file&quot;,
<br>
AT_SYMLINK_FOLLOW); <br>
*/</p>

<p style="margin-left:22%; margin-top: 1em">In this case,
the <b>open</b>() <i>mode</i> argument determines the file
permission mode, as with <b>O_CREAT</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Specifying
<b>O_EXCL</b> in conjunction with <b>O_TMPFILE</b> prevents
a temporary file from being linked into the filesystem in
the above manner. (Note that the meaning of <b>O_EXCL</b> in
this case is different from the meaning of <b>O_EXCL</b>
otherwise.)</p>

<p style="margin-left:22%; margin-top: 1em">There are two
main use cases for <b>O_TMPFILE</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Improved <a href="https://man.page/3/tmpfile">tmpfile(3)</a> functionality: race-free
creation of temporary files that (1) are automatically
deleted when closed; (2) can never be reached via any
pathname; (3) are not subject to symlink attacks; and (4) do
not require the caller to devise unique names.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>Creating a file that is initially invisible, which is
then populated with data and adjusted to have appropriate
filesystem attributes (<a href="https://man.page/2/fchown">fchown(2)</a>, <a href="https://man.page/2/fchmod">fchmod(2)</a>,
<a href="https://man.page/2/fsetxattr">fsetxattr(2)</a>, etc.) before being atomically linked
into the filesystem in a fully formed state (using
<a href="https://man.page/2/linkat">linkat(2)</a> as described above).</p></td></tr>
</table>


<p style="margin-left:22%; margin-top: 1em"><b>O_TMPFILE</b>
requires support by the underlying filesystem; only a subset
of Linux filesystems provide that support. In the initial
implementation, support was provided in the ext2, ext3,
ext4, UDF, Minix, and shmem filesystems. Support for other
filesystems has subsequently been added as follows: XFS
(Linux 3.15); Btrfs (Linux 3.16); F2FS (Linux 3.16); and
ubifs (Linux 4.9)</p>

<p style="margin-left:11%;"><b>O_TRUNC</b></p>

<p style="margin-left:22%;">If the file already exists and
is a regular file and the access mode allows writing (i.e.,
is <b>O_RDWR</b> or <b>O_WRONLY</b>) it will be truncated to
length 0. If the file is a FIFO or terminal device file, the
<b>O_TRUNC</b> flag is ignored. Otherwise, the effect of
<b>O_TRUNC</b> is unspecified.</p>

<p style="margin-left:11%; margin-top: 1em"><b>creat()</b>
<br>
A call to <b>creat</b>() is equivalent to calling
<b>open</b>() with <i>flags</i> equal to
<b>O_CREAT|O_WRONLY|O_TRUNC</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>openat()</b>
<br>
The <b>openat</b>() system call operates in exactly the same
way as <b>open</b>(), except for the differences described
here.</p>

<p style="margin-left:11%; margin-top: 1em">If the pathname
given in <i>pathname</i> is relative, then it is interpreted
relative to the directory referred to by the file descriptor
<i>dirfd</i> (rather than relative to the current working
directory of the calling process, as is done by
<b>open</b>() for a relative pathname).</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>pathname</i> is relative and <i>dirfd</i> is the special
value <b>AT_FDCWD</b>, then <i>pathname</i> is interpreted
relative to the current working directory of the calling
process (like <b>open</b>()).</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>pathname</i> is absolute, then <i>dirfd</i> is
ignored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>openat2(2)</b>
<br>
The <a href="https://man.page/2/openat2">openat2(2)</a> system call is an extension of
<b>openat</b>(), and provides a superset of the features of
<b>openat</b>(). It is documented separately, in
<a href="https://man.page/2/openat2">openat2(2)</a>.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>open</b>(),
<b>openat</b>(), and <b>creat</b>() return the new file
descriptor (a nonnegative integer), or -1 if an error
occurred (in which case, <i>errno</i> is set
appropriately).</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>open</b>(),
<b>openat</b>(), and <b>creat</b>() can fail with the
following errors:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The requested access to the file is not allowed, or
search permission is denied for one of the directories in
the path prefix of <i>pathname</i>, or the file did not
exist yet and write access to the parent directory is not
allowed. (See also <a href="https://man.page/7/path_resolution">path_resolution(7)</a>.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Where <b>O_CREAT</b> is specified, the
<i>protected_fifos</i> or <i>protected_regular</i> sysctl is
enabled, the file already exists and is a FIFO or regular
file, the owner of the file is neither the current user nor
the owner of the containing directory, and the containing
directory is both world- or group-writable and sticky. For
details, see the descriptions of
<i>/proc/sys/fs/protected_fifos</i> and
<i>/proc/sys/fs/protected_regular</i> in <a href="https://man.page/5/proc">proc(5)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBUSY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>O_EXCL</b> was specified in <i>flags</i> and
<i>pathname</i> refers to a block device that is in use by
the system (e.g., it is mounted).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EDQUOT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Where <b>O_CREAT</b> is specified, the file does not
exist, and the user&rsquo;s quota of disk blocks or inodes
on the filesystem has been exhausted.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EEXIST</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> already exists and <b>O_CREAT</b> and
<b>O_EXCL</b> were used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> points outside your accessible address
space.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFBIG</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>See <b>EOVERFLOW</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>While blocked waiting to complete an open of a slow
device (e.g., a FIFO; see <a href="https://man.page/7/fifo">fifo(7)</a>), the call was
interrupted by a signal handler; see <a href="https://man.page/7/signal">signal(7)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The filesystem does not support the <b>O_DIRECT</b>
flag. See <b>NOTES</b> for more information.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Invalid value in <i>flags</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>O_TMPFILE</b> was specified in <i>flags</i>, but
neither <b>O_WRONLY</b> nor <b>O_RDWR</b> was specified.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>O_CREAT</b> was specified in <i>flags</i> and the
final component (&quot;basename&quot;) of the new
file&rsquo;s <i>pathname</i> is invalid (e.g., it contains
characters not permitted by the underlying filesystem).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The final component (&quot;basename&quot;) of
<i>pathname</i> is invalid (e.g., it contains characters not
permitted by the underlying filesystem).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EISDIR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> refers to a directory and the access
requested involved writing (that is, <b>O_WRONLY</b> or
<b>O_RDWR</b> is set).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EISDIR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> refers to an existing directory,
<b>O_TMPFILE</b> and one of <b>O_WRONLY</b> or <b>O_RDWR</b>
were specified in <i>flags</i>, but this kernel version does
not provide the <b>O_TMPFILE</b> functionality.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ELOOP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Too many symbolic links were encountered in resolving
<i>pathname</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ELOOP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> was a symbolic link, and <i>flags</i>
specified <b>O_NOFOLLOW</b> but not <b>O_PATH</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The per-process limit on the number of open file
descriptors has been reached (see the description of
<b>RLIMIT_NOFILE</b> in <a href="https://man.page/2/getrlimit">getrlimit(2)</a>).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENAMETOOLONG</b></p>

<p style="margin-left:22%;"><i>pathname</i> was too
long.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The system-wide limit on the total number of open files
has been reached.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENODEV</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> refers to a device special file and no
corresponding device exists. (This is a Linux kernel bug; in
this situation <b>ENXIO</b> must be returned.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>O_CREAT</b> is not set and the named file does not
exist.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A directory component in <i>pathname</i> does not exist
or is a dangling symbolic link.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> refers to a nonexistent directory,
<b>O_TMPFILE</b> and one of <b>O_WRONLY</b> or <b>O_RDWR</b>
were specified in <i>flags</i>, but this kernel version does
not provide the <b>O_TMPFILE</b> functionality.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The named file is a FIFO, but memory for the FIFO buffer
can&rsquo;t be allocated because the per-user hard limit on
memory allocation for pipes has been reached and the caller
is not privileged; see <a href="https://man.page/7/pipe">pipe(7)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Insufficient kernel memory was available.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOSPC</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> was to be created but the device
containing <i>pathname</i> has no room for the new file.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENOTDIR</b></p>

<p style="margin-left:22%;">A component used as a directory
in <i>pathname</i> is not, in fact, a directory, or
<b>O_DIRECTORY</b> was specified and <i>pathname</i> was not
a directory.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="78%">


<p><b>O_NONBLOCK</b> | <b>O_WRONLY</b> is set, the named
file is a FIFO, and no process has the FIFO open for
reading.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The file is a device special file and no corresponding
device exists.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The file is a UNIX domain socket.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EOPNOTSUPP</b></p>

<p style="margin-left:22%;">The filesystem containing
<i>pathname</i> does not support <b>O_TMPFILE</b>.</p>

<p style="margin-left:11%;"><b>EOVERFLOW</b></p>

<p style="margin-left:22%;"><i>pathname</i> refers to a
regular file that is too large to be opened. The usual
scenario here is that an application compiled on a 32-bit
platform without <i>-D_FILE_OFFSET_BITS=64</i> tried to open
a file whose size exceeds <i>(1&lt;&lt;31)-1</i> bytes; see
also <b>O_LARGEFILE</b> above. This is the error specified
by POSIX.1; in kernels before 2.6.24, Linux gave the error
<b>EFBIG</b> for this case.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The <b>O_NOATIME</b> flag was specified, but the
effective user ID of the caller did not match the owner of
the file and the caller was not privileged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The operation was prevented by a file seal; see
<a href="https://man.page/2/fcntl">fcntl(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EROFS</b></p></td>
<td width="4%"></td>
<td width="78%">


<p><i>pathname</i> refers to a file on a read-only
filesystem and write access was requested.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ETXTBSY</b></p>

<p style="margin-left:22%;"><i>pathname</i> refers to an
executable image which is currently being executed and write
access was requested.</p>

<p style="margin-left:11%;"><b>ETXTBSY</b></p>

<p style="margin-left:22%;"><i>pathname</i> refers to a
file that is currently in use as a swap file, and the
<b>O_TRUNC</b> flag was specified.</p>

<p style="margin-left:11%;"><b>ETXTBSY</b></p>

<p style="margin-left:22%;"><i>pathname</i> refers to a
file that is currently being read by the kernel (e.g., for
module/firmware loading), and write access was
requested.</p>

<p style="margin-left:11%;"><b>EWOULDBLOCK</b></p>

<p style="margin-left:22%;">The <b>O_NONBLOCK</b> flag was
specified, and an incompatible lease was held on the file
(see <a href="https://man.page/2/fcntl">fcntl(2)</a>).</p>

<p style="margin-left:11%; margin-top: 1em">The following
additional errors can occur for <b>openat</b>():</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EBADF</b></p></td>
<td width="4%"></td>
<td width="56%">


<p><i>dirfd</i> is not a valid file descriptor.</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ENOTDIR</b></p>

<p style="margin-left:22%;"><i>pathname</i> is a relative
pathname and <i>dirfd</i> is a file descriptor referring to
a file other than a directory.</p>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>openat</b>()
was added to Linux in kernel 2.6.16; library support was
added to glibc in version 2.4.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>open</b>(),
<b>creat</b>() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.</p>


<p style="margin-left:11%; margin-top: 1em"><b>openat</b>():
POSIX.1-2008.</p>


<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/openat2">openat2(2)</a>
is Linux-specific.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>O_DIRECT</b>, <b>O_NOATIME</b>, <b>O_PATH</b>, and
<b>O_TMPFILE</b> flags are Linux-specific. One must define
<b>_GNU_SOURCE</b> to obtain their definitions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>O_CLOEXEC</b>, <b>O_DIRECTORY</b>, and <b>O_NOFOLLOW</b>
flags are not specified in POSIX.1-2001, but are specified
in POSIX.1-2008. Since glibc 2.12, one can obtain their
definitions by defining either <b>_POSIX_C_SOURCE</b> with a
value greater than or equal to 200809L or
<b>_XOPEN_SOURCE</b> with a value greater than or equal to
700. In glibc 2.11 and earlier, one obtains the definitions
by defining <b>_GNU_SOURCE</b>.</p>

<p style="margin-left:11%; margin-top: 1em">As noted in
<a href="https://man.page/7/feature_test_macros">feature_test_macros(7)</a>, feature test macros such as
<b>_POSIX_C_SOURCE</b>, <b>_XOPEN_SOURCE</b>, and
<b>_GNU_SOURCE</b> must be defined before including
<i>any</i> header files.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Under Linux,
the <b>O_NONBLOCK</b> flag is sometimes used in cases where
one wants to open but does not necessarily have the
intention to read or write. For example, this may be used to
open a device in order to get a file descriptor for use with
<a href="https://man.page/2/ioctl">ioctl(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The (undefined)
effect of <b>O_RDONLY | O_TRUNC</b> varies among
implementations. On many systems the file is actually
truncated.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<b>open</b>() can open device special files, but
<b>creat</b>() cannot create them; use <a href="https://man.page/2/mknod">mknod(2)</a>
instead.</p>

<p style="margin-left:11%; margin-top: 1em">If the file is
newly created, its <i>st_atime</i>, <i>st_ctime</i>,
<i>st_mtime</i> fields (respectively, time of last access,
time of last status change, and time of last modification;
see <a href="https://man.page/2/stat">stat(2)</a>) are set to the current time, and so are
the <i>st_ctime</i> and <i>st_mtime</i> fields of the parent
directory. Otherwise, if the file is modified because of the
<b>O_TRUNC</b> flag, its <i>st_ctime</i> and <i>st_mtime</i>
fields are set to the current time.</p>

<p style="margin-left:11%; margin-top: 1em">The files in
the <i>/proc/[pid]/fd</i> directory show the open file
descriptors of the process with the PID <i>pid</i>. The
files in the <i>/proc/[pid]/fdinfo</i> directory show even
more information about these file descriptors. See
<a href="https://man.page/5/proc">proc(5)</a> for further details of both of these
directories.</p>

<p style="margin-left:11%; margin-top: 1em">The Linux
header file <b>&lt;asm/fcntl.h&gt;</b> doesn&rsquo;t define
<b>O_ASYNC</b>; the (BSD-derived) <b>FASYNC</b> synonym is
defined instead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Open file
descriptions</b> <br>
The term open file description is the one used by POSIX to
refer to the entries in the system-wide table of open files.
In other contexts, this object is variously also called an
&quot;open file object&quot;, a &quot;file handle&quot;, an
&quot;open file table entry&quot;, or&mdash;in
kernel-developer parlance&mdash;a <i>struct file</i>.</p>

<p style="margin-left:11%; margin-top: 1em">When a file
descriptor is duplicated (using <a href="https://man.page/2/dup">dup(2)</a> or similar),
the duplicate refers to the same open file description as
the original file descriptor, and the two file descriptors
consequently share the file offset and file status flags.
Such sharing can also occur between processes: a child
process created via <a href="https://man.page/2/fork">fork(2)</a> inherits duplicates of
its parent&rsquo;s file descriptors, and those duplicates
refer to the same open file descriptions.</p>

<p style="margin-left:11%; margin-top: 1em">Each
<b>open</b>() of a file creates a new open file description;
thus, there may be multiple open file descriptions
corresponding to a file inode.</p>

<p style="margin-left:11%; margin-top: 1em">On Linux, one
can use the <a href="https://man.page/2/kcmp">kcmp(2)</a> <b>KCMP_FILE</b> operation to
test whether two file descriptors (in the same process or in
two different processes) refer to the same open file
description.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Synchronized
I/O</b> <br>
The POSIX.1-2008 &quot;synchronized I/O&quot; option
specifies different variants of synchronized I/O, and
specifies the <b>open</b>() flags <b>O_SYNC</b>,
<b>O_DSYNC</b>, and <b>O_RSYNC</b> for controlling the
behavior. Regardless of whether an implementation supports
this option, it must at least support the use of
<b>O_SYNC</b> for regular files.</p>

<p style="margin-left:11%; margin-top: 1em">Linux
implements <b>O_SYNC</b> and <b>O_DSYNC</b>, but not
<b>O_RSYNC</b>. Somewhat incorrectly, glibc defines
<b>O_RSYNC</b> to have the same value as <b>O_SYNC</b>.
(<b>O_RSYNC</b> is defined in the Linux header file
<i>&lt;asm/fcntl.h&gt;</i> on HP PA-RISC, but it is not
used.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>O_SYNC</b>
provides synchronized I/O <i>file</i> integrity completion,
meaning write operations will flush data and all associated
metadata to the underlying hardware. <b>O_DSYNC</b> provides
synchronized I/O <i>data</i> integrity completion, meaning
write operations will flush data to the underlying hardware,
but will only flush metadata updates that are required to
allow a subsequent read operation to complete successfully.
Data integrity completion can reduce the number of disk
operations that are required for applications that
don&rsquo;t need the guarantees of file integrity
completion.</p>

<p style="margin-left:11%; margin-top: 1em">To understand
the difference between the two types of completion, consider
two pieces of file metadata: the file last modification
timestamp (<i>st_mtime</i>) and the file length. All write
operations will update the last file modification timestamp,
but only writes that add data to the end of the file will
change the file length. The last modification timestamp is
not needed to ensure that a read completes successfully, but
the file length is. Thus, <b>O_DSYNC</b> would only
guarantee to flush updates to the file length metadata
(whereas <b>O_SYNC</b> would also always flush the last
modification timestamp metadata).</p>

<p style="margin-left:11%; margin-top: 1em">Before Linux
2.6.33, Linux implemented only the <b>O_SYNC</b> flag for
<b>open</b>(). However, when that flag was specified, most
filesystems actually provided the equivalent of synchronized
I/O <i>data</i> integrity completion (i.e., <b>O_SYNC</b>
was actually implemented as the equivalent of
<b>O_DSYNC</b>).</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
2.6.33, proper <b>O_SYNC</b> support is provided. However,
to ensure backward binary compatibility, <b>O_DSYNC</b> was
defined with the same value as the historical <b>O_SYNC</b>,
and <b>O_SYNC</b> was defined as a new (two-bit) flag value
that includes the <b>O_DSYNC</b> flag value. This ensures
that applications compiled against new headers get at least
<b>O_DSYNC</b> semantics on pre-2.6.33 kernels.</p>

<p style="margin-left:11%; margin-top: 1em"><b>C
library/kernel differences</b> <br>
Since version 2.26, the glibc wrapper function for
<b>open</b>() employs the <b>openat</b>() system call,
rather than the kernel&rsquo;s <b>open</b>() system call.
For certain architectures, this is also true in glibc
versions before 2.26.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NFS</b> <br>
There are many infelicities in the protocol underlying NFS,
affecting amongst others <b>O_SYNC</b> and
<b>O_NDELAY</b>.</p>

<p style="margin-left:11%; margin-top: 1em">On NFS
filesystems with UID mapping enabled, <b>open</b>() may
return a file descriptor but, for example, <a href="https://man.page/2/read">read(2)</a>
requests are denied with <b>EACCES</b>. This is because the
client performs <b>open</b>() by checking the permissions,
but UID mapping is performed by the server upon read and
write requests.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FIFOs</b>
<br>
Opening the read or write end of a FIFO blocks until the
other end is also opened (by another process or thread). See
<a href="https://man.page/7/fifo">fifo(7)</a> for further details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File access
mode</b> <br>
Unlike the other values that can be specified in
<i>flags</i>, the <i>access mode</i> values <b>O_RDONLY</b>,
<b>O_WRONLY</b>, and <b>O_RDWR</b> do not specify individual
bits. Rather, they define the low order two bits of
<i>flags</i>, and are defined respectively as 0, 1, and 2.
In other words, the combination <b>O_RDONLY | O_WRONLY</b>
is a logical error, and certainly does not have the same
meaning as <b>O_RDWR</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Linux reserves
the special, nonstandard access mode 3 (binary 11) in
<i>flags</i> to mean: check for read and write permission on
the file and return a file descriptor that can&rsquo;t be
used for reading or writing. This nonstandard access mode is
used by some Linux drivers to return a file descriptor that
is to be used only for device-specific <a href="https://man.page/2/ioctl">ioctl(2)</a>
operations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Rationale
for openat() and other directory file descriptor APIs <br>
openat</b>() and the other system calls and library
functions that take a directory file descriptor argument
(i.e., <a href="https://man.page/2/execveat">execveat(2)</a>, <a href="https://man.page/2/faccessat">faccessat(2)</a>,
<a href="https://man.page/2/fanotify_mark">fanotify_mark(2)</a>, <a href="https://man.page/2/fchmodat">fchmodat(2)</a>,
<a href="https://man.page/2/fchownat">fchownat(2)</a>, <a href="https://man.page/2/fspick">fspick(2)</a>, <a href="https://man.page/2/fstatat">fstatat(2)</a>,
<a href="https://man.page/2/futimesat">futimesat(2)</a>, <a href="https://man.page/2/linkat">linkat(2)</a>, <a href="https://man.page/2/mkdirat">mkdirat(2)</a>,
<a href="https://man.page/2/move_mount">move_mount(2)</a>, <a href="https://man.page/2/mknodat">mknodat(2)</a>,
<a href="https://man.page/2/name_to_handle_at">name_to_handle_at(2)</a>, <a href="https://man.page/2/open_tree">open_tree(2)</a>,
<a href="https://man.page/2/openat2">openat2(2)</a>, <a href="https://man.page/2/readlinkat">readlinkat(2)</a>, <a href="https://man.page/2/renameat">renameat(2)</a>,
<a href="https://man.page/2/statx">statx(2)</a>, <a href="https://man.page/2/symlinkat">symlinkat(2)</a>, <a href="https://man.page/2/unlinkat">unlinkat(2)</a>,
<a href="https://man.page/2/utimensat">utimensat(2)</a>, <a href="https://man.page/3/mkfifoat">mkfifoat(3)</a>, and
<a href="https://man.page/3/scandirat">scandirat(3)</a>) address two problems with the older
interfaces that preceded them. Here, the explanation is in
terms of the <b>openat</b>() call, but the rationale is
analogous for the other interfaces.</p>

<p style="margin-left:11%; margin-top: 1em">First,
<b>openat</b>() allows an application to avoid race
conditions that could occur when using <b>open</b>() to open
files in directories other than the current working
directory. These race conditions result from the fact that
some component of the directory prefix given to
<b>open</b>() could be changed in parallel with the call to
<b>open</b>(). Suppose, for example, that we wish to create
the file <i>dir1/dir2/xxx.dep</i> if the file
<i>dir1/dir2/xxx</i> exists. The problem is that between the
existence check and the file-creation step, <i>dir1</i> or
<i>dir2</i> (which might be symbolic links) could be
modified to point to a different location. Such races can be
avoided by opening a file descriptor for the target
directory, and then specifying that file descriptor as the
<i>dirfd</i> argument of (say) <a href="https://man.page/2/fstatat">fstatat(2)</a> and
<b>openat</b>(). The use of the <i>dirfd</i> file descriptor
also has other benefits:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>the file descriptor is a stable reference to the
directory, even if the directory is renamed; and</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>the open file descriptor prevents the underlying
filesystem from being dismounted, just as when a process has
a current working directory on a filesystem.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Second,
<b>openat</b>() allows the implementation of a per-thread
&quot;current working directory&quot;, via file
descriptor(s) maintained by the application. (This
functionality can also be obtained by tricks based on the
use of <i>/proc/self/fd/</i>dirfd, but less
efficiently.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>dirfd</i> argument for these APIs can be obtained by
using <b>open</b>() or <b>openat</b>() to open a directory
(with either the <b>O_RDONLY</b> or the <b>O_PATH</b> flag).
Alternatively, such a file descriptor can be obtained by
applying <a href="https://man.page/3/dirfd">dirfd(3)</a> to a directory stream created using
<a href="https://man.page/3/opendir">opendir(3)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">When these APIs
are given a <i>dirfd</i> argument of <b>AT_FDCWD</b> or the
specified pathname is absolute, then they handle their
pathname argument in the same way as the corresponding
conventional APIs. However, in this case, several of the
APIs have a <i>flags</i> argument that provides access to
functionality that is not available with the corresponding
conventional APIs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>O_DIRECT</b>
<br>
The <b>O_DIRECT</b> flag may impose alignment restrictions
on the length and address of user-space buffers and the file
offset of I/Os. In Linux alignment restrictions vary by
filesystem and kernel version and might be absent entirely.
However there is currently no filesystem-independent
interface for an application to discover these restrictions
for a given file or filesystem. Some filesystems provide
their own interfaces for doing so, for example the
<b>XFS_IOC_DIOINFO</b> operation in <a href="https://man.page/3/xfsctl">xfsctl(3)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Under Linux
2.4, transfer sizes, and the alignment of the user buffer
and the file offset must all be multiples of the logical
block size of the filesystem. Since Linux 2.6.0, alignment
to the logical block size of the underlying storage
(typically 512 bytes) suffices. The logical block size can
be determined using the <a href="https://man.page/2/ioctl">ioctl(2)</a> <b>BLKSSZGET</b>
operation or from the shell using the command:</p>

<p style="margin-left:17%; margin-top: 1em">blockdev
--getss</p>


<p style="margin-left:11%; margin-top: 1em"><b>O_DIRECT</b>
I/Os should never be run concurrently with the
<a href="https://man.page/2/fork">fork(2)</a> system call, if the memory buffer is a
private mapping (i.e., any mapping created with the
<a href="https://man.page/2/mmap">mmap(2)</a> <b>MAP_PRIVATE</b> flag; this includes memory
allocated on the heap and statically allocated buffers). Any
such I/Os, whether submitted via an asynchronous I/O
interface or from another thread in the process, should be
completed before <a href="https://man.page/2/fork">fork(2)</a> is called. Failure to do so
can result in data corruption and undefined behavior in
parent and child processes. This restriction does not apply
when the memory buffer for the <b>O_DIRECT</b> I/Os was
created using <a href="https://man.page/2/shmat">shmat(2)</a> or <a href="https://man.page/2/mmap">mmap(2)</a> with the
<b>MAP_SHARED</b> flag. Nor does this restriction apply when
the memory buffer has been advised as <b>MADV_DONTFORK</b>
with <a href="https://man.page/2/madvise">madvise(2)</a>, ensuring that it will not be
available to the child after <a href="https://man.page/2/fork">fork(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>O_DIRECT</b> flag was introduced in SGI IRIX, where it
has alignment restrictions similar to those of Linux 2.4.
IRIX has also a <a href="https://man.page/2/fcntl">fcntl(2)</a> call to query appropriate
alignments, and sizes. FreeBSD 4.x introduced a flag of the
same name, but without alignment restrictions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>O_DIRECT</b>
support was added under Linux in kernel version 2.4.10.
Older Linux kernels simply ignore this flag. Some
filesystems may not implement the flag, in which case
<b>open</b>() fails with the error <b>EINVAL</b> if it is
used.</p>

<p style="margin-left:11%; margin-top: 1em">Applications
should avoid mixing <b>O_DIRECT</b> and normal I/O to the
same file, and especially to overlapping byte regions in the
same file. Even when the filesystem correctly handles the
coherency issues in this situation, overall I/O throughput
is likely to be slower than using either mode alone.
Likewise, applications should avoid mixing <a href="https://man.page/2/mmap">mmap(2)</a> of
files with direct I/O to the same files.</p>

<p style="margin-left:11%; margin-top: 1em">The behavior of
<b>O_DIRECT</b> with NFS will differ from local filesystems.
Older kernels, or kernels configured in certain ways, may
not support this combination. The NFS protocol does not
support passing the flag to the server, so <b>O_DIRECT</b>
I/O will bypass the page cache only on the client; the
server may still cache the I/O. The client asks the server
to make the I/O synchronous to preserve the synchronous
semantics of <b>O_DIRECT</b>. Some servers will perform
poorly under these circumstances, especially if the I/O size
is small. Some servers may also be configured to lie to
clients about the I/O having reached stable storage; this
will avoid the performance penalty at some risk to data
integrity in the event of server power failure. The Linux
NFS client places no alignment restrictions on
<b>O_DIRECT</b> I/O.</p>

<p style="margin-left:11%; margin-top: 1em">In summary,
<b>O_DIRECT</b> is a potentially powerful tool that should
be used with caution. It is recommended that applications
treat use of <b>O_DIRECT</b> as a performance option which
is disabled by default.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Currently, it
is not possible to enable signal-driven I/O by specifying
<b>O_ASYNC</b> when calling <b>open</b>(); use
<a href="https://man.page/2/fcntl">fcntl(2)</a> to enable this flag.</p>

<p style="margin-left:11%; margin-top: 1em">One must check
for two different error codes, <b>EISDIR</b> and
<b>ENOENT</b>, when trying to determine whether the kernel
supports <b>O_TMPFILE</b> functionality.</p>

<p style="margin-left:11%; margin-top: 1em">When both
<b>O_CREAT</b> and <b>O_DIRECTORY</b> are specified in
<i>flags</i> and the file specified by <i>pathname</i> does
not exist, <b>open</b>() will create a regular file (i.e.,
<b>O_DIRECTORY</b> is ignored).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/chmod">chmod(2)</a>,
<a href="https://man.page/2/chown">chown(2)</a>, <a href="https://man.page/2/close">close(2)</a>, <a href="https://man.page/2/dup">dup(2)</a>,
<a href="https://man.page/2/fcntl">fcntl(2)</a>, <a href="https://man.page/2/link">link(2)</a>, <a href="https://man.page/2/lseek">lseek(2)</a>,
<a href="https://man.page/2/mknod">mknod(2)</a>, <a href="https://man.page/2/mmap">mmap(2)</a>, <a href="https://man.page/2/mount">mount(2)</a>,
<a href="https://man.page/2/open_by_handle_at">open_by_handle_at(2)</a>, <a href="https://man.page/2/openat2">openat2(2)</a>,
<a href="https://man.page/2/read">read(2)</a>, <a href="https://man.page/2/socket">socket(2)</a>, <a href="https://man.page/2/stat">stat(2)</a>,
<a href="https://man.page/2/umask">umask(2)</a>, <a href="https://man.page/2/unlink">unlink(2)</a>, <a href="https://man.page/2/write">write(2)</a>,
<a href="https://man.page/3/fopen">fopen(3)</a>, <a href="https://man.page/5/acl">acl(5)</a>, <a href="https://man.page/7/fifo">fifo(7)</a>,
<a href="https://man.page/7/inode">inode(7)</a>, <a href="https://man.page/7/path_resolution">path_resolution(7)</a>,
<a href="https://man.page/7/symlink">symlink(7)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
