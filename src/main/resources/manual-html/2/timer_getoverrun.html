<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:05 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TIMER_GETOVERRUN</title>

</head>
<body>

<h1 align="center">TIMER_GETOVERRUN</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">timer_getoverrun
- get overrun count for a POSIX per-process timer</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;time.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
timer_getoverrun(timer_t</b> <i>timerid</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">Link with
<i>-lrt</i>.</p>

<p style="margin-left:5%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<a href="https://man.page/7/feature_test_macros">feature_test_macros(7)</a>):</p>


<p style="margin-left:11%; margin-top: 1em"><b>timer_getoverrun</b>():
_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;199309L</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>timer_getoverrun</b>()
returns the &quot;overrun count&quot; for the timer referred
to by <i>timerid</i>. An application can use the overrun
count to accurately calculate the number of timer
expirations that would have occurred over a given time
interval. Timer overruns can occur both when receiving
expiration notifications via signals (<b>SIGEV_SIGNAL</b>),
and via threads (<b>SIGEV_THREAD</b>).</p>

<p style="margin-left:11%; margin-top: 1em">When expiration
notifications are delivered via a signal, overruns can occur
as follows. Regardless of whether or not a real-time signal
is used for timer notifications, the system queues at most
one signal per timer. (This is the behavior specified by
POSIX.1. The alternative, queuing one signal for each timer
expiration, could easily result in overflowing the allowed
limits for queued signals on the system.) Because of system
scheduling delays, or because the signal may be temporarily
blocked, there can be a delay between the time when the
notification signal is generated and the time when it is
delivered (e.g., caught by a signal handler) or accepted
(e.g., using <a href="https://man.page/2/sigwaitinfo">sigwaitinfo(2)</a>). In this interval,
further timer expirations may occur. The timer overrun count
is the number of additional timer expirations that occurred
between the time when the signal was generated and when it
was delivered or accepted.</p>

<p style="margin-left:11%; margin-top: 1em">Timer overruns
can also occur when expiration notifications are delivered
via invocation of a thread, since there may be an arbitrary
delay between an expiration of the timer and the invocation
of the notification thread, and in that delay interval,
additional timer expirations may occur.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
<b>timer_getoverrun</b>() returns the overrun count of the
specified timer; this count may be 0 if no overruns have
occurred. On failure, -1 is returned, and <i>errno</i> is
set to indicate the error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><i>timerid</i> is not a valid
timer ID.</p></td>
<td width="29%">
</td></tr>
</table>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This system
call is available since Linux 2.6.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1-2001,
POSIX.1-2008.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When timer
notifications are delivered via signals
(<b>SIGEV_SIGNAL</b>), on Linux it is also possible to
obtain the overrun count via the <i>si_overrun</i> field of
the <i>siginfo_t</i> structure (see <a href="https://man.page/2/sigaction">sigaction(2)</a>).
This allows an application to avoid the overhead of making a
system call to obtain the overrun count, but is a
nonportable extension to POSIX.1.</p>

<p style="margin-left:11%; margin-top: 1em">POSIX.1
discusses timer overruns only in the context of timer
notifications using signals.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1
specifies that if the timer overrun count is equal to or
greater than an implementation-defined maximum,
<b>DELAYTIMER_MAX</b>, then <b>timer_getoverrun</b>() should
return <b>DELAYTIMER_MAX</b>. However, before Linux 4.19, if
the timer overrun value exceeds the maximum representable
integer, the counter cycles, starting once more from low
values. Since Linux 4.19, <b>timer_getoverrun</b>() returns
<b>DELAYTIMER_MAX</b> (defined as <b>INT_MAX</b> in
<i>&lt;limits.h&gt;</i>) in this case (and the overrun value
is reset to 0).</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<a href="https://man.page/2/timer_create">timer_create(2)</a>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/clock_gettime">clock_gettime(2)</a>,
<a href="https://man.page/2/sigaction">sigaction(2)</a>, <a href="https://man.page/2/signalfd">signalfd(2)</a>,
<a href="https://man.page/2/sigwaitinfo">sigwaitinfo(2)</a>, <a href="https://man.page/2/timer_create">timer_create(2)</a>,
<a href="https://man.page/2/timer_delete">timer_delete(2)</a>, <a href="https://man.page/2/timer_settime">timer_settime(2)</a>,
<a href="https://man.page/7/signal">signal(7)</a>, <a href="https://man.page/7/time">time(7)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
