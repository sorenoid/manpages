<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:09 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FUTEX</title>

</head>
<body>

<h1 align="center">FUTEX</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">futex - fast
user-space locking</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;linux/futex.h&gt; <br>
#include &lt;stdint.h&gt; <br>
#include &lt;sys/time.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>long
futex(uint32_t *</b><i>uaddr</i><b>, int</b>
<i>futex_op</i><b>, uint32_t</b> <i>val</i><b>, <br>
const struct timespec *</b><i>timeout</i><b>,</b> /* or:
<b>uint32_t</b> <i>val2</i> <b>*/ <br>
uint32_t *</b><i>uaddr2</i><b>, uint32_t</b>
<i>val3</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>Note</i>:
There is no glibc wrapper for this system call; see
NOTES.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>futex</b>() system call provides a method for waiting
until a certain condition becomes true. It is typically used
as a blocking construct in the context of shared-memory
synchronization. When using futexes, the majority of the
synchronization operations are performed in user space. A
user-space program employs the <b>futex</b>() system call
only when it is likely that the program has to block for a
longer time until the condition becomes true. Other
<b>futex</b>() operations can be used to wake any processes
or threads waiting for a particular condition.</p>

<p style="margin-left:11%; margin-top: 1em">A futex is a
32-bit value&mdash;referred to below as a <i>futex
word</i>&mdash;whose address is supplied to the
<b>futex</b>() system call. (Futexes are 32 bits in size on
all platforms, including 64-bit systems.) All futex
operations are governed by this value. In order to share a
futex between processes, the futex is placed in a region of
shared memory, created using (for example) <b>mmap</b>(2) or
<b>shmat</b>(2). (Thus, the futex word may have different
virtual addresses in different processes, but these
addresses all refer to the same location in physical
memory.) In a multithreaded program, it is sufficient to
place the futex word in a global variable shared by all
threads.</p>

<p style="margin-left:11%; margin-top: 1em">When executing
a futex operation that requests to block a thread, the
kernel will block only if the futex word has the value that
the calling thread supplied (as one of the arguments of the
<b>futex</b>() call) as the expected value of the futex
word. The loading of the futex word&rsquo;s value, the
comparison of that value with the expected value, and the
actual blocking will happen atomically and will be totally
ordered with respect to concurrent operations performed by
other threads on the same futex word. Thus, the futex word
is used to connect the synchronization in user space with
the implementation of blocking by the kernel. Analogously to
an atomic compare-and-exchange operation that potentially
changes shared memory, blocking via a futex is an atomic
compare-and-block operation.</p>

<p style="margin-left:11%; margin-top: 1em">One use of
futexes is for implementing locks. The state of the lock
(i.e., acquired or not acquired) can be represented as an
atomically accessed flag in shared memory. In the
uncontended case, a thread can access or modify the lock
state with atomic instructions, for example atomically
changing it from not acquired to acquired using an atomic
compare-and-exchange instruction. (Such instructions are
performed entirely in user mode, and the kernel maintains no
information about the lock state.) On the other hand, a
thread may be unable to acquire a lock because it is already
acquired by another thread. It then may pass the
lock&rsquo;s flag as a futex word and the value representing
the acquired state as the expected value to a <b>futex</b>()
wait operation. This <b>futex</b>() operation will block if
and only if the lock is still acquired (i.e., the value in
the futex word still matches the &quot;acquired
state&quot;). When releasing the lock, a thread has to first
reset the lock state to not acquired and then execute a
futex operation that wakes threads blocked on the lock flag
used as a futex word (this can be further optimized to avoid
unnecessary wake-ups). See <b>futex</b>(7) for more detail
on how to use futexes.</p>

<p style="margin-left:11%; margin-top: 1em">Besides the
basic wait and wake-up futex functionality, there are
further futex operations aimed at supporting more complex
use cases.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
explicit initialization or destruction is necessary to use
futexes; the kernel maintains a futex (i.e., the
kernel-internal implementation artifact) only while
operations such as <b>FUTEX_WAIT</b>, described below, are
being performed on a particular futex word.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Arguments</b>
<br>
The <i>uaddr</i> argument points to the futex word. On all
platforms, futexes are four-byte integers that must be
aligned on a four-byte boundary. The operation to perform on
the futex is specified in the <i>futex_op</i> argument;
<i>val</i> is a value whose meaning and purpose depends on
<i>futex_op</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The remaining
arguments (<i>timeout</i>, <i>uaddr2</i>, and <i>val3</i>)
are required only for certain of the futex operations
described below. Where one of these arguments is not
required, it is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">For several
blocking operations, the <i>timeout</i> argument is a
pointer to a <i>timespec</i> structure that specifies a
timeout for the operation. However, notwithstanding the
prototype shown above, for some operations, the least
significant four bytes of this argument are instead used as
an integer whose meaning is determined by the operation. For
these operations, the kernel casts the <i>timeout</i> value
first to <i>unsigned long</i>, then to <i>uint32_t</i>, and
in the remainder of this page, this argument is referred to
as <i>val2</i> when interpreted in this fashion.</p>

<p style="margin-left:11%; margin-top: 1em">Where it is
required, the <i>uaddr2</i> argument is a pointer to a
second futex word that is employed by the operation.</p>

<p style="margin-left:11%; margin-top: 1em">The
interpretation of the final integer argument, <i>val3</i>,
depends on the operation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Futex
operations</b> <br>
The <i>futex_op</i> argument consists of two parts: a
command that specifies the operation to be performed,
bitwise ORed with zero or more options that modify the
behaviour of the operation. The options that may be included
in <i>futex_op</i> are as follows: <b><br>
FUTEX_PRIVATE_FLAG</b> (since Linux 2.6.22)</p>

<p style="margin-left:22%;">This option bit can be employed
with all futex operations. It tells the kernel that the
futex is process-private and not shared with another process
(i.e., it is being used for synchronization only between
threads of the same process). This allows the kernel to make
some additional performance optimizations.</p>

<p style="margin-left:22%; margin-top: 1em">As a
convenience, <i>&lt;linux/futex.h&gt;</i> defines a set of
constants with the suffix <b>_PRIVATE</b> that are
equivalents of all of the operations listed below, but with
the <b>FUTEX_PRIVATE_FLAG</b> ORed into the constant value.
Thus, there are <b>FUTEX_WAIT_PRIVATE</b>,
<b>FUTEX_WAKE_PRIVATE</b>, and so on.</p>

<p style="margin-left:11%;"><b>FUTEX_CLOCK_REALTIME</b>
(since Linux 2.6.28)</p>

<p style="margin-left:22%;">This option bit can be employed
only with the <b>FUTEX_WAIT_BITSET</b>,
<b>FUTEX_WAIT_REQUEUE_PI</b>, and (since Linux 4.5)
<b>FUTEX_WAIT</b> operations.</p>

<p style="margin-left:22%; margin-top: 1em">If this option
is set, the kernel measures the <i>timeout</i> against the
<b>CLOCK_REALTIME</b> clock.</p>

<p style="margin-left:22%; margin-top: 1em">If this option
is not set, the kernel measures the <i>timeout</i> against
the <b>CLOCK_MONOTONIC</b> clock.</p>

<p style="margin-left:11%; margin-top: 1em">The operation
specified in <i>futex_op</i> is one of the following:
<b><br>
FUTEX_WAIT</b> (since Linux 2.6.0)</p>

<p style="margin-left:22%;">This operation tests that the
value at the futex word pointed to by the address
<i>uaddr</i> still contains the expected value <i>val</i>,
and if so, then sleeps waiting for a <b>FUTEX_WAKE</b>
operation on the futex word. The load of the value of the
futex word is an atomic memory access (i.e., using atomic
machine instructions of the respective architecture). This
load, the comparison with the expected value, and starting
to sleep are performed atomically and totally ordered with
respect to other futex operations on the same futex word. If
the thread starts to sleep, it is considered a waiter on
this futex word. If the futex value does not match
<i>val</i>, then the call fails immediately with the error
<b>EAGAIN</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The purpose of
the comparison with the expected value is to prevent lost
wake-ups. If another thread changed the value of the futex
word after the calling thread decided to block based on the
prior value, and if the other thread executed a
<b>FUTEX_WAKE</b> operation (or similar wake-up) after the
value change and before this <b>FUTEX_WAIT</b> operation,
then the calling thread will observe the value change and
will not start to sleep.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<i>timeout</i> is not NULL, the structure it points to
specifies a timeout for the wait. (This interval will be
rounded up to the system clock granularity, and is
guaranteed not to expire early.) The timeout is by default
measured according to the <b>CLOCK_MONOTONIC</b> clock, but,
since Linux 4.5, the <b>CLOCK_REALTIME</b> clock can be
selected by specifying <b>FUTEX_CLOCK_REALTIME</b> in
<i>futex_op</i>. If <i>timeout</i> is NULL, the call blocks
indefinitely.</p>

<p style="margin-left:22%; margin-top: 1em"><i>Note</i>:
for <b>FUTEX_WAIT</b>, <i>timeout</i> is interpreted as a
<i>relative</i> value. This differs from other futex
operations, where <i>timeout</i> is interpreted as an
absolute value. To obtain the equivalent of
<b>FUTEX_WAIT</b> with an absolute timeout, employ
<b>FUTEX_WAIT_BITSET</b> with <i>val3</i> specified as
<b>FUTEX_BITSET_MATCH_ANY</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The arguments
<i>uaddr2</i> and <i>val3</i> are ignored.</p>

<p style="margin-left:11%;"><b>FUTEX_WAKE</b> (since Linux
2.6.0)</p>

<p style="margin-left:22%;">This operation wakes at most
<i>val</i> of the waiters that are waiting (e.g., inside
<b>FUTEX_WAIT</b>) on the futex word at the address
<i>uaddr</i>. Most commonly, <i>val</i> is specified as
either 1 (wake up a single waiter) or <b>INT_MAX</b> (wake
up all waiters). No guarantee is provided about which
waiters are awoken (e.g., a waiter with a higher scheduling
priority is not guaranteed to be awoken in preference to a
waiter with a lower priority).</p>

<p style="margin-left:22%; margin-top: 1em">The arguments
<i>timeout</i>, <i>uaddr2</i>, and <i>val3</i> are
ignored.</p>

<p style="margin-left:11%;"><b>FUTEX_FD</b> (from Linux
2.6.0 up to and including Linux 2.6.25)</p>

<p style="margin-left:22%;">This operation creates a file
descriptor that is associated with the futex at
<i>uaddr</i>. The caller must close the returned file
descriptor after use. When another process or thread
performs a <b>FUTEX_WAKE</b> on the futex word, the file
descriptor indicates as being readable with
<b>select</b>(2), <b>poll</b>(2), and <b>epoll</b>(7)</p>

<p style="margin-left:22%; margin-top: 1em">The file
descriptor can be used to obtain asynchronous notifications:
if <i>val</i> is nonzero, then, when another process or
thread executes a <b>FUTEX_WAKE</b>, the caller will receive
the signal number that was passed in <i>val</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The arguments
<i>timeout</i>, <i>uaddr2</i>, and <i>val3</i> are
ignored.</p>

<p style="margin-left:22%; margin-top: 1em">Because it was
inherently racy, <b>FUTEX_FD</b> has been removed from Linux
2.6.26 onward.</p>

<p style="margin-left:11%;"><b>FUTEX_REQUEUE</b> (since
Linux 2.6.0)</p>

<p style="margin-left:22%;">This operation performs the
same task as <b>FUTEX_CMP_REQUEUE</b> (see below), except
that no check is made using the value in <i>val3</i>. (The
argument <i>val3</i> is ignored.)</p>

<p style="margin-left:11%;"><b>FUTEX_CMP_REQUEUE</b> (since
Linux 2.6.7)</p>

<p style="margin-left:22%;">This operation first checks
whether the location <i>uaddr</i> still contains the value
<i>val3</i>. If not, the operation fails with the error
<b>EAGAIN</b>. Otherwise, the operation wakes up a maximum
of <i>val</i> waiters that are waiting on the futex at
<i>uaddr</i>. If there are more than <i>val</i> waiters,
then the remaining waiters are removed from the wait queue
of the source futex at <i>uaddr</i> and added to the wait
queue of the target futex at <i>uaddr2</i>. The <i>val2</i>
argument specifies an upper limit on the number of waiters
that are requeued to the futex at <i>uaddr2</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The load from
<i>uaddr</i> is an atomic memory access (i.e., using atomic
machine instructions of the respective architecture). This
load, the comparison with <i>val3</i>, and the requeueing of
any waiters are performed atomically and totally ordered
with respect to other operations on the same futex word.</p>

<p style="margin-left:22%; margin-top: 1em">Typical values
to specify for <i>val</i> are 0 or 1. (Specifying
<b>INT_MAX</b> is not useful, because it would make the
<b>FUTEX_CMP_REQUEUE</b> operation equivalent to
<b>FUTEX_WAKE</b>.) The limit value specified via
<i>val2</i> is typically either 1 or <b>INT_MAX</b>.
(Specifying the argument as 0 is not useful, because it
would make the <b>FUTEX_CMP_REQUEUE</b> operation equivalent
to <b>FUTEX_WAIT</b>.)</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>FUTEX_CMP_REQUEUE</b> operation was added as a
replacement for the earlier <b>FUTEX_REQUEUE</b>. The
difference is that the check of the value at <i>uaddr</i>
can be used to ensure that requeueing happens only under
certain conditions, which allows race conditions to be
avoided in certain use cases.</p>

<p style="margin-left:22%; margin-top: 1em">Both
<b>FUTEX_REQUEUE</b> and <b>FUTEX_CMP_REQUEUE</b> can be
used to avoid &quot;thundering herd&quot; wake-ups that
could occur when using <b>FUTEX_WAKE</b> in cases where all
of the waiters that are woken need to acquire another futex.
Consider the following scenario, where multiple waiter
threads are waiting on B, a wait queue implemented using a
futex:</p>

<p style="margin-left:28%; margin-top: 1em">lock(A) <br>
while (!check_value(V)) { <br>
unlock(A); <br>
block_on(B); <br>
lock(A); <br>
}; <br>
unlock(A);</p>

<p style="margin-left:22%; margin-top: 1em">If a waker
thread used <b>FUTEX_WAKE</b>, then all waiters waiting on B
would be woken up, and they would all try to acquire lock A.
However, waking all of the threads in this manner would be
pointless because all except one of the threads would
immediately block on lock A again. By contrast, a requeue
operation wakes just one waiter and moves the other waiters
to lock A, and when the woken waiter unlocks A then the next
waiter can proceed.</p>

<p style="margin-left:11%;"><b>FUTEX_WAKE_OP</b> (since
Linux 2.6.14)</p>

<p style="margin-left:22%;">This operation was added to
support some user-space use cases where more than one futex
must be handled at the same time. The most notable example
is the implementation of <b>pthread_cond_signal</b>(3),
which requires operations on two futexes, the one used to
implement the mutex and the one used in the implementation
of the wait queue associated with the condition variable.
<b>FUTEX_WAKE_OP</b> allows such cases to be implemented
without leading to high rates of contention and context
switching.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>FUTEX_WAKE_OP</b> operation is equivalent to executing
the following code atomically and totally ordered with
respect to other futex operations on any of the two supplied
futex words:</p>

<p style="margin-left:28%; margin-top: 1em">uint32_t oldval
= *(uint32_t *) uaddr2; <br>
*(uint32_t *) uaddr2 = oldval <i>op oparg</i>; <br>
futex(uaddr, FUTEX_WAKE, val, 0, 0, 0); <br>
if (oldval <i>cmp cmparg</i>) <br>
futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);</p>

<p style="margin-left:22%; margin-top: 1em">In other words,
<b>FUTEX_WAKE_OP</b> does the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>saves the original value of the futex word at
<i>uaddr2</i> and performs an operation to modify the value
of the futex at <i>uaddr2</i>; this is an atomic
read-modify-write memory access (i.e., using atomic machine
instructions of the respective architecture)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>wakes up a maximum of <i>val</i> waiters on the futex
for the futex word at <i>uaddr</i>; and</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>dependent on the results of a test of the original value
of the futex word at <i>uaddr2</i>, wakes up a maximum of
<i>val2</i> waiters on the futex for the futex word at
<i>uaddr2</i>.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The operation
and comparison that are to be performed are encoded in the
bits of the argument <i>val3</i>. Pictorially, the encoding
is:</p>


<p style="margin-left:28%; margin-top: 1em">+---+---+-----------+-----------+
<br>
|op |cmp| oparg | cmparg | <br>
+---+---+-----------+-----------+ <br>
4 4 12 12 &lt;== # of bits</p>

<p style="margin-left:22%; margin-top: 1em">Expressed in
code, the encoding is:</p>

<p style="margin-left:28%; margin-top: 1em">#define
FUTEX_OP(op, oparg, cmp, cmparg) \ <br>
(((op &amp; 0xf) &lt;&lt; 28) | \ <br>
((cmp &amp; 0xf) &lt;&lt; 24) | \ <br>
((oparg &amp; 0xfff) &lt;&lt; 12) | \ <br>
(cmparg &amp; 0xfff))</p>

<p style="margin-left:22%; margin-top: 1em">In the above,
<i>op</i> and <i>cmp</i> are each one of the codes listed
below. The <i>oparg</i> and <i>cmparg</i> components are
literal numeric values, except as noted below.</p>

<p style="margin-left:22%; margin-top: 1em">The <i>op</i>
component has one of the following values:</p>

<p style="margin-left:28%; margin-top: 1em">FUTEX_OP_SET 0
/* uaddr2 = oparg; */ <br>
FUTEX_OP_ADD 1 /* uaddr2 += oparg; */ <br>
FUTEX_OP_OR 2 /* uaddr2 |= oparg; */ <br>
FUTEX_OP_ANDN 3 /* uaddr2 &amp;= ~oparg; */ <br>
FUTEX_OP_XOR 4 /* uaddr2 ^= oparg; */</p>

<p style="margin-left:22%; margin-top: 1em">In addition,
bitwise ORing the following value into <i>op</i> causes
<i>(1&nbsp;&lt;&lt;&nbsp;oparg)</i> to be used as the
operand:</p>


<p style="margin-left:28%; margin-top: 1em">FUTEX_OP_ARG_SHIFT
8 /* Use (1 &lt;&lt; oparg) as operand */</p>

<p style="margin-left:22%; margin-top: 1em">The <i>cmp</i>
field is one of the following:</p>


<p style="margin-left:28%; margin-top: 1em">FUTEX_OP_CMP_EQ
0 /* if (oldval == cmparg) wake */ <br>
FUTEX_OP_CMP_NE 1 /* if (oldval != cmparg) wake */ <br>
FUTEX_OP_CMP_LT 2 /* if (oldval &lt; cmparg) wake */ <br>
FUTEX_OP_CMP_LE 3 /* if (oldval &lt;= cmparg) wake */ <br>
FUTEX_OP_CMP_GT 4 /* if (oldval &gt; cmparg) wake */ <br>
FUTEX_OP_CMP_GE 5 /* if (oldval &gt;= cmparg) wake */</p>

<p style="margin-left:22%; margin-top: 1em">The return
value of <b>FUTEX_WAKE_OP</b> is the sum of the number of
waiters woken on the futex <i>uaddr</i> plus the number of
waiters woken on the futex <i>uaddr2</i>.</p>

<p style="margin-left:11%;"><b>FUTEX_WAIT_BITSET</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">This operation is like
<b>FUTEX_WAIT</b> except that <i>val3</i> is used to provide
a 32-bit bit mask to the kernel. This bit mask, in which at
least one bit must be set, is stored in the kernel-internal
state of the waiter. See the description of
<b>FUTEX_WAKE_BITSET</b> for further details.</p>

<p style="margin-left:22%; margin-top: 1em">If
<i>timeout</i> is not NULL, the structure it points to
specifies an absolute timeout for the wait operation. If
<i>timeout</i> is NULL, the operation can block
indefinitely.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>uaddr2</i> argument is ignored.</p>

<p style="margin-left:11%;"><b>FUTEX_WAKE_BITSET</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">This operation is the same as
<b>FUTEX_WAKE</b> except that the <i>val3</i> argument is
used to provide a 32-bit bit mask to the kernel. This bit
mask, in which at least one bit must be set, is used to
select which waiters should be woken up. The selection is
done by a bitwise AND of the &quot;wake&quot; bit mask
(i.e., the value in <i>val3</i>) and the bit mask which is
stored in the kernel-internal state of the waiter (the
&quot;wait&quot; bit mask that is set using
<b>FUTEX_WAIT_BITSET</b>). All of the waiters for which the
result of the AND is nonzero are woken up; the remaining
waiters are left sleeping.</p>

<p style="margin-left:22%; margin-top: 1em">The effect of
<b>FUTEX_WAIT_BITSET</b> and <b>FUTEX_WAKE_BITSET</b> is to
allow selective wake-ups among multiple waiters that are
blocked on the same futex. However, note that, depending on
the use case, employing this bit-mask multiplexing feature
on a futex can be less efficient than simply using multiple
futexes, because employing bit-mask multiplexing requires
the kernel to check all waiters on a futex, including those
that are not interested in being woken up (i.e., they do not
have the relevant bit set in their &quot;wait&quot; bit
mask).</p>

<p style="margin-left:22%; margin-top: 1em">The constant
<b>FUTEX_BITSET_MATCH_ANY</b>, which corresponds to all 32
bits set in the bit mask, can be used as the <i>val3</i>
argument for <b>FUTEX_WAIT_BITSET</b> and
<b>FUTEX_WAKE_BITSET</b>. Other than differences in the
handling of the <i>timeout</i> argument, the
<b>FUTEX_WAIT</b> operation is equivalent to
<b>FUTEX_WAIT_BITSET</b> with <i>val3</i> specified as
<b>FUTEX_BITSET_MATCH_ANY</b>; that is, allow a wake-up by
any waker. The <b>FUTEX_WAKE</b> operation is equivalent to
<b>FUTEX_WAKE_BITSET</b> with <i>val3</i> specified as
<b>FUTEX_BITSET_MATCH_ANY</b>; that is, wake up any
waiter(s).</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>uaddr2</i> and <i>timeout</i> arguments are ignored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Priority-inheritance
futexes</b> <br>
Linux supports priority-inheritance (PI) futexes in order to
handle priority-inversion problems that can be encountered
with normal futex locks. Priority inversion is the problem
that occurs when a high-priority task is blocked waiting to
acquire a lock held by a low-priority task, while tasks at
an intermediate priority continuously preempt the
low-priority task from the CPU. Consequently, the
low-priority task makes no progress toward releasing the
lock, and the high-priority task remains blocked.</p>

<p style="margin-left:11%; margin-top: 1em">Priority
inheritance is a mechanism for dealing with the
priority-inversion problem. With this mechanism, when a
high-priority task becomes blocked by a lock held by a
low-priority task, the priority of the low-priority task is
temporarily raised to that of the high-priority task, so
that it is not preempted by any intermediate level tasks,
and can thus make progress toward releasing the lock. To be
effective, priority inheritance must be transitive, meaning
that if a high-priority task blocks on a lock held by a
lower-priority task that is itself blocked by a lock held by
another intermediate-priority task (and so on, for chains of
arbitrary length), then both of those tasks (or more
generally, all of the tasks in a lock chain) have their
priorities raised to be the same as the high-priority
task.</p>

<p style="margin-left:11%; margin-top: 1em">From a
user-space perspective, what makes a futex PI-aware is a
policy agreement (described below) between user space and
the kernel about the value of the futex word, coupled with
the use of the PI-futex operations described below. (Unlike
the other futex operations described above, the PI-futex
operations are designed for the implementation of very
specific IPC mechanisms.)</p>

<p style="margin-left:11%; margin-top: 1em">The PI-futex
operations described below differ from the other futex
operations in that they impose policy on the use of the
value of the futex word:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the lock is not acquired, the futex word&rsquo;s
value shall be 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the lock is acquired, the futex word&rsquo;s value
shall be the thread ID (TID; see <b>gettid</b>(2)) of the
owning thread.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the lock is owned and there are threads contending
for the lock, then the <b>FUTEX_WAITERS</b> bit shall be set
in the futex word&rsquo;s value; in other words, this value
is:</p> </td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">FUTEX_WAITERS |
TID</p>

<p style="margin-left:15%; margin-top: 1em">(Note that is
invalid for a PI futex word to have no owner and
<b>FUTEX_WAITERS</b> set.)</p>

<p style="margin-left:11%; margin-top: 1em">With this
policy in place, a user-space application can acquire an
unacquired lock or release a lock using atomic instructions
executed in user mode (e.g., a compare-and-swap operation
such as <i>cmpxchg</i> on the x86 architecture). Acquiring a
lock simply consists of using compare-and-swap to atomically
set the futex word&rsquo;s value to the caller&rsquo;s TID
if its previous value was 0. Releasing a lock requires using
compare-and-swap to set the futex word&rsquo;s value to 0 if
the previous value was the expected TID.</p>

<p style="margin-left:11%; margin-top: 1em">If a futex is
already acquired (i.e., has a nonzero value), waiters must
employ the <b>FUTEX_LOCK_PI</b> operation to acquire the
lock. If other threads are waiting for the lock, then the
<b>FUTEX_WAITERS</b> bit is set in the futex value; in this
case, the lock owner must employ the <b>FUTEX_UNLOCK_PI</b>
operation to release the lock.</p>

<p style="margin-left:11%; margin-top: 1em">In the cases
where callers are forced into the kernel (i.e., required to
perform a <b>futex</b>() call), they then deal directly with
a so-called RT-mutex, a kernel locking mechanism which
implements the required priority-inheritance semantics.
After the RT-mutex is acquired, the futex value is updated
accordingly, before the calling thread returns to user
space.</p>

<p style="margin-left:11%; margin-top: 1em">It is important
to note that the kernel will update the futex word&rsquo;s
value prior to returning to user space. (This prevents the
possibility of the futex word&rsquo;s value ending up in an
invalid state, such as having an owner but the value being
0, or having waiters but not having the <b>FUTEX_WAITERS</b>
bit set.)</p>

<p style="margin-left:11%; margin-top: 1em">If a futex has
an associated RT-mutex in the kernel (i.e., there are
blocked waiters) and the owner of the futex/RT-mutex dies
unexpectedly, then the kernel cleans up the RT-mutex and
hands it over to the next waiter. This in turn requires that
the user-space value is updated accordingly. To indicate
that this is required, the kernel sets the
<b>FUTEX_OWNER_DIED</b> bit in the futex word along with the
thread ID of the new owner. User space can detect this
situation via the presence of the <b>FUTEX_OWNER_DIED</b>
bit and is then responsible for cleaning up the stale state
left over by the dead owner.</p>

<p style="margin-left:11%; margin-top: 1em">PI futexes are
operated on by specifying one of the values listed below in
<i>futex_op</i>. Note that the PI futex operations must be
used as paired operations and are subject to some additional
requirements:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em"><b>FUTEX_LOCK_PI</b> and
<b>FUTEX_TRYLOCK_PI</b> pair with <b>FUTEX_UNLOCK_PI</b>.
<b>FUTEX_UNLOCK_PI</b> must be called only on a futex owned
by the calling thread, as defined by the value policy,
otherwise the error <b>EPERM</b> results.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>FUTEX_WAIT_REQUEUE_PI</b> pairs with
<b>FUTEX_CMP_REQUEUE_PI</b>. This must be performed from a
non-PI futex to a distinct PI futex (or the error
<b>EINVAL</b> results). Additionally, <i>val</i> (the number
of waiters to be woken) must be 1 (or the error
<b>EINVAL</b> results).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The PI futex
operations are as follows: <b><br>
FUTEX_LOCK_PI</b> (since Linux 2.6.18)</p>

<p style="margin-left:22%;">This operation is used after an
attempt to acquire the lock via an atomic user-mode
instruction failed because the futex word has a nonzero
value&mdash;specifically, because it contained the
(PID-namespace-specific) TID of the lock owner.</p>

<p style="margin-left:22%; margin-top: 1em">The operation
checks the value of the futex word at the address
<i>uaddr</i>. If the value is 0, then the kernel tries to
atomically set the futex value to the caller&rsquo;s TID. If
the futex word&rsquo;s value is nonzero, the kernel
atomically sets the <b>FUTEX_WAITERS</b> bit, which signals
the futex owner that it cannot unlock the futex in user
space atomically by setting the futex value to 0. After
that, the kernel:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Tries to find the thread which is associated with the
owner TID.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Creates or reuses kernel state on behalf of the owner.
(If this is the first waiter, there is no kernel state for
this futex, so kernel state is created by locking the
RT-mutex and the futex owner is made the owner of the
RT-mutex. If there are existing waiters, then the existing
state is reused.)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Attaches the waiter to the futex (i.e., the waiter is
enqueued on the RT-mutex waiter list).</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">If more than
one waiter exists, the enqueueing of the waiter is in
descending priority order. (For information on priority
ordering, see the discussion of the <b>SCHED_DEADLINE</b>,
<b>SCHED_FIFO</b>, and <b>SCHED_RR</b> scheduling policies
in <b>sched</b>(7).) The owner inherits either the
waiter&rsquo;s CPU bandwidth (if the waiter is scheduled
under the <b>SCHED_DEADLINE</b> policy) or the
waiter&rsquo;s priority (if the waiter is scheduled under
the <b>SCHED_RR</b> or <b>SCHED_FIFO</b> policy). This
inheritance follows the lock chain in the case of nested
locking and performs deadlock detection.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>timeout</i> argument provides a timeout for the lock
attempt. If <i>timeout</i> is not NULL, the structure it
points to specifies an absolute timeout, measured against
the <b>CLOCK_REALTIME</b> clock. If <i>timeout</i> is NULL,
the operation will block indefinitely.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>uaddr2</i>, <i>val</i>, and <i>val3</i> arguments are
ignored.</p>

<p style="margin-left:11%;"><b>FUTEX_TRYLOCK_PI</b> (since
Linux 2.6.18)</p>

<p style="margin-left:22%;">This operation tries to acquire
the lock at <i>uaddr</i>. It is invoked when a user-space
atomic acquire did not succeed because the futex word was
not 0.</p>

<p style="margin-left:22%; margin-top: 1em">Because the
kernel has access to more state information than user space,
acquisition of the lock might succeed if performed by the
kernel in cases where the futex word (i.e., the state
information accessible to use-space) contains stale state
(<b>FUTEX_WAITERS</b> and/or <b>FUTEX_OWNER_DIED</b>). This
can happen when the owner of the futex died. User space
cannot handle this condition in a race-free manner, but the
kernel can fix this up and acquire the futex.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>uaddr2</i>, <i>val</i>, <i>timeout</i>, and <i>val3</i>
arguments are ignored.</p>

<p style="margin-left:11%;"><b>FUTEX_UNLOCK_PI</b> (since
Linux 2.6.18)</p>

<p style="margin-left:22%;">This operation wakes the top
priority waiter that is waiting in <b>FUTEX_LOCK_PI</b> on
the futex address provided by the <i>uaddr</i> argument.</p>

<p style="margin-left:22%; margin-top: 1em">This is called
when the user-space value at <i>uaddr</i> cannot be changed
atomically from a TID (of the owner) to 0.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>uaddr2</i>, <i>val</i>, <i>timeout</i>, and <i>val3</i>
arguments are ignored.</p>

<p style="margin-left:11%;"><b>FUTEX_CMP_REQUEUE_PI</b>
(since Linux 2.6.31)</p>

<p style="margin-left:22%;">This operation is a PI-aware
variant of <b>FUTEX_CMP_REQUEUE</b>. It requeues waiters
that are blocked via <b>FUTEX_WAIT_REQUEUE_PI</b> on
<i>uaddr</i> from a non-PI source futex (<i>uaddr</i>) to a
PI target futex (<i>uaddr2</i>).</p>

<p style="margin-left:22%; margin-top: 1em">As with
<b>FUTEX_CMP_REQUEUE</b>, this operation wakes up a maximum
of <i>val</i> waiters that are waiting on the futex at
<i>uaddr</i>. However, for <b>FUTEX_CMP_REQUEUE_PI</b>,
<i>val</i> is required to be 1 (since the main point is to
avoid a thundering herd). The remaining waiters are removed
from the wait queue of the source futex at <i>uaddr</i> and
added to the wait queue of the target futex at
<i>uaddr2</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The <i>val2</i>
and <i>val3</i> arguments serve the same purposes as for
<b>FUTEX_CMP_REQUEUE</b>.</p>

<p style="margin-left:11%;"><b>FUTEX_WAIT_REQUEUE_PI</b>
(since Linux 2.6.31)</p>

<p style="margin-left:22%;">Wait on a non-PI futex at
<i>uaddr</i> and potentially be requeued (via a
<b>FUTEX_CMP_REQUEUE_PI</b> operation in another task) onto
a PI futex at <i>uaddr2</i>. The wait operation on
<i>uaddr</i> is the same as for <b>FUTEX_WAIT</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The waiter can
be removed from the wait on <i>uaddr</i> without requeueing
on <i>uaddr2</i> via a <b>FUTEX_WAKE</b> operation in
another task. In this case, the <b>FUTEX_WAIT_REQUEUE_PI</b>
operation fails with the error <b>EAGAIN</b>.</p>

<p style="margin-left:22%; margin-top: 1em">If
<i>timeout</i> is not NULL, the structure it points to
specifies an absolute timeout for the wait operation. If
<i>timeout</i> is NULL, the operation can block
indefinitely.</p>

<p style="margin-left:22%; margin-top: 1em">The <i>val3</i>
argument is ignored.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>FUTEX_WAIT_REQUEUE_PI</b> and <b>FUTEX_CMP_REQUEUE_PI</b>
were added to support a fairly specific use case: support
for priority-inheritance-aware POSIX threads condition
variables. The idea is that these operations should always
be paired, in order to ensure that user space and the kernel
remain in sync. Thus, in the <b>FUTEX_WAIT_REQUEUE_PI</b>
operation, the user-space application pre-specifies the
target of the requeue that takes place in the
<b>FUTEX_CMP_REQUEUE_PI</b> operation.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In the event of
an error (and assuming that <b>futex</b>() was invoked via
<b>syscall</b>(2)), all operations return -1 and set
<i>errno</i> to indicate the cause of the error.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value on success depends on the operation, as described in
the following list: <b><br>
FUTEX_WAIT</b></p>

<p style="margin-left:22%;">Returns 0 if the caller was
woken up. Note that a wake-up can also be caused by common
futex usage patterns in unrelated code that happened to have
previously used the futex word&rsquo;s memory location
(e.g., typical futex-based implementations of Pthreads
mutexes can cause this under some conditions). Therefore,
callers should always conservatively assume that a return
value of 0 can mean a spurious wake-up, and use the futex
word&rsquo;s value (i.e., the user-space synchronization
scheme) to decide whether to continue to block or not.</p>

<p style="margin-left:11%;"><b>FUTEX_WAKE</b></p>

<p style="margin-left:22%;">Returns the number of waiters
that were woken up.</p>

<p style="margin-left:11%;"><b>FUTEX_FD</b></p>

<p style="margin-left:22%;">Returns the new file descriptor
associated with the futex.</p>

<p style="margin-left:11%;"><b>FUTEX_REQUEUE</b></p>

<p style="margin-left:22%;">Returns the number of waiters
that were woken up.</p>

<p style="margin-left:11%;"><b>FUTEX_CMP_REQUEUE</b></p>

<p style="margin-left:22%;">Returns the total number of
waiters that were woken up or requeued to the futex for the
futex word at <i>uaddr2</i>. If this value is greater than
<i>val</i>, then the difference is the number of waiters
requeued to the futex for the futex word at
<i>uaddr2</i>.</p>

<p style="margin-left:11%;"><b>FUTEX_WAKE_OP</b></p>

<p style="margin-left:22%;">Returns the total number of
waiters that were woken up. This is the sum of the woken
waiters on the two futexes for the futex words at
<i>uaddr</i> and <i>uaddr2</i>.</p>

<p style="margin-left:11%;"><b>FUTEX_WAIT_BITSET</b></p>

<p style="margin-left:22%;">Returns 0 if the caller was
woken up. See <b>FUTEX_WAIT</b> for how to interpret this
correctly in practice.</p>

<p style="margin-left:11%;"><b>FUTEX_WAKE_BITSET</b></p>

<p style="margin-left:22%;">Returns the number of waiters
that were woken up.</p>

<p style="margin-left:11%;"><b>FUTEX_LOCK_PI</b></p>

<p style="margin-left:22%;">Returns 0 if the futex was
successfully locked.</p>

<p style="margin-left:11%;"><b>FUTEX_TRYLOCK_PI</b></p>

<p style="margin-left:22%;">Returns 0 if the futex was
successfully locked.</p>

<p style="margin-left:11%;"><b>FUTEX_UNLOCK_PI</b></p>

<p style="margin-left:22%;">Returns 0 if the futex was
successfully unlocked.</p>


<p style="margin-left:11%;"><b>FUTEX_CMP_REQUEUE_PI</b></p>

<p style="margin-left:22%;">Returns the total number of
waiters that were woken up or requeued to the futex for the
futex word at <i>uaddr2</i>. If this value is greater than
<i>val</i>, then difference is the number of waiters
requeued to the futex for the futex word at
<i>uaddr2</i>.</p>


<p style="margin-left:11%;"><b>FUTEX_WAIT_REQUEUE_PI</b></p>

<p style="margin-left:22%;">Returns 0 if the caller was
successfully requeued to the futex for the futex word at
<i>uaddr2</i>.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">No read access to the memory of
a futex word.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_WAIT</b>, <b>FUTEX_WAIT_BITSET</b>,
<b>FUTEX_WAIT_REQUEUE_PI</b>) The value pointed to by
<i>uaddr</i> was not equal to the expected value <i>val</i>
at the time of the call.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em"><b>Note</b>: on
Linux, the symbolic names <b>EAGAIN</b> and
<b>EWOULDBLOCK</b> (both of which appear in different parts
of the kernel futex code) have the same value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">(<b>FUTEX_CMP_REQUEUE</b>,
<b>FUTEX_CMP_REQUEUE_PI</b>) The value pointed to by
<i>uaddr</i> is not equal to the expected value
<i>val3</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,
<b>FUTEX_CMP_REQUEUE_PI</b>) The futex owner thread ID of
<i>uaddr</i> (for <b>FUTEX_CMP_REQUEUE_PI</b>:
<i>uaddr2</i>) is about to exit, but has not yet handled the
internal state cleanup. Try again.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EDEADLK</b></p>

<p style="margin-left:22%;">(<b>FUTEX_LOCK_PI</b>,
<b>FUTEX_TRYLOCK_PI</b>, <b>FUTEX_CMP_REQUEUE_PI</b>) The
futex word at <i>uaddr</i> is already locked by the
caller.</p>

<p style="margin-left:11%;"><b>EDEADLK</b></p>

<p style="margin-left:22%;">(<b>FUTEX_CMP_REQUEUE_PI</b>)
While requeueing a waiter to the PI futex for the futex word
at <i>uaddr2</i>, the kernel detected a deadlock.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A required pointer argument (i.e., <i>uaddr</i>,
<i>uaddr2</i>, or <i>timeout</i>) did not point to a valid
user-space address.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A <b>FUTEX_WAIT</b> or <b>FUTEX_WAIT_BITSET</b>
operation was interrupted by a signal (see
<b>signal</b>(7)). In kernels before Linux 2.6.22, this
error could also be returned for a spurious wakeup; since
Linux 2.6.22, this no longer happens.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The operation in <i>futex_op</i> is one of those that
employs a timeout, but the supplied <i>timeout</i> argument
was invalid (<i>tv_sec</i> was less than zero, or
<i>tv_nsec</i> was not less than 1,000,000,000).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The operation specified in <i>futex_op</i> employs one
or both of the pointers <i>uaddr</i> and <i>uaddr2</i>, but
one of these does not point to a valid object&mdash;that is,
the address is not four-byte-aligned.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_WAIT_BITSET</b>, <b>FUTEX_WAKE_BITSET</b>) The
bit mask supplied in <i>val3</i> is zero.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) <i>uaddr</i> equals
<i>uaddr2</i> (i.e., an attempt was made to requeue to the
same futex).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_FD</b>) The signal number supplied in
<i>val</i> is invalid.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_WAKE</b>, <b>FUTEX_WAKE_OP</b>,
<b>FUTEX_WAKE_BITSET</b>, <b>FUTEX_REQUEUE</b>,
<b>FUTEX_CMP_REQUEUE</b>) The kernel detected an
inconsistency between the user-space state at <i>uaddr</i>
and the kernel state&mdash;that is, it detected a waiter
which waits in <b>FUTEX_LOCK_PI</b> on <i>uaddr</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,
<b>FUTEX_UNLOCK_PI</b>) The kernel detected an inconsistency
between the user-space state at <i>uaddr</i> and the kernel
state. This indicates either state corruption or that the
kernel found a waiter on <i>uaddr</i> which is waiting via
<b>FUTEX_WAIT</b> or <b>FUTEX_WAIT_BITSET</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an
inconsistency between the user-space state at <i>uaddr2</i>
and the kernel state; that is, the kernel detected a waiter
which waits via <b>FUTEX_WAIT</b> or
<b>FUTEX_WAIT_BITSET</b> on <i>uaddr2</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an
inconsistency between the user-space state at <i>uaddr</i>
and the kernel state; that is, the kernel detected a waiter
which waits via <b>FUTEX_WAIT</b> or
<b>FUTEX_WAIT_BITESET</b> on <i>uaddr</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel detected an
inconsistency between the user-space state at <i>uaddr</i>
and the kernel state; that is, the kernel detected a waiter
which waits on <i>uaddr</i> via <b>FUTEX_LOCK_PI</b>
(instead of <b>FUTEX_WAIT_REQUEUE_PI</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) An attempt was made to
requeue a waiter to a futex other than that specified by the
matching <b>FUTEX_WAIT_REQUEUE_PI</b> call for that
waiter.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The <i>val</i> argument is
not 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Invalid argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_FD</b>) The system-wide limit on the total
number of open files has been reached.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,
<b>FUTEX_CMP_REQUEUE_PI</b>) The kernel could not allocate
memory to hold state information.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOSYS</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Invalid operation specified in <i>futex_op</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOSYS</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <b>FUTEX_CLOCK_REALTIME</b> option was specified in
<i>futex_op</i>, but the accompanying operation was neither
<b>FUTEX_WAIT</b>, <b>FUTEX_WAIT_BITSET</b>, nor
<b>FUTEX_WAIT_REQUEUE_PI</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOSYS</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,
<b>FUTEX_UNLOCK_PI</b>, <b>FUTEX_CMP_REQUEUE_PI</b>,
<b>FUTEX_WAIT_REQUEUE_PI</b>) A run-time check determined
that the operation is not available. The PI-futex operations
are not implemented on all architectures and are not
supported on some CPU variants.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,
<b>FUTEX_CMP_REQUEUE_PI</b>) The caller is not allowed to
attach itself to the futex at <i>uaddr</i> (for
<b>FUTEX_CMP_REQUEUE_PI</b>: the futex at <i>uaddr2</i>).
(This may be caused by a state corruption in user
space.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_UNLOCK_PI</b>) The caller does not own the
lock represented by the futex word.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ESRCH</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_LOCK_PI</b>, <b>FUTEX_TRYLOCK_PI</b>,
<b>FUTEX_CMP_REQUEUE_PI</b>) The thread ID in the futex word
at <i>uaddr</i> does not exist.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ESRCH</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(<b>FUTEX_CMP_REQUEUE_PI</b>) The thread ID in the futex
word at <i>uaddr2</i> does not exist.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ETIMEDOUT</b></p>

<p style="margin-left:22%;">The operation in
<i>futex_op</i> employed the timeout specified in
<i>timeout</i>, and the timeout expired before the operation
completed.</p>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Futexes were
first made available in a stable kernel release with Linux
2.6.0.</p>

<p style="margin-left:11%; margin-top: 1em">Initial futex
support was merged in Linux 2.5.7 but with different
semantics from what was described above. A four-argument
system call with the semantics described in this page was
introduced in Linux 2.5.40. A fifth argument was added in
Linux 2.5.70, and a sixth argument was added in Linux
2.6.7.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This system
call is Linux-specific.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Glibc does not
provide a wrapper for this system call; call it using
<b>syscall</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Several
higher-level programming abstractions are implemented via
futexes, including POSIX semaphores and various POSIX
threads synchronization mechanisms (mutexes, condition
variables, read-write locks, and barriers).</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The program
below demonstrates use of futexes in a program where a
parent process and a child process use a pair of futexes
located inside a shared anonymous mapping to synchronize
access to a shared resource: the terminal. The two processes
each write <i>nloops</i> (a command-line argument that
defaults to 5 if omitted) messages to the terminal and
employ a synchronization protocol that ensures that they
alternate in writing messages. Upon running this program we
see output such as the following:</p>

<p style="margin-left:17%; margin-top: 1em">$
<b>./futex_demo</b> <br>
Parent (18534) 0 <br>
Child (18535) 0 <br>
Parent (18534) 1 <br>
Child (18535) 1 <br>
Parent (18534) 2 <br>
Child (18535) 2 <br>
Parent (18534) 3 <br>
Child (18535) 3 <br>
Parent (18534) 4 <br>
Child (18535) 4</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
/* futex_demo.c</p>

<p style="margin-left:11%; margin-top: 1em">Usage:
futex_demo [nloops] <br>
(Default: 5)</p>

<p style="margin-left:11%; margin-top: 1em">Demonstrate the
use of futexes in a program where parent and child <br>
use a pair of futexes located inside a shared anonymous
mapping to <br>
synchronize access to a shared resource: the terminal. The
two <br>
processes each write 'num-loops' messages to the terminal
and employ <br>
a synchronization protocol that ensures that they alternate
in <br>
writing messages. <br>
*/ <br>
#define _GNU_SOURCE <br>
#include &lt;stdio.h&gt; <br>
#include &lt;errno.h&gt; <br>
#include &lt;stdatomic.h&gt; <br>
#include &lt;stdint.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;sys/wait.h&gt; <br>
#include &lt;sys/mman.h&gt; <br>
#include &lt;sys/syscall.h&gt; <br>
#include &lt;linux/futex.h&gt; <br>
#include &lt;sys/time.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">#define
errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \ <br>
} while (0)</p>

<p style="margin-left:11%; margin-top: 1em">static uint32_t
*futex1, *futex2, *iaddr;</p>

<p style="margin-left:11%; margin-top: 1em">static int <br>
futex(uint32_t *uaddr, int futex_op, uint32_t val, <br>
const struct timespec *timeout, uint32_t *uaddr2, uint32_t
val3) <br>
{ <br>
return syscall(SYS_futex, uaddr, futex_op, val, <br>
timeout, uaddr2, val3); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Acquire the
futex pointed to by 'futexp': wait for its value to <br>
become 1, and then set the value to 0. */</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
fwait(uint32_t *futexp) <br>
{ <br>
long s;</p>

<p style="margin-left:11%; margin-top: 1em">/*
atomic_compare_exchange_strong(ptr, oldval, newval) <br>
atomically performs the equivalent of:</p>

<p style="margin-left:11%; margin-top: 1em">if (*ptr ==
*oldval) <br>
*ptr = newval;</p>

<p style="margin-left:11%; margin-top: 1em">It returns true
if the test yielded true and *ptr was updated. */</p>

<p style="margin-left:11%; margin-top: 1em">while (1) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Is the futex
available? */ <br>
const uint32_t one = 1; <br>
if (atomic_compare_exchange_strong(futexp, &amp;one, 0))
<br>
break; /* Yes */</p>

<p style="margin-left:11%; margin-top: 1em">/* Futex is not
available; wait */</p>

<p style="margin-left:11%; margin-top: 1em">s =
futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0); <br>
if (s == -1 &amp;&amp; errno != EAGAIN) <br>
errExit(&quot;futex-FUTEX_WAIT&quot;); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Release the
futex pointed to by 'futexp': if the futex currently <br>
has the value 0, set its value to 1 and the wake any futex
waiters, <br>
so that if the peer is blocked in fwait(), it can proceed.
*/</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
fpost(uint32_t *futexp) <br>
{ <br>
long s;</p>

<p style="margin-left:11%; margin-top: 1em">/*
atomic_compare_exchange_strong() was described <br>
in comments above */</p>

<p style="margin-left:11%; margin-top: 1em">const uint32_t
zero = 0; <br>
if (atomic_compare_exchange_strong(futexp, &amp;zero, 1)) {
<br>
s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0); <br>
if (s == -1) <br>
errExit(&quot;futex-FUTEX_WAKE&quot;); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
pid_t childPid; <br>
int nloops;</p>

<p style="margin-left:11%; margin-top: 1em">setbuf(stdout,
NULL);</p>

<p style="margin-left:11%; margin-top: 1em">nloops = (argc
&gt; 1) ? atoi(argv[1]) : 5;</p>

<p style="margin-left:11%; margin-top: 1em">/* Create a
shared anonymous mapping that will hold the futexes. <br>
Since the futexes are being shared between processes, we
<br>
subsequently use the &quot;shared&quot; futex operations
(i.e., not the <br>
ones suffixed &quot;_PRIVATE&quot;) */</p>

<p style="margin-left:11%; margin-top: 1em">iaddr =
mmap(NULL, sizeof(*iaddr) * 2, PROT_READ | PROT_WRITE, <br>
MAP_ANONYMOUS | MAP_SHARED, -1, 0); <br>
if (iaddr == MAP_FAILED) <br>
errExit(&quot;mmap&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">futex1 =
&amp;iaddr[0]; <br>
futex2 = &amp;iaddr[1];</p>

<p style="margin-left:11%; margin-top: 1em">*futex1 = 0; /*
State: unavailable */ <br>
*futex2 = 1; /* State: available */</p>

<p style="margin-left:11%; margin-top: 1em">/* Create a
child process that inherits the shared anonymous <br>
mapping */</p>

<p style="margin-left:11%; margin-top: 1em">childPid =
fork(); <br>
if (childPid == -1) <br>
errExit(&quot;fork&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">if (childPid ==
0) { /* Child */ <br>
for (int j = 0; j &lt; nloops; j++) { <br>
fwait(futex1); <br>
printf(&quot;Child (%jd) %d\n&quot;, (intmax_t) getpid(),
j); <br>
fpost(futex2); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Parent falls
through to here */</p>

<p style="margin-left:11%; margin-top: 1em">for (int j = 0;
j &lt; nloops; j++) { <br>
fwait(futex2); <br>
printf(&quot;Parent (%jd) %d\n&quot;, (intmax_t) getpid(),
j); <br>
fpost(futex1); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">wait(NULL);</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>get_robust_list</b>(2),
<b>restart_syscall</b>(2),
<b>pthread_mutexattr_getprotocol</b>(3), <b>futex</b>(7),
<b>sched</b>(7)</p>

<p style="margin-left:11%; margin-top: 1em">The following
kernel source files:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p><i>Documentation/pi-futex.txt</i></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p><i>Documentation/futex-requeue-pi.txt</i></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p><i>Documentation/locking/rt-mutex.txt</i></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p><i>Documentation/locking/rt-mutex-design.txt</i></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p><i>Documentation/robust-futex-ABI.txt</i></p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Franke, H.,
Russell, R., and Kirwood, M., 2002. <i>Fuss, Futexes and
Furwocks: Fast Userlevel Locking in Linux</i> (from
proceedings of the Ottawa Linux Symposium 2002), <br>

<a href="http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf">http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf</a></p>

<p style="margin-left:11%; margin-top: 1em">Hart, D., 2009.
<i>A futex overview and update</i>,
<a href="http://lwn.net/Articles/360699/">http://lwn.net/Articles/360699/</a></p>

<p style="margin-left:11%; margin-top: 1em">Hart, D. and
Guniguntala, D., 2009. <i>Requeue-PI: Making Glibc Condvars
PI-Aware</i> (from proceedings of the 2009 Real-Time Linux
Workshop),
<a href="http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf">http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf</a></p>

<p style="margin-left:11%; margin-top: 1em">Drepper, U.,
2011. <i>Futexes Are Tricky</i>,
<a href="http://www.akkadia.org/drepper/futex.pdf">http://www.akkadia.org/drepper/futex.pdf</a></p>

<p style="margin-left:11%; margin-top: 1em">Futex example
library, futex-*.tar.bz2 at <br>

<a href="ftp://ftp.kernel.org/pub/linux/kernel/people/rusty/">ftp://ftp.kernel.org/pub/linux/kernel/people/rusty/</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
