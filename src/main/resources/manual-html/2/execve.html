<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:00 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EXECVE</title>

</head>
<body>

<h1 align="center">EXECVE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">execve -
execute program</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;unistd.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
execve(const char *</b><i>pathname</i><b>, char *const</b>
<i>argv</i><b>[], <br>
char *const</b> <i>envp</i><b>[]);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>execve</b>()
executes the program referred to by <i>pathname</i>. This
causes the program that is currently being run by the
calling process to be replaced with a new program, with
newly initialized stack, heap, and (initialized and
uninitialized) data segments.</p>


<p style="margin-left:11%; margin-top: 1em"><i>pathname</i>
must be either a binary executable, or a script starting
with a line of the form:</p>


<p style="margin-left:17%; margin-top: 1em"><b>#!</b><i>interpreter</i>
[optional-arg]</p>

<p style="margin-left:11%; margin-top: 1em">For details of
the latter case, see &quot;Interpreter scripts&quot;
below.</p>

<p style="margin-left:11%; margin-top: 1em"><i>argv</i> is
an array of pointers to strings passed to the new program as
its command-line arguments. By convention, the first of
these strings (i.e., <i>argv[0]</i>) should contain the
filename associated with the file being executed. The
<i>argv</i> array must be terminated by a NULL pointer.
(Thus, in the new program, <i>argv[argc]</i> will be
NULL.)</p>

<p style="margin-left:11%; margin-top: 1em"><i>envp</i> is
an array of pointers to strings, conventionally of the form
<b>key=value</b>, which are passed as the environment of the
new program. The <i>envp</i> array must be terminated by a
NULL pointer.</p>

<p style="margin-left:11%; margin-top: 1em">The argument
vector and environment can be accessed by the new
program&rsquo;s main function, when it is defined as:</p>

<p style="margin-left:17%; margin-top: 1em">int main(int
argc, char *argv[], char *envp[])</p>

<p style="margin-left:11%; margin-top: 1em">Note, however,
that the use of a third argument to the main function is not
specified in POSIX.1; according to POSIX.1, the environment
should be accessed via the external variable
<a href="https://man.page/7/environ">environ(7)</a>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>execve</b>()
does not return on success, and the text, initialized data,
uninitialized data (bss), and stack of the calling process
are overwritten according to the contents of the newly
loaded program.</p>

<p style="margin-left:11%; margin-top: 1em">If the current
program is being ptraced, a <b>SIGTRAP</b> signal is sent to
it after a successful <b>execve</b>().</p>

<p style="margin-left:11%; margin-top: 1em">If the
set-user-ID bit is set on the program file referred to by
<i>pathname</i>, then the effective user ID of the calling
process is changed to that of the owner of the program file.
Similarly, if the set-group-ID bit is set on the program
file, then the effective group ID of the calling process is
set to the group of the program file.</p>

<p style="margin-left:11%; margin-top: 1em">The
aforementioned transformations of the effective IDs are
<i>not</i> performed (i.e., the set-user-ID and set-group-ID
bits are ignored) if any of the following is true:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>the <i>no_new_privs</i> attribute is set for the calling
thread (see <a href="https://man.page/2/prctl">prctl(2)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>the underlying filesystem is mounted <i>nosuid</i> (the
<b>MS_NOSUID</b> flag for <a href="https://man.page/2/mount">mount(2)</a>); or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>the calling process is being ptraced.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
capabilities of the program file (see
<a href="https://man.page/7/capabilities">capabilities(7)</a>) are also ignored if any of the above
are true.</p>

<p style="margin-left:11%; margin-top: 1em">The effective
user ID of the process is copied to the saved set-user-ID;
similarly, the effective group ID is copied to the saved
set-group-ID. This copying takes place after any effective
ID changes that occur because of the set-user-ID and
set-group-ID mode bits.</p>

<p style="margin-left:11%; margin-top: 1em">The
process&rsquo;s real UID and real GID, as well its
supplementary group IDs, are unchanged by a call to
<b>execve</b>().</p>

<p style="margin-left:11%; margin-top: 1em">If the
executable is an a.out dynamically linked binary executable
containing shared-library stubs, the Linux dynamic linker
<b>ld.so</b>(8) is called at the start of execution to bring
needed shared objects into memory and link the executable
with them.</p>

<p style="margin-left:11%; margin-top: 1em">If the
executable is a dynamically linked ELF executable, the
interpreter named in the PT_INTERP segment is used to load
the needed shared objects. This interpreter is typically
<i>/lib/ld-linux.so.2</i> for binaries linked with glibc
(see <b>ld-linux.so</b>(8)).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Effect on
process attributes</b> <br>
All process attributes are preserved during an
<b>execve</b>(), except the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The dispositions of any signals
that are being caught are reset to the default
(<a href="https://man.page/7/signal">signal(7)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Any alternate signal stack is not preserved
(<a href="https://man.page/2/sigaltstack">sigaltstack(2)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Memory mappings are not preserved (<a href="https://man.page/2/mmap">mmap(2)</a>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Attached System&nbsp;V shared memory segments are
detached (<a href="https://man.page/2/shmat">shmat(2)</a>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>POSIX shared memory regions are unmapped
(<a href="https://man.page/3/shm_open">shm_open(3)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Open POSIX message queue descriptors are closed
(<a href="https://man.page/7/mq_overview">mq_overview(7)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Any open POSIX named semaphores are closed
(<a href="https://man.page/7/sem_overview">sem_overview(7)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>POSIX timers are not preserved
(<a href="https://man.page/2/timer_create">timer_create(2)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Any open directory streams are closed
(<a href="https://man.page/3/opendir">opendir(3)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Memory locks are not preserved (<a href="https://man.page/2/mlock">mlock(2)</a>,
<a href="https://man.page/2/mlockall">mlockall(2)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Exit handlers are not preserved (<a href="https://man.page/3/atexit">atexit(3)</a>,
<a href="https://man.page/3/on_exit">on_exit(3)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The floating-point environment is reset to the default
(see <a href="https://man.page/3/fenv">fenv(3)</a>).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The process
attributes in the preceding list are all specified in
POSIX.1. The following Linux-specific process attributes are
also not preserved during an <b>execve</b>():</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The process&rsquo;s
&quot;dumpable&quot; attribute is set to the value 1, unless
a set-user-ID program, a set-group-ID program, or a program
with capabilities is being executed, in which case the
dumpable flag may instead be reset to the value in
<i>/proc/sys/fs/suid_dumpable</i>, in the circumstances
described under <b>PR_SET_DUMPABLE</b> in <a href="https://man.page/2/prctl">prctl(2)</a>.
Note that changes to the &quot;dumpable&quot; attribute may
cause ownership of files in the process&rsquo;s
<i>/proc/[pid]</i> directory to change to <i>root:root</i>,
as described in <a href="https://man.page/5/proc">proc(5)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The <a href="https://man.page/2/prctl">prctl(2)</a> <b>PR_SET_KEEPCAPS</b> flag is
cleared.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>(Since Linux 2.4.36 / 2.6.23) If a set-user-ID or
set-group-ID program is being executed, then the parent
death signal set by <a href="https://man.page/2/prctl">prctl(2)</a> <b>PR_SET_PDEATHSIG</b>
flag is cleared.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The process name, as set by <a href="https://man.page/2/prctl">prctl(2)</a>
<b>PR_SET_NAME</b> (and displayed by <i>ps&nbsp;-o
comm</i>), is reset to the name of the new executable
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The <b>SECBIT_KEEP_CAPS</b> <i>securebits</i> flag is
cleared. See <a href="https://man.page/7/capabilities">capabilities(7)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The termination signal is reset to <b>SIGCHLD</b> (see
<a href="https://man.page/2/clone">clone(2)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The file descriptor table is unshared, undoing the
effect of the <b>CLONE_FILES</b> flag of
<a href="https://man.page/2/clone">clone(2)</a>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note the
following further points:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">All threads other than the
calling thread are destroyed during an <b>execve</b>().
Mutexes, condition variables, and other pthreads objects are
not preserved.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The equivalent of <i>setlocale(LC_ALL,
&quot;C&quot;)</i> is executed at program start-up.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>POSIX.1 specifies that the dispositions of any signals
that are ignored or set to the default are left unchanged.
POSIX.1 specifies one exception: if <b>SIGCHLD</b> is being
ignored, then an implementation may leave the disposition
unchanged or reset it to the default; Linux does the
former.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Any outstanding asynchronous I/O operations are canceled
(<a href="https://man.page/3/aio_read">aio_read(3)</a>, <a href="https://man.page/3/aio_write">aio_write(3)</a>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>For the handling of capabilities during <b>execve</b>(),
see <a href="https://man.page/7/capabilities">capabilities(7)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>By default, file descriptors remain open across an
<b>execve</b>(). File descriptors that are marked
close-on-exec are closed; see the description of
<b>FD_CLOEXEC</b> in <a href="https://man.page/2/fcntl">fcntl(2)</a>. (If a file descriptor
is closed, this will cause the release of all record locks
obtained on the underlying file by this process. See
<a href="https://man.page/2/fcntl">fcntl(2)</a> for details.) POSIX.1 says that if file
descriptors 0, 1, and 2 would otherwise be closed after a
successful <b>execve</b>(), and the process would gain
privilege because the set-user-ID or set-group-ID mode bit
was set on the executed file, then the system may open an
unspecified file for each of these file descriptors. As a
general principle, no portable program, whether privileged
or not, can assume that these three file descriptors will
remain closed across an <b>execve</b>().</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Interpreter
scripts</b> <br>
An interpreter script is a text file that has execute
permission enabled and whose first line is of the form:</p>


<p style="margin-left:17%; margin-top: 1em"><b>#!</b><i>interpreter</i>
[optional-arg]</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>interpreter</i> must be a valid pathname for an
executable file.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>pathname</i> argument of <b>execve</b>() specifies an
interpreter script, then <i>interpreter</i> will be invoked
with the following arguments:</p>


<p style="margin-left:17%; margin-top: 1em"><i>interpreter</i>
[optional-arg] <i>pathname</i> arg...</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>pathname</i> is the absolute pathname of the file
specified as the first argument of <b>execve</b>(), and
<i>arg...</i> is the series of words pointed to by the
<i>argv</i> argument of <b>execve</b>(), starting at
<i>argv[1]</i>. Note that there is no way to get the
<i>argv[0]</i> that was passed to the <b>execve</b>()
call.</p>

<p style="margin-left:11%; margin-top: 1em">For portable
use, <i>optional-arg</i> should either be absent, or be
specified as a single word (i.e., it should not contain
white space); see NOTES below.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
2.6.28, the kernel permits the interpreter of a script to
itself be a script. This permission is recursive, up to a
limit of four recursions, so that the interpreter may be a
script which is interpreted by a script, and so on.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Limits on
size of arguments and environment</b> <br>
Most UNIX implementations impose some limit on the total
size of the command-line argument (<i>argv</i>) and
environment (<i>envp</i>) strings that may be passed to a
new program. POSIX.1 allows an implementation to advertise
this limit using the <b>ARG_MAX</b> constant (either defined
in <i>&lt;limits.h&gt;</i> or available at run time using
the call <i>sysconf(_SC_ARG_MAX)</i>).</p>

<p style="margin-left:11%; margin-top: 1em">On Linux prior
to kernel 2.6.23, the memory used to store the environment
and argument strings was limited to 32 pages (defined by the
kernel constant <b>MAX_ARG_PAGES</b>). On architectures with
a 4-kB page size, this yields a maximum size of
128&nbsp;kB.</p>

<p style="margin-left:11%; margin-top: 1em">On kernel
2.6.23 and later, most architectures support a size limit
derived from the soft <b>RLIMIT_STACK</b> resource limit
(see <a href="https://man.page/2/getrlimit">getrlimit(2)</a>) that is in force at the time of
the <b>execve</b>() call. (Architectures with no memory
management unit are excepted: they maintain the limit that
was in effect before kernel 2.6.23.) This change allows
programs to have a much larger argument and/or environment
list. For these architectures, the total size is limited to
1/4 of the allowed stack size. (Imposing the 1/4-limit
ensures that the new program always has some stack space.)
Additionally, the total size is limited to 3/4 of the value
of the kernel constant <b>_STK_LIM</b> (8 Mibibytes). Since
Linux 2.6.25, the kernel also places a floor of 32 pages on
this size limit, so that, even when <b>RLIMIT_STACK</b> is
set very low, applications are guaranteed to have at least
as much argument and environment space as was provided by
Linux 2.6.23 and earlier. (This guarantee was not provided
in Linux 2.6.23 and 2.6.24.) Additionally, the limit per
string is 32 pages (the kernel constant
<b>MAX_ARG_STRLEN</b>), and the maximum number of strings is
0x7FFFFFFF.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
<b>execve</b>() does not return, on error -1 is returned,
and <i>errno</i> is set appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>E2BIG</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">The total number of bytes in the
environment (<i>envp</i>) and argument list (<i>argv</i>) is
too large.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Search permission is denied on a component of the path
prefix of <i>pathname</i> or the name of a script
interpreter. (See also <a href="https://man.page/7/path_resolution">path_resolution(7)</a>.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The file or a script interpreter is not a regular
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Execute permission is denied for the file or a script or
ELF interpreter.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The filesystem is mounted <i>noexec</i>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> (since Linux
3.1)</p>

<p style="margin-left:22%;">Having changed its real UID
using one of the <b>set*uid</b>() calls, the caller
was&mdash;and is now still&mdash;above its
<b>RLIMIT_NPROC</b> resource limit (see
<a href="https://man.page/2/setrlimit">setrlimit(2)</a>). For a more detailed explanation of
this error, see NOTES.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>pathname</i> or one of the pointers in the vectors
<i>argv</i> or <i>envp</i> points outside your accessible
address space.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>An ELF executable had more than one PT_INTERP segment
(i.e., tried to name more than one interpreter).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>An I/O error occurred.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EISDIR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>An ELF interpreter was a directory.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ELIBBAD</b></p>

<p style="margin-left:22%;">An ELF interpreter was not in a
recognized format.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ELOOP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Too many symbolic links were encountered in resolving
<i>pathname</i> or the name of a script or ELF
interpreter.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ELOOP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The maximum recursion limit was reached during recursive
script interpretation (see &quot;Interpreter scripts&quot;,
above). Before Linux 3.8, the error produced for this case
was <b>ENOEXEC</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The per-process limit on the number of open file
descriptors has been reached.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENAMETOOLONG</b></p>

<p style="margin-left:22%;"><i>pathname</i> is too
long.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The system-wide limit on the total number of open files
has been reached.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The file <i>pathname</i> or a script or ELF interpreter
does not exist.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENOEXEC</b></p>

<p style="margin-left:22%;">An executable is not in a
recognized format, is for the wrong architecture, or has
some other format error that means it cannot be
executed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="63%">


<p>Insufficient kernel memory was available.</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ENOTDIR</b></p>

<p style="margin-left:22%;">A component of the path prefix
of <i>pathname</i> or a script or ELF interpreter is not a
directory.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The filesystem is mounted <i>nosuid</i>, the user is not
the superuser, and the file has the set-user-ID or
set-group-ID bit set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The process is being traced, the user is not the
superuser and the file has the set-user-ID or set-group-ID
bit set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>A &quot;capability-dumb&quot; applications would not
obtain the full set of permitted capabilities granted by the
executable file. See <a href="https://man.page/7/capabilities">capabilities(7)</a>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ETXTBSY</b></p>

<p style="margin-left:22%;">The specified executable was
open for writing by one or more processes.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1-2001,
POSIX.1-2008, SVr4, 4.3BSD. POSIX does not document the #!
behavior, but it exists (with some variations) on other UNIX
systems.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">One sometimes
sees <b>execve</b>() (and the related functions described in
<a href="https://man.page/3/exec">exec(3)</a>) described as &quot;executing a <i>new</i>
process&quot; (or similar). This is a highly misleading
description: there is no new process; many attributes of the
calling process remain unchanged (in particular, its PID).
All that <b>execve</b>() does is arrange for an existing
process (the calling process) to execute a new program.</p>

<p style="margin-left:11%; margin-top: 1em">Set-user-ID and
set-group-ID processes can not be <a href="https://man.page/2/ptrace">ptrace(2)</a>d.</p>

<p style="margin-left:11%; margin-top: 1em">The result of
mounting a filesystem <i>nosuid</i> varies across Linux
kernel versions: some will refuse execution of set-user-ID
and set-group-ID executables when this would give the user
powers they did not have already (and return <b>EPERM</b>),
some will just ignore the set-user-ID and set-group-ID bits
and <b>exec</b>() successfully.</p>

<p style="margin-left:11%; margin-top: 1em">On Linux,
<i>argv</i> and <i>envp</i> can be specified as NULL. In
both cases, this has the same effect as specifying the
argument as a pointer to a list containing a single null
pointer. <b>Do not take advantage of this nonstandard and
nonportable misfeature!</b> On many other UNIX systems,
specifying <i>argv</i> as NULL will result in an error
(<b>EFAULT</b>). <i>Some</i> other UNIX systems treat the
<i>envp==NULL</i> case the same as Linux.</p>

<p style="margin-left:11%; margin-top: 1em">POSIX.1 says
that values returned by <a href="https://man.page/3/sysconf">sysconf(3)</a> should be
invariant over the lifetime of a process. However, since
Linux 2.6.23, if the <b>RLIMIT_STACK</b> resource limit
changes, then the value reported by <b>_SC_ARG_MAX</b> will
also change, to reflect the fact that the limit on space for
holding command-line arguments and environment variables has
changed.</p>

<p style="margin-left:11%; margin-top: 1em">In most cases
where <b>execve</b>() fails, control returns to the original
executable image, and the caller of <b>execve</b>() can then
handle the error. However, in (rare) cases (typically caused
by resource exhaustion), failure may occur past the point of
no return: the original executable image has been torn down,
but the new image could not be completely built. In such
cases, the kernel kills the process with a <b>SIGSEGV</b>
(<b>SIGKILL</b> until Linux 3.17) signal.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Interpreter
scripts</b> <br>
The kernel imposes a maximum length on the text that follows
the &quot;#!&quot; characters at the start of a script;
characters beyond the limit are ignored. Before Linux 5.1,
the limit is 127 characters. Since Linux 5.1, the limit is
255 characters.</p>

<p style="margin-left:11%; margin-top: 1em">The semantics
of the <i>optional-arg</i> argument of an interpreter script
vary across implementations. On Linux, the entire string
following the <i>interpreter</i> name is passed as a single
argument to the interpreter, and this string can include
white space. However, behavior differs on some other
systems. Some systems use the first white space to terminate
<i>optional-arg</i>. On some systems, an interpreter script
can have multiple arguments, and white spaces in
<i>optional-arg</i> are used to delimit the arguments.</p>

<p style="margin-left:11%; margin-top: 1em">Linux (like
most other modern UNIX systems) ignores the set-user-ID and
set-group-ID bits on scripts.</p>

<p style="margin-left:11%; margin-top: 1em"><b>execve() and
EAGAIN</b> <br>
A more detailed explanation of the <b>EAGAIN</b> error that
can occur (since Linux 3.1) when calling <b>execve</b>() is
as follows.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EAGAIN</b> error can occur when a <i>preceding</i> call
to <a href="https://man.page/2/setuid">setuid(2)</a>, <a href="https://man.page/2/setreuid">setreuid(2)</a>, or
<a href="https://man.page/2/setresuid">setresuid(2)</a> caused the real user ID of the process
to change, and that change caused the process to exceed its
<b>RLIMIT_NPROC</b> resource limit (i.e., the number of
processes belonging to the new real UID exceeds the resource
limit). From Linux 2.6.0 to 3.0, this caused the
<b>set*uid</b>() call to fail. (Prior to 2.6, the resource
limit was not imposed on processes that changed their user
IDs.)</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
3.1, the scenario just described no longer causes the
<b>set*uid</b>() call to fail, because it too often led to
security holes where buggy applications didn&rsquo;t check
the return status and assumed that&mdash;if the caller had
root privileges&mdash;the call would always succeed.
Instead, the <b>set*uid</b>() calls now successfully change
the real UID, but the kernel sets an internal flag, named
<b>PF_NPROC_EXCEEDED</b>, to note that the
<b>RLIMIT_NPROC</b> resource limit has been exceeded. If the
<b>PF_NPROC_EXCEEDED</b> flag is set and the resource limit
is still exceeded at the time of a subsequent
<b>execve</b>() call, that call fails with the error
<b>EAGAIN</b>. This kernel logic ensures that the
<b>RLIMIT_NPROC</b> resource limit is still enforced for the
common privileged daemon workflow&mdash;namely,
<a href="https://man.page/2/fork">fork(2)</a> + <b>set*uid</b>() + <b>execve</b>().</p>

<p style="margin-left:11%; margin-top: 1em">If the resource
limit was not still exceeded at the time of the
<b>execve</b>() call (because other processes belonging to
this real UID terminated between the <b>set*uid</b>() call
and the <b>execve</b>() call), then the <b>execve</b>() call
succeeds and the kernel clears the <b>PF_NPROC_EXCEEDED</b>
process flag. The flag is also cleared if a subsequent call
to <a href="https://man.page/2/fork">fork(2)</a> by this process succeeds.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Historical</b>
<br>
With UNIX&nbsp;V6, the argument list of an <b>exec</b>()
call was ended by 0, while the argument list of <i>main</i>
was ended by -1. Thus, this argument list was not directly
usable in a further <b>exec</b>() call. Since UNIX&nbsp;V7,
both are NULL.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
program is designed to be execed by the second program
below. It just echoes its command-line arguments, one per
line.</p>

<p style="margin-left:17%; margin-top: 1em">/* myecho.c
*/</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt;</p>

<p style="margin-left:17%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
for (int j = 0; j &lt; argc; j++) <br>
printf(&quot;argv[%d]: %s\n&quot;, j, argv[j]);</p>


<p style="margin-left:17%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This program
can be used to exec the program named in its command-line
argument:</p>

<p style="margin-left:17%; margin-top: 1em">/* execve.c
*/</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;unistd.h&gt;</p>

<p style="margin-left:17%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
char *newargv[] = { NULL, &quot;hello&quot;,
&quot;world&quot;, NULL }; <br>
char *newenviron[] = { NULL };</p>

<p style="margin-left:17%; margin-top: 1em">if (argc != 2)
{ <br>
fprintf(stderr, &quot;Usage: %s
&lt;file-to-exec&gt;\n&quot;, argv[0]); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">newargv[0] =
argv[1];</p>


<p style="margin-left:17%; margin-top: 1em">execve(argv[1],
newargv, newenviron); <br>
perror(&quot;execve&quot;); /* execve() returns only on
error */ <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">We can use the
second program to exec the first as follows:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>cc
myecho.c -o myecho</b> <br>
$ <b>cc execve.c -o execve</b> <br>
$ <b>./execve ./myecho</b> <br>
argv[0]: ./myecho <br>
argv[1]: hello <br>
argv[2]: world</p>

<p style="margin-left:11%; margin-top: 1em">We can also use
these programs to demonstrate the use of a script
interpreter. To do this we create a script whose
&quot;interpreter&quot; is our <i>myecho</i> program:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>cat &gt;
script <br>
#!./myecho script-arg <br>
^D</b> <br>
$ <b>chmod +x script</b></p>

<p style="margin-left:11%; margin-top: 1em">We can then use
our program to exec the script:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>./execve
./script</b> <br>
argv[0]: ./myecho <br>
argv[1]: script-arg <br>
argv[2]: ./script <br>
argv[3]: hello <br>
argv[4]: world</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/chmod">chmod(2)</a>,
<a href="https://man.page/2/execveat">execveat(2)</a>, <a href="https://man.page/2/fork">fork(2)</a>,
<a href="https://man.page/2/get_robust_list">get_robust_list(2)</a>, <a href="https://man.page/2/ptrace">ptrace(2)</a>, <a href="https://man.page/3/exec">exec(3)</a>,
<a href="https://man.page/3/fexecve">fexecve(3)</a>, <a href="https://man.page/3/getopt">getopt(3)</a>, <a href="https://man.page/3/system">system(3)</a>,
<a href="https://man.page/7/capabilities">capabilities(7)</a>, <a href="https://man.page/7/credentials">credentials(7)</a>,
<a href="https://man.page/7/environ">environ(7)</a>, <a href="https://man.page/7/path_resolution">path_resolution(7)</a>,
<b>ld.so</b>(8)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
