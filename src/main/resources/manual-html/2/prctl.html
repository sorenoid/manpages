<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:05 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PRCTL</title>

</head>
<body>

<h1 align="center">PRCTL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">prctl -
operations on a process or thread</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/prctl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
prctl(int</b> <i>option</i><b>, unsigned long</b>
<i>arg2</i><b>, unsigned long</b> <i>arg3</i><b>, <br>
unsigned long</b> <i>arg4</i><b>, unsigned long</b>
<i>arg5</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>prctl</b>()
manipulates various aspects of the behavior of the calling
thread or process.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
careless use of some <b>prctl</b>() operations can confuse
the user-space run-time environment, so these operations
should be used with care.</p>

<p style="margin-left:11%; margin-top: 1em"><b>prctl</b>()
is called with a first argument describing what to do (with
values defined in <i>&lt;linux/prctl.h&gt;</i>), and further
arguments with a significance depending on the first one.
The first argument can be: <b><br>
PR_CAP_AMBIENT</b> (since Linux 4.3)</p>

<p style="margin-left:22%;">Reads or changes the ambient
capability set of the calling thread, according to the value
of <i>arg2</i>, which must be one of the following: <b><br>
PR_CAP_AMBIENT_RAISE</b></p>

<p style="margin-left:32%;">The capability specified in
<i>arg3</i> is added to the ambient set. The specified
capability must already be present in both the permitted and
the inheritable sets of the process. This operation is not
permitted if the <b>SECBIT_NO_CAP_AMBIENT_RAISE</b>
securebit is set.</p>


<p style="margin-left:22%;"><b>PR_CAP_AMBIENT_LOWER</b></p>

<p style="margin-left:32%;">The capability specified in
<i>arg3</i> is removed from the ambient set.</p>


<p style="margin-left:22%;"><b>PR_CAP_AMBIENT_IS_SET</b></p>

<p style="margin-left:32%;">The <b>prctl</b>() call returns
1 if the capability in <i>arg3</i> is in the ambient set and
0 if it is not.</p>


<p style="margin-left:22%;"><b>PR_CAP_AMBIENT_CLEAR_ALL</b></p>

<p style="margin-left:32%;">All capabilities will be
removed from the ambient set. This operation requires
setting <i>arg3</i> to zero.</p>

<p style="margin-left:22%; margin-top: 1em">In all of the
above operations, <i>arg4</i> and <i>arg5</i> must be
specified as 0.</p>

<p style="margin-left:22%; margin-top: 1em">Higher-level
interfaces layered on top of the above operations are
provided in the <b>libcap</b>(3) library in the form of
<b>cap_get_ambient</b>(3), <b>cap_set_ambient</b>(3), and
<b>cap_reset_ambient</b>(3).</p>

<p style="margin-left:11%;"><b>PR_CAPBSET_READ</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">Return (as the function result)
1 if the capability specified in <i>arg2</i> is in the
calling thread&rsquo;s capability bounding set, or 0 if it
is not. (The capability constants are defined in
<i>&lt;linux/capability.h&gt;</i>.) The capability bounding
set dictates whether the process can receive the capability
through a file&rsquo;s permitted capability set on a
subsequent call to <b>execve</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">If the
capability specified in <i>arg2</i> is not valid, then the
call fails with the error <b>EINVAL</b>.</p>

<p style="margin-left:22%; margin-top: 1em">A higher-level
interface layered on top of this operation is provided in
the <b>libcap</b>(3) library in the form of
<b>cap_get_bound</b>(3).</p>

<p style="margin-left:11%;"><b>PR_CAPBSET_DROP</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">If the calling thread has the
<b>CAP_SETPCAP</b> capability within its user namespace,
then drop the capability specified by <i>arg2</i> from the
calling thread&rsquo;s capability bounding set. Any children
of the calling thread will inherit the newly reduced
bounding set.</p>

<p style="margin-left:22%; margin-top: 1em">The call fails
with the error: <b>EPERM</b> if the calling thread does not
have the <b>CAP_SETPCAP</b>; <b>EINVAL</b> if <i>arg2</i>
does not represent a valid capability; or <b>EINVAL</b> if
file capabilities are not enabled in the kernel, in which
case bounding sets are not supported.</p>

<p style="margin-left:22%; margin-top: 1em">A higher-level
interface layered on top of this operation is provided in
the <b>libcap</b>(3) library in the form of
<b>cap_drop_bound</b>(3).</p>

<p style="margin-left:11%;"><b>PR_SET_CHILD_SUBREAPER</b>
(since Linux 3.4)</p>

<p style="margin-left:22%;">If <i>arg2</i> is nonzero, set
the &quot;child subreaper&quot; attribute of the calling
process; if <i>arg2</i> is zero, unset the attribute.</p>

<p style="margin-left:22%; margin-top: 1em">A subreaper
fulfills the role of <b>init</b>(1) for its descendant
processes. When a process becomes orphaned (i.e., its
immediate parent terminates), then that process will be
reparented to the nearest still living ancestor subreaper.
Subsequently, calls to <b>getppid</b>(2) in the orphaned
process will now return the PID of the subreaper process,
and when the orphan terminates, it is the subreaper process
that will receive a <b>SIGCHLD</b> signal and will be able
to <b>wait</b>(2) on the process to discover its termination
status.</p>

<p style="margin-left:22%; margin-top: 1em">The setting of
the &quot;child subreaper&quot; attribute is not inherited
by children created by <b>fork</b>(2) and <b>clone</b>(2).
The setting is preserved across <b>execve</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">Establishing a
subreaper process is useful in session management frameworks
where a hierarchical group of processes is managed by a
subreaper process that needs to be informed when one of the
processes&mdash;for example, a double-forked
daemon&mdash;terminates (perhaps so that it can restart that
process). Some <b>init</b>(1) frameworks (e.g.,
<b>systemd</b>(1)) employ a subreaper process for similar
reasons.</p>

<p style="margin-left:11%;"><b>PR_GET_CHILD_SUBREAPER</b>
(since Linux 3.4)</p>

<p style="margin-left:22%;">Return the &quot;child
subreaper&quot; setting of the caller, in the location
pointed to by <i>(int&nbsp;*) arg2</i>.</p>

<p style="margin-left:11%;"><b>PR_SET_DUMPABLE</b> (since
Linux 2.3.20)</p>

<p style="margin-left:22%;">Set the state of the
&quot;dumpable&quot; attribute, which determines whether
core dumps are produced for the calling process upon
delivery of a signal whose default behavior is to produce a
core dump.</p>

<p style="margin-left:22%; margin-top: 1em">In kernels up
to and including 2.6.12, <i>arg2</i> must be either 0
(<b>SUID_DUMP_DISABLE</b>, process is not dumpable) or 1
(<b>SUID_DUMP_USER</b>, process is dumpable). Between
kernels 2.6.13 and 2.6.17, the value 2 was also permitted,
which caused any binary which normally would not be dumped
to be dumped readable by root only; for security reasons,
this feature has been removed. (See also the description of
<i>/proc/sys/fs/ suid_dumpable</i> in <b>proc</b>(5).)</p>

<p style="margin-left:22%; margin-top: 1em">Normally, the
&quot;dumpable&quot; attribute is set to 1. However, it is
reset to the current value contained in the file
<i>/proc/sys/fs/ suid_dumpable</i> (which by default has the
value 0), in the following circumstances:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>The process&rsquo;s effective user or group ID is
changed.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>The process&rsquo;s filesystem user or group ID is
changed (see <b>credentials</b>(7)).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>The process executes (<b>execve</b>(2)) a set-user-ID or
set-group-ID program, resulting in a change of either the
effective user ID or the effective group ID.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p>The process executes (<b>execve</b>(2)) a program that
has file capabilities (see <b>capabilities</b>(7)), but only
if the permitted capabilities gained exceed those already
permitted for the process.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Processes that
are not dumpable can not be attached via <b>ptrace</b>(2)
<b>PTRACE_ATTACH</b>; see <b>ptrace</b>(2) for further
details.</p>

<p style="margin-left:22%; margin-top: 1em">If a process is
not dumpable, the ownership of files in the process&rsquo;s
<i>/proc/[pid]</i> directory is affected as described in
<b>proc</b>(5).</p>

<p style="margin-left:11%;"><b>PR_GET_DUMPABLE</b> (since
Linux 2.3.20)</p>

<p style="margin-left:22%;">Return (as the function result)
the current state of the calling process&rsquo;s dumpable
attribute.</p>

<p style="margin-left:11%;"><b>PR_SET_ENDIAN</b> (since
Linux 2.6.18, PowerPC only)</p>

<p style="margin-left:22%;">Set the endian-ness of the
calling process to the value given in <i>arg2</i>, which
should be one of the following: <b>PR_ENDIAN_BIG</b>,
<b>PR_ENDIAN_LITTLE</b>, or <b>PR_ENDIAN_PPC_LITTLE</b>
(PowerPC pseudo little endian).</p>

<p style="margin-left:11%;"><b>PR_GET_ENDIAN</b> (since
Linux 2.6.18, PowerPC only)</p>

<p style="margin-left:22%;">Return the endian-ness of the
calling process, in the location pointed to by
<i>(int&nbsp;*) arg2</i>.</p>

<p style="margin-left:11%;"><b>PR_SET_FP_MODE</b> (since
Linux 4.0, only on MIPS)</p>

<p style="margin-left:22%;">On the MIPS architecture,
user-space code can be built using an ABI which permits
linking with code that has more restrictive floating-point
(FP) requirements. For example, user-space code may be built
to target the O32 FPXX ABI and linked with code built for
either one of the more restrictive FP32 or FP64 ABIs. When
more restrictive code is linked in, the overall requirement
for the process is to use the more restrictive
floating-point mode.</p>

<p style="margin-left:22%; margin-top: 1em">Because the
kernel has no means of knowing in advance which mode the
process should be executed in, and because these
restrictions can change over the lifetime of the process,
the <b>PR_SET_FP_MODE</b> operation is provided to allow
control of the floating-point mode from user space.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>(unsigned int) arg2</i> argument is a bit mask describing
the floating-point mode used: <b><br>
PR_FP_MODE_FR</b></p>

<p style="margin-left:32%;">When this bit is <i>unset</i>
(so called <b>FR=0</b> or <b>FR0</b> mode), the 32
floating-point registers are 32 bits wide, and 64-bit
registers are represented as a pair of registers (even- and
odd- numbered, with the even-numbered register containing
the lower 32 bits, and the odd-numbered register containing
the higher 32 bits).</p>

<p style="margin-left:32%; margin-top: 1em">When this bit
is <i>set</i> (on supported hardware), the 32 floating-point
registers are 64 bits wide (so called <b>FR=1</b> or
<b>FR1</b> mode). Note that modern MIPS implementations
(MIPS R6 and newer) support <b>FR=1</b> mode only.</p>

<p style="margin-left:32%; margin-top: 1em">Applications
that use the O32 FP32 ABI can operate only when this bit is
<i>unset</i> (<b>FR=0</b>; or they can be used with FRE
enabled, see below). Applications that use the O32 FP64 ABI
(and the O32 FP64A ABI, which exists to provide the ability
to operate with existing FP32 code; see below) can operate
only when this bit is <i>set</i> (<b>FR=1</b>). Applications
that use the O32 FPXX ABI can operate with either
<b>FR=0</b> or <b>FR=1</b>.</p>

<p style="margin-left:22%;"><b>PR_FP_MODE_FRE</b></p>

<p style="margin-left:32%;">Enable emulation of 32-bit
floating-point mode. When this mode is enabled, it emulates
32-bit floating-point operations by raising a
reserved-instruction exception on every instruction that
uses 32-bit formats and the kernel then handles the
instruction in software. (The problem lies in the
discrepancy of handling odd-numbered registers which are the
high 32 bits of 64-bit registers with even numbers in
<b>FR=0</b> mode and the lower 32-bit parts of odd-numbered
64-bit registers in <b>FR=1</b> mode.) Enabling this bit is
necessary when code with the O32 FP32 ABI should operate
with code with compatible the O32 FPXX or O32 FP64A ABIs
(which require <b>FR=1</b> FPU mode) or when it is executed
on newer hardware (MIPS R6 onwards) which lacks <b>FR=0</b>
mode support when a binary with the FP32 ABI is used.</p>

<p style="margin-left:32%; margin-top: 1em">Note that this
mode makes sense only when the FPU is in 64-bit mode
(<b>FR=1</b>).</p>

<p style="margin-left:32%; margin-top: 1em">Note that the
use of emulation inherently has a significant performance
hit and should be avoided if possible.</p>

<p style="margin-left:22%; margin-top: 1em">In the N32/N64
ABI, 64-bit floating-point mode is always used, so FPU
emulation is not required and the FPU always operates in
<b>FR=1</b> mode.</p>

<p style="margin-left:22%; margin-top: 1em">This option is
mainly intended for use by the dynamic linker
(<b>ld.so</b>(8)).</p>

<p style="margin-left:22%; margin-top: 1em">The arguments
<i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.</p>

<p style="margin-left:11%;"><b>PR_GET_FP_MODE</b> (since
Linux 4.0, only on MIPS)</p>

<p style="margin-left:22%;">Return (as the function result)
the current floating-point mode (see the description of
<b>PR_SET_FP_MODE</b> for details).</p>

<p style="margin-left:22%; margin-top: 1em">On success, the
call returns a bit mask which represents the current
floating-point mode.</p>

<p style="margin-left:22%; margin-top: 1em">The arguments
<i>arg2</i>, <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are
ignored.</p>

<p style="margin-left:11%;"><b>PR_SET_FPEMU</b> (since
Linux 2.4.18, 2.5.9, only on ia64)</p>

<p style="margin-left:22%;">Set floating-point emulation
control bits to <i>arg2</i>. Pass <b>PR_FPEMU_NOPRINT</b> to
silently emulate floating-point operation accesses, or
<b>PR_FPEMU_SIGFPE</b> to not emulate floating-point
operations and send <b>SIGFPE</b> instead.</p>

<p style="margin-left:11%;"><b>PR_GET_FPEMU</b> (since
Linux 2.4.18, 2.5.9, only on ia64)</p>

<p style="margin-left:22%;">Return floating-point emulation
control bits, in the location pointed to by <i>(int&nbsp;*)
arg2</i>.</p>

<p style="margin-left:11%;"><b>PR_SET_FPEXC</b> (since
Linux 2.4.21, 2.5.32, only on PowerPC)</p>

<p style="margin-left:22%;">Set floating-point exception
mode to <i>arg2</i>. Pass <b>PR_FP_EXC_SW_ENABLE</b> to use
FPEXC for FP exception enables, <b>PR_FP_EXC_DIV</b> for
floating-point divide by zero, <b>PR_FP_EXC_OVF</b> for
floating-point overflow, <b>PR_FP_EXC_UND</b> for
floating-point underflow, <b>PR_FP_EXC_RES</b> for
floating-point inexact result, <b>PR_FP_EXC_INV</b> for
floating-point invalid operation, <b>PR_FP_EXC_DISABLED</b>
for FP exceptions disabled, <b>PR_FP_EXC_NONRECOV</b> for
async nonrecoverable exception mode, <b>PR_FP_EXC_ASYNC</b>
for async recoverable exception mode,
<b>PR_FP_EXC_PRECISE</b> for precise exception mode.</p>

<p style="margin-left:11%;"><b>PR_GET_FPEXC</b> (since
Linux 2.4.21, 2.5.32, only on PowerPC)</p>

<p style="margin-left:22%;">Return floating-point exception
mode, in the location pointed to by <i>(int&nbsp;*)
arg2</i>.</p>

<p style="margin-left:11%;"><b>PR_SET_IO_FLUSHER</b> (since
Linux 5.6)</p>

<p style="margin-left:22%;">If a user process is involved
in the block layer or filesystem I/O path, and can allocate
memory while processing I/O requests it must set <i>arg2</i>
to 1. This will put the process in the IO_FLUSHER state,
which allows it special treatment to make progress when
allocating memory. If <i>arg2</i> is 0, the process will
clear the IO_FLUSHER state, and the default behavior will be
used.</p>

<p style="margin-left:22%; margin-top: 1em">The calling
process must have the <b>CAP_SYS_RESOURCE</b>
capability.</p>

<p style="margin-left:22%; margin-top: 1em"><i>arg3</i>,
<i>arg4</i>, and <i>arg5</i> must be zero.</p>

<p style="margin-left:22%; margin-top: 1em">The IO_FLUSHER
state is inherited by a child process created via
<b>fork</b>(2) and is preserved across <b>execve</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">Examples of
IO_FLUSHER applications are FUSE daemons, SCSI device
emulation daemons, and daemons that perform error handling
like multipath path recovery applications.</p>

<p style="margin-left:11%;"><b>PR_GET_IO_FLUSHER (Since
Linux 5.6)</b></p>

<p style="margin-left:22%;">Return (as the function result)
the IO_FLUSHER state of the caller. A value of 1 indicates
that the caller is in the IO_FLUSHER state; 0 indicates that
the caller is not in the IO_FLUSHER state.</p>

<p style="margin-left:22%; margin-top: 1em">The calling
process must have the <b>CAP_SYS_RESOURCE</b>
capability.</p>

<p style="margin-left:22%; margin-top: 1em"><i>arg2</i>,
<i>arg3</i>, <i>arg4</i>, and <i>arg5</i> must be zero.</p>

<p style="margin-left:11%;"><b>PR_SET_KEEPCAPS</b> (since
Linux 2.2.18)</p>

<p style="margin-left:22%;">Set the state of the calling
thread&rsquo;s &quot;keep capabilities&quot; flag. The
effect of this flag is described in <b>capabilities</b>(7).
<i>arg2</i> must be either 0 (clear the flag) or 1 (set the
flag). The &quot;keep capabilities&quot; value will be reset
to 0 on subsequent calls to <b>execve</b>(2).</p>

<p style="margin-left:11%;"><b>PR_GET_KEEPCAPS</b> (since
Linux 2.2.18)</p>

<p style="margin-left:22%;">Return (as the function result)
the current state of the calling thread&rsquo;s &quot;keep
capabilities&quot; flag. See <b>capabilities</b>(7) for a
description of this flag.</p>

<p style="margin-left:11%;"><b>PR_MCE_KILL</b> (since Linux
2.6.32)</p>

<p style="margin-left:22%;">Set the machine check memory
corruption kill policy for the calling thread. If
<i>arg2</i> is <b>PR_MCE_KILL_CLEAR</b>, clear the thread
memory corruption kill policy and use the system-wide
default. (The system-wide default is defined by
<i>/proc/sys/vm/memory_failure_early_kill</i>; see
<b>proc</b>(5).) If <i>arg2</i> is <b>PR_MCE_KILL_SET</b>,
use a thread-specific memory corruption kill policy. In this
case, <i>arg3</i> defines whether the policy is <i>early
kill</i> (<b>PR_MCE_KILL_EARLY</b>), <i>late kill</i>
(<b>PR_MCE_KILL_LATE</b>), or the system-wide default
(<b>PR_MCE_KILL_DEFAULT</b>). Early kill means that the
thread receives a <b>SIGBUS</b> signal as soon as hardware
memory corruption is detected inside its address space. In
late kill mode, the process is killed only when it accesses
a corrupted page. See <b>sigaction</b>(2) for more
information on the <b>SIGBUS</b> signal. The policy is
inherited by children. The remaining unused <b>prctl</b>()
arguments must be zero for future compatibility.</p>

<p style="margin-left:11%;"><b>PR_MCE_KILL_GET</b> (since
Linux 2.6.32)</p>

<p style="margin-left:22%;">Return (as the function result)
the current per-process machine check kill policy. All
unused <b>prctl</b>() arguments must be zero.</p>

<p style="margin-left:11%;"><b>PR_SET_MM</b> (since Linux
3.3)</p>

<p style="margin-left:22%;">Modify certain kernel memory
map descriptor fields of the calling process. Usually these
fields are set by the kernel and dynamic loader (see
<b>ld.so</b>(8) for more information) and a regular
application should not use this feature. However, there are
cases, such as self-modifying programs, where a program
might find it useful to change its own memory map.</p>

<p style="margin-left:22%; margin-top: 1em">The calling
process must have the <b>CAP_SYS_RESOURCE</b> capability.
The value in <i>arg2</i> is one of the options below, while
<i>arg3</i> provides a new value for the option. The
<i>arg4</i> and <i>arg5</i> arguments must be zero if
unused.</p>

<p style="margin-left:22%; margin-top: 1em">Before Linux
3.10, this feature is available only if the kernel is built
with the <b>CONFIG_CHECKPOINT_RESTORE</b> option enabled.
<b><br>
PR_SET_MM_START_CODE</b></p>

<p style="margin-left:32%;">Set the address above which the
program text can run. The corresponding memory area must be
readable and executable, but not writable or shareable (see
<b>mprotect</b>(2) and <b>mmap</b>(2) for more
information).</p>

<p style="margin-left:22%;"><b>PR_SET_MM_END_CODE</b></p>

<p style="margin-left:32%;">Set the address below which the
program text can run. The corresponding memory area must be
readable and executable, but not writable or shareable.</p>


<p style="margin-left:22%;"><b>PR_SET_MM_START_DATA</b></p>

<p style="margin-left:32%;">Set the address above which
initialized and uninitialized (bss) data are placed. The
corresponding memory area must be readable and writable, but
not executable or shareable.</p>

<p style="margin-left:22%;"><b>PR_SET_MM_END_DATA</b></p>

<p style="margin-left:32%;">Set the address below which
initialized and uninitialized (bss) data are placed. The
corresponding memory area must be readable and writable, but
not executable or shareable.</p>


<p style="margin-left:22%;"><b>PR_SET_MM_START_STACK</b></p>

<p style="margin-left:32%;">Set the start address of the
stack. The corresponding memory area must be readable and
writable.</p>

<p style="margin-left:22%;"><b>PR_SET_MM_START_BRK</b></p>

<p style="margin-left:32%;">Set the address above which the
program heap can be expanded with <b>brk</b>(2) call. The
address must be greater than the ending address of the
current program data segment. In addition, the combined size
of the resulting heap and the size of the data segment
can&rsquo;t exceed the <b>RLIMIT_DATA</b> resource limit
(see <b>setrlimit</b>(2)).</p>

<p style="margin-left:22%;"><b>PR_SET_MM_BRK</b></p>

<p style="margin-left:32%;">Set the current <b>brk</b>(2)
value. The requirements for the address are the same as for
the <b>PR_SET_MM_START_BRK</b> option.</p>

<p style="margin-left:22%; margin-top: 1em">The following
options are available since Linux 3.5. <b><br>
PR_SET_MM_ARG_START</b></p>

<p style="margin-left:32%;">Set the address above which the
program command line is placed.</p>

<p style="margin-left:22%;"><b>PR_SET_MM_ARG_END</b></p>

<p style="margin-left:32%;">Set the address below which the
program command line is placed.</p>

<p style="margin-left:22%;"><b>PR_SET_MM_ENV_START</b></p>

<p style="margin-left:32%;">Set the address above which the
program environment is placed.</p>

<p style="margin-left:22%;"><b>PR_SET_MM_ENV_END</b></p>

<p style="margin-left:32%;">Set the address below which the
program environment is placed.</p>

<p style="margin-left:32%; margin-top: 1em">The address
passed with <b>PR_SET_MM_ARG_START</b>,
<b>PR_SET_MM_ARG_END</b>, <b>PR_SET_MM_ENV_START</b>, and
<b>PR_SET_MM_ENV_END</b> should belong to a process stack
area. Thus, the corresponding memory area must be readable,
writable, and (depending on the kernel configuration) have
the <b>MAP_GROWSDOWN</b> attribute set (see
<b>mmap</b>(2)).</p>

<p style="margin-left:22%;"><b>PR_SET_MM_AUXV</b></p>

<p style="margin-left:32%;">Set a new auxiliary vector. The
<i>arg3</i> argument should provide the address of the
vector. The <i>arg4</i> is the size of the vector.</p>

<p style="margin-left:22%;"><b>PR_SET_MM_EXE_FILE</b></p>

<p style="margin-left:32%;">Supersede the
<i>/proc/pid/exe</i> symbolic link with a new one pointing
to a new executable file identified by the file descriptor
provided in <i>arg3</i> argument. The file descriptor should
be obtained with a regular <b>open</b>(2) call.</p>

<p style="margin-left:32%; margin-top: 1em">To change the
symbolic link, one needs to unmap all existing executable
memory areas, including those created by the kernel itself
(for example the kernel usually creates at least one
executable memory area for the ELF <i>.text</i>
section).</p>

<p style="margin-left:32%; margin-top: 1em">In Linux 4.9
and earlier, the <b>PR_SET_MM_EXE_FILE</b> operation can be
performed only once in a process&rsquo;s lifetime;
attempting to perform the operation a second time results in
the error <b>EPERM</b>. This restriction was enforced for
security reasons that were subsequently deemed specious, and
the restriction was removed in Linux 4.10 because some
user-space applications needed to perform this operation
more than once.</p>

<p style="margin-left:22%; margin-top: 1em">The following
options are available since Linux 3.18. <b><br>
PR_SET_MM_MAP</b></p>

<p style="margin-left:32%;">Provides one-shot access to all
the addresses by passing in a <i>struct prctl_mm_map</i> (as
defined in <i>&lt;linux/prctl.h&gt;</i>). The <i>arg4</i>
argument should provide the size of the struct.</p>

<p style="margin-left:32%; margin-top: 1em">This feature is
available only if the kernel is built with the
<b>CONFIG_CHECKPOINT_RESTORE</b> option enabled.</p>

<p style="margin-left:22%;"><b>PR_SET_MM_MAP_SIZE</b></p>

<p style="margin-left:32%;">Returns the size of the
<i>struct prctl_mm_map</i> the kernel expects. This allows
user space to find a compatible struct. The <i>arg4</i>
argument should be a pointer to an unsigned int.</p>

<p style="margin-left:32%; margin-top: 1em">This feature is
available only if the kernel is built with the
<b>CONFIG_CHECKPOINT_RESTORE</b> option enabled.</p>


<p style="margin-left:11%;"><b>PR_MPX_ENABLE_MANAGEMENT</b>,
<b>PR_MPX_DISABLE_MANAGEMENT</b> (since Linux 3.19, <br>
removed in Linux 5.4; only on x86)</p>

<p style="margin-left:22%;">Enable or disable kernel
management of Memory Protection eXtensions (MPX) bounds
tables. The <i>arg2</i>, <i>arg3</i>, <i>arg4</i>, and
<i>arg5</i> arguments must be zero.</p>

<p style="margin-left:22%; margin-top: 1em">MPX is a
hardware-assisted mechanism for performing bounds checking
on pointers. It consists of a set of registers storing
bounds information and a set of special instruction prefixes
that tell the CPU on which instructions it should do bounds
enforcement. There is a limited number of these registers
and when there are more pointers than registers, their
contents must be &quot;spilled&quot; into a set of tables.
These tables are called &quot;bounds tables&quot; and the
MPX <b>prctl</b>() operations control whether the kernel
manages their allocation and freeing.</p>

<p style="margin-left:22%; margin-top: 1em">When management
is enabled, the kernel will take over allocation and freeing
of the bounds tables. It does this by trapping the #BR
exceptions that result at first use of missing bounds tables
and instead of delivering the exception to user space, it
allocates the table and populates the bounds directory with
the location of the new table. For freeing, the kernel
checks to see if bounds tables are present for memory which
is not allocated, and frees them if so.</p>

<p style="margin-left:22%; margin-top: 1em">Before enabling
MPX management using <b>PR_MPX_ENABLE_MANAGEMENT</b>, the
application must first have allocated a user-space buffer
for the bounds directory and placed the location of that
directory in the <i>bndcfgu</i> register.</p>

<p style="margin-left:22%; margin-top: 1em">These calls
fail if the CPU or kernel does not support MPX. Kernel
support for MPX is enabled via the
<b>CONFIG_X86_INTEL_MPX</b> configuration option. You can
check whether the CPU supports MPX by looking for the
<i>mpx</i> CPUID bit, like with the following command:</p>

<p style="margin-left:28%; margin-top: 1em">cat
/proc/cpuinfo | grep ' mpx '</p>

<p style="margin-left:22%; margin-top: 1em">A thread may
not switch in or out of long (64-bit) mode while MPX is
enabled.</p>

<p style="margin-left:22%; margin-top: 1em">All threads in
a process are affected by these calls.</p>

<p style="margin-left:22%; margin-top: 1em">The child of a
<b>fork</b>(2) inherits the state of MPX management. During
<b>execve</b>(2), MPX management is reset to a state as if
<b>PR_MPX_DISABLE_MANAGEMENT</b> had been called.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information on Intel MPX, see the kernel source file
<i>Documentation/x86/intel_mpx.txt</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Due to a lack
of toolchain support, <b>PR_MPX_ENABLE_MANAGEMENT</b> and
<b>PR_MPX_DISABLE_MANAGEMENT</b> are not supported in Linux
5.4 and later.</p>

<p style="margin-left:11%;"><b>PR_SET_NAME</b> (since Linux
2.6.9)</p>

<p style="margin-left:22%;">Set the name of the calling
thread, using the value in the location pointed to by
<i>(char&nbsp;*) arg2</i>. The name can be up to 16 bytes
long, including the terminating null byte. (If the length of
the string, including the terminating null byte, exceeds 16
bytes, the string is silently truncated.) This is the same
attribute that can be set via <b>pthread_setname_np</b>(3)
and retrieved using <b>pthread_getname_np</b>(3). The
attribute is likewise accessible via
<i>/proc/self/task/[tid]/comm</i> (see <b>proc</b>(5)),
where <i>[tid]</i> is the thread ID of the calling thread,
as returned by <b>gettid</b>(2).</p>

<p style="margin-left:11%;"><b>PR_GET_NAME</b> (since Linux
2.6.11)</p>

<p style="margin-left:22%;">Return the name of the calling
thread, in the buffer pointed to by <i>(char&nbsp;*)
arg2</i>. The buffer should allow space for up to 16 bytes;
the returned string will be null-terminated.</p>

<p style="margin-left:11%;"><b>PR_SET_NO_NEW_PRIVS</b>
(since Linux 3.5)</p>

<p style="margin-left:22%;">Set the calling thread&rsquo;s
<i>no_new_privs</i> attribute to the value in <i>arg2</i>.
With <i>no_new_privs</i> set to 1, <b>execve</b>(2) promises
not to grant privileges to do anything that could not have
been done without the <b>execve</b>(2) call (for example,
rendering the set-user-ID and set-group-ID mode bits, and
file capabilities non-functional). Once set, the
<i>no_new_privs</i> attribute cannot be unset. The setting
of this attribute is inherited by children created by
<b>fork</b>(2) and <b>clone</b>(2), and preserved across
<b>execve</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">Since Linux
4.10, the value of a thread&rsquo;s <i>no_new_privs</i>
attribute can be viewed via the <i>NoNewPrivs</i> field in
the <i>/proc/[pid]/status</i> file.</p>

<p style="margin-left:22%; margin-top: 1em">For more
information, see the kernel source file
<i>Documentation/userspace-api/no_new_privs.rst</i> (or
<i>Documentation/prctl/no_new_privs.txt</i> before Linux
4.13). See also <b>seccomp</b>(2).</p>

<p style="margin-left:11%;"><b>PR_GET_NO_NEW_PRIVS</b>
(since Linux 3.5)</p>

<p style="margin-left:22%;">Return (as the function result)
the value of the <i>no_new_privs</i> attribute for the
calling thread. A value of 0 indicates the regular
<b>execve</b>(2) behavior. A value of 1 indicates
<b>execve</b>(2) will operate in the privilege-restricting
mode described above.</p>

<p style="margin-left:11%;"><b>PR_PAC_RESET_KEYS</b> (since
Linux 5.0, only on arm64)</p>

<p style="margin-left:22%;">Securely reset the
thread&rsquo;s pointer authentication keys to fresh random
values generated by the kernel.</p>

<p style="margin-left:22%; margin-top: 1em">The set of keys
to be reset is specified by <i>arg2</i>, which must be a
logical OR of zero or more of the following: <b><br>
PR_PAC_APIAKEY</b></p>

<p style="margin-left:32%;">instruction authentication key
A</p>

<p style="margin-left:22%;"><b>PR_PAC_APIBKEY</b></p>

<p style="margin-left:32%;">instruction authentication key
B</p>

<p style="margin-left:22%;"><b>PR_PAC_APDAKEY</b></p>

<p style="margin-left:32%;">data authentication key A</p>

<p style="margin-left:22%;"><b>PR_PAC_APDBKEY</b></p>

<p style="margin-left:32%;">data authentication key B</p>

<p style="margin-left:22%;"><b>PR_PAC_APGAKEY</b></p>

<p style="margin-left:32%;">generic authentication
&ldquo;A&rdquo; key.</p>

<p style="margin-left:32%; margin-top: 1em">(Yes folks,
there really is no generic B key.)</p>

<p style="margin-left:22%; margin-top: 1em">As a special
case, if <i>arg2</i> is zero, then all the keys are reset.
Since new keys could be added in future, this is the
recommended way to completely wipe the existing keys when
establishing a clean execution context. Note that there is
no need to use <b>PR_PAC_RESET_KEYS</b> in preparation for
calling <b>execve</b>(2), since <b>execve</b>(2) resets all
the pointer authentication keys.</p>

<p style="margin-left:22%; margin-top: 1em">The remaining
arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> must all
be zero.</p>

<p style="margin-left:22%; margin-top: 1em">If the
arguments are invalid, and in particular if <i>arg2</i>
contains set bits that are unrecognized or that correspond
to a key not available on this platform, then the call fails
with error <b>EINVAL</b>.</p>


<p style="margin-left:22%; margin-top: 1em"><b>Warning:</b>
Because the compiler or run-time environment may be using
some or all of the keys, a successful
<b>PR_PAC_RESET_KEYS</b> may crash the calling process. The
conditions for using it safely are complex and
system-dependent. Don&rsquo;t use it unless you know what
you are doing.</p>

<p style="margin-left:22%; margin-top: 1em">For more
information, see the kernel source file
<i>Documentation/arm64/pointer-authentication.rst</i> (or
<i>Documentation/arm64/pointer-authentication.txt</i> before
Linux 5.3).</p>

<p style="margin-left:11%;"><b>PR_SET_PDEATHSIG</b> (since
Linux 2.1.57)</p>

<p style="margin-left:22%;">Set the parent-death signal of
the calling process to <i>arg2</i> (either a signal value in
the range 1..<b>NSIG</b>-1<b>,</b> or 0 to clear). This is
the signal that the calling process will get when its parent
dies.</p>


<p style="margin-left:22%; margin-top: 1em"><i>Warning</i>:
the &quot;parent&quot; in this case is considered to be the
<i>thread</i> that created this process. In other words, the
signal will be sent when that thread terminates (via, for
example, <b>pthread_exit</b>(3)), rather than after all of
the threads in the parent process terminate.</p>

<p style="margin-left:22%; margin-top: 1em">The
parent-death signal is sent upon subsequent termination of
the parent thread and also upon termination of each
subreaper process (see the description of
<b>PR_SET_CHILD_SUBREAPER</b> above) to which the caller is
subsequently reparented. If the parent thread and all
ancestor subreapers have already terminated by the time of
the <b>PR_SET_PDEATHSIG</b> operation, then no parent-death
signal is sent to the caller.</p>

<p style="margin-left:22%; margin-top: 1em">The
parent-death signal is process-directed (see
<b>signal</b>(7)) and, if the child installs a handler using
the <b>sigaction</b>(2) <b>SA_SIGINFO</b> flag, the
<i>si_pid</i> field of the <i>siginfo_t</i> argument of the
handler contains the PID of the terminating parent
process.</p>

<p style="margin-left:22%; margin-top: 1em">The
parent-death signal setting is cleared for the child of a
<b>fork</b>(2). It is also (since Linux 2.4.36 / 2.6.23)
cleared when executing a set-user-ID or set-group-ID binary,
or a binary that has associated capabilities (see
<b>capabilities</b>(7)); otherwise, this value is preserved
across <b>execve</b>(2). The parent-death signal setting is
also cleared upon changes to any of the following thread
credentials: effective user ID, effective group ID,
filesystem user ID, or filesystem group ID.</p>

<p style="margin-left:11%;"><b>PR_GET_PDEATHSIG</b> (since
Linux 2.3.15)</p>

<p style="margin-left:22%;">Return the current value of the
parent process death signal, in the location pointed to by
<i>(int&nbsp;*) arg2</i>.</p>

<p style="margin-left:11%;"><b>PR_SET_PTRACER</b> (since
Linux 3.4)</p>

<p style="margin-left:22%;">This is meaningful only when
the Yama LSM is enabled and in mode 1 (&quot;restricted
ptrace&quot;, visible via
<i>/proc/sys/kernel/yama/ptrace_scope</i>). When a
&quot;ptracer process ID&quot; is passed in <i>arg2</i>, the
caller is declaring that the ptracer process can
<b>ptrace</b>(2) the calling process as if it were a direct
process ancestor. Each <b>PR_SET_PTRACER</b> operation
replaces the previous &quot;ptracer process ID&quot;.
Employing <b>PR_SET_PTRACER</b> with <i>arg2</i> set to 0
clears the caller&rsquo;s &quot;ptracer process ID&quot;. If
<i>arg2</i> is <b>PR_SET_PTRACER_ANY</b>, the ptrace
restrictions introduced by Yama are effectively disabled for
the calling process.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information, see the kernel source file
<i>Documentation/admin-guide/LSM/Yama.rst</i> (or
<i>Documentation/security/Yama.txt</i> before Linux
4.13).</p>

<p style="margin-left:11%;"><b>PR_SET_SECCOMP</b> (since
Linux 2.6.23)</p>

<p style="margin-left:22%;">Set the secure computing
(seccomp) mode for the calling thread, to limit the
available system calls. The more recent <b>seccomp</b>(2)
system call provides a superset of the functionality of
<b>PR_SET_SECCOMP</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The seccomp
mode is selected via <i>arg2</i>. (The seccomp constants are
defined in <i>&lt;linux/seccomp.h&gt;</i>.)</p>

<p style="margin-left:22%; margin-top: 1em">With
<i>arg2</i> set to <b>SECCOMP_MODE_STRICT</b>, the only
system calls that the thread is permitted to make are
<b>read</b>(2), <b>write</b>(2), <b>_exit</b>(2) (but not
<b>exit_group</b>(2)), and <b>sigreturn</b>(2). Other system
calls result in the delivery of a <b>SIGKILL</b> signal.
Strict secure computing mode is useful for number-crunching
applications that may need to execute untrusted byte code,
perhaps obtained by reading from a pipe or socket. This
operation is available only if the kernel is configured with
<b>CONFIG_SECCOMP</b> enabled.</p>

<p style="margin-left:22%; margin-top: 1em">With
<i>arg2</i> set to <b>SECCOMP_MODE_FILTER</b> (since Linux
3.5), the system calls allowed are defined by a pointer to a
Berkeley Packet Filter passed in <i>arg3</i>. This argument
is a pointer to <i>struct sock_fprog</i>; it can be designed
to filter arbitrary system calls and system call arguments.
This mode is available only if the kernel is configured with
<b>CONFIG_SECCOMP_FILTER</b> enabled.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>SECCOMP_MODE_FILTER</b> filters permit <b>fork</b>(2),
then the seccomp mode is inherited by children created by
<b>fork</b>(2); if <b>execve</b>(2) is permitted, then the
seccomp mode is preserved across <b>execve</b>(2). If the
filters permit <b>prctl</b>() calls, then additional filters
can be added; they are run in order until the first
non-allow result is seen.</p>

<p style="margin-left:22%; margin-top: 1em">For further
information, see the kernel source file
<i>Documentation/userspace-api/seccomp_filter.rst</i> (or
<i>Documentation/prctl/seccomp_filter.txt</i> before Linux
4.13).</p>

<p style="margin-left:11%;"><b>PR_GET_SECCOMP</b> (since
Linux 2.6.23)</p>

<p style="margin-left:22%;">Return (as the function result)
the secure computing mode of the calling thread. If the
caller is not in secure computing mode, this operation
returns 0; if the caller is in strict secure computing mode,
then the <b>prctl</b>() call will cause a <b>SIGKILL</b>
signal to be sent to the process. If the caller is in filter
mode, and this system call is allowed by the seccomp
filters, it returns 2; otherwise, the process is killed with
a <b>SIGKILL</b> signal. This operation is available only if
the kernel is configured with <b>CONFIG_SECCOMP</b>
enabled.</p>

<p style="margin-left:22%; margin-top: 1em">Since Linux
3.8, the <i>Seccomp</i> field of the
<i>/proc/[pid]/status</i> file provides a method of
obtaining the same information, without the risk that the
process is killed; see <b>proc</b>(5).</p>

<p style="margin-left:11%;"><b>PR_SET_SECUREBITS</b> (since
Linux 2.6.26)</p>

<p style="margin-left:22%;">Set the &quot;securebits&quot;
flags of the calling thread to the value supplied in
<i>arg2</i>. See <b>capabilities</b>(7).</p>

<p style="margin-left:11%;"><b>PR_GET_SECUREBITS</b> (since
Linux 2.6.26)</p>

<p style="margin-left:22%;">Return (as the function result)
the &quot;securebits&quot; flags of the calling thread. See
<b>capabilities</b>(7).</p>

<p style="margin-left:11%;"><b>PR_GET_SPECULATION_CTRL</b>
(since Linux 4.17)</p>

<p style="margin-left:22%;">Return (as the function result)
the state of the speculation misfeature specified in
<i>arg2</i>. Currently, the only permitted value for this
argument is <b>PR_SPEC_STORE_BYPASS</b> (otherwise the call
fails with the error <b>ENODEV</b>).</p>

<p style="margin-left:22%; margin-top: 1em">The return
value uses bits 0-3 with the following meaning: <b><br>
PR_SPEC_PRCTL</b></p>

<p style="margin-left:32%;">Mitigation can be controlled
per thread by <b>PR_SET_SPECULATION_CTRL</b>.</p>

<p style="margin-left:22%;"><b>PR_SPEC_ENABLE</b></p>

<p style="margin-left:32%;">The speculation feature is
enabled, mitigation is disabled.</p>

<p style="margin-left:22%;"><b>PR_SPEC_DISABLE</b></p>

<p style="margin-left:32%;">The speculation feature is
disabled, mitigation is enabled.</p>


<p style="margin-left:22%;"><b>PR_SPEC_FORCE_DISABLE</b></p>

<p style="margin-left:32%;">Same as <b>PR_SPEC_DISABLE</b>
but cannot be undone.</p>

<p style="margin-left:22%;"><b>PR_SPEC_DISABLE_NOEXEC</b>
(since Linux 5.1)</p>

<p style="margin-left:32%;">Same as <b>PR_SPEC_DISABLE</b>,
but the state will be cleared on <b>execve</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">If all bits are
0, then the CPU is not affected by the speculation
misfeature.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>PR_SPEC_PRCTL</b> is set, then per-thread control of the
mitigation is available. If not set, <b>prctl</b>() for the
speculation misfeature will fail.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>arg3</i>, <i>arg4</i>, and <i>arg5</i> arguments must be
specified as 0; otherwise the call fails with the error
<b>EINVAL</b>.</p>

<p style="margin-left:11%;"><b>PR_SET_SPECULATION_CTRL</b>
(since Linux 4.17)</p>

<p style="margin-left:22%;">Sets the state of the
speculation misfeature specified in <i>arg2</i>. The
speculation-misfeature settings are per-thread
attributes.</p>

<p style="margin-left:22%; margin-top: 1em">Currently,
<i>arg2</i> must be one of: <b><br>
PR_SPEC_STORE_BYPASS</b></p>

<p style="margin-left:32%;">Set the state of the
speculative store bypass misfeature.</p>

<p style="margin-left:22%;"><b>PR_SPEC_INDIRECT_BRANCH</b>
(since Linux 4.20)</p>

<p style="margin-left:32%;">Set the state of the indirect
branch speculation misfeature.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>arg2</i>
does not have one of the above values, then the call fails
with the error <b>ENODEV</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The <i>arg3</i>
argument is used to hand in the control value, which is one
of the following: <b><br>
PR_SPEC_ENABLE</b></p>

<p style="margin-left:32%;">The speculation feature is
enabled, mitigation is disabled.</p>

<p style="margin-left:22%;"><b>PR_SPEC_DISABLE</b></p>

<p style="margin-left:32%;">The speculation feature is
disabled, mitigation is enabled.</p>


<p style="margin-left:22%;"><b>PR_SPEC_FORCE_DISABLE</b></p>

<p style="margin-left:32%;">Same as <b>PR_SPEC_DISABLE</b>,
but cannot be undone. A subsequent <b>prctl</b>(<i>arg2</i>,
<b>PR_SPEC_ENABLE</b>) with the same value for <i>arg2</i>
will fail with the error <b>EPERM</b>.</p>

<p style="margin-left:22%;"><b>PR_SPEC_DISABLE_NOEXEC</b>
(since Linux 5.1)</p>

<p style="margin-left:32%;">Same as <b>PR_SPEC_DISABLE</b>,
but the state will be cleared on <b>execve</b>(2). Currently
only supported for <i>arg2</i> equal to
<b>PR_SPEC_STORE_BYPASS.</b></p>

<p style="margin-left:22%; margin-top: 1em">Any unsupported
value in <i>arg3</i> will result in the call failing with
the error <b>ERANGE</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The <i>arg4</i>
and <i>arg5</i> arguments must be specified as 0; otherwise
the call fails with the error <b>EINVAL</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The speculation
feature can also be controlled by the
<b>spec_store_bypass_disable</b> boot parameter. This
parameter may enforce a read-only policy which will result
in the <b>prctl</b>() call failing with the error
<b>ENXIO</b>. For further details, see the kernel source
file
<i>Documentation/admin-guide/kernel-parameters.txt</i>.</p>

<p style="margin-left:11%;"><b>PR_SVE_SET_VL</b> (since
Linux 4.15, only on arm64)</p>

<p style="margin-left:22%;">Configure the thread&rsquo;s
SVE vector length, as specified by <i>(int) arg2</i>.
Arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are
ignored.</p>

<p style="margin-left:22%; margin-top: 1em">The bits of
<i>arg2</i> corresponding to <b>PR_SVE_VL_LEN_MASK</b> must
be set to the desired vector length in bytes. This is
interpreted as an upper bound: the kernel will select the
greatest available vector length that does not exceed the
value specified. In particular, specifying <b>SVE_VL_MAX</b>
(defined in <i>&lt;asm/sigcontext.h&gt;)</i> for the
<b>PR_SVE_VL_LEN_MASK</b> bits requests the maximum
supported vector length.</p>

<p style="margin-left:22%; margin-top: 1em">In addition,
the other bits of <i>arg2</i> must be set to one of the
following combinations of flags:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p><b>0</b></p></td>
<td width="9%"></td>
<td width="68%">


<p>Perform the change immediately. At the next
<b>execve</b>(2) in the thread, the vector length will be
reset to the value configured in
<i>/proc/sys/abi/sve_default_vector_length</i>.</p> </td></tr>
</table>

<p style="margin-left:22%;"><b>PR_SVE_VL_INHERIT</b></p>

<p style="margin-left:32%;">Perform the change immediately.
Subsequent <b>execve</b>(2) calls will preserve the new
vector length.</p>


<p style="margin-left:22%;"><b>PR_SVE_SET_VL_ONEXEC</b></p>

<p style="margin-left:32%;">Defer the change, so that it is
performed at the next <b>execve</b>(2) in the thread.
Further <b>execve</b>(2) calls will reset the vector length
to the value configured in
<i>/proc/sys/abi/sve_default_vector_length</i>.</p>

<p style="margin-left:22%;"><b>PR_SVE_SET_VL_ONEXEC |
PR_SVE_VL_INHERIT</b></p>

<p style="margin-left:32%;">Defer the change, so that it is
performed at the next <b>execve</b>(2) in the thread.
Further <b>execve</b>(2) calls will preserve the new vector
length.</p>

<p style="margin-left:22%; margin-top: 1em">In all cases,
any previously pending deferred change is canceled.</p>

<p style="margin-left:22%; margin-top: 1em">The call fails
with error <b>EINVAL</b> if SVE is not supported on the
platform, if <i>arg2</i> is unrecognized or invalid, or the
value in the bits of <i>arg2</i> corresponding to
<b>PR_SVE_VL_LEN_MASK</b> is outside the range
<b>SVE_VL_MIN</b>..<b>SVE_VL_MAX</b> or is not a multiple of
16.</p>

<p style="margin-left:22%; margin-top: 1em">On success, a
nonnegative value is returned that describes the
<i>selected</i> configuration. If
<b>PR_SVE_SET_VL_ONEXEC</b> was included in <i>arg2</i>,
then the configuration described by the return value will
take effect at the next <b>execve</b>(). Otherwise, the
configuration is already in effect when the
<b>PR_SVE_SET_VL</b> call returns. In either case, the value
is encoded in the same way as the return value of
<b>PR_SVE_GET_VL</b>. Note that there is no explicit flag in
the return value corresponding to
<b>PR_SVE_SET_VL_ONEXEC</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The
configuration (including any pending deferred change) is
inherited across <b>fork</b>(2) and <b>clone</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">For more
information, see the kernel source file
<i>Documentation/arm64/sve.rst</i> (or
<i>Documentation/arm64/sve.txt</i> before Linux 5.3).</p>


<p style="margin-left:22%; margin-top: 1em"><b>Warning:</b>
Because the compiler or run-time environment may be using
SVE, using this call without the <b>PR_SVE_SET_VL_ONEXEC</b>
flag may crash the calling process. The conditions for using
it safely are complex and system-dependent. Don&rsquo;t use
it unless you really know what you are doing.</p>

<p style="margin-left:11%;"><b>PR_SVE_GET_VL</b> (since
Linux 4.15, only on arm64)</p>

<p style="margin-left:22%;">Get the thread&rsquo;s current
SVE vector length configuration.</p>

<p style="margin-left:22%; margin-top: 1em">Arguments
<i>arg2</i>, <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are
ignored.</p>

<p style="margin-left:22%; margin-top: 1em">Provided that
the kernel and platform support SVE, this operation always
succeeds, returning a nonnegative value that describes the
<i>current</i> configuration. The bits corresponding to
<b>PR_SVE_VL_LEN_MASK</b> contain the currently configured
vector length in bytes. The bit corresponding to
<b>PR_SVE_VL_INHERIT</b> indicates whether the vector length
will be inherited across <b>execve</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">Note that there
is no way to determine whether there is a pending vector
length change that has not yet taken effect.</p>

<p style="margin-left:22%; margin-top: 1em">For more
information, see the kernel source file
<i>Documentation/arm64/sve.rst</i> (or
<i>Documentation/arm64/sve.txt</i> before Linux 5.3).</p>

<p style="margin-left:11%;"><b>PR_SET_TAGGED_ADDR_CTRL</b>
(since Linux 5.4, only on arm64)</p>

<p style="margin-left:22%;">Controls support for passing
tagged user-space addresses to the kernel (i.e., addresses
where bits 56&mdash;63 are not all zero).</p>

<p style="margin-left:22%; margin-top: 1em">The level of
support is selected by <i>arg2</i>, which can be one of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p><b>0</b></p></td>
<td width="9%"></td>
<td width="68%">


<p>Addresses that are passed for the purpose of being
dereferenced by the kernel must be untagged.</p></td></tr>
</table>


<p style="margin-left:22%;"><b>PR_TAGGED_ADDR_ENABLE</b></p>

<p style="margin-left:32%;">Addresses that are passed for
the purpose of being dereferenced by the kernel may be
tagged, with the exceptions summarized below.</p>

<p style="margin-left:22%; margin-top: 1em">The remaining
arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> must all
be zero.</p>

<p style="margin-left:22%; margin-top: 1em">On success, the
mode specified in <i>arg2</i> is set for the calling thread
and the return value is 0. If the arguments are invalid, the
mode specified in <i>arg2</i> is unrecognized, or if this
feature is unsupported by the kernel or disabled via
<i>/proc/sys/abi/tagged_addr_disabled</i>, the call fails
with the error <b>EINVAL</b>.</p>

<p style="margin-left:22%; margin-top: 1em">In particular,
if <b>prctl</b>(<b>PR_SET_TAGGED_ADDR_CTRL</b>, 0, 0, 0, 0)
fails with <b>EINVAL</b>, then all addresses passed to the
kernel must be untagged.</p>

<p style="margin-left:22%; margin-top: 1em">Irrespective of
which mode is set, addresses passed to certain interfaces
must always be untagged:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>brk</b>(2), <b>mmap</b>(2), <b>shmat</b>(2),
<b>shmdt</b>(2), and the <i>new_address</i> argument of
<b>mremap</b>(2).</p> </td></tr>
</table>

<p style="margin-left:25%; margin-top: 1em">(Prior to Linux
5.6 these accepted tagged addresses, but the behaviour may
not be what you expect. Don&rsquo;t rely on it.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em">&rsquo;polymorphic&rsquo;
interfaces that accept pointers to arbitrary types cast to a
<i>void *</i> or other generic type, specifically
<b>prctl</b>(), <b>ioctl</b>(2), and in general
<b>setsockopt</b>(2) (only certain specific
<b>setsockopt</b>(2) options allow tagged addresses).</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This list of
exclusions may shrink when moving from one kernel version to
a later kernel version. While the kernel may make some
guarantees for backwards compatibility reasons, for the
purposes of new software the effect of passing tagged
addresses to these interfaces is unspecified.</p>

<p style="margin-left:22%; margin-top: 1em">The mode set by
this call is inherited across <b>fork</b>(2) and
<b>clone</b>(2). The mode is reset by <b>execve</b>(2) to 0
(i.e., tagged addresses not permitted in the user/kernel
ABI).</p>

<p style="margin-left:22%; margin-top: 1em">For more
information, see the kernel source file
<i>Documentation/arm64/tagged-address-abi.rst</i>.</p>


<p style="margin-left:22%; margin-top: 1em"><b>Warning:</b>
This call is primarily intended for use by the run-time
environment. A successful <b>PR_SET_TAGGED_ADDR_CTRL</b>
call elsewhere may crash the calling process. The conditions
for using it safely are complex and system-dependent.
Don&rsquo;t use it unless you know what you are doing.</p>

<p style="margin-left:11%;"><b>PR_GET_TAGGED_ADDR_CTRL</b>
(since Linux 5.4, only on arm64)</p>

<p style="margin-left:22%;">Returns the current tagged
address mode for the calling thread.</p>

<p style="margin-left:22%; margin-top: 1em">Arguments
<i>arg2</i>, <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> must
all be zero.</p>

<p style="margin-left:22%; margin-top: 1em">If the
arguments are invalid or this feature is disabled or
unsupported by the kernel, the call fails with
<b>EINVAL</b>. In particular, if
<b>prctl</b>(<b>PR_GET_TAGGED_ADDR_CTRL</b>, 0, 0, 0, 0)
fails with <b>EINVAL</b>, then this feature is definitely
either unsupported, or disabled via
<i>/proc/sys/abi/tagged_addr_disabled</i>. In this case, all
addresses passed to the kernel must be untagged.</p>

<p style="margin-left:22%; margin-top: 1em">Otherwise, the
call returns a nonnegative value describing the current
tagged address mode, encoded in the same way as the
<i>arg2</i> argument of <b>PR_SET_TAGGED_ADDR_CTRL</b>.</p>

<p style="margin-left:22%; margin-top: 1em">For more
information, see the kernel source file
<i>Documentation/arm64/tagged-address-abi.rst</i>.</p>


<p style="margin-left:11%;"><b>PR_TASK_PERF_EVENTS_DISABLE</b>
(since Linux 2.6.31)</p>

<p style="margin-left:22%;">Disable all performance
counters attached to the calling process, regardless of
whether the counters were created by this process or another
process. Performance counters created by the calling process
for other processes are unaffected. For more information on
performance counters, see the Linux kernel source file
<i>tools/perf/design.txt</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Originally
called <b>PR_TASK_PERF_COUNTERS_DISABLE</b>; renamed
(retaining the same numerical value) in Linux 2.6.32.</p>


<p style="margin-left:11%;"><b>PR_TASK_PERF_EVENTS_ENABLE</b>
(since Linux 2.6.31)</p>

<p style="margin-left:22%;">The converse of
<b>PR_TASK_PERF_EVENTS_DISABLE</b>; enable performance
counters attached to the calling process.</p>

<p style="margin-left:22%; margin-top: 1em">Originally
called <b>PR_TASK_PERF_COUNTERS_ENABLE</b>; renamed in Linux
2.6.32.</p>

<p style="margin-left:11%;"><b>PR_SET_THP_DISABLE</b>
(since Linux 3.15)</p>

<p style="margin-left:22%;">Set the state of the &quot;THP
disable&quot; flag for the calling thread. If <i>arg2</i>
has a nonzero value, the flag is set, otherwise it is
cleared. Setting this flag provides a method for disabling
transparent huge pages for jobs where the code cannot be
modified, and using a malloc hook with <b>madvise</b>(2) is
not an option (i.e., statically allocated data). The setting
of the &quot;THP disable&quot; flag is inherited by a child
created via <b>fork</b>(2) and is preserved across
<b>execve</b>(2).</p>

<p style="margin-left:11%;"><b>PR_GET_THP_DISABLE</b>
(since Linux 3.15)</p>

<p style="margin-left:22%;">Return (as the function result)
the current setting of the &quot;THP disable&quot; flag for
the calling thread: either 1, if the flag is set, or 0, if
it is not.</p>

<p style="margin-left:11%;"><b>PR_GET_TID_ADDRESS</b>
(since Linux 3.5)</p>

<p style="margin-left:22%;">Return the
<i>clear_child_tid</i> address set by
<b>set_tid_address</b>(2) and the <b>clone</b>(2)
<b>CLONE_CHILD_CLEARTID</b> flag, in the location pointed to
by <i>(int&nbsp;**)&nbsp;arg2</i>. This feature is available
only if the kernel is built with the
<b>CONFIG_CHECKPOINT_RESTORE</b> option enabled. Note that
since the <b>prctl</b>() system call does not have a compat
implementation for the AMD64 x32 and MIPS n32 ABIs, and the
kernel writes out a pointer using the kernel&rsquo;s pointer
size, this operation expects a user-space buffer of 8 (not
4) bytes on these ABIs.</p>

<p style="margin-left:11%;"><b>PR_SET_TIMERSLACK</b> (since
Linux 2.6.28)</p>

<p style="margin-left:22%;">Each thread has two associated
timer slack values: a &quot;default&quot; value, and a
&quot;current&quot; value. This operation sets the
&quot;current&quot; timer slack value for the calling
thread. <i>arg2</i> is an unsigned long value, then maximum
&quot;current&quot; value is ULONG_MAX and the minimum
&quot;current&quot; value is 1. If the nanosecond value
supplied in <i>arg2</i> is greater than zero, then the
&quot;current&quot; value is set to this value. If
<i>arg2</i> is equal to zero, the &quot;current&quot; timer
slack is reset to the thread&rsquo;s &quot;default&quot;
timer slack value.</p>

<p style="margin-left:22%; margin-top: 1em">The
&quot;current&quot; timer slack is used by the kernel to
group timer expirations for the calling thread that are
close to one another; as a consequence, timer expirations
for the thread may be up to the specified number of
nanoseconds late (but will never expire early). Grouping
timer expirations can help reduce system power consumption
by minimizing CPU wake-ups.</p>

<p style="margin-left:22%; margin-top: 1em">The timer
expirations affected by timer slack are those set by
<b>select</b>(2), <b>pselect</b>(2), <b>poll</b>(2),
<b>ppoll</b>(2), <b>epoll_wait</b>(2),
<b>epoll_pwait</b>(2), <b>clock_nanosleep</b>(2),
<b>nanosleep</b>(2), and <b>futex</b>(2) (and thus the
library functions implemented via futexes, including
<b>pthread_cond_timedwait</b>(3),
<b>pthread_mutex_timedlock</b>(3),
<b>pthread_rwlock_timedrdlock</b>(3),
<b>pthread_rwlock_timedwrlock</b>(3), and
<b>sem_timedwait</b>(3)).</p>

<p style="margin-left:22%; margin-top: 1em">Timer slack is
not applied to threads that are scheduled under a real-time
scheduling policy (see <b>sched_setscheduler</b>(2)).</p>

<p style="margin-left:22%; margin-top: 1em">When a new
thread is created, the two timer slack values are made the
same as the &quot;current&quot; value of the creating
thread. Thereafter, a thread can adjust its
&quot;current&quot; timer slack value via
<b>PR_SET_TIMERSLACK</b>. The &quot;default&quot; value
can&rsquo;t be changed. The timer slack values of
<i>init</i> (PID 1), the ancestor of all processes, are
50,000 nanoseconds (50 microseconds). The timer slack value
is inherited by a child created via <b>fork</b>(2), and is
preserved across <b>execve</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">Since Linux
4.6, the &quot;current&quot; timer slack value of any
process can be examined and changed via the file
<i>/proc/[pid]/timerslack_ns</i>. See <b>proc</b>(5).</p>

<p style="margin-left:11%;"><b>PR_GET_TIMERSLACK</b> (since
Linux 2.6.28)</p>

<p style="margin-left:22%;">Return (as the function result)
the &quot;current&quot; timer slack value of the calling
thread.</p>

<p style="margin-left:11%;"><b>PR_SET_TIMING</b> (since
Linux 2.6.0)</p>

<p style="margin-left:22%;">Set whether to use (normal,
traditional) statistical process timing or accurate
timestamp-based process timing, by passing
<b>PR_TIMING_STATISTICAL</b> or <b>PR_TIMING_TIMESTAMP</b>
to <i>arg2</i>. <b>PR_TIMING_TIMESTAMP</b> is not currently
implemented (attempting to set this mode will yield the
error <b>EINVAL</b>).</p>

<p style="margin-left:11%;"><b>PR_GET_TIMING</b> (since
Linux 2.6.0)</p>

<p style="margin-left:22%;">Return (as the function result)
which process timing method is currently in use.</p>

<p style="margin-left:11%;"><b>PR_SET_TSC</b> (since Linux
2.6.26, x86 only)</p>

<p style="margin-left:22%;">Set the state of the flag
determining whether the timestamp counter can be read by the
process. Pass <b>PR_TSC_ENABLE</b> to <i>arg2</i> to allow
it to be read, or <b>PR_TSC_SIGSEGV</b> to generate a
<b>SIGSEGV</b> when the process tries to read the timestamp
counter.</p>

<p style="margin-left:11%;"><b>PR_GET_TSC</b> (since Linux
2.6.26, x86 only)</p>

<p style="margin-left:22%;">Return the state of the flag
determining whether the timestamp counter can be read, in
the location pointed to by <i>(int&nbsp;*) arg2</i>.</p>

<p style="margin-left:11%;"><b>PR_SET_UNALIGN</b></p>

<p style="margin-left:22%;">(Only on: ia64, since Linux
2.3.48; parisc, since Linux 2.6.15; PowerPC, since Linux
2.6.18; Alpha, since Linux 2.6.22; sh, since Linux 2.6.34;
tile, since Linux 3.12) Set unaligned access control bits to
<i>arg2</i>. Pass <b>PR_UNALIGN_NOPRINT</b> to silently fix
up unaligned user accesses, or <b>PR_UNALIGN_SIGBUS</b> to
generate <b>SIGBUS</b> on unaligned user access. Alpha also
supports an additional flag with the value of 4 and no
corresponding named constant, which instructs kernel to not
fix up unaligned accesses (it is analogous to providing the
<b>UAC_NOFIX</b> flag in <b>SSI_NVPAIRS</b> operation of the
<b>setsysinfo</b>() system call on Tru64).</p>

<p style="margin-left:11%;"><b>PR_GET_UNALIGN</b></p>

<p style="margin-left:22%;">(See <b>PR_SET_UNALIGN</b> for
information on versions and architectures.) Return unaligned
access control bits, in the location pointed to by
<i>(unsigned int&nbsp;*) arg2</i>.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
<b>PR_CAP_AMBIENT</b>+<b>PR_CAP_AMBIENT_IS_SET</b>,
<b>PR_CAPBSET_READ</b>, <b>PR_GET_DUMPABLE</b>,
<b>PR_GET_FP_MODE</b>, <b>PR_GET_IO_FLUSHER</b>,
<b>PR_GET_KEEPCAPS</b>, <b>PR_MCE_KILL_GET</b>,
<b>PR_GET_NO_NEW_PRIVS</b>, <b>PR_GET_SECUREBITS</b>,
<b>PR_GET_SPECULATION_CTRL</b>, <b>PR_SVE_GET_VL</b>,
<b>PR_SVE_SET_VL</b>, <b>PR_GET_TAGGED_ADDR_CTRL</b>,
<b>PR_GET_THP_DISABLE</b>, <b>PR_GET_TIMING</b>,
<b>PR_GET_TIMERSLACK</b>, and (if it returns)
<b>PR_GET_SECCOMP</b> return the nonnegative values
described above. All other <i>option</i> values return 0 on
success. On error, -1 is returned, and <i>errno</i> is set
appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><i>option</i> is
<b>PR_SET_SECCOMP</b> and <i>arg2</i> is
<b>SECCOMP_MODE_FILTER</b>, but the process does not have
the <b>CAP_SYS_ADMIN</b> capability or has not set the
<i>no_new_privs</i> attribute (see the discussion of
<b>PR_SET_NO_NEW_PRIVS</b> above).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_MM</b>, and <i>arg3</i> is
<b>PR_SET_MM_EXE_FILE</b>, the file is not executable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_MM</b>, <i>arg3</i> is
<b>PR_SET_MM_EXE_FILE</b>, and the file descriptor passed in
<i>arg4</i> is not valid.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBUSY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_MM</b>, <i>arg3</i> is
<b>PR_SET_MM_EXE_FILE</b>, and this the second attempt to
change the <i>/proc/pid/exe</i> symbolic link, which is
prohibited.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>arg2</i> is an invalid address.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_SECCOMP</b>, <i>arg2</i> is
<b>SECCOMP_MODE_FILTER</b>, the system was built with
<b>CONFIG_SECCOMP_FILTER</b>, and <i>arg3</i> is an invalid
address.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The value of <i>option</i> is not recognized, or not
supported on this system.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_MCE_KILL</b> or
<b>PR_MCE_KILL_GET</b> or <b>PR_SET_MM</b>, and unused
<b>prctl</b>() arguments were not specified as zero.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>arg2</i> is not valid value for this
<i>option</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_SECCOMP</b> or
<b>PR_GET_SECCOMP</b>, and the kernel was not configured
with <b>CONFIG_SECCOMP</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_SECCOMP</b>, <i>arg2</i> is
<b>SECCOMP_MODE_FILTER</b>, and the kernel was not
configured with <b>CONFIG_SECCOMP_FILTER</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_MM</b>, and one of the
following is true</p></td></tr>
</table>

<p style="margin-left:22%;">*</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%"></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em"><i>arg4</i> or <i>arg5</i> is
nonzero;</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>arg3</i> is greater than <b>TASK_SIZE</b> (the limit
on the size of the user address space for this
architecture);</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>arg2</i> is <b>PR_SET_MM_START_CODE</b>,
<b>PR_SET_MM_END_CODE</b>, <b>PR_SET_MM_START_DATA</b>,
<b>PR_SET_MM_END_DATA</b>, or <b>PR_SET_MM_START_STACK</b>,
and the permissions of the corresponding memory area are not
as required;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>arg2</i> is <b>PR_SET_MM_START_BRK</b> or
<b>PR_SET_MM_BRK</b>, and <i>arg3</i> is less than or equal
to the end of the data segment or specifies a value that
would cause the <b>RLIMIT_DATA</b> resource limit to be
exceeded.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>EINVAL</b></p></td>
<td width="3%"></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em"><i>option</i>
is <b>PR_SET_PTRACER</b> and <i>arg2</i> is not 0,
<b>PR_SET_PTRACER_ANY</b>, or the PID of an existing
process.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><i>option</i> is
<b>PR_SET_PDEATHSIG</b> and <i>arg2</i> is not a valid
signal number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_DUMPABLE</b> and <i>arg2</i>
is neither <b>SUID_DUMP_DISABLE</b> nor
<b>SUID_DUMP_USER</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_TIMING</b> and <i>arg2</i> is
not <b>PR_TIMING_STATISTICAL</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_NO_NEW_PRIVS</b> and
<i>arg2</i> is not equal to 1 or <i>arg3</i>, <i>arg4</i>,
or <i>arg5</i> is nonzero.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_GET_NO_NEW_PRIVS</b> and
<i>arg2</i>, <i>arg3</i>, <i>arg4</i>, or <i>arg5</i> is
nonzero.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_THP_DISABLE</b> and
<i>arg3</i>, <i>arg4</i>, or <i>arg5</i> is nonzero.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_GET_THP_DISABLE</b> and
<i>arg2</i>, <i>arg3</i>, <i>arg4</i>, or <i>arg5</i> is
nonzero.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_CAP_AMBIENT</b> and an unused
argument (<i>arg4</i>, <i>arg5</i>, or, in the case of
<b>PR_CAP_AMBIENT_CLEAR_ALL</b>, <i>arg3</i>) is nonzero; or
<i>arg2</i> has an invalid value; or <i>arg2</i> is
<b>PR_CAP_AMBIENT_LOWER</b>, <b>PR_CAP_AMBIENT_RAISE</b>, or
<b>PR_CAP_AMBIENT_IS_SET</b> and <i>arg3</i> does not
specify a valid capability.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> was <b>PR_GET_SPECULATION_CTRL</b> or
<b>PR_SET_SPECULATION_CTRL</b> and unused arguments to
<b>prctl</b>() are not 0. <b>EINVAL</b> <i>option</i> is
<b>PR_PAC_RESET_KEYS</b> and the arguments are invalid or
unsupported. See the description of <b>PR_PAC_RESET_KEYS</b>
above for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SVE_SET_VL</b> and the arguments
are invalid or unsupported, or SVE is not available on this
platform. See the description of <b>PR_SVE_SET_VL</b> above
for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SVE_GET_VL</b> and SVE is not
available on this platform.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_TAGGED_ADDR_CTRL</b> and the
arguments are invalid or unsupported. See the description of
<b>PR_SET_TAGGED_ADDR_CTRL</b> above for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_GET_TAGGED_ADDR_CTRL</b> and the
arguments are invalid or unsupported. See the description of
<b>PR_GET_TAGGED_ADDR_CTRL</b> above for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENODEV</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> was <b>PR_SET_SPECULATION_CTRL</b> the
kernel or CPU does not support the requested speculation
misfeature.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> was <b>PR_MPX_ENABLE_MANAGEMENT</b> or
<b>PR_MPX_DISABLE_MANAGEMENT</b> and the kernel or the CPU
does not support MPX management. Check that the kernel and
processor have MPX support.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> was <b>PR_SET_SPECULATION_CTRL</b> implies
that the control of the selected speculation misfeature is
not possible. See <b>PR_GET_SPECULATION_CTRL</b> for the bit
fields to determine which option is available.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EOPNOTSUPP</b></p>

<p style="margin-left:22%;"><i>option</i> is
<b>PR_SET_FP_MODE</b> and <i>arg2</i> has an invalid or
unsupported value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_SECUREBITS</b>, and the
caller does not have the <b>CAP_SETPCAP</b> capability, or
tried to unset a &quot;locked&quot; flag, or tried to set a
flag whose corresponding locked flag was set (see
<b>capabilities</b>(7)).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_SPECULATION_CTRL</b> wherein
the speculation was disabled with
<b>PR_SPEC_FORCE_DISABLE</b> and caller tried to enable it
again.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_KEEPCAPS</b>, and the
caller&rsquo;s <b>SECBIT_KEEP_CAPS_LOCKED</b> flag is set
(see <b>capabilities</b>(7)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_CAPBSET_DROP</b>, and the caller
does not have the <b>CAP_SETPCAP</b> capability.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_SET_MM</b>, and the caller does
not have the <b>CAP_SYS_RESOURCE</b> capability.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> is <b>PR_CAP_AMBIENT</b> and <i>arg2</i>
is <b>PR_CAP_AMBIENT_RAISE</b>, but either the capability
specified in <i>arg3</i> is not present in the
process&rsquo;s permitted and inheritable capability sets,
or the <b>PR_CAP_AMBIENT_LOWER</b> securebit has been
set.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ERANGE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>option</i> was <b>PR_SET_SPECULATION_CTRL</b> and
<i>arg3</i> is not <b>PR_SPEC_ENABLE</b>,
<b>PR_SPEC_DISABLE</b>, <b>PR_SPEC_FORCE_DISABLE</b>, nor
<b>PR_SPEC_DISABLE_NOEXEC</b>.</p> </td></tr>
</table>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>prctl</b>() system call was introduced in Linux
2.1.57.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This call is
Linux-specific. IRIX has a <b>prctl</b>() system call (also
introduced in Linux 2.1.44 as irix_prctl on the MIPS
architecture), with prototype</p>

<p style="margin-left:17%; margin-top: 1em"><b>ptrdiff_t
prctl(int</b> <i>option</i><b>, int</b> <i>arg2</i><b>,
int</b> <i>arg3</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">and options to
get the maximum number of processes per user, get the
maximum number of processors the calling process can use,
find out whether a specified process is currently blocked,
get or set the maximum stack size, and so on.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>signal</b>(2),
<b>core</b>(5)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
