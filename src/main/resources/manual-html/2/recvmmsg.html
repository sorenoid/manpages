<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:01 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>RECVMMSG</title>

</head>
<body>

<h1 align="center">RECVMMSG</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">recvmmsg -
receive multiple messages on a socket</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#define
_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>
#include &lt;sys/socket.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
recvmmsg(int</b> <i>sockfd</i><b>, struct mmsghdr
*</b><i>msgvec</i><b>, unsigned int</b> <i>vlen</i><b>, <br>
int</b> <i>flags</i><b>, struct timespec
*</b><i>timeout</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>recvmmsg</b>() system call is an extension of
<a href="https://man.page/2/recvmsg">recvmsg(2)</a> that allows the caller to receive multiple
messages from a socket using a single system call. (This has
performance benefits for some applications.) A further
extension over <a href="https://man.page/2/recvmsg">recvmsg(2)</a> is support for a timeout on
the receive operation.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>sockfd</i> argument is the file descriptor of the socket
to receive data from.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>msgvec</i> argument is a pointer to an array of
<i>mmsghdr</i> structures. The size of this array is
specified in <i>vlen</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>mmsghdr</i> structure is defined in
<i>&lt;sys/socket.h&gt;</i> as:</p>

<p style="margin-left:17%; margin-top: 1em">struct mmsghdr
{ <br>
struct msghdr msg_hdr; /* Message header */ <br>
unsigned int msg_len; /* Number of received bytes for header
*/ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>msg_hdr</i> field is a <i>msghdr</i> structure, as
described in <a href="https://man.page/2/recvmsg">recvmsg(2)</a>. The <i>msg_len</i> field is
the number of bytes returned for the message in the entry.
This field has the same value as the return value of a
single <a href="https://man.page/2/recvmsg">recvmsg(2)</a> on the header.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> argument contains flags ORed together. The
flags are the same as documented for <a href="https://man.page/2/recvmsg">recvmsg(2)</a>, with
the following addition: <b><br>
MSG_WAITFORONE</b> (since Linux 2.6.34)</p>

<p style="margin-left:22%;">Turns on <b>MSG_DONTWAIT</b>
after the first message has been received.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>timeout</i> argument points to a <i>struct timespec</i>
(see <a href="https://man.page/2/clock_gettime">clock_gettime(2)</a>) defining a timeout (seconds
plus nanoseconds) for the receive operation (<i>but see
BUGS!</i>). (This interval will be rounded up to the system
clock granularity, and kernel scheduling delays mean that
the blocking interval may overrun by a small amount.) If
<i>timeout</i> is NULL, then the operation blocks
indefinitely.</p>

<p style="margin-left:11%; margin-top: 1em">A blocking
<b>recvmmsg</b>() call blocks until <i>vlen</i> messages
have been received or until the timeout expires. A
nonblocking call reads as many messages as are available (up
to the limit specified by <i>vlen</i>) and returns
immediately.</p>

<p style="margin-left:11%; margin-top: 1em">On return from
<b>recvmmsg</b>(), successive elements of <i>msgvec</i> are
updated to contain information about each received message:
<i>msg_len</i> contains the size of the received message;
the subfields of <i>msg_hdr</i> are updated as described in
<a href="https://man.page/2/recvmsg">recvmsg(2)</a>. The return value of the call indicates
the number of elements of <i>msgvec</i> that have been
updated.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
<b>recvmmsg</b>() returns the number of messages received in
<i>msgvec</i>; on error, -1 is returned, and <i>errno</i> is
set to indicate the error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Errors are as
for <a href="https://man.page/2/recvmsg">recvmsg(2)</a>. In addition, the following error can
occur:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="29%">


<p><i>timeout</i> is invalid.</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">See also
BUGS.</p>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>recvmmsg</b>() system call was added in Linux 2.6.33.
Support in glibc was added in version 2.12.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>recvmmsg</b>()
is Linux-specific.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>timeout</i> argument does not work as intended. The
timeout is checked only after the receipt of each datagram,
so that if up to <i>vlen-1</i> datagrams are received before
the timeout expires, but then no further datagrams are
received, the call will block forever.</p>

<p style="margin-left:11%; margin-top: 1em">If an error
occurs after at least one message has been received, the
call succeeds, and returns the number of messages received.
The error code is expected to be returned on a subsequent
call to <b>recvmmsg</b>(). In the current implementation,
however, the error code can be overwritten in the meantime
by an unrelated network event on a socket, for example an
incoming ICMP packet.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
program uses <b>recvmmsg</b>() to receive multiple messages
on a socket and stores them in multiple buffers. The call
returns if all buffers are filled or if the timeout
specified has expired.</p>

<p style="margin-left:11%; margin-top: 1em">The following
snippet periodically generates UDP datagrams containing a
random number:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>while
true; do echo $RANDOM &gt; /dev/udp/127.0.0.1/1234; <br>
sleep 0.25; done</b></p>

<p style="margin-left:11%; margin-top: 1em">These datagrams
are read by the example application, which can give the
following output:</p>

<p style="margin-left:17%; margin-top: 1em">$
<b>./a.out</b> <br>
5 messages received <br>
1 11782 <br>
2 11345 <br>
3 304 <br>
4 13514 <br>
5 28421</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
#define _GNU_SOURCE <br>
#include &lt;netinet/ip.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;sys/socket.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(void) <br>
{ <br>
#define VLEN 10 <br>
#define BUFSIZE 200 <br>
#define TIMEOUT 1 <br>
int sockfd, retval; <br>
struct sockaddr_in addr; <br>
struct mmsghdr msgs[VLEN]; <br>
struct iovec iovecs[VLEN]; <br>
char bufs[VLEN][BUFSIZE+1]; <br>
struct timespec timeout;</p>

<p style="margin-left:11%; margin-top: 1em">sockfd =
socket(AF_INET, SOCK_DGRAM, 0); <br>
if (sockfd == -1) { <br>
perror(&quot;socket()&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">addr.sin_family
= AF_INET; <br>
addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); <br>
addr.sin_port = htons(1234); <br>
if (bind(sockfd, (struct sockaddr *) &amp;addr,
sizeof(addr)) == -1) { <br>
perror(&quot;bind()&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">memset(msgs, 0,
sizeof(msgs)); <br>
for (int i = 0; i &lt; VLEN; i++) { <br>
iovecs[i].iov_base = bufs[i]; <br>
iovecs[i].iov_len = BUFSIZE; <br>
msgs[i].msg_hdr.msg_iov = &amp;iovecs[i]; <br>
msgs[i].msg_hdr.msg_iovlen = 1; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">timeout.tv_sec
= TIMEOUT; <br>
timeout.tv_nsec = 0;</p>

<p style="margin-left:11%; margin-top: 1em">retval =
recvmmsg(sockfd, msgs, VLEN, 0, &amp;timeout); <br>
if (retval == -1) { <br>
perror(&quot;recvmmsg()&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;%d
messages received\n&quot;, retval); <br>
for (int i = 0; i &lt; retval; i++) { <br>
bufs[i][msgs[i].msg_len] = 0; <br>
printf(&quot;%d %s&quot;, i+1, bufs[i]); <br>
} <br>
exit(EXIT_SUCCESS); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/clock_gettime">clock_gettime(2)</a>,
<a href="https://man.page/2/recvmsg">recvmsg(2)</a>, <a href="https://man.page/2/sendmmsg">sendmmsg(2)</a>, <a href="https://man.page/2/sendmsg">sendmsg(2)</a>,
<a href="https://man.page/2/socket">socket(2)</a>, <a href="https://man.page/7/socket">socket(7)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
