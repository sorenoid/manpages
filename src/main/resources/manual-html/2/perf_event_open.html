<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:36:55 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERF_EVENT_OPEN</title>

</head>
<body>

<h1 align="center">PERF_EVENT_OPEN</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">perf_event_open
- set up performance monitoring</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;linux/perf_event.h&gt; <br>
#include &lt;linux/hw_breakpoint.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
perf_event_open(struct perf_event_attr *</b><i>attr</i><b>,
<br>
pid_t</b> <i>pid</i><b>, int</b> <i>cpu</i><b>, int</b>
<i>group_fd</i><b>, <br>
unsigned long</b> <i>flags</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>Note</i>:
There is no glibc wrapper for this system call; see
NOTES.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Given a list of
parameters, <b>perf_event_open</b>() returns a file
descriptor, for use in subsequent system calls
(<b>read</b>(2), <b>mmap</b>(2), <b>prctl</b>(2),
<b>fcntl</b>(2), etc.).</p>

<p style="margin-left:11%; margin-top: 1em">A call to
<b>perf_event_open</b>() creates a file descriptor that
allows measuring performance information. Each file
descriptor corresponds to one event that is measured; these
can be grouped together to measure multiple events
simultaneously.</p>

<p style="margin-left:11%; margin-top: 1em">Events can be
enabled and disabled in two ways: via <b>ioctl</b>(2) and
via <b>prctl</b>(2). When an event is disabled it does not
count or generate overflows but does continue to exist and
maintain its count value.</p>

<p style="margin-left:11%; margin-top: 1em">Events come in
two flavors: counting and sampled. A <i>counting</i> event
is one that is used for counting the aggregate number of
events that occur. In general, counting event results are
gathered with a <b>read</b>(2) call. A <i>sampling</i> event
periodically writes measurements to a buffer that can then
be accessed via <b>mmap</b>(2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Arguments</b>
<br>
The <i>pid</i> and <i>cpu</i> arguments allow specifying
which process and CPU to monitor: <b><br>
pid == 0</b> and <b>cpu == -1</b></p>

<p style="margin-left:22%;">This measures the calling
process/thread on any CPU.</p>

<p style="margin-left:11%;"><b>pid == 0</b> and <b>cpu
&gt;= 0</b></p>

<p style="margin-left:22%;">This measures the calling
process/thread only when running on the specified CPU.</p>

<p style="margin-left:11%;"><b>pid &gt; 0</b> and <b>cpu ==
-1</b></p>

<p style="margin-left:22%;">This measures the specified
process/thread on any CPU.</p>

<p style="margin-left:11%;"><b>pid &gt; 0</b> and <b>cpu
&gt;= 0</b></p>

<p style="margin-left:22%;">This measures the specified
process/thread only when running on the specified CPU.</p>

<p style="margin-left:11%;"><b>pid == -1</b> and <b>cpu
&gt;= 0</b></p>

<p style="margin-left:22%;">This measures all
processes/threads on the specified CPU. This requires
<b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b>
capability or a <i>/proc/sys/kernel/perf_event_paranoid</i>
value of less than 1.</p>

<p style="margin-left:11%;"><b>pid == -1</b> and <b>cpu ==
-1</b></p>

<p style="margin-left:22%;">This setting is invalid and
will return an error.</p>

<p style="margin-left:11%; margin-top: 1em">When <i>pid</i>
is greater than zero, permission to perform this system call
is governed by <b>CAP_PERFMON</b> (since Linux 5.9) and a
ptrace access mode <b>PTRACE_MODE_READ_REALCREDS</b> check
on older Linux versions; see <b>ptrace</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>group_fd</i> argument allows event groups to be created.
An event group has one event which is the group leader. The
leader is created first, with <i>group_fd</i> = -1. The rest
of the group members are created with subsequent
<b>perf_event_open</b>() calls with <i>group_fd</i> being
set to the file descriptor of the group leader. (A single
event on its own is created with <i>group_fd</i> = -1 and is
considered to be a group with only 1 member.) An event group
is scheduled onto the CPU as a unit: it will be put onto the
CPU only if all of the events in the group can be put onto
the CPU. This means that the values of the member events can
be meaningfully compared&mdash;added, divided (to get
ratios), and so on&mdash;with each other, since they have
counted events for the same set of executed
instructions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> argument is formed by ORing together zero or
more of the following values: <b><br>
PERF_FLAG_FD_CLOEXEC</b> (since Linux 3.14)</p>

<p style="margin-left:22%;">This flag enables the
close-on-exec flag for the created event file descriptor, so
that the file descriptor is automatically closed on
<b>execve</b>(2). Setting the close-on-exec flags at
creation time, rather than later with <b>fcntl</b>(2),
avoids potential race conditions where the calling thread
invokes <b>perf_event_open</b>() and <b>fcntl</b>(2) at the
same time as another thread calls <b>fork</b>(2) then
<b>execve</b>(2).</p>


<p style="margin-left:11%;"><b>PERF_FLAG_FD_NO_GROUP</b></p>

<p style="margin-left:22%;">This flag tells the event to
ignore the <i>group_fd</i> parameter except for the purpose
of setting up output redirection using the
<b>PERF_FLAG_FD_OUTPUT</b> flag.</p>

<p style="margin-left:11%;"><b>PERF_FLAG_FD_OUTPUT</b>
(broken since Linux 2.6.35)</p>

<p style="margin-left:22%;">This flag re-routes the
event&rsquo;s sampled output to instead be included in the
mmap buffer of the event specified by <i>group_fd</i>.</p>

<p style="margin-left:11%;"><b>PERF_FLAG_PID_CGROUP</b>
(since Linux 2.6.39)</p>

<p style="margin-left:22%;">This flag activates
per-container system-wide monitoring. A container is an
abstraction that isolates a set of resources for
finer-grained control (CPUs, memory, etc.). In this mode,
the event is measured only if the thread running on the
monitored CPU belongs to the designated container (cgroup).
The cgroup is identified by passing a file descriptor opened
on its directory in the cgroupfs filesystem. For instance,
if the cgroup to monitor is called <i>test</i>, then a file
descriptor opened on <i>/dev/cgroup/test</i> (assuming
cgroupfs is mounted on <i>/dev/cgroup</i>) must be passed as
the <i>pid</i> parameter. cgroup monitoring is available
only for system-wide events and may therefore require extra
permissions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>perf_event_attr</i> structure provides detailed
configuration information for the event being created.</p>

<p style="margin-left:17%; margin-top: 1em">struct
perf_event_attr { <br>
__u32 type; /* Type of event */ <br>
__u32 size; /* Size of attribute structure */ <br>
__u64 config; /* Type-specific configuration */</p>

<p style="margin-left:17%; margin-top: 1em">union { <br>
__u64 sample_period; /* Period of sampling */ <br>
__u64 sample_freq; /* Frequency of sampling */ <br>
};</p>

<p style="margin-left:17%; margin-top: 1em">__u64
sample_type; /* Specifies values included in sample */ <br>
__u64 read_format; /* Specifies values returned in read
*/</p>

<p style="margin-left:17%; margin-top: 1em">__u64 disabled
: 1, /* off by default */ <br>
inherit : 1, /* children inherit it */ <br>
pinned : 1, /* must always be on PMU */ <br>
exclusive : 1, /* only group on PMU */ <br>
exclude_user : 1, /* don't count user */ <br>
exclude_kernel : 1, /* don't count kernel */ <br>
exclude_hv : 1, /* don't count hypervisor */ <br>
exclude_idle : 1, /* don't count when idle */ <br>
mmap : 1, /* include mmap data */ <br>
comm : 1, /* include comm data */ <br>
freq : 1, /* use freq, not period */ <br>
inherit_stat : 1, /* per task counts */ <br>
enable_on_exec : 1, /* next exec enables */ <br>
task : 1, /* trace fork/exit */ <br>
watermark : 1, /* wakeup_watermark */ <br>
precise_ip : 2, /* skid constraint */ <br>
mmap_data : 1, /* non-exec mmap data */ <br>
sample_id_all : 1, /* sample_type all events */ <br>
exclude_host : 1, /* don't count in host */ <br>
exclude_guest : 1, /* don't count in guest */ <br>
exclude_callchain_kernel : 1, <br>
/* exclude kernel callchains */ <br>
exclude_callchain_user : 1, <br>
/* exclude user callchains */ <br>
mmap2 : 1, /* include mmap with inode data */ <br>
comm_exec : 1, /* flag comm events that are <br>
due to exec */ <br>
use_clockid : 1, /* use clockid for time fields */ <br>
context_switch : 1, /* context switch data */ <br>
write_backward : 1, /* Write ring buffer from end <br>
to beginning */ <br>
namespaces : 1, /* include namespaces data */ <br>
ksymbol : 1, /* include ksymbol events */ <br>
bpf_event : 1, /* include bpf events */ <br>
aux_output : 1, /* generate AUX records <br>
instead of events */ <br>
cgroup : 1, /* include cgroup events */ <br>
text_poke : 1, /* include text poke events */</p>

<p style="margin-left:17%; margin-top: 1em">__reserved_1 :
30;</p>

<p style="margin-left:17%; margin-top: 1em">union { <br>
__u32 wakeup_events; /* wakeup every n events */ <br>
__u32 wakeup_watermark; /* bytes before wakeup */ <br>
};</p>

<p style="margin-left:17%; margin-top: 1em">__u32 bp_type;
/* breakpoint type */</p>

<p style="margin-left:17%; margin-top: 1em">union { <br>
__u64 bp_addr; /* breakpoint address */ <br>
__u64 kprobe_func; /* for perf_kprobe */ <br>
__u64 uprobe_path; /* for perf_uprobe */ <br>
__u64 config1; /* extension of config */ <br>
};</p>

<p style="margin-left:17%; margin-top: 1em">union { <br>
__u64 bp_len; /* breakpoint length */ <br>
__u64 kprobe_addr; /* with kprobe_func == NULL */ <br>
__u64 probe_offset; /* for perf_[k,u]probe */ <br>
__u64 config2; /* extension of config1 */ <br>
}; <br>
__u64 branch_sample_type; /* enum perf_branch_sample_type */
<br>
__u64 sample_regs_user; /* user regs to dump on samples */
<br>
__u32 sample_stack_user; /* size of stack to dump on <br>
samples */ <br>
__s32 clockid; /* clock to use for time fields */ <br>
__u64 sample_regs_intr; /* regs to dump on samples */ <br>
__u32 aux_watermark; /* aux bytes before wakeup */ <br>
__u16 sample_max_stack; /* max frames in callchain */ <br>
__u16 __reserved_2; /* align to u64 */</p>

<p style="margin-left:17%; margin-top: 1em">};</p>

<p style="margin-left:11%; margin-top: 1em">The fields of
the <i>perf_event_attr</i> structure are described in more
detail below:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>type</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This field specifies the overall event type. It has one
of the following values:</p></td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_TYPE_HARDWARE</b></p>

<p style="margin-left:32%;">This indicates one of the
&quot;generalized&quot; hardware events provided by the
kernel. See the <i>config</i> field definition for more
details.</p>

<p style="margin-left:22%;"><b>PERF_TYPE_SOFTWARE</b></p>

<p style="margin-left:32%;">This indicates one of the
software-defined events provided by the kernel (even if no
hardware support is available).</p>


<p style="margin-left:22%;"><b>PERF_TYPE_TRACEPOINT</b></p>

<p style="margin-left:32%;">This indicates a tracepoint
provided by the kernel tracepoint infrastructure.</p>

<p style="margin-left:22%;"><b>PERF_TYPE_HW_CACHE</b></p>

<p style="margin-left:32%;">This indicates a hardware cache
event. This has a special encoding, described in the
<i>config</i> field definition.</p>

<p style="margin-left:22%;"><b>PERF_TYPE_RAW</b></p>

<p style="margin-left:32%;">This indicates a
&quot;raw&quot; implementation-specific event in the
<i>config</i> field.</p>

<p style="margin-left:22%;"><b>PERF_TYPE_BREAKPOINT</b>
(since Linux 2.6.33)</p>

<p style="margin-left:32%;">This indicates a hardware
breakpoint as provided by the CPU. Breakpoints can be
read/write accesses to an address as well as execution of an
instruction address.</p>

<p style="margin-left:22%;">dynamic PMU</p>

<p style="margin-left:32%;">Since Linux 2.6.38,
<b>perf_event_open</b>() can support multiple PMUs. To
enable this, a value exported by the kernel can be used in
the <i>type</i> field to indicate which PMU to use. The
value to use can be found in the sysfs filesystem: there is
a subdirectory per PMU instance under
<i>/sys/bus/event_source/devices</i>. In each subdirectory
there is a <i>type</i> file whose content is an integer that
can be used in the <i>type</i> field. For instance,
<i>/sys/bus/event_source/devices/cpu/type</i> contains the
value for the core CPU PMU, which is usually 4.</p>

<p style="margin-left:22%;"><b>kprobe</b> and <b>uprobe</b>
(since Linux 4.17)</p>

<p style="margin-left:32%;">These two dynamic PMUs create a
kprobe/uprobe and attach it to the file descriptor generated
by perf_event_open. The kprobe/uprobe will be destroyed on
the destruction of the file descriptor. See fields
<i>kprobe_func</i>, <i>uprobe_path</i>, <i>kprobe_addr</i>,
and <i>probe_offset</i> for more details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>size</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The size of the <i>perf_event_attr</i> structure for
forward/backward compatibility. Set this using
<i>sizeof(struct perf_event_attr)</i> to allow the kernel to
see the struct size at the time of compilation.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The related
define <b>PERF_ATTR_SIZE_VER0</b> is set to 64; this was the
size of the first published struct.
<b>PERF_ATTR_SIZE_VER1</b> is 72, corresponding to the
addition of breakpoints in Linux 2.6.33.
<b>PERF_ATTR_SIZE_VER2</b> is 80 corresponding to the
addition of branch sampling in Linux 3.4.
<b>PERF_ATTR_SIZE_VER3</b> is 96 corresponding to the
addition of <i>sample_regs_user</i> and
<i>sample_stack_user</i> in Linux 3.7.
<b>PERF_ATTR_SIZE_VER4</b> is 104 corresponding to the
addition of <i>sample_regs_intr</i> in Linux 3.19.
<b>PERF_ATTR_SIZE_VER5</b> is 112 corresponding to the
addition of <i>aux_watermark</i> in Linux 4.1.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><i>config</i></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">This specifies which event you
want, in conjunction with the <i>type</i> field. The
<i>config1</i> and <i>config2</i> fields are also taken into
account in cases where 64 bits is not enough to fully
specify the event. The encoding of these fields are event
dependent.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">There are
various ways to set the <i>config</i> field that are
dependent on the value of the previously described
<i>type</i> field. What follows are various possible
settings for <i>config</i> separated out by <i>type</i>.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>PERF_TYPE_HARDWARE</b>, we are measuring one of the
generalized hardware CPU events. Not all of these are
available on all platforms. Set <i>config</i> to one of the
following:</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_CPU_CYCLES</b></p>

<p style="margin-left:40%;">Total cycles. Be wary of what
happens during CPU frequency scaling.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_INSTRUCTIONS</b></p>

<p style="margin-left:40%;">Retired instructions. Be
careful, these can be affected by various issues, most
notably hardware interrupt counts.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_CACHE_REFERENCES</b></p>

<p style="margin-left:40%;">Cache accesses. Usually this
indicates Last Level Cache accesses but this may vary
depending on your CPU. This may include prefetches and
coherency messages; again this depends on the design of your
CPU.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_CACHE_MISSES</b></p>

<p style="margin-left:40%;">Cache misses. Usually this
indicates Last Level Cache misses; this is intended to be
used in conjunction with the
<b>PERF_COUNT_HW_CACHE_REFERENCES</b> event to calculate
cache miss rates.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_BRANCH_INSTRUCTIONS</b></p>

<p style="margin-left:40%;">Retired branch instructions.
Prior to Linux 2.6.35, this used the wrong event on AMD
processors.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_BRANCH_MISSES</b></p>

<p style="margin-left:40%;">Mispredicted branch
instructions.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_BUS_CYCLES</b></p>

<p style="margin-left:40%;">Bus cycles, which can be
different from total cycles.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_STALLED_CYCLES_FRONTEND</b>
(since Linux 3.0)</p>

<p style="margin-left:40%;">Stalled cycles during
issue.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_STALLED_CYCLES_BACKEND</b>
(since Linux 3.0)</p>

<p style="margin-left:40%;">Stalled cycles during
retirement.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_HW_REF_CPU_CYCLES</b>
(since Linux 3.3)</p>

<p style="margin-left:40%;">Total cycles; not affected by
CPU frequency scaling.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>PERF_TYPE_SOFTWARE</b>, we are measuring software
events provided by the kernel. Set <i>config</i> to one of
the following:</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_CPU_CLOCK</b></p>

<p style="margin-left:40%;">This reports the CPU clock, a
high-resolution per-CPU timer.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_TASK_CLOCK</b></p>

<p style="margin-left:40%;">This reports a clock count
specific to the task that is running.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_PAGE_FAULTS</b></p>

<p style="margin-left:40%;">This reports the number of page
faults.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_CONTEXT_SWITCHES</b></p>

<p style="margin-left:40%;">This counts context switches.
Until Linux 2.6.34, these were all reported as user-space
events, after that they are reported as happening in the
kernel.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_CPU_MIGRATIONS</b></p>

<p style="margin-left:40%;">This reports the number of
times the process has migrated to a new CPU.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_PAGE_FAULTS_MIN</b></p>

<p style="margin-left:40%;">This counts the number of minor
page faults. These did not require disk I/O to handle.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_PAGE_FAULTS_MAJ</b></p>

<p style="margin-left:40%;">This counts the number of major
page faults. These required disk I/O to handle.</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_ALIGNMENT_FAULTS</b>
(since Linux 2.6.33)</p>

<p style="margin-left:40%;">This counts the number of
alignment faults. These happen when unaligned memory
accesses happen; the kernel can handle these but it reduces
performance. This happens only on some architectures (never
on x86).</p>


<p style="margin-left:29%;"><b>PERF_COUNT_SW_EMULATION_FAULTS</b>
(since Linux 2.6.33)</p>

<p style="margin-left:40%;">This counts the number of
emulation faults. The kernel sometimes traps on
unimplemented instructions and emulates them for user space.
This can negatively impact performance.</p>

<p style="margin-left:29%;"><b>PERF_COUNT_SW_DUMMY</b>
(since Linux 3.12)</p>

<p style="margin-left:40%;">This is a placeholder event
that counts nothing. Informational sample record types such
as mmap or comm must be associated with an active event.
This dummy event allows gathering such records without
requiring a counting event.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>PERF_TYPE_TRACEPOINT</b>, then we are measuring kernel
tracepoints. The value to use in <i>config</i> can be
obtained from under debugfs <i>tracing/events/*/*/id</i> if
ftrace is enabled in the kernel.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>PERF_TYPE_HW_CACHE</b>, then we are measuring a
hardware CPU cache event. To calculate the appropriate
<i>config</i> value, use the following equation:</p>

<p style="margin-left:34%; margin-top: 1em">config =
(perf_hw_cache_id) | <br>
(perf_hw_cache_op_id &lt;&lt; 8) | <br>
(perf_hw_cache_op_result_id &lt;&lt; 16);</p>

<p style="margin-left:28%; margin-top: 1em">where
<i>perf_hw_cache_id</i> is one of:</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_L1D</b></p>

<p style="margin-left:45%;">for measuring Level 1 Data
Cache</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_L1I</b></p>

<p style="margin-left:45%;">for measuring Level 1
Instruction Cache</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_LL</b></p>

<p style="margin-left:45%;">for measuring Last-Level
Cache</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_DTLB</b></p>

<p style="margin-left:45%;">for measuring the Data TLB</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_ITLB</b></p>

<p style="margin-left:45%;">for measuring the Instruction
TLB</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_BPU</b></p>

<p style="margin-left:45%;">for measuring the branch
prediction unit</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_NODE</b>
(since Linux 3.1)</p>

<p style="margin-left:45%;">for measuring local memory
accesses</p>

<p style="margin-left:28%; margin-top: 1em">and
<i>perf_hw_cache_op_id</i> is one of:</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_OP_READ</b></p>

<p style="margin-left:45%;">for read accesses</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_OP_WRITE</b></p>

<p style="margin-left:45%;">for write accesses</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_OP_PREFETCH</b></p>

<p style="margin-left:45%;">for prefetch accesses</p>

<p style="margin-left:28%; margin-top: 1em">and
<i>perf_hw_cache_op_result_id</i> is one of:</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_RESULT_ACCESS</b></p>

<p style="margin-left:45%;">to measure accesses</p>


<p style="margin-left:34%;"><b>PERF_COUNT_HW_CACHE_RESULT_MISS</b></p>

<p style="margin-left:45%;">to measure misses</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>PERF_TYPE_RAW</b>, then a custom &quot;raw&quot;
<i>config</i> value is needed. Most CPUs support events that
are not covered by the &quot;generalized&quot; events. These
are implementation defined; see your CPU manual (for example
the Intel Volume 3B documentation or the AMD BIOS and Kernel
Developer Guide). The libpfm4 library can be used to
translate from the name in the architectural manuals to the
raw hex value <b>perf_event_open</b>() expects in this
field.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>PERF_TYPE_BREAKPOINT</b>, then leave <i>config</i> set
to zero. Its parameters are set in other places.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>kprobe</b> or <b>uprobe</b>, set <i>retprobe</i> (bit
0 of <i>config</i>, see
<i>/sys/bus/event_source/devices/[k,u]probe/format/retprobe</i>)
for kretprobe/uretprobe. See fields <i>kprobe_func</i>,
<i>uprobe_path</i>, <i>kprobe_addr</i>, and
<i>probe_offset</i> for more details.</p>

<p style="margin-left:11%;"><i>kprobe_func</i>,
<i>uprobe_path</i>, <i>kprobe_addr</i>, and
<i>probe_offset</i></p>

<p style="margin-left:22%;">These fields describe the
kprobe/uprobe for dynamic PMUs <b>kprobe</b> and
<b>uprobe</b>. For <b>kprobe</b>: use <i>kprobe_func</i> and
<i>probe_offset</i>, or use <i>kprobe_addr</i> and leave
<i>kprobe_func</i> as NULL. For <b>uprobe</b>: use
<i>uprobe_path</i> and <i>probe_offset</i>.</p>

<p style="margin-left:11%;"><i>sample_period</i>,
<i>sample_freq</i></p>

<p style="margin-left:22%;">A &quot;sampling&quot; event is
one that generates an overflow notification every N events,
where N is given by <i>sample_period</i>. A sampling event
has <i>sample_period</i> &gt; 0. When an overflow occurs,
requested data is recorded in the mmap buffer. The
<i>sample_type</i> field controls what data is recorded on
each overflow.</p>


<p style="margin-left:22%; margin-top: 1em"><i>sample_freq</i>
can be used if you wish to use frequency rather than period.
In this case, you set the <i>freq</i> flag. The kernel will
adjust the sampling period to try and achieve the desired
rate. The rate of adjustment is a timer tick.</p>

<p style="margin-left:11%;"><i>sample_type</i></p>

<p style="margin-left:22%;">The various bits in this field
specify which values to include in the sample. They will be
recorded in a ring-buffer, which is available to user space
using <b>mmap</b>(2). The order in which the values are
saved in the sample are documented in the MMAP Layout
subsection below; it is not the <i>enum
perf_event_sample_format</i> order. <b><br>
PERF_SAMPLE_IP</b></p>

<p style="margin-left:32%;">Records instruction
pointer.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_TID</b></p>

<p style="margin-left:32%;">Records the process and thread
IDs.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_TIME</b></p>

<p style="margin-left:32%;">Records a timestamp.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_ADDR</b></p>

<p style="margin-left:32%;">Records an address, if
applicable.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_READ</b></p>

<p style="margin-left:32%;">Record counter values for all
events in a group, not just the group leader.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_CALLCHAIN</b></p>

<p style="margin-left:32%;">Records the callchain (stack
backtrace).</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_ID</b></p>

<p style="margin-left:32%;">Records a unique ID for the
opened event&rsquo;s group leader.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_CPU</b></p>

<p style="margin-left:32%;">Records CPU number.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_PERIOD</b></p>

<p style="margin-left:32%;">Records the current sampling
period.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_STREAM_ID</b></p>

<p style="margin-left:32%;">Records a unique ID for the
opened event. Unlike <b>PERF_SAMPLE_ID</b> the actual ID is
returned, not the group leader. This ID is the same as the
one returned by <b>PERF_FORMAT_ID</b>.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_RAW</b></p>

<p style="margin-left:32%;">Records additional data, if
applicable. Usually returned by tracepoint events.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_STACK</b>
(since Linux 3.4)</p>

<p style="margin-left:32%;">This provides a record of
recent branches, as provided by CPU branch sampling hardware
(such as Intel Last Branch Record). Not all hardware
supports this feature.</p>

<p style="margin-left:32%; margin-top: 1em">See the
<i>branch_sample_type</i> field for how to filter which
branches are reported.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_REGS_USER</b>
(since Linux 3.7)</p>

<p style="margin-left:32%;">Records the current user-level
CPU register state (the values in the process before the
kernel was called).</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_STACK_USER</b>
(since Linux 3.7)</p>

<p style="margin-left:32%;">Records the user level stack,
allowing stack unwinding.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_WEIGHT</b>
(since Linux 3.10)</p>

<p style="margin-left:32%;">Records a hardware provided
weight value that expresses how costly the sampled event
was. This allows the hardware to highlight expensive events
in a profile.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_DATA_SRC</b>
(since Linux 3.10)</p>

<p style="margin-left:32%;">Records the data source: where
in the memory hierarchy the data associated with the sampled
instruction came from. This is available only if the
underlying hardware supports this feature.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_IDENTIFIER</b>
(since Linux 3.12)</p>

<p style="margin-left:32%;">Places the <b>SAMPLE_ID</b>
value in a fixed position in the record, either at the
beginning (for sample events) or at the end (if a non-sample
event).</p>

<p style="margin-left:32%; margin-top: 1em">This was
necessary because a sample stream may have records from
various different event sources with different
<i>sample_type</i> settings. Parsing the event stream
properly was not possible because the format of the record
was needed to find <b>SAMPLE_ID</b>, but the format could
not be found without knowing what event the sample belonged
to (causing a circular dependency).</p>

<p style="margin-left:32%; margin-top: 1em">The
<b>PERF_SAMPLE_IDENTIFIER</b> setting makes the event stream
always parsable by putting <b>SAMPLE_ID</b> in a fixed
location, even though it means having duplicate
<b>SAMPLE_ID</b> values in records.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_TRANSACTION</b>
(since Linux 3.13)</p>

<p style="margin-left:32%;">Records reasons for
transactional memory abort events (for example, from Intel
TSX transactional memory support).</p>

<p style="margin-left:32%; margin-top: 1em">The
<i>precise_ip</i> setting must be greater than 0 and a
transactional memory abort event must be measured or no
values will be recorded. Also note that some perf_event
measurements, such as sampled cycle counting, may cause
extraneous aborts (by causing an interrupt during a
transaction).</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_REGS_INTR</b>
(since Linux 3.19)</p>

<p style="margin-left:32%;">Records a subset of the current
CPU register state as specified by <i>sample_regs_intr</i>.
Unlike <b>PERF_SAMPLE_REGS_USER</b> the register values will
return kernel register state if the overflow happened while
kernel code is running. If the CPU supports hardware
sampling of register state (i.e., PEBS on Intel x86) and
<i>precise_ip</i> is set higher than zero then the register
values returned are those captured by hardware at the time
of the sampled instruction&rsquo;s retirement.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_PHYS_ADDR</b>
(since Linux 4.13)</p>

<p style="margin-left:32%;">Records physical address of
data like in <b>PERF_SAMPLE_ADDR</b>.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_CGROUP</b>
(since Linux 5.7)</p>

<p style="margin-left:32%;">Records (perf_event) cgroup ID
of the process. This corresponds to the <i>id</i> field in
the <b>PERF_RECORD_CGROUP</b> event.</p>

<p style="margin-left:11%;"><i>read_format</i></p>

<p style="margin-left:22%;">This field specifies the format
of the data returned by <b>read</b>(2) on a
<b>perf_event_open</b>() file descriptor. <b><br>
PERF_FORMAT_TOTAL_TIME_ENABLED</b></p>

<p style="margin-left:32%;">Adds the 64-bit
<i>time_enabled</i> field. This can be used to calculate
estimated totals if the PMU is overcommitted and
multiplexing is happening.</p>


<p style="margin-left:22%;"><b>PERF_FORMAT_TOTAL_TIME_RUNNING</b></p>

<p style="margin-left:32%;">Adds the 64-bit
<i>time_running</i> field. This can be used to calculate
estimated totals if the PMU is overcommitted and
multiplexing is happening.</p>

<p style="margin-left:22%;"><b>PERF_FORMAT_ID</b></p>

<p style="margin-left:32%;">Adds a 64-bit unique value that
corresponds to the event group.</p>

<p style="margin-left:22%;"><b>PERF_FORMAT_GROUP</b></p>

<p style="margin-left:32%;">Allows all counter values in an
event group to be read with one read.</p>

<p style="margin-left:11%;"><i>disabled</i></p>

<p style="margin-left:22%;">The <i>disabled</i> bit
specifies whether the counter starts out disabled or
enabled. If disabled, the event can later be enabled by
<b>ioctl</b>(2), <b>prctl</b>(2), or
<i>enable_on_exec</i>.</p>

<p style="margin-left:22%; margin-top: 1em">When creating
an event group, typically the group leader is initialized
with <i>disabled</i> set to 1 and any child events are
initialized with <i>disabled</i> set to 0. Despite
<i>disabled</i> being 0, the child events will not start
until the group leader is enabled.</p>

<p style="margin-left:11%;"><i>inherit</i></p>

<p style="margin-left:22%;">The <i>inherit</i> bit
specifies that this counter should count events of child
tasks as well as the task specified. This applies only to
new children, not to any existing children at the time the
counter is created (nor to any new children of existing
children).</p>

<p style="margin-left:22%; margin-top: 1em">Inherit does
not work for some combinations of <i>read_format</i> values,
such as <b>PERF_FORMAT_GROUP</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>pinned</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>pinned</i> bit specifies that the counter should
always be on the CPU if at all possible. It applies only to
hardware counters and only to group leaders. If a pinned
counter cannot be put onto the CPU (e.g., because there are
not enough hardware counters or because of a conflict with
some other event), then the counter goes into an
&rsquo;error&rsquo; state, where reads return end-of-file
(i.e., <b>read</b>(2) returns 0) until the counter is
subsequently enabled or disabled.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>exclusive</i></p>

<p style="margin-left:22%;">The <i>exclusive</i> bit
specifies that when this counter&rsquo;s group is on the
CPU, it should be the only group using the CPU&rsquo;s
counters. In the future this may allow monitoring programs
to support PMU features that need to run alone so that they
do not disrupt other hardware counters.</p>

<p style="margin-left:22%; margin-top: 1em">Note that many
unexpected situations may prevent events with the
<i>exclusive</i> bit set from ever running. This includes
any users running a system-wide measurement as well as any
kernel use of the performance counters (including the
commonly enabled NMI Watchdog Timer interface).</p>

<p style="margin-left:11%;"><i>exclude_user</i></p>

<p style="margin-left:22%;">If this bit is set, the count
excludes events that happen in user space.</p>

<p style="margin-left:11%;"><i>exclude_kernel</i></p>

<p style="margin-left:22%;">If this bit is set, the count
excludes events that happen in kernel space.</p>

<p style="margin-left:11%;"><i>exclude_hv</i></p>

<p style="margin-left:22%;">If this bit is set, the count
excludes events that happen in the hypervisor. This is
mainly for PMUs that have built-in support for handling this
(such as POWER). Extra support is needed for handling
hypervisor measurements on most machines.</p>

<p style="margin-left:11%;"><i>exclude_idle</i></p>

<p style="margin-left:22%;">If set, don&rsquo;t count when
the CPU is running the idle task. While you can currently
enable this for any event type, it is ignored for all but
software events.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>mmap</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>mmap</i> bit enables generation of
<b>PERF_RECORD_MMAP</b> samples for every <b>mmap</b>(2)
call that has <b>PROT_EXEC</b> set. This allows tools to
notice new executable code being mapped into a program
(dynamic shared libraries for example) so that addresses can
be mapped back to the original code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>comm</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>comm</i> bit enables tracking of process command
name as modified by the <b>exec</b>(2) and
<b>prctl</b>(PR_SET_NAME) system calls as well as writing to
<i>/proc/self/comm</i>. If the <i>comm_exec</i> flag is also
successfully set (possible since Linux 3.16), then the misc
flag <b>PERF_RECORD_MISC_COMM_EXEC</b> can be used to
differentiate the <b>exec</b>(2) case from the others.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>freq</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>If this bit is set, then <i>sample_frequency</i> not
<i>sample_period</i> is used when setting up the sampling
interval.</p> </td></tr>
</table>

<p style="margin-left:11%;"><i>inherit_stat</i></p>

<p style="margin-left:22%;">This bit enables saving of
event counts on context switch for inherited tasks. This is
meaningful only if the <i>inherit</i> field is set.</p>

<p style="margin-left:11%;"><i>enable_on_exec</i></p>

<p style="margin-left:22%;">If this bit is set, a counter
is automatically enabled after a call to <b>exec</b>(2).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>task</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>If this bit is set, then fork/exit notifications are
included in the ring buffer.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>watermark</i></p>

<p style="margin-left:22%;">If set, have an overflow
notification happen when we cross the
<i>wakeup_watermark</i> boundary. Otherwise, overflow
notifications happen after <i>wakeup_events</i> samples.</p>

<p style="margin-left:11%;"><i>precise_ip</i> (since Linux
2.6.35)</p>

<p style="margin-left:22%;">This controls the amount of
skid. Skid is how many instructions execute between an event
of interest happening and the kernel being able to stop and
record the event. Smaller skid is better and allows more
accurate reporting of which events correspond to which
instructions, but hardware is often limited with how small
this can be.</p>

<p style="margin-left:22%; margin-top: 1em">The possible
values of this field are the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>0</p></td>
<td width="3%"></td>
<td width="74%">


<p><b>SAMPLE_IP</b> can have arbitrary skid.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>1</p></td>
<td width="3%"></td>
<td width="74%">


<p><b>SAMPLE_IP</b> must have constant skid.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>2</p></td>
<td width="3%"></td>
<td width="74%">


<p><b>SAMPLE_IP</b> requested to have 0 skid.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>3</p></td>
<td width="3%"></td>
<td width="74%">


<p><b>SAMPLE_IP</b> must have 0 skid. See also the
description of <b>PERF_RECORD_MISC_EXACT_IP</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>mmap_data</i> (since Linux
2.6.36)</p>

<p style="margin-left:22%;">This is the counterpart of the
<i>mmap</i> field. This enables generation of
<b>PERF_RECORD_MMAP</b> samples for <b>mmap</b>(2) calls
that do not have <b>PROT_EXEC</b> set (for example data and
SysV shared memory).</p>

<p style="margin-left:11%;"><i>sample_id_all</i> (since
Linux 2.6.38)</p>

<p style="margin-left:22%;">If set, then TID, TIME, ID,
STREAM_ID, and CPU can additionally be included in
non-<b>PERF_RECORD_SAMPLE</b>s if the corresponding
<i>sample_type</i> is selected.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>PERF_SAMPLE_IDENTIFIER</b> is specified, then an
additional ID value is included as the last value to ease
parsing the record stream. This may lead to the <i>id</i>
value appearing twice.</p>

<p style="margin-left:22%; margin-top: 1em">The layout is
described by this pseudo-structure:</p>

<p style="margin-left:28%; margin-top: 1em">struct
sample_id { <br>
{ u32 pid, tid; } /* if PERF_SAMPLE_TID set */ <br>
{ u64 time; } /* if PERF_SAMPLE_TIME set */ <br>
{ u64 id; } /* if PERF_SAMPLE_ID set */ <br>
{ u64 stream_id;} /* if PERF_SAMPLE_STREAM_ID set */ <br>
{ u32 cpu, res; } /* if PERF_SAMPLE_CPU set */ <br>
{ u64 id; } /* if PERF_SAMPLE_IDENTIFIER set */ <br>
};</p>

<p style="margin-left:11%;"><i>exclude_host</i> (since
Linux 3.2)</p>

<p style="margin-left:22%;">When conducting measurements
that include processes running VM instances (i.e., have
executed a <b>KVM_RUN ioctl</b>(2)), only measure events
happening inside a guest instance. This is only meaningful
outside the guests; this setting does not change counts
gathered inside of a guest. Currently, this functionality is
x86 only.</p>

<p style="margin-left:11%;"><i>exclude_guest</i> (since
Linux 3.2)</p>

<p style="margin-left:22%;">When conducting measurements
that include processes running VM instances (i.e., have
executed a <b>KVM_RUN ioctl</b>(2)), do not measure events
happening inside guest instances. This is only meaningful
outside the guests; this setting does not change counts
gathered inside of a guest. Currently, this functionality is
x86 only.</p>


<p style="margin-left:11%;"><i>exclude_callchain_kernel</i>
(since Linux 3.7)</p>

<p style="margin-left:22%;">Do not include kernel
callchains.</p>

<p style="margin-left:11%;"><i>exclude_callchain_user</i>
(since Linux 3.7)</p>

<p style="margin-left:22%;">Do not include user
callchains.</p>

<p style="margin-left:11%;"><i>mmap2</i> (since Linux
3.16)</p>

<p style="margin-left:22%;">Generate an extended executable
mmap record that contains enough additional information to
uniquely identify shared mappings. The <i>mmap</i> flag must
also be set for this to work.</p>

<p style="margin-left:11%;"><i>comm_exec</i> (since Linux
3.16)</p>

<p style="margin-left:22%;">This is purely a
feature-detection flag, it does not change kernel behavior.
If this flag can successfully be set, then, when <i>comm</i>
is enabled, the <b>PERF_RECORD_MISC_COMM_EXEC</b> flag will
be set in the <i>misc</i> field of a comm record header if
the rename event being reported was caused by a call to
<b>exec</b>(2). This allows tools to distinguish between the
various types of process renaming.</p>

<p style="margin-left:11%;"><i>use_clockid</i> (since Linux
4.1)</p>

<p style="margin-left:22%;">This allows selecting which
internal Linux clock to use when generating timestamps via
the <i>clockid</i> field. This can make it easier to
correlate perf sample times with timestamps generated by
other tools.</p>

<p style="margin-left:11%;"><i>context_switch</i> (since
Linux 4.3)</p>

<p style="margin-left:22%;">This enables the generation of
<b>PERF_RECORD_SWITCH</b> records when a context switch
occurs. It also enables the generation of
<b>PERF_RECORD_SWITCH_CPU_WIDE</b> records when sampling in
CPU-wide mode. This functionality is in addition to existing
tracepoint and software events for measuring context
switches. The advantage of this method is that it will give
full information even with strict <i>perf_event_paranoid</i>
settings.</p>

<p style="margin-left:11%;"><i>write_backward</i> (since
Linux 4.6)</p>

<p style="margin-left:22%;">This causes the ring buffer to
be written from the end to the beginning. This is to support
reading from overwritable ring buffer.</p>

<p style="margin-left:11%;"><i>namespaces</i> (since Linux
4.11)</p>

<p style="margin-left:22%;">This enables the generation of
<b>PERF_RECORD_NAMESPACES</b> records when a task enters a
new namespace. Each namespace has a combination of device
and inode numbers.</p>

<p style="margin-left:11%;"><i>ksymbol</i> (since Linux
5.0)</p>

<p style="margin-left:22%;">This enables the generation of
<b>PERF_RECORD_KSYMBOL</b> records when new kernel symbols
are registered or unregistered. This is analyzing dynamic
kernel functions like eBPF.</p>

<p style="margin-left:11%;"><i>bpf_event</i> (since Linux
5.0)</p>

<p style="margin-left:22%;">This enables the generation of
<b>PERF_RECORD_BPF_EVENT</b> records when an eBPF program is
loaded or unloaded.</p>

<p style="margin-left:11%;"><i>auxevent</i> (since Linux
5.4)</p>

<p style="margin-left:22%;">This allows normal (non-AUX)
events to generate data for AUX events if the hardware
supports it.</p>

<p style="margin-left:11%;"><i>cgroup</i> (since Linux
5.7)</p>

<p style="margin-left:22%;">This enables the generation of
<b>PERF_RECORD_CGROUP</b> records when a new cgroup is
created (and activated).</p>

<p style="margin-left:11%;"><i>text_poke</i> (since Linux
5.8)</p>

<p style="margin-left:22%;">This enables the generation of
<b>PERF_RECORD_TEXT_POKE</b> records when there&rsquo;s a
changes to the kernel text (i.e., self-modifying code).</p>

<p style="margin-left:11%;"><i>wakeup_events</i>,
<i>wakeup_watermark</i></p>

<p style="margin-left:22%;">This union sets how many
samples (<i>wakeup_events</i>) or bytes
(<i>wakeup_watermark</i>) happen before an overflow
notification happens. Which one is used is selected by the
<i>watermark</i> bit flag.</p>


<p style="margin-left:22%; margin-top: 1em"><i>wakeup_events</i>
counts only <b>PERF_RECORD_SAMPLE</b> record types. To
receive overflow notification for all <b>PERF_RECORD</b>
types choose watermark and set <i>wakeup_watermark</i> to
1.</p>

<p style="margin-left:22%; margin-top: 1em">Prior to Linux
3.0, setting <i>wakeup_events</i> to 0 resulted in no
overflow notifications; more recent kernels treat 0 the same
as 1.</p>

<p style="margin-left:11%;"><i>bp_type</i> (since Linux
2.6.33)</p>

<p style="margin-left:22%;">This chooses the breakpoint
type. It is one of: <b><br>
HW_BREAKPOINT_EMPTY</b></p>

<p style="margin-left:32%;">No breakpoint.</p>

<p style="margin-left:22%;"><b>HW_BREAKPOINT_R</b></p>

<p style="margin-left:32%;">Count when we read the memory
location.</p>

<p style="margin-left:22%;"><b>HW_BREAKPOINT_W</b></p>

<p style="margin-left:32%;">Count when we write the memory
location.</p>

<p style="margin-left:22%;"><b>HW_BREAKPOINT_RW</b></p>

<p style="margin-left:32%;">Count when we read or write the
memory location.</p>

<p style="margin-left:22%;"><b>HW_BREAKPOINT_X</b></p>

<p style="margin-left:32%;">Count when we execute code at
the memory location.</p>

<p style="margin-left:22%; margin-top: 1em">The values can
be combined via a bitwise or, but the combination of
<b>HW_BREAKPOINT_R</b> or <b>HW_BREAKPOINT_W</b> with
<b>HW_BREAKPOINT_X</b> is not allowed.</p>

<p style="margin-left:11%;"><i>bp_addr</i> (since Linux
2.6.33)</p>

<p style="margin-left:22%;">This is the address of the
breakpoint. For execution breakpoints, this is the memory
address of the instruction of interest; for read and write
breakpoints, it is the memory address of the memory location
of interest.</p>

<p style="margin-left:11%;"><i>config1</i> (since Linux
2.6.39)</p>

<p style="margin-left:22%;"><i>config1</i> is used for
setting events that need an extra register or otherwise do
not fit in the regular config field. Raw OFFCORE_EVENTS on
Nehalem/Westmere/SandyBridge use this field on Linux 3.3 and
later kernels.</p>

<p style="margin-left:11%;"><i>bp_len</i> (since Linux
2.6.33)</p>

<p style="margin-left:22%;"><i>bp_len</i> is the length of
the breakpoint being measured if <i>type</i> is
<b>PERF_TYPE_BREAKPOINT</b>. Options are
<b>HW_BREAKPOINT_LEN_1</b>, <b>HW_BREAKPOINT_LEN_2</b>,
<b>HW_BREAKPOINT_LEN_4</b>, and <b>HW_BREAKPOINT_LEN_8</b>.
For an execution breakpoint, set this to
<i>sizeof(long)</i>.</p>

<p style="margin-left:11%;"><i>config2</i> (since Linux
2.6.39)</p>

<p style="margin-left:22%;"><i>config2</i> is a further
extension of the <i>config1</i> field.</p>

<p style="margin-left:11%;"><i>branch_sample_type</i>
(since Linux 3.4)</p>

<p style="margin-left:22%;">If
<b>PERF_SAMPLE_BRANCH_STACK</b> is enabled, then this
specifies what branches to include in the branch record.</p>

<p style="margin-left:22%; margin-top: 1em">The first part
of the value is the privilege level, which is a combination
of one of the values listed below. If the user does not set
privilege level explicitly, the kernel will use the
event&rsquo;s privilege level. Event and branch privilege
levels do not have to match. <b><br>
PERF_SAMPLE_BRANCH_USER</b></p>

<p style="margin-left:32%;">Branch target is in user
space.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_KERNEL</b></p>

<p style="margin-left:32%;">Branch target is in kernel
space.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_HV</b></p>

<p style="margin-left:32%;">Branch target is in
hypervisor.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_PLM_ALL</b></p>

<p style="margin-left:32%;">A convenience value that is the
three preceding values ORed together.</p>

<p style="margin-left:22%; margin-top: 1em">In addition to
the privilege value, at least one or more of the following
bits must be set. <b><br>
PERF_SAMPLE_BRANCH_ANY</b></p>

<p style="margin-left:32%;">Any branch type.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_ANY_CALL</b></p>

<p style="margin-left:32%;">Any call branch (includes
direct calls, indirect calls, and far jumps).</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_IND_CALL</b></p>

<p style="margin-left:32%;">Indirect calls.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_CALL</b>
(since Linux 4.4)</p>

<p style="margin-left:32%;">Direct calls.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_ANY_RETURN</b></p>

<p style="margin-left:32%;">Any return branch.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_IND_JUMP</b>
(since Linux 4.2)</p>

<p style="margin-left:32%;">Indirect jumps.</p>

<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_COND</b>
(since Linux 3.16)</p>

<p style="margin-left:32%;">Conditional branches.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_ABORT_TX</b>
(since Linux 3.11)</p>

<p style="margin-left:32%;">Transactional memory
aborts.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_IN_TX</b>
(since Linux 3.11)</p>

<p style="margin-left:32%;">Branch in transactional memory
transaction.</p>


<p style="margin-left:22%;"><b>PERF_SAMPLE_BRANCH_NO_TX</b>
(since Linux 3.11)</p>

<p style="margin-left:32%;">Branch not in transactional
memory transaction. <b>PERF_SAMPLE_BRANCH_CALL_STACK</b>
(since Linux 4.1) Branch is part of a hardware-generated
call stack. This requires hardware support, currently only
found on Intel x86 Haswell or newer.</p>

<p style="margin-left:11%;"><i>sample_regs_user</i> (since
Linux 3.7)</p>

<p style="margin-left:22%;">This bit mask defines the set
of user CPU registers to dump on samples. The layout of the
register mask is architecture-specific and is described in
the kernel header file
<i>arch/ARCH/include/uapi/asm/perf_regs.h</i>.</p>

<p style="margin-left:11%;"><i>sample_stack_user</i> (since
Linux 3.7)</p>

<p style="margin-left:22%;">This defines the size of the
user stack to dump if <b>PERF_SAMPLE_STACK_USER</b> is
specified.</p>

<p style="margin-left:11%;"><i>clockid</i> (since Linux
4.1)</p>

<p style="margin-left:22%;">If <i>use_clockid</i> is set,
then this field selects which internal Linux timer to use
for timestamps. The available timers are defined in
<i>linux/time.h</i>, with <b>CLOCK_MONOTONIC</b>,
<b>CLOCK_MONOTONIC_RAW</b>, <b>CLOCK_REALTIME</b>,
<b>CLOCK_BOOTTIME</b>, and <b>CLOCK_TAI</b> currently
supported.</p>

<p style="margin-left:11%;"><i>aux_watermark</i> (since
Linux 4.1)</p>

<p style="margin-left:22%;">This specifies how much data is
required to trigger a <b>PERF_RECORD_AUX</b> sample.</p>

<p style="margin-left:11%;"><i>sample_max_stack</i> (since
Linux 4.8)</p>

<p style="margin-left:22%;">When <i>sample_type</i>
includes <b>PERF_SAMPLE_CALLCHAIN</b>, this field specifies
how many stack frames to report when generating the
callchain.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Reading
results</b> <br>
Once a <b>perf_event_open</b>() file descriptor has been
opened, the values of the events can be read from the file
descriptor. The values that are there are specified by the
<i>read_format</i> field in the <i>attr</i> structure at
open time.</p>

<p style="margin-left:11%; margin-top: 1em">If you attempt
to read into a buffer that is not big enough to hold the
data, the error <b>ENOSPC</b> results.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
layout of the data returned by a read:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>If <b>PERF_FORMAT_GROUP</b> was specified to allow
reading all events in a group at once:</p></td></tr>
</table>

<p style="margin-left:20%; margin-top: 1em">struct
read_format { <br>
u64 nr; /* The number of events */ <br>
u64 time_enabled; /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
<br>
u64 time_running; /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
<br>
struct { <br>
u64 value; /* The value of the event */ <br>
u64 id; /* if PERF_FORMAT_ID */ <br>
} values[nr]; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em">If <b>PERF_FORMAT_GROUP</b> was
<i>not</i> specified:</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:20%; margin-top: 1em">struct
read_format { <br>
u64 value; /* The value of the event */ <br>
u64 time_enabled; /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
<br>
u64 time_running; /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
<br>
u64 id; /* if PERF_FORMAT_ID */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The values read
are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><i>nr</i></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">The number of events in this
file descriptor. Available only if <b>PERF_FORMAT_GROUP</b>
was specified.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>time_enabled</i>,
<i>time_running</i></p>

<p style="margin-left:22%;">Total time the event was
enabled and running. Normally these values are the same.
Multiplexing happens if the number of events is more than
the number of available PMU counter slots. In that case the
events run only part of the time and the <i>time_enabled</i>
and <i>time running</i> values can be used to scale an
estimated value for the count.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>value</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>An unsigned 64-bit value containing the counter
result.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>id</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>A globally unique value for this particular event; only
present if <b>PERF_FORMAT_ID</b> was specified in
<i>read_format</i>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>MMAP
layout</b> <br>
When using <b>perf_event_open</b>() in sampled mode,
asynchronous events (like counter overflow or
<b>PROT_EXEC</b> mmap tracking) are logged into a
ring-buffer. This ring-buffer is created and accessed
through <b>mmap</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The mmap size
should be 1+2^n pages, where the first page is a metadata
page (<i>struct perf_event_mmap_page</i>) that contains
various bits of information such as where the ring-buffer
head is.</p>

<p style="margin-left:11%; margin-top: 1em">Before kernel
2.6.39, there is a bug that means you must allocate an mmap
ring buffer when sampling even if you do not plan to access
it.</p>

<p style="margin-left:11%; margin-top: 1em">The structure
of the first metadata mmap page is as follows:</p>

<p style="margin-left:17%; margin-top: 1em">struct
perf_event_mmap_page { <br>
__u32 version; /* version number of this structure */ <br>
__u32 compat_version; /* lowest version this is compat with
*/ <br>
__u32 lock; /* seqlock for synchronization */ <br>
__u32 index; /* hardware counter identifier */ <br>
__s64 offset; /* add to hardware counter value */ <br>
__u64 time_enabled; /* time event active */ <br>
__u64 time_running; /* time event on CPU */ <br>
union { <br>
__u64 capabilities; <br>
struct { <br>
__u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1, <br>
cap_bit0_is_deprecated : 1, <br>
cap_user_rdpmc : 1, <br>
cap_user_time : 1, <br>
cap_user_time_zero : 1, <br>
}; <br>
}; <br>
__u16 pmc_width; <br>
__u16 time_shift; <br>
__u32 time_mult; <br>
__u64 time_offset; <br>
__u64 __reserved[120]; /* Pad to 1 k */ <br>
__u64 data_head; /* head in the data section */ <br>
__u64 data_tail; /* user-space written tail */ <br>
__u64 data_offset; /* where the buffer starts */ <br>
__u64 data_size; /* data buffer size */ <br>
__u64 aux_head; <br>
__u64 aux_tail; <br>
__u64 aux_offset; <br>
__u64 aux_size;</p>

<p style="margin-left:17%; margin-top: 1em">}</p>

<p style="margin-left:11%; margin-top: 1em">The following
list describes the fields in the <i>perf_event_mmap_page</i>
structure in more detail: <i><br>
version</i></p>

<p style="margin-left:22%;">Version number of this
structure.</p>

<p style="margin-left:11%;"><i>compat_version</i></p>

<p style="margin-left:22%;">The lowest version this is
compatible with.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>lock</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>A seqlock for synchronization.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>index</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>A unique hardware counter identifier.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>offset</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>When using rdpmc for reads this offset value must be
added to the one returned by rdpmc to get the current total
event count.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>time_enabled</i></p>

<p style="margin-left:22%;">Time the event was active.</p>

<p style="margin-left:11%;"><i>time_running</i></p>

<p style="margin-left:22%;">Time the event was running.</p>

<p style="margin-left:11%;"><i>cap_usr_time</i> /
<i>cap_usr_rdpmc</i> / <i>cap_bit0</i> (since Linux 3.4)</p>

<p style="margin-left:22%;">There was a bug in the
definition of <i>cap_usr_time</i> and <i>cap_usr_rdpmc</i>
from Linux 3.4 until Linux 3.11. Both bits were defined to
point to the same location, so it was impossible to know if
<i>cap_usr_time</i> or <i>cap_usr_rdpmc</i> were actually
set.</p>

<p style="margin-left:22%; margin-top: 1em">Starting with
Linux 3.12, these are renamed to <i>cap_bit0</i> and you
should use the <i>cap_user_time</i> and
<i>cap_user_rdpmc</i> fields instead.</p>

<p style="margin-left:11%;"><i>cap_bit0_is_deprecated</i>
(since Linux 3.12)</p>

<p style="margin-left:22%;">If set, this bit indicates that
the kernel supports the properly separated
<i>cap_user_time</i> and <i>cap_user_rdpmc</i> bits.</p>

<p style="margin-left:22%; margin-top: 1em">If not-set, it
indicates an older kernel where <i>cap_usr_time</i> and
<i>cap_usr_rdpmc</i> map to the same bit and thus both
features should be used with caution.</p>

<p style="margin-left:11%;"><i>cap_user_rdpmc</i> (since
Linux 3.12)</p>

<p style="margin-left:22%;">If the hardware supports
user-space read of performance counters without syscall
(this is the &quot;rdpmc&quot; instruction on x86), then the
following code can be used to do a read:</p>

<p style="margin-left:28%; margin-top: 1em">u32 seq,
time_mult, time_shift, idx, width; <br>
u64 count, enabled, running; <br>
u64 cyc, time_offset;</p>

<p style="margin-left:28%; margin-top: 1em">do { <br>
seq = pc-&gt;lock; <br>
barrier(); <br>
enabled = pc-&gt;time_enabled; <br>
running = pc-&gt;time_running;</p>

<p style="margin-left:28%; margin-top: 1em">if
(pc-&gt;cap_usr_time &amp;&amp; enabled != running) { <br>
cyc = rdtsc(); <br>
time_offset = pc-&gt;time_offset; <br>
time_mult = pc-&gt;time_mult; <br>
time_shift = pc-&gt;time_shift; <br>
}</p>

<p style="margin-left:28%; margin-top: 1em">idx =
pc-&gt;index; <br>
count = pc-&gt;offset;</p>

<p style="margin-left:28%; margin-top: 1em">if
(pc-&gt;cap_usr_rdpmc &amp;&amp; idx) { <br>
width = pc-&gt;pmc_width; <br>
count += rdpmc(idx - 1); <br>
}</p>

<p style="margin-left:28%; margin-top: 1em">barrier(); <br>
} while (pc-&gt;lock != seq);</p>

<p style="margin-left:11%;"><i>cap_user_time</i> (since
Linux 3.12)</p>

<p style="margin-left:22%;">This bit indicates the hardware
has a constant, nonstop timestamp counter (TSC on x86).</p>

<p style="margin-left:11%;"><i>cap_user_time_zero</i>
(since Linux 3.12)</p>

<p style="margin-left:22%;">Indicates the presence of
<i>time_zero</i> which allows mapping timestamp values to
the hardware clock.</p>

<p style="margin-left:11%;"><i>pmc_width</i></p>

<p style="margin-left:22%;">If <i>cap_usr_rdpmc</i>, this
field provides the bit-width of the value read using the
rdpmc or equivalent instruction. This can be used to sign
extend the result like:</p>

<p style="margin-left:28%; margin-top: 1em">pmc &lt;&lt;=
64 - pmc_width; <br>
pmc &gt;&gt;= 64 - pmc_width; // signed shift right <br>
count += pmc;</p>

<p style="margin-left:11%;"><i>time_shift</i>,
<i>time_mult</i>, <i>time_offset</i></p>

<p style="margin-left:22%; margin-top: 1em">If
<i>cap_usr_time</i>, these fields can be used to compute the
time delta since <i>time_enabled</i> (in nanoseconds) using
rdtsc or similar.</p>

<p style="margin-left:28%; margin-top: 1em">u64 quot, rem;
<br>
u64 delta;</p>

<p style="margin-left:28%; margin-top: 1em">quot = cyc
&gt;&gt; time_shift; <br>
rem = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1); <br>
delta = time_offset + quot * time_mult + <br>
((rem * time_mult) &gt;&gt; time_shift);</p>

<p style="margin-left:22%; margin-top: 1em">Where
<i>time_offset</i>, <i>time_mult</i>, <i>time_shift</i>, and
<i>cyc</i> are read in the seqcount loop described above.
This delta can then be added to enabled and possible running
(if idx), improving the scaling:</p>

<p style="margin-left:28%; margin-top: 1em">enabled +=
delta; <br>
if (idx) <br>
running += delta; <br>
quot = count / running; <br>
rem = count % running; <br>
count = quot * enabled + (rem * enabled) / running;</p>

<p style="margin-left:11%;"><i>time_zero</i> (since Linux
3.12)</p>

<p style="margin-left:22%; margin-top: 1em">If
<i>cap_usr_time_zero</i> is set, then the hardware clock
(the TSC timestamp counter on x86) can be calculated from
the <i>time_zero</i>, <i>time_mult</i>, and
<i>time_shift</i> values:</p>

<p style="margin-left:28%; margin-top: 1em">time =
timestamp - time_zero; <br>
quot = time / time_mult; <br>
rem = time % time_mult; <br>
cyc = (quot &lt;&lt; time_shift) + (rem &lt;&lt; time_shift)
/ time_mult;</p>

<p style="margin-left:22%; margin-top: 1em">And vice
versa:</p>

<p style="margin-left:28%; margin-top: 1em">quot = cyc
&gt;&gt; time_shift; <br>
rem = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1); <br>
timestamp = time_zero + quot * time_mult + <br>
((rem * time_mult) &gt;&gt; time_shift);</p>

<p style="margin-left:11%;"><i>data_head</i></p>

<p style="margin-left:22%;">This points to the head of the
data section. The value continuously increases, it does not
wrap. The value needs to be manually wrapped by the size of
the mmap buffer before accessing the samples.</p>

<p style="margin-left:22%; margin-top: 1em">On SMP-capable
platforms, after reading the <i>data_head</i> value, user
space should issue an rmb().</p>

<p style="margin-left:11%;"><i>data_tail</i></p>

<p style="margin-left:22%;">When the mapping is
<b>PROT_WRITE</b>, the <i>data_tail</i> value should be
written by user space to reflect the last read data. In this
case, the kernel will not overwrite unread data.</p>

<p style="margin-left:11%;"><i>data_offset</i> (since Linux
4.1)</p>

<p style="margin-left:22%;">Contains the offset of the
location in the mmap buffer where perf sample data
begins.</p>

<p style="margin-left:11%;"><i>data_size</i> (since Linux
4.1)</p>

<p style="margin-left:22%;">Contains the size of the perf
sample region within the mmap buffer.</p>

<p style="margin-left:11%;"><i>aux_head</i>,
<i>aux_tail</i>, <i>aux_offset</i>, <i>aux_size</i> (since
Linux 4.1)</p>

<p style="margin-left:22%;">The AUX region allows
<b>mmap</b>(2)-ing a separate sample buffer for
high-bandwidth data streams (separate from the main perf
sample buffer). An example of a high-bandwidth stream is
instruction tracing support, as is found in newer Intel
processors.</p>

<p style="margin-left:22%; margin-top: 1em">To set up an
AUX area, first <i>aux_offset</i> needs to be set with an
offset greater than <i>data_offset</i>+<i>data_size</i> and
<i>aux_size</i> needs to be set to the desired buffer size.
The desired offset and size must be page aligned, and the
size must be a power of two. These values are then passed to
mmap in order to map the AUX buffer. Pages in the AUX buffer
are included as part of the <b>RLIMIT_MEMLOCK</b> resource
limit (see <b>setrlimit</b>(2)), and also as part of the
<i>perf_event_mlock_kb</i> allowance.</p>

<p style="margin-left:22%; margin-top: 1em">By default, the
AUX buffer will be truncated if it will not fit in the
available space in the ring buffer. If the AUX buffer is
mapped as a read only buffer, then it will operate in ring
buffer mode where old data will be overwritten by new. In
overwrite mode, it might not be possible to infer where the
new data began, and it is the consumer&rsquo;s job to
disable measurement while reading to avoid possible data
races.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>aux_head</i> and <i>aux_tail</i> ring buffer pointers
have the same behavior and ordering rules as the previous
described <i>data_head</i> and <i>data_tail</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
2^n ring-buffer pages have the layout described below.</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>perf_event_attr.sample_id_all</i> is set, then all event
types will have the sample_type selected fields related to
where/when (identity) an event took place (TID, TIME, ID,
CPU, STREAM_ID) described in <b>PERF_RECORD_SAMPLE</b>
below, it will be stashed just after the
<i>perf_event_header</i> and the fields already present for
the existing fields, that is, at the end of the payload.
This allows a newer perf.data file to be supported by older
perf tools, with the new optional fields being ignored.</p>

<p style="margin-left:11%; margin-top: 1em">The mmap values
start with a header:</p>

<p style="margin-left:17%; margin-top: 1em">struct
perf_event_header { <br>
__u32 type; <br>
__u16 misc; <br>
__u16 size; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Below, we
describe the <i>perf_event_header</i> fields in more detail.
For ease of reading, the fields with shorter descriptions
are presented first.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>size</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This indicates the size of the record.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>misc</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>misc</i> field contains additional information
about the sample.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The CPU mode
can be determined from this value by masking with
<b>PERF_RECORD_MISC_CPUMODE_MASK</b> and looking for one of
the following (note these are not bit masks, only one can be
set at a time): <b><br>
PERF_RECORD_MISC_CPUMODE_UNKNOWN</b></p>

<p style="margin-left:32%;">Unknown CPU mode.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_KERNEL</b></p>

<p style="margin-left:32%;">Sample happened in the
kernel.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_USER</b></p>

<p style="margin-left:32%;">Sample happened in user
code.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_HYPERVISOR</b></p>

<p style="margin-left:32%;">Sample happened in the
hypervisor.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_GUEST_KERNEL</b>
(since Linux 2.6.35)</p>

<p style="margin-left:32%;">Sample happened in the guest
kernel.</p>

<p style="margin-left:22%;"><b>PERF_RECORD_MISC_GUEST_USER
(since Linux 2.6.35)</b></p>

<p style="margin-left:32%;">Sample happened in guest user
code.</p>

<p style="margin-left:22%; margin-top: 1em">Since the
following three statuses are generated by different record
types, they alias to the same bit: <b><br>
PERF_RECORD_MISC_MMAP_DATA</b> (since Linux 3.10)</p>

<p style="margin-left:32%;">This is set when the mapping is
not executable; otherwise the mapping is executable.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_COMM_EXEC</b>
(since Linux 3.16)</p>

<p style="margin-left:32%;">This is set for a
<b>PERF_RECORD_COMM</b> record on kernels more recent than
Linux 3.16 if a process name change was caused by an
<b>exec</b>(2) system call.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_SWITCH_OUT</b>
(since Linux 4.3)</p>

<p style="margin-left:32%;">When a
<b>PERF_RECORD_SWITCH</b> or
<b>PERF_RECORD_SWITCH_CPU_WIDE</b> record is generated, this
bit indicates that the context switch is away from the
current process (instead of into the current process).</p>

<p style="margin-left:22%; margin-top: 1em">In addition,
the following bits can be set: <b><br>
PERF_RECORD_MISC_EXACT_IP</b></p>

<p style="margin-left:32%;">This indicates that the content
of <b>PERF_SAMPLE_IP</b> points to the actual instruction
that triggered the event. See also
<i>perf_event_attr.precise_ip</i>.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_EXT_RESERVED</b>
(since Linux 2.6.35)</p>

<p style="margin-left:32%;">This indicates there is
extended data available (currently not used).</p>


<p style="margin-left:22%;"><b>PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT</b></p>

<p style="margin-left:32%;">This bit is not set by the
kernel. It is reserved for the user-space perf utility to
indicate that <i>/proc/i[pid]/maps</i> parsing was taking
too long and was stopped, and thus the mmap records may be
truncated.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>type</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>type</i> value is one of the below. The values in
the corresponding record (that follows the header) depend on
the <i>type</i> selected as shown.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_MMAP</b></p>

<p style="margin-left:28%;">The MMAP events record the
<b>PROT_EXEC</b> mappings so that we can correlate
user-space IPs to code. They have the following
structure:</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid, tid; <br>
u64 addr; <br>
u64 len; <br>
u64 pgoff; <br>
char filename[]; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>pid</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the process ID.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>tid</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the thread ID.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>addr</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the address of the allocated memory. <i>len</i> is
the length of the allocated memory. <i>pgoff</i> is the page
offset of the allocated memory. <i>filename</i> is a string
describing the backing of the allocated memory.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_LOST</b></p>

<p style="margin-left:28%;">This record indicates when
events are lost.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 id; <br>
u64 lost; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>id</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the unique event ID for the samples that were
lost.</p> </td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>lost</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the number of events that were lost.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_COMM</b></p>

<p style="margin-left:28%;">This record indicates a change
in the process name.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid; <br>
u32 tid; <br>
char comm[]; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>pid</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the process ID.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>tid</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the thread ID.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>comm</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is a string containing the new name of the process.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_EXIT</b></p>

<p style="margin-left:28%;">This record indicates a process
exit event.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid, ppid; <br>
u32 tid, ptid; <br>
u64 time; <br>
struct sample_id sample_id; <br>
};</p>

<p style="margin-left:22%;"><b>PERF_RECORD_THROTTLE</b>,
<b>PERF_RECORD_UNTHROTTLE</b></p>

<p style="margin-left:28%;">This record indicates a
throttle/unthrottle event.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 time; <br>
u64 id; <br>
u64 stream_id; <br>
struct sample_id sample_id; <br>
};</p>

<p style="margin-left:22%;"><b>PERF_RECORD_FORK</b></p>

<p style="margin-left:28%;">This record indicates a fork
event.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid, ppid; <br>
u32 tid, ptid; <br>
u64 time; <br>
struct sample_id sample_id; <br>
};</p>

<p style="margin-left:22%;"><b>PERF_RECORD_READ</b></p>

<p style="margin-left:28%;">This record indicates a read
event.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid, tid; <br>
struct read_format values; <br>
struct sample_id sample_id; <br>
};</p>

<p style="margin-left:22%;"><b>PERF_RECORD_SAMPLE</b></p>

<p style="margin-left:28%;">This record indicates a
sample.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 sample_id; /* if PERF_SAMPLE_IDENTIFIER */ <br>
u64 ip; /* if PERF_SAMPLE_IP */ <br>
u32 pid, tid; /* if PERF_SAMPLE_TID */ <br>
u64 time; /* if PERF_SAMPLE_TIME */ <br>
u64 addr; /* if PERF_SAMPLE_ADDR */ <br>
u64 id; /* if PERF_SAMPLE_ID */ <br>
u64 stream_id; /* if PERF_SAMPLE_STREAM_ID */ <br>
u32 cpu, res; /* if PERF_SAMPLE_CPU */ <br>
u64 period; /* if PERF_SAMPLE_PERIOD */ <br>
struct read_format v; <br>
/* if PERF_SAMPLE_READ */ <br>
u64 nr; /* if PERF_SAMPLE_CALLCHAIN */ <br>
u64 ips[nr]; /* if PERF_SAMPLE_CALLCHAIN */ <br>
u32 size; /* if PERF_SAMPLE_RAW */ <br>
char data[size]; /* if PERF_SAMPLE_RAW */ <br>
u64 bnr; /* if PERF_SAMPLE_BRANCH_STACK */ <br>
struct perf_branch_entry lbr[bnr]; <br>
/* if PERF_SAMPLE_BRANCH_STACK */ <br>
u64 abi; /* if PERF_SAMPLE_REGS_USER */ <br>
u64 regs[weight(mask)]; <br>
/* if PERF_SAMPLE_REGS_USER */ <br>
u64 size; /* if PERF_SAMPLE_STACK_USER */ <br>
char data[size]; /* if PERF_SAMPLE_STACK_USER */ <br>
u64 dyn_size; /* if PERF_SAMPLE_STACK_USER &amp;&amp; <br>
size != 0 */ <br>
u64 weight; /* if PERF_SAMPLE_WEIGHT */ <br>
u64 data_src; /* if PERF_SAMPLE_DATA_SRC */ <br>
u64 transaction; /* if PERF_SAMPLE_TRANSACTION */ <br>
u64 abi; /* if PERF_SAMPLE_REGS_INTR */ <br>
u64 regs[weight(mask)]; <br>
/* if PERF_SAMPLE_REGS_INTR */ <br>
u64 phys_addr; /* if PERF_SAMPLE_PHYS_ADDR */ <br>
u64 cgroup; /* if PERF_SAMPLE_CGROUP */ <br>
};</p>

<p style="margin-left:28%;"><i>sample_id</i></p>

<p style="margin-left:34%;">If
<b>PERF_SAMPLE_IDENTIFIER</b> is enabled, a 64-bit unique ID
is included. This is a duplication of the
<b>PERF_SAMPLE_ID</b> <i>id</i> value, but included at the
beginning of the sample so parsers can easily obtain the
value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="3%">


<p><i>ip</i></p></td>
<td width="3%"></td>
<td width="66%">


<p>If <b>PERF_SAMPLE_IP</b> is enabled, then a 64-bit
instruction pointer value is included.</p></td></tr>
</table>

<p style="margin-left:28%;"><i>pid</i>, <i>tid</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_TID</b> is
enabled, then a 32-bit process ID and 32-bit thread ID are
included.</p>

<p style="margin-left:28%;"><i>time</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_TIME</b> is
enabled, then a 64-bit timestamp is included. This is
obtained via local_clock() which is a hardware timestamp if
available and the jiffies value if not.</p>

<p style="margin-left:28%;"><i>addr</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_ADDR</b> is
enabled, then a 64-bit address is included. This is usually
the address of a tracepoint, breakpoint, or software event;
otherwise the value is 0.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="3%">


<p><i>id</i></p></td>
<td width="3%"></td>
<td width="66%">


<p>If <b>PERF_SAMPLE_ID</b> is enabled, a 64-bit unique ID
is included. If the event is a member of an event group, the
group leader ID is returned. This ID is the same as the one
returned by <b>PERF_FORMAT_ID</b>.</p></td></tr>
</table>

<p style="margin-left:28%;"><i>stream_id</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_STREAM_ID</b>
is enabled, a 64-bit unique ID is included. Unlike
<b>PERF_SAMPLE_ID</b> the actual ID is returned, not the
group leader. This ID is the same as the one returned by
<b>PERF_FORMAT_ID</b>.</p>

<p style="margin-left:28%;"><i>cpu</i>, <i>res</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_CPU</b> is
enabled, this is a 32-bit value indicating which CPU was
being used, in addition to a reserved (unused) 32-bit
value.</p>

<p style="margin-left:28%;"><i>period</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_PERIOD</b> is
enabled, a 64-bit value indicating the current sampling
period is written.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="1%">


<p><i>v</i></p></td>
<td width="5%"></td>
<td width="66%">


<p>If <b>PERF_SAMPLE_READ</b> is enabled, a structure of
type read_format is included which has values for all events
in the event group. The values included depend on the
<i>read_format</i> value used at <b>perf_event_open</b>()
time.</p> </td></tr>
</table>

<p style="margin-left:28%;"><i>nr</i>, <i>ips[nr]</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_CALLCHAIN</b>
is enabled, then a 64-bit number is included which indicates
how many following 64-bit instruction pointers will follow.
This is the current callchain.</p>

<p style="margin-left:28%;"><i>size</i>,
<i>data[size]</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_RAW</b> is
enabled, then a 32-bit value indicating size is included
followed by an array of 8-bit values of length size. The
values are padded with 0 to have 64-bit alignment.</p>

<p style="margin-left:34%; margin-top: 1em">This RAW record
data is opaque with respect to the ABI. The ABI
doesn&rsquo;t make any promises with respect to the
stability of its content, it may vary depending on event,
hardware, and kernel version.</p>

<p style="margin-left:28%;"><i>bnr</i>, <i>lbr[bnr]</i></p>

<p style="margin-left:34%;">If
<b>PERF_SAMPLE_BRANCH_STACK</b> is enabled, then a 64-bit
value indicating the number of records is included, followed
by <i>bnr perf_branch_entry</i> structures which each
include the fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="34%"></td>
<td width="6%">


<p><i>from</i></p></td>
<td width="5%"></td>
<td width="55%">


<p>This indicates the source instruction (may not be a
branch).</p> </td></tr>
<tr valign="top" align="left">
<td width="34%"></td>
<td width="6%">


<p><i>to</i></p></td>
<td width="5%"></td>
<td width="55%">


<p>The branch target.</p></td></tr>
</table>

<p style="margin-left:34%;"><i>mispred</i></p>

<p style="margin-left:45%;">The branch target was
mispredicted.</p>

<p style="margin-left:34%;"><i>predicted</i></p>

<p style="margin-left:45%;">The branch target was
predicted.</p>

<p style="margin-left:34%;"><i>in_tx</i> (since Linux
3.11)</p>

<p style="margin-left:45%;">The branch was in a
transactional memory transaction.</p>

<p style="margin-left:34%;"><i>abort</i> (since Linux
3.11)</p>

<p style="margin-left:45%;">The branch was in an aborted
transactional memory transaction.</p>

<p style="margin-left:34%;"><i>cycles</i> (since Linux
4.3)</p>

<p style="margin-left:45%;">This reports the number of
cycles elapsed since the previous branch stack update.</p>

<p style="margin-left:34%; margin-top: 1em">The entries are
from most to least recent, so the first entry has the most
recent branch.</p>

<p style="margin-left:34%; margin-top: 1em">Support for
<i>mispred</i>, <i>predicted</i>, and <i>cycles</i> is
optional; if not supported, those values will be 0.</p>

<p style="margin-left:34%; margin-top: 1em">The type of
branches recorded is specified by the
<i>branch_sample_type</i> field.</p>

<p style="margin-left:28%;"><i>abi</i>,
<i>regs[weight(mask)]</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_REGS_USER</b>
is enabled, then the user CPU registers are recorded.</p>

<p style="margin-left:34%; margin-top: 1em">The <i>abi</i>
field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,
<b>PERF_SAMPLE_REGS_ABI_32</b>, or
<b>PERF_SAMPLE_REGS_ABI_64</b>.</p>

<p style="margin-left:34%; margin-top: 1em">The <i>regs</i>
field is an array of the CPU registers that were specified
by the <i>sample_regs_user</i> attr field. The number of
values is the number of bits set in the
<i>sample_regs_user</i> bit mask.</p>

<p style="margin-left:28%;"><i>size</i>, <i>data[size]</i>,
<i>dyn_size</i></p>

<p style="margin-left:34%;">If
<b>PERF_SAMPLE_STACK_USER</b> is enabled, then the user
stack is recorded. This can be used to generate stack
backtraces. <i>size</i> is the size requested by the user in
<i>sample_stack_user</i> or else the maximum record size.
<i>data</i> is the stack data (a raw dump of the memory
pointed to by the stack pointer at the time of sampling).
<i>dyn_size</i> is the amount of data actually dumped (can
be less than <i>size</i>). Note that <i>dyn_size</i> is
omitted if <i>size</i> is 0.</p>

<p style="margin-left:28%;"><i>weight</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_WEIGHT</b> is
enabled, then a 64-bit value provided by the hardware is
recorded that indicates how costly the event was. This
allows expensive events to stand out more clearly in
profiles.</p>

<p style="margin-left:28%;"><i>data_src</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_DATA_SRC</b>
is enabled, then a 64-bit value is recorded that is made up
of the following fields: <i><br>
mem_op</i></p>

<p style="margin-left:40%;">Type of opcode, a bitwise
combination of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="28%">


<p><b>PERF_MEM_OP_NA</b></p></td>
<td width="9%"></td>
<td width="23%">


<p>Not available</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="28%">


<p><b>PERF_MEM_OP_LOAD</b></p></td>
<td width="9%"></td>
<td width="23%">


<p>Load instruction</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="28%">


<p><b>PERF_MEM_OP_STORE</b></p></td>
<td width="9%"></td>
<td width="23%">


<p>Store instruction</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="28%">


<p><b>PERF_MEM_OP_PFETCH</b></p></td>
<td width="9%"></td>
<td width="23%">


<p>Prefetch</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="28%">


<p><b>PERF_MEM_OP_EXEC</b></p></td>
<td width="9%"></td>
<td width="23%">


<p>Executable code</p></td></tr>
</table>

<p style="margin-left:34%;"><i>mem_lvl</i></p>

<p style="margin-left:40%;">Memory hierarchy level hit or
miss, a bitwise combination of the following, shifted left
by <b>PERF_MEM_LVL_SHIFT</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_NA</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Not available</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_HIT</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Hit</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_MISS</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Miss</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_L1</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Level 1 cache</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_LFB</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Line fill buffer</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_L2</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Level 2 cache</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_L3</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Level 3 cache</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_LOC_RAM</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Local DRAM</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_REM_RAM1</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Remote DRAM 1 hop</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_REM_RAM2</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Remote DRAM 2 hops</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_REM_CCE1</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Remote cache 1 hop</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_REM_CCE2</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Remote cache 2 hops</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_IO</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>I/O memory</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="32%">


<p><b>PERF_MEM_LVL_UNC</b></p></td>
<td width="5%"></td>
<td width="23%">


<p>Uncached memory</p></td></tr>
</table>

<p style="margin-left:34%;"><i>mem_snoop</i></p>

<p style="margin-left:40%;">Snoop mode, a bitwise
combination of the following, shifted left by
<b>PERF_MEM_SNOOP_SHIFT</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="29%">


<p><b>PERF_MEM_SNOOP_NA</b></p></td>
<td width="8%"></td>
<td width="23%">


<p>Not available</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="29%">


<p><b>PERF_MEM_SNOOP_NONE</b></p></td>
<td width="8%"></td>
<td width="23%">


<p>No snoop</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="29%">


<p><b>PERF_MEM_SNOOP_HIT</b></p></td>
<td width="8%"></td>
<td width="23%">


<p>Snoop hit</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="29%">


<p><b>PERF_MEM_SNOOP_MISS</b></p></td>
<td width="8%"></td>
<td width="23%">


<p>Snoop miss</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="29%">


<p><b>PERF_MEM_SNOOP_HITM</b></p></td>
<td width="8%"></td>
<td width="23%">


<p>Snoop hit modified</p></td></tr>
</table>

<p style="margin-left:34%;"><i>mem_lock</i></p>

<p style="margin-left:40%;">Lock instruction, a bitwise
combination of the following, shifted left by
<b>PERF_MEM_LOCK_SHIFT</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="31%">


<p><b>PERF_MEM_LOCK_NA</b></p></td>
<td width="6%"></td>
<td width="23%">


<p>Not available</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="31%">


<p><b>PERF_MEM_LOCK_LOCKED</b></p></td>
<td width="6%"></td>
<td width="23%">


<p>Locked transaction</p></td></tr>
</table>

<p style="margin-left:34%;"><i>mem_dtlb</i></p>

<p style="margin-left:40%;">TLB access hit or miss, a
bitwise combination of the following, shifted left by
<b>PERF_MEM_TLB_SHIFT</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="26%">


<p><b>PERF_MEM_TLB_NA</b></p></td>
<td width="11%"></td>
<td width="23%">


<p>Not available</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="26%">


<p><b>PERF_MEM_TLB_HIT</b></p></td>
<td width="11%"></td>
<td width="23%">


<p>Hit</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="26%">


<p><b>PERF_MEM_TLB_MISS</b></p></td>
<td width="11%"></td>
<td width="23%">


<p>Miss</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="26%">


<p><b>PERF_MEM_TLB_L1</b></p></td>
<td width="11%"></td>
<td width="23%">


<p>Level 1 TLB</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="26%">


<p><b>PERF_MEM_TLB_L2</b></p></td>
<td width="11%"></td>
<td width="23%">


<p>Level 2 TLB</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="26%">


<p><b>PERF_MEM_TLB_WK</b></p></td>
<td width="11%"></td>
<td width="23%">


<p>Hardware walker</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="26%">


<p><b>PERF_MEM_TLB_OS</b></p></td>
<td width="11%"></td>
<td width="23%">


<p>OS fault handler</p></td></tr>
</table>

<p style="margin-left:28%;"><i>transaction</i></p>

<p style="margin-left:34%;">If the
<b>PERF_SAMPLE_TRANSACTION</b> flag is set, then a 64-bit
field is recorded describing the sources of any
transactional memory aborts.</p>

<p style="margin-left:34%; margin-top: 1em">The field is a
bitwise combination of the following values: <b><br>
PERF_TXN_ELISION</b></p>

<p style="margin-left:45%;">Abort from an elision type
transaction (Intel-CPU-specific).</p>


<p style="margin-left:34%;"><b>PERF_TXN_TRANSACTION</b></p>

<p style="margin-left:45%;">Abort from a generic
transaction.</p>

<p style="margin-left:34%;"><b>PERF_TXN_SYNC</b></p>

<p style="margin-left:45%;">Synchronous abort (related to
the reported instruction).</p>

<p style="margin-left:34%;"><b>PERF_TXN_ASYNC</b></p>

<p style="margin-left:45%;">Asynchronous abort (not related
to the reported instruction).</p>

<p style="margin-left:34%;"><b>PERF_TXN_RETRY</b></p>

<p style="margin-left:45%;">Retryable abort (retrying the
transaction may have succeeded).</p>

<p style="margin-left:34%;"><b>PERF_TXN_CONFLICT</b></p>

<p style="margin-left:45%;">Abort due to memory conflicts
with other threads.</p>


<p style="margin-left:34%;"><b>PERF_TXN_CAPACITY_WRITE</b></p>

<p style="margin-left:45%;">Abort due to write capacity
overflow.</p>


<p style="margin-left:34%;"><b>PERF_TXN_CAPACITY_READ</b></p>

<p style="margin-left:45%;">Abort due to read capacity
overflow.</p>

<p style="margin-left:34%; margin-top: 1em">In addition, a
user-specified abort code can be obtained from the high 32
bits of the field by shifting right by
<b>PERF_TXN_ABORT_SHIFT</b> and masking with the value
<b>PERF_TXN_ABORT_MASK</b>.</p>

<p style="margin-left:28%;"><i>abi</i>,
<i>regs[weight(mask)]</i></p>

<p style="margin-left:34%;">If <b>PERF_SAMPLE_REGS_INTR</b>
is enabled, then the user CPU registers are recorded.</p>

<p style="margin-left:34%; margin-top: 1em">The <i>abi</i>
field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,
<b>PERF_SAMPLE_REGS_ABI_32</b>, or
<b>PERF_SAMPLE_REGS_ABI_64</b>.</p>

<p style="margin-left:34%; margin-top: 1em">The <i>regs</i>
field is an array of the CPU registers that were specified
by the <i>sample_regs_intr</i> attr field. The number of
values is the number of bits set in the
<i>sample_regs_intr</i> bit mask.</p>

<p style="margin-left:28%;"><i>phys_addr</i></p>

<p style="margin-left:34%;">If the
<b>PERF_SAMPLE_PHYS_ADDR</b> flag is set, then the 64-bit
physical address is recorded.</p>

<p style="margin-left:28%;"><i>cgroup</i></p>

<p style="margin-left:34%;">If the
<b>PERF_SAMPLE_CGROUP</b> flag is set, then the 64-bit
cgroup ID (for the perf_event subsystem) is recorded. To get
the pathname of the cgroup, the ID should match to one in a
<b>PERF_RECORD_CGROUP .</b></p>

<p style="margin-left:22%;"><b>PERF_RECORD_MMAP2</b></p>

<p style="margin-left:28%;">This record includes extended
information on <b>mmap</b>(2) calls returning executable
mappings. The format is similar to that of the
<b>PERF_RECORD_MMAP</b> record, but includes extra values
that allow uniquely identifying shared mappings.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid; <br>
u32 tid; <br>
u64 addr; <br>
u64 len; <br>
u64 pgoff; <br>
u32 maj; <br>
u32 min; <br>
u64 ino; <br>
u64 ino_generation; <br>
u32 prot; <br>
u32 flags; <br>
char filename[]; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>pid</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the process ID.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>tid</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the thread ID.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>addr</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the address of the allocated memory.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>len</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the length of the allocated memory.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>pgoff</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the page offset of the allocated memory.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>maj</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the major ID of the underlying device.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>min</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the minor ID of the underlying device.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>ino</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>is the inode number.</p></td></tr>
</table>

<p style="margin-left:28%;"><i>ino_generation</i></p>

<p style="margin-left:38%;">is the inode generation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>prot</i></p></td>
<td width="3%"></td>
<td width="47%">


<p>is the protection information.</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>flags</i></p></td>
<td width="3%"></td>
<td width="47%">


<p>is the flags information.</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:28%;"><i>filename</i></p>

<p style="margin-left:38%;">is a string describing the
backing of the allocated memory.</p>

<p style="margin-left:22%;"><b>PERF_RECORD_AUX</b> (since
Linux 4.1)</p>

<p style="margin-left:28%;">This record reports that new
data is available in the separate AUX buffer region.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 aux_offset; <br>
u64 aux_size; <br>
u64 flags; <br>
struct sample_id sample_id; <br>
};</p>

<p style="margin-left:28%;"><i>aux_offset</i></p>

<p style="margin-left:38%;">offset in the AUX mmap region
where the new data begins.</p>

<p style="margin-left:28%;"><i>aux_size</i></p>

<p style="margin-left:38%;">size of the data made
available.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>flags</i></p></td>
<td width="3%"></td>
<td width="39%">


<p>describes the AUX update.</p></td>
<td width="23%">
</td></tr>
</table>


<p style="margin-left:38%;"><b>PERF_AUX_FLAG_TRUNCATED</b></p>

<p style="margin-left:49%;">if set, then the data returned
was truncated to fit the available buffer size.</p>


<p style="margin-left:38%;"><b>PERF_AUX_FLAG_OVERWRITE</b></p>

<p style="margin-left:49%;">if set, then the data returned
has overwritten previous data.</p>


<p style="margin-left:22%;"><b>PERF_RECORD_ITRACE_START</b>
(since Linux 4.1)</p>

<p style="margin-left:28%;">This record indicates which
process has initiated an instruction trace event, allowing
tools to properly correlate the instruction addresses in the
AUX buffer with the proper executable.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid; <br>
u32 tid; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="4%">


<p><i>pid</i></p></td>
<td width="6%"></td>
<td width="62%">


<p>process ID of the thread starting an instruction
trace.</p> </td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="4%">


<p><i>tid</i></p></td>
<td width="6%"></td>
<td width="62%">


<p>thread ID of the thread starting an instruction
trace.</p> </td></tr>
</table>


<p style="margin-left:22%;"><b>PERF_RECORD_LOST_SAMPLES</b>
(since Linux 4.2)</p>

<p style="margin-left:28%;">When using hardware sampling
(such as Intel PEBS) this record indicates some number of
samples that may have been lost.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 lost; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>lost</i></p></td>
<td width="4%"></td>
<td width="60%">


<p>the number of potentially lost samples.</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_SWITCH</b>
(since Linux 4.3)</p>

<p style="margin-left:28%;">This record indicates a context
switch has happened. The <b>PERF_RECORD_MISC_SWITCH_OUT</b>
bit in the <i>misc</i> field indicates whether it was a
context switch into or away from the current process.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
struct sample_id sample_id; <br>
};</p>


<p style="margin-left:22%;"><b>PERF_RECORD_SWITCH_CPU_WIDE</b>
(since Linux 4.3)</p>

<p style="margin-left:28%;">As with
<b>PERF_RECORD_SWITCH</b> this record indicates a context
switch has happened, but it only occurs when sampling in
CPU-wide mode and provides additional information on the
process being switched to/from. The
<b>PERF_RECORD_MISC_SWITCH_OUT</b> bit in the <i>misc</i>
field indicates whether it was a context switch into or away
from the current process.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 next_prev_pid; <br>
u32 next_prev_tid; <br>
struct sample_id sample_id; <br>
};</p>

<p style="margin-left:28%;"><i>next_prev_pid</i></p>

<p style="margin-left:38%;">The process ID of the previous
(if switching in) or next (if switching out) process on the
CPU.</p>

<p style="margin-left:28%;"><i>next_prev_tid</i></p>

<p style="margin-left:38%;">The thread ID of the previous
(if switching in) or next (if switching out) thread on the
CPU.</p>

<p style="margin-left:22%;"><b>PERF_RECORD_NAMESPACES</b>
(since Linux 4.11)</p>

<p style="margin-left:28%;">This record includes various
namespace information of a process.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u32 pid; <br>
u32 tid; <br>
u64 nr_namespaces; <br>
struct { u64 dev, inode } [nr_namespaces]; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="4%">


<p><i>pid</i></p></td>
<td width="6%"></td>
<td width="27%">


<p>is the process ID</p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="4%">


<p><i>tid</i></p></td>
<td width="6%"></td>
<td width="27%">


<p>is the thread ID</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:28%;"><i>nr_namespace</i></p>

<p style="margin-left:38%;">is the number of namespaces in
this record</p>

<p style="margin-left:28%; margin-top: 1em">Each namespace
has <i>dev</i> and <i>inode</i> fields and is recorded in
the fixed position like below: <b><br>
NET_NS_INDEX</b>=<b>0</b></p>

<p style="margin-left:38%;">Network namespace</p>


<p style="margin-left:28%;"><b>UTS_NS_INDEX</b>=<b>1</b></p>

<p style="margin-left:38%;">UTS namespace</p>


<p style="margin-left:28%;"><b>IPC_NS_INDEX</b>=<b>2</b></p>

<p style="margin-left:38%;">IPC namespace</p>


<p style="margin-left:28%;"><b>PID_NS_INDEX</b>=<b>3</b></p>

<p style="margin-left:38%;">PID namespace</p>


<p style="margin-left:28%;"><b>USER_NS_INDEX</b>=<b>4</b></p>

<p style="margin-left:38%;">User namespace</p>


<p style="margin-left:28%;"><b>MNT_NS_INDEX</b>=<b>5</b></p>

<p style="margin-left:38%;">Mount namespace</p>


<p style="margin-left:28%;"><b>CGROUP_NS_INDEX</b>=<b>6</b></p>

<p style="margin-left:38%;">Cgroup namespace</p>

<p style="margin-left:22%;"><b>PERF_RECORD_KSYMBOL</b>
(since Linux 5.0)</p>

<p style="margin-left:28%;">This record indicates kernel
symbol register/unregister events.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 addr; <br>
u32 len; <br>
u16 ksym_type; <br>
u16 flags; <br>
char name[]; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>addr</i></p></td>
<td width="4%"></td>
<td width="56%">


<p>is the address of the kernel symbol.</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>len</i></p></td>
<td width="4%"></td>
<td width="56%">


<p>is the length of the kernel symbol.</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:28%;"><i>ksym_type</i></p>

<p style="margin-left:38%;">is the type of the kernel
symbol. Currently the following types are available: <b><br>
PERF_RECORD_KSYMBOL_TYPE_BPF</b></p>

<p style="margin-left:49%;">The kernel symbol is a BPF
function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>flags</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>If the <b>PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER</b> is
set, then this event is for unregistering the kernel
symbol.</p> </td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_BPF_EVENT</b>
(since Linux 5.0)</p>

<p style="margin-left:28%;">This record indicates BPF
program is loaded or unloaded.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u16 type; <br>
u16 flags; <br>
u32 id; <br>
u8 tag[BPF_TAG_SIZE]; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>type</i></p></td>
<td width="4%"></td>
<td width="48%">


<p>is one of the following values:</p></td>
<td width="14%">
</td></tr>
</table>


<p style="margin-left:38%;"><b>PERF_BPF_EVENT_PROG_LOAD</b></p>

<p style="margin-left:49%;">A BPF program is loaded</p>


<p style="margin-left:38%;"><b>PERF_BPF_EVENT_PROG_UNLOAD</b></p>

<p style="margin-left:49%;">A BPF program is unloaded</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="4%">


<p><i>id</i></p></td>
<td width="6%"></td>
<td width="62%">


<p>is the ID of the BPF program.</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="4%">


<p><i>tag</i></p></td>
<td width="6%"></td>
<td width="62%">


<p>is the tag of the BPF program. Currently,
<b>BPF_TAG_SIZE</b> is defined as 8.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_CGROUP</b>
(since Linux 5.7)</p>

<p style="margin-left:28%;">This record indicates a new
cgroup is created and activated.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 id; <br>
char path[]; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>id</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the cgroup identifier. This can be also retrieved by
<b>name_to_handle_at</b>(2) on the cgroup path (as a file
handle).</p> </td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>path</i></p></td>
<td width="4%"></td>
<td width="62%">


<p>is the path of the cgroup from the root.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>PERF_RECORD_TEXT_POKE</b>
(since Linux 5.8)</p>

<p style="margin-left:28%;">This record indicates a change
in the kernel text. This includes addition and removal of
the text and the corresponding length is zero in this
case.</p>

<p style="margin-left:34%; margin-top: 1em">struct { <br>
struct perf_event_header header; <br>
u64 addr; <br>
u16 old_len; <br>
u16 new_len; <br>
u8 bytes[]; <br>
struct sample_id sample_id; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="6%">


<p><i>addr</i></p></td>
<td width="4%"></td>
<td width="44%">


<p>is the address of the change</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:28%;"><i>old_len</i></p>

<p style="margin-left:38%;">is the old length</p>

<p style="margin-left:28%;"><i>new_len</i></p>

<p style="margin-left:38%;">is the new length</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="7%">


<p><i>bytes</i></p></td>
<td width="3%"></td>
<td width="62%">


<p>contains old bytes immediately followed by new
bytes.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Overflow
handling</b> <br>
Events can be set to notify when a threshold is crossed,
indicating an overflow. Overflow conditions can be captured
by monitoring the event file descriptor with <b>poll</b>(2),
<b>select</b>(2), or <b>epoll</b>(7). Alternatively, the
overflow events can be captured via sa signal handler, by
enabling I/O signaling on the file descriptor; see the
discussion of the <b>F_SETOWN</b> and <b>F_SETSIG</b>
operations in <b>fcntl</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Overflows are
generated only by sampling events (<i>sample_period</i> must
have a nonzero value).</p>

<p style="margin-left:11%; margin-top: 1em">There are two
ways to generate overflow notifications.</p>

<p style="margin-left:11%; margin-top: 1em">The first is to
set a <i>wakeup_events</i> or <i>wakeup_watermark</i> value
that will trigger if a certain number of samples or bytes
have been written to the mmap ring buffer. In this case,
<b>POLL_IN</b> is indicated.</p>

<p style="margin-left:11%; margin-top: 1em">The other way
is by use of the <b>PERF_EVENT_IOC_REFRESH</b> ioctl. This
ioctl adds to a counter that decrements each time the event
overflows. When nonzero, <b>POLL_IN</b> is indicated, but
once the counter reaches 0 <b>POLL_HUP</b> is indicated and
the underlying event is disabled.</p>

<p style="margin-left:11%; margin-top: 1em">Refreshing an
event group leader refreshes all siblings and refreshing
with a parameter of 0 currently enables infinite refreshes;
these behaviors are unsupported and should not be relied
on.</p>

<p style="margin-left:11%; margin-top: 1em">Starting with
Linux 3.18, <b>POLL_HUP</b> is indicated if the event being
monitored is attached to a different process and that
process exits.</p>

<p style="margin-left:11%; margin-top: 1em"><b>rdpmc
instruction</b> <br>
Starting with Linux 3.4 on x86, you can use the <i>rdpmc</i>
instruction to get low-latency reads without having to enter
the kernel. Note that using <i>rdpmc</i> is not necessarily
faster than other methods for reading event values.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
this can be detected with the <i>cap_usr_rdpmc</i> field in
the mmap page; documentation on how to calculate event
values can be found in that section.</p>

<p style="margin-left:11%; margin-top: 1em">Originally,
when rdpmc support was enabled, any process (not just ones
with an active perf event) could use the rdpmc instruction
to access the counters. Starting with Linux 4.0, rdpmc
support is only allowed if an event is currently enabled in
a process&rsquo;s context. To restore the old behavior,
write the value 2 to <i>/sys/devices/cpu/rdpmc</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>perf_event
ioctl calls</b> <br>
Various ioctls act on <b>perf_event_open</b>() file
descriptors: <b><br>
PERF_EVENT_IOC_ENABLE</b></p>

<p style="margin-left:22%;">This enables the individual
event or event group specified by the file descriptor
argument.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument,
then all events in a group are enabled, even if the event
specified is not the group leader (but see BUGS).</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_DISABLE</b></p>

<p style="margin-left:22%;">This disables the individual
counter or event group specified by the file descriptor
argument.</p>

<p style="margin-left:22%; margin-top: 1em">Enabling or
disabling the leader of a group enables or disables the
entire group; that is, while the group leader is disabled,
none of the counters in the group will count. Enabling or
disabling a member of a group other than the leader affects
only that counter; disabling a non-leader stops that counter
from counting but doesn&rsquo;t affect any other
counter.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument,
then all events in a group are disabled, even if the event
specified is not the group leader (but see BUGS).</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_REFRESH</b></p>

<p style="margin-left:22%;">Non-inherited overflow counters
can use this to enable a counter for a number of overflows
specified by the argument, after which it is disabled.
Subsequent calls of this ioctl add the argument value to the
current count. An overflow notification with <b>POLL_IN</b>
set will happen on each overflow until the count reaches 0;
when that happens a notification with <b>POLL_HUP</b> set is
sent and the event is disabled. Using an argument of 0 is
considered undefined behavior.</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_RESET</b></p>

<p style="margin-left:22%;">Reset the event count specified
by the file descriptor argument to zero. This resets only
the counts; there is no way to reset the multiplexing
<i>time_enabled</i> or <i>time_running</i> values.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument,
then all events in a group are reset, even if the event
specified is not the group leader (but see BUGS).</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_PERIOD</b></p>

<p style="margin-left:22%;">This updates the overflow
period for the event.</p>

<p style="margin-left:22%; margin-top: 1em">Since Linux 3.7
(on ARM) and Linux 3.14 (all other architectures), the new
period takes effect immediately. On older kernels, the new
period did not take effect until after the next
overflow.</p>

<p style="margin-left:22%; margin-top: 1em">The argument is
a pointer to a 64-bit value containing the desired new
period.</p>

<p style="margin-left:22%; margin-top: 1em">Prior to Linux
2.6.36, this ioctl always failed due to a bug in the
kernel.</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_SET_OUTPUT</b></p>

<p style="margin-left:22%;">This tells the kernel to report
event notifications to the specified file descriptor rather
than the default one. The file descriptors must all be on
the same CPU.</p>

<p style="margin-left:22%; margin-top: 1em">The argument
specifies the desired file descriptor, or -1 if output
should be ignored.</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_SET_FILTER</b>
(since Linux 2.6.33)</p>

<p style="margin-left:22%;">This adds an ftrace filter to
this event.</p>

<p style="margin-left:22%; margin-top: 1em">The argument is
a pointer to the desired ftrace filter.</p>

<p style="margin-left:11%;"><b>PERF_EVENT_IOC_ID</b> (since
Linux 3.12)</p>

<p style="margin-left:22%;">This returns the event ID value
for the given event file descriptor.</p>

<p style="margin-left:22%; margin-top: 1em">The argument is
a pointer to a 64-bit unsigned integer to hold the
result.</p>

<p style="margin-left:11%;"><b>PERF_EVENT_IOC_SET_BPF</b>
(since Linux 4.1)</p>

<p style="margin-left:22%;">This allows attaching a
Berkeley Packet Filter (BPF) program to an existing kprobe
tracepoint event. You need <b>CAP_PERFMON</b> (since Linux
5.8) or <b>CAP_SYS_ADMIN</b> privileges to use this
ioctl.</p>

<p style="margin-left:22%; margin-top: 1em">The argument is
a BPF program file descriptor that was created by a previous
<b>bpf</b>(2) system call.</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_PAUSE_OUTPUT</b>
(since Linux 4.7)</p>

<p style="margin-left:22%;">This allows pausing and
resuming the event&rsquo;s ring-buffer. A paused ring-buffer
does not prevent generation of samples, but simply discards
them. The discarded samples are considered lost, and cause a
<b>PERF_RECORD_LOST</b> sample to be generated when
possible. An overflow signal may still be triggered by the
discarded sample even though the ring-buffer remains
empty.</p>

<p style="margin-left:22%; margin-top: 1em">The argument is
an unsigned 32-bit integer. A nonzero value pauses the
ring-buffer, while a zero value resumes the ring-buffer.</p>


<p style="margin-left:11%;"><b>PERF_EVENT_MODIFY_ATTRIBUTES</b>
(since Linux 4.17)</p>

<p style="margin-left:22%;">This allows modifying an
existing event without the overhead of closing and reopening
a new event. Currently this is supported only for breakpoint
events.</p>

<p style="margin-left:22%; margin-top: 1em">The argument is
a pointer to a <i>perf_event_attr</i> structure containing
the updated event settings.</p>


<p style="margin-left:11%;"><b>PERF_EVENT_IOC_QUERY_BPF</b>
(since Linux 4.16)</p>

<p style="margin-left:22%;">This allows querying which
Berkeley Packet Filter (BPF) programs are attached to an
existing kprobe tracepoint. You can only attach one BPF
program per event, but you can have multiple events attached
to a tracepoint. Querying this value on one tracepoint event
returns the ID of all BPF programs in all events attached to
the tracepoint. You need <b>CAP_PERFMON</b> (since Linux
5.8) or <b>CAP_SYS_ADMIN</b> privileges to use this
ioctl.</p>

<p style="margin-left:22%; margin-top: 1em">The argument is
a pointer to a structure</p>

<p style="margin-left:28%;">struct perf_event_query_bpf {
<br>
__u32 ids_len; <br>
__u32 prog_cnt; <br>
__u32 ids[0]; <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>ids_len</i> field indicates the number of ids that can
fit in the provided <i>ids</i> array. The <i>prog_cnt</i>
value is filled in by the kernel with the number of attached
BPF programs. The <i>ids</i> array is filled with the ID of
each attached BPF program. If there are more programs than
will fit in the array, then the kernel will return
<b>ENOSPC</b> and <i>ids_len</i> will indicate the number of
program IDs that were successfully copied.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
prctl(2)</b> <br>
A process can enable or disable all currently open event
groups using the <b>prctl</b>(2)
<b>PR_TASK_PERF_EVENTS_ENABLE</b> and
<b>PR_TASK_PERF_EVENTS_DISABLE</b> operations. This applies
only to events created locally by the calling process. This
does not apply to events created by other processes attached
to the calling process or inherited events from a parent
process. Only group leaders are enabled and disabled, not
any other members of the groups.</p>

<p style="margin-left:11%; margin-top: 1em"><b>perf_event
related configuration files</b> <br>
Files in <i>/proc/sys/kernel/</i></p>


<p style="margin-left:17%;"><i>/proc/sys/kernel/perf_event_paranoid</i></p>

<p style="margin-left:28%;">The <i>perf_event_paranoid</i>
file can be set to restrict access to the performance
counters.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="3%">


<p>2</p></td>
<td width="3%"></td>
<td width="66%">


<p>allow only user-space measurements (default since Linux
4.6).</p> </td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="3%">


<p>1</p></td>
<td width="3%"></td>
<td width="66%">


<p>allow both kernel and user measurements (default before
Linux 4.6).</p></td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="3%">


<p>0</p></td>
<td width="3%"></td>
<td width="66%">


<p>allow access to CPU-specific data but not raw tracepoint
samples.</p> </td></tr>
<tr valign="top" align="left">
<td width="28%"></td>
<td width="3%">


<p>-1</p></td>
<td width="3%"></td>
<td width="66%">


<p>no restrictions.</p></td></tr>
</table>

<p style="margin-left:28%; margin-top: 1em">The existence
of the <i>perf_event_paranoid</i> file is the official
method for determining if a kernel supports
<b>perf_event_open</b>().</p>


<p style="margin-left:17%;"><i>/proc/sys/kernel/perf_event_max_sample_rate</i></p>

<p style="margin-left:28%;">This sets the maximum sample
rate. Setting this too high can allow users to sample at a
rate that impacts overall machine performance and
potentially lock up the machine. The default value is 100000
(samples per second).</p>


<p style="margin-left:17%;"><i>/proc/sys/kernel/perf_event_max_stack</i></p>

<p style="margin-left:28%;">This file sets the maximum
depth of stack frame entries reported when generating a call
trace.</p>


<p style="margin-left:17%;"><i>/proc/sys/kernel/perf_event_mlock_kb</i></p>

<p style="margin-left:28%;">Maximum number of pages an
unprivileged user can <b>mlock</b>(2). The default is 516
(kB).</p>

<p style="margin-left:11%; margin-top: 1em">Files in
<i>/sys/bus/event_source/devices/</i></p>

<p style="margin-left:17%; margin-top: 1em">Since Linux
2.6.34, the kernel supports having multiple PMUs available
for monitoring. Information on how to program these PMUs can
be found under <i>/sys/bus/event_source/devices/</i>. Each
subdirectory corresponds to a different PMU. <i><br>
/sys/bus/event_source/devices/*/type</i> (since Linux
2.6.38)</p>

<p style="margin-left:28%;">This contains an integer that
can be used in the <i>type</i> field of
<i>perf_event_attr</i> to indicate that you wish to use this
PMU.</p>


<p style="margin-left:17%;"><i>/sys/bus/event_source/devices/cpu/rdpmc</i>
(since Linux 3.4)</p>

<p style="margin-left:28%;">If this file is 1, then direct
user-space access to the performance counter registers is
allowed via the rdpmc instruction. This can be disabled by
echoing 0 to the file.</p>

<p style="margin-left:28%; margin-top: 1em">As of Linux 4.0
the behavior has changed, so that 1 now means only allow
access to processes with active perf events, with 2
indicating the old allow-anyone-access behavior.</p>


<p style="margin-left:17%;"><i>/sys/bus/event_source/devices/*/format/</i>
(since Linux 3.4)</p>

<p style="margin-left:28%;">This subdirectory contains
information on the architecture-specific subfields available
for programming the various <i>config</i> fields in the
<i>perf_event_attr</i> struct.</p>

<p style="margin-left:28%; margin-top: 1em">The content of
each file is the name of the config field, followed by a
colon, followed by a series of integer bit ranges separated
by commas. For example, the file <i>event</i> may contain
the value <i>config1:1,6-10,44</i> which indicates that
event is an attribute that occupies bits 1,6&ndash;10, and
44 of <i>perf_event_attr::config1</i>.</p>


<p style="margin-left:17%;"><i>/sys/bus/event_source/devices/*/events/</i>
(since Linux 3.4)</p>

<p style="margin-left:28%;">This subdirectory contains
files with predefined events. The contents are strings
describing the event settings expressed in terms of the
fields found in the previously mentioned <i>./format/</i>
directory. These are not necessarily complete lists of all
events supported by a PMU, but usually a subset of events
deemed useful or interesting.</p>

<p style="margin-left:28%; margin-top: 1em">The content of
each file is a list of attribute names separated by commas.
Each entry has an optional value (either hex or decimal). If
no value is specified, then it is assumed to be a single-bit
field with a value of 1. An example entry may look like
this: <i>event=0x2,inv,ldlat=3</i>.</p>


<p style="margin-left:17%;"><i>/sys/bus/event_source/devices/*/uevent</i></p>

<p style="margin-left:28%;">This file is the standard
kernel device interface for injecting hotplug events.</p>


<p style="margin-left:17%;"><i>/sys/bus/event_source/devices/*/cpumask</i>
(since Linux 3.7)</p>

<p style="margin-left:28%;">The <i>cpumask</i> file
contains a comma-separated list of integers that indicate a
representative CPU number for each socket (package) on the
motherboard. This is needed when setting up uncore or
northbridge events, as those PMUs present socket-wide
events.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>perf_event_open</b>()
returns the new file descriptor, or -1 if an error occurred
(in which case, <i>errno</i> is set appropriately).</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The errors
returned by <b>perf_event_open</b>() can be inconsistent,
and may vary across processor architectures and performance
monitoring units.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>E2BIG</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned if the <i>perf_event_attr size</i> value is too
small (smaller than <b>PERF_ATTR_SIZE_VER0</b>), too big
(larger than the page size), or larger than the kernel
supports and the extra bytes are not zero. When <b>E2BIG</b>
is returned, the <i>perf_event_attr size</i> field is
overwritten by the kernel to be the size of the structure it
was expecting.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned when the requested event requires
<b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b>
permissions (or a more permissive perf_event paranoid
setting). Some common cases where an unprivileged process
may encounter this error: attaching to a process owned by a
different user; monitoring all processes on a given CPU
(i.e., specifying the <i>pid</i> argument as -1); and not
setting <i>exclude_kernel</i> when the paranoid setting
requires it.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned if the <i>group_fd</i> file descriptor is not
valid, or, if <b>PERF_FLAG_PID_CGROUP</b> is set, the cgroup
file descriptor in <i>pid</i> is not valid.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EBUSY</b> (since Linux
4.1)</p>

<p style="margin-left:22%;">Returned if another event
already has exclusive access to the PMU.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned if the <i>attr</i> pointer points at an invalid
memory address.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned if the specified event is invalid. There are
many possible reasons for this. A not-exhaustive list:
<i>sample_freq</i> is higher than the maximum setting; the
<i>cpu</i> to monitor does not exist; <i>read_format</i> is
out of range; <i>sample_type</i> is out of range; the
<i>flags</i> value is out of range; <i>exclusive</i> or
<i>pinned</i> set and the event is not a group leader; the
event <i>config</i> values are out of range or set reserved
bits; the generic event selected is not supported; or there
is not enough room to add the selected event.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned when trying to mix perf and ftrace handling for
a uprobe.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Each opened event uses one file descriptor. If a large
number of events are opened, the per-process limit on the
number of open file descriptors will be reached, and no more
events can be created.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENODEV</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned when the event involves a feature not supported
by the current CPU.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned if the <i>type</i> setting is not valid. This
error is also returned for some unsupported generic
events.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOSPC</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Prior to Linux 3.3, if there was not enough room for the
event, <b>ENOSPC</b> was returned. In Linux 3.3, this was
changed to <b>EINVAL</b>. <b>ENOSPC</b> is still returned if
you try to add more breakpoint events than supported by the
hardware.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOSYS</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Returned if <b>PERF_SAMPLE_STACK_USER</b> is set in
<i>sample_type</i> and it is not supported by hardware.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EOPNOTSUPP</b></p>

<p style="margin-left:22%;">Returned if an event requiring
a specific hardware feature is requested but there is no
hardware support. This includes requesting low-skid events
if not supported, branch tracing if it is not available,
sampling if no PMU interrupt is available, and branch stacks
for software events.</p>

<p style="margin-left:11%;"><b>EOVERFLOW</b> (since Linux
4.8)</p>

<p style="margin-left:22%;">Returned if
<b>PERF_SAMPLE_CALLCHAIN</b> is requested and
<i>sample_max_stack</i> is larger than the maximum specified
in <i>/proc/sys/kernel/perf_event_max_stack</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Returned on many (but not all) architectures when an
unsupported <i>exclude_hv</i>, <i>exclude_idle</i>,
<i>exclude_user</i>, or <i>exclude_kernel</i> setting is
specified.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">It can also
happen, as with <b>EACCES</b>, when the requested event
requires <b>CAP_PERFMON</b> (since Linux 5.8) or
<b>CAP_SYS_ADMIN</b> permissions (or a more permissive
perf_event paranoid setting). This includes setting a
breakpoint on a kernel address, and (since Linux 3.13)
setting a kernel function-trace tracepoint.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>ESRCH</b></p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">Returned if attempting to attach
to a process that does not exist.</p></td></tr>
</table>

<h2>VERSION
<a name="VERSION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>perf_event_open</b>()
was introduced in Linux 2.6.31 but was called
<b>perf_counter_open</b>(). It was renamed in Linux
2.6.32.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This
<b>perf_event_open</b>() system call Linux-specific and
should not be used in programs intended to be portable.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Glibc does not
provide a wrapper for this system call; call it using
<b>syscall</b>(2). See the example below.</p>

<p style="margin-left:11%; margin-top: 1em">The official
way of knowing if <b>perf_event_open</b>() support is
enabled is checking for the existence of the file
<i>/proc/sys/kernel/perf_event_paranoid</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CAP_PERFMON</b>
capability (since Linux 5.8) provides secure approach to
performance monitoring and observability operations in a
system according to the principal of least privilege (POSIX
IEEE 1003.1e). Accessing system performance monitoring and
observability operations using <b>CAP_PERFMON</b> rather
than the much more powerful <b>CAP_SYS_ADMIN</b> excludes
chances to misuse credentials and makes operations more
secure. <b>CAP_SYS_ADMIN</b> usage for secure system
performance monitoring and observability is discouraged in
favor of the <b>CAP_PERFMON</b> capability.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>F_SETOWN_EX</b> option to <b>fcntl</b>(2) is needed to
properly get overflow signals in threads. This was
introduced in Linux 2.6.32.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to Linux
2.6.33 (at least for x86), the kernel did not check if
events could be scheduled together until read time. The same
happens on all known kernels if the NMI watchdog is enabled.
This means to see if a given set of events works you have to
<b>perf_event_open</b>(), start, then read before you know
for sure you can get valid measurements.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to Linux
2.6.34, event constraints were not enforced by the kernel.
In that case, some events would silently return
&quot;0&quot; if the kernel scheduled them in an improper
counter slot.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to Linux
2.6.34, there was a bug when multiplexing where the wrong
results could be returned.</p>

<p style="margin-left:11%; margin-top: 1em">Kernels from
Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if
&quot;inherit&quot; is enabled and many threads are
started.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to Linux
2.6.35, <b>PERF_FORMAT_GROUP</b> did not work with attached
processes.</p>

<p style="margin-left:11%; margin-top: 1em">There is a bug
in the kernel code between Linux 2.6.36 and Linux 3.0 that
ignores the &quot;watermark&quot; field and acts as if a
wakeup_event was chosen if the union has a nonzero value in
it.</p>

<p style="margin-left:11%; margin-top: 1em">From Linux
2.6.31 to Linux 3.4, the <b>PERF_IOC_FLAG_GROUP</b> ioctl
argument was broken and would repeatedly operate on the
event specified rather than iterating across all sibling
events in a group.</p>

<p style="margin-left:11%; margin-top: 1em">From Linux 3.4
to Linux 3.11, the mmap <i>cap_usr_rdpmc</i> and
<i>cap_usr_time</i> bits mapped to the same location. Code
should migrate to the new <i>cap_user_rdpmc</i> and
<i>cap_user_time</i> fields instead.</p>

<p style="margin-left:11%; margin-top: 1em">Always
double-check your results! Various generalized events have
had wrong values. For example, retired branches measured the
wrong thing on AMD machines until Linux 2.6.35.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
is a short example that measures the total instruction count
of a call to <b>printf</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;stdlib.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;sys/ioctl.h&gt; <br>
#include &lt;linux/perf_event.h&gt; <br>
#include &lt;asm/unistd.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">static long
<br>
perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
<br>
int cpu, int group_fd, unsigned long flags) <br>
{ <br>
int ret;</p>

<p style="margin-left:11%; margin-top: 1em">ret =
syscall(__NR_perf_event_open, hw_event, pid, cpu, <br>
group_fd, flags); <br>
return ret; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char **argv) <br>
{ <br>
struct perf_event_attr pe; <br>
long long count; <br>
int fd;</p>


<p style="margin-left:11%; margin-top: 1em">memset(&amp;pe,
0, sizeof(pe)); <br>
pe.type = PERF_TYPE_HARDWARE; <br>
pe.size = sizeof(pe); <br>
pe.config = PERF_COUNT_HW_INSTRUCTIONS; <br>
pe.disabled = 1; <br>
pe.exclude_kernel = 1; <br>
pe.exclude_hv = 1;</p>

<p style="margin-left:11%; margin-top: 1em">fd =
perf_event_open(&amp;pe, 0, -1, -1, 0); <br>
if (fd == -1) { <br>
fprintf(stderr, &quot;Error opening leader %llx\n&quot;,
pe.config); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">ioctl(fd,
PERF_EVENT_IOC_RESET, 0); <br>
ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Measuring
instruction count for this printf\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">ioctl(fd,
PERF_EVENT_IOC_DISABLE, 0); <br>
read(fd, &amp;count, sizeof(count));</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Used
%lld instructions\n&quot;, count);</p>

<p style="margin-left:11%; margin-top: 1em">close(fd); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>perf</b>(1),
<b>fcntl</b>(2), <b>mmap</b>(2), <b>open</b>(2),
<b>prctl</b>(2), <b>read</b>(2)</p>


<p style="margin-left:11%; margin-top: 1em"><i>Documentation/admin-guide/perf-security.rst</i>
in the kernel source tree</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
