<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:06 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SOCKET</title>

</head>
<body>

<h1 align="center">SOCKET</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">socket - create
an endpoint for communication</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/types.h&gt;</b> /* See NOTES */ <b><br>
#include &lt;sys/socket.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
socket(int</b> <i>domain</i><b>, int</b> <i>type</i><b>,
int</b> <i>protocol</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>socket</b>()
creates an endpoint for communication and returns a file
descriptor that refers to that endpoint. The file descriptor
returned by a successful call will be the lowest-numbered
file descriptor not currently open for the process.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>domain</i> argument specifies a communication domain;
this selects the protocol family which will be used for
communication. These families are defined in
<i>&lt;sys/socket.h&gt;</i>. The formats currently
understood by the Linux kernel include:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3267431.png" alt="Image grohtml-3267431.png"></p>

<p style="margin-left:11%; margin-top: 1em">Further details
of the above address families, as well as information on
several other address families, can be found in
<a href="https://man.page/7/address_families">address_families(7)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The socket has
the indicated <i>type</i>, which specifies the communication
semantics. Currently defined types are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_STREAM</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides sequenced, reliable, two-way, connection-based
byte streams. An out-of-band data transmission mechanism may
be supported.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_DGRAM</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Supports datagrams (connectionless, unreliable messages
of a fixed maximum length).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_SEQPACKET</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides a sequenced, reliable, two-way connection-based
data transmission path for datagrams of fixed maximum
length; a consumer is required to read an entire packet with
each input system call.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_RAW</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides raw network protocol access.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_RDM</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides a reliable datagram layer that does not
guarantee ordering.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_PACKET</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Obsolete and should not be used in new programs; see
<a href="https://man.page/7/packet">packet(7)</a>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Some socket
types may not be implemented by all protocol families.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
2.6.27, the <i>type</i> argument serves a second purpose: in
addition to specifying a socket type, it may include the
bitwise OR of any of the following values, to modify the
behavior of <b>socket</b>():</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p style="margin-top: 1em"><b>SOCK_NONBLOCK</b></p></td>
<td width="4%"></td>
<td width="65%">


<p style="margin-top: 1em">Set the <b>O_NONBLOCK</b> file
status flag on the open file description (see
<a href="https://man.page/2/open">open(2)</a>) referred to by the new file descriptor.
Using this flag saves extra calls to <a href="https://man.page/2/fcntl">fcntl(2)</a> to
achieve the same result.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>SOCK_CLOEXEC</b></p></td>
<td width="4%"></td>
<td width="65%">


<p>Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the
new file descriptor. See the description of the
<b>O_CLOEXEC</b> flag in <a href="https://man.page/2/open">open(2)</a> for reasons why this
may be useful.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>protocol</i> specifies a particular protocol to be used
with the socket. Normally only a single protocol exists to
support a particular socket type within a given protocol
family, in which case <i>protocol</i> can be specified as 0.
However, it is possible that many protocols may exist, in
which case a particular protocol must be specified in this
manner. The protocol number to use is specific to the
&ldquo;communication domain&rdquo; in which communication is
to take place; see <a href="https://man.page/5/protocols">protocols(5)</a>. See
<a href="https://man.page/3/getprotoent">getprotoent(3)</a> on how to map protocol name strings to
protocol numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Sockets of type
<b>SOCK_STREAM</b> are full-duplex byte streams. They do not
preserve record boundaries. A stream socket must be in a
<i>connected</i> state before any data may be sent or
received on it. A connection to another socket is created
with a <a href="https://man.page/2/connect">connect(2)</a> call. Once connected, data may be
transferred using <a href="https://man.page/2/read">read(2)</a> and <a href="https://man.page/2/write">write(2)</a> calls
or some variant of the <a href="https://man.page/2/send">send(2)</a> and <a href="https://man.page/2/recv">recv(2)</a>
calls. When a session has been completed a <a href="https://man.page/2/close">close(2)</a>
may be performed. Out-of-band data may also be transmitted
as described in <a href="https://man.page/2/send">send(2)</a> and received as described in
<a href="https://man.page/2/recv">recv(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The
communications protocols which implement a
<b>SOCK_STREAM</b> ensure that data is not lost or
duplicated. If a piece of data for which the peer protocol
has buffer space cannot be successfully transmitted within a
reasonable length of time, then the connection is considered
to be dead. When <b>SO_KEEPALIVE</b> is enabled on the
socket the protocol checks in a protocol-specific manner if
the other end is still alive. A <b>SIGPIPE</b> signal is
raised if a process sends or receives on a broken stream;
this causes naive processes, which do not handle the signal,
to exit. <b>SOCK_SEQPACKET</b> sockets employ the same
system calls as <b>SOCK_STREAM</b> sockets. The only
difference is that <a href="https://man.page/2/read">read(2)</a> calls will return only the
amount of data requested, and any data remaining in the
arriving packet will be discarded. Also all message
boundaries in incoming datagrams are preserved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SOCK_DGRAM</b>
and <b>SOCK_RAW</b> sockets allow sending of datagrams to
correspondents named in <a href="https://man.page/2/sendto">sendto(2)</a> calls. Datagrams
are generally received with <a href="https://man.page/2/recvfrom">recvfrom(2)</a>, which
returns the next datagram along with the address of its
sender.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SOCK_PACKET</b>
is an obsolete socket type to receive raw packets directly
from the device driver. Use <a href="https://man.page/7/packet">packet(7)</a> instead.</p>

<p style="margin-left:11%; margin-top: 1em">An
<a href="https://man.page/2/fcntl">fcntl(2)</a> <b>F_SETOWN</b> operation can be used to
specify a process or process group to receive a
<b>SIGURG</b> signal when the out-of-band data arrives or
<b>SIGPIPE</b> signal when a <b>SOCK_STREAM</b> connection
breaks unexpectedly. This operation may also be used to set
the process or process group that receives the I/O and
asynchronous notification of I/O events via <b>SIGIO</b>.
Using <b>F_SETOWN</b> is equivalent to an <a href="https://man.page/2/ioctl">ioctl(2)</a>
call with the <b>FIOSETOWN</b> or <b>SIOCSPGRP</b>
argument.</p>

<p style="margin-left:11%; margin-top: 1em">When the
network signals an error condition to the protocol module
(e.g., using an ICMP message for IP) the pending error flag
is set for the socket. The next operation on this socket
will return the error code of the pending error. For some
protocols it is possible to enable a per-socket error queue
to retrieve detailed information about the error; see
<b>IP_RECVERR</b> in <a href="https://man.page/7/ip">ip(7)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The operation
of sockets is controlled by socket level <i>options</i>.
These options are defined in <i>&lt;sys/socket.h&gt;</i>.
The functions <a href="https://man.page/2/setsockopt">setsockopt(2)</a> and <a href="https://man.page/2/getsockopt">getsockopt(2)</a>
are used to set and get options.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success, a
file descriptor for the new socket is returned. On error, -1
is returned, and <i>errno</i> is set appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Permission to create a socket of
the specified type and/or protocol is denied.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAFNOSUPPORT</b></p>

<p style="margin-left:22%;">The implementation does not
support the specified address family.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Unknown protocol, or protocol family not available.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Invalid flags in <i>type</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The per-process limit on the number of open file
descriptors has been reached.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The system-wide limit on the total number of open files
has been reached.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENOBUFS</b> or
<b>ENOMEM</b></p>

<p style="margin-left:22%;">Insufficient memory is
available. The socket cannot be created until sufficient
resources are freed.</p>

<p style="margin-left:11%;"><b>EPROTONOSUPPORT</b></p>

<p style="margin-left:22%;">The protocol type or the
specified protocol is not supported within this domain.</p>

<p style="margin-left:11%; margin-top: 1em">Other errors
may be generated by the underlying protocol modules.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1-2001,
POSIX.1-2008, 4.4BSD.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>SOCK_NONBLOCK</b> and <b>SOCK_CLOEXEC</b> flags are
Linux-specific.</p>


<p style="margin-left:11%; margin-top: 1em"><b>socket</b>()
appeared in 4.2BSD. It is generally portable to/from non-BSD
systems supporting clones of the BSD socket layer (including
System&nbsp;V variants).</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1 does
not require the inclusion of <i>&lt;sys/types.h&gt;</i>, and
this header file is not required on Linux. However, some
historical (BSD) implementations required this header file,
and portable applications are probably wise to include
it.</p>

<p style="margin-left:11%; margin-top: 1em">The manifest
constants used under 4.x BSD for protocol families are
<b>PF_UNIX</b>, <b>PF_INET</b>, and so on, while
<b>AF_UNIX</b>, <b>AF_INET</b>, and so on are used for
address families. However, already the BSD man page
promises: &quot;The protocol family generally is the same as
the address family&quot;, and subsequent standards use AF_*
everywhere.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An example of
the use of <b>socket</b>() is shown in
<a href="https://man.page/3/getaddrinfo">getaddrinfo(3)</a>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/accept">accept(2)</a>,
<a href="https://man.page/2/bind">bind(2)</a>, <a href="https://man.page/2/close">close(2)</a>, <a href="https://man.page/2/connect">connect(2)</a>,
<a href="https://man.page/2/fcntl">fcntl(2)</a>, <a href="https://man.page/2/getpeername">getpeername(2)</a>,
<a href="https://man.page/2/getsockname">getsockname(2)</a>, <a href="https://man.page/2/getsockopt">getsockopt(2)</a>,
<a href="https://man.page/2/ioctl">ioctl(2)</a>, <a href="https://man.page/2/listen">listen(2)</a>, <a href="https://man.page/2/read">read(2)</a>,
<a href="https://man.page/2/recv">recv(2)</a>, <a href="https://man.page/2/select">select(2)</a>, <a href="https://man.page/2/send">send(2)</a>,
<a href="https://man.page/2/shutdown">shutdown(2)</a>, <a href="https://man.page/2/socketpair">socketpair(2)</a>, <a href="https://man.page/2/write">write(2)</a>,
<a href="https://man.page/3/getprotoent">getprotoent(3)</a>, <a href="https://man.page/7/address_families">address_families(7)</a>,
<a href="https://man.page/7/ip">ip(7)</a>, <a href="https://man.page/7/socket">socket(7)</a>, <a href="https://man.page/7/tcp">tcp(7)</a>,
<a href="https://man.page/7/udp">udp(7)</a>, <a href="https://man.page/7/unix">unix(7)</a></p>

<p style="margin-left:11%; margin-top: 1em">&ldquo;An
Introductory 4.3BSD Interprocess Communication
Tutorial&rdquo; and &ldquo;BSD Interprocess Communication
Tutorial&rdquo;, reprinted in <i>UNIX Programmer&rsquo;s
Supplementary Documents Volume 1.</i></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
