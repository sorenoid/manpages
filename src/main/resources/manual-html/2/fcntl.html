<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:04 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FCNTL</title>

</head>
<body>

<h1 align="center">FCNTL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">fcntl -
manipulate file descriptor</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;unistd.h&gt; <br>
#include &lt;fcntl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
fcntl(int</b> <i>fd</i><b>, int</b> <i>cmd</i><b>, ...
/*</b> <i>arg</i> <b>*/ );</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>fcntl</b>()
performs one of the operations described below on the open
file descriptor <i>fd</i>. The operation is determined by
<i>cmd</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>fcntl</b>()
can take an optional third argument. Whether or not this
argument is required is determined by <i>cmd</i>. The
required argument type is indicated in parentheses after
each <i>cmd</i> name (in most cases, the required type is
<i>int</i>, and we identify the argument using the name
<i>arg</i>), or <i>void</i> is specified if the argument is
not required.</p>

<p style="margin-left:11%; margin-top: 1em">Certain of the
operations below are supported only since a particular Linux
kernel version. The preferred method of checking whether the
host kernel supports a particular operation is to invoke
<b>fcntl</b>() with the desired <i>cmd</i> value and then
test whether the call failed with <b>EINVAL</b>, indicating
that the kernel does not recognize this value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Duplicating
a file descriptor <br>
F_DUPFD</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Duplicate the file descriptor
<i>fd</i> using the lowest-numbered available file
descriptor greater than or equal to <i>arg</i>. This is
different from <a href="https://man.page/2/dup2">dup2(2)</a>, which uses exactly the file
descriptor specified.</p>

<p style="margin-left:22%; margin-top: 1em">On success, the
new file descriptor is returned.</p>

<p style="margin-left:22%; margin-top: 1em">See
<a href="https://man.page/2/dup">dup(2)</a> for further details.</p>

<p style="margin-left:11%;"><b>F_DUPFD_CLOEXEC</b>
(<i>int</i>; since Linux 2.6.24)</p>

<p style="margin-left:22%;">As for <b>F_DUPFD</b>, but
additionally set the close-on-exec flag for the duplicate
file descriptor. Specifying this flag permits a program to
avoid an additional <b>fcntl</b>() <b>F_SETFD</b> operation
to set the <b>FD_CLOEXEC</b> flag. For an explanation of why
this flag is useful, see the description of <b>O_CLOEXEC</b>
in <a href="https://man.page/2/open">open(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
descriptor flags</b> <br>
The following commands manipulate the flags associated with
a file descriptor. Currently, only one such flag is defined:
<b>FD_CLOEXEC</b>, the close-on-exec flag. If the
<b>FD_CLOEXEC</b> bit is set, the file descriptor will
automatically be closed during a successful
<a href="https://man.page/2/execve">execve(2)</a>. (If the <a href="https://man.page/2/execve">execve(2)</a> fails, the file
descriptor is left open.) If the <b>FD_CLOEXEC</b> bit is
not set, the file descriptor will remain open across an
<a href="https://man.page/2/execve">execve(2)</a>. <b><br>
F_GETFD</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Return (as the function result)
the file descriptor flags; <i>arg</i> is ignored.</p>

<p style="margin-left:11%;"><b>F_SETFD</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Set the file descriptor flags
to the value specified by <i>arg</i>.</p>

<p style="margin-left:11%; margin-top: 1em">In
multithreaded programs, using <b>fcntl</b>() <b>F_SETFD</b>
to set the close-on-exec flag at the same time as another
thread performs a <a href="https://man.page/2/fork">fork(2)</a> plus <a href="https://man.page/2/execve">execve(2)</a> is
vulnerable to a race condition that may unintentionally leak
the file descriptor to the program executed in the child
process. See the discussion of the <b>O_CLOEXEC</b> flag in
<a href="https://man.page/2/open">open(2)</a> for details and a remedy to the problem.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File status
flags</b> <br>
Each open file description has certain associated status
flags, initialized by <a href="https://man.page/2/open">open(2)</a> and possibly modified
by <b>fcntl</b>(). Duplicated file descriptors (made with
<a href="https://man.page/2/dup">dup(2)</a>, <b>fcntl</b>(F_DUPFD), <a href="https://man.page/2/fork">fork(2)</a>, etc.)
refer to the same open file description, and thus share the
same file status flags.</p>

<p style="margin-left:11%; margin-top: 1em">The file status
flags and their semantics are described in <a href="https://man.page/2/open">open(2)</a>.
<b><br>
F_GETFL</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Return (as the function result)
the file access mode and the file status flags; <i>arg</i>
is ignored.</p>

<p style="margin-left:11%;"><b>F_SETFL</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Set the file status flags to
the value specified by <i>arg</i>. File access mode
(<b>O_RDONLY</b>, <b>O_WRONLY</b>, <b>O_RDWR</b>) and file
creation flags (i.e., <b>O_CREAT</b>, <b>O_EXCL</b>,
<b>O_NOCTTY</b>, <b>O_TRUNC</b>) in <i>arg</i> are ignored.
On Linux, this command can change only the <b>O_APPEND</b>,
<b>O_ASYNC</b>, <b>O_DIRECT</b>, <b>O_NOATIME</b>, and
<b>O_NONBLOCK</b> flags. It is not possible to change the
<b>O_DSYNC</b> and <b>O_SYNC</b> flags; see BUGS, below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Advisory
record locking</b> <br>
Linux implements traditional
(&quot;process-associated&quot;) UNIX record locks, as
standardized by POSIX. For a Linux-specific alternative with
better semantics, see the discussion of open file
description locks below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_SETLK</b>,
<b>F_SETLKW</b>, and <b>F_GETLK</b> are used to acquire,
release, and test for the existence of record locks (also
known as byte-range, file-segment, or file-region locks).
The third argument, <i>lock</i>, is a pointer to a structure
that has at least the following fields (in unspecified
order).</p>

<p style="margin-left:17%; margin-top: 1em">struct flock {
<br>
... <br>
short l_type; /* Type of lock: F_RDLCK, <br>
F_WRLCK, F_UNLCK */ <br>
short l_whence; /* How to interpret l_start: <br>
SEEK_SET, SEEK_CUR, SEEK_END */ <br>
off_t l_start; /* Starting offset for lock */ <br>
off_t l_len; /* Number of bytes to lock */ <br>
pid_t l_pid; /* PID of process blocking our lock <br>
(set by F_GETLK and F_OFD_GETLK) */ <br>
... <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of
this structure specify the range of bytes we wish to lock.
Bytes past the end of the file may be locked, but not bytes
before the start of the file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>l_start</i>
is the starting offset for the lock, and is interpreted
relative to either: the start of the file (if
<i>l_whence</i> is <b>SEEK_SET</b>); the current file offset
(if <i>l_whence</i> is <b>SEEK_CUR</b>); or the end of the
file (if <i>l_whence</i> is <b>SEEK_END</b>). In the final
two cases, <i>l_start</i> can be a negative number provided
the offset does not lie before the start of the file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>l_len</i>
specifies the number of bytes to be locked. If <i>l_len</i>
is positive, then the range to be locked covers bytes
<i>l_start</i> up to and including
<i>l_start</i>+<i>l_len</i>-1. Specifying 0 for <i>l_len</i>
has the special meaning: lock all bytes starting at the
location specified by <i>l_whence</i> and <i>l_start</i>
through to the end of file, no matter how large the file
grows.</p>

<p style="margin-left:11%; margin-top: 1em">POSIX.1-2001
allows (but does not require) an implementation to support a
negative <i>l_len</i> value; if <i>l_len</i> is negative,
the interval described by <i>lock</i> covers bytes
<i>l_start</i>+<i>l_len</i> up to and including
<i>l_start</i>-1. This is supported by Linux since kernel
versions 2.4.21 and 2.5.49.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>l_type</i> field can be used to place a read
(<b>F_RDLCK</b>) or a write (<b>F_WRLCK</b>) lock on a file.
Any number of processes may hold a read lock (shared lock)
on a file region, but only one process may hold a write lock
(exclusive lock). An exclusive lock excludes all other
locks, both shared and exclusive. A single process can hold
only one type of lock on a file region; if a new lock is
applied to an already-locked region, then the existing lock
is converted to the new lock type. (Such conversions may
involve splitting, shrinking, or coalescing with an existing
lock if the byte range specified by the new lock does not
precisely coincide with the range of the existing lock.)
<b><br>
F_SETLK</b> (<i>struct flock *</i>)</p>

<p style="margin-left:22%;">Acquire a lock (when
<i>l_type</i> is <b>F_RDLCK</b> or <b>F_WRLCK</b>) or
release a lock (when <i>l_type</i> is <b>F_UNLCK</b>) on the
bytes specified by the <i>l_whence</i>, <i>l_start</i>, and
<i>l_len</i> fields of <i>lock</i>. If a conflicting lock is
held by another process, this call returns -1 and sets
<i>errno</i> to <b>EACCES</b> or <b>EAGAIN</b>. (The error
returned in this case differs across implementations, so
POSIX requires a portable application to check for both
errors.)</p>

<p style="margin-left:11%;"><b>F_SETLKW</b> (<i>struct
flock *</i>)</p>

<p style="margin-left:22%;">As for <b>F_SETLK</b>, but if a
conflicting lock is held on the file, then wait for that
lock to be released. If a signal is caught while waiting,
then the call is interrupted and (after the signal handler
has returned) returns immediately (with return value -1 and
<i>errno</i> set to <b>EINTR</b>; see <a href="https://man.page/7/signal">signal(7)</a>).</p>

<p style="margin-left:11%;"><b>F_GETLK</b> (<i>struct flock
*</i>)</p>

<p style="margin-left:22%;">On input to this call,
<i>lock</i> describes a lock we would like to place on the
file. If the lock could be placed, <b>fcntl</b>() does not
actually place it, but returns <b>F_UNLCK</b> in the
<i>l_type</i> field of <i>lock</i> and leaves the other
fields of the structure unchanged.</p>

<p style="margin-left:22%; margin-top: 1em">If one or more
incompatible locks would prevent this lock being placed,
then <b>fcntl</b>() returns details about one of those locks
in the <i>l_type</i>, <i>l_whence</i>, <i>l_start</i>, and
<i>l_len</i> fields of <i>lock</i>. If the conflicting lock
is a traditional (process-associated) record lock, then the
<i>l_pid</i> field is set to the PID of the process holding
that lock. If the conflicting lock is an open file
description lock, then <i>l_pid</i> is set to -1. Note that
the returned information may already be out of date by the
time the caller inspects it.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
place a read lock, <i>fd</i> must be open for reading. In
order to place a write lock, <i>fd</i> must be open for
writing. To place both types of lock, open a file
read-write.</p>

<p style="margin-left:11%; margin-top: 1em">When placing
locks with <b>F_SETLKW</b>, the kernel detects
<i>deadlocks</i>, whereby two or more processes have their
lock requests mutually blocked by locks held by the other
processes. For example, suppose process A holds a write lock
on byte 100 of a file, and process B holds a write lock on
byte 200. If each process then attempts to lock the byte
already locked by the other process using <b>F_SETLKW</b>,
then, without deadlock detection, both processes would
remain blocked indefinitely. When the kernel detects such
deadlocks, it causes one of the blocking lock requests to
immediately fail with the error <b>EDEADLK</b>; an
application that encounters such an error should release
some of its locks to allow other applications to proceed
before attempting regain the locks that it requires.
Circular deadlocks involving more than two processes are
also detected. Note, however, that there are limitations to
the kernel&rsquo;s deadlock-detection algorithm; see
BUGS.</p>

<p style="margin-left:11%; margin-top: 1em">As well as
being removed by an explicit <b>F_UNLCK</b>, record locks
are automatically released when the process terminates.</p>

<p style="margin-left:11%; margin-top: 1em">Record locks
are not inherited by a child created via <a href="https://man.page/2/fork">fork(2)</a>, but
are preserved across an <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Because of the
buffering performed by the <a href="https://man.page/3/stdio">stdio(3)</a> library, the use
of record locking with routines in that package should be
avoided; use <a href="https://man.page/2/read">read(2)</a> and <a href="https://man.page/2/write">write(2)</a> instead.</p>

<p style="margin-left:11%; margin-top: 1em">The record
locks described above are associated with the process
(unlike the open file description locks described below).
This has some unfortunate consequences:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If a process closes <i>any</i> file descriptor referring
to a file, then all of the process&rsquo;s locks on that
file are released, regardless of the file descriptor(s) on
which the locks were obtained. This is bad: it means that a
process can lose its locks on a file such as
<i>/etc/passwd</i> or <i>/etc/mtab</i> when for some reason
a library function decides to open, read, and close the same
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The threads in a process share locks. In other words, a
multithreaded program can&rsquo;t use record locking to
ensure that threads don&rsquo;t simultaneously access the
same region of a file.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Open file
description locks solve both of these problems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Open file
description locks (non-POSIX)</b> <br>
Open file description locks are advisory byte-range locks
whose operation is in most respects identical to the
traditional record locks described above. This lock type is
Linux-specific, and available since Linux 3.15. (There is a
proposal with the Austin Group to include this lock type in
the next revision of POSIX.1.) For an explanation of open
file descriptions, see <a href="https://man.page/2/open">open(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The principal
difference between the two lock types is that whereas
traditional record locks are associated with a process, open
file description locks are associated with the open file
description on which they are acquired, much like locks
acquired with <a href="https://man.page/2/flock">flock(2)</a>. Consequently (and unlike
traditional advisory record locks), open file description
locks are inherited across <a href="https://man.page/2/fork">fork(2)</a> (and
<a href="https://man.page/2/clone">clone(2)</a> with <b>CLONE_FILES</b>), and are only
automatically released on the last close of the open file
description, instead of being released on any close of the
file.</p>

<p style="margin-left:11%; margin-top: 1em">Conflicting
lock combinations (i.e., a read lock and a write lock or two
write locks) where one lock is an open file description lock
and the other is a traditional record lock conflict even
when they are acquired by the same process on the same file
descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">Open file
description locks placed via the same open file description
(i.e., via the same file descriptor, or via a duplicate of
the file descriptor created by <a href="https://man.page/2/fork">fork(2)</a>,
<a href="https://man.page/2/dup">dup(2)</a>, <b>fcntl</b>() <b>F_DUPFD</b>, and so on) are
always compatible: if a new lock is placed on an already
locked region, then the existing lock is converted to the
new lock type. (Such conversions may result in splitting,
shrinking, or coalescing with an existing lock as discussed
above.)</p>

<p style="margin-left:11%; margin-top: 1em">On the other
hand, open file description locks may conflict with each
other when they are acquired via different open file
descriptions. Thus, the threads in a multithreaded program
can use open file description locks to synchronize access to
a file region by having each thread perform its own
<a href="https://man.page/2/open">open(2)</a> on the file and applying locks via the
resulting file descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">As with
traditional advisory locks, the third argument to
<b>fcntl</b>(), <i>lock</i>, is a pointer to an <i>flock</i>
structure. By contrast with traditional record locks, the
<i>l_pid</i> field of that structure must be set to zero
when using the commands described below.</p>

<p style="margin-left:11%; margin-top: 1em">The commands
for working with open file description locks are analogous
to those used with traditional locks: <b><br>
F_OFD_SETLK</b> (<i>struct flock *</i>)</p>

<p style="margin-left:22%;">Acquire an open file
description lock (when <i>l_type</i> is <b>F_RDLCK</b> or
<b>F_WRLCK</b>) or release an open file description lock
(when <i>l_type</i> is <b>F_UNLCK</b>) on the bytes
specified by the <i>l_whence</i>, <i>l_start</i>, and
<i>l_len</i> fields of <i>lock</i>. If a conflicting lock is
held by another process, this call returns -1 and sets
<i>errno</i> to <b>EAGAIN</b>.</p>

<p style="margin-left:11%;"><b>F_OFD_SETLKW</b> (<i>struct
flock *</i>)</p>

<p style="margin-left:22%;">As for <b>F_OFD_SETLK</b>, but
if a conflicting lock is held on the file, then wait for
that lock to be released. If a signal is caught while
waiting, then the call is interrupted and (after the signal
handler has returned) returns immediately (with return value
-1 and <i>errno</i> set to <b>EINTR</b>; see
<a href="https://man.page/7/signal">signal(7)</a>).</p>

<p style="margin-left:11%;"><b>F_OFD_GETLK</b> (<i>struct
flock *</i>)</p>

<p style="margin-left:22%;">On input to this call,
<i>lock</i> describes an open file description lock we would
like to place on the file. If the lock could be placed,
<b>fcntl</b>() does not actually place it, but returns
<b>F_UNLCK</b> in the <i>l_type</i> field of <i>lock</i> and
leaves the other fields of the structure unchanged. If one
or more incompatible locks would prevent this lock being
placed, then details about one of these locks are returned
via <i>lock</i>, as described above for <b>F_GETLK</b>.</p>

<p style="margin-left:11%; margin-top: 1em">In the current
implementation, no deadlock detection is performed for open
file description locks. (This contrasts with
process-associated record locks, for which the kernel does
perform deadlock detection.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mandatory
locking</b> <i><br>
Warning</i>: the Linux implementation of mandatory locking
is unreliable. See BUGS below. Because of these bugs, and
the fact that the feature is believed to be little used,
since Linux 4.5, mandatory locking has been made an optional
feature, governed by a configuration option
(<b>CONFIG_MANDATORY_FILE_LOCKING</b>). This is an initial
step toward removing this feature completely.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
both traditional (process-associated) and open file
description record locks are advisory. Advisory locks are
not enforced and are useful only between cooperating
processes.</p>

<p style="margin-left:11%; margin-top: 1em">Both lock types
can also be mandatory. Mandatory locks are enforced for all
processes. If a process tries to perform an incompatible
access (e.g., <a href="https://man.page/2/read">read(2)</a> or <a href="https://man.page/2/write">write(2)</a>) on a file
region that has an incompatible mandatory lock, then the
result depends upon whether the <b>O_NONBLOCK</b> flag is
enabled for its open file description. If the
<b>O_NONBLOCK</b> flag is not enabled, then the system call
is blocked until the lock is removed or converted to a mode
that is compatible with the access. If the <b>O_NONBLOCK</b>
flag is enabled, then the system call fails with the error
<b>EAGAIN</b>.</p>

<p style="margin-left:11%; margin-top: 1em">To make use of
mandatory locks, mandatory locking must be enabled both on
the filesystem that contains the file to be locked, and on
the file itself. Mandatory locking is enabled on a
filesystem using the &quot;-o mand&quot; option to
<b>mount</b>(8), or the <b>MS_MANDLOCK</b> flag for
<a href="https://man.page/2/mount">mount(2)</a>. Mandatory locking is enabled on a file by
disabling group execute permission on the file and enabling
the set-group-ID permission bit (see <a href="https://man.page/1/chmod">chmod(1)</a> and
<a href="https://man.page/2/chmod">chmod(2)</a>).</p>

<p style="margin-left:11%; margin-top: 1em">Mandatory
locking is not specified by POSIX. Some other systems also
support mandatory locking, although the details of how to
enable it vary across systems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Lost
locks</b> <br>
When an advisory lock is obtained on a networked filesystem
such as NFS it is possible that the lock might get lost.
This may happen due to administrative action on the server,
or due to a network partition (i.e., loss of network
connectivity with the server) which lasts long enough for
the server to assume that the client is no longer
functioning.</p>

<p style="margin-left:11%; margin-top: 1em">When the
filesystem determines that a lock has been lost, future
<a href="https://man.page/2/read">read(2)</a> or <a href="https://man.page/2/write">write(2)</a> requests may fail with the
error <b>EIO</b>. This error will persist until the lock is
removed or the file descriptor is closed. Since Linux 3.12,
this happens at least for NFSv4 (including all minor
versions).</p>

<p style="margin-left:11%; margin-top: 1em">Some versions
of UNIX send a signal (<b>SIGLOST</b>) in this circumstance.
Linux does not define this signal, and does not provide any
asynchronous notification of lost locks.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Managing
signals <br>
F_GETOWN</b>, <b>F_SETOWN</b>, <b>F_GETOWN_EX</b>,
<b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and <b>F_SETSIG</b> are
used to manage I/O availability signals: <b><br>
F_GETOWN</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Return (as the function result)
the process ID or process group ID currently receiving
<b>SIGIO</b> and <b>SIGURG</b> signals for events on file
descriptor <i>fd</i>. Process IDs are returned as positive
values; process group IDs are returned as negative values
(but see BUGS below). <i>arg</i> is ignored.</p>

<p style="margin-left:11%;"><b>F_SETOWN</b>
(<i>int</i>)</p>

<p style="margin-left:22%;">Set the process ID or process
group ID that will receive <b>SIGIO</b> and <b>SIGURG</b>
signals for events on the file descriptor <i>fd</i>. The
target process or process group ID is specified in
<i>arg</i>. A process ID is specified as a positive value; a
process group ID is specified as a negative value. Most
commonly, the calling process specifies itself as the owner
(that is, <i>arg</i> is specified as <a href="https://man.page/2/getpid">getpid(2)</a>).</p>

<p style="margin-left:22%; margin-top: 1em">As well as
setting the file descriptor owner, one must also enable
generation of signals on the file descriptor. This is done
by using the <b>fcntl</b>() <b>F_SETFL</b> command to set
the <b>O_ASYNC</b> file status flag on the file descriptor.
Subsequently, a <b>SIGIO</b> signal is sent whenever input
or output becomes possible on the file descriptor. The
<b>fcntl</b>() <b>F_SETSIG</b> command can be used to obtain
delivery of a signal other than <b>SIGIO</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Sending a
signal to the owner process (group) specified by
<b>F_SETOWN</b> is subject to the same permissions checks as
are described for <a href="https://man.page/2/kill">kill(2)</a>, where the sending process
is the one that employs <b>F_SETOWN</b> (but see BUGS
below). If this permission check fails, then the signal is
silently discarded. <i>Note</i>: The <b>F_SETOWN</b>
operation records the caller&rsquo;s credentials at the time
of the <b>fcntl</b>() call, and it is these saved
credentials that are used for the permission checks.</p>

<p style="margin-left:22%; margin-top: 1em">If the file
descriptor <i>fd</i> refers to a socket, <b>F_SETOWN</b>
also selects the recipient of <b>SIGURG</b> signals that are
delivered when out-of-band data arrives on that socket.
(<b>SIGURG</b> is sent in any situation where
<a href="https://man.page/2/select">select(2)</a> would report the socket as having an
&quot;exceptional condition&quot;.)</p>

<p style="margin-left:22%; margin-top: 1em">The following
was true in 2.6.x kernels up to and including kernel
2.6.11:</p>

<p style="margin-left:32%; margin-top: 1em">If a nonzero
value is given to <b>F_SETSIG</b> in a multithreaded process
running with a threading library that supports thread groups
(e.g., NPTL), then a positive value given to <b>F_SETOWN</b>
has a different meaning: instead of being a process ID
identifying a whole process, it is a thread ID identifying a
specific thread within a process. Consequently, it may be
necessary to pass <b>F_SETOWN</b> the result of
<a href="https://man.page/2/gettid">gettid(2)</a> instead of <a href="https://man.page/2/getpid">getpid(2)</a> to get sensible
results when <b>F_SETSIG</b> is used. (In current Linux
threading implementations, a main thread&rsquo;s thread ID
is the same as its process ID. This means that a
single-threaded program can equally use <a href="https://man.page/2/gettid">gettid(2)</a> or
<a href="https://man.page/2/getpid">getpid(2)</a> in this scenario.) Note, however, that the
statements in this paragraph do not apply to the
<b>SIGURG</b> signal generated for out-of-band data on a
socket: this signal is always sent to either a process or a
process group, depending on the value given to
<b>F_SETOWN</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The above
behavior was accidentally dropped in Linux 2.6.12, and
won&rsquo;t be restored. From Linux 2.6.32 onward, use
<b>F_SETOWN_EX</b> to target <b>SIGIO</b> and <b>SIGURG</b>
signals at a particular thread.</p>

<p style="margin-left:11%;"><b>F_GETOWN_EX</b> (<i>struct
f_owner_ex *</i>) (since Linux 2.6.32)</p>

<p style="margin-left:22%;">Return the current file
descriptor owner settings as defined by a previous
<b>F_SETOWN_EX</b> operation. The information is returned in
the structure pointed to by <i>arg</i>, which has the
following form:</p>

<p style="margin-left:28%; margin-top: 1em">struct
f_owner_ex { <br>
int type; <br>
pid_t pid; <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">The <i>type</i>
field will have one of the values <b>F_OWNER_TID</b>,
<b>F_OWNER_PID</b>, or <b>F_OWNER_PGRP</b>. The <i>pid</i>
field is a positive integer representing a thread ID,
process ID, or process group ID. See <b>F_SETOWN_EX</b> for
more details.</p>

<p style="margin-left:11%;"><b>F_SETOWN_EX</b> (<i>struct
f_owner_ex *</i>) (since Linux 2.6.32)</p>

<p style="margin-left:22%;">This operation performs a
similar task to <b>F_SETOWN</b>. It allows the caller to
direct I/O availability signals to a specific thread,
process, or process group. The caller specifies the target
of signals via <i>arg</i>, which is a pointer to a
<i>f_owner_ex</i> structure. The <i>type</i> field has one
of the following values, which define how <i>pid</i> is
interpreted: <b><br>
F_OWNER_TID</b></p>

<p style="margin-left:32%;">Send the signal to the thread
whose thread ID (the value returned by a call to
<a href="https://man.page/2/clone">clone(2)</a> or <a href="https://man.page/2/gettid">gettid(2)</a>) is specified in
<i>pid</i>.</p>

<p style="margin-left:22%;"><b>F_OWNER_PID</b></p>

<p style="margin-left:32%;">Send the signal to the process
whose ID is specified in <i>pid</i>.</p>

<p style="margin-left:22%;"><b>F_OWNER_PGRP</b></p>

<p style="margin-left:32%;">Send the signal to the process
group whose ID is specified in <i>pid</i>. (Note that,
unlike with <b>F_SETOWN</b>, a process group ID is specified
as a positive value here.)</p>

<p style="margin-left:11%;"><b>F_GETSIG</b>
(<i>void</i>)</p>

<p style="margin-left:22%;">Return (as the function result)
the signal sent when input or output becomes possible. A
value of zero means <b>SIGIO</b> is sent. Any other value
(including <b>SIGIO</b>) is the signal sent instead, and in
this case additional info is available to the signal handler
if installed with <b>SA_SIGINFO</b>. <i>arg</i> is
ignored.</p>

<p style="margin-left:11%;"><b>F_SETSIG</b>
(<i>int</i>)</p>

<p style="margin-left:22%;">Set the signal sent when input
or output becomes possible to the value given in <i>arg</i>.
A value of zero means to send the default <b>SIGIO</b>
signal. Any other value (including <b>SIGIO</b>) is the
signal to send instead, and in this case additional info is
available to the signal handler if installed with
<b>SA_SIGINFO</b>.</p>

<p style="margin-left:22%; margin-top: 1em">By using
<b>F_SETSIG</b> with a nonzero value, and setting
<b>SA_SIGINFO</b> for the signal handler (see
<a href="https://man.page/2/sigaction">sigaction(2)</a>), extra information about I/O events is
passed to the handler in a <i>siginfo_t</i> structure. If
the <i>si_code</i> field indicates the source is
<b>SI_SIGIO</b>, the <i>si_fd</i> field gives the file
descriptor associated with the event. Otherwise, there is no
indication which file descriptors are pending, and you
should use the usual mechanisms (<a href="https://man.page/2/select">select(2)</a>,
<a href="https://man.page/2/poll">poll(2)</a>, <a href="https://man.page/2/read">read(2)</a> with <b>O_NONBLOCK</b> set
etc.) to determine which file descriptors are available for
I/O.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
file descriptor provided in <i>si_fd</i> is the one that was
specified during the <b>F_SETSIG</b> operation. This can
lead to an unusual corner case. If the file descriptor is
duplicated (<a href="https://man.page/2/dup">dup(2)</a> or similar), and the original file
descriptor is closed, then I/O events will continue to be
generated, but the <i>si_fd</i> field will contain the
number of the now closed file descriptor.</p>

<p style="margin-left:22%; margin-top: 1em">By selecting a
real time signal (value &gt;= <b>SIGRTMIN</b>), multiple I/O
events may be queued using the same signal numbers. (Queuing
is dependent on available memory.) Extra information is
available if <b>SA_SIGINFO</b> is set for the signal
handler, as above.</p>

<p style="margin-left:22%; margin-top: 1em">Note that Linux
imposes a limit on the number of real-time signals that may
be queued to a process (see <a href="https://man.page/2/getrlimit">getrlimit(2)</a> and
<a href="https://man.page/7/signal">signal(7)</a>) and if this limit is reached, then the
kernel reverts to delivering <b>SIGIO</b>, and this signal
is delivered to the entire process rather than to a specific
thread.</p>

<p style="margin-left:11%; margin-top: 1em">Using these
mechanisms, a program can implement fully asynchronous I/O
without using <a href="https://man.page/2/select">select(2)</a> or <a href="https://man.page/2/poll">poll(2)</a> most of the
time.</p>

<p style="margin-left:11%; margin-top: 1em">The use of
<b>O_ASYNC</b> is specific to BSD and Linux. The only use of
<b>F_GETOWN</b> and <b>F_SETOWN</b> specified in POSIX.1 is
in conjunction with the use of the <b>SIGURG</b> signal on
sockets. (POSIX does not specify the <b>SIGIO</b> signal.)
<b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and
<b>F_SETSIG</b> are Linux-specific. POSIX has asynchronous
I/O and the <i>aio_sigevent</i> structure to achieve similar
things; these are also available in Linux as part of the GNU
C Library (Glibc).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Leases <br>
F_SETLEASE</b> and <b>F_GETLEASE</b> (Linux 2.4 onward) are
used to establish a new lease, and retrieve the current
lease, on the open file description referred to by the file
descriptor <i>fd</i>. A file lease provides a mechanism
whereby the process holding the lease (the &quot;lease
holder&quot;) is notified (via delivery of a signal) when a
process (the &quot;lease breaker&quot;) tries to
<a href="https://man.page/2/open">open(2)</a> or <a href="https://man.page/2/truncate">truncate(2)</a> the file referred to by
that file descriptor. <b><br>
F_SETLEASE</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Set or remove a file lease
according to which of the following values is specified in
the integer <i>arg</i>: <b><br>
F_RDLCK</b></p>

<p style="margin-left:32%;">Take out a read lease. This
will cause the calling process to be notified when the file
is opened for writing or is truncated. A read lease can be
placed only on a file descriptor that is opened
read-only.</p>

<p style="margin-left:22%;"><b>F_WRLCK</b></p>

<p style="margin-left:32%;">Take out a write lease. This
will cause the caller to be notified when the file is opened
for reading or writing or is truncated. A write lease may be
placed on a file only if there are no other open file
descriptors for the file.</p>

<p style="margin-left:22%;"><b>F_UNLCK</b></p>

<p style="margin-left:32%;">Remove our lease from the
file.</p>

<p style="margin-left:11%; margin-top: 1em">Leases are
associated with an open file description (see
<a href="https://man.page/2/open">open(2)</a>). This means that duplicate file descriptors
(created by, for example, <a href="https://man.page/2/fork">fork(2)</a> or <a href="https://man.page/2/dup">dup(2)</a>)
refer to the same lease, and this lease may be modified or
released using any of these descriptors. Furthermore, the
lease is released by either an explicit <b>F_UNLCK</b>
operation on any of these duplicate file descriptors, or
when all such file descriptors have been closed.</p>

<p style="margin-left:11%; margin-top: 1em">Leases may be
taken out only on regular files. An unprivileged process may
take out a lease only on a file whose UID (owner) matches
the filesystem UID of the process. A process with the
<b>CAP_LEASE</b> capability may take out leases on arbitrary
files. <b><br>
F_GETLEASE</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Indicates what type of lease is
associated with the file descriptor <i>fd</i> by returning
either <b>F_RDLCK</b>, <b>F_WRLCK</b>, or <b>F_UNLCK</b>,
indicating, respectively, a read lease , a write lease, or
no lease. <i>arg</i> is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">When a process
(the &quot;lease breaker&quot;) performs an <a href="https://man.page/2/open">open(2)</a>
or <a href="https://man.page/2/truncate">truncate(2)</a> that conflicts with a lease
established via <b>F_SETLEASE</b>, the system call is
blocked by the kernel and the kernel notifies the lease
holder by sending it a signal (<b>SIGIO</b> by default). The
lease holder should respond to receipt of this signal by
doing whatever cleanup is required in preparation for the
file to be accessed by another process (e.g., flushing
cached buffers) and then either remove or downgrade its
lease. A lease is removed by performing an <b>F_SETLEASE</b>
command specifying <i>arg</i> as <b>F_UNLCK</b>. If the
lease holder currently holds a write lease on the file, and
the lease breaker is opening the file for reading, then it
is sufficient for the lease holder to downgrade the lease to
a read lease. This is done by performing an
<b>F_SETLEASE</b> command specifying <i>arg</i> as
<b>F_RDLCK</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If the lease
holder fails to downgrade or remove the lease within the
number of seconds specified in
<i>/proc/sys/fs/lease-break-time</i>, then the kernel
forcibly removes or downgrades the lease holder&rsquo;s
lease.</p>

<p style="margin-left:11%; margin-top: 1em">Once a lease
break has been initiated, <b>F_GETLEASE</b> returns the
target lease type (either <b>F_RDLCK</b> or <b>F_UNLCK</b>,
depending on what would be compatible with the lease
breaker) until the lease holder voluntarily downgrades or
removes the lease or the kernel forcibly does so after the
lease break timer expires.</p>

<p style="margin-left:11%; margin-top: 1em">Once the lease
has been voluntarily or forcibly removed or downgraded, and
assuming the lease breaker has not unblocked its system
call, the kernel permits the lease breaker&rsquo;s system
call to proceed.</p>

<p style="margin-left:11%; margin-top: 1em">If the lease
breaker&rsquo;s blocked <a href="https://man.page/2/open">open(2)</a> or <a href="https://man.page/2/truncate">truncate(2)</a>
is interrupted by a signal handler, then the system call
fails with the error <b>EINTR</b>, but the other steps still
occur as described above. If the lease breaker is killed by
a signal while blocked in <a href="https://man.page/2/open">open(2)</a> or
<a href="https://man.page/2/truncate">truncate(2)</a>, then the other steps still occur as
described above. If the lease breaker specifies the
<b>O_NONBLOCK</b> flag when calling <a href="https://man.page/2/open">open(2)</a>, then the
call immediately fails with the error <b>EWOULDBLOCK</b>,
but the other steps still occur as described above.</p>

<p style="margin-left:11%; margin-top: 1em">The default
signal used to notify the lease holder is <b>SIGIO</b>, but
this can be changed using the <b>F_SETSIG</b> command to
<b>fcntl</b>(). If a <b>F_SETSIG</b> command is performed
(even one specifying <b>SIGIO</b>), and the signal handler
is established using <b>SA_SIGINFO</b>, then the handler
will receive a <i>siginfo_t</i> structure as its second
argument, and the <i>si_fd</i> field of this argument will
hold the file descriptor of the leased file that has been
accessed by another process. (This is useful if the caller
holds leases against multiple files.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>File and
directory change notification (dnotify) <br>
F_NOTIFY</b> (<i>int</i>)</p>

<p style="margin-left:22%;">(Linux 2.4 onward) Provide
notification when the directory referred to by <i>fd</i> or
any of the files that it contains is changed. The events to
be notified are specified in <i>arg</i>, which is a bit mask
specified by ORing together zero or more of the following
bits: <b><br>
DN_ACCESS</b></p>

<p style="margin-left:32%;">A file was accessed
(<a href="https://man.page/2/read">read(2)</a>, <a href="https://man.page/2/pread">pread(2)</a>, <a href="https://man.page/2/readv">readv(2)</a>, and
similar)</p>

<p style="margin-left:22%;"><b>DN_MODIFY</b></p>

<p style="margin-left:32%;">A file was modified
(<a href="https://man.page/2/write">write(2)</a>, <a href="https://man.page/2/pwrite">pwrite(2)</a>, <a href="https://man.page/2/writev">writev(2)</a>,
<a href="https://man.page/2/truncate">truncate(2)</a>, <a href="https://man.page/2/ftruncate">ftruncate(2)</a>, and similar).</p>

<p style="margin-left:22%;"><b>DN_CREATE</b></p>

<p style="margin-left:32%;">A file was created
(<a href="https://man.page/2/open">open(2)</a>, <a href="https://man.page/2/creat">creat(2)</a>, <a href="https://man.page/2/mknod">mknod(2)</a>,
<a href="https://man.page/2/mkdir">mkdir(2)</a>, <a href="https://man.page/2/link">link(2)</a>, <a href="https://man.page/2/symlink">symlink(2)</a>,
<a href="https://man.page/2/rename">rename(2)</a> into this directory).</p>

<p style="margin-left:22%;"><b>DN_DELETE</b></p>

<p style="margin-left:32%;">A file was unlinked
(<a href="https://man.page/2/unlink">unlink(2)</a>, <a href="https://man.page/2/rename">rename(2)</a> to another directory,
<a href="https://man.page/2/rmdir">rmdir(2)</a>).</p>

<p style="margin-left:22%;"><b>DN_RENAME</b></p>

<p style="margin-left:32%;">A file was renamed within this
directory (<a href="https://man.page/2/rename">rename(2)</a>).</p>

<p style="margin-left:22%;"><b>DN_ATTRIB</b></p>

<p style="margin-left:32%;">The attributes of a file were
changed (<a href="https://man.page/2/chown">chown(2)</a>, <a href="https://man.page/2/chmod">chmod(2)</a>, <a href="https://man.page/2/utime">utime(2)</a>,
<a href="https://man.page/2/utimensat">utimensat(2)</a>, and similar).</p>

<p style="margin-left:22%; margin-top: 1em">(In order to
obtain these definitions, the <b>_GNU_SOURCE</b> feature
test macro must be defined before including <i>any</i>
header files.)</p>

<p style="margin-left:22%; margin-top: 1em">Directory
notifications are normally &quot;one-shot&quot;, and the
application must reregister to receive further
notifications. Alternatively, if <b>DN_MULTISHOT</b> is
included in <i>arg</i>, then notification will remain in
effect until explicitly removed.</p>

<p style="margin-left:22%; margin-top: 1em">A series of
<b>F_NOTIFY</b> requests is cumulative, with the events in
<i>arg</i> being added to the set already monitored. To
disable notification of all events, make an <b>F_NOTIFY</b>
call specifying <i>arg</i> as 0.</p>

<p style="margin-left:22%; margin-top: 1em">Notification
occurs via delivery of a signal. The default signal is
<b>SIGIO</b>, but this can be changed using the
<b>F_SETSIG</b> command to <b>fcntl</b>(). (Note that
<b>SIGIO</b> is one of the nonqueuing standard signals;
switching to the use of a real-time signal means that
multiple notifications can be queued to the process.) In the
latter case, the signal handler receives a <i>siginfo_t</i>
structure as its second argument (if the handler was
established using <b>SA_SIGINFO</b>) and the <i>si_fd</i>
field of this structure contains the file descriptor which
generated the notification (useful when establishing
notification on multiple directories).</p>

<p style="margin-left:22%; margin-top: 1em">Especially when
using <b>DN_MULTISHOT</b>, a real time signal should be used
for notification, so that multiple notifications can be
queued.</p>

<p style="margin-left:22%; margin-top: 1em"><b>NOTE:</b>
New applications should use the <i>inotify</i> interface
(available since kernel 2.6.13), which provides a much
superior interface for obtaining notifications of filesystem
events. See <a href="https://man.page/7/inotify">inotify(7)</a>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Changing the
capacity of a pipe <br>
F_SETPIPE_SZ</b> (<i>int</i>; since Linux 2.6.35)</p>

<p style="margin-left:22%;">Change the capacity of the pipe
referred to by <i>fd</i> to be at least <i>arg</i> bytes. An
unprivileged process can adjust the pipe capacity to any
value between the system page size and the limit defined in
<i>/proc/sys/fs/pipe-max-size</i> (see <a href="https://man.page/5/proc">proc(5)</a>).
Attempts to set the pipe capacity below the page size are
silently rounded up to the page size. Attempts by an
unprivileged process to set the pipe capacity above the
limit in <i>/proc/sys/fs/pipe-max-size</i> yield the error
<b>EPERM</b>; a privileged process (<b>CAP_SYS_RESOURCE</b>)
can override the limit.</p>

<p style="margin-left:22%; margin-top: 1em">When allocating
the buffer for the pipe, the kernel may use a capacity
larger than <i>arg</i>, if that is convenient for the
implementation. (In the current implementation, the
allocation is the next higher power-of-two page-size
multiple of the requested size.) The actual capacity (in
bytes) that is set is returned as the function result.</p>

<p style="margin-left:22%; margin-top: 1em">Attempting to
set the pipe capacity smaller than the amount of buffer
space currently used to store data produces the error
<b>EBUSY</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Note that
because of the way the pages of the pipe buffer are employed
when data is written to the pipe, the number of bytes that
can be written may be less than the nominal size, depending
on the size of the writes.</p>

<p style="margin-left:11%;"><b>F_GETPIPE_SZ</b>
(<i>void</i>; since Linux 2.6.35)</p>

<p style="margin-left:22%;">Return (as the function result)
the capacity of the pipe referred to by <i>fd</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
Sealing</b> <br>
File seals limit the set of allowed operations on a given
file. For each seal that is set on a file, a specific set of
operations will fail with <b>EPERM</b> on this file from now
on. The file is said to be sealed. The default set of seals
depends on the type of the underlying file and filesystem.
For an overview of file sealing, a discussion of its
purpose, and some code examples, see
<a href="https://man.page/2/memfd_create">memfd_create(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Currently, file
seals can be applied only to a file descriptor returned by
<a href="https://man.page/2/memfd_create">memfd_create(2)</a> (if the <b>MFD_ALLOW_SEALING</b> was
employed). On other filesystems, all <b>fcntl</b>()
operations that operate on seals will return
<b>EINVAL</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Seals are a
property of an inode. Thus, all open file descriptors
referring to the same inode share the same set of seals.
Furthermore, seals can never be removed, only added. <b><br>
F_ADD_SEALS</b> (<i>int</i>; since Linux 3.17)</p>

<p style="margin-left:22%;">Add the seals given in the
bit-mask argument <i>arg</i> to the set of seals of the
inode referred to by the file descriptor <i>fd</i>. Seals
cannot be removed again. Once this call succeeds, the seals
are enforced by the kernel immediately. If the current set
of seals includes <b>F_SEAL_SEAL</b> (see below), then this
call will be rejected with <b>EPERM</b>. Adding a seal that
is already set is a no-op, in case <b>F_SEAL_SEAL</b> is not
set already. In order to place a seal, the file descriptor
<i>fd</i> must be writable.</p>

<p style="margin-left:11%;"><b>F_GET_SEALS</b>
(<i>void</i>; since Linux 3.17)</p>

<p style="margin-left:22%;">Return (as the function result)
the current set of seals of the inode referred to by
<i>fd</i>. If no seals are set, 0 is returned. If the file
does not support sealing, -1 is returned and <i>errno</i> is
set to <b>EINVAL</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
seals are available: <b><br>
F_SEAL_SEAL</b></p>

<p style="margin-left:22%;">If this seal is set, any
further call to <b>fcntl</b>() with <b>F_ADD_SEALS</b> fails
with the error <b>EPERM</b>. Therefore, this seal prevents
any modifications to the set of seals itself. If the initial
set of seals of a file includes <b>F_SEAL_SEAL</b>, then
this effectively causes the set of seals to be constant and
locked.</p>

<p style="margin-left:11%;"><b>F_SEAL_SHRINK</b></p>

<p style="margin-left:22%;">If this seal is set, the file
in question cannot be reduced in size. This affects
<a href="https://man.page/2/open">open(2)</a> with the <b>O_TRUNC</b> flag as well as
<a href="https://man.page/2/truncate">truncate(2)</a> and <a href="https://man.page/2/ftruncate">ftruncate(2)</a>. Those calls fail
with <b>EPERM</b> if you try to shrink the file in question.
Increasing the file size is still possible.</p>

<p style="margin-left:11%;"><b>F_SEAL_GROW</b></p>

<p style="margin-left:22%;">If this seal is set, the size
of the file in question cannot be increased. This affects
<a href="https://man.page/2/write">write(2)</a> beyond the end of the file,
<a href="https://man.page/2/truncate">truncate(2)</a>, <a href="https://man.page/2/ftruncate">ftruncate(2)</a>, and
<a href="https://man.page/2/fallocate">fallocate(2)</a>. These calls fail with <b>EPERM</b> if
you use them to increase the file size. If you keep the size
or shrink it, those calls still work as expected.</p>

<p style="margin-left:11%;"><b>F_SEAL_WRITE</b></p>

<p style="margin-left:22%;">If this seal is set, you cannot
modify the contents of the file. Note that shrinking or
growing the size of the file is still possible and allowed.
Thus, this seal is normally used in combination with one of
the other seals. This seal affects <a href="https://man.page/2/write">write(2)</a> and
<a href="https://man.page/2/fallocate">fallocate(2)</a> (only in combination with the
<b>FALLOC_FL_PUNCH_HOLE</b> flag). Those calls fail with
<b>EPERM</b> if this seal is set. Furthermore, trying to
create new shared, writable memory-mappings via
<a href="https://man.page/2/mmap">mmap(2)</a> will also fail with <b>EPERM</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Using the
<b>F_ADD_SEALS</b> operation to set the <b>F_SEAL_WRITE</b>
seal fails with <b>EBUSY</b> if any writable, shared mapping
exists. Such mappings must be unmapped before you can add
this seal. Furthermore, if there are any asynchronous I/O
operations (<a href="https://man.page/2/io_submit">io_submit(2)</a>) pending on the file, all
outstanding writes will be discarded.</p>

<p style="margin-left:11%;"><b>F_SEAL_FUTURE_WRITE</b>
(since Linux 5.1)</p>

<p style="margin-left:22%;">The effect of this seal is
similar to <b>F_SEAL_WRITE</b>, but the contents of the file
can still be modified via shared writable mappings that were
created prior to the seal being set. Any attempt to create a
new writable mapping on the file via <a href="https://man.page/2/mmap">mmap(2)</a> will
fail with <b>EPERM</b>. Likewise, an attempt to write to the
file via <a href="https://man.page/2/write">write(2)</a> will fail with <b>EPERM</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Using this
seal, one process can create a memory buffer that it can
continue to modify while sharing that buffer on a
&quot;read-only&quot; basis with other processes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
read/write hints</b> <br>
Write lifetime hints can be used to inform the kernel about
the relative expected lifetime of writes on a given inode or
via a particular open file description. (See <a href="https://man.page/2/open">open(2)</a>
for an explanation of open file descriptions.) In this
context, the term &quot;write lifetime&quot; means the
expected time the data will live on media, before being
overwritten or erased.</p>

<p style="margin-left:11%; margin-top: 1em">An application
may use the different hint values specified below to
separate writes into different write classes, so that
multiple users or applications running on a single storage
back-end can aggregate their I/O patterns in a consistent
manner. However, there are no functional semantics implied
by these flags, and different I/O classes can use the write
lifetime hints in arbitrary ways, so long as the hints are
used consistently.</p>

<p style="margin-left:11%; margin-top: 1em">The following
operations can be applied to the file descriptor, <i>fd</i>:
<b><br>
F_GET_RW_HINT</b> (<i>uint64_t *</i>; since Linux 4.13)</p>

<p style="margin-left:22%;">Returns the value of the
read/write hint associated with the underlying inode
referred to by <i>fd</i>.</p>

<p style="margin-left:11%;"><b>F_SET_RW_HINT</b>
(<i>uint64_t *</i>; since Linux 4.13)</p>

<p style="margin-left:22%;">Sets the read/write hint value
associated with the underlying inode referred to by
<i>fd</i>. This hint persists until either it is explicitly
modified or the underlying filesystem is unmounted.</p>

<p style="margin-left:11%;"><b>F_GET_FILE_RW_HINT</b>
(<i>uint64_t *</i>; since Linux 4.13)</p>

<p style="margin-left:22%;">Returns the value of the
read/write hint associated with the open file description
referred to by <i>fd</i>.</p>

<p style="margin-left:11%;"><b>F_SET_FILE_RW_HINT</b>
(<i>uint64_t *</i>; since Linux 4.13)</p>

<p style="margin-left:22%;">Sets the read/write hint value
associated with the open file description referred to by
<i>fd</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If an open file
description has not been assigned a read/write hint, then it
shall use the value assigned to the inode, if any.</p>

<p style="margin-left:11%; margin-top: 1em">The following
read/write hints are valid since Linux 4.13: <b><br>
RWH_WRITE_LIFE_NOT_SET</b></p>

<p style="margin-left:22%;">No specific hint has been set.
This is the default value.</p>

<p style="margin-left:11%;"><b>RWH_WRITE_LIFE_NONE</b></p>

<p style="margin-left:22%;">No specific write lifetime is
associated with this file or inode.</p>


<p style="margin-left:11%;"><b>RWH_WRITE_LIFE_SHORT</b></p>

<p style="margin-left:22%;">Data written to this inode or
via this open file description is expected to have a short
lifetime.</p>


<p style="margin-left:11%;"><b>RWH_WRITE_LIFE_MEDIUM</b></p>

<p style="margin-left:22%;">Data written to this inode or
via this open file description is expected to have a
lifetime longer than data written with
<b>RWH_WRITE_LIFE_SHORT</b>.</p>

<p style="margin-left:11%;"><b>RWH_WRITE_LIFE_LONG</b></p>

<p style="margin-left:22%;">Data written to this inode or
via this open file description is expected to have a
lifetime longer than data written with
<b>RWH_WRITE_LIFE_MEDIUM</b>.</p>


<p style="margin-left:11%;"><b>RWH_WRITE_LIFE_EXTREME</b></p>

<p style="margin-left:22%;">Data written to this inode or
via this open file description is expected to have a
lifetime longer than data written with
<b>RWH_WRITE_LIFE_LONG</b>.</p>

<p style="margin-left:11%; margin-top: 1em">All the
write-specific hints are relative to each other, and no
individual absolute meaning should be attributed to
them.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For a
successful call, the return value depends on the operation:
<b><br>
F_DUPFD</b></p>

<p style="margin-left:22%;">The new file descriptor.</p>

<p style="margin-left:11%;"><b>F_GETFD</b></p>

<p style="margin-left:22%;">Value of file descriptor
flags.</p>

<p style="margin-left:11%;"><b>F_GETFL</b></p>

<p style="margin-left:22%;">Value of file status flags.</p>

<p style="margin-left:11%;"><b>F_GETLEASE</b></p>

<p style="margin-left:22%;">Type of lease held on file
descriptor.</p>

<p style="margin-left:11%;"><b>F_GETOWN</b></p>

<p style="margin-left:22%;">Value of file descriptor
owner.</p>

<p style="margin-left:11%;"><b>F_GETSIG</b></p>

<p style="margin-left:22%;">Value of signal sent when read
or write becomes possible, or zero for traditional
<b>SIGIO</b> behavior.</p>

<p style="margin-left:11%;"><b>F_GETPIPE_SZ</b>,
<b>F_SETPIPE_SZ</b></p>

<p style="margin-left:22%;">The pipe capacity.</p>

<p style="margin-left:11%;"><b>F_GET_SEALS</b></p>

<p style="margin-left:22%;">A bit mask identifying the
seals that have been set for the inode referred to by
<i>fd</i>.</p>

<p style="margin-left:11%;">All other commands</p>

<p style="margin-left:22%;">Zero.</p>

<p style="margin-left:11%; margin-top: 1em">On error, -1 is
returned, and <i>errno</i> is set appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>EACCES</b>
or <b>EAGAIN</b></p>

<p style="margin-left:22%;">Operation is prohibited by
locks held by other processes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The operation is prohibited because the file has been
memory-mapped by another process.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>fd</i> is not an open file descriptor</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_SETLK</b> or <b>F_SETLKW</b> and the
file descriptor open mode doesn&rsquo;t match with the type
of lock requested.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBUSY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_SETPIPE_SZ</b> and the new pipe
capacity specified in <i>arg</i> is smaller than the amount
of buffer space currently used to store data in the
pipe.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBUSY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_ADD_SEALS</b>, <i>arg</i> includes
<b>F_SEAL_WRITE</b>, and there exists a writable, shared
mapping on the file referred to by <i>fd</i>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EDEADLK</b></p>

<p style="margin-left:22%;">It was detected that the
specified <b>F_SETLKW</b> command would cause a
deadlock.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>lock</i> is outside your accessible address
space.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_SETLKW</b> or <b>F_OFD_SETLKW</b> and
the operation was interrupted by a signal; see
<a href="https://man.page/7/signal">signal(7)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_GETLK</b>, <b>F_SETLK</b>,
<b>F_OFD_GETLK</b>, or <b>F_OFD_SETLK</b>, and the operation
was interrupted by a signal before the lock was checked or
acquired. Most likely when locking a remote file (e.g.,
locking over NFS), but can sometimes happen locally.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The value specified in <i>cmd</i> is not recognized by
this kernel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_ADD_SEALS</b> and <i>arg</i> includes
an unrecognized sealing bit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_ADD_SEALS</b> or <b>F_GET_SEALS</b>
and the filesystem containing the inode referred to by
<i>fd</i> does not support sealing.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_DUPFD</b> and <i>arg</i> is negative
or is greater than the maximum allowable value (see the
discussion of <b>RLIMIT_NOFILE</b> in
<a href="https://man.page/2/getrlimit">getrlimit(2)</a>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_SETSIG</b> and <i>arg</i> is not an
allowable signal number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>,
or <b>F_OFD_GETLK</b>, and <i>l_pid</i> was not specified as
zero.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_DUPFD</b> and the per-process limit
on the number of open file descriptors has been reached.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOLCK</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Too many segment locks open, lock table is full, or a
remote locking protocol failed (e.g., locking over NFS).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENOTDIR</b></p>

<p style="margin-left:22%;"><b>F_NOTIFY</b> was specified
in <i>cmd</i>, but <i>fd</i> does not refer to a
directory.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p><i>cmd</i> is <b>F_SETPIPE_SZ</b> and the soft or hard
user pipe limit has been reached; see <a href="https://man.page/7/pipe">pipe(7)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Attempted to clear the <b>O_APPEND</b> flag on a file
that has the append-only attribute set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p><i>cmd</i> was <b>F_ADD_SEALS</b>, but <i>fd</i> was not
open for writing or the current set of seals on the file
already includes <b>F_SEAL_SEAL</b>.</p></td></tr>
</table>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SVr4, 4.3BSD,
POSIX.1-2001. Only the operations <b>F_DUPFD</b>,
<b>F_GETFD</b>, <b>F_SETFD</b>, <b>F_GETFL</b>,
<b>F_SETFL</b>, <b>F_GETLK</b>, <b>F_SETLK</b>, and
<b>F_SETLKW</b> are specified in POSIX.1-2001.</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_GETOWN</b>
and <b>F_SETOWN</b> are specified in POSIX.1-2001. (To get
their definitions, define either <b>_XOPEN_SOURCE</b> with
the value 500 or greater, or <b>_POSIX_C_SOURCE</b> with the
value 200809L or greater.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_DUPFD_CLOEXEC</b>
is specified in POSIX.1-2008. (To get this definition,
define <b>_POSIX_C_SOURCE</b> with the value 200809L or
greater, or <b>_XOPEN_SOURCE</b> with the value 700 or
greater.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_GETOWN_EX</b>,
<b>F_SETOWN_EX</b>, <b>F_SETPIPE_SZ</b>,
<b>F_GETPIPE_SZ</b>, <b>F_GETSIG</b>, <b>F_SETSIG</b>,
<b>F_NOTIFY</b>, <b>F_GETLEASE</b>, and <b>F_SETLEASE</b>
are Linux-specific. (Define the <b>_GNU_SOURCE</b> macro to
obtain these definitions.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_OFD_SETLK</b>,
<b>F_OFD_SETLKW</b>, and <b>F_OFD_GETLK</b> are
Linux-specific (and one must define <b>_GNU_SOURCE</b> to
obtain their definitions), but work is being done to have
them included in the next version of POSIX.1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_ADD_SEALS</b>
and <b>F_GET_SEALS</b> are Linux-specific.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The errors
returned by <a href="https://man.page/2/dup2">dup2(2)</a> are different from those returned
by <b>F_DUPFD</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
locking</b> <br>
The original Linux <b>fcntl</b>() system call was not
designed to handle large file offsets (in the <i>flock</i>
structure). Consequently, an <b>fcntl64</b>() system call
was added in Linux 2.4. The newer system call employs a
different structure for file locking, <i>flock64</i>, and
corresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>,
and <b>F_SETLKW64</b>. However, these details can be ignored
by applications using glibc, whose <b>fcntl</b>() wrapper
function transparently employs the more recent system call
where it is available.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Record
locks</b> <br>
Since kernel 2.0, there is no interaction between the types
of lock placed by <a href="https://man.page/2/flock">flock(2)</a> and <b>fcntl</b>().</p>

<p style="margin-left:11%; margin-top: 1em">Several systems
have more fields in <i>struct flock</i> such as, for
example, <i>l_sysid</i> (to identify the machine where the
lock is held). Clearly, <i>l_pid</i> alone is not going to
be very useful if the process holding the lock may live on a
different machine; on Linux, while present on some
architectures (such as MIPS32), this field is not used.</p>

<p style="margin-left:11%; margin-top: 1em">The original
Linux <b>fcntl</b>() system call was not designed to handle
large file offsets (in the <i>flock</i> structure).
Consequently, an <b>fcntl64</b>() system call was added in
Linux 2.4. The newer system call employs a different
structure for file locking, <i>flock64</i>, and
corresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>,
and <b>F_SETLKW64</b>. However, these details can be ignored
by applications using glibc, whose <b>fcntl</b>() wrapper
function transparently employs the more recent system call
where it is available.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Record
locking and NFS</b> <br>
Before Linux 3.12, if an NFSv4 client loses contact with the
server for a period of time (defined as more than 90 seconds
with no communication), it might lose and regain a lock
without ever being aware of the fact. (The period of time
after which contact is assumed lost is known as the NFSv4
leasetime. On a Linux NFS server, this can be determined by
looking at <i>/proc/fs/nfsd/nfsv4leasetime</i>, which
expresses the period in seconds. The default value for this
file is 90.) This scenario potentially risks data
corruption, since another process might acquire a lock in
the intervening period and perform file I/O.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
3.12, if an NFSv4 client loses contact with the server, any
I/O to the file by a process which &quot;thinks&quot; it
holds a lock will fail until that process closes and reopens
the file. A kernel parameter, <i>nfs.recover_lost_locks</i>,
can be set to 1 to obtain the pre-3.12 behavior, whereby the
client will attempt to recover lost locks when contact is
reestablished with the server. Because of the attendant risk
of data corruption, this parameter defaults to 0
(disabled).</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>F_SETFL</b>
<br>
It is not possible to use <b>F_SETFL</b> to change the state
of the <b>O_DSYNC</b> and <b>O_SYNC</b> flags. Attempts to
change the state of these flags are silently ignored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_GETOWN</b>
<br>
A limitation of the Linux system call conventions on some
architectures (notably i386) means that if a (negative)
process group ID to be returned by <b>F_GETOWN</b> falls in
the range -1 to -4095, then the return value is wrongly
interpreted by glibc as an error in the system call; that
is, the return value of <b>fcntl</b>() will be -1, and
<i>errno</i> will contain the (positive) process group ID.
The Linux-specific <b>F_GETOWN_EX</b> operation avoids this
problem. Since glibc version 2.11, glibc makes the kernel
<b>F_GETOWN</b> problem invisible by implementing
<b>F_GETOWN</b> using <b>F_GETOWN_EX</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_SETOWN</b>
<br>
In Linux 2.4 and earlier, there is bug that can occur when
an unprivileged process uses <b>F_SETOWN</b> to specify the
owner of a socket file descriptor as a process (group) other
than the caller. In this case, <b>fcntl</b>() can return -1
with <i>errno</i> set to <b>EPERM</b>, even when the owner
process (group) is one that the caller has permission to
send signals to. Despite this error return, the file
descriptor owner is set, and signals will be sent to the
owner.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Deadlock
detection</b> <br>
The deadlock-detection algorithm employed by the kernel when
dealing with <b>F_SETLKW</b> requests can yield both false
negatives (failures to detect deadlocks, leaving a set of
deadlocked processes blocked indefinitely) and false
positives (<b>EDEADLK</b> errors when there is no deadlock).
For example, the kernel limits the lock depth of its
dependency search to 10 steps, meaning that circular
deadlock chains that exceed that size will not be detected.
In addition, the kernel may falsely indicate a deadlock when
two or more processes created using the <a href="https://man.page/2/clone">clone(2)</a>
<b>CLONE_FILES</b> flag place locks that appear (to the
kernel) to conflict.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mandatory
locking</b> <br>
The Linux implementation of mandatory locking is subject to
race conditions which render it unreliable: a
<a href="https://man.page/2/write">write(2)</a> call that overlaps with a lock may modify
data after the mandatory lock is acquired; a <a href="https://man.page/2/read">read(2)</a>
call that overlaps with a lock may detect changes to data
that were made only after a write lock was acquired. Similar
races exist between mandatory locks and <a href="https://man.page/2/mmap">mmap(2)</a>. It
is therefore inadvisable to rely on mandatory locking.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/dup2">dup2(2)</a>,
<a href="https://man.page/2/flock">flock(2)</a>, <a href="https://man.page/2/open">open(2)</a>, <a href="https://man.page/2/socket">socket(2)</a>,
<a href="https://man.page/3/lockf">lockf(3)</a>, <a href="https://man.page/7/capabilities">capabilities(7)</a>,
<a href="https://man.page/7/feature_test_macros">feature_test_macros(7)</a>, <b>lslocks</b>(8)</p>


<p style="margin-left:11%; margin-top: 1em"><i>locks.txt</i>,
<i>mandatory-locking.txt</i>, and <i>dnotify.txt</i> in the
Linux kernel source directory
<i>Documentation/filesystems/</i> (on older kernels, these
files are directly under the <i>Documentation/</i>
directory, and <i>mandatory-locking.txt</i> is called
<i>mandatory.txt</i>)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
