<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:37:05 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SECCOMP</title>

</head>
<body>

<h1 align="center">SECCOMP</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">seccomp -
operate on Secure Computing state of the process</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;linux/seccomp.h&gt; <br>
#include &lt;linux/filter.h&gt; <br>
#include &lt;linux/audit.h&gt; <br>
#include &lt;linux/signal.h&gt; <br>
#include &lt;sys/ptrace.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
seccomp(unsigned int</b> <i>operation</i><b>, unsigned
int</b> <i>flags</i><b>, void *</b><i>args</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>seccomp</b>() system call operates on the Secure
Computing (seccomp) state of the calling process.</p>

<p style="margin-left:11%; margin-top: 1em">Currently,
Linux supports the following <i>operation</i> values:
<b><br>
SECCOMP_SET_MODE_STRICT</b></p>

<p style="margin-left:22%;">The only system calls that the
calling thread is permitted to make are <a href="https://man.page/2/read">read(2)</a>,
<a href="https://man.page/2/write">write(2)</a>, <a href="https://man.page/2/_exit">_exit(2)</a> (but not
<a href="https://man.page/2/exit_group">exit_group(2)</a>), and <a href="https://man.page/2/sigreturn">sigreturn(2)</a>. Other system
calls result in the delivery of a <b>SIGKILL</b> signal.
Strict secure computing mode is useful for number-crunching
applications that may need to execute untrusted byte code,
perhaps obtained by reading from a pipe or socket.</p>

<p style="margin-left:22%; margin-top: 1em">Note that
although the calling thread can no longer call
<a href="https://man.page/2/sigprocmask">sigprocmask(2)</a>, it can use <a href="https://man.page/2/sigreturn">sigreturn(2)</a> to
block all signals apart from <b>SIGKILL</b> and
<b>SIGSTOP</b>. This means that <a href="https://man.page/2/alarm">alarm(2)</a> (for
example) is not sufficient for restricting the
process&rsquo;s execution time. Instead, to reliably
terminate the process, <b>SIGKILL</b> must be used. This can
be done by using <a href="https://man.page/2/timer_create">timer_create(2)</a> with
<b>SIGEV_SIGNAL</b> and <i>sigev_signo</i> set to
<b>SIGKILL</b>, or by using <a href="https://man.page/2/setrlimit">setrlimit(2)</a> to set the
hard limit for <b>RLIMIT_CPU</b>.</p>

<p style="margin-left:22%; margin-top: 1em">This operation
is available only if the kernel is configured with
<b>CONFIG_SECCOMP</b> enabled.</p>

<p style="margin-left:22%; margin-top: 1em">The value of
<i>flags</i> must be 0, and <i>args</i> must be NULL.</p>

<p style="margin-left:22%; margin-top: 1em">This operation
is functionally identical to the call:</p>


<p style="margin-left:28%; margin-top: 1em">prctl(PR_SET_SECCOMP,
SECCOMP_MODE_STRICT);</p>


<p style="margin-left:11%;"><b>SECCOMP_SET_MODE_FILTER</b></p>

<p style="margin-left:22%;">The system calls allowed are
defined by a pointer to a Berkeley Packet Filter (BPF)
passed via <i>args</i>. This argument is a pointer to a
<i>struct&nbsp;sock_fprog</i>; it can be designed to filter
arbitrary system calls and system call arguments. If the
filter is invalid, <b>seccomp</b>() fails, returning
<b>EINVAL</b> in <i>errno</i>.</p>

<p style="margin-left:22%; margin-top: 1em">If
<a href="https://man.page/2/fork">fork(2)</a> or <a href="https://man.page/2/clone">clone(2)</a> is allowed by the filter,
any child processes will be constrained to the same system
call filters as the parent. If <a href="https://man.page/2/execve">execve(2)</a> is allowed,
the existing filters will be preserved across a call to
<a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">In order to use
the <b>SECCOMP_SET_MODE_FILTER</b> operation, either the
calling thread must have the <b>CAP_SYS_ADMIN</b> capability
in its user namespace, or the thread must already have the
<i>no_new_privs</i> bit set. If that bit was not already set
by an ancestor of this thread, the thread must make the
following call:</p>


<p style="margin-left:28%; margin-top: 1em">prctl(PR_SET_NO_NEW_PRIVS,
1);</p>

<p style="margin-left:22%; margin-top: 1em">Otherwise, the
<b>SECCOMP_SET_MODE_FILTER</b> operation fails and returns
<b>EACCES</b> in <i>errno</i>. This requirement ensures that
an unprivileged process cannot apply a malicious filter and
then invoke a set-user-ID or other privileged program using
<a href="https://man.page/2/execve">execve(2)</a>, thus potentially compromising that
program. (Such a malicious filter might, for example, cause
an attempt to use <a href="https://man.page/2/setuid">setuid(2)</a> to set the caller&rsquo;s
user IDs to nonzero values to instead return 0 without
actually making the system call. Thus, the program might be
tricked into retaining superuser privileges in circumstances
where it is possible to influence it to do dangerous things
because it did not actually drop privileges.)</p>

<p style="margin-left:22%; margin-top: 1em">If
<a href="https://man.page/2/prctl">prctl(2)</a> or <b>seccomp</b>() is allowed by the
attached filter, further filters may be added. This will
increase evaluation time, but allows for further reduction
of the attack surface during execution of a thread.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>SECCOMP_SET_MODE_FILTER</b> operation is available only
if the kernel is configured with
<b>CONFIG_SECCOMP_FILTER</b> enabled.</p>

<p style="margin-left:22%; margin-top: 1em">When
<i>flags</i> is 0, this operation is functionally identical
to the call:</p>


<p style="margin-left:28%; margin-top: 1em">prctl(PR_SET_SECCOMP,
SECCOMP_MODE_FILTER, args);</p>

<p style="margin-left:22%; margin-top: 1em">The recognized
<i>flags</i> are: <b><br>
SECCOMP_FILTER_FLAG_TSYNC</b></p>

<p style="margin-left:32%;">When adding a new filter,
synchronize all other threads of the calling process to the
same seccomp filter tree. A &quot;filter tree&quot; is the
ordered list of filters attached to a thread. (Attaching
identical filters in separate <b>seccomp</b>() calls results
in different filters from this perspective.)</p>

<p style="margin-left:32%; margin-top: 1em">If any thread
cannot synchronize to the same filter tree, the call will
not attach the new seccomp filter, and will fail, returning
the first thread ID found that cannot synchronize.
Synchronization will fail if another thread in the same
process is in <b>SECCOMP_MODE_STRICT</b> or if it has
attached new seccomp filters to itself, diverging from the
calling thread&rsquo;s filter tree.</p>

<p style="margin-left:22%;"><b>SECCOMP_FILTER_FLAG_LOG</b>
(since Linux 4.14)</p>

<p style="margin-left:32%;">All filter return actions
except <b>SECCOMP_RET_ALLOW</b> should be logged. An
administrator may override this filter flag by preventing
specific actions from being logged via the
<i>/proc/sys/kernel/seccomp/actions_logged</i> file.</p>


<p style="margin-left:22%;"><b>SECCOMP_FILTER_FLAG_SPEC_ALLOW</b>
(since Linux 4.17)</p>

<p style="margin-left:32%;">Disable Speculative Store
Bypass mitigation.</p>


<p style="margin-left:11%;"><b>SECCOMP_GET_ACTION_AVAIL</b>
(since Linux 4.14)</p>

<p style="margin-left:22%;">Test to see if an action is
supported by the kernel. This operation is helpful to
confirm that the kernel knows of a more recently added
filter return action since the kernel treats all unknown
actions as <b>SECCOMP_RET_KILL_PROCESS</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The value of
<i>flags</i> must be 0, and <i>args</i> must be a pointer to
an unsigned 32-bit filter return action.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Filters</b>
<br>
When adding filters via <b>SECCOMP_SET_MODE_FILTER</b>,
<i>args</i> points to a filter program:</p>

<p style="margin-left:17%; margin-top: 1em">struct
sock_fprog { <br>
unsigned short len; /* Number of BPF instructions */ <br>
struct sock_filter *filter; /* Pointer to array of <br>
BPF instructions */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Each program
must contain one or more BPF instructions:</p>

<p style="margin-left:17%; margin-top: 1em">struct
sock_filter { /* Filter block */ <br>
__u16 code; /* Actual filter code */ <br>
__u8 jt; /* Jump true */ <br>
__u8 jf; /* Jump false */ <br>
__u32 k; /* Generic multiuse field */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">When executing
the instructions, the BPF program operates on the system
call information made available (i.e., use the
<b>BPF_ABS</b> addressing mode) as a (read-only) buffer of
the following form:</p>

<p style="margin-left:17%; margin-top: 1em">struct
seccomp_data { <br>
int nr; /* System call number */ <br>
__u32 arch; /* AUDIT_ARCH_* value <br>
(see &lt;linux/audit.h&gt;) */ <br>
__u64 instruction_pointer; /* CPU instruction pointer */
<br>
__u64 args[6]; /* Up to 6 system call arguments */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Because
numbering of system calls varies between architectures and
some architectures (e.g., x86-64) allow user-space code to
use the calling conventions of multiple architectures (and
the convention being used may vary over the life of a
process that uses <a href="https://man.page/2/execve">execve(2)</a> to execute binaries that
employ the different conventions), it is usually necessary
to verify the value of the <i>arch</i> field.</p>

<p style="margin-left:11%; margin-top: 1em">It is strongly
recommended to use an allow-list approach whenever possible
because such an approach is more robust and simple. A
deny-list will have to be updated whenever a potentially
dangerous system call is added (or a dangerous flag or
option if those are deny-listed), and it is often possible
to alter the representation of a value without altering its
meaning, leading to a deny-list bypass. See also
<i>Caveats</i> below.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>arch</i>
field is not unique for all calling conventions. The x86-64
ABI and the x32 ABI both use <b>AUDIT_ARCH_X86_64</b> as
<i>arch</i>, and they run on the same processors. Instead,
the mask <b>__X32_SYSCALL_BIT</b> is used on the system call
number to tell the two ABIs apart.</p>

<p style="margin-left:11%; margin-top: 1em">This means that
a policy must either deny all syscalls with
<b>__X32_SYSCALL_BIT</b> or it must recognize syscalls with
and without <b>__X32_SYSCALL_BIT</b> set. A list of system
calls to be denied based on <i>nr</i> that does not also
contain <i>nr</i> values with <b>__X32_SYSCALL_BIT</b> set
can be bypassed by a malicious program that sets
<b>__X32_SYSCALL_BIT</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally,
kernels prior to Linux 5.4 incorrectly permitted <i>nr</i>
in the ranges 512-547 as well as the corresponding non-x32
syscalls ORed with <b>__X32_SYSCALL_BIT</b>. For example,
<i>nr</i> == 521 and <i>nr</i> == (101 |
<b>__X32_SYSCALL_BIT</b>) would result in invocations of
<a href="https://man.page/2/ptrace">ptrace(2)</a> with potentially confused x32-vs-x86_64
semantics in the kernel. Policies intended to work on
kernels before Linux 5.4 must ensure that they deny or
otherwise correctly handle these system calls. On Linux 5.4
and newer, such system calls will fail with the error
<b>ENOSYS</b>, without doing anything.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>instruction_pointer</i> field provides the address of the
machine-language instruction that performed the system call.
This might be useful in conjunction with the use of
<i>/proc/[pid]/maps</i> to perform checks based on which
region (mapping) of the program made the system call.
(Probably, it is wise to lock down the <a href="https://man.page/2/mmap">mmap(2)</a> and
<a href="https://man.page/2/mprotect">mprotect(2)</a> system calls to prevent the program from
subverting such checks.)</p>

<p style="margin-left:11%; margin-top: 1em">When checking
values from <i>args</i>, keep in mind that arguments are
often silently truncated before being processed, but after
the seccomp check. For example, this happens if the i386 ABI
is used on an x86-64 kernel: although the kernel will
normally not look beyond the 32 lowest bits of the
arguments, the values of the full 64-bit registers will be
present in the seccomp data. A less surprising example is
that if the x86-64 ABI is used to perform a system call that
takes an argument of type <i>int</i>, the more-significant
half of the argument register is ignored by the system call,
but visible in the seccomp data.</p>

<p style="margin-left:11%; margin-top: 1em">A seccomp
filter returns a 32-bit value consisting of two parts: the
most significant 16 bits (corresponding to the mask defined
by the constant <b>SECCOMP_RET_ACTION_FULL</b>) contain one
of the &quot;action&quot; values listed below; the least
significant 16-bits (defined by the constant
<b>SECCOMP_RET_DATA</b>) are &quot;data&quot; to be
associated with this return value.</p>

<p style="margin-left:11%; margin-top: 1em">If multiple
filters exist, they are <i>all</i> executed, in reverse
order of their addition to the filter tree&mdash;that is,
the most recently installed filter is executed first. (Note
that all filters will be called even if one of the earlier
filters returns <b>SECCOMP_RET_KILL</b>. This is done to
simplify the kernel code and to provide a tiny speed-up in
the execution of sets of filters by avoiding a check for
this uncommon case.) The return value for the evaluation of
a given system call is the first-seen action value of
highest precedence (along with its accompanying data)
returned by execution of all of the filters.</p>

<p style="margin-left:11%; margin-top: 1em">In decreasing
order of precedence, the action values that may be returned
by a seccomp filter are: <b><br>
SECCOMP_RET_KILL_PROCESS</b> (since Linux 4.14)</p>

<p style="margin-left:22%;">This value results in immediate
termination of the process, with a core dump. The system
call is not executed. By contrast with
<b>SECCOMP_RET_KILL_THREAD</b> below, all threads in the
thread group are terminated. (For a discussion of thread
groups, see the description of the <b>CLONE_THREAD</b> flag
in <a href="https://man.page/2/clone">clone(2)</a>.)</p>

<p style="margin-left:22%; margin-top: 1em">The process
terminates <i>as though</i> killed by a <b>SIGSYS</b>
signal. Even if a signal handler has been registered for
<b>SIGSYS</b>, the handler will be ignored in this case and
the process always terminates. To a parent process that is
waiting on this process (using <a href="https://man.page/2/waitpid">waitpid(2)</a> or
similar), the returned <i>wstatus</i> will indicate that its
child was terminated as though by a <b>SIGSYS</b>
signal.</p>

<p style="margin-left:11%;"><b>SECCOMP_RET_KILL_THREAD</b>
(or <b>SECCOMP_RET_KILL</b>)</p>

<p style="margin-left:22%;">This value results in immediate
termination of the thread that made the system call. The
system call is not executed. Other threads in the same
thread group will continue to execute.</p>

<p style="margin-left:22%; margin-top: 1em">The thread
terminates <i>as though</i> killed by a <b>SIGSYS</b>
signal. See <b>SECCOMP_RET_KILL_PROCESS</b> above.</p>

<p style="margin-left:22%; margin-top: 1em">Before Linux
4.11, any process terminated in this way would not trigger a
coredump (even though <b>SIGSYS</b> is documented in
<a href="https://man.page/7/signal">signal(7)</a> as having a default action of termination
with a core dump). Since Linux 4.11, a single-threaded
process will dump core if terminated in this way.</p>

<p style="margin-left:22%; margin-top: 1em">With the
addition of <b>SECCOMP_RET_KILL_PROCESS</b> in Linux 4.14,
<b>SECCOMP_RET_KILL_THREAD</b> was added as a synonym for
<b>SECCOMP_RET_KILL</b>, in order to more clearly
distinguish the two actions.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Note</b>:
the use of <b>SECCOMP_RET_KILL_THREAD</b> to kill a single
thread in a multithreaded process is likely to leave the
process in a permanently inconsistent and possibly corrupt
state.</p>

<p style="margin-left:11%;"><b>SECCOMP_RET_TRAP</b></p>

<p style="margin-left:22%;">This value results in the
kernel sending a thread-directed <b>SIGSYS</b> signal to the
triggering thread. (The system call is not executed.)
Various fields will be set in the <i>siginfo_t</i> structure
(see <a href="https://man.page/2/sigaction">sigaction(2)</a>) associated with signal:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>si_signo</i> will contain <b>SIGSYS</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>si_call_addr</i> will show the address of the system
call instruction.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>si_syscall</i> and <i>si_arch</i> will indicate which
system call was attempted.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>si_code</i> will contain <b>SYS_SECCOMP</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="74%">


<p><i>si_errno</i> will contain the <b>SECCOMP_RET_DATA</b>
portion of the filter return value.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The program
counter will be as though the system call happened (i.e.,
the program counter will not point to the system call
instruction). The return value register will contain an
architecture-dependent value; if resuming execution, set it
to something appropriate for the system call. (The
architecture dependency is because replacing it with
<b>ENOSYS</b> could overwrite some useful information.)</p>

<p style="margin-left:11%;"><b>SECCOMP_RET_ERRNO</b></p>

<p style="margin-left:22%;">This value results in the
<b>SECCOMP_RET_DATA</b> portion of the filter&rsquo;s return
value being passed to user space as the <i>errno</i> value
without executing the system call.</p>

<p style="margin-left:11%;"><b>SECCOMP_RET_TRACE</b></p>

<p style="margin-left:22%;">When returned, this value will
cause the kernel to attempt to notify a
<a href="https://man.page/2/ptrace">ptrace(2)</a>-based tracer prior to executing the system
call. If there is no tracer present, the system call is not
executed and returns a failure status with <i>errno</i> set
to <b>ENOSYS</b>.</p>

<p style="margin-left:22%; margin-top: 1em">A tracer will
be notified if it requests <b>PTRACE_O_TRACESECCOMP</b>
using <i>ptrace(PTRACE_SETOPTIONS)</i>. The tracer will be
notified of a <b>PTRACE_EVENT_SECCOMP</b> and the
<b>SECCOMP_RET_DATA</b> portion of the filter&rsquo;s return
value will be available to the tracer via
<b>PTRACE_GETEVENTMSG</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The tracer can
skip the system call by changing the system call number to
-1. Alternatively, the tracer can change the system call
requested by changing the system call to a valid system call
number. If the tracer asks to skip the system call, then the
system call will appear to return the value that the tracer
puts in the return value register.</p>

<p style="margin-left:22%; margin-top: 1em">Before kernel
4.8, the seccomp check will not be run again after the
tracer is notified. (This means that, on older kernels,
seccomp-based sandboxes <b>must not</b> allow use of
<a href="https://man.page/2/ptrace">ptrace(2)</a>&mdash;even of other sandboxed
processes&mdash;without extreme care; ptracers can use this
mechanism to escape from the seccomp sandbox.)</p>

<p style="margin-left:22%; margin-top: 1em">Note that a
tracer process will not be notified if another filter
returns an action value with a precedence greater than
<b>SECCOMP_RET_TRACE</b>.</p>

<p style="margin-left:11%;"><b>SECCOMP_RET_LOG</b> (since
Linux 4.14)</p>

<p style="margin-left:22%;">This value results in the
system call being executed after the filter return action is
logged. An administrator may override the logging of this
action via the
<i>/proc/sys/kernel/seccomp/actions_logged</i> file.</p>

<p style="margin-left:11%;"><b>SECCOMP_RET_ALLOW</b></p>

<p style="margin-left:22%;">This value results in the
system call being executed.</p>

<p style="margin-left:11%; margin-top: 1em">If an action
value other than one of the above is specified, then the
filter action is treated as either
<b>SECCOMP_RET_KILL_PROCESS</b> (since Linux 4.14) or
<b>SECCOMP_RET_KILL_THREAD</b> (in Linux 4.13 and
earlier).</p>

<p style="margin-left:11%; margin-top: 1em"><b>/proc
interfaces</b> <br>
The files in the directory <i>/proc/sys/kernel/seccomp</i>
provide additional seccomp information and configuration:
<i><br>
actions_avail</i> (since Linux 4.14)</p>

<p style="margin-left:22%;">A read-only ordered list of
seccomp filter return actions in string form. The ordering,
from left-to-right, is in decreasing order of precedence.
The list represents the set of seccomp filter return actions
supported by the kernel.</p>

<p style="margin-left:11%;"><i>actions_logged</i> (since
Linux 4.14)</p>

<p style="margin-left:22%;">A read-write ordered list of
seccomp filter return actions that are allowed to be logged.
Writes to the file do not need to be in ordered form but
reads from the file will be ordered in the same way as the
<i>actions_avail</i> file.</p>

<p style="margin-left:22%; margin-top: 1em">It is important
to note that the value of <i>actions_logged</i> does not
prevent certain filter return actions from being logged when
the audit subsystem is configured to audit a task. If the
action is not found in the <i>actions_logged</i> file, the
final decision on whether to audit the action for that task
is ultimately left up to the audit subsystem to decide for
all filter return actions other than
<b>SECCOMP_RET_ALLOW</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The
&quot;allow&quot; string is not accepted in the
<i>actions_logged</i> file as it is not possible to log
<b>SECCOMP_RET_ALLOW</b> actions. Attempting to write
&quot;allow&quot; to the file will fail with the error
<b>EINVAL</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Audit
logging of seccomp actions</b> <br>
Since Linux 4.14, the kernel provides the facility to log
the actions returned by seccomp filters in the audit log.
The kernel makes the decision to log an action based on the
action type, whether or not the action is present in the
<i>actions_logged</i> file, and whether kernel auditing is
enabled (e.g., via the kernel boot option <i>audit=1</i>).
The rules are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the action is <b>SECCOMP_RET_ALLOW</b>, the action is
not logged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Otherwise, if the action is either
<b>SECCOMP_RET_KILL_PROCESS</b> or
<b>SECCOMP_RET_KILL_THREAD</b>, and that action appears in
the <i>actions_logged</i> file, the action is logged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Otherwise, if the filter has requested logging (the
<b>SECCOMP_FILTER_FLAG_LOG</b> flag) and the action appears
in the <i>actions_logged</i> file, the action is logged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Otherwise, if kernel auditing is enabled and the process
is being audited (<b>autrace</b>(8)), the action is
logged.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Otherwise, the action is not logged.</p></td></tr>
</table>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
<b>seccomp</b>() returns 0. On error, if
<b>SECCOMP_FILTER_FLAG_TSYNC</b> was used, the return value
is the ID of the thread that caused the synchronization
failure. (This ID is a kernel thread ID of the type returned
by <a href="https://man.page/2/clone">clone(2)</a> and <a href="https://man.page/2/gettid">gettid(2)</a>.) On other errors,
-1 is returned, and <i>errno</i> is set to indicate the
cause of the error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>seccomp</b>()
can fail for the following reasons:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">The caller did not have the
<b>CAP_SYS_ADMIN</b> capability in its user namespace, or
had not set <i>no_new_privs</i> before using
<b>SECCOMP_SET_MODE_FILTER</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>args</i> was not a valid address.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>operation</i> is unknown or is not supported by this
kernel version or configuration.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The specified <i>flags</i> are invalid for the given
<i>operation</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>operation</i> included <b>BPF_ABS</b>, but the
specified offset was not aligned to a 32-bit boundary or
exceeded <i>sizeof(struct&nbsp;seccomp_data)</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A secure computing mode has already been set, and
<i>operation</i> differs from the existing setting.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>operation</i> specified
<b>SECCOMP_SET_MODE_FILTER</b>, but the filter program
pointed to by <i>args</i> was not valid or the length of the
filter program was zero or exceeded <b>BPF_MAXINSNS</b>
(4096) instructions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Out of memory.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The total length of all filter programs attached to the
calling thread would exceed <b>MAX_INSNS_PER_PATH</b>
(32768) instructions. Note that for the purposes of
calculating this limit, each already existing filter program
incurs an overhead penalty of 4 instructions.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EOPNOTSUPP</b></p>

<p style="margin-left:22%;"><i>operation</i> specified
<b>SECCOMP_GET_ACTION_AVAIL</b>, but the kernel does not
support the filter return action specified by
<i>args</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ESRCH</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Another thread caused a failure during thread sync, but
its ID could not be determined.</p></td></tr>
</table>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>seccomp</b>() system call first appeared in Linux
3.17.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>seccomp</b>() system call is a nonstandard Linux
extension.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Rather than
hand-coding seccomp filters as shown in the example below,
you may prefer to employ the <i>libseccomp</i> library,
which provides a front-end for generating seccomp
filters.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>Seccomp</i> field of the <i>/proc/[pid]/status</i> file
provides a method of viewing the seccomp mode of a process;
see <a href="https://man.page/5/proc">proc(5)</a>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>seccomp</b>()
provides a superset of the functionality provided by the
<a href="https://man.page/2/prctl">prctl(2)</a> <b>PR_SET_SECCOMP</b> operation (which does
not support <i>flags</i>).</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
4.4, the <a href="https://man.page/2/ptrace">ptrace(2)</a> <b>PTRACE_SECCOMP_GET_FILTER</b>
operation can be used to dump a process&rsquo;s seccomp
filters.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Architecture
support for seccomp BPF</b> <br>
Architecture support for seccomp BPF filtering is available
on the following architectures:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="54%">


<p style="margin-top: 1em">x86-64, i386, x32 (since Linux
3.5)</p> </td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="54%">


<p>ARM (since Linux 3.8)</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="54%">


<p>s390 (since Linux 3.8)</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="54%">


<p>MIPS (since Linux 3.16)</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="54%">


<p>ARM-64 (since Linux 3.19)</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="54%">


<p>PowerPC (since Linux 4.3)</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="54%">


<p>Tile (since Linux 4.3)</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="54%">


<p>PA-RISC (since Linux 4.6)</p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Caveats</b>
<br>
There are various subtleties to consider when applying
seccomp filters to a program, including the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">Some traditional system calls
have user-space implementations in the <a href="https://man.page/7/vdso">vdso(7)</a> on
many architectures. Notable examples include
<a href="https://man.page/2/clock_gettime">clock_gettime(2)</a>, <a href="https://man.page/2/gettimeofday">gettimeofday(2)</a>, and
<a href="https://man.page/2/time">time(2)</a>. On such architectures, seccomp filtering for
these system calls will have no effect. (However, there are
cases where the <a href="https://man.page/7/vdso">vdso(7)</a> implementations may fall back
to invoking the true system call, in which case seccomp
filters would see the system call.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Seccomp filtering is based on system call numbers.
However, applications typically do not directly invoke
system calls, but instead call wrapper functions in the C
library which in turn invoke the system calls. Consequently,
one must be aware of the following:</p></td></tr>
</table>

<p style="margin-left:15%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%"></td>
<td width="3%"></td>
<td width="80%">


<p style="margin-top: 1em">The glibc wrappers for some
traditional system calls may actually employ system calls
with different names in the kernel. For example, the
<a href="https://man.page/2/exit">exit(2)</a> wrapper function actually employs the
<a href="https://man.page/2/exit_group">exit_group(2)</a> system call, and the <a href="https://man.page/2/fork">fork(2)</a>
wrapper function actually calls <a href="https://man.page/2/clone">clone(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="80%">


<p>The behavior of wrapper functions may vary across
architectures, according to the range of system calls
provided on those architectures. In other words, the same
wrapper function may invoke different system calls on
different architectures.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="80%">


<p>Finally, the behavior of wrapper functions can change
across glibc versions. For example, in older versions, the
glibc wrapper function for <a href="https://man.page/2/open">open(2)</a> invoked the system
call of the same name, but starting in glibc 2.26, the
implementation switched to calling <a href="https://man.page/2/openat">openat(2)</a> on all
architectures.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The consequence
of the above points is that it may be necessary to filter
for a system call other than might be expected. Various
manual pages in Section 2 provide helpful details about the
differences between wrapper functions and the underlying
system calls in subsections entitled <i>C library/kernel
differences</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Furthermore,
note that the application of seccomp filters even risks
causing bugs in an application, when the filters cause
unexpected failures for legitimate operations that the
application might need to perform. Such bugs may not easily
be discovered when testing the seccomp filters if the bugs
occur in rarely used application code paths.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Seccomp-specific
BPF details</b> <br>
Note the following BPF details specific to seccomp
filters:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The <b>BPF_H</b> and
<b>BPF_B</b> size modifiers are not supported: all
operations must load and store (4-byte) words
(<b>BPF_W</b>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>To access the contents of the <i>seccomp_data</i>
buffer, use the <b>BPF_ABS</b> addressing mode modifier.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The <b>BPF_LEN</b> addressing mode modifier yields an
immediate mode operand whose value is the size of the
<i>seccomp_data</i> buffer.</p></td></tr>
</table>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The program
below accepts four or more arguments. The first three
arguments are a system call number, a numeric architecture
identifier, and an error number. The program uses these
values to construct a BPF filter that is used at run time to
perform the following checks:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">If the program is not running on
the specified architecture, the BPF filter causes system
calls to fail with the error <b>ENOSYS</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>If the program attempts to execute the system call with
the specified number, the BPF filter causes the system call
to fail, with <i>errno</i> being set to the specified error
number.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The remaining
command-line arguments specify the pathname and additional
arguments of a program that the example program should
attempt to execute using <a href="https://man.page/3/execv">execv(3)</a> (a library function
that employs the <a href="https://man.page/2/execve">execve(2)</a> system call). Some example
runs of the program are shown below.</p>

<p style="margin-left:11%; margin-top: 1em">First, we
display the architecture that we are running on (x86-64) and
then construct a shell function that looks up system call
numbers on this architecture:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>uname
-m</b> <br>
x86_64 <br>
$ <b>syscall_nr() { <br>
cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \ <br>
awk '$2 != &quot;x32&quot; &amp;&amp; $3 == &quot;'$1'&quot;
{ print $1 }' <br>
}</b></p>

<p style="margin-left:11%; margin-top: 1em">When the BPF
filter rejects a system call (case [2] above), it causes the
system call to fail with the error number specified on the
command line. In the experiments shown here, we&rsquo;ll use
error number 99:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>errno
99</b> <br>
EADDRNOTAVAIL 99 Cannot assign requested address</p>

<p style="margin-left:11%; margin-top: 1em">In the
following example, we attempt to run the command
<a href="https://man.page/1/whoami">whoami(1)</a>, but the BPF filter rejects the
<a href="https://man.page/2/execve">execve(2)</a> system call, so that the command is not
even executed:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>syscall_nr
execve</b> <br>
59 <br>
$ <b>./a.out</b> <br>
Usage: ./a.out &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt;
&lt;prog&gt; [&lt;args&gt;] <br>
Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x40000003 <br>
AUDIT_ARCH_X86_64: 0xC000003E <br>
$ <b>./a.out 59 0xC000003E 99 /bin/whoami</b> <br>
execv: Cannot assign requested address</p>

<p style="margin-left:11%; margin-top: 1em">In the next
example, the BPF filter rejects the <a href="https://man.page/2/write">write(2)</a> system
call, so that, although it is successfully started, the
<a href="https://man.page/1/whoami">whoami(1)</a> command is not able to write output:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>syscall_nr
write</b> <br>
1 <br>
$ <b>./a.out 1 0xC000003E 99 /bin/whoami</b></p>

<p style="margin-left:11%; margin-top: 1em">In the final
example, the BPF filter rejects a system call that is not
used by the <a href="https://man.page/1/whoami">whoami(1)</a> command, so it is able to
successfully execute and produce output:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>syscall_nr
preadv</b> <br>
295 <br>
$ <b>./a.out 295 0xC000003E 99 /bin/whoami</b> <br>
cecilia</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
#include &lt;errno.h&gt; <br>
#include &lt;stddef.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;linux/audit.h&gt; <br>
#include &lt;linux/filter.h&gt; <br>
#include &lt;linux/seccomp.h&gt; <br>
#include &lt;sys/prctl.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">#define
X32_SYSCALL_BIT 0x40000000 <br>
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))</p>

<p style="margin-left:11%; margin-top: 1em">static int <br>
install_filter(int syscall_nr, int t_arch, int f_errno) <br>
{ <br>
unsigned int upper_nr_limit = 0xffffffff;</p>

<p style="margin-left:11%; margin-top: 1em">/* Assume that
AUDIT_ARCH_X86_64 means the normal x86-64 ABI <br>
(in the x32 ABI, all system calls have bit 30 set in the
<br>
'nr' field, meaning the numbers are &gt;= X32_SYSCALL_BIT)
*/ <br>
if (t_arch == AUDIT_ARCH_X86_64) <br>
upper_nr_limit = X32_SYSCALL_BIT - 1;</p>

<p style="margin-left:11%; margin-top: 1em">struct
sock_filter filter[] = { <br>
/* [0] Load architecture from 'seccomp_data' buffer into
<br>
accumulator */ <br>
BPF_STMT(BPF_LD | BPF_W | BPF_ABS, <br>
(offsetof(struct seccomp_data, arch))),</p>

<p style="margin-left:11%; margin-top: 1em">/* [1] Jump
forward 5 instructions if architecture does not <br>
match 't_arch' */ <br>
BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),</p>

<p style="margin-left:11%; margin-top: 1em">/* [2] Load
system call number from 'seccomp_data' buffer into <br>
accumulator */ <br>
BPF_STMT(BPF_LD | BPF_W | BPF_ABS, <br>
(offsetof(struct seccomp_data, nr))),</p>

<p style="margin-left:11%; margin-top: 1em">/* [3] Check
ABI - only needed for x86-64 in deny-list use <br>
cases. Use BPF_JGT instead of checking against the bit <br>
mask to avoid having to reload the syscall number. */ <br>
BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3,
0),</p>

<p style="margin-left:11%; margin-top: 1em">/* [4] Jump
forward 1 instruction if system call number <br>
does not match 'syscall_nr' */ <br>
BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),</p>

<p style="margin-left:11%; margin-top: 1em">/* [5] Matching
architecture and system call: don't execute <br>
the system call, and return 'f_errno' in 'errno' */ <br>
BPF_STMT(BPF_RET | BPF_K, <br>
SECCOMP_RET_ERRNO | (f_errno &amp; SECCOMP_RET_DATA)),</p>

<p style="margin-left:11%; margin-top: 1em">/* [6]
Destination of system call number mismatch: allow other <br>
system calls */ <br>
BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</p>

<p style="margin-left:11%; margin-top: 1em">/* [7]
Destination of architecture mismatch: kill process */ <br>
BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS), <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">struct
sock_fprog prog = { <br>
.len = ARRAY_SIZE(filter), <br>
.filter = filter, <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">if
(seccomp(SECCOMP_SET_MODE_FILTER, 0, &amp;prog)) { <br>
perror(&quot;seccomp&quot;); <br>
return 1; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">return 0; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char **argv) <br>
{ <br>
if (argc &lt; 5) { <br>
fprintf(stderr, &quot;Usage: &quot; <br>
&quot;%s &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt;
&lt;prog&gt; [&lt;args&gt;]\n&quot; <br>
&quot;Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x%X\n&quot;
<br>
&quot; AUDIT_ARCH_X86_64: 0x%X\n&quot; <br>
&quot;\n&quot;, argv[0], AUDIT_ARCH_I386,
AUDIT_ARCH_X86_64); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if
(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) { <br>
perror(&quot;prctl&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if
(install_filter(strtol(argv[1], NULL, 0), <br>
strtol(argv[2], NULL, 0), <br>
strtol(argv[3], NULL, 0))) <br>
exit(EXIT_FAILURE);</p>

<p style="margin-left:11%; margin-top: 1em">execv(argv[4],
&amp;argv[4]); <br>
perror(&quot;execv&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/1/bpfc">bpfc(1)</a>,
<a href="https://man.page/1/strace">strace(1)</a>, <a href="https://man.page/2/bpf">bpf(2)</a>, <a href="https://man.page/2/prctl">prctl(2)</a>,
<a href="https://man.page/2/ptrace">ptrace(2)</a>, <a href="https://man.page/2/sigaction">sigaction(2)</a>, <a href="https://man.page/5/proc">proc(5)</a>,
<a href="https://man.page/7/signal">signal(7)</a>, <a href="https://man.page/7/socket">socket(7)</a></p>

<p style="margin-left:11%; margin-top: 1em">Various pages
from the <i>libseccomp</i> library, including:
<a href="https://man.page/1/scmp_sys_resolver">scmp_sys_resolver(1)</a>, <a href="https://man.page/3/seccomp_export_bpf">seccomp_export_bpf(3)</a>,
<a href="https://man.page/3/seccomp_init">seccomp_init(3)</a>, <a href="https://man.page/3/seccomp_load">seccomp_load(3)</a>, and
<a href="https://man.page/3/seccomp_rule_add">seccomp_rule_add(3)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The kernel
source files <i>Documentation/networking/filter.txt</i> and
<i>Documentation/userspace-api/seccomp_filter.rst</i> (or
<i>Documentation/prctl/seccomp_filter.txt</i> before Linux
4.13).</p>

<p style="margin-left:11%; margin-top: 1em">McCanne, S. and
Jacobson, V. (1992) <i>The BSD Packet Filter: A New
Architecture for User-level Packet Capture</i>, Proceedings
of the USENIX Winter 1993 Conference
<a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">http://www.tcpdump.org/papers/bpf-usenix93.pdf</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
