<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:55 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>QEMU-BLOCK-DRIVERS</title>

</head>
<body>

<h1 align="center">QEMU-BLOCK-DRIVERS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">qemu-block-drivers
- QEMU block drivers reference</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">QEMU block
driver reference manual</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Disk image
file formats</b> <br>
QEMU supports many image file formats that can be used with
VMs as well as with any of the tools (like <b>qemu-img</b>).
This includes the preferred formats raw and qcow2 as well as
formats that are supported for compatibility with older QEMU
versions or other hypervisors.</p>

<p style="margin-left:11%; margin-top: 1em">Depending on
the image format, different options can be passed to
<b>qemu-img create</b> and <b>qemu-img convert</b> using the
<b>-o</b> option. This section describes each format and the
options that are supported for it.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>raw</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Raw disk image format. This format has the advantage of
being simple and easily exportable to all other emulators.
If your file system supports <i>holes</i> (for example in
ext2 or ext3 on Linux or NTFS on Windows), then only the
written sectors will reserve space. Use <b>qemu-img info</b>
to know the real size used by the image or <b>ls -ls</b> on
Unix/Linux.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Supported
options: <b><br>
preallocation</b></p>

<p style="margin-left:32%;">Preallocation mode (allowed
values: <b>off</b>, <b>falloc</b>, <b>full</b>).
<b>falloc</b> mode preallocates space for image by calling
<b>posix_fallocate()</b>. <b>full</b> mode preallocates
space for image by writing data to underlying storage. This
data may or may not be zero, depending on the storage
location.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>qcow2</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>QEMU image format, the most versatile format. Use it to
have smaller images (useful if your filesystem does not
supports holes, for example on Windows), zlib based
compression and support of multiple VM snapshots.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Supported
options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>compat</b></p></td>
<td width="1%"></td>
<td width="68%">


<p style="margin-top: 1em">Determines the qcow2 version to
use. <b>compat=0.10</b> uses the traditional image format
that can be read by any QEMU since 0.10. <b>compat=1.1</b>
enables image format extensions that only QEMU 1.1 and newer
understand (this is the default). Amongst others, this
includes zero clusters, which allow efficient copy-on-read
for sparse images.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>backing_file</b></p>

<p style="margin-left:32%;">File name of a base image (see
<b>create</b> subcommand)</p>

<p style="margin-left:22%;"><b>backing_fmt</b></p>

<p style="margin-left:32%;">Image format of the base
image</p>

<p style="margin-left:22%;"><b>encryption</b></p>

<p style="margin-left:32%;">This option is deprecated and
equivalent to <b>encrypt.format=aes</b></p>

<p style="margin-left:22%;"><b>encrypt.format</b></p>

<p style="margin-left:32%;">If this is set to <b>luks</b>,
it requests that the qcow2 payload (not qcow2 header) be
encrypted using the LUKS format. The passphrase to use to
unlock the LUKS key slot is given by the
<b>encrypt.key-secret</b> parameter. LUKS encryption
parameters can be tuned with the other <b>encrypt.*</b>
parameters.</p>

<p style="margin-left:32%; margin-top: 1em">If this is set
to <b>aes</b>, the image is encrypted with 128-bit AES-CBC.
The encryption key is given by the <b>encrypt.key-secret</b>
parameter. This encryption format is considered to be flawed
by modern cryptography standards, suffering from a number of
design problems:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>The AES-CBC cipher is used with predictable
initialization vectors based on the sector number. This
makes it vulnerable to chosen plaintext attacks which can
reveal the existence of encrypted data.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>The user passphrase is directly used as the encryption
key. A poorly chosen or short passphrase will compromise the
security of the encryption.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>In the event of the passphrase being compromised there
is no way to change the passphrase to protect data in any
qcow images. The files must be cloned, using a different
encryption passphrase in the new file. The original file
must then be securely erased using a program like shred,
though even this is ineffective with many modern storage
technologies.</p> </td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em">The use of this
is no longer supported in system emulators. Support only
remains in the command line utilities, for the purposes of
data liberation and interoperability with old versions of
QEMU. The <b>luks</b> format should be used instead.</p>

<p style="margin-left:22%;"><b>encrypt.key-secret</b></p>

<p style="margin-left:32%;">Provides the ID of a
<b>secret</b> object that contains the passphrase
(<b>encrypt.format=luks</b>) or encryption key
(<b>encrypt.format=aes</b>).</p>

<p style="margin-left:22%;"><b>encrypt.cipher-alg</b></p>

<p style="margin-left:32%;">Name of the cipher algorithm
and key length. Currently defaults to <b>aes-256</b>. Only
used when <b>encrypt.format=luks</b>.</p>

<p style="margin-left:22%;"><b>encrypt.cipher-mode</b></p>

<p style="margin-left:32%;">Name of the encryption mode to
use. Currently defaults to <b>xts</b>. Only used when
<b>encrypt.format=luks</b>.</p>

<p style="margin-left:22%;"><b>encrypt.ivgen-alg</b></p>

<p style="margin-left:32%;">Name of the initialization
vector generator algorithm. Currently defaults to
<b>plain64</b>. Only used when
<b>encrypt.format=luks</b>.</p>


<p style="margin-left:22%;"><b>encrypt.ivgen-hash-alg</b></p>

<p style="margin-left:32%;">Name of the hash algorithm to
use with the initialization vector generator (if required).
Defaults to <b>sha256</b>. Only used when
<b>encrypt.format=luks</b>.</p>

<p style="margin-left:22%;"><b>encrypt.hash-alg</b></p>

<p style="margin-left:32%;">Name of the hash algorithm to
use for PBKDF algorithm Defaults to <b>sha256</b>. Only used
when <b>encrypt.format=luks</b>.</p>

<p style="margin-left:22%;"><b>encrypt.iter-time</b></p>

<p style="margin-left:32%;">Amount of time, in
milliseconds, to use for PBKDF algorithm per key slot.
Defaults to <b>2000</b>. Only used when
<b>encrypt.format=luks</b>.</p>

<p style="margin-left:22%;"><b>cluster_size</b></p>

<p style="margin-left:32%;">Changes the qcow2 cluster size
(must be between 512 and 2M). Smaller cluster sizes can
improve the image file size whereas larger cluster sizes
generally provide better performance.</p>

<p style="margin-left:22%;"><b>preallocation</b></p>

<p style="margin-left:32%;">Preallocation mode (allowed
values: <b>off</b>, <b>metadata</b>, <b>falloc</b>,
<b>full</b>). An image with preallocated metadata is
initially larger but can improve performance when the image
needs to grow. <b>falloc</b> and <b>full</b> preallocations
are like the same options of <b>raw</b> format, but sets up
metadata also.</p>

<p style="margin-left:22%;"><b>lazy_refcounts</b></p>

<p style="margin-left:32%;">If this option is set to
<b>on</b>, reference count updates are postponed with the
goal of avoiding metadata I/O and improving performance.
This is particularly interesting with
<b>cache=writethrough</b> which doesn't batch metadata
updates. The tradeoff is that after a host crash, the
reference count tables must be rebuilt, i.e. on the next
open an (automatic) <b>qemu-img check -r all</b> is
required, which may take some time.</p>

<p style="margin-left:32%; margin-top: 1em">This option can
only be enabled if <b>compat=1.1</b> is specified.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>nocow</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>If this option is set to <b>on</b>, it will turn off COW
of the file. It's only valid on btrfs, no effect on other
file systems.</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em">Btrfs has low
performance when hosting a VM image file, even more when the
guest on the VM also using btrfs as file system. Turning off
COW is a way to mitigate this bad performance. Generally
there are two ways to turn off COW on btrfs:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p style="margin-top: 1em">Disable it by mounting with
nodatacow, then all newly created files will be NOCOW.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>For an empty file, add the NOCOW file attribute. That's
what this option does.</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em">Note: this
option is only valid to new or empty files. If there is an
existing file which is COW and has data blocks already, it
couldn't be changed to NOCOW by setting <b>nocow=on</b>. One
can issue <b>lsattr filename</b> to check if the NOCOW flag
is set or not (Capital 'C' is NOCOW flag).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>qed</b></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">Old QEMU image format with
support for backing files and compact image files (when your
filesystem or transport medium does not support holes).</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When converting
QED images to qcow2, you might want to consider using the
<b>lazy_refcounts=on</b> option to get a more QED-like
behaviour.</p>

<p style="margin-left:22%; margin-top: 1em">Supported
options: <b><br>
backing_file</b></p>

<p style="margin-left:32%;">File name of a base image (see
<b>create</b> subcommand).</p>

<p style="margin-left:22%;"><b>backing_fmt</b></p>

<p style="margin-left:32%;">Image file format of backing
file (optional). Useful if the format cannot be autodetected
because it has no header, like some vhd/vpc files.</p>

<p style="margin-left:22%;"><b>cluster_size</b></p>

<p style="margin-left:32%;">Changes the cluster size (must
be power-of-2 between 4K and 64K). Smaller cluster sizes can
improve the image file size whereas larger cluster sizes
generally provide better performance.</p>

<p style="margin-left:22%;"><b>table_size</b></p>

<p style="margin-left:32%;">Changes the number of clusters
per L1/L2 table (must be power-of-2 between 1 and 16). There
is normally no need to change this value but this option can
between used for performance benchmarking.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>qcow</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Old QEMU image format with support for backing files,
compact image files, encryption and compression.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Supported
options:</p>

<p style="margin-left:26%;"><b>backing_file</b></p>

<p style="margin-left:37%;">File name of a base image (see
<b>create</b> subcommand)</p>

<p style="margin-left:26%;"><b>encryption</b></p>

<p style="margin-left:37%;">This option is deprecated and
equivalent to <b>encrypt.format=aes</b></p>

<p style="margin-left:26%;"><b>encrypt.format</b></p>

<p style="margin-left:37%;">If this is set to <b>aes</b>,
the image is encrypted with 128-bit AES-CBC. The encryption
key is given by the <b>encrypt.key-secret</b> parameter.
This encryption format is considered to be flawed by modern
cryptography standards, suffering from a number of design
problems enumerated previously against the <b>qcow2</b>
image format.</p>

<p style="margin-left:37%; margin-top: 1em">The use of this
is no longer supported in system emulators. Support only
remains in the command line utilities, for the purposes of
data liberation and interoperability with old versions of
QEMU.</p>

<p style="margin-left:37%; margin-top: 1em">Users requiring
native encryption should use the <b>qcow2</b> format instead
with <b>encrypt.format=luks</b>.</p>

<p style="margin-left:26%;"><b>encrypt.key-secret</b></p>

<p style="margin-left:37%;">Provides the ID of a
<b>secret</b> object that contains the encryption key
(<b>encrypt.format=aes</b>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>luks</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>LUKS v1 encryption format, compatible with Linux
dm-crypt/cryptsetup</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Supported
options: <b><br>
key-secret</b></p>

<p style="margin-left:32%;">Provides the ID of a
<b>secret</b> object that contains the passphrase.</p>

<p style="margin-left:22%;"><b>cipher-alg</b></p>

<p style="margin-left:32%;">Name of the cipher algorithm
and key length. Currently defaults to <b>aes-256</b>.</p>

<p style="margin-left:22%;"><b>cipher-mode</b></p>

<p style="margin-left:32%;">Name of the encryption mode to
use. Currently defaults to <b>xts</b>.</p>

<p style="margin-left:22%;"><b>ivgen-alg</b></p>

<p style="margin-left:32%;">Name of the initialization
vector generator algorithm. Currently defaults to
<b>plain64</b>.</p>

<p style="margin-left:22%;"><b>ivgen-hash-alg</b></p>

<p style="margin-left:32%;">Name of the hash algorithm to
use with the initialization vector generator (if required).
Defaults to <b>sha256</b>.</p>

<p style="margin-left:22%;"><b>hash-alg</b></p>

<p style="margin-left:32%;">Name of the hash algorithm to
use for PBKDF algorithm Defaults to <b>sha256</b>.</p>

<p style="margin-left:22%;"><b>iter-time</b></p>

<p style="margin-left:32%;">Amount of time, in
milliseconds, to use for PBKDF algorithm per key slot.
Defaults to <b>2000</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>vdi</b></p></td>
<td width="7%"></td>
<td width="60%">


<p>VirtualBox 1.1 compatible image format.</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Supported
options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p style="margin-top: 1em"><b>static</b></p></td>
<td width="1%"></td>
<td width="68%">


<p style="margin-top: 1em">If this option is set to
<b>on</b>, the image is created with metadata
preallocation.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>vmdk</b></p></td>
<td width="1%"></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">VMware 3 and 4
compatible image format.</p>

<p style="margin-left:22%; margin-top: 1em">Supported
options: <b><br>
backing_file</b></p>

<p style="margin-left:32%;">File name of a base image (see
<b>create</b> subcommand).</p>

<p style="margin-left:22%;"><b>compat6</b></p>

<p style="margin-left:32%;">Create a VMDK version 6 image
(instead of version 4)</p>

<p style="margin-left:22%;"><b>hwversion</b></p>

<p style="margin-left:32%;">Specify vmdk virtual hardware
version. Compat6 flag cannot be enabled if hwversion is
specified.</p>

<p style="margin-left:22%;"><b>subformat</b></p>

<p style="margin-left:32%;">Specifies which VMDK subformat
to use. Valid options are <b>monolithicSparse</b> (default),
<b>monolithicFlat</b>, <b>twoGbMaxExtentSparse</b>,
<b>twoGbMaxExtentFlat</b> and <b>streamOptimized</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>vpc</b></p></td>
<td width="7%"></td>
<td width="61%">


<p>VirtualPC compatible image format (VHD).</p></td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Supported
options: <b><br>
subformat</b></p>

<p style="margin-left:32%;">Specifies which VHD subformat
to use. Valid options are <b>dynamic</b> (default) and
<b>fixed</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>VHDX</b></p></td>
<td width="5%"></td>
<td width="60%">


<p>Hyper-V compatible image format (VHDX).</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Supported
options: <b><br>
subformat</b></p>

<p style="margin-left:32%;">Specifies which VHDX subformat
to use. Valid options are <b>dynamic</b> (default) and
<b>fixed</b>. <b><br>
block_state_zero</b></p>

<p style="margin-left:43%;">Force use of payload blocks of
type 'ZERO'. Can be set to <b>on</b> (default) or
<b>off</b>. When set to <b>off</b>, new blocks will be
created as <b>PAYLOAD_BLOCK_NOT_PRESENT</b>, which means
parsers are free to return arbitrary data for those blocks.
Do not set to <b>off</b> when using <b>qemu-img convert</b>
with <b>subformat=dynamic</b>.</p>

<p style="margin-left:32%;"><b>block_size</b></p>

<p style="margin-left:43%;">Block size; min 1 MB, max 256
MB. 0 means auto-calculate based on image size.</p>

<p style="margin-left:32%;"><b>log_size</b></p>

<p style="margin-left:43%;">Log size; min 1 MB.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Read-only
formats</b> <br>
More disk image file formats are supported in a read-only
mode.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>bochs</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Bochs images of <b>growing</b> type.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>cloop</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Linux Compressed Loop image, useful only to reuse
directly compressed CD-ROM images present for example in the
Knoppix CD-ROMs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>dmg</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Apple disk image.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>parallels</b></p>

<p style="margin-left:22%;">Parallels disk image
format.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using host
drives</b> <br>
In addition to disk image files, QEMU can directly access
host devices. We describe here the usage for QEMU version
&gt;= 0.8.3.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Linux</b>
<br>
On Linux, you can directly use the host device filename
instead of a disk image filename provided you have enough
privileges to access it. For example, use <b>/dev/cdrom</b>
to access to the CDROM.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CD</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>You can specify a CDROM device even if no CDROM is
loaded. QEMU has specific code to detect CDROM insertion or
removal. CDROM ejection by the guest OS is supported.
Currently only data CDs are supported.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>Floppy</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>You can specify a floppy device even if no floppy is
loaded. Floppy removal is currently not detected accurately
(if you change floppy without doing floppy access while the
floppy is not loaded, the guest OS will think that the same
floppy is loaded). Use of the host's floppy device is
deprecated, and support for it will be removed in a future
release.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>Hard disks</b></p>

<p style="margin-left:22%;">Hard disks can be used.
Normally you must specify the whole disk (<b>/dev/hdb</b>
instead of <b>/dev/hdb1</b>) so that the guest OS can see it
as a partitioned disk. WARNING: unless you know what you do,
it is better to only make READ-ONLY accesses to the hard
disk otherwise you may corrupt your host data (use the
<b>-snapshot</b> command line option or modify the device
permissions accordingly).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Windows</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>CD</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>The preferred syntax is the drive letter (e.g.
<b>d:</b>). The alternate syntax <b>\\.\d:</b> is supported.
<b>/dev/cdrom</b> is supported as an alias to the first
CDROM drive.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Currently there
is no specific code to handle removable media, so it is
better to use the <b>change</b> or <b>eject</b> monitor
commands to change or eject media.</p>

<p style="margin-left:11%;"><b>Hard disks</b></p>

<p style="margin-left:22%;">Hard disks can be used with the
syntax: <b>\\.\PhysicalDriveN</b> where <i>N</i> is the
drive number (0 is the first hard disk).</p>

<p style="margin-left:22%; margin-top: 1em">WARNING: unless
you know what you do, it is better to only make READ-ONLY
accesses to the hard disk otherwise you may corrupt your
host data (use the <b>-snapshot</b> command line so that the
modifications are written in a temporary file).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mac OS X
<br>
/dev/cdrom</b> is an alias to the first CDROM.</p>

<p style="margin-left:11%; margin-top: 1em">Currently there
is no specific code to handle removable media, so it is
better to use the <b>change</b> or <b>eject</b> monitor
commands to change or eject media.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Virtual FAT
disk images</b> <br>
QEMU can automatically create a virtual FAT disk image from
a directory tree. In order to use it, just type:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 linux.img -hdb fat:/my_directory</pre>


<p style="margin-left:11%; margin-top: 1em">Then you access
access to all the files in the <b>/my_directory</b>
directory without having to copy them in a disk image or to
export them via SAMBA or NFS. The default access is
<i>read-only</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Floppies can be
emulated with the <b>:floppy:</b> option:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 linux.img -fda fat:floppy:/my_directory</pre>


<p style="margin-left:11%; margin-top: 1em">A read/write
support is available for testing (beta stage) with the
<b>:rw:</b> option:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 linux.img -fda fat:floppy:rw:/my_directory</pre>


<p style="margin-left:11%; margin-top: 1em">What you should
<i>never</i> do:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>use non-ASCII filenames</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>use &quot;-snapshot&quot; together with
&quot;:rw:&quot;</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>expect it to work when loadvm'ing</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>write to the FAT directory on the host system while
accessing it with the guest system</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>NBD
access</b> <br>
QEMU can access directly to block device exported using the
Network Block Device protocol.</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 linux.img -hdb nbd://my_nbd_server.mydomain.org:1024/</pre>


<p style="margin-left:11%; margin-top: 1em">If the NBD
server is located on the same host, you can use an unix
socket instead of an inet socket:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 linux.img -hdb nbd+unix://?socket=/tmp/my_socket</pre>


<p style="margin-left:11%; margin-top: 1em">In this case,
the block device must be exported using <b>qemu-nbd</b>:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-nbd --socket=/tmp/my_socket my_disk.qcow2</pre>


<p style="margin-left:11%; margin-top: 1em">The use of
<b>qemu-nbd</b> allows sharing of a disk between several
guests:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-nbd --socket=/tmp/my_socket --share=2 my_disk.qcow2</pre>


<p style="margin-left:11%; margin-top: 1em">and then you
can use it with two guests:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 linux1.img -hdb nbd+unix://?socket=/tmp/my_socket
qemu-system-x86_64 linux2.img -hdb nbd+unix://?socket=/tmp/my_socket</pre>


<p style="margin-left:11%; margin-top: 1em">If the
<b>nbd-server</b> uses named exports (supported since NBD
2.9.18, or with QEMU's own embedded NBD server), you must
specify an export name in the URI:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 -cdrom nbd://localhost/debian-500-ppc-netinst
qemu-system-x86_64 -cdrom nbd://localhost/openSUSE-11.1-ppc-netinst</pre>


<p style="margin-left:11%; margin-top: 1em">The URI syntax
for NBD is supported since QEMU 1.3. An alternative syntax
is also available. Here are some example of the older
syntax:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 linux.img -hdb nbd:my_nbd_server.mydomain.org:1024
qemu-system-x86_64 linux2.img -hdb nbd:unix:/tmp/my_socket
qemu-system-x86_64 -cdrom nbd:localhost:10809:exportname=debian-500-ppc-netinst</pre>


<p style="margin-left:11%; margin-top: 1em"><b>iSCSI
LUNs</b> <br>
iSCSI is a popular protocol used to access SCSI devices
across a computer network.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
different ways iSCSI devices can be used by QEMU.</p>

<p style="margin-left:11%; margin-top: 1em">The first
method is to mount the iSCSI LUN on the host, and make it
appear as any other ordinary SCSI device on the host and
then to access this device as a /dev/sd device from QEMU.
How to do this differs between host OSes.</p>

<p style="margin-left:11%; margin-top: 1em">The second
method involves using the iSCSI initiator that is built into
QEMU. This provides a mechanism that works the same way
regardless of which host OS you are running QEMU on. This
section will describe this second method of using iSCSI
together with QEMU.</p>

<p style="margin-left:11%; margin-top: 1em">In QEMU, iSCSI
devices are described using special iSCSI URLs. URL
syntax:</p>

<pre style="margin-left:15%; margin-top: 1em">iscsi://[&lt;username&gt;[%&lt;password&gt;]@]&lt;host&gt;[:&lt;port&gt;]/&lt;target-iqn-name&gt;/&lt;lun&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Username and
password are optional and only used if your target is set up
using CHAP authentication for access control. Alternatively
the username and password can also be set via environment
variables to have these not show up in the process list:</p>

<pre style="margin-left:15%; margin-top: 1em">export LIBISCSI_CHAP_USERNAME=&lt;username&gt;
export LIBISCSI_CHAP_PASSWORD=&lt;password&gt;
iscsi://&lt;host&gt;/&lt;target-iqn-name&gt;/&lt;lun&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Various session
related parameters can be set via special options, either in
a configuration file provided via '-readconfig' or directly
on the command line.</p>

<p style="margin-left:11%; margin-top: 1em">If the
initiator-name is not specified qemu will use a default name
of 'iqn.2008-11.org.linux-kvm[:&lt;uuid&gt;'] where
&lt;uuid&gt; is the UUID of the virtual machine. If the UUID
is not specified qemu will use
'iqn.2008-11.org.linux-kvm[:&lt;name&gt;'] where
&lt;name&gt; is the name of the virtual machine.</p>

<p style="margin-left:11%; margin-top: 1em">Setting a
specific initiator name to use when logging in to the
target:</p>

<pre style="margin-left:15%; margin-top: 1em">-iscsi initiator-name=iqn.qemu.test:my-initiator</pre>


<p style="margin-left:11%; margin-top: 1em">Controlling
which type of header digest to negotiate with the
target:</p>

<pre style="margin-left:15%; margin-top: 1em">-iscsi header-digest=CRC32C|CRC32C-NONE|NONE-CRC32C|NONE</pre>


<p style="margin-left:11%; margin-top: 1em">These can also
be set via a configuration file:</p>

<pre style="margin-left:15%; margin-top: 1em">[iscsi]
  user = &quot;CHAP username&quot;
  password = &quot;CHAP password&quot;
  initiator-name = &quot;iqn.qemu.test:my-initiator&quot;
  # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE
  header-digest = &quot;CRC32C&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">Setting the
target name allows different options for different
targets:</p>

<pre style="margin-left:15%; margin-top: 1em">[iscsi &quot;iqn.target.name&quot;]
  user = &quot;CHAP username&quot;
  password = &quot;CHAP password&quot;
  initiator-name = &quot;iqn.qemu.test:my-initiator&quot;
  # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE
  header-digest = &quot;CRC32C&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">How to use a
configuration file to set iSCSI configuration options:</p>
<pre style="margin-left:15%; margin-top: 1em">cat &gt;iscsi.conf &lt;&lt;EOF
[iscsi]
  user = &quot;me&quot;
  password = &quot;my password&quot;
  initiator-name = &quot;iqn.qemu.test:my-initiator&quot;
  header-digest = &quot;CRC32C&quot;
EOF


qemu-system-x86_64 -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \
  -readconfig iscsi.conf</pre>


<p style="margin-left:11%; margin-top: 1em">How to set up a
simple iSCSI target on loopback and access it via QEMU: this
example shows how to set up an iSCSI target with one CDROM
and one DISK using the Linux STGT software target. This
target is available on Red Hat based systems as the package
'scsi-target-utils'.</p>
<pre style="margin-left:15%; margin-top: 1em">tgtd --iscsi portal=127.0.0.1:3260
tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.qemu.test
tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 \
    -b /IMAGES/disk.img --device-type=disk
tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 2 \
    -b /IMAGES/cd.iso --device-type=cd
tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL


qemu-system-x86_64 -iscsi initiator-name=iqn.qemu.test:my-initiator \
  -boot d -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \
  -cdrom iscsi://127.0.0.1/iqn.qemu.test/2</pre>


<p style="margin-left:11%; margin-top: 1em"><b>GlusterFS
disk images</b> <br>
GlusterFS is a user space distributed file system.</p>

<p style="margin-left:11%; margin-top: 1em">You can boot
from the GlusterFS disk image with the command:</p>

<p style="margin-left:11%; margin-top: 1em">URI:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 -drive file=gluster[+TYPE]://[HOST}[:PORT]]/VOLUME/PATH
                             [?socket=...][,file.debug=9][,file.logfile=...]</pre>


<p style="margin-left:11%; margin-top: 1em">JSON:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 'json:{&quot;driver&quot;:&quot;qcow2&quot;,
                         &quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,
                                  &quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,&quot;debug&quot;:9,&quot;logfile&quot;:&quot;...&quot;,
                                  &quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;...&quot;,&quot;port&quot;:&quot;...&quot;},
                                            {&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;...&quot;}]}}'</pre>


<p style="margin-left:11%; margin-top: 1em"><i>gluster</i>
is the protocol.</p>

<p style="margin-left:11%; margin-top: 1em"><i>TYPE</i>
specifies the transport type used to connect to gluster
management daemon (glusterd). Valid transport types are tcp
and unix. In the URI form, if a transport type isn't
specified, then tcp type is assumed.</p>

<p style="margin-left:11%; margin-top: 1em"><i>HOST</i>
specifies the server where the volume file specification for
the given volume resides. This can be either a hostname or
an ipv4 address. If transport type is unix, then <i>HOST</i>
field should not be specified. Instead <i>socket</i> field
needs to be populated with the path to unix domain
socket.</p>

<p style="margin-left:11%; margin-top: 1em"><i>PORT</i> is
the port number on which glusterd is listening. This is
optional and if not specified, it defaults to port 24007. If
the transport type is unix, then <i>PORT</i> should not be
specified.</p>

<p style="margin-left:11%; margin-top: 1em"><i>VOLUME</i>
is the name of the gluster volume which contains the disk
image.</p>

<p style="margin-left:11%; margin-top: 1em"><i>PATH</i> is
the path to the actual disk image that resides on gluster
volume.</p>

<p style="margin-left:11%; margin-top: 1em"><i>debug</i> is
the logging level of the gluster protocol driver. Debug
levels are 0-9, with 9 being the most verbose, and 0
representing no debugging output. The default level is 4.
The current logging levels defined in the gluster source are
0 - None, 1 - Emergency, 2 - Alert, 3 - Critical, 4 - Error,
5 - Warning, 6 - Notice, 7 - Info, 8 - Debug, 9 - Trace</p>

<p style="margin-left:11%; margin-top: 1em"><i>logfile</i>
is a commandline option to mention log file path which helps
in logging to the specified file and also help in persisting
the gfapi logs. The default is stderr.</p>

<p style="margin-left:11%; margin-top: 1em">You can create
a GlusterFS disk image with the command:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-img create gluster://HOST/VOLUME/PATH SIZE</pre>


<p style="margin-left:11%; margin-top: 1em">Examples</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 -drive file=gluster://1.2.3.4/testvol/a.img
qemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4/testvol/a.img
qemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4:24007/testvol/dir/a.img
qemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]/testvol/dir/a.img
qemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]:24007/testvol/dir/a.img
qemu-system-x86_64 -drive file=gluster+tcp://server.domain.com:24007/testvol/dir/a.img
qemu-system-x86_64 -drive file=gluster+unix:///testvol/dir/a.img?socket=/tmp/glusterd.socket
qemu-system-x86_64 -drive file=gluster+rdma://1.2.3.4:24007/testvol/a.img
qemu-system-x86_64 -drive file=gluster://1.2.3.4/testvol/a.img,file.debug=9,file.logfile=/var/log/qemu-gluster.log
qemu-system-x86_64 'json:{&quot;driver&quot;:&quot;qcow2&quot;,
                         &quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,
                                  &quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,
                                  &quot;debug&quot;:9,&quot;logfile&quot;:&quot;/var/log/qemu-gluster.log&quot;,
                                  &quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;1.2.3.4&quot;,&quot;port&quot;:24007},
                                            {&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;/var/run/glusterd.socket&quot;}]}}'
qemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,
                                     file.debug=9,file.logfile=/var/log/qemu-gluster.log,
                                     file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,
                                     file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Secure Shell
(ssh) disk images</b> <br>
You can access disk images located on a remote ssh server by
using the ssh protocol:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 -drive file=ssh://[USER@]SERVER[:PORT]/PATH[?host_key_check=HOST_KEY_CHECK]</pre>


<p style="margin-left:11%; margin-top: 1em">Alternative
syntax using properties:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 -drive file.driver=ssh[,file.user=USER],file.host=SERVER[,file.port=PORT],file.path=PATH[,file.host_key_check=HOST_KEY_CHECK]</pre>


<p style="margin-left:11%; margin-top: 1em"><i>ssh</i> is
the protocol.</p>

<p style="margin-left:11%; margin-top: 1em"><i>USER</i> is
the remote user. If not specified, then the local username
is tried.</p>

<p style="margin-left:11%; margin-top: 1em"><i>SERVER</i>
specifies the remote ssh server. Any ssh server can be used,
but it must implement the sftp-server protocol. Most
Unix/Linux systems should work without requiring any extra
configuration.</p>

<p style="margin-left:11%; margin-top: 1em"><i>PORT</i> is
the port number on which sshd is listening. By default the
standard ssh port (22) is used.</p>

<p style="margin-left:11%; margin-top: 1em"><i>PATH</i> is
the path to the disk image.</p>

<p style="margin-left:11%; margin-top: 1em">The optional
<i>HOST_KEY_CHECK</i> parameter controls how the remote
host's key is checked. The default is <b>yes</b> which means
to use the local <b>.ssh/known_hosts</b> file. Setting this
to <b>no</b> turns off known-hosts checking. Or you can
check that the host key matches a specific fingerprint:
<b>host_key_check=md5:78:45:8e:14:57:4f:d5:45:83:0a:0e:f3:49:82:c9:c8</b>
(<b>sha1:</b> can also be used as a prefix, but note that
OpenSSH tools only use MD5 to print fingerprints).</p>

<p style="margin-left:11%; margin-top: 1em">Currently
authentication must be done using ssh-agent. Other
authentication methods may be supported in future.</p>

<p style="margin-left:11%; margin-top: 1em">Note: Many ssh
servers do not support an <b>fsync</b>-style operation. The
ssh driver cannot guarantee that disk flush requests are
obeyed, and this causes a risk of disk corruption if the
remote server or network goes down during writes. The driver
will print a warning when <b>fsync</b> is not supported:</p>

<pre style="margin-left:15%; margin-top: 1em">warning: ssh server ssh.example.com:22 does not support fsync</pre>


<p style="margin-left:11%; margin-top: 1em">With
sufficiently new versions of libssh and OpenSSH,
<b>fsync</b> is supported.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NVMe disk
images</b> <br>
NVM Express (NVMe) storage controllers can be accessed
directly by a userspace driver in QEMU. This bypasses the
host kernel file system and block layers while retaining
QEMU block layer functionalities, such as block jobs, I/O
throttling, image formats, etc. Disk I/O performance is
typically higher than with <b>-drive file=/dev/sda</b> using
either thread pool or linux-aio.</p>

<p style="margin-left:11%; margin-top: 1em">The controller
will be exclusively used by the QEMU process once started.
To be able to share storage between multiple VMs and other
applications on the host, please use the file based
protocols.</p>

<p style="margin-left:11%; margin-top: 1em">Before starting
QEMU, bind the host NVMe controller to the host vfio-pci
driver. For example:</p>
<pre style="margin-left:15%; margin-top: 1em"># modprobe vfio-pci
# lspci -n -s 0000:06:0d.0
06:0d.0 0401: 1102:0002 (rev 08)
# echo 0000:06:0d.0 &gt; /sys/bus/pci/devices/0000:06:0d.0/driver/unbind
# echo 1102 0002 &gt; /sys/bus/pci/drivers/vfio-pci/new_id


# qemu-system-x86_64 -drive file=nvme://HOST:BUS:SLOT.FUNC/NAMESPACE</pre>


<p style="margin-left:11%; margin-top: 1em">Alternative
syntax using properties:</p>

<pre style="margin-left:15%; margin-top: 1em">qemu-system-x86_64 -drive file.driver=nvme,file.device=HOST:BUS:SLOT.FUNC,file.namespace=NAMESPACE</pre>



<p style="margin-left:11%; margin-top: 1em"><i>HOST</i>:<i>BUS</i>:<i>SLOT</i>.<i>FUNC</i>
is the NVMe controller's PCI device address on the host.</p>


<p style="margin-left:11%; margin-top: 1em"><i>NAMESPACE</i>
is the NVMe namespace number, starting from 1.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Disk image
file locking</b> <br>
By default, QEMU tries to protect image files from
unexpected concurrent access, as long as it's supported by
the block protocol driver and host operating system. If
multiple QEMU processes (including QEMU emulators and
utilities) try to open the same image with conflicting
accessing modes, all but the first one will get an
error.</p>

<p style="margin-left:11%; margin-top: 1em">This feature is
currently supported by the file protocol on Linux with the
Open File Descriptor (OFD) locking API, and can be
configured to fall back to POSIX locking if the POSIX host
doesn't support Linux OFD locking.</p>

<p style="margin-left:11%; margin-top: 1em">To explicitly
enable image locking, specify &quot;locking=on&quot; in the
file protocol driver options. If OFD locking is not
possible, a warning will be printed and the POSIX locking
API will be used. In this case there is a risk that the lock
will get silently lost when doing hot plugging and block
jobs, due to the shortcomings of the POSIX locking API.</p>

<p style="margin-left:11%; margin-top: 1em">QEMU
transparently handles lock handover during shared storage
migration. For shared virtual disk images between multiple
VMs, the &quot;share-rw&quot; device option should be
used.</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
guest has exclusive write access to its disk image. If the
guest can safely share the disk image with other writers the
<b>-device ...,share-rw=on</b> parameter can be used. This
is only safe if the guest is running software, such as a
cluster file system, that coordinates disk accesses to avoid
corruption.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
share-rw=on only declares the guest's ability to share the
disk. Some QEMU features, such as image file formats,
require exclusive write access to the disk image and this is
unaffected by the share-rw=on option.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
locking can be fully disabled by &quot;locking=off&quot;
block device option. In the command line, the option is
usually in the form of &quot;file.locking=off&quot; as the
protocol driver is normally placed as a &quot;file&quot;
child under a format driver. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">-blockdev driver=qcow2,file.filename=/path/to/image,file.locking=off,file.driver=file</pre>


<p style="margin-left:11%; margin-top: 1em">To check if
image locking is active, check the output of the
&quot;lslocks&quot; command on host and see if there are
locks held by the QEMU process on the image file. More than
one byte could be locked by the QEMU instance, each byte of
which reflects a particular permission that is acquired or
protected by the running block driver.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Filter
drivers</b> <br>
QEMU supports several filter drivers, which don't store any
data, but perform some additional tasks, hooking io
requests. <b><br>
preallocate</b></p>

<p style="margin-left:22%;">The preallocate filter driver
is intended to be inserted between format and protocol nodes
and preallocates some additional space (expanding the
protocol file) when writing past the file&acirc;s end. This
can be useful for file-systems with slow allocation.</p>

<p style="margin-left:22%; margin-top: 1em">Supported
options: <b><br>
prealloc-align</b></p>

<p style="margin-left:32%;">On preallocation, align the
file length to this value (in bytes), default 1M.</p>

<p style="margin-left:22%;"><b>prealloc-size</b></p>

<p style="margin-left:32%;">How much to preallocate (in
bytes), default 128M.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The HTML
documentation of QEMU for more precise information and Linux
user mode emulator invocation.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Fabrice Bellard
and the QEMU Project developers</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">2022, The QEMU
Project Developers</p>
<hr>
</body>
</html>
