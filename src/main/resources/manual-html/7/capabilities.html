<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:37 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CAPABILITIES</title>

</head>
<body>

<h1 align="center">CAPABILITIES</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">capabilities -
overview of Linux capabilities</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For the purpose
of performing permission checks, traditional UNIX
implementations distinguish two categories of processes:
<i>privileged</i> processes (whose effective user ID is 0,
referred to as superuser or root), and <i>unprivileged</i>
processes (whose effective UID is nonzero). Privileged
processes bypass all kernel permission checks, while
unprivileged processes are subject to full permission
checking based on the process&rsquo;s credentials (usually:
effective UID, effective GID, and supplementary group
list).</p>

<p style="margin-left:11%; margin-top: 1em">Starting with
kernel 2.2, Linux divides the privileges traditionally
associated with superuser into distinct units, known as
<i>capabilities</i>, which can be independently enabled and
disabled. Capabilities are a per-thread attribute.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Capabilities
list</b> <br>
The following list shows the capabilities implemented on
Linux, and the operations or behaviors that each capability
permits: <b><br>
CAP_AUDIT_CONTROL</b> (since Linux 2.6.11)</p>

<p style="margin-left:22%;">Enable and disable kernel
auditing; change auditing filter rules; retrieve auditing
status and filtering rules.</p>

<p style="margin-left:11%;"><b>CAP_AUDIT_READ</b> (since
Linux 3.16)</p>

<p style="margin-left:22%;">Allow reading the audit log via
a multicast netlink socket.</p>

<p style="margin-left:11%;"><b>CAP_AUDIT_WRITE</b> (since
Linux 2.6.11)</p>

<p style="margin-left:22%;">Write records to kernel
auditing log.</p>

<p style="margin-left:11%;"><b>CAP_BLOCK_SUSPEND</b> (since
Linux 3.5)</p>

<p style="margin-left:22%;">Employ features that can block
system suspend (<a href="https://man.page/7/epoll">epoll(7)</a> <b>EPOLLWAKEUP</b>,
<i>/proc/sys/wake_lock</i>).</p>

<p style="margin-left:11%;"><b>CAP_BPF</b> (since Linux
5.8)</p>

<p style="margin-left:22%;">Employ privileged BPF
operations; see <a href="https://man.page/2/bpf">bpf(2)</a> and <a href="https://man.page/7/bpf-helpers">bpf-helpers(7)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">This capability
was added in Linux 5.8 to separate out BPF functionality
from the overloaded <b>CAP_SYS_ADMIN</b> capability.</p>

<p style="margin-left:11%;"><b>CAP_CHECKPOINT_RESTORE</b>
(since Linux 5.9)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Update <i>/proc/sys/kernel/ns_last_pid</i> (see
<a href="https://man.page/7/pid_namespaces">pid_namespaces(7)</a>);</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <i>set_tid</i> feature of
<a href="https://man.page/2/clone3">clone3(2)</a>;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>read the contents of the symbolic links in
<i>/proc/[pid]/map_files</i> for other processes.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This capability
was added in Linux 5.9 to separate out checkpoint/restore
functionality from the overloaded <b>CAP_SYS_ADMIN</b>
capability.</p>

<p style="margin-left:11%;"><b>CAP_CHOWN</b></p>

<p style="margin-left:22%;">Make arbitrary changes to file
UIDs and GIDs (see <a href="https://man.page/2/chown">chown(2)</a>).</p>

<p style="margin-left:11%;"><b>CAP_DAC_OVERRIDE</b></p>

<p style="margin-left:22%;">Bypass file read, write, and
execute permission checks. (DAC is an abbreviation of
&quot;discretionary access control&quot;.)</p>

<p style="margin-left:11%;"><b>CAP_DAC_READ_SEARCH</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Bypass file read permission checks and directory read
and execute permission checks;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>invoke <a href="https://man.page/2/open_by_handle_at">open_by_handle_at(2)</a>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use the <a href="https://man.page/2/linkat">linkat(2)</a> <b>AT_EMPTY_PATH</b> flag to
create a link to a file referred to by a file
descriptor.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_FOWNER</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Bypass permission checks on operations that normally
require the filesystem UID of the process to match the UID
of the file (e.g., <a href="https://man.page/2/chmod">chmod(2)</a>, <a href="https://man.page/2/utime">utime(2)</a>),
excluding those operations covered by
<b>CAP_DAC_OVERRIDE</b> and <b>CAP_DAC_READ_SEARCH</b>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set inode flags (see <a href="https://man.page/2/ioctl_iflags">ioctl_iflags(2)</a>) on
arbitrary files;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set Access Control Lists (ACLs) on arbitrary files;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>ignore directory sticky bit on file deletion;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>modify <i>user</i> extended attributes on sticky
directory owned by any user;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>specify <b>O_NOATIME</b> for arbitrary files in
<a href="https://man.page/2/open">open(2)</a> and <a href="https://man.page/2/fcntl">fcntl(2)</a>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_FSETID</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Don&rsquo;t clear set-user-ID and set-group-ID mode bits
when a file is modified;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set the set-group-ID bit for a file whose GID does not
match the filesystem or any of the supplementary GIDs of the
calling process.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_IPC_LOCK</b></p>

<p style="margin-left:22%;">Lock memory (<a href="https://man.page/2/mlock">mlock(2)</a>,
<a href="https://man.page/2/mlockall">mlockall(2)</a>, <a href="https://man.page/2/mmap">mmap(2)</a>, <a href="https://man.page/2/shmctl">shmctl(2)</a>).</p>

<p style="margin-left:11%;"><b>CAP_IPC_OWNER</b></p>

<p style="margin-left:22%;">Bypass permission checks for
operations on System V IPC objects.</p>

<p style="margin-left:11%;"><b>CAP_KILL</b></p>

<p style="margin-left:22%;">Bypass permission checks for
sending signals (see <a href="https://man.page/2/kill">kill(2)</a>). This includes use of
the <a href="https://man.page/2/ioctl">ioctl(2)</a> <b>KDSIGACCEPT</b> operation.</p>

<p style="margin-left:11%;"><b>CAP_LEASE</b> (since Linux
2.4)</p>

<p style="margin-left:22%;">Establish leases on arbitrary
files (see <a href="https://man.page/2/fcntl">fcntl(2)</a>).</p>

<p style="margin-left:11%;"><b>CAP_LINUX_IMMUTABLE</b></p>

<p style="margin-left:22%;">Set the <b>FS_APPEND_FL</b> and
<b>FS_IMMUTABLE_FL</b> inode flags (see
<a href="https://man.page/2/ioctl_iflags">ioctl_iflags(2)</a>).</p>

<p style="margin-left:11%;"><b>CAP_MAC_ADMIN</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">Allow MAC configuration or
state changes. Implemented for the Smack Linux Security
Module (LSM).</p>

<p style="margin-left:11%;"><b>CAP_MAC_OVERRIDE</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">Override Mandatory Access
Control (MAC). Implemented for the Smack LSM.</p>

<p style="margin-left:11%;"><b>CAP_MKNOD</b> (since Linux
2.4)</p>

<p style="margin-left:22%;">Create special files using
<a href="https://man.page/2/mknod">mknod(2)</a>.</p>

<p style="margin-left:11%;"><b>CAP_NET_ADMIN</b></p>

<p style="margin-left:22%;">Perform various network-related
operations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>interface configuration;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>administration of IP firewall, masquerading, and
accounting;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>modify routing tables;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>bind to any address for transparent proxying;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set type-of-service (TOS);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>clear driver statistics;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set promiscuous mode;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>enabling multicasting;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <a href="https://man.page/2/setsockopt">setsockopt(2)</a> to set the following socket
options: <b>SO_DEBUG</b>, <b>SO_MARK</b>, <b>SO_PRIORITY</b>
(for a priority outside the range 0 to 6),
<b>SO_RCVBUFFORCE</b>, and <b>SO_SNDBUFFORCE</b>.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>CAP_NET_BIND_SERVICE</b></p>

<p style="margin-left:22%;">Bind a socket to Internet
domain privileged ports (port numbers less than 1024).</p>

<p style="margin-left:11%;"><b>CAP_NET_BROADCAST</b></p>

<p style="margin-left:22%;">(Unused) Make socket
broadcasts, and listen to multicasts.</p>

<p style="margin-left:11%;"><b>CAP_NET_RAW</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="69%">


<p>Use RAW and PACKET sockets;</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="69%">


<p>bind to any address for transparent proxying.</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_PERFMON</b> (since Linux
5.8)</p>

<p style="margin-left:22%;">Employ various
performance-monitoring mechanisms, including:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>call <a href="https://man.page/2/perf_event_open">perf_event_open(2)</a>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ various BPF operations that have performance
implications.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This capability
was added in Linux 5.8 to separate out performance
monitoring functionality from the overloaded
<b>CAP_SYS_ADMIN</b> capability. See also the kernel source
file <i>Documentation/admin-guide/perf-security.rst</i>.</p>

<p style="margin-left:11%;"><b>CAP_SETGID</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Make arbitrary manipulations of process GIDs and
supplementary GID list;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>forge GID when passing socket credentials via UNIX
domain sockets;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>write a group ID mapping in a user namespace (see
<a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>).</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SETFCAP</b> (since Linux
2.6.24)</p>

<p style="margin-left:22%;">Set arbitrary capabilities on a
file.</p>

<p style="margin-left:11%;"><b>CAP_SETPCAP</b></p>

<p style="margin-left:22%;">If file capabilities are
supported (i.e., since Linux 2.6.24): add any capability
from the calling thread&rsquo;s bounding set to its
inheritable set; drop capabilities from the bounding set
(via <a href="https://man.page/2/prctl">prctl(2)</a> <b>PR_CAPBSET_DROP</b>); make changes
to the <i>securebits</i> flags.</p>

<p style="margin-left:22%; margin-top: 1em">If file
capabilities are not supported (i.e., kernels before Linux
2.6.24): grant or remove any capability in the
caller&rsquo;s permitted capability set to or from any other
process. (This property of <b>CAP_SETPCAP</b> is not
available when the kernel is configured to support file
capabilities, since <b>CAP_SETPCAP</b> has entirely
different semantics for such kernels.)</p>

<p style="margin-left:11%;"><b>CAP_SETUID</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Make arbitrary manipulations of process UIDs
(<a href="https://man.page/2/setuid">setuid(2)</a>, <a href="https://man.page/2/setreuid">setreuid(2)</a>, <a href="https://man.page/2/setresuid">setresuid(2)</a>,
<a href="https://man.page/2/setfsuid">setfsuid(2)</a>);</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>forge UID when passing socket credentials via UNIX
domain sockets;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>write a user ID mapping in a user namespace (see
<a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>).</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_ADMIN</b></p>

<p style="margin-left:22%;"><i>Note</i>: this capability is
overloaded; see <i>Notes to kernel developers</i>,
below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Perform a range of system administration operations
including: <a href="https://man.page/2/quotactl">quotactl(2)</a>, <a href="https://man.page/2/mount">mount(2)</a>,
<a href="https://man.page/2/umount">umount(2)</a>, <a href="https://man.page/2/pivot_root">pivot_root(2)</a>, <a href="https://man.page/2/swapon">swapon(2)</a>,
<a href="https://man.page/2/swapoff">swapoff(2)</a>, <a href="https://man.page/2/sethostname">sethostname(2)</a>, and
<a href="https://man.page/2/setdomainname">setdomainname(2)</a>;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform privileged <a href="https://man.page/2/syslog">syslog(2)</a> operations (since
Linux 2.6.37, <b>CAP_SYSLOG</b> should be used to permit
such operations);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform <b>VM86_REQUEST_IRQ vm86</b>(2) command;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>access the same checkpoint/restore functionality that is
governed by <b>CAP_CHECKPOINT_RESTORE</b> (but the latter,
weaker capability is preferred for accessing that
functionality).</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform the same BPF operations as are governed by
<b>CAP_BPF</b> (but the latter, weaker capability is
preferred for accessing that functionality).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the same performance monitoring mechanisms as are
governed by <b>CAP_PERFMON</b> (but the latter, weaker
capability is preferred for accessing that
functionality).</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform <b>IPC_SET</b> and <b>IPC_RMID</b> operations on
arbitrary System V IPC objects;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override <b>RLIMIT_NPROC</b> resource limit;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform operations on <i>trusted</i> and <i>security</i>
extended attributes (see <a href="https://man.page/7/xattr">xattr(7)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <a href="https://man.page/2/lookup_dcookie">lookup_dcookie(2)</a>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <a href="https://man.page/2/ioprio_set">ioprio_set(2)</a> to assign
<b>IOPRIO_CLASS_RT</b> and (before Linux 2.6.25)
<b>IOPRIO_CLASS_IDLE</b> I/O scheduling classes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>forge PID when passing socket credentials via UNIX
domain sockets;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>exceed <i>/proc/sys/fs/file-max</i>, the system-wide
limit on the number of open files, in system calls that open
files (e.g., <a href="https://man.page/2/accept">accept(2)</a>, <a href="https://man.page/2/execve">execve(2)</a>,
<a href="https://man.page/2/open">open(2)</a>, <a href="https://man.page/2/pipe">pipe(2)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ <b>CLONE_*</b> flags that create new namespaces
with <a href="https://man.page/2/clone">clone(2)</a> and <a href="https://man.page/2/unshare">unshare(2)</a> (but, since Linux
3.8, creating user namespaces does not require any
capability);</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>access privileged <i>perf</i> event information;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>call <a href="https://man.page/2/setns">setns(2)</a> (requires <b>CAP_SYS_ADMIN</b> in
the <i>target</i> namespace);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>call <a href="https://man.page/2/fanotify_init">fanotify_init(2)</a>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform privileged <b>KEYCTL_CHOWN</b> and
<b>KEYCTL_SETPERM keyctl</b>(2) operations;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform <a href="https://man.page/2/madvise">madvise(2)</a> <b>MADV_HWPOISON</b>
operation;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <b>TIOCSTI ioctl</b>(2) to insert characters
into the input queue of a terminal other than the
caller&rsquo;s controlling terminal;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the obsolete <a href="https://man.page/2/nfsservctl">nfsservctl(2)</a> system
call;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the obsolete <a href="https://man.page/2/bdflush">bdflush(2)</a> system call;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform various privileged block-device <a href="https://man.page/2/ioctl">ioctl(2)</a>
operations;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform various privileged filesystem <a href="https://man.page/2/ioctl">ioctl(2)</a>
operations;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform privileged <a href="https://man.page/2/ioctl">ioctl(2)</a> operations on the
<i>/dev/random</i> device (see <a href="https://man.page/4/random">random(4)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>install a <a href="https://man.page/2/seccomp">seccomp(2)</a> filter without first having
to set the <i>no_new_privs</i> thread attribute;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>modify allow/deny rules for device control groups;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <a href="https://man.page/2/ptrace">ptrace(2)</a>
<b>PTRACE_SECCOMP_GET_FILTER</b> operation to dump
tracee&rsquo;s seccomp filters;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <a href="https://man.page/2/ptrace">ptrace(2)</a> <b>PTRACE_SETOPTIONS</b>
operation to suspend the tracee&rsquo;s seccomp protections
(i.e., the <b>PTRACE_O_SUSPEND_SECCOMP</b> flag);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform administrative operations on many device
drivers;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>modify autogroup nice values by writing to
<i>/proc/[pid]/autogroup</i> (see <a href="https://man.page/7/sched">sched(7)</a>).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_BOOT</b></p>

<p style="margin-left:22%;">Use <a href="https://man.page/2/reboot">reboot(2)</a> and
<a href="https://man.page/2/kexec_load">kexec_load(2)</a>.</p>

<p style="margin-left:11%;"><b>CAP_SYS_CHROOT</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="60%">


<p>Use <a href="https://man.page/2/chroot">chroot(2)</a>;</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="60%">


<p>change mount namespaces using <a href="https://man.page/2/setns">setns(2)</a>.</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_MODULE</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Load and unload kernel modules (see
<a href="https://man.page/2/init_module">init_module(2)</a> and <a href="https://man.page/2/delete_module">delete_module(2)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>in kernels before 2.6.25: drop capabilities from the
system-wide capability bounding set.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_NICE</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Lower the process nice value (<a href="https://man.page/2/nice">nice(2)</a>,
<a href="https://man.page/2/setpriority">setpriority(2)</a>) and change the nice value for
arbitrary processes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set real-time scheduling policies for calling process,
and set scheduling policies and priorities for arbitrary
processes (<a href="https://man.page/2/sched_setscheduler">sched_setscheduler(2)</a>,
<a href="https://man.page/2/sched_setparam">sched_setparam(2)</a>, <a href="https://man.page/2/sched_setattr">sched_setattr(2)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set CPU affinity for arbitrary processes
(<a href="https://man.page/2/sched_setaffinity">sched_setaffinity(2)</a>);</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set I/O scheduling class and priority for arbitrary
processes (<a href="https://man.page/2/ioprio_set">ioprio_set(2)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>apply <a href="https://man.page/2/migrate_pages">migrate_pages(2)</a> to arbitrary processes and
allow processes to be migrated to arbitrary nodes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>apply <a href="https://man.page/2/move_pages">move_pages(2)</a> to arbitrary processes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use the <b>MPOL_MF_MOVE_ALL</b> flag with
<a href="https://man.page/2/mbind">mbind(2)</a> and <a href="https://man.page/2/move_pages">move_pages(2)</a>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_PACCT</b></p>

<p style="margin-left:22%;">Use <a href="https://man.page/2/acct">acct(2)</a>.</p>

<p style="margin-left:11%;"><b>CAP_SYS_PTRACE</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Trace arbitrary processes using <a href="https://man.page/2/ptrace">ptrace(2)</a>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>apply <a href="https://man.page/2/get_robust_list">get_robust_list(2)</a> to arbitrary
processes;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>transfer data to or from the memory of arbitrary
processes using <a href="https://man.page/2/process_vm_readv">process_vm_readv(2)</a> and
<a href="https://man.page/2/process_vm_writev">process_vm_writev(2)</a>;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>inspect processes using <a href="https://man.page/2/kcmp">kcmp(2)</a>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_RAWIO</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Perform I/O port operations (<a href="https://man.page/2/iopl">iopl(2)</a> and
<a href="https://man.page/2/ioperm">ioperm(2)</a>);</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>access <i>/proc/kcore</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <b>FIBMAP ioctl</b>(2) operation;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>open devices for accessing x86 model-specific registers
(MSRs, see <a href="https://man.page/4/msr">msr(4)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>update <i>/proc/sys/vm/mmap_min_addr</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>create memory mappings at addresses below the value
specified by <i>/proc/sys/vm/mmap_min_addr</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>map files in <i>/proc/bus/pci</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>open <i>/dev/mem</i> and <i>/dev/kmem</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform various SCSI device commands;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform certain operations on <a href="https://man.page/4/hpsa">hpsa(4)</a> and
<a href="https://man.page/4/cciss">cciss(4)</a> devices;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform a range of device-specific operations on other
devices.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_RESOURCE</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Use reserved space on ext2 filesystems;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>make <a href="https://man.page/2/ioctl">ioctl(2)</a> calls controlling ext3
journaling;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override disk quota limits;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>increase resource limits (see <a href="https://man.page/2/setrlimit">setrlimit(2)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override <b>RLIMIT_NPROC</b> resource limit;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override maximum number of consoles on console
allocation;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override maximum number of keymaps;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>allow more than 64hz interrupts from the real-time
clock;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>raise <i>msg_qbytes</i> limit for a System V message
queue above the limit in <i>/proc/sys/kernel/msgmnb</i> (see
<a href="https://man.page/2/msgop">msgop(2)</a> and <a href="https://man.page/2/msgctl">msgctl(2)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>allow the <b>RLIMIT_NOFILE</b> resource limit on the
number of &quot;in-flight&quot; file descriptors to be
bypassed when passing file descriptors to another process
via a UNIX domain socket (see <a href="https://man.page/7/unix">unix(7)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override the <i>/proc/sys/fs/pipe-size-max</i> limit
when setting the capacity of a pipe using the
<b>F_SETPIPE_SZ fcntl</b>(2) command;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <b>F_SETPIPE_SZ</b> to increase the capacity of a
pipe above the limit specified by
<i>/proc/sys/fs/pipe-max-size</i>;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override <i>/proc/sys/fs/mqueue/queues_max,
/proc/sys/fs/mqueue/msg_max,</i> and
<i>/proc/sys/fs/mqueue/msgsize_max</i> limits when creating
POSIX message queues (see <a href="https://man.page/7/mq_overview">mq_overview(7)</a>);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <a href="https://man.page/2/prctl">prctl(2)</a> <b>PR_SET_MM</b>
operation;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set <i>/proc/[pid]/oom_score_adj</i> to a value lower
than the value last set by a process with
<b>CAP_SYS_RESOURCE</b>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_TIME</b></p>

<p style="margin-left:22%;">Set system clock
(<a href="https://man.page/2/settimeofday">settimeofday(2)</a>, <a href="https://man.page/2/stime">stime(2)</a>,
<a href="https://man.page/2/adjtimex">adjtimex(2)</a>); set real-time (hardware) clock.</p>

<p style="margin-left:11%;"><b>CAP_SYS_TTY_CONFIG</b></p>

<p style="margin-left:22%;">Use <a href="https://man.page/2/vhangup">vhangup(2)</a>; employ
various privileged <a href="https://man.page/2/ioctl">ioctl(2)</a> operations on virtual
terminals.</p>

<p style="margin-left:11%;"><b>CAP_SYSLOG</b> (since Linux
2.6.37)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Perform privileged <a href="https://man.page/2/syslog">syslog(2)</a> operations. See
<a href="https://man.page/2/syslog">syslog(2)</a> for information on which operations require
privilege.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>View kernel addresses exposed via <i>/proc</i> and other
interfaces when <i>/proc/sys/kernel/kptr_restrict</i> has
the value 1. (See the discussion of the <i>kptr_restrict</i>
in <a href="https://man.page/5/proc">proc(5)</a>.)</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_WAKE_ALARM</b> (since
Linux 3.0)</p>

<p style="margin-left:22%;">Trigger something that will
wake up the system (set <b>CLOCK_REALTIME_ALARM</b> and
<b>CLOCK_BOOTTIME_ALARM</b> timers).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Past and
current implementation</b> <br>
A full implementation of capabilities requires that:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>For all privileged operations, the kernel must check
whether the thread has the required capability in its
effective set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The kernel must provide system calls allowing a
thread&rsquo;s capability sets to be changed and
retrieved.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The filesystem must support attaching capabilities to an
executable file, so that a process gains those capabilities
when the file is executed.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Before kernel
2.6.24, only the first two of these requirements are met;
since kernel 2.6.24, all three requirements are met.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Notes to
kernel developers</b> <br>
When adding a new kernel feature that should be governed by
a capability, consider the following points.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The goal of capabilities is
divide the power of superuser into pieces, such that if a
program that has one or more capabilities is compromised,
its power to do damage to the system would be less than the
same program running with root privilege.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>You have the choice of either creating a new capability
for your new feature, or associating the feature with one of
the existing capabilities. In order to keep the set of
capabilities to a manageable size, the latter option is
preferable, unless there are compelling reasons to take the
former option. (There is also a technical limit: the size of
capability sets is currently limited to 64 bits.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>To determine which existing capability might best be
associated with your new feature, review the list of
capabilities above in order to find a &quot;silo&quot; into
which your new feature best fits. One approach to take is to
determine if there are other features requiring capabilities
that will always be used along with the new feature. If the
new feature is useless without these other features, you
should use the same capability as the other features.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p><i>Don&rsquo;t</i> choose <b>CAP_SYS_ADMIN</b> if you
can possibly avoid it! A vast proportion of existing
capability checks are associated with this capability (see
the partial list above). It can plausibly be called
&quot;the new root&quot;, since on the one hand, it confers
a wide range of powers, and on the other hand, its broad
scope means that this is the capability that is required by
many privileged programs. Don&rsquo;t make the problem
worse. The only new features that should be associated with
<b>CAP_SYS_ADMIN</b> are ones that <i>closely</i> match
existing uses in that silo.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If you have determined that it really is necessary to
create a new capability for your feature, don&rsquo;t make
or name it as a &quot;single-use&quot; capability. Thus, for
example, the addition of the highly specific
<b>CAP_SYS_PACCT</b> was probably a mistake. Instead, try to
identify and name your new capability as a broader silo into
which other related future use cases might fit.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Thread
capability sets</b> <br>
Each thread has the following capability sets containing
zero or more of the above capabilities: <i><br>
Permitted</i></p>

<p style="margin-left:22%;">This is a limiting superset for
the effective capabilities that the thread may assume. It is
also a limiting superset for the capabilities that may be
added to the inheritable set by a thread that does not have
the <b>CAP_SETPCAP</b> capability in its effective set.</p>

<p style="margin-left:22%; margin-top: 1em">If a thread
drops a capability from its permitted set, it can never
reacquire that capability (unless it <a href="https://man.page/2/execve">execve(2)</a>s
either a set-user-ID-root program, or a program whose
associated file capabilities grant that capability).</p>

<p style="margin-left:11%;"><i>Inheritable</i></p>

<p style="margin-left:22%;">This is a set of capabilities
preserved across an <a href="https://man.page/2/execve">execve(2)</a>. Inheritable
capabilities remain inheritable when executing any program,
and inheritable capabilities are added to the permitted set
when executing a program that has the corresponding bits set
in the file inheritable set.</p>

<p style="margin-left:22%; margin-top: 1em">Because
inheritable capabilities are not generally preserved across
<a href="https://man.page/2/execve">execve(2)</a> when running as a non-root user,
applications that wish to run helper programs with elevated
capabilities should consider using ambient capabilities,
described below.</p>

<p style="margin-left:11%;"><i>Effective</i></p>

<p style="margin-left:22%;">This is the set of capabilities
used by the kernel to perform permission checks for the
thread.</p>

<p style="margin-left:11%;"><i>Bounding</i> (per-thread
since Linux 2.6.25)</p>

<p style="margin-left:22%;">The capability bounding set is
a mechanism that can be used to limit the capabilities that
are gained during <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Since Linux
2.6.25, this is a per-thread capability set. In older
kernels, the capability bounding set was a system wide
attribute shared by all threads on the system.</p>

<p style="margin-left:22%; margin-top: 1em">For more
details on the capability bounding set, see below.</p>

<p style="margin-left:11%;"><i>Ambient</i> (since Linux
4.3)</p>

<p style="margin-left:22%;">This is a set of capabilities
that are preserved across an <a href="https://man.page/2/execve">execve(2)</a> of a program
that is not privileged. The ambient capability set obeys the
invariant that no capability can ever be ambient if it is
not both permitted and inheritable.</p>

<p style="margin-left:22%; margin-top: 1em">The ambient
capability set can be directly modified using
<a href="https://man.page/2/prctl">prctl(2)</a>. Ambient capabilities are automatically
lowered if either of the corresponding permitted or
inheritable capabilities is lowered.</p>

<p style="margin-left:22%; margin-top: 1em">Executing a
program that changes UID or GID due to the set-user-ID or
set-group-ID bits or executing a program that has any file
capabilities set will clear the ambient set. Ambient
capabilities are added to the permitted set and assigned to
the effective set when <a href="https://man.page/2/execve">execve(2)</a> is called. If
ambient capabilities cause a process&rsquo;s permitted and
effective capabilities to increase during an
<a href="https://man.page/2/execve">execve(2)</a>, this does not trigger the secure-execution
mode described in <b>ld.so</b>(8).</p>

<p style="margin-left:11%; margin-top: 1em">A child created
via <a href="https://man.page/2/fork">fork(2)</a> inherits copies of its parent&rsquo;s
capability sets. See below for a discussion of the treatment
of capabilities during <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Using
<a href="https://man.page/2/capset">capset(2)</a>, a thread may manipulate its own capability
sets (see below).</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
3.2, the file <i>/proc/sys/kernel/cap_last_cap</i> exposes
the numerical value of the highest capability supported by
the running kernel; this can be used to determine the
highest bit that may be set in a capability set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
capabilities</b> <br>
Since kernel 2.6.24, the kernel supports associating
capability sets with an executable file using
<b>setcap</b>(8). The file capability sets are stored in an
extended attribute (see <a href="https://man.page/2/setxattr">setxattr(2)</a> and
<a href="https://man.page/7/xattr">xattr(7)</a>) named <i>security.capability</i>. Writing
to this extended attribute requires the <b>CAP_SETFCAP</b>
capability. The file capability sets, in conjunction with
the capability sets of the thread, determine the
capabilities of a thread after an <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The three file
capability sets are: <i><br>
Permitted</i> (formerly known as <i>forced</i>):</p>

<p style="margin-left:22%;">These capabilities are
automatically permitted to the thread, regardless of the
thread&rsquo;s inheritable capabilities.</p>

<p style="margin-left:11%;"><i>Inheritable</i> (formerly
known as <i>allowed</i>):</p>

<p style="margin-left:22%;">This set is ANDed with the
thread&rsquo;s inheritable set to determine which
inheritable capabilities are enabled in the permitted set of
the thread after the <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%;"><i>Effective</i>:</p>

<p style="margin-left:22%;">This is not a set, but rather
just a single bit. If this bit is set, then during an
<a href="https://man.page/2/execve">execve(2)</a> all of the new permitted capabilities for
the thread are also raised in the effective set. If this bit
is not set, then after an <a href="https://man.page/2/execve">execve(2)</a>, none of the new
permitted capabilities is in the new effective set.</p>

<p style="margin-left:22%; margin-top: 1em">Enabling the
file effective capability bit implies that any file
permitted or inheritable capability that causes a thread to
acquire the corresponding permitted capability during an
<a href="https://man.page/2/execve">execve(2)</a> (see the transformation rules described
below) will also acquire that capability in its effective
set. Therefore, when assigning capabilities to a file
(<b>setcap</b>(8), <a href="https://man.page/3/cap_set_file">cap_set_file(3)</a>,
<a href="https://man.page/3/cap_set_fd">cap_set_fd(3)</a>), if we specify the effective flag as
being enabled for any capability, then the effective flag
must also be specified as enabled for all other capabilities
for which the corresponding permitted or inheritable flags
is enabled.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
capability extended attribute versioning</b> <br>
To allow extensibility, the kernel supports a scheme to
encode a version number inside the
<i>security.capability</i> extended attribute that is used
to implement file capabilities. These version numbers are
internal to the implementation, and not directly visible to
user-space applications. To date, the following versions are
supported: <b><br>
VFS_CAP_REVISION_1</b></p>

<p style="margin-left:22%;">This was the original file
capability implementation, which supported 32-bit masks for
file capabilities.</p>

<p style="margin-left:11%;"><b>VFS_CAP_REVISION_2</b>
(since Linux 2.6.25)</p>

<p style="margin-left:22%;">This version allows for file
capability masks that are 64 bits in size, and was necessary
as the number of supported capabilities grew beyond 32. The
kernel transparently continues to support the execution of
files that have 32-bit version 1 capability masks, but when
adding capabilities to files that did not previously have
capabilities, or modifying the capabilities of existing
files, it automatically uses the version 2 scheme (or
possibly the version 3 scheme, as described below).</p>

<p style="margin-left:11%;"><b>VFS_CAP_REVISION_3</b>
(since Linux 4.14)</p>

<p style="margin-left:22%;">Version 3 file capabilities are
provided to support namespaced file capabilities (described
below).</p>

<p style="margin-left:22%; margin-top: 1em">As with version
2 file capabilities, version 3 capability masks are 64 bits
in size. But in addition, the root user ID of namespace is
encoded in the <i>security.capability</i> extended
attribute. (A namespace&rsquo;s root user ID is the value
that user ID 0 inside that namespace maps to in the initial
user namespace.)</p>

<p style="margin-left:22%; margin-top: 1em">Version 3 file
capabilities are designed to coexist with version 2
capabilities; that is, on a modern Linux system, there may
be some files with version 2 capabilities while others have
version 3 capabilities.</p>

<p style="margin-left:11%; margin-top: 1em">Before Linux
4.14, the only kind of file capability extended attribute
that could be attached to a file was a
<b>VFS_CAP_REVISION_2</b> attribute. Since Linux 4.14, the
version of the <i>security.capability</i> extended attribute
that is attached to a file depends on the circumstances in
which the attribute was created.</p>

<p style="margin-left:11%; margin-top: 1em">Starting with
Linux 4.14, a <i>security.capability</i> extended attribute
is automatically created as (or converted to) a version 3
(<b>VFS_CAP_REVISION_3</b>) attribute if both of the
following are true:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(1)</p></td>
<td width="2%"></td>
<td width="83%">


<p>The thread writing the attribute resides in a noninitial
user namespace. (More precisely: the thread resides in a
user namespace other than the one from which the underlying
filesystem was mounted.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(2)</p></td>
<td width="2%"></td>
<td width="83%">


<p>The thread has the <b>CAP_SETFCAP</b> capability over
the file inode, meaning that (a) the thread has the
<b>CAP_SETFCAP</b> capability in its own user namespace; and
(b) the UID and GID of the file inode have mappings in the
writer&rsquo;s user namespace.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">When a
<b>VFS_CAP_REVISION_3</b> <i>security.capability</i>
extended attribute is created, the root user ID of the
creating thread&rsquo;s user namespace is saved in the
extended attribute.</p>

<p style="margin-left:11%; margin-top: 1em">By contrast,
creating or modifying a <i>security.capability</i> extended
attribute from a privileged (<b>CAP_SETFCAP</b>) thread that
resides in the namespace where the underlying filesystem was
mounted (this normally means the initial user namespace)
automatically results in the creation of a version 2
(<b>VFS_CAP_REVISION_2</b>) attribute.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
creation of a version 3 <i>security.capability</i> extended
attribute is automatic. That is to say, when a user-space
application writes (<a href="https://man.page/2/setxattr">setxattr(2)</a>) a
<i>security.capability</i> attribute in the version 2
format, the kernel will automatically create a version 3
attribute if the attribute is created in the circumstances
described above. Correspondingly, when a version 3
<i>security.capability</i> attribute is retrieved
(<a href="https://man.page/2/getxattr">getxattr(2)</a>) by a process that resides inside a user
namespace that was created by the root user ID (or a
descendant of that user namespace), the returned attribute
is (automatically) simplified to appear as a version 2
attribute (i.e., the returned value is the size of a version
2 attribute and does not include the root user ID). These
automatic translations mean that no changes are required to
user-space tools (e.g., <a href="https://man.page/1/setcap">setcap(1)</a> and
<a href="https://man.page/1/getcap">getcap(1)</a>) in order for those tools to be used to
create and retrieve version 3 <i>security.capability</i>
attributes.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
file can have either a version 2 or a version 3
<i>security.capability</i> extended attribute associated
with it, but not both: creation or modification of the
<i>security.capability</i> extended attribute will
automatically modify the version according to the
circumstances in which the extended attribute is created or
modified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Transformation
of capabilities during execve()</b> <br>
During an <a href="https://man.page/2/execve">execve(2)</a>, the kernel calculates the new
capabilities of the process using the following
algorithm:</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(ambient)
= (file is privileged) ? 0 : P(ambient)</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(permitted)
= (P(inheritable) &amp; F(inheritable)) | <br>
(F(permitted) &amp; P(bounding)) | P&rsquo;(ambient)</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(effective)
= F(effective) ? P&rsquo;(permitted) : P&rsquo;(ambient)</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(inheritable)
= P(inheritable) [i.e., unchanged]</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(bounding)
= P(bounding) [i.e., unchanged]</p>

<p style="margin-left:11%; margin-top: 1em">where:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="6%">


<p style="margin-top: 1em">P()</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">denotes the value of a thread
capability set before the <a href="https://man.page/2/execve">execve(2)</a></p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="6%">


<p>P&rsquo;()</p></td>
<td width="3%"></td>
<td width="74%">


<p>denotes the value of a thread capability set after the
<a href="https://man.page/2/execve">execve(2)</a></p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="6%">


<p>F()</p></td>
<td width="3%"></td>
<td width="74%">


<p>denotes a file capability set</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note the
following details relating to the above capability
transformation rules:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The ambient capability set is
present only since Linux 4.3. When determining the
transformation of the ambient set during <a href="https://man.page/2/execve">execve(2)</a>, a
privileged file is one that has capabilities or has the
set-user-ID or set-group-ID bit set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Prior to Linux 2.6.25, the bounding set was a
system-wide attribute shared by all threads. That
system-wide value was employed to calculate the new
permitted set during <a href="https://man.page/2/execve">execve(2)</a> in the same manner as
shown above for <i>P(bounding)</i>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><i>Note</i>:
during the capability transitions described above, file
capabilities may be ignored (treated as empty) for the same
reasons that the set-user-ID and set-group-ID bits are
ignored; see <a href="https://man.page/2/execve">execve(2)</a>. File capabilities are
similarly ignored if the kernel was booted with the
<i>no_file_caps</i> option.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Note</i>:
according to the rules above, if a process with nonzero user
IDs performs an <a href="https://man.page/2/execve">execve(2)</a> then any capabilities that
are present in its permitted and effective sets will be
cleared. For the treatment of capabilities when a process
with a user ID of zero performs an <a href="https://man.page/2/execve">execve(2)</a>, see
below under <i>Capabilities and execution of programs by
root</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Safety
checking for capability-dumb binaries</b> <br>
A capability-dumb binary is an application that has been
marked to have file capabilities, but has not been converted
to use the <a href="https://man.page/3/libcap">libcap(3)</a> API to manipulate its
capabilities. (In other words, this is a traditional
set-user-ID-root program that has been switched to use file
capabilities, but whose code has not been modified to
understand capabilities.) For such applications, the
effective capability bit is set on the file, so that the
file permitted capabilities are automatically enabled in the
process effective set when executing the file. The kernel
recognizes a file which has the effective capability bit set
as capability-dumb for the purpose of the check described
here.</p>

<p style="margin-left:11%; margin-top: 1em">When executing
a capability-dumb binary, the kernel checks if the process
obtained all permitted capabilities that were specified in
the file permitted set, after the capability transformations
described above have been performed. (The typical reason why
this might <i>not</i> occur is that the capability bounding
set masked out some of the capabilities in the file
permitted set.) If the process did not obtain the full set
of file permitted capabilities, then <a href="https://man.page/2/execve">execve(2)</a> fails
with the error <b>EPERM</b>. This prevents possible security
risks that could arise when a capability-dumb application is
executed with less privilege that it needs. Note that, by
definition, the application could not itself recognize this
problem, since it does not employ the <a href="https://man.page/3/libcap">libcap(3)</a>
API.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Capabilities
and execution of programs by root</b> <br>
In order to mirror traditional UNIX semantics, the kernel
performs special treatment of file capabilities when a
process with UID 0 (root) executes a program and when a
set-user-ID-root program is executed.</p>

<p style="margin-left:11%; margin-top: 1em">After having
performed any changes to the process effective ID that were
triggered by the set-user-ID mode bit of the
binary&mdash;e.g., switching the effective user ID to 0
(root) because a set-user-ID-root program was
executed&mdash;the kernel calculates the file capability
sets as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If the real or effective user ID
of the process is 0 (root), then the file inheritable and
permitted sets are ignored; instead they are notionally
considered to be all ones (i.e., all capabilities enabled).
(There is one exception to this behavior, described below in
<i>Set-user-ID-root programs that have file
capabilities</i>.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the effective user ID of the process is 0 (root) or
the file effective bit is in fact enabled, then the file
effective bit is notionally defined to be one (enabled).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">These notional
values for the file&rsquo;s capability sets are then used as
described above to calculate the transformation of the
process&rsquo;s capabilities during <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Thus, when a
process with nonzero UIDs <a href="https://man.page/2/execve">execve(2)</a>s a
set-user-ID-root program that does not have capabilities
attached, or when a process whose real and effective UIDs
are zero <a href="https://man.page/2/execve">execve(2)</a>s a program, the calculation of the
process&rsquo;s new permitted capabilities simplifies
to:</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(permitted)
= P(inheritable) | P(bounding)</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(effective)
= P&rsquo;(permitted)</p>

<p style="margin-left:11%; margin-top: 1em">Consequently,
the process gains all capabilities in its permitted and
effective capability sets, except those masked out by the
capability bounding set. (In the calculation of
P&rsquo;(permitted), the P&rsquo;(ambient) term can be
simplified away because it is by definition a proper subset
of P(inheritable).)</p>

<p style="margin-left:11%; margin-top: 1em">The special
treatments of user ID 0 (root) described in this subsection
can be disabled using the securebits mechanism described
below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Set-user-ID-root
programs that have file capabilities</b> <br>
There is one exception to the behavior described under
<i>Capabilities and execution of programs by root</i>. If
(a) the binary that is being executed has capabilities
attached and (b) the real user ID of the process is
<i>not</i> 0 (root) and (c) the effective user ID of the
process <i>is</i> 0 (root), then the file capability bits
are honored (i.e., they are not notionally considered to be
all ones). The usual way in which this situation can arise
is when executing a set-UID-root program that also has file
capabilities. When such a program is executed, the process
gains just the capabilities granted by the program (i.e.,
not all capabilities, as would occur when executing a
set-user-ID-root program that does not have any associated
file capabilities).</p>

<p style="margin-left:11%; margin-top: 1em">Note that one
can assign empty capability sets to a program file, and thus
it is possible to create a set-user-ID-root program that
changes the effective and saved set-user-ID of the process
that executes the program to 0, but confers no capabilities
to that process.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capability
bounding set</b> <br>
The capability bounding set is a security mechanism that can
be used to limit the capabilities that can be gained during
an <a href="https://man.page/2/execve">execve(2)</a>. The bounding set is used in the
following ways:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">During an <a href="https://man.page/2/execve">execve(2)</a>, the
capability bounding set is ANDed with the file permitted
capability set, and the result of this operation is assigned
to the thread&rsquo;s permitted capability set. The
capability bounding set thus places a limit on the permitted
capabilities that may be granted by an executable file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>(Since Linux 2.6.25) The capability bounding set acts as
a limiting superset for the capabilities that a thread can
add to its inheritable set using <a href="https://man.page/2/capset">capset(2)</a>. This
means that if a capability is not in the bounding set, then
a thread can&rsquo;t add this capability to its inheritable
set, even if it was in its permitted capabilities, and
thereby cannot have this capability preserved in its
permitted set when it <a href="https://man.page/2/execve">execve(2)</a>s a file that has the
capability in its inheritable set.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that the
bounding set masks the file permitted capabilities, but not
the inheritable capabilities. If a thread maintains a
capability in its inheritable set that is not in its
bounding set, then it can still gain that capability in its
permitted set by executing a file that has the capability in
its inheritable set.</p>

<p style="margin-left:11%; margin-top: 1em">Depending on
the kernel version, the capability bounding set is either a
system-wide attribute, or a per-process attribute.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capability
bounding set from Linux 2.6.25 onward</b></p>

<p style="margin-left:11%; margin-top: 1em">From Linux
2.6.25, the <i>capability bounding set</i> is a per-thread
attribute. (The system-wide capability bounding set
described below no longer exists.)</p>

<p style="margin-left:11%; margin-top: 1em">The bounding
set is inherited at <a href="https://man.page/2/fork">fork(2)</a> from the thread&rsquo;s
parent, and is preserved across an <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">A thread may
remove capabilities from its capability bounding set using
the <a href="https://man.page/2/prctl">prctl(2)</a> <b>PR_CAPBSET_DROP</b> operation,
provided it has the <b>CAP_SETPCAP</b> capability. Once a
capability has been dropped from the bounding set, it cannot
be restored to that set. A thread can determine if a
capability is in its bounding set using the <a href="https://man.page/2/prctl">prctl(2)</a>
<b>PR_CAPBSET_READ</b> operation.</p>

<p style="margin-left:11%; margin-top: 1em">Removing
capabilities from the bounding set is supported only if file
capabilities are compiled into the kernel. In kernels before
Linux 2.6.33, file capabilities were an optional feature
configurable via the
<b>CONFIG_SECURITY_FILE_CAPABILITIES</b> option. Since Linux
2.6.33, the configuration option has been removed and file
capabilities are always part of the kernel. When file
capabilities are compiled into the kernel, the <b>init</b>
process (the ancestor of all processes) begins with a full
bounding set. If file capabilities are not compiled into the
kernel, then <b>init</b> begins with a full bounding set
minus <b>CAP_SETPCAP</b>, because this capability has a
different meaning when there are no file capabilities.</p>

<p style="margin-left:11%; margin-top: 1em">Removing a
capability from the bounding set does not remove it from the
thread&rsquo;s inheritable set. However it does prevent the
capability from being added back into the thread&rsquo;s
inheritable set in the future.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capability
bounding set prior to Linux 2.6.25</b></p>

<p style="margin-left:11%; margin-top: 1em">In kernels
before 2.6.25, the capability bounding set is a system-wide
attribute that affects all threads on the system. The
bounding set is accessible via the file
<i>/proc/sys/kernel/cap-bound</i>. (Confusingly, this bit
mask parameter is expressed as a signed decimal number in
<i>/proc/sys/kernel/cap-bound</i>.)</p>

<p style="margin-left:11%; margin-top: 1em">Only the
<b>init</b> process may set capabilities in the capability
bounding set; other than that, the superuser (more
precisely: a process with the <b>CAP_SYS_MODULE</b>
capability) may only clear capabilities from this set.</p>

<p style="margin-left:11%; margin-top: 1em">On a standard
system the capability bounding set always masks out the
<b>CAP_SETPCAP</b> capability. To remove this restriction
(dangerous!), modify the definition of
<b>CAP_INIT_EFF_SET</b> in <i>include/linux/capability.h</i>
and rebuild the kernel.</p>

<p style="margin-left:11%; margin-top: 1em">The system-wide
capability bounding set feature was added to Linux starting
with kernel version 2.2.11.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Effect of
user ID changes on capabilities</b> <br>
To preserve the traditional semantics for transitions
between 0 and nonzero user IDs, the kernel makes the
following changes to a thread&rsquo;s capability sets on
changes to the thread&rsquo;s real, effective, saved set,
and filesystem user IDs (using <a href="https://man.page/2/setuid">setuid(2)</a>,
<a href="https://man.page/2/setresuid">setresuid(2)</a>, or similar):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If one or more of the real,
effective or saved set user IDs was previously 0, and as a
result of the UID changes all of these IDs have a nonzero
value, then all capabilities are cleared from the permitted,
effective, and ambient capability sets.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the effective user ID is changed from 0 to nonzero,
then all capabilities are cleared from the effective
set.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the effective user ID is changed from nonzero to 0,
then the permitted set is copied to the effective set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the filesystem user ID is changed from 0 to nonzero
(see <a href="https://man.page/2/setfsuid">setfsuid(2)</a>), then the following capabilities
are cleared from the effective set: <b>CAP_CHOWN</b>,
<b>CAP_DAC_OVERRIDE</b>, <b>CAP_DAC_READ_SEARCH</b>,
<b>CAP_FOWNER</b>, <b>CAP_FSETID</b>,
<b>CAP_LINUX_IMMUTABLE</b> (since Linux 2.6.30),
<b>CAP_MAC_OVERRIDE</b>, and <b>CAP_MKNOD</b> (since Linux
2.6.30). If the filesystem UID is changed from nonzero to 0,
then any of these capabilities that are enabled in the
permitted set are enabled in the effective set.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If a thread
that has a 0 value for one or more of its user IDs wants to
prevent its permitted capability set being cleared when it
resets all of its user IDs to nonzero values, it can do so
using the <b>SECBIT_KEEP_CAPS</b> securebits flag described
below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Programmatically
adjusting capability sets</b> <br>
A thread can retrieve and change its permitted, effective,
and inheritable capability sets using the <a href="https://man.page/2/capget">capget(2)</a>
and <a href="https://man.page/2/capset">capset(2)</a> system calls. However, the use of
<a href="https://man.page/3/cap_get_proc">cap_get_proc(3)</a> and <a href="https://man.page/3/cap_set_proc">cap_set_proc(3)</a>, both
provided in the <i>libcap</i> package, is preferred for this
purpose. The following rules govern changes to the thread
capability sets:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If the caller does not have the
<b>CAP_SETPCAP</b> capability, the new inheritable set must
be a subset of the combination of the existing inheritable
and permitted sets.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>(Since Linux 2.6.25) The new inheritable set must be a
subset of the combination of the existing inheritable set
and the capability bounding set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The new permitted set must be a subset of the existing
permitted set (i.e., it is not possible to acquire permitted
capabilities that the thread does not currently have).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The new effective set must be a subset of the new
permitted set.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>The
securebits flags: establishing a capabilities-only
environment</b> <br>
Starting with kernel 2.6.26, and with a kernel in which file
capabilities are enabled, Linux implements a set of
per-thread <i>securebits</i> flags that can be used to
disable special handling of capabilities for UID 0
(<i>root</i>). These flags are as follows: <b><br>
SECBIT_KEEP_CAPS</b></p>

<p style="margin-left:22%;">Setting this flag allows a
thread that has one or more 0 UIDs to retain capabilities in
its permitted set when it switches all of its UIDs to
nonzero values. If this flag is not set, then such a UID
switch causes the thread to lose all permitted capabilities.
This flag is always cleared on an <a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">Note that even
with the <b>SECBIT_KEEP_CAPS</b> flag set, the effective
capabilities of a thread are cleared when it switches its
effective UID to a nonzero value. However, if the thread has
set this flag and its effective UID is already nonzero, and
the thread subsequently switches all other UIDs to nonzero
values, then the effective capabilities will not be
cleared.</p>

<p style="margin-left:22%; margin-top: 1em">The setting of
the <b>SECBIT_KEEP_CAPS</b> flag is ignored if the
<b>SECBIT_NO_SETUID_FIXUP</b> flag is set. (The latter flag
provides a superset of the effect of the former flag.)</p>

<p style="margin-left:22%; margin-top: 1em">This flag
provides the same functionality as the older <a href="https://man.page/2/prctl">prctl(2)</a>
<b>PR_SET_KEEPCAPS</b> operation.</p>


<p style="margin-left:11%;"><b>SECBIT_NO_SETUID_FIXUP</b></p>

<p style="margin-left:22%;">Setting this flag stops the
kernel from adjusting the process&rsquo;s permitted,
effective, and ambient capability sets when the
thread&rsquo;s effective and filesystem UIDs are switched
between zero and nonzero values. (See the subsection
<i>Effect of user ID changes on capabilities</i>.)</p>

<p style="margin-left:11%;"><b>SECBIT_NOROOT</b></p>

<p style="margin-left:22%;">If this bit is set, then the
kernel does not grant capabilities when a set-user-ID-root
program is executed, or when a process with an effective or
real UID of 0 calls <a href="https://man.page/2/execve">execve(2)</a>. (See the subsection
<i>Capabilities and execution of programs by root</i>.)</p>


<p style="margin-left:11%;"><b>SECBIT_NO_CAP_AMBIENT_RAISE</b></p>

<p style="margin-left:22%;">Setting this flag disallows
raising ambient capabilities via the <a href="https://man.page/2/prctl">prctl(2)</a>
<b>PR_CAP_AMBIENT_RAISE</b> operation.</p>

<p style="margin-left:11%; margin-top: 1em">Each of the
above &quot;base&quot; flags has a companion
&quot;locked&quot; flag. Setting any of the
&quot;locked&quot; flags is irreversible, and has the effect
of preventing further changes to the corresponding
&quot;base&quot; flag. The locked flags are:
<b>SECBIT_KEEP_CAPS_LOCKED</b>,
<b>SECBIT_NO_SETUID_FIXUP_LOCKED</b>,
<b>SECBIT_NOROOT_LOCKED</b>, and
<b>SECBIT_NO_CAP_AMBIENT_RAISE_LOCKED</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>securebits</i> flags can be modified and retrieved using
the <a href="https://man.page/2/prctl">prctl(2)</a> <b>PR_SET_SECUREBITS</b> and
<b>PR_GET_SECUREBITS</b> operations. The <b>CAP_SETPCAP</b>
capability is required to modify the flags. Note that the
<b>SECBIT_*</b> constants are available only after including
the <i>&lt;linux/securebits.h&gt;</i> header file.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>securebits</i> flags are inherited by child processes.
During an <a href="https://man.page/2/execve">execve(2)</a>, all of the flags are preserved,
except <b>SECBIT_KEEP_CAPS</b> which is always cleared.</p>

<p style="margin-left:11%; margin-top: 1em">An application
can use the following call to lock itself, and all of its
descendants, into an environment where the only way of
gaining capabilities is by executing a program with
associated file capabilities:</p>


<p style="margin-left:17%; margin-top: 1em">prctl(PR_SET_SECUREBITS,
<br>
/* SECBIT_KEEP_CAPS off */ <br>
SECBIT_KEEP_CAPS_LOCKED | <br>
SECBIT_NO_SETUID_FIXUP | <br>
SECBIT_NO_SETUID_FIXUP_LOCKED | <br>
SECBIT_NOROOT | <br>
SECBIT_NOROOT_LOCKED); <br>
/* Setting/locking SECBIT_NO_CAP_AMBIENT_RAISE <br>
is not required */</p>


<p style="margin-left:11%; margin-top: 1em"><b>Per-user-namespace
&quot;set-user-ID-root&quot; programs</b> <br>
A set-user-ID program whose UID matches the UID that created
a user namespace will confer capabilities in the
process&rsquo;s permitted and effective sets when executed
by any process inside that namespace or any descendant user
namespace.</p>

<p style="margin-left:11%; margin-top: 1em">The rules about
the transformation of the process&rsquo;s capabilities
during the <a href="https://man.page/2/execve">execve(2)</a> are exactly as described in the
subsections <i>Transformation of capabilities during
execve()</i> and <i>Capabilities and execution of programs
by root</i>, with the difference that, in the latter
subsection, &quot;root&quot; is the UID of the creator of
the user namespace.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Namespaced
file capabilities</b> <br>
Traditional (i.e., version 2) file capabilities associate
only a set of capability masks with a binary executable
file. When a process executes a binary with such
capabilities, it gains the associated capabilities (within
its user namespace) as per the rules described above in
&quot;Transformation of capabilities during
execve()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Because version
2 file capabilities confer capabilities to the executing
process regardless of which user namespace it resides in,
only privileged processes are permitted to associate
capabilities with a file. Here, &quot;privileged&quot; means
a process that has the <b>CAP_SETFCAP</b> capability in the
user namespace where the filesystem was mounted (normally
the initial user namespace). This limitation renders file
capabilities useless for certain use cases. For example, in
user-namespaced containers, it can be desirable to be able
to create a binary that confers capabilities only to
processes executed inside that container, but not to
processes that are executed outside the container.</p>

<p style="margin-left:11%; margin-top: 1em">Linux 4.14
added so-called namespaced file capabilities to support such
use cases. Namespaced file capabilities are recorded as
version 3 (i.e., <b>VFS_CAP_REVISION_3</b>)
<i>security.capability</i> extended attributes. Such an
attribute is automatically created in the circumstances
described above under &quot;File capability extended
attribute versioning&quot;. When a version 3
<i>security.capability</i> extended attribute is created,
the kernel records not just the capability masks in the
extended attribute, but also the namespace root user ID.</p>

<p style="margin-left:11%; margin-top: 1em">As with a
binary that has <b>VFS_CAP_REVISION_2</b> file capabilities,
a binary with <b>VFS_CAP_REVISION_3</b> file capabilities
confers capabilities to a process during <b>execve</b>().
However, capabilities are conferred only if the binary is
executed by a process that resides in a user namespace whose
UID 0 maps to the root user ID that is saved in the extended
attribute, or when executed by a process that resides in a
descendant of such a namespace.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Interaction
with user namespaces</b> <br>
For further information on the interaction of capabilities
and user namespaces, see <a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No standards
govern capabilities, but the Linux capability implementation
is based on the withdrawn POSIX.1e draft standard; see
<a href="https://archive.org/details/posix_1003.1e-990310">https://archive.org/details/posix_1003.1e-990310</a>.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When attempting
to <a href="https://man.page/1/strace">strace(1)</a> binaries that have capabilities (or
set-user-ID-root binaries), you may find the <i>-u
&lt;username&gt;</i> option useful. Something like:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>sudo
strace -o trace.log -u ceci ./myprivprog</b></p>

<p style="margin-left:11%; margin-top: 1em">From kernel
2.5.27 to kernel 2.6.26, capabilities were an optional
kernel component, and could be enabled/disabled via the
<b>CONFIG_SECURITY_CAPABILITIES</b> kernel configuration
option.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>/proc/[pid]/task/TID/status</i> file can be used to view
the capability sets of a thread. The
<i>/proc/[pid]/status</i> file shows the capability sets of
a process&rsquo;s main thread. Before Linux 3.8, nonexistent
capabilities were shown as being enabled (1) in these sets.
Since Linux 3.8, all nonexistent capabilities (above
<b>CAP_LAST_CAP</b>) are shown as disabled (0).</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>libcap</i> package provides a suite of routines for
setting and getting capabilities that is more comfortable
and less likely to change than the interface provided by
<a href="https://man.page/2/capset">capset(2)</a> and <a href="https://man.page/2/capget">capget(2)</a>. This package also
provides the <b>setcap</b>(8) and <b>getcap</b>(8) programs.
It can be found at <br>

<a href="https://git.kernel.org/pub/scm/libs/libcap/libcap.git/refs/">https://git.kernel.org/pub/scm/libs/libcap/libcap.git/refs/</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Before kernel
2.6.24, and from kernel 2.6.24 to kernel 2.6.32 if file
capabilities are not enabled, a thread with the
<b>CAP_SETPCAP</b> capability can manipulate the
capabilities of threads other than itself. However, this is
only theoretically possible, since no thread ever has
<b>CAP_SETPCAP</b> in either of these cases:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>In the pre-2.6.25 implementation the system-wide
capability bounding set, <i>/proc/sys/kernel/cap-bound</i>,
always masks out the <b>CAP_SETPCAP</b> capability, and this
can not be changed without modifying the kernel source and
rebuilding the kernel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>If file capabilities are disabled (i.e., the kernel
<b>CONFIG_SECURITY_FILE_CAPABILITIES</b> option is
disabled), then <b>init</b> starts out with the
<b>CAP_SETPCAP</b> capability removed from its per-process
bounding set, and that bounding set is inherited by all
other processes created on the system.</p></td></tr>
</table>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/1/capsh">capsh(1)</a>,
<a href="https://man.page/1/setpriv">setpriv(1)</a>, <a href="https://man.page/2/prctl">prctl(2)</a>, <a href="https://man.page/2/setfsuid">setfsuid(2)</a>,
<a href="https://man.page/3/cap_clear">cap_clear(3)</a>, <a href="https://man.page/3/cap_copy_ext">cap_copy_ext(3)</a>,
<a href="https://man.page/3/cap_from_text">cap_from_text(3)</a>, <a href="https://man.page/3/cap_get_file">cap_get_file(3)</a>,
<a href="https://man.page/3/cap_get_proc">cap_get_proc(3)</a>, <a href="https://man.page/3/cap_init">cap_init(3)</a>,
<a href="https://man.page/3/capgetp">capgetp(3)</a>, <a href="https://man.page/3/capsetp">capsetp(3)</a>, <a href="https://man.page/3/libcap">libcap(3)</a>,
<a href="https://man.page/5/proc">proc(5)</a>, <a href="https://man.page/7/credentials">credentials(7)</a>, <a href="https://man.page/7/pthreads">pthreads(7)</a>,
<a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>, <b>captest</b>(8),
<b>filecap</b>(8), <b>getcap</b>(8), <b>getpcaps</b>(8),
<b>netcap</b>(8), <b>pscap</b>(8), <b>setcap</b>(8)</p>


<p style="margin-left:11%; margin-top: 1em"><i>include/linux/capability.h</i>
in the Linux kernel source tree</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
