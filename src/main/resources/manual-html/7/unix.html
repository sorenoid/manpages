<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:34 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>UNIX</title>

</head>
<body>

<h1 align="center">UNIX</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">unix - sockets
for local interprocess communication</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/socket.h&gt; <br>
#include &lt;sys/un.h&gt;</b></p>


<p style="margin-left:11%; margin-top: 1em"><i>unix_socket</i>
<b>= socket(AF_UNIX, type, 0);</b> <i><br>
error</i> <b>= socketpair(AF_UNIX, type, 0, int
*</b><i>sv</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>AF_UNIX</b> (also known as <b>AF_LOCAL</b>) socket family
is used to communicate between processes on the same machine
efficiently. Traditionally, UNIX domain sockets can be
either unnamed, or bound to a filesystem pathname (marked as
being of type socket). Linux also supports an abstract
namespace which is independent of the filesystem.</p>

<p style="margin-left:11%; margin-top: 1em">Valid socket
types in the UNIX domain are: <b>SOCK_STREAM</b>, for a
stream-oriented socket; <b>SOCK_DGRAM</b>, for a
datagram-oriented socket that preserves message boundaries
(as on most UNIX implementations, UNIX domain datagram
sockets are always reliable and don&rsquo;t reorder
datagrams); and (since Linux 2.6.4) <b>SOCK_SEQPACKET</b>,
for a sequenced-packet socket that is connection-oriented,
preserves message boundaries, and delivers messages in the
order that they were sent.</p>

<p style="margin-left:11%; margin-top: 1em">UNIX domain
sockets support passing file descriptors or process
credentials to other processes using ancillary data.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Address
format</b> <br>
A UNIX domain socket address is represented in the following
structure:</p>

<p style="margin-left:17%; margin-top: 1em">struct
sockaddr_un { <br>
sa_family_t sun_family; /* AF_UNIX */ <br>
char sun_path[108]; /* Pathname */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>sun_family</i> field always contains <b>AF_UNIX</b>. On
Linux, <i>sun_path</i> is 108 bytes in size; see also NOTES,
below.</p>

<p style="margin-left:11%; margin-top: 1em">Various systems
calls (for example, <a href="https://man.page/2/bind">bind(2)</a>, <a href="https://man.page/2/connect">connect(2)</a>, and
<a href="https://man.page/2/sendto">sendto(2)</a>) take a <i>sockaddr_un</i> argument as
input. Some other system calls (for example,
<a href="https://man.page/2/getsockname">getsockname(2)</a>, <a href="https://man.page/2/getpeername">getpeername(2)</a>,
<a href="https://man.page/2/recvfrom">recvfrom(2)</a>, and <a href="https://man.page/2/accept">accept(2)</a>) return an argument
of this type.</p>

<p style="margin-left:11%; margin-top: 1em">Three types of
address are distinguished in the <i>sockaddr_un</i>
structure:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p><i>pathname</i>: a UNIX domain socket can be bound to a
null-terminated filesystem pathname using <a href="https://man.page/2/bind">bind(2)</a>.
When the address of a pathname socket is returned (by one of
the system calls noted above), its length is</p></td></tr>
</table>


<p style="margin-left:15%; margin-top: 1em">offsetof(struct
sockaddr_un, sun_path) + strlen(sun_path) + 1</p>

<p style="margin-left:15%; margin-top: 1em">and
<i>sun_path</i> contains the null-terminated pathname. (On
Linux, the above <b>offsetof</b>() expression equates to the
same value as <i>sizeof(sa_family_t)</i>, but some other
implementations include other fields before <i>sun_path</i>,
so the <b>offsetof</b>() expression more portably describes
the size of the address structure.)</p>

<p style="margin-left:15%; margin-top: 1em">For further
details of pathname sockets, see below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em"><i>unnamed</i>: A stream socket
that has not been bound to a pathname using <a href="https://man.page/2/bind">bind(2)</a>
has no name. Likewise, the two sockets created by
<a href="https://man.page/2/socketpair">socketpair(2)</a> are unnamed. When the address of an
unnamed socket is returned, its length is
<i>sizeof(sa_family_t)</i>, and <i>sun_path</i> should not
be inspected.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p><i>abstract</i>: an abstract socket address is
distinguished (from a pathname socket) by the fact that
<i>sun_path[0]</i> is a null byte ('\0'). The socket&rsquo;s
address in this namespace is given by the additional bytes
in <i>sun_path</i> that are covered by the specified length
of the address structure. (Null bytes in the name have no
special significance.) The name has no connection with
filesystem pathnames. When the address of an abstract socket
is returned, the returned <i>addrlen</i> is greater than
<i>sizeof(sa_family_t)</i> (i.e., greater than 2), and the
name of the socket is contained in the first <i>(addrlen -
sizeof(sa_family_t))</i> bytes of <i>sun_path</i>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Pathname
sockets</b> <br>
When binding a socket to a pathname, a few rules should be
observed for maximum portability and ease of coding:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The pathname in <i>sun_path</i>
should be null-terminated.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The length of the pathname, including the terminating
null byte, should not exceed the size of
<i>sun_path</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The <i>addrlen</i> argument that describes the enclosing
<i>sockaddr_un</i> structure should have a value of at
least:</p> </td></tr>
</table>


<p style="margin-left:15%; margin-top: 1em">offsetof(struct
sockaddr_un, sun_path)+strlen(addr.sun_path)+1</p>

<p style="margin-left:15%; margin-top: 1em">or, more
simply, <i>addrlen</i> can be specified as <i>sizeof(struct
sockaddr_un)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">There is some
variation in how implementations handle UNIX domain socket
addresses that do not follow the above rules. For example,
some (but not all) implementations append a null terminator
if none is present in the supplied <i>sun_path</i>.</p>

<p style="margin-left:11%; margin-top: 1em">When coding
portable applications, keep in mind that some
implementations have <i>sun_path</i> as short as 92
bytes.</p>

<p style="margin-left:11%; margin-top: 1em">Various system
calls (<a href="https://man.page/2/accept">accept(2)</a>, <a href="https://man.page/2/recvfrom">recvfrom(2)</a>,
<a href="https://man.page/2/getsockname">getsockname(2)</a>, <a href="https://man.page/2/getpeername">getpeername(2)</a>) return socket
address structures. When applied to UNIX domain sockets, the
value-result <i>addrlen</i> argument supplied to the call
should be initialized as above. Upon return, the argument is
set to indicate the <i>actual</i> size of the address
structure. The caller should check the value returned in
this argument: if the output value exceeds the input value,
then there is no guarantee that a null terminator is present
in <i>sun_path</i>. (See BUGS.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pathname
socket ownership and permissions</b> <br>
In the Linux implementation, pathname sockets honor the
permissions of the directory they are in. Creation of a new
socket fails if the process does not have write and search
(execute) permission on the directory in which the socket is
created.</p>

<p style="margin-left:11%; margin-top: 1em">On Linux,
connecting to a stream socket object requires write
permission on that socket; sending a datagram to a datagram
socket likewise requires write permission on that socket.
POSIX does not make any statement about the effect of the
permissions on a socket file, and on some systems (e.g.,
older BSDs), the socket permissions are ignored. Portable
programs should not rely on this feature for security.</p>

<p style="margin-left:11%; margin-top: 1em">When creating a
new socket, the owner and group of the socket file are set
according to the usual rules. The socket file has all
permissions enabled, other than those that are turned off by
the process <a href="https://man.page/2/umask">umask(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The owner,
group, and permissions of a pathname socket can be changed
(using <a href="https://man.page/2/chown">chown(2)</a> and <a href="https://man.page/2/chmod">chmod(2)</a>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Abstract
sockets</b> <br>
Socket permissions have no meaning for abstract sockets: the
process <a href="https://man.page/2/umask">umask(2)</a> has no effect when binding an
abstract socket, and changing the ownership and permissions
of the object (via <a href="https://man.page/2/fchown">fchown(2)</a> and <a href="https://man.page/2/fchmod">fchmod(2)</a>)
has no effect on the accessibility of the socket.</p>

<p style="margin-left:11%; margin-top: 1em">Abstract
sockets automatically disappear when all open references to
the socket are closed.</p>

<p style="margin-left:11%; margin-top: 1em">The abstract
socket namespace is a nonportable Linux extension.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Socket
options</b> <br>
For historical reasons, these socket options are specified
with a <b>SOL_SOCKET</b> type even though they are
<b>AF_UNIX</b> specific. They can be set with
<a href="https://man.page/2/setsockopt">setsockopt(2)</a> and read with <a href="https://man.page/2/getsockopt">getsockopt(2)</a> by
specifying <b>SOL_SOCKET</b> as the socket family. <b><br>
SO_PASSCRED</b></p>

<p style="margin-left:22%;">Enabling this socket option
causes receipt of the credentials of the sending process in
an <b>SCM_CREDENTIALS ancillary</b> message in each
subsequently received message. The returned credentials are
those specified by the sender using <b>SCM_CREDENTIALS</b>,
or a default that includes the sender&rsquo;s PID, real user
ID, and real group ID, if the sender did not specify
<b>SCM_CREDENTIALS</b> ancillary data.</p>

<p style="margin-left:22%; margin-top: 1em">When this
option is set and the socket is not yet connected, a unique
name in the abstract namespace will be generated
automatically.</p>

<p style="margin-left:22%; margin-top: 1em">The value given
as an argument to <a href="https://man.page/2/setsockopt">setsockopt(2)</a> and returned as the
result of <a href="https://man.page/2/getsockopt">getsockopt(2)</a> is an integer boolean
flag.</p>

<p style="margin-left:11%;"><b>SO_PASSSEC</b></p>

<p style="margin-left:22%;">Enables receiving of the
SELinux security label of the peer socket in an ancillary
message of type <b>SCM_SECURITY</b> (see below).</p>

<p style="margin-left:22%; margin-top: 1em">The value given
as an argument to <a href="https://man.page/2/setsockopt">setsockopt(2)</a> and returned as the
result of <a href="https://man.page/2/getsockopt">getsockopt(2)</a> is an integer boolean
flag.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>SO_PASSSEC</b> option is supported for UNIX domain
datagram sockets since Linux 2.6.18; support for UNIX domain
stream sockets was added in Linux 4.2.</p>

<p style="margin-left:11%;"><b>SO_PEEK_OFF</b></p>

<p style="margin-left:22%;">See <a href="https://man.page/7/socket">socket(7)</a>.</p>

<p style="margin-left:11%;"><b>SO_PEERCRED</b></p>

<p style="margin-left:22%;">This read-only socket option
returns the credentials of the peer process connected to
this socket. The returned credentials are those that were in
effect at the time of the call to <a href="https://man.page/2/connect">connect(2)</a> or
<a href="https://man.page/2/socketpair">socketpair(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">The argument to
<a href="https://man.page/2/getsockopt">getsockopt(2)</a> is a pointer to a <i>ucred</i>
structure; define the <b>_GNU_SOURCE</b> feature test macro
to obtain the definition of that structure from
<i>&lt;sys/socket.h&gt;</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The use of this
option is possible only for connected <b>AF_UNIX</b> stream
sockets and for <b>AF_UNIX</b> stream and datagram socket
pairs created using <a href="https://man.page/2/socketpair">socketpair(2)</a>.</p>

<p style="margin-left:11%;"><b>SO_PEERSEC</b></p>

<p style="margin-left:22%;">This read-only socket option
returns the security context of the peer socket connected to
this socket. By default, this will be the same as the
security context of the process that created the peer socket
unless overridden by the policy or by a process with the
required permissions.</p>

<p style="margin-left:22%; margin-top: 1em">The argument to
<a href="https://man.page/2/getsockopt">getsockopt(2)</a> is a pointer to a buffer of the
specified length in bytes into which the security context
string will be copied. If the buffer length is less than the
length of the security context string, then
<a href="https://man.page/2/getsockopt">getsockopt(2)</a> returns -1, sets <i>errno</i> to
<b>ERANGE</b>, and returns the required length via
<i>optlen</i>. The caller should allocate at least
<b>NAME_MAX</b> bytes for the buffer initially, although
this is not guaranteed to be sufficient. Resizing the buffer
to the returned length and retrying may be necessary.</p>

<p style="margin-left:22%; margin-top: 1em">The security
context string may include a terminating null character in
the returned length, but is not guaranteed to do so: a
security context &quot;foo&quot; might be represented as
either {&rsquo;f&rsquo;,&rsquo;o&rsquo;,&rsquo;o&rsquo;} of
length 3 or
{&rsquo;f&rsquo;,&rsquo;o&rsquo;,&rsquo;o&rsquo;,&rsquo;\0&rsquo;}
of length 4, which are considered to be interchangeable. The
string is printable, does not contain non-terminating null
characters, and is in an unspecified encoding (in
particular, it is not guaranteed to be ASCII or UTF-8).</p>

<p style="margin-left:22%; margin-top: 1em">The use of this
option for sockets in the <b>AF_UNIX</b> address family is
supported since Linux 2.6.2 for connected stream sockets,
and since Linux 4.18 also for stream and datagram socket
pairs created using <a href="https://man.page/2/socketpair">socketpair(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Autobind
feature</b> <br>
If a <a href="https://man.page/2/bind">bind(2)</a> call specifies <i>addrlen</i> as
<i>sizeof(sa_family_t)</i>, or the <b>SO_PASSCRED</b> socket
option was specified for a socket that was not explicitly
bound to an address, then the socket is autobound to an
abstract address. The address consists of a null byte
followed by 5 bytes in the character set <i>[0-9a-f]</i>.
Thus, there is a limit of 2^20 autobind addresses. (From
Linux 2.1.15, when the autobind feature was added, 8 bytes
were used, and the limit was thus 2^32 autobind addresses.
The change to 5 bytes came in Linux 2.3.15.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Sockets
API</b> <br>
The following paragraphs describe domain-specific details
and unsupported features of the sockets API for UNIX domain
sockets on Linux.</p>

<p style="margin-left:11%; margin-top: 1em">UNIX domain
sockets do not support the transmission of out-of-band data
(the <b>MSG_OOB</b> flag for <a href="https://man.page/2/send">send(2)</a> and
<a href="https://man.page/2/recv">recv(2)</a>).</p>

<p style="margin-left:11%; margin-top: 1em">The
<a href="https://man.page/2/send">send(2)</a> <b>MSG_MORE</b> flag is not supported by UNIX
domain sockets.</p>

<p style="margin-left:11%; margin-top: 1em">Before Linux
3.4, the use of <b>MSG_TRUNC</b> in the <i>flags</i>
argument of <a href="https://man.page/2/recv">recv(2)</a> was not supported by UNIX domain
sockets.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>SO_SNDBUF</b> socket option does have an effect for UNIX
domain sockets, but the <b>SO_RCVBUF</b> option does not.
For datagram sockets, the <b>SO_SNDBUF</b> value imposes an
upper limit on the size of outgoing datagrams. This limit is
calculated as the doubled (see <a href="https://man.page/7/socket">socket(7)</a>) option
value less 32 bytes used for overhead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Ancillary
messages</b> <br>
Ancillary data is sent and received using <a href="https://man.page/2/sendmsg">sendmsg(2)</a>
and <a href="https://man.page/2/recvmsg">recvmsg(2)</a>. For historical reasons, the ancillary
message types listed below are specified with a
<b>SOL_SOCKET</b> type even though they are <b>AF_UNIX</b>
specific. To send them, set the <i>cmsg_level</i> field of
the struct <i>cmsghdr</i> to <b>SOL_SOCKET</b> and the
<i>cmsg_type</i> field to the type. For more information,
see <a href="https://man.page/3/cmsg">cmsg(3)</a>. <b><br>
SCM_RIGHTS</b></p>

<p style="margin-left:22%;">Send or receive a set of open
file descriptors from another process. The data portion
contains an integer array of the file descriptors.</p>

<p style="margin-left:22%; margin-top: 1em">Commonly, this
operation is referred to as &quot;passing a file
descriptor&quot; to another process. However, more
accurately, what is being passed is a reference to an open
file description (see <a href="https://man.page/2/open">open(2)</a>), and in the receiving
process it is likely that a different file descriptor number
will be used. Semantically, this operation is equivalent to
duplicating (<a href="https://man.page/2/dup">dup(2)</a>) a file descriptor into the file
descriptor table of another process.</p>

<p style="margin-left:22%; margin-top: 1em">If the buffer
used to receive the ancillary data containing file
descriptors is too small (or is absent), then the ancillary
data is truncated (or discarded) and the excess file
descriptors are automatically closed in the receiving
process.</p>

<p style="margin-left:22%; margin-top: 1em">If the number
of file descriptors received in the ancillary data would
cause the process to exceed its <b>RLIMIT_NOFILE</b>
resource limit (see <a href="https://man.page/2/getrlimit">getrlimit(2)</a>), the excess file
descriptors are automatically closed in the receiving
process.</p>

<p style="margin-left:22%; margin-top: 1em">The kernel
constant <b>SCM_MAX_FD</b> defines a limit on the number of
file descriptors in the array. Attempting to send an array
larger than this limit causes <a href="https://man.page/2/sendmsg">sendmsg(2)</a> to fail with
the error <b>EINVAL</b>. <b>SCM_MAX_FD</b> has the value 253
(or 255 in kernels before 2.6.38).</p>

<p style="margin-left:11%;"><b>SCM_CREDENTIALS</b></p>

<p style="margin-left:22%;">Send or receive UNIX
credentials. This can be used for authentication. The
credentials are passed as a <i>struct ucred</i> ancillary
message. This structure is defined in
<i>&lt;sys/socket.h&gt;</i> as follows:</p>

<p style="margin-left:28%; margin-top: 1em">struct ucred {
<br>
pid_t pid; /* Process ID of the sending process */ <br>
uid_t uid; /* User ID of the sending process */ <br>
gid_t gid; /* Group ID of the sending process */ <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">Since glibc
2.8, the <b>_GNU_SOURCE</b> feature test macro must be
defined (before including <i>any</i> header files) in order
to obtain the definition of this structure.</p>

<p style="margin-left:22%; margin-top: 1em">The credentials
which the sender specifies are checked by the kernel. A
privileged process is allowed to specify values that do not
match its own. The sender must specify its own process ID
(unless it has the capability <b>CAP_SYS_ADMIN</b>, in which
case the PID of any existing process may be specified), its
real user ID, effective user ID, or saved set-user-ID
(unless it has <b>CAP_SETUID</b>), and its real group ID,
effective group ID, or saved set-group-ID (unless it has
<b>CAP_SETGID</b>).</p>

<p style="margin-left:22%; margin-top: 1em">To receive a
<i>struct ucred</i> message, the <b>SO_PASSCRED</b> option
must be enabled on the socket.</p>

<p style="margin-left:11%;"><b>SCM_SECURITY</b></p>

<p style="margin-left:22%;">Receive the SELinux security
context (the security label) of the peer socket. The
received ancillary data is a null-terminated string
containing the security context. The receiver should
allocate at least <b>NAME_MAX</b> bytes in the data portion
of the ancillary message for this data.</p>

<p style="margin-left:22%; margin-top: 1em">To receive the
security context, the <b>SO_PASSSEC</b> option must be
enabled on the socket (see above).</p>

<p style="margin-left:11%; margin-top: 1em">When sending
ancillary data with <a href="https://man.page/2/sendmsg">sendmsg(2)</a>, only one item of each
of the above types may be included in the sent message.</p>

<p style="margin-left:11%; margin-top: 1em">At least one
byte of real data should be sent when sending ancillary
data. On Linux, this is required to successfully send
ancillary data over a UNIX domain stream socket. When
sending ancillary data over a UNIX domain datagram socket,
it is not necessary on Linux to send any accompanying real
data. However, portable applications should also include at
least one byte of real data when sending ancillary data over
a datagram socket.</p>

<p style="margin-left:11%; margin-top: 1em">When receiving
from a stream socket, ancillary data forms a kind of barrier
for the received data. For example, suppose that the sender
transmits as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="74%">


<p><a href="https://man.page/2/sendmsg">sendmsg(2)</a> of four bytes, with no ancillary
data.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="74%">


<p><a href="https://man.page/2/sendmsg">sendmsg(2)</a> of one byte, with ancillary data.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="74%">


<p><a href="https://man.page/2/sendmsg">sendmsg(2)</a> of four bytes, with no ancillary
data.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Suppose that
the receiver now performs <a href="https://man.page/2/recvmsg">recvmsg(2)</a> calls each with
a buffer size of 20 bytes. The first call will receive five
bytes of data, along with the ancillary data sent by the
second <a href="https://man.page/2/sendmsg">sendmsg(2)</a> call. The next call will receive
the remaining four bytes of data.</p>

<p style="margin-left:11%; margin-top: 1em">If the space
allocated for receiving incoming ancillary data is too small
then the ancillary data is truncated to the number of
headers that will fit in the supplied buffer (or, in the
case of an <b>SCM_RIGHTS</b> file descriptor list, the list
of file descriptors may be truncated). If no buffer is
provided for incoming ancillary data (i.e., the
<i>msg_control</i> field of the <i>msghdr</i> structure
supplied to <a href="https://man.page/2/recvmsg">recvmsg(2)</a> is NULL), then the incoming
ancillary data is discarded. In both of these cases, the
<b>MSG_CTRUNC</b> flag will be set in the
<i>msg.msg_flags</i> value returned by
<a href="https://man.page/2/recvmsg">recvmsg(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Ioctls</b>
<br>
The following <a href="https://man.page/2/ioctl">ioctl(2)</a> calls return information in
<i>value</i>. The correct syntax is:</p>

<p style="margin-left:22%; margin-top: 1em"><b>int</b>
<i>value</i><b>;</b> <i><br>
error</i> <b>= ioctl(</b><i>unix_socket</i><b>,</b>
<i>ioctl_type</i><b>, &amp;</b><i>value</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><i>ioctl_type</i>
can be: <b><br>
SIOCINQ</b></p>

<p style="margin-left:22%;">For <b>SOCK_STREAM</b> sockets,
this call returns the number of unread bytes in the receive
buffer. The socket must not be in LISTEN state, otherwise an
error (<b>EINVAL</b>) is returned. <b>SIOCINQ</b> is defined
in <i>&lt;linux/sockios.h&gt;</i>. Alternatively, you can
use the synonymous <b>FIONREAD</b>, defined in
<i>&lt;sys/ioctl.h&gt;</i>. For <b>SOCK_DGRAM</b> sockets,
the returned value is the same as for Internet domain
datagram sockets; see <a href="https://man.page/7/udp">udp(7)</a>.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EADDRINUSE</b></p>

<p style="margin-left:22%;">The specified local address is
already in use or the filesystem socket object already
exists.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EBADF</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>This error can occur for <a href="https://man.page/2/sendmsg">sendmsg(2)</a> when sending
a file descriptor as ancillary data over a UNIX domain
socket (see the description of <b>SCM_RIGHTS</b>, above),
and indicates that the file descriptor number that is being
sent is not valid (e.g., it is not an open file
descriptor).</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>ECONNREFUSED</b></p>

<p style="margin-left:22%;">The remote address specified by
<a href="https://man.page/2/connect">connect(2)</a> was not a listening socket. This error can
also occur if the target pathname is not a socket.</p>

<p style="margin-left:11%;"><b>ECONNRESET</b></p>

<p style="margin-left:22%;">Remote socket was unexpectedly
closed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>User memory address was not valid.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Invalid argument passed. A common cause is that the
value <b>AF_UNIX</b> was not specified in the
<i>sun_type</i> field of passed addresses, or the socket was
in an invalid state for the applied operation.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EISCONN</b></p>

<p style="margin-left:22%;"><a href="https://man.page/2/connect">connect(2)</a> called on an
already connected socket or a target address was specified
on a connected socket.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The pathname in the remote address specified to
<a href="https://man.page/2/connect">connect(2)</a> did not exist.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Out of memory.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENOTCONN</b></p>

<p style="margin-left:22%;">Socket operation needs a target
address, but the socket is not connected.</p>

<p style="margin-left:11%;"><b>EOPNOTSUPP</b></p>

<p style="margin-left:22%;">Stream operation called on
non-stream oriented socket or tried to use the out-of-band
data option.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPERM</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The sender passed invalid credentials in the <i>struct
ucred</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>EPIPE</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Remote socket was closed on a stream socket. If enabled,
a <b>SIGPIPE</b> is sent as well. This can be avoided by
passing the <b>MSG_NOSIGNAL</b> flag to <a href="https://man.page/2/send">send(2)</a> or
<a href="https://man.page/2/sendmsg">sendmsg(2)</a>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>EPROTONOSUPPORT</b></p>

<p style="margin-left:22%;">Passed protocol is not
<b>AF_UNIX</b>.</p>

<p style="margin-left:11%;"><b>EPROTOTYPE</b></p>

<p style="margin-left:22%;">Remote socket does not match
the local socket type (<b>SOCK_DGRAM</b> versus
<b>SOCK_STREAM</b>).</p>

<p style="margin-left:11%;"><b>ESOCKTNOSUPPORT</b></p>

<p style="margin-left:22%;">Unknown socket type.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ESRCH</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>While sending an ancillary message containing
credentials (<b>SCM_CREDENTIALS</b>), the caller specified a
PID that does not match any existing process.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ETOOMANYREFS</b></p>

<p style="margin-left:22%;">This error can occur for
<a href="https://man.page/2/sendmsg">sendmsg(2)</a> when sending a file descriptor as
ancillary data over a UNIX domain socket (see the
description of <b>SCM_RIGHTS</b>, above). It occurs if the
number of &quot;in-flight&quot; file descriptors exceeds the
<b>RLIMIT_NOFILE</b> resource limit and the caller does not
have the <b>CAP_SYS_RESOURCE</b> capability. An in-flight
file descriptor is one that has been sent using
<a href="https://man.page/2/sendmsg">sendmsg(2)</a> but has not yet been accepted in the
recipient process using <a href="https://man.page/2/recvmsg">recvmsg(2)</a>.</p>

<p style="margin-left:22%; margin-top: 1em">This error is
diagnosed since mainline Linux 4.5 (and in some earlier
kernel versions where the fix has been backported). In
earlier kernel versions, it was possible to place an
unlimited number of file descriptors in flight, by sending
each file descriptor with <a href="https://man.page/2/sendmsg">sendmsg(2)</a> and then closing
the file descriptor so that it was not accounted against the
<b>RLIMIT_NOFILE</b> resource limit.</p>

<p style="margin-left:11%; margin-top: 1em">Other errors
can be generated by the generic socket layer or by the
filesystem while generating a filesystem socket object. See
the appropriate manual pages for more information.</p>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>SCM_CREDENTIALS</b>
and the abstract namespace were introduced with Linux 2.2
and should not be used in portable programs. (Some
BSD-derived systems also support credential passing, but the
implementation details differ.)</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Binding to a
socket with a filename creates a socket in the filesystem
that must be deleted by the caller when it is no longer
needed (using <a href="https://man.page/2/unlink">unlink(2)</a>). The usual UNIX close-behind
semantics apply; the socket can be unlinked at any time and
will be finally removed from the filesystem when the last
reference to it is closed.</p>

<p style="margin-left:11%; margin-top: 1em">To pass file
descriptors or credentials over a <b>SOCK_STREAM</b> socket,
you must to send or receive at least one byte of
nonancillary data in the same <a href="https://man.page/2/sendmsg">sendmsg(2)</a> or
<a href="https://man.page/2/recvmsg">recvmsg(2)</a> call.</p>

<p style="margin-left:11%; margin-top: 1em">UNIX domain
stream sockets do not support the notion of out-of-band
data.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When binding a
socket to an address, Linux is one of the implementations
that appends a null terminator if none is supplied in
<i>sun_path</i>. In most cases this is unproblematic: when
the socket address is retrieved, it will be one byte longer
than that supplied when the socket was bound. However, there
is one case where confusing behavior can result: if 108
non-null bytes are supplied when a socket is bound, then the
addition of the null terminator takes the length of the
pathname beyond <i>sizeof(sun_path)</i>. Consequently, when
retrieving the socket address (for example, via
<a href="https://man.page/2/accept">accept(2)</a>), if the input <i>addrlen</i> argument for
the retrieving call is specified as <i>sizeof(struct
sockaddr_un)</i>, then the returned address structure
<i>won&rsquo;t</i> have a null terminator in
<i>sun_path</i>.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
some implementations don&rsquo;t require a null terminator
when binding a socket (the <i>addrlen</i> argument is used
to determine the length of <i>sun_path</i>) and when the
socket address is retrieved on these implementations, there
is no null terminator in <i>sun_path</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Applications
that retrieve socket addresses can (portably) code to handle
the possibility that there is no null terminator in
<i>sun_path</i> by respecting the fact that the number of
valid bytes in the pathname is:</p>


<p style="margin-left:11%; margin-top: 1em">strnlen(addr.sun_path,
addrlen - offsetof(sockaddr_un, sun_path))</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
an application can retrieve the socket address by allocating
a buffer of size <i>sizeof(struct sockaddr_un)+1</i> that is
zeroed out before the retrieval. The retrieving call can
specify <i>addrlen</i> as <i>sizeof(struct sockaddr_un)</i>,
and the extra zero byte ensures that there will be a null
terminator for the string returned in <i>sun_path</i>:</p>

<p style="margin-left:17%; margin-top: 1em">void
*addrp;</p>

<p style="margin-left:17%; margin-top: 1em">addrlen =
sizeof(struct sockaddr_un); <br>
addrp = malloc(addrlen + 1); <br>
if (addrp == NULL) <br>
/* Handle error */ ; <br>
memset(addrp, 0, addrlen + 1);</p>

<p style="margin-left:17%; margin-top: 1em">if
(getsockname(sfd, (struct sockaddr *) addrp, &amp;addrlen))
== -1) <br>
/* handle error */ ;</p>


<p style="margin-left:17%; margin-top: 1em">printf(&quot;sun_path
= %s\n&quot;, ((struct sockaddr_un *)
addrp)-&gt;sun_path);</p>

<p style="margin-left:11%; margin-top: 1em">This sort of
messiness can be avoided if it is guaranteed that the
applications that <i>create</i> pathname sockets follow the
rules outlined above under <i>Pathname sockets</i>.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
code demonstrates the use of sequenced-packet sockets for
local interprocess communication. It consists of two
programs. The server program waits for a connection from the
client program. The client sends each of its command-line
arguments in separate messages. The server treats the
incoming messages as integers and adds them up. The client
sends the command string &quot;END&quot;. The server sends
back a message containing the sum of the client&rsquo;s
integers. The client prints the sum and exits. The server
waits for the next client to connect. To stop the server,
the client is called with the command-line argument
&quot;DOWN&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The following
output was recorded while running the server in the
background and repeatedly executing the client. Execution of
the server program ends when it receives the
&quot;DOWN&quot; command.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
output</b></p>

<p style="margin-left:17%;">$ <b>./server &amp;</b> <br>
[1] 25887 <br>
$ <b>./client 3 4</b> <br>
Result = 7 <br>
$ <b>./client 11 -5</b> <br>
Result = 6 <br>
$ <b>./client DOWN</b> <br>
Result = 0 <br>
[1]+ Done ./server <br>
$</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
/* <br>
* File connection.h <br>
*/</p>

<p style="margin-left:11%; margin-top: 1em">#define
SOCKET_NAME &quot;/tmp/9Lq7BNBnBycd6nxy.socket&quot; <br>
#define BUFFER_SIZE 12</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* File server.c <br>
*/</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;sys/socket.h&gt; <br>
#include &lt;sys/un.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &quot;connection.h&quot;</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
struct sockaddr_un name; <br>
int down_flag = 0; <br>
int ret; <br>
int connection_socket; <br>
int data_socket; <br>
int result; <br>
char buffer[BUFFER_SIZE];</p>

<p style="margin-left:11%; margin-top: 1em">/* Create local
socket. */</p>


<p style="margin-left:11%; margin-top: 1em">connection_socket
= socket(AF_UNIX, SOCK_SEQPACKET, 0); <br>
if (connection_socket == -1) { <br>
perror(&quot;socket&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* For portability clear the whole structure, since some <br>
* implementations have additional (nonstandard) fields in
<br>
* the structure. <br>
*/</p>


<p style="margin-left:11%; margin-top: 1em">memset(&amp;name,
0, sizeof(name));</p>

<p style="margin-left:11%; margin-top: 1em">/* Bind socket
to socket name. */</p>


<p style="margin-left:11%; margin-top: 1em">name.sun_family
= AF_UNIX; <br>
strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) -
1);</p>

<p style="margin-left:11%; margin-top: 1em">ret =
bind(connection_socket, (const struct sockaddr *) &amp;name,
<br>
sizeof(name)); <br>
if (ret == -1) { <br>
perror(&quot;bind&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* Prepare for accepting connections. The backlog size is set
<br>
* to 20. So while one request is being processed other
requests <br>
* can be waiting. <br>
*/</p>

<p style="margin-left:11%; margin-top: 1em">ret =
listen(connection_socket, 20); <br>
if (ret == -1) { <br>
perror(&quot;listen&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* This is the
main loop for handling connections. */</p>

<p style="margin-left:11%; margin-top: 1em">for (;;) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Wait for
incoming connection. */</p>

<p style="margin-left:11%; margin-top: 1em">data_socket =
accept(connection_socket, NULL, NULL); <br>
if (data_socket == -1) { <br>
perror(&quot;accept&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">result = 0;
<br>
for (;;) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Wait for
next data packet. */</p>

<p style="margin-left:11%; margin-top: 1em">ret =
read(data_socket, buffer, sizeof(buffer)); <br>
if (ret == -1) { <br>
perror(&quot;read&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Ensure
buffer is 0-terminated. */</p>


<p style="margin-left:11%; margin-top: 1em">buffer[sizeof(buffer)
- 1] = 0;</p>

<p style="margin-left:11%; margin-top: 1em">/* Handle
commands. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(!strncmp(buffer, &quot;DOWN&quot;, sizeof(buffer))) { <br>
down_flag = 1; <br>
break; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if
(!strncmp(buffer, &quot;END&quot;, sizeof(buffer))) { <br>
break; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Add received
summand. */</p>

<p style="margin-left:11%; margin-top: 1em">result +=
atoi(buffer); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Send result.
*/</p>


<p style="margin-left:11%; margin-top: 1em">sprintf(buffer,
&quot;%d&quot;, result); <br>
ret = write(data_socket, buffer, sizeof(buffer)); <br>
if (ret == -1) { <br>
perror(&quot;write&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Close
socket. */</p>


<p style="margin-left:11%; margin-top: 1em">close(data_socket);</p>

<p style="margin-left:11%; margin-top: 1em">/* Quit on DOWN
command. */</p>

<p style="margin-left:11%; margin-top: 1em">if (down_flag)
{ <br>
break; <br>
} <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">close(connection_socket);</p>

<p style="margin-left:11%; margin-top: 1em">/* Unlink the
socket. */</p>


<p style="margin-left:11%; margin-top: 1em">unlink(SOCKET_NAME);</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* File client.c <br>
*/</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;errno.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;sys/socket.h&gt; <br>
#include &lt;sys/un.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &quot;connection.h&quot;</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
struct sockaddr_un addr; <br>
int ret; <br>
int data_socket; <br>
char buffer[BUFFER_SIZE];</p>

<p style="margin-left:11%; margin-top: 1em">/* Create local
socket. */</p>

<p style="margin-left:11%; margin-top: 1em">data_socket =
socket(AF_UNIX, SOCK_SEQPACKET, 0); <br>
if (data_socket == -1) { <br>
perror(&quot;socket&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* For portability clear the whole structure, since some <br>
* implementations have additional (nonstandard) fields in
<br>
* the structure. <br>
*/</p>


<p style="margin-left:11%; margin-top: 1em">memset(&amp;addr,
0, sizeof(addr));</p>

<p style="margin-left:11%; margin-top: 1em">/* Connect
socket to socket address */</p>


<p style="margin-left:11%; margin-top: 1em">addr.sun_family
= AF_UNIX; <br>
strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) -
1);</p>

<p style="margin-left:11%; margin-top: 1em">ret =
connect(data_socket, (const struct sockaddr *) &amp;addr,
<br>
sizeof(addr)); <br>
if (ret == -1) { <br>
fprintf(stderr, &quot;The server is down.\n&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Send
arguments. */</p>

<p style="margin-left:11%; margin-top: 1em">for (int i = 1;
i &lt; argc; ++i) { <br>
ret = write(data_socket, argv[i], strlen(argv[i]) + 1); <br>
if (ret == -1) { <br>
perror(&quot;write&quot;); <br>
break; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Request
result. */</p>

<p style="margin-left:11%; margin-top: 1em">strcpy(buffer,
&quot;END&quot;); <br>
ret = write(data_socket, buffer, strlen(buffer) + 1); <br>
if (ret == -1) { <br>
perror(&quot;write&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Receive
result. */</p>

<p style="margin-left:11%; margin-top: 1em">ret =
read(data_socket, buffer, sizeof(buffer)); <br>
if (ret == -1) { <br>
perror(&quot;read&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Ensure
buffer is 0-terminated. */</p>


<p style="margin-left:11%; margin-top: 1em">buffer[sizeof(buffer)
- 1] = 0;</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Result
= %s\n&quot;, buffer);</p>

<p style="margin-left:11%; margin-top: 1em">/* Close
socket. */</p>


<p style="margin-left:11%; margin-top: 1em">close(data_socket);</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">For an example
of the use of <b>SCM_RIGHTS</b> see <a href="https://man.page/3/cmsg">cmsg(3)</a>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/recvmsg">recvmsg(2)</a>,
<a href="https://man.page/2/sendmsg">sendmsg(2)</a>, <a href="https://man.page/2/socket">socket(2)</a>, <a href="https://man.page/2/socketpair">socketpair(2)</a>,
<a href="https://man.page/3/cmsg">cmsg(3)</a>, <a href="https://man.page/7/capabilities">capabilities(7)</a>,
<a href="https://man.page/7/credentials">credentials(7)</a>, <a href="https://man.page/7/socket">socket(7)</a>, <a href="https://man.page/7/udp">udp(7)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
