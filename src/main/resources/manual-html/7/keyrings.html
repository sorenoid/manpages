<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:33 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>KEYRINGS</title>

</head>
<body>

<h1 align="center">KEYRINGS</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">keyrings -
in-kernel key management and retention facility</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Linux
key-management facility is primarily a way for various
kernel components to retain or cache security data,
authentication keys, encryption keys, and other data in the
kernel.</p>

<p style="margin-left:11%; margin-top: 1em">System call
interfaces are provided so that user-space programs can
manage those objects and also use the facility for their own
purposes; see <b>add_key</b>(2), <b>request_key</b>(2), and
<b>keyctl</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">A library and
some user-space utilities are provided to allow access to
the facility. See <b>keyctl</b>(1), <b>keyctl</b>(3), and
<b>keyutils</b>(7) for more information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Keys</b>
<br>
A key has the following attributes: <br>
Serial number (ID)</p>

<p style="margin-left:22%;">This is a unique integer handle
by which a key is referred to in system calls. The serial
number is sometimes synonymously referred as the key ID.
Programmatically, key serial numbers are represented using
the type <i>key_serial_t</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>Type</p></td>
<td width="5%"></td>
<td width="78%">


<p>A key&rsquo;s type defines what sort of data can be held
in the key, how the proposed content of the key will be
parsed, and how the payload will be used.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">There are a
number of general-purpose types available, plus some
specialist types defined by specific kernel components.</p>

<p style="margin-left:11%;">Description (name)</p>

<p style="margin-left:22%;">The key description is a
printable string that is used as the search term for the key
(in conjunction with the key type) as well as a display
name. During searches, the description may be partially
matched or exactly matched.</p>

<p style="margin-left:11%;">Payload (data)</p>

<p style="margin-left:22%;">The payload is the actual
content of a key. This is usually set when a key is created,
but it is possible for the kernel to upcall to user space to
finish the instantiation of a key if that key wasn&rsquo;t
already known to the kernel when it was requested. For
further details, see <b>request_key</b>(2).</p>

<p style="margin-left:22%; margin-top: 1em">A key&rsquo;s
payload can be read and updated if the key type supports it
and if suitable permission is granted to the caller.</p>

<p style="margin-left:11%;">Access rights</p>

<p style="margin-left:22%;">Much as files do, each key has
an owning user ID, an owning group ID, and a security label.
Each key also has a set of permissions, though there are
more than for a normal UNIX file, and there is an additional
category&mdash;possessor&mdash;beyond the usual user, group,
and other (see <i>Possession</i>, below).</p>

<p style="margin-left:22%; margin-top: 1em">Note that keys
are quota controlled, since they require unswappable kernel
memory. The owning user ID specifies whose quota is to be
debited.</p>

<p style="margin-left:11%;">Expiration time</p>

<p style="margin-left:22%;">Each key can have an expiration
time set. When that time is reached, the key is marked as
being expired and accesses to it fail with the error
<b>EKEYEXPIRED</b>. If not deleted, updated, or replaced,
then, after a set amount of time, an expired key is
automatically removed (garbage collected) along with all
links to it, and attempts to access the key fail with the
error <b>ENOKEY</b>.</p>

<p style="margin-left:11%;">Reference count</p>

<p style="margin-left:22%;">Each key has a reference count.
Keys are referenced by keyrings, by currently active users,
and by a process&rsquo;s credentials. When the reference
count reaches zero, the key is scheduled for garbage
collection.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Key
types</b> <br>
The kernel provides several basic types of key: <i><br>
&quot;keyring&quot;</i></p>

<p style="margin-left:22%;">Keyrings are special keys which
store a set of links to other keys (including other
keyrings), analogous to a directory holding links to files.
The main purpose of a keyring is to prevent other keys from
being garbage collected because nothing refers to them.</p>

<p style="margin-left:22%; margin-top: 1em">Keyrings with
descriptions (names) that begin with a period ('.') are
reserved to the implementation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>&quot;user&quot;</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This is a general-purpose key type. The key is kept
entirely within kernel memory. The payload may be read and
updated by user-space applications.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The payload for
keys of this type is a blob of arbitrary data of up to
32,767 bytes.</p>

<p style="margin-left:22%; margin-top: 1em">The description
may be any valid string, though it is preferred that it
start with a colon-delimited prefix representing the service
to which the key is of interest (for instance
<i>&quot;afs:mykey&quot;</i>).</p>

<p style="margin-left:11%;"><i>&quot;logon&quot;</i> (since
Linux 3.3)</p>

<p style="margin-left:22%;">This key type is essentially
the same as <i>&quot;user&quot;</i>, but it does not provide
reading (i.e., the <b>keyctl</b>(2) <b>KEYCTL_READ</b>
operation), meaning that the key payload is never visible
from user space. This is suitable for storing
username-password pairs that should not be readable from
user space.</p>

<p style="margin-left:22%; margin-top: 1em">The description
of a <i>&quot;logon&quot;</i> key <i>must</i> start with a
non-empty colon-delimited prefix whose purpose is to
identify the service to which the key belongs. (Note that
this differs from keys of the <i>&quot;user&quot;</i> type,
where the inclusion of a prefix is recommended but is not
enforced.)</p>

<p style="margin-left:11%;"><i>&quot;big_key&quot;</i>
(since Linux 3.13)</p>

<p style="margin-left:22%;">This key type is similar to the
<i>&quot;user&quot;</i> key type, but it may hold a payload
of up to 1&nbsp;MiB in size. This key type is useful for
purposes such as holding Kerberos ticket caches.</p>

<p style="margin-left:22%; margin-top: 1em">The payload
data may be stored in a tmpfs filesystem, rather than in
kernel memory, if the data size exceeds the overhead of
storing the data in the filesystem. (Storing the data in a
filesystem requires filesystem structures to be allocated in
the kernel. The size of these structures determines the size
threshold above which the tmpfs storage method is used.)
Since Linux 4.8, the payload data is encrypted when stored
in tmpfs, thereby preventing it from being written
unencrypted into swap space.</p>

<p style="margin-left:11%; margin-top: 1em">There are more
specialized key types available also, but they aren&rsquo;t
discussed here because they aren&rsquo;t intended for normal
user-space use.</p>

<p style="margin-left:11%; margin-top: 1em">Key type names
that begin with a period ('.') are reserved to the
implementation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Keyrings</b>
<br>
As previously mentioned, keyrings are a special type of key
that contain links to other keys (which may include other
keyrings). Keys may be linked to by multiple keyrings.
Keyrings may be considered as analogous to UNIX directories
where each directory contains a set of hard links to
files.</p>

<p style="margin-left:11%; margin-top: 1em">Various
operations (system calls) may be applied only to
keyrings:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>Adding</p></td>
<td width="2%"></td>
<td width="78%">


<p>A key may be added to a keyring by system calls that
create keys. This prevents the new key from being
immediately deleted when the system call releases its last
reference to the key.</p></td></tr>
</table>

<p style="margin-left:11%;">Linking</p>

<p style="margin-left:22%;">A link may be added to a
keyring pointing to a key that is already known, provided
this does not create a self-referential cycle.</p>

<p style="margin-left:11%;">Unlinking</p>

<p style="margin-left:22%;">A link may be removed from a
keyring. When the last link to a key is removed, that key
will be scheduled for deletion by the garbage collector.</p>

<p style="margin-left:11%;">Clearing</p>

<p style="margin-left:22%;">All the links may be removed
from a keyring.</p>

<p style="margin-left:11%;">Searching</p>

<p style="margin-left:22%;">A keyring may be considered the
root of a tree or subtree in which keyrings form the
branches and non-keyrings the leaves. This tree may be
searched for a key matching a particular type and
description.</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>keyctl_clear</b>(3), <b>keyctl_link</b>(3),
<b>keyctl_search</b>(3), and <b>keyctl_unlink</b>(3) for
more information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Anchoring
keys</b> <br>
To prevent a key from being garbage collected, it must be
anchored to keep its reference count elevated when it is not
in active use by the kernel.</p>

<p style="margin-left:11%; margin-top: 1em">Keyrings are
used to anchor other keys: each link is a reference on a
key. Note that keyrings themselves are just keys and are
also subject to the same anchoring requirement to prevent
them being garbage collected.</p>

<p style="margin-left:11%; margin-top: 1em">The kernel
makes available a number of anchor keyrings. Note that some
of these keyrings will be created only when first accessed.
<br>
Process keyrings</p>

<p style="margin-left:22%;">Process credentials themselves
reference keyrings with specific semantics. These keyrings
are pinned as long as the set of credentials exists, which
is usually as long as the process exists.</p>

<p style="margin-left:22%; margin-top: 1em">There are three
keyrings with different inheritance/sharing rules: the
<b>session-keyring</b>(7) (inherited and shared by all child
processes), the <b>process-keyring</b>(7) (shared by all
threads in a process) and the <b>thread-keyring</b>(7)
(specific to a particular thread).</p>

<p style="margin-left:22%; margin-top: 1em">As an
alternative to using the actual keyring IDs, in calls to
<b>add_key</b>(2), <b>keyctl</b>(2), and
<b>request_key</b>(2), the special keyring values
<b>KEY_SPEC_SESSION_KEYRING</b>,
<b>KEY_SPEC_PROCESS_KEYRING</b>, and
<b>KEY_SPEC_THREAD_KEYRING</b> can be used to refer to the
caller&rsquo;s own instances of these keyrings.</p>

<p style="margin-left:11%;">User keyrings</p>

<p style="margin-left:22%;">Each UID known to the kernel
has a record that contains two keyrings: the
<b>user-keyring</b>(7) and the
<b>user-session-keyring</b>(7). These exist for as long as
the UID record in the kernel exists.</p>

<p style="margin-left:22%; margin-top: 1em">As an
alternative to using the actual keyring IDs, in calls to
<b>add_key</b>(2), <b>keyctl</b>(2), and
<b>request_key</b>(2), the special keyring values
<b>KEY_SPEC_USER_KEYRING</b> and
<b>KEY_SPEC_USER_SESSION_KEYRING</b> can be used to refer to
the caller&rsquo;s own instances of these keyrings.</p>

<p style="margin-left:22%; margin-top: 1em">A link to the
user keyring is placed in a new session keyring by
<b>pam_keyinit</b>(8) when a new login session is
initiated.</p>

<p style="margin-left:11%;">Persistent keyrings</p>

<p style="margin-left:22%;">There is a
<b>persistent-keyring</b>(7) available to each UID known to
the system. It may persist beyond the life of the UID record
previously mentioned, but has an expiration time set such
that it is automatically cleaned up after a set time. The
persistent keyring permits, for example, <b>cron</b>(8)
scripts to use credentials that are left in the persistent
keyring after the user logs out.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
expiration time of the persistent keyring is reset every
time the persistent key is requested.</p>

<p style="margin-left:11%;">Special keyrings</p>

<p style="margin-left:22%;">There are special keyrings
owned by the kernel that can anchor keys for special
purposes. An example of this is the <i>system keyring</i>
used for holding encryption keys for module signature
verification.</p>

<p style="margin-left:22%; margin-top: 1em">These special
keyrings are usually closed to direct alteration by user
space.</p>

<p style="margin-left:11%; margin-top: 1em">An originally
planned &quot;group keyring&quot;, for storing keys
associated with each GID known to the kernel, is not so far
implemented, is unlikely to be implemented. Nevertheless,
the constant <b>KEY_SPEC_GROUP_KEYRING</b> has been defined
for this keyring.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Possession</b>
<br>
The concept of possession is important to understanding the
keyrings security model. Whether a thread possesses a key is
determined by the following rules:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(1)</p></td>
<td width="2%"></td>
<td width="83%">


<p>Any key or keyring that does not grant <i>search</i>
permission to the caller is ignored in all the following
rules.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(2)</p></td>
<td width="2%"></td>
<td width="83%">


<p>A thread possesses its <b>session-keyring</b>(7),
<b>process-keyring</b>(7), and <b>thread-keyring</b>(7)
directly because those keyrings are referred to by its
credentials.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(3)</p></td>
<td width="2%"></td>
<td width="83%">


<p>If a keyring is possessed, then any key it links to is
also possessed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(4)</p></td>
<td width="2%"></td>
<td width="83%">


<p>If any key a keyring links to is itself a keyring, then
rule (3) applies recursively.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(5)</p></td>
<td width="2%"></td>
<td width="83%">


<p>If a process is upcalled from the kernel to instantiate
a key (see <b>request_key</b>(2)), then it also possesses
the requester&rsquo;s keyrings as in rule (1) as if it were
the requester.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that
possession is not a fundamental property of a key, but must
rather be calculated each time the key is needed.</p>

<p style="margin-left:11%; margin-top: 1em">Possession is
designed to allow set-user-ID programs run from, say a
user&rsquo;s shell to access the user&rsquo;s keys. Granting
permissions to the key possessor while denying them to the
key owner and group allows the prevention of access to keys
on the basis of UID and GID matches.</p>

<p style="margin-left:11%; margin-top: 1em">When it creates
the session keyring, <b>pam_keyinit</b>(8) adds a link to
the <b>user-keyring</b>(7), thus making the user keyring and
anything it contains possessed by default.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Access
rights</b> <br>
Each key has the following security-related attributes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="82%">


<p style="margin-top: 1em">The owning user ID</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="82%">


<p>The ID of a group that is permitted to access the
key</p> </td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="82%">


<p>A security label</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="82%">


<p>A permissions mask</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The permissions
mask contains four sets of rights. The first three sets are
mutually exclusive. One and only one will be in force for a
particular access check. In order of descending priority,
these three sets are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><i>user</i></p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">The set specifies the rights
granted if the key&rsquo;s user ID matches the
caller&rsquo;s filesystem user ID.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>group</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>The set specifies the rights granted if the user ID
didn&rsquo;t match and the key&rsquo;s group ID matches the
caller&rsquo;s filesystem GID or one of the caller&rsquo;s
supplementary group IDs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>other</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>The set specifies the rights granted if neither the
key&rsquo;s user ID nor group ID matched.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The fourth set
of rights is: <i><br>
possessor</i></p>

<p style="margin-left:22%;">The set specifies the rights
granted if a key is determined to be possessed by the
caller.</p>

<p style="margin-left:11%; margin-top: 1em">The complete
set of rights for a key is the union of whichever of the
first three sets is applicable plus the fourth set if the
key is possessed.</p>

<p style="margin-left:11%; margin-top: 1em">The set of
rights that may be granted in each of the four masks is as
follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>view</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>The attributes of the key may be read. This includes the
type, description, and access rights (excluding the security
label).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>read</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>For a key: the payload of the key may be read. For a
keyring: the list of serial numbers (keys) to which the
keyring has links may be read.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>write</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>The payload of the key may be updated and the key may be
revoked. For a keyring, links may be added to or removed
from the keyring, and the keyring may be cleared completely
(all links are removed),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>search</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>For a key (or a keyring): the key may be found by a
search. For a keyring: keys and keyrings that are linked to
by the keyring may be searched.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>link</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>Links may be created from keyrings to the key. The
initial link to a key that is established when the key is
created doesn&rsquo;t require this permission.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>setattr</i></p>

<p style="margin-left:22%;">The ownership details and
security label of the key may be changed, the key&rsquo;s
expiration time may be set, and the key may be revoked.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
access rights, any active Linux Security Module (LSM) may
prevent access to a key if its policy so dictates. A key may
be given a security label or other attribute by the LSM;
this label is retrievable via
<b>keyctl_get_security</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>keyctl_chown</b>(3), <b>keyctl_describe</b>(3),
<b>keyctl_get_security</b>(3), <b>keyctl_setperm</b>(3), and
<b>selinux</b>(8) for more information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Searching
for keys</b> <br>
One of the key features of the Linux key-management facility
is the ability to find a key that a process is retaining.
The <b>request_key</b>(2) system call is the primary point
of access for user-space applications to find a key.
(Internally, the kernel has something similar available for
use by internal components that make use of keys.)</p>

<p style="margin-left:11%; margin-top: 1em">The search
algorithm works as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(1)</p></td>
<td width="2%"></td>
<td width="83%">


<p>The process keyrings are searched in the following
order: the thread <b>thread-keyring</b>(7) if it exists, the
<b>process-keyring</b>(7) if it exists, and then either the
<b>session-keyring</b>(7) if it exists or the
<b>user-session-keyring</b>(7) if that exists.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(2)</p></td>
<td width="2%"></td>
<td width="83%">


<p>If the caller was a process that was invoked by the
<b>request_key</b>(2) upcall mechanism, then the keyrings of
the original caller of <b>request_key</b>(2) will be
searched as well.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(3)</p></td>
<td width="2%"></td>
<td width="83%">


<p>The search of a keyring tree is in breadth-first order:
each keyring is searched first for a match, then the
keyrings referred to by that keyring are searched.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(4)</p></td>
<td width="2%"></td>
<td width="83%">


<p>If a matching key is found that is valid, then the
search terminates and that key is returned.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(5)</p></td>
<td width="2%"></td>
<td width="83%">


<p>If a matching key is found that has an error state
attached, that error state is noted and the search
continues.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(6)</p></td>
<td width="2%"></td>
<td width="83%">


<p>If no valid matching key is found, then the first noted
error state is returned; otherwise, an <b>ENOKEY</b> error
is returned.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">It is also
possible to search a specific keyring, in which case only
steps (3) to (6) apply.</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>request_key</b>(2) and <b>keyctl_search</b>(3) for more
information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>On-demand
key creation</b> <br>
If a key cannot be found, <b>request_key</b>(2) will, if
given a <i>callout_info</i> argument, create a new key and
then upcall to user space to instantiate the key. This
allows keys to be created on an as-needed basis.</p>

<p style="margin-left:11%; margin-top: 1em">Typically, this
will involve the kernel creating a new process that executes
the <b>request-key</b>(8) program, which will then execute
the appropriate handler based on its configuration.</p>

<p style="margin-left:11%; margin-top: 1em">The handler is
passed a special authorization key that allows it and only
it to instantiate the new key. This is also used to permit
searches performed by the handler program to also search the
requester&rsquo;s keyrings.</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>request_key</b>(2), <b>keyctl_assume_authority</b>(3),
<b>keyctl_instantiate</b>(3), <b>keyctl_negate</b>(3),
<b>keyctl_reject</b>(3), <b>request-key</b>(8), and
<b>request-key.conf</b>(5) for more information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>/proc
files</b> <br>
The kernel provides various <i>/proc</i> files that expose
information about keys or define limits on key usage.
<i><br>
/proc/keys</i> (since Linux 2.6.10)</p>

<p style="margin-left:22%;">This file exposes a list of the
keys for which the reading thread has <i>view</i>
permission, providing various information about each key.
The thread need not possess the key for it to be visible in
this file.</p>

<p style="margin-left:22%; margin-top: 1em">The only keys
included in the list are those that grant <i>view</i>
permission to the reading process (regardless of whether or
not it possesses them). LSM security checks are still
performed, and may filter out further keys that the process
is not authorized to view.</p>

<p style="margin-left:22%; margin-top: 1em">An example of
the data that one might see in this file (with the columns
numbered for easy reference below) is the following:</p>

<p style="margin-left:22%; margin-top: 1em">(1) (2) (3)(4)
(5) (6) (7) (8) (9) <br>
009a2028 I--Q--- 1 perm 3f010000 1000 1000 user
krb_ccache:primary: 12 <br>
1806c4ba I--Q--- 1 perm 3f010000 1000 1000 keyring _pid: 2
<br>
25d3a08f I--Q--- 1 perm 1f3f0000 1000 65534 keyring
_uid_ses.1000: 1 <br>
28576bd8 I--Q--- 3 perm 3f010000 1000 1000 keyring _krb: 1
<br>
2c546d21 I--Q--- 190 perm 3f030000 1000 1000 keyring _ses: 2
<br>
30a4e0be I------ 4 2d 1f030000 1000 65534 keyring
_persistent.1000: 1 <br>
32100fab I--Q--- 4 perm 1f3f0000 1000 65534 keyring
_uid.1000: 2 <br>
32a387ea I--Q--- 1 perm 3f010000 1000 1000 keyring _pid: 2
<br>
3ce56aea I--Q--- 5 perm 3f030000 1000 1000 keyring _ses:
1</p>

<p style="margin-left:22%; margin-top: 1em">The fields
shown in each line of this file are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p>ID (1)</p></td>
<td width="1%"></td>
<td width="68%">


<p>The ID (serial number) of the key, expressed in
hexadecimal.</p> </td></tr>
</table>

<p style="margin-left:22%;">Flags (2)</p>

<p style="margin-left:32%;">A set of flags describing the
state of the key:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>I</p></td>
<td width="4%"></td>
<td width="62%">


<p>The key has been instantiated.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>R</p></td>
<td width="4%"></td>
<td width="62%">


<p>The key has been revoked.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>D</p></td>
<td width="4%"></td>
<td width="62%">


<p>The key is dead (i.e., the key type has been
unregistered). (A key may be briefly in this state during
garbage collection.)</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>Q</p></td>
<td width="4%"></td>
<td width="62%">


<p>The key contributes to the user&rsquo;s quota.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>U</p></td>
<td width="4%"></td>
<td width="62%">


<p>The key is under construction via a callback to user
space; see <b>request-key</b>(2).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>N</p></td>
<td width="4%"></td>
<td width="62%">


<p>The key is negatively instantiated.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="2%">


<p>i</p></td>
<td width="4%"></td>
<td width="62%">


<p>The key has been invalidated.</p></td></tr>
</table>

<p style="margin-left:22%;">Usage (3)</p>

<p style="margin-left:32%;">This is a count of the number
of kernel credential structures that are pinning the key
(approximately: the number of threads and open file
references that refer to this key).</p>

<p style="margin-left:22%;">Timeout (4)</p>

<p style="margin-left:32%;">The amount of time until the
key will expire, expressed in human-readable form (weeks,
days, hours, minutes, and seconds). The string <i>perm</i>
here means that the key is permanent (no timeout). The
string <i>expd</i> means that the key has already expired,
but has not yet been garbage collected.</p>

<p style="margin-left:22%;">Permissions (5)</p>

<p style="margin-left:32%;">The key permissions, expressed
as four hexadecimal bytes containing, from left to right,
the possessor, user, group, and other permissions. Within
each byte, the permission bits are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="6%">


<p>0x01</p></td>
<td width="5%"></td>
<td width="11%">


<p><i>view</i></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="6%">


<p>Ox02</p></td>
<td width="5%"></td>
<td width="11%">


<p><i>read</i></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="6%">


<p>0x04</p></td>
<td width="5%"></td>
<td width="11%">


<p><i>write</i></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="6%">


<p>0x08</p></td>
<td width="5%"></td>
<td width="11%">


<p><i>search</i></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="6%">


<p>0x10</p></td>
<td width="5%"></td>
<td width="11%">


<p><i>link</i></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="6%">


<p>0x20</p></td>
<td width="5%"></td>
<td width="11%">


<p><i>setattr</i></p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:22%;">UID (6)</p>

<p style="margin-left:32%;">The user ID of the key
owner.</p>

<p style="margin-left:22%;">GID (7)</p>

<p style="margin-left:32%;">The group ID of the key. The
value -1 here means that the key has no group ID; this can
occur in certain circumstances for keys created by the
kernel.</p>

<p style="margin-left:22%;">Type (8)</p>

<p style="margin-left:32%;">The key type (user, keyring,
etc.)</p>

<p style="margin-left:22%;">Description (9)</p>

<p style="margin-left:32%;">The key description (name).
This field contains descriptive information about the key.
For most key types, it has the form</p>

<p style="margin-left:32%; margin-top: 1em">name[:
extra-info]</p>

<p style="margin-left:32%; margin-top: 1em">The <i>name</i>
subfield is the key&rsquo;s description (name). The optional
<i>extra-info</i> field provides some further information
about the key. The information that appears here depends on
the key type, as follows: <i><br>
&quot;user&quot;</i> and <i>&quot;logon&quot;</i></p>

<p style="margin-left:43%;">The size in bytes of the key
payload (expressed in decimal).</p>

<p style="margin-left:32%;"><i>&quot;keyring&quot;</i></p>

<p style="margin-left:43%;">The number of keys linked to
the keyring, or the string <i>empty</i> if there are no keys
linked to the keyring.</p>

<p style="margin-left:32%;"><i>&quot;big_key&quot;</i></p>

<p style="margin-left:43%;">The payload size in bytes,
followed either by the string <i>[file]</i>, if the key
payload exceeds the threshold that means that the payload is
stored in a (swappable) <b>tmpfs</b>(5) filesystem, or
otherwise the string <i>[buff]</i>, indicating that the key
is small enough to reside in kernel memory.</p>

<p style="margin-left:32%; margin-top: 1em">For the
<i>&quot;.request_key_auth&quot;</i> key type (authorization
key; see <b>request_key</b>(2)), the description field has
the form shown in the following example:</p>

<p style="margin-left:32%; margin-top: 1em">key:c9a9b19
pid:28880 ci:10</p>

<p style="margin-left:32%; margin-top: 1em">The three
subfields are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="5%">


<p><i>key</i></p></td>
<td width="6%"></td>
<td width="57%">


<p>The hexadecimal ID of the key being instantiated in the
requesting program.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="5%">


<p><i>pid</i></p></td>
<td width="6%"></td>
<td width="57%">


<p>The PID of the requesting program.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="5%">


<p><i>ci</i></p></td>
<td width="6%"></td>
<td width="57%">


<p>The length of the callout data with which the requested
key should be instantiated (i.e., the length of the payload
associated with the authorization key).</p></td></tr>
</table>

<p style="margin-left:11%;"><i>/proc/key-users</i> (since
Linux 2.6.10)</p>

<p style="margin-left:22%;">This file lists various
information for each user ID that has at least one key on
the system. An example of the data that one might see in
this file is the following:</p>

<p style="margin-left:28%; margin-top: 1em">0: 10 9/9
2/1000000 22/25000000 <br>
42: 9 9/9 8/200 106/20000 <br>
1000: 11 11/11 10/200 271/20000</p>

<p style="margin-left:22%; margin-top: 1em">The fields
shown in each line are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><i>uid</i></p></td>
<td width="3%"></td>
<td width="68%">


<p>The user ID.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><i>usage</i></p></td>
<td width="3%"></td>
<td width="68%">


<p>This is a kernel-internal usage count for the kernel
structure used to record key users.</p></td></tr>
</table>

<p style="margin-left:22%;"><i>nkeys</i>/<i>nikeys</i></p>

<p style="margin-left:32%;">The total number of keys owned
by the user, and the number of those keys that have been
instantiated.</p>


<p style="margin-left:22%;"><i>qnkeys</i>/<i>maxkeys</i></p>

<p style="margin-left:32%;">The number of keys owned by the
user, and the maximum number of keys that the user may
own.</p>


<p style="margin-left:22%;"><i>qnbytes</i>/<i>maxbytes</i></p>

<p style="margin-left:32%;">The number of bytes consumed in
payloads of the keys owned by this user, and the upper limit
on the number of bytes in key payloads for that user.</p>


<p style="margin-left:11%;"><i>/proc/sys/kernel/keys/gc_delay</i>
(since Linux 2.6.32)</p>

<p style="margin-left:22%;">The value in this file
specifies the interval, in seconds, after which revoked and
expired keys will be garbage collected. The purpose of
having such an interval is so that there is a window of time
where user space can see an error (respectively
<b>EKEYREVOKED</b> and <b>EKEYEXPIRED</b>) that indicates
what happened to the key.</p>

<p style="margin-left:22%; margin-top: 1em">The default
value in this file is 300 (i.e., 5 minutes).</p>


<p style="margin-left:11%;"><i>/proc/sys/kernel/keys/persistent_keyring_expiry</i>
(since Linux 3.13)</p>

<p style="margin-left:22%;">This file defines an interval,
in seconds, to which the persistent keyring&rsquo;s
expiration timer is reset each time the keyring is accessed
(via <b>keyctl_get_persistent</b>(3) or the <b>keyctl</b>(2)
<b>KEYCTL_GET_PERSISTENT</b> operation.)</p>

<p style="margin-left:22%; margin-top: 1em">The default
value in this file is 259200 (i.e., 3 days).</p>

<p style="margin-left:11%; margin-top: 1em">The following
files (which are writable by privileged processes) are used
to enforce quotas on the number of keys and number of bytes
of data that can be stored in key payloads: <i><br>
/proc/sys/kernel/keys/maxbytes</i> (since Linux 2.6.26)</p>

<p style="margin-left:22%;">This is the maximum number of
bytes of data that a nonroot user can hold in the payloads
of the keys owned by the user.</p>

<p style="margin-left:22%; margin-top: 1em">The default
value in this file is 20,000.</p>


<p style="margin-left:11%;"><i>/proc/sys/kernel/keys/maxkeys</i>
(since Linux 2.6.26)</p>

<p style="margin-left:22%;">This is the maximum number of
keys that a nonroot user may own.</p>

<p style="margin-left:22%; margin-top: 1em">The default
value in this file is 200.</p>


<p style="margin-left:11%;"><i>/proc/sys/kernel/keys/root_maxbytes</i>
(since Linux 2.6.26)</p>

<p style="margin-left:22%;">This is the maximum number of
bytes of data that the root user (UID 0 in the root user
namespace) can hold in the payloads of the keys owned by
root.</p>

<p style="margin-left:22%; margin-top: 1em">The default
value in this file is 25,000,000 (20,000 before Linux
3.17).</p>


<p style="margin-left:11%;"><i>/proc/sys/kernel/keys/root_maxkeys</i>
(since Linux 2.6.26)</p>

<p style="margin-left:22%;">This is the maximum number of
keys that the root user (UID 0 in the root user namespace)
may own.</p>

<p style="margin-left:22%; margin-top: 1em">The default
value in this file is 1,000,000 (200 before Linux 3.17).</p>

<p style="margin-left:11%; margin-top: 1em">With respect to
keyrings, note that each link in a keyring consumes 4 bytes
of the keyring payload.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Users</b>
<br>
The Linux key-management facility has a number of users and
usages, but is not limited to those that already exist.</p>

<p style="margin-left:11%; margin-top: 1em">In-kernel users
of this facility include: <br>
Network filesystems - DNS</p>

<p style="margin-left:22%;">The kernel uses the upcall
mechanism provided by the keys to upcall to user space to do
DNS lookups and then to cache the results.</p>

<p style="margin-left:11%;">AF_RXRPC and kAFS -
Authentication</p>

<p style="margin-left:22%;">The AF_RXRPC network protocol
and the in-kernel AFS filesystem use keys to store the
ticket needed to do secured or encrypted traffic. These are
then looked up by network operations on AF_RXRPC and
filesystem operations on kAFS.</p>

<p style="margin-left:11%;">NFS - User ID mapping</p>

<p style="margin-left:22%;">The NFS filesystem uses keys to
store mappings of foreign user IDs to local user IDs.</p>

<p style="margin-left:11%;">CIFS - Password</p>

<p style="margin-left:22%;">The CIFS filesystem uses keys
to store passwords for accessing remote shares.</p>

<p style="margin-left:11%;">Module verification</p>

<p style="margin-left:22%;">The kernel build process can be
made to cryptographically sign modules. That signature is
then checked when a module is loaded.</p>

<p style="margin-left:11%; margin-top: 1em">User-space
users of this facility include: <br>
Kerberos key storage</p>

<p style="margin-left:22%;">The MIT Kerberos 5 facility
(libkrb5) can use keys to store authentication tokens which
can be made to be automatically cleaned up a set time after
the user last uses them, but until then permits them to hang
around after the user has logged out so that <b>cron</b>(8)
scripts can use them.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>keyctl</b>(1),
<b>add_key</b>(2), <b>keyctl</b>(2), <b>request_key</b>(2),
<b>keyctl</b>(3), <b>keyutils</b>(7),
<b>persistent-keyring</b>(7), <b>process-keyring</b>(7),
<b>session-keyring</b>(7), <b>thread-keyring</b>(7),
<b>user-keyring</b>(7), <b>user-session-keyring</b>(7),
<b>pam_keyinit</b>(8), <b>request-key</b>(8)</p>

<p style="margin-left:11%; margin-top: 1em">The kernel
source files <i>Documentation/crypto/asymmetric-keys.txt</i>
and under <i>Documentation/security/keys</i> (or, before
Linux 4.13, in the file
<i>Documentation/security/keys.txt</i>).</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
