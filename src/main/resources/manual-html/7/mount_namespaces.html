<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:51 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MOUNT_NAMESPACES</title>

</head>
<body>

<h1 align="center">MOUNT_NAMESPACES</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SHARED SUBTREES">SHARED SUBTREES</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">mount_namespaces
- overview of Linux mount namespaces</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For an overview
of namespaces, see <a href="https://man.page/7/namespaces">namespaces(7)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Mount
namespaces provide isolation of the list of mount points
seen by the processes in each namespace instance. Thus, the
processes in each of the mount namespace instances will see
distinct single-directory hierarchies.</p>

<p style="margin-left:11%; margin-top: 1em">The views
provided by the <i>/proc/[pid]/mounts</i>,
<i>/proc/[pid]/mountinfo</i>, and
<i>/proc/[pid]/mountstats</i> files (all described in
<a href="https://man.page/5/proc">proc(5)</a>) correspond to the mount namespace in which
the process with the PID <i>[pid]</i> resides. (All of the
processes that reside in the same mount namespace will see
the same view in these files.)</p>

<p style="margin-left:11%; margin-top: 1em">A new mount
namespace is created using either <a href="https://man.page/2/clone">clone(2)</a> or
<a href="https://man.page/2/unshare">unshare(2)</a> with the <b>CLONE_NEWNS</b> flag. When a
new mount namespace is created, its mount point list is
initialized as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the namespace is created using <a href="https://man.page/2/clone">clone(2)</a>, the
mount point list of the child&rsquo;s namespace is a copy of
the mount point list in the parent&rsquo;s namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the namespace is created using <a href="https://man.page/2/unshare">unshare(2)</a>, the
mount point list of the new namespace is a copy of the mount
point list in the caller&rsquo;s previous mount
namespace.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Subsequent
modifications to the mount point list (<a href="https://man.page/2/mount">mount(2)</a> and
<a href="https://man.page/2/umount">umount(2)</a>) in either mount namespace will not (by
default) affect the mount point list seen in the other
namespace (but see the following discussion of shared
subtrees).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Restrictions
on mount namespaces</b> <br>
Note the following points with respect to mount
namespaces:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">Each mount namespace has an
owner user namespace. As explained above, when a new mount
namespace is created, its mount point list is initialized as
a copy of the mount point list of another mount namespace.
If the new namespace and the namespace from which the mount
point list was copied are owned by different user
namespaces, then the new mount namespace is considered
<i>less privileged</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>When creating a less privileged mount namespace, shared
mounts are reduced to slave mounts. (Shared and slave mounts
are discussed below.) This ensures that mappings performed
in less privileged mount namespaces will not propagate to
more privileged mount namespaces.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Mounts that come as a single unit from a more privileged
mount namespace are locked together and may not be separated
in a less privileged mount namespace. (The <a href="https://man.page/2/unshare">unshare(2)</a>
<b>CLONE_NEWNS</b> operation brings across all of the mounts
from the original mount namespace as a single unit, and
recursive mounts that propagate between mount namespaces
propagate as a single unit.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The <a href="https://man.page/2/mount">mount(2)</a> flags <b>MS_RDONLY</b>,
<b>MS_NOSUID</b>, <b>MS_NOEXEC</b>, and the
&quot;atime&quot; flags (<b>MS_NOATIME</b>,
<b>MS_NODIRATIME</b>, <b>MS_RELATIME</b>) settings become
locked when propagated from a more privileged to a less
privileged mount namespace, and may not be changed in the
less privileged mount namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>A file or directory that is a mount point in one
namespace that is not a mount point in another namespace,
may be renamed, unlinked, or removed (<a href="https://man.page/2/rmdir">rmdir(2)</a>) in
the mount namespace in which it is not a mount point
(subject to the usual permission checks). Consequently, the
mount point is removed in the mount namespace where it was a
mount point.</p></td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">Previously
(before Linux 3.18), attempting to unlink, rename, or remove
a file or directory that was a mount point in another mount
namespace would result in the error <b>EBUSY</b>. That
behavior had technical problems of enforcement (e.g., for
NFS) and permitted denial-of-service attacks against more
privileged users. (i.e., preventing individual files from
being updated by bind mounting on top of them).</p>

<h2>SHARED SUBTREES
<a name="SHARED SUBTREES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">After the
implementation of mount namespaces was completed, experience
showed that the isolation that they provided was, in some
cases, too great. For example, in order to make a newly
loaded optical disk available in all mount namespaces, a
mount operation was required in each namespace. For this use
case, and others, the shared subtree feature was introduced
in Linux 2.6.15. This feature allows for automatic,
controlled propagation of mount and unmount <i>events</i>
between namespaces (or, more precisely, between the members
of a <i>peer group</i> that are propagating events to one
another).</p>

<p style="margin-left:11%; margin-top: 1em">Each mount
point is marked (via <a href="https://man.page/2/mount">mount(2)</a>) as having one of the
following <i>propagation types</i>: <b><br>
MS_SHARED</b></p>

<p style="margin-left:22%;">This mount point shares events
with members of a peer group. Mount and unmount events
immediately under this mount point will propagate to the
other mount points that are members of the peer group.
<i>Propagation</i> here means that the same mount or unmount
will automatically occur under all of the other mount points
in the peer group. Conversely, mount and unmount events that
take place under peer mount points will propagate to this
mount point.</p>

<p style="margin-left:11%;"><b>MS_PRIVATE</b></p>

<p style="margin-left:22%;">This mount point is private; it
does not have a peer group. Mount and unmount events do not
propagate into or out of this mount point.</p>

<p style="margin-left:11%;"><b>MS_SLAVE</b></p>

<p style="margin-left:22%;">Mount and unmount events
propagate into this mount point from a (master) shared peer
group. Mount and unmount events under this mount point do
not propagate to any peer.</p>

<p style="margin-left:22%; margin-top: 1em">Note that a
mount point can be the slave of another peer group while at
the same time sharing mount and unmount events with a peer
group of which it is a member. (More precisely, one peer
group can be the slave of another peer group.)</p>

<p style="margin-left:11%;"><b>MS_UNBINDABLE</b></p>

<p style="margin-left:22%;">This is like a private mount,
and in addition this mount can&rsquo;t be bind mounted.
Attempts to bind mount this mount (<a href="https://man.page/2/mount">mount(2)</a> with the
<b>MS_BIND</b> flag) will fail.</p>

<p style="margin-left:22%; margin-top: 1em">When a
recursive bind mount (<a href="https://man.page/2/mount">mount(2)</a> with the
<b>MS_BIND</b> and <b>MS_REC</b> flags) is performed on a
directory subtree, any bind mounts within the subtree are
automatically pruned (i.e., not replicated) when replicating
that subtree to produce the target subtree.</p>

<p style="margin-left:11%; margin-top: 1em">For a
discussion of the propagation type assigned to a new mount,
see NOTES.</p>

<p style="margin-left:11%; margin-top: 1em">The propagation
type is a per-mount-point setting; some mount points may be
marked as shared (with each shared mount point being a
member of a distinct peer group), while others are private
(or slaved or unbindable).</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
mount&rsquo;s propagation type determines whether mounts and
unmounts of mount points <i>immediately under</i> the mount
point are propagated. Thus, the propagation type does not
affect propagation of events for grandchildren and further
removed descendant mount points. What happens if the mount
point itself is unmounted is determined by the propagation
type that is in effect for the <i>parent</i> of the mount
point.</p>

<p style="margin-left:11%; margin-top: 1em">Members are
added to a <i>peer group</i> when a mount point is marked as
shared and either:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>the mount point is replicated during the creation of a
new mount namespace; or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>a new bind mount is created from the mount point.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In both of
these cases, the new mount point joins the peer group of
which the existing mount point is a member.</p>

<p style="margin-left:11%; margin-top: 1em">A new peer
group is also created when a child mount point is created
under an existing mount point that is marked as shared. In
this case, the new child mount point is also marked as
shared and the resulting peer group consists of all the
mount points that are replicated under the peers of parent
mount.</p>

<p style="margin-left:11%; margin-top: 1em">A mount ceases
to be a member of a peer group when either the mount is
explicitly unmounted, or when the mount is implicitly
unmounted because a mount namespace is removed (because it
has no more member processes).</p>

<p style="margin-left:11%; margin-top: 1em">The propagation
type of the mount points in a mount namespace can be
discovered via the &quot;optional fields&quot; exposed in
<i>/proc/[pid]/mountinfo</i>. (See <a href="https://man.page/5/proc">proc(5)</a> for
details of this file.) The following tags can appear in the
optional fields for a record in that file: <i><br>
shared:X</i></p>

<p style="margin-left:22%;">This mount point is shared in
peer group <i>X</i>. Each peer group has a unique ID that is
automatically generated by the kernel, and all mount points
in the same peer group will show the same ID. (These IDs are
assigned starting from the value 1, and may be recycled when
a peer group ceases to have any members.)</p>

<p style="margin-left:11%;"><i>master:X</i></p>

<p style="margin-left:22%;">This mount is a slave to shared
peer group <i>X</i>.</p>

<p style="margin-left:11%;"><i>propagate_from:X</i> (since
Linux 2.6.26)</p>

<p style="margin-left:22%;">This mount is a slave and
receives propagation from shared peer group <i>X</i>. This
tag will always appear in conjunction with a <i>master:X</i>
tag. Here, <i>X</i> is the closest dominant peer group under
the process&rsquo;s root directory. If <i>X</i> is the
immediate master of the mount, or if there is no dominant
peer group under the same root, then only the
<i>master:X</i> field is present and not the
<i>propagate_from:X</i> field. For further details, see
below.</p>

<p style="margin-left:11%;"><i>unbindable</i></p>

<p style="margin-left:22%;">This is an unbindable
mount.</p>

<p style="margin-left:11%; margin-top: 1em">If none of the
above tags is present, then this is a private mount.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MS_SHARED
and MS_PRIVATE example</b> <br>
Suppose that on a terminal in the initial mount namespace,
we mark one mount point as shared and another as private,
and then view the mounts in <i>/proc/self/mountinfo</i>:</p>

<p style="margin-left:17%; margin-top: 1em">sh1# <b>mount
--make-shared /mntS</b> <br>
sh1# <b>mount --make-private /mntP</b> <br>
sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
77 61 8:17 / /mntS rw,relatime shared:1 <br>
83 61 8:15 / /mntP rw,relatime</p>

<p style="margin-left:11%; margin-top: 1em">From the
<i>/proc/self/mountinfo</i> output, we see that <i>/mntS</i>
is a shared mount in peer group 1, and that <i>/mntP</i> has
no optional tags, indicating that it is a private mount. The
first two fields in each record in this file are the unique
ID for this mount, and the mount ID of the parent mount. We
can further inspect this file to see that the parent mount
point of <i>/mntS</i> and <i>/mntP</i> is the root
directory, <i>/</i>, which is mounted as private:</p>

<p style="margin-left:17%; margin-top: 1em">sh1# <b>cat
/proc/self/mountinfo | awk '$1 == 61' | sed 's/ - .*//'</b>
<br>
61 0 8:2 / / rw,relatime</p>

<p style="margin-left:11%; margin-top: 1em">On a second
terminal, we create a new mount namespace where we run a
second shell and inspect the mounts:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>PS1='sh2#
' sudo unshare -m --propagation unchanged sh</b> <br>
sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
222 145 8:17 / /mntS rw,relatime shared:1 <br>
225 145 8:15 / /mntP rw,relatime</p>

<p style="margin-left:11%; margin-top: 1em">The new mount
namespace received a copy of the initial mount
namespace&rsquo;s mount points. These new mount points
maintain the same propagation types, but have unique mount
IDs. (The <i>--propagation&nbsp;unchanged</i> option
prevents <a href="https://man.page/1/unshare">unshare(1)</a> from marking all mounts as
private when creating a new mount namespace, which it does
by default.)</p>

<p style="margin-left:11%; margin-top: 1em">In the second
terminal, we then create submounts under each of
<i>/mntS</i> and <i>/mntP</i> and inspect the set-up:</p>

<p style="margin-left:17%; margin-top: 1em">sh2# <b>mkdir
/mntS/a</b> <br>
sh2# <b>mount /dev/sdb6 /mntS/a</b> <br>
sh2# <b>mkdir /mntP/b</b> <br>
sh2# <b>mount /dev/sdb7 /mntP/b</b> <br>
sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
222 145 8:17 / /mntS rw,relatime shared:1 <br>
225 145 8:15 / /mntP rw,relatime <br>
178 222 8:22 / /mntS/a rw,relatime shared:2 <br>
230 225 8:23 / /mntP/b rw,relatime</p>

<p style="margin-left:11%; margin-top: 1em">From the above,
it can be seen that <i>/mntS/a</i> was created as shared
(inheriting this setting from its parent mount) and
<i>/mntP/b</i> was created as a private mount.</p>

<p style="margin-left:11%; margin-top: 1em">Returning to
the first terminal and inspecting the set-up, we see that
the new mount created under the shared mount point
<i>/mntS</i> propagated to its peer mount (in the initial
mount namespace), but the new mount created under the
private mount point <i>/mntP</i> did not propagate:</p>

<p style="margin-left:17%; margin-top: 1em">sh1# <b>cat
/proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
<br>
77 61 8:17 / /mntS rw,relatime shared:1 <br>
83 61 8:15 / /mntP rw,relatime <br>
179 77 8:22 / /mntS/a rw,relatime shared:2</p>

<p style="margin-left:11%; margin-top: 1em"><b>MS_SLAVE
example</b> <br>
Making a mount point a slave allows it to receive propagated
mount and unmount events from a master shared peer group,
while preventing it from propagating events to that master.
This is useful if we want to (say) receive a mount event
when an optical disk is mounted in the master shared peer
group (in another mount namespace), but want to prevent
mount and unmount events under the slave mount from having
side effects in other namespaces.</p>

<p style="margin-left:11%; margin-top: 1em">We can
demonstrate the effect of slaving by first marking two mount
points as shared in the initial mount namespace:</p>

<p style="margin-left:17%; margin-top: 1em">sh1# <b>mount
--make-shared /mntX</b> <br>
sh1# <b>mount --make-shared /mntY</b> <br>
sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
132 83 8:23 / /mntX rw,relatime shared:1 <br>
133 83 8:22 / /mntY rw,relatime shared:2</p>

<p style="margin-left:11%; margin-top: 1em">On a second
terminal, we create a new mount namespace and inspect the
mount points:</p>

<p style="margin-left:17%; margin-top: 1em">sh2# <b>unshare
-m --propagation unchanged sh</b> <br>
sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
168 167 8:23 / /mntX rw,relatime shared:1 <br>
169 167 8:22 / /mntY rw,relatime shared:2</p>

<p style="margin-left:11%; margin-top: 1em">In the new
mount namespace, we then mark one of the mount points as a
slave:</p>

<p style="margin-left:17%; margin-top: 1em">sh2# <b>mount
--make-slave /mntY</b> <br>
sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
168 167 8:23 / /mntX rw,relatime shared:1 <br>
169 167 8:22 / /mntY rw,relatime master:2</p>

<p style="margin-left:11%; margin-top: 1em">From the above
output, we see that <i>/mntY</i> is now a slave mount that
is receiving propagation events from the shared peer group
with the ID 2.</p>

<p style="margin-left:11%; margin-top: 1em">Continuing in
the new namespace, we create submounts under each of
<i>/mntX</i> and <i>/mntY</i>:</p>

<p style="margin-left:17%; margin-top: 1em">sh2# <b>mkdir
/mntX/a</b> <br>
sh2# <b>mount /dev/sda3 /mntX/a</b> <br>
sh2# <b>mkdir /mntY/b</b> <br>
sh2# <b>mount /dev/sda5 /mntY/b</b></p>

<p style="margin-left:11%; margin-top: 1em">When we inspect
the state of the mount points in the new mount namespace, we
see that <i>/mntX/a</i> was created as a new shared mount
(inheriting the &quot;shared&quot; setting from its parent
mount) and <i>/mntY/b</i> was created as a private
mount:</p>

<p style="margin-left:17%; margin-top: 1em">sh2# <b>cat
/proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
<br>
168 167 8:23 / /mntX rw,relatime shared:1 <br>
169 167 8:22 / /mntY rw,relatime master:2 <br>
173 168 8:3 / /mntX/a rw,relatime shared:3 <br>
175 169 8:5 / /mntY/b rw,relatime</p>

<p style="margin-left:11%; margin-top: 1em">Returning to
the first terminal (in the initial mount namespace), we see
that the mount <i>/mntX/a</i> propagated to the peer (the
shared <i>/mntX</i>), but the mount <i>/mntY/b</i> was not
propagated:</p>

<p style="margin-left:17%; margin-top: 1em">sh1# <b>cat
/proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
<br>
132 83 8:23 / /mntX rw,relatime shared:1 <br>
133 83 8:22 / /mntY rw,relatime shared:2 <br>
174 132 8:3 / /mntX/a rw,relatime shared:3</p>

<p style="margin-left:11%; margin-top: 1em">Now we create a
new mount point under <i>/mntY</i> in the first shell:</p>

<p style="margin-left:17%; margin-top: 1em">sh1# <b>mkdir
/mntY/c</b> <br>
sh1# <b>mount /dev/sda1 /mntY/c</b> <br>
sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
132 83 8:23 / /mntX rw,relatime shared:1 <br>
133 83 8:22 / /mntY rw,relatime shared:2 <br>
174 132 8:3 / /mntX/a rw,relatime shared:3 <br>
178 133 8:1 / /mntY/c rw,relatime shared:4</p>

<p style="margin-left:11%; margin-top: 1em">When we examine
the mount points in the second mount namespace, we see that
in this case the new mount has been propagated to the slave
mount point, and that the new mount is itself a slave mount
(to peer group 4):</p>

<p style="margin-left:17%; margin-top: 1em">sh2# <b>cat
/proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
<br>
168 167 8:23 / /mntX rw,relatime shared:1 <br>
169 167 8:22 / /mntY rw,relatime master:2 <br>
173 168 8:3 / /mntX/a rw,relatime shared:3 <br>
175 169 8:5 / /mntY/b rw,relatime <br>
179 169 8:1 / /mntY/c rw,relatime master:4</p>


<p style="margin-left:11%; margin-top: 1em"><b>MS_UNBINDABLE
example</b> <br>
One of the primary purposes of unbindable mounts is to avoid
the &quot;mount point explosion&quot; problem when
repeatedly performing bind mounts of a higher-level subtree
at a lower-level mount point. The problem is illustrated by
the following shell session.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose we have
a system with the following mount points:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount |
awk '{print $1, $2, $3}'</b> <br>
/dev/sda1 on / <br>
/dev/sdb6 on /mntX <br>
/dev/sdb7 on /mntY</p>

<p style="margin-left:11%; margin-top: 1em">Suppose
furthermore that we wish to recursively bind mount the root
directory under several users&rsquo; home directories. We do
this for the first user, and inspect the mount points:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount
--rbind / /home/cecilia/</b> <br>
# <b>mount | awk '{print $1, $2, $3}'</b> <br>
/dev/sda1 on / <br>
/dev/sdb6 on /mntX <br>
/dev/sdb7 on /mntY <br>
/dev/sda1 on /home/cecilia <br>
/dev/sdb6 on /home/cecilia/mntX <br>
/dev/sdb7 on /home/cecilia/mntY</p>

<p style="margin-left:11%; margin-top: 1em">When we repeat
this operation for the second user, we start to see the
explosion problem:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount
--rbind / /home/henry</b> <br>
# <b>mount | awk '{print $1, $2, $3}'</b> <br>
/dev/sda1 on / <br>
/dev/sdb6 on /mntX <br>
/dev/sdb7 on /mntY <br>
/dev/sda1 on /home/cecilia <br>
/dev/sdb6 on /home/cecilia/mntX <br>
/dev/sdb7 on /home/cecilia/mntY <br>
/dev/sda1 on /home/henry <br>
/dev/sdb6 on /home/henry/mntX <br>
/dev/sdb7 on /home/henry/mntY <br>
/dev/sda1 on /home/henry/home/cecilia <br>
/dev/sdb6 on /home/henry/home/cecilia/mntX <br>
/dev/sdb7 on /home/henry/home/cecilia/mntY</p>

<p style="margin-left:11%; margin-top: 1em">Under
<i>/home/henry</i>, we have not only recursively added the
<i>/mntX</i> and <i>/mntY</i> mounts, but also the recursive
mounts of those directories under <i>/home/cecilia</i> that
were created in the previous step. Upon repeating the step
for a third user, it becomes obvious that the explosion is
exponential in nature:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount
--rbind / /home/otto</b> <br>
# <b>mount | awk '{print $1, $2, $3}'</b> <br>
/dev/sda1 on / <br>
/dev/sdb6 on /mntX <br>
/dev/sdb7 on /mntY <br>
/dev/sda1 on /home/cecilia <br>
/dev/sdb6 on /home/cecilia/mntX <br>
/dev/sdb7 on /home/cecilia/mntY <br>
/dev/sda1 on /home/henry <br>
/dev/sdb6 on /home/henry/mntX <br>
/dev/sdb7 on /home/henry/mntY <br>
/dev/sda1 on /home/henry/home/cecilia <br>
/dev/sdb6 on /home/henry/home/cecilia/mntX <br>
/dev/sdb7 on /home/henry/home/cecilia/mntY <br>
/dev/sda1 on /home/otto <br>
/dev/sdb6 on /home/otto/mntX <br>
/dev/sdb7 on /home/otto/mntY <br>
/dev/sda1 on /home/otto/home/cecilia <br>
/dev/sdb6 on /home/otto/home/cecilia/mntX <br>
/dev/sdb7 on /home/otto/home/cecilia/mntY <br>
/dev/sda1 on /home/otto/home/henry <br>
/dev/sdb6 on /home/otto/home/henry/mntX <br>
/dev/sdb7 on /home/otto/home/henry/mntY <br>
/dev/sda1 on /home/otto/home/henry/home/cecilia <br>
/dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX <br>
/dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY</p>

<p style="margin-left:11%; margin-top: 1em">The mount
explosion problem in the above scenario can be avoided by
making each of the new mounts unbindable. The effect of
doing this is that recursive mounts of the root directory
will not replicate the unbindable mounts. We make such a
mount for the first user:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount
--rbind --make-unbindable / /home/cecilia</b></p>

<p style="margin-left:11%; margin-top: 1em">Before going
further, we show that unbindable mounts are indeed
unbindable:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mkdir
/mntZ</b> <br>
# <b>mount --bind /home/cecilia /mntZ</b> <br>
mount: wrong fs type, bad option, bad superblock on
/home/cecilia, <br>
missing codepage or helper program, or other error</p>

<p style="margin-left:17%; margin-top: 1em">In some cases
useful info is found in syslog - try <br>
dmesg | tail or so.</p>

<p style="margin-left:11%; margin-top: 1em">Now we create
unbindable recursive bind mounts for the other two
users:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount
--rbind --make-unbindable / /home/henry</b> <br>
# <b>mount --rbind --make-unbindable / /home/otto</b></p>

<p style="margin-left:11%; margin-top: 1em">Upon examining
the list of mount points, we see there has been no explosion
of mount points, because the unbindable mounts were not
replicated under each user&rsquo;s directory:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount |
awk '{print $1, $2, $3}'</b> <br>
/dev/sda1 on / <br>
/dev/sdb6 on /mntX <br>
/dev/sdb7 on /mntY <br>
/dev/sda1 on /home/cecilia <br>
/dev/sdb6 on /home/cecilia/mntX <br>
/dev/sdb7 on /home/cecilia/mntY <br>
/dev/sda1 on /home/henry <br>
/dev/sdb6 on /home/henry/mntX <br>
/dev/sdb7 on /home/henry/mntY <br>
/dev/sda1 on /home/otto <br>
/dev/sdb6 on /home/otto/mntX <br>
/dev/sdb7 on /home/otto/mntY</p>

<p style="margin-left:11%; margin-top: 1em"><b>Propagation
type transitions</b> <br>
The following table shows the effect that applying a new
propagation type (i.e., <i>mount --make-xxxx</i>) has on the
existing propagation type of a mount point. The rows
correspond to existing propagation types, and the columns
are the new propagation settings. For reasons of space,
&quot;private&quot; is abbreviated as &quot;priv&quot; and
&quot;unbindable&quot; as &quot;unbind&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%">
</td></tr>
</table>


<p align="center"><img src="grohtml-3520431.png" alt="Image grohtml-3520431.png"></p>

<p style="margin-left:11%; margin-top: 1em">Note the
following details to the table:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>If a shared mount is the only mount in its peer group,
making it a slave automatically makes it private.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>Slaving a nonshared mount has no effect on the
mount.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Bind
(MS_BIND) semantics</b> <br>
Suppose that the following command is performed:</p>

<p style="margin-left:17%; margin-top: 1em">mount --bind
A/a B/b</p>

<p style="margin-left:11%; margin-top: 1em">Here, <i>A</i>
is the source mount point, <i>B</i> is the destination mount
point, <i>a</i> is a subdirectory path under the mount point
<i>A</i>, and <i>b</i> is a subdirectory path under the
mount point <i>B</i>. The propagation type of the resulting
mount, <i>B/b</i>, depends on the propagation types of the
mount points <i>A</i> and <i>B</i>, and is summarized in the
following table.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3520432.png" alt="Image grohtml-3520432.png"></p>

<p style="margin-left:11%; margin-top: 1em">Note that a
recursive bind of a subtree follows the same semantics as
for a bind operation on each mount in the subtree.
(Unbindable mounts are automatically pruned at the target
mount point.)</p>

<p style="margin-left:11%; margin-top: 1em">For further
details, see
<i>Documentation/filesystems/sharedsubtree.txt</i> in the
kernel source tree.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Move
(MS_MOVE) semantics</b> <br>
Suppose that the following command is performed:</p>

<p style="margin-left:17%; margin-top: 1em">mount --move A
B/b</p>

<p style="margin-left:11%; margin-top: 1em">Here, <i>A</i>
is the source mount point, <i>B</i> is the destination mount
point, and <i>b</i> is a subdirectory path under the mount
point <i>B</i>. The propagation type of the resulting mount,
<i>B/b</i>, depends on the propagation types of the mount
points <i>A</i> and <i>B</i>, and is summarized in the
following table.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3520433.png" alt="Image grohtml-3520433.png"></p>

<p style="margin-left:11%; margin-top: 1em">Note: moving a
mount that resides under a shared mount is invalid.</p>

<p style="margin-left:11%; margin-top: 1em">For further
details, see
<i>Documentation/filesystems/sharedsubtree.txt</i> in the
kernel source tree.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mount
semantics</b> <br>
Suppose that we use the following command to create a mount
point:</p>

<p style="margin-left:17%; margin-top: 1em">mount device
B/b</p>

<p style="margin-left:11%; margin-top: 1em">Here, <i>B</i>
is the destination mount point, and <i>b</i> is a
subdirectory path under the mount point <i>B</i>. The
propagation type of the resulting mount, <i>B/b</i>, follows
the same rules as for a bind mount, where the propagation
type of the source mount is considered always to be
private.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unmount
semantics</b> <br>
Suppose that we use the following command to tear down a
mount point:</p>

<p style="margin-left:17%; margin-top: 1em">unmount A</p>

<p style="margin-left:11%; margin-top: 1em">Here, <i>A</i>
is a mount point on <i>B/b</i>, where <i>B</i> is the parent
mount and <i>b</i> is a subdirectory path under the mount
point <i>B</i>. If <b>B</b> is shared, then all
most-recently-mounted mounts at <i>b</i> on mounts that
receive propagation from mount <i>B</i> and do not have
submounts under them are unmounted.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
/proc/[pid]/mountinfo propagate_from tag</b> <br>
The <i>propagate_from:X</i> tag is shown in the optional
fields of a <i>/proc/[pid]/mountinfo</i> record in cases
where a process can&rsquo;t see a slave&rsquo;s immediate
master (i.e., the pathname of the master is not reachable
from the filesystem root directory) and so cannot determine
the chain of propagation between the mounts it can see.</p>

<p style="margin-left:11%; margin-top: 1em">In the
following example, we first create a two-link master-slave
chain between the mounts <i>/mnt</i>, <i>/tmp/etc</i>, and
<i>/mnt/tmp/etc</i>. Then the <a href="https://man.page/1/chroot">chroot(1)</a> command is
used to make the <i>/tmp/etc</i> mount point unreachable
from the root directory, creating a situation where the
master of <i>/mnt/tmp/etc</i> is not reachable from the
(new) root directory of the process.</p>

<p style="margin-left:11%; margin-top: 1em">First, we bind
mount the root directory onto <i>/mnt</i> and then bind
mount <i>/proc</i> at <i>/mnt/proc</i> so that after the
later <a href="https://man.page/1/chroot">chroot(1)</a> the <a href="https://man.page/5/proc">proc(5)</a> filesystem remains
visible at the correct location in the chroot-ed
environment.</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mkdir -p
/mnt/proc</b> <br>
# <b>mount --bind / /mnt</b> <br>
# <b>mount --bind /proc /mnt/proc</b></p>

<p style="margin-left:11%; margin-top: 1em">Next, we ensure
that the <i>/mnt</i> mount is a shared mount in a new peer
group (with no peers):</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount
--make-private /mnt</b> # Isolate from any previous peer
group <br>
# <b>mount --make-shared /mnt</b> <br>
# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ -
.*//'</b> <br>
239 61 8:2 / /mnt ... shared:102 <br>
248 239 0:4 / /mnt/proc ... shared:5</p>

<p style="margin-left:11%; margin-top: 1em">Next, we bind
mount <i>/mnt/etc</i> onto <i>/tmp/etc</i>:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mkdir -p
/tmp/etc</b> <br>
# <b>mount --bind /mnt/etc /tmp/etc</b> <br>
# <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/
- .*//'</b> <br>
239 61 8:2 / /mnt ... shared:102 <br>
248 239 0:4 / /mnt/proc ... shared:5 <br>
267 40 8:2 /etc /tmp/etc ... shared:102</p>

<p style="margin-left:11%; margin-top: 1em">Initially,
these two mount points are in the same peer group, but we
then make the <i>/tmp/etc</i> a slave of <i>/mnt/etc</i>,
and then make <i>/tmp/etc</i> shared as well, so that it can
propagate events to the next slave in the chain:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mount
--make-slave /tmp/etc</b> <br>
# <b>mount --make-shared /tmp/etc</b> <br>
# <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/
- .*//'</b> <br>
239 61 8:2 / /mnt ... shared:102 <br>
248 239 0:4 / /mnt/proc ... shared:5 <br>
267 40 8:2 /etc /tmp/etc ... shared:105 master:102</p>

<p style="margin-left:11%; margin-top: 1em">Then we bind
mount <i>/tmp/etc</i> onto <i>/mnt/tmp/etc</i>. Again, the
two mount points are initially in the same peer group, but
we then make <i>/mnt/tmp/etc</i> a slave of
<i>/tmp/etc</i>:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>mkdir -p
/mnt/tmp/etc</b> <br>
# <b>mount --bind /tmp/etc /mnt/tmp/etc</b> <br>
# <b>mount --make-slave /mnt/tmp/etc</b> <br>
# <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/
- .*//'</b> <br>
239 61 8:2 / /mnt ... shared:102 <br>
248 239 0:4 / /mnt/proc ... shared:5 <br>
267 40 8:2 /etc /tmp/etc ... shared:105 master:102 <br>
273 239 8:2 /etc /mnt/tmp/etc ... master:105</p>

<p style="margin-left:11%; margin-top: 1em">From the above,
we see that <i>/mnt</i> is the master of the slave
<i>/tmp/etc</i>, which in turn is the master of the slave
<i>/mnt/tmp/etc</i>.</p>

<p style="margin-left:11%; margin-top: 1em">We then
<a href="https://man.page/1/chroot">chroot(1)</a> to the <i>/mnt</i> directory, which renders
the mount with ID 267 unreachable from the (new) root
directory:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>chroot
/mnt</b></p>

<p style="margin-left:11%; margin-top: 1em">When we examine
the state of the mounts inside the chroot-ed environment, we
see the following:</p>

<p style="margin-left:17%; margin-top: 1em"># <b>cat
/proc/self/mountinfo | sed 's/ - .*//'</b> <br>
239 61 8:2 / / ... shared:102 <br>
248 239 0:4 / /proc ... shared:5 <br>
273 239 8:2 /etc /tmp/etc ... master:105
propagate_from:102</p>

<p style="margin-left:11%; margin-top: 1em">Above, we see
that the mount with ID 273 is a slave whose master is the
peer group 105. The mount point for that master is
unreachable, and so a <i>propagate_from</i> tag is
displayed, indicating that the closest dominant peer group
(i.e., the nearest reachable mount in the slave chain) is
the peer group with the ID 102 (corresponding to the
<i>/mnt</i> mount point before the <a href="https://man.page/1/chroot">chroot(1)</a> was
performed.</p>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Mount
namespaces first appeared in Linux 2.4.19.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Namespaces are
a Linux-specific feature.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The propagation
type assigned to a new mount point depends on the
propagation type of the parent mount. If the mount point has
a parent (i.e., it is a non-root mount point) and the
propagation type of the parent is <b>MS_SHARED</b>, then the
propagation type of the new mount is also <b>MS_SHARED</b>.
Otherwise, the propagation type of the new mount is
<b>MS_PRIVATE</b>.</p>


<p style="margin-left:11%; margin-top: 1em">Notwithstanding
the fact that the default propagation type for new mount
points is in many cases <b>MS_PRIVATE</b>, <b>MS_SHARED</b>
is typically more useful. For this reason, <a href="https://man.page/1/systemd">systemd(1)</a>
automatically remounts all mount points as <b>MS_SHARED</b>
on system startup. Thus, on most modern systems, the default
propagation type is in practice <b>MS_SHARED</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Since, when one
uses <a href="https://man.page/1/unshare">unshare(1)</a> to create a mount namespace, the goal
is commonly to provide full isolation of the mount points in
the new namespace, <a href="https://man.page/1/unshare">unshare(1)</a> (since
<i>util-linux</i> version 2.27) in turn reverses the step
performed by <a href="https://man.page/1/systemd">systemd(1)</a>, by making all mount points
private in the new namespace. That is, <a href="https://man.page/1/unshare">unshare(1)</a>
performs the equivalent of the following in the new mount
namespace:</p>

<p style="margin-left:17%; margin-top: 1em">mount
--make-rprivate /</p>

<p style="margin-left:11%; margin-top: 1em">To prevent
this, one can use the <i>--propagation&nbsp;unchanged</i>
option to <a href="https://man.page/1/unshare">unshare(1)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">An application
that creates a new mount namespace directly using
<a href="https://man.page/2/clone">clone(2)</a> or <a href="https://man.page/2/unshare">unshare(2)</a> may desire to prevent
propagation of mount events to other mount namespaces (as is
done by <a href="https://man.page/1/unshare">unshare(1)</a>). This can be done by changing the
propagation type of mount points in the new namespace to
either <b>MS_SLAVE</b> or <b>MS_PRIVATE</b>. using a call
such as the following:</p>

<p style="margin-left:17%; margin-top: 1em">mount(NULL,
&quot;/&quot;, MS_SLAVE | MS_REC, NULL);</p>

<p style="margin-left:11%; margin-top: 1em">For a
discussion of propagation types when moving mounts
(<b>MS_MOVE</b>) and creating bind mounts (<b>MS_BIND</b>),
see <i>Documentation/filesystems/sharedsubtree.txt</i>.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<a href="https://man.page/2/pivot_root">pivot_root(2)</a>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/1/unshare">unshare(1)</a>,
<a href="https://man.page/2/clone">clone(2)</a>, <a href="https://man.page/2/mount">mount(2)</a>, <a href="https://man.page/2/pivot_root">pivot_root(2)</a>,
<a href="https://man.page/2/setns">setns(2)</a>, <a href="https://man.page/2/umount">umount(2)</a>, <a href="https://man.page/2/unshare">unshare(2)</a>,
<a href="https://man.page/5/proc">proc(5)</a>, <a href="https://man.page/7/namespaces">namespaces(7)</a>,
<a href="https://man.page/7/user_namespaces">user_namespaces(7)</a>, <b>findmnt</b>(8),
<b>mount</b>(8), <b>pivot_root</b>(8), <b>umount</b>(8)</p>


<p style="margin-left:11%; margin-top: 1em"><i>Documentation/filesystems/sharedsubtree.txt</i>
in the kernel source tree.</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
