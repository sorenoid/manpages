<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:50 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>BOOTUP</title>

</head>
<body>

<h1 align="center">BOOTUP</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SYSTEM MANAGER BOOTUP">SYSTEM MANAGER BOOTUP</a><br>
<a href="#USER MANAGER STARTUP">USER MANAGER STARTUP</a><br>
<a href="#BOOTUP IN THE INITIAL RAM DISK (INITRD)">BOOTUP IN THE INITIAL RAM DISK (INITRD)</a><br>
<a href="#SYSTEM MANAGER SHUTDOWN">SYSTEM MANAGER SHUTDOWN</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">bootup - System
bootup process</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A number of
different components are involved in the boot of a Linux
system. Immediately after power-up, the system firmware will
do minimal hardware initialization, and hand control over to
a boot loader (e.g. <b>systemd-boot</b>(7) or
<b><font color="#0000FF">GRUB</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">) stored on a persistent storage
device. This boot loader will then invoke an OS kernel from
disk (or the network). On systems using EFI or other types
of firmware, this firmware may also load the kernel
directly.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
kernel (optionally) mounts an in-memory file system, often
generated by <b>dracut</b>(8), which looks for the root file
system. Nowadays this is usually implemented as an initramfs
&mdash; a compressed archive which is extracted when the
kernel boots up into a lightweight in-memory file system
based on tmpfs, but in the past normal file systems using an
in-memory block device (ramdisk) were used, and the name
&quot;initrd&quot; is still used to describe both concepts.
It's the boot loader or the firmware that loads both the
kernel and initrd/initramfs images into memory, but the
kernel which interprets it as a file system.
<b>systemd</b>(1) may be used to manage services in the
initrd, similarly to the real system.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">After
the root file system is found and mounted, the initrd hands
over control to the host's system manager (such as
<b>systemd</b>(1)) stored in the root file system, which is
then responsible for probing all remaining hardware,
mounting all necessary file systems and spawning all
configured services.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">On
shutdown, the system manager stops all services, unmounts
all file systems (detaching the storage technologies backing
them), and then (optionally) jumps back into the initrd code
which unmounts/detaches the root file system and the storage
it resides on. As a last step, the system is powered
down.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Additional
information about the system boot process may be found in
<b>boot</b>(7).</font></p>

<h2>SYSTEM MANAGER BOOTUP
<a name="SYSTEM MANAGER BOOTUP"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">At
boot, the system manager on the OS image is responsible for
initializing the required file systems, services and drivers
that are necessary for operation of the system. On
<b>systemd</b>(1) systems, this process is split up in
various discrete steps which are exposed as target units.
(See <b>systemd.target</b>(5) for detailed information about
target units.) The boot-up process is highly parallelized so
that the order in which specific target units are reached is
not deterministic, but still adheres to a limited amount of
ordering structure.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">When
systemd starts up the system, it will activate all units
that are dependencies of default.target (as well as
recursively all dependencies of these dependencies).
Usually, default.target is simply an alias of
graphical.target or multi-user.target, depending on whether
the system is configured for a graphical UI or only for a
text console. To enforce minimal ordering between the units
pulled in, a number of well-known target units are
available, as listed on
<b>systemd.special</b>(7).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following chart is a structural overview of these well-known
units and their position in the boot-up logic. The arrows
describe which units are pulled in and ordered before which
other units. Units near the top are started before units
nearer to the bottom of the chart.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">cryptsetup-pre.target
veritysetup-pre.target <br>
| <br>
(various low-level v <br>
API VFS mounts: (various cryptsetup/veritysetup devices...)
<br>
mqueue, configfs, | | <br>
debugfs, ...) v | <br>
| cryptsetup.target | <br>
| (various swap | | remote-fs-pre.target <br>
| devices...) | | | | <br>
| | | | | v <br>
| v local-fs-pre.target | | | (network file systems) <br>
| swap.target | | v v | <br>
| | v | remote-cryptsetup.target | <br>
| | (various low-level (various mounts and |
remote-veritysetup.target | <br>
| | services: udevd, fsck services...) | | remote-fs.target
<br>
| | tmpfiles, random | | | / <br>
| | seed, sysctl, ...) v | | / <br>
| | | local-fs.target | | / <br>
| | | | | | / <br>
\____|______|_______________ ______|___________/ | / <br>
\ / | / <br>
v | / <br>
sysinit.target | / <br>
| | / <br>
______________________/|\_____________________ | / <br>
/ | | | \ | / <br>
| | | | | | / <br>
v v | v | | / <br>
(various (various | (various | |/ <br>
timers...) paths...) | sockets...) | | <br>
| | | | | | <br>
v v | v | | <br>
timers.target paths.target | sockets.target | | <br>
| | | | v | <br>
v \_______ | _____/ rescue.service | <br>
\|/ | | <br>
v v | <br>
basic.target <i>rescue.target</i> | <br>
| | <br>
________v____________________ | <br>
/ | \ | <br>
| | | | <br>
v v v | <br>
display- (various system (various system | <br>
manager.service services services) | <br>
| required for | | <br>
| graphical UIs) v v <br>
| | <i>multi-user.target</i> <br>
emergency.service | | | <br>
| \_____________ | _____________/ <br>
v \|/ <i><br>
emergency.target</i> v <i><br>
graphical.target</i></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Target
units that are commonly used as boot targets are
<i>emphasized</i>. These units are good choices as goal
targets, for example by passing them to the
<i>systemd.unit=</i> kernel command line option (see
<b>systemd</b>(1)) or by symlinking default.target to
them.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">timers.target
is pulled-in by basic.target asynchronously. This allows
timers units to depend on services which become only
available later in boot.</font></p>

<h2>USER MANAGER STARTUP
<a name="USER MANAGER STARTUP"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
system manager starts the user@<i>uid</i>.service unit for
each user, which launches a separate unprivileged instance
of <b>systemd</b> for each user &mdash; the user manager.
Similarly to the system manager, the user manager starts
units which are pulled in by default.target. The following
chart is a structural overview of the well-known user units.
For non-graphical sessions, default.target is used. Whenever
the user logs into a graphical session, the login manager
will start the graphical-session.target target that is used
to pull in units required for the graphical session. A
number of targets (shown on the right side) are started when
specific hardware is available to the user.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">(various
(various (various <br>
timers...) paths...) sockets...) (sound devices) <br>
| | | | <br>
v v v v <br>
timers.target paths.target sockets.target sound.target <br>
| | | <br>
\______________ _|_________________/ (bluetooth devices)
<br>
\ / | <br>
V v <br>
basic.target bluetooth.target <br>
| <br>
__________/ \_______ (smartcard devices) <br>
/ \ | <br>
| | v <br>
| v smartcard.target <br>
v graphical-session-pre.target <br>
(various user services) | (printers) <br>
| v | <br>
| (services for the graphical session) v <br>
| | printer.target <br>
v v <i><br>
default.target</i> graphical-session.target</font></p>

<h2>BOOTUP IN THE INITIAL RAM DISK (INITRD)
<a name="BOOTUP IN THE INITIAL RAM DISK (INITRD)"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
initial RAM disk implementation (initrd) can be set up using
systemd as well. In this case, boot up inside the initrd
follows the following structure.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">systemd
detects that it is run within an initrd by checking for the
file /etc/initrd-release. The default target in the initrd
is initrd.target. The bootup process begins identical to the
system manager bootup (see above) until it reaches
basic.target. From there, systemd approaches the special
target initrd.target. Before any file systems are mounted,
it must be determined whether the system will resume from
hibernation or proceed with normal boot. This is
accomplished by systemd-hibernate-resume@.service which must
be finished before local-fs-pre.target, so no filesystems
can be mounted before the check is complete. When the root
device becomes available, initrd-root-device.target is
reached. If the root device can be mounted at /sysroot, the
sysroot.mount unit becomes active and initrd-root-fs.target
is reached. The service initrd-parse-etc.service scans
/sysroot/etc/fstab for a possible /usr/ mount point and
additional entries marked with the <i>x-initrd.mount</i>
option. All entries found are mounted below /sysroot, and
initrd-fs.target is reached. The service
initrd-cleanup.service isolates to the
initrd-switch-root.target, where cleanup services can run.
As the very last step, the initrd-switch-root.service is
activated, which will cause the system to switch its root to
/sysroot.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">:
(beginning identical to above) <br>
: <br>
v <br>
basic.target <br>
| emergency.service <br>
______________________/| | <br>
/ | v <br>
| initrd-root-device.target <i>emergency.target</i> <br>
| | <br>
| v <br>
| sysroot.mount <br>
| | <br>
| v <br>
| initrd-root-fs.target <br>
| | <br>
| v <br>
v initrd-parse-etc.service <br>
(custom initrd | <br>
services...) v <br>
| (sysroot-usr.mount and <br>
| various mounts marked <br>
| with fstab option <br>
| x-initrd.mount...) <br>
| | <br>
| v <br>
| initrd-fs.target <br>
\______________________ | <br>
\| <br>
v <br>
initrd.target <br>
| <br>
v <br>
initrd-cleanup.service <br>
isolates to <br>
initrd-switch-root.target <br>
| <br>
v <br>
______________________/| <br>
/ v <br>
| initrd-udevadm-cleanup-db.service <br>
v | <br>
(custom initrd | <br>
services...) | <br>
\______________________ | <br>
\| <br>
v <br>
initrd-switch-root.target <br>
| <br>
v <br>
initrd-switch-root.service <br>
| <br>
v <br>
Transition to Host OS</font></p>

<h2>SYSTEM MANAGER SHUTDOWN
<a name="SYSTEM MANAGER SHUTDOWN"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">System
shutdown with systemd also consists of various target units
with some minimal ordering structure applied:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">(conflicts
with (conflicts with <br>
all system all file system <br>
services) mounts, swaps, <br>
| cryptsetup/ <br>
| veritysetup <br>
| devices, ...) <br>
| | <br>
v v <br>
shutdown.target umount.target <br>
| | <br>
\_______ ______/ <br>
\ / <br>
v <br>
(various low-level <br>
services) <br>
| <br>
v <br>
final.target <br>
| <br>
_____________________________________/
\_________________________________ <br>
/ | | \ <br>
| | | | <br>
v v v v <br>
systemd-reboot.service systemd-poweroff.service
systemd-halt.service systemd-kexec.service <br>
| | | | <br>
v v v v <i><br>
reboot.target poweroff.target halt.target
kexec.target</i></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Commonly
used system shutdown targets are
<i>emphasized</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that <b>systemd-halt.service</b>(8), systemd-reboot.service,
systemd-poweroff.service and systemd-kexec.service will
transition the system and server manager (PID 1) into the
second phase of system shutdown (implemented in the
systemd-shutdown binary), which will unmount any remaining
file systems, kill any remaining processes and release any
other remaining resources, in a simple and robust fashion,
without taking any service or unit concept into account
anymore. At that point, regular applications and resources
are generally terminated and released already, the second
phase hence operates only as safety net for everything that
couldn't be stopped or released for some reason during the
primary, unit-based shutdown phase described
above.</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>systemd</b>(1),
<b>boot</b>(7), <b>systemd.special</b>(7),
<b>systemd.target</b>(5), <b>systemd-halt.service</b>(8),
<b>dracut</b>(8)</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="6%">



<p style="margin-top: 1em"><font color="#000000">GRUB</font></p> </td>
<td width="77%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://www.gnu.org/software/grub/</font></p>
<hr>
</body>
</html>
