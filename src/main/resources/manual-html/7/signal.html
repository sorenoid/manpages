<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:42 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SIGNAL</title>

</head>
<body>

<h1 align="center">SIGNAL</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">signal -
overview of signals</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Linux supports
both POSIX reliable signals (hereinafter &quot;standard
signals&quot;) and POSIX real-time signals.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Signal
dispositions</b> <br>
Each signal has a current <i>disposition</i>, which
determines how the process behaves when it is delivered the
signal.</p>

<p style="margin-left:11%; margin-top: 1em">The entries in
the &quot;Action&quot; column of the table below specify the
default disposition for each signal, as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>Term</p></td>
<td width="5%"></td>
<td width="78%">


<p>Default action is to terminate the process.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>Ign</p></td>
<td width="5%"></td>
<td width="78%">


<p>Default action is to ignore the signal.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>Core</p></td>
<td width="5%"></td>
<td width="78%">


<p>Default action is to terminate the process and dump core
(see <a href="https://man.page/5/core">core(5)</a>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>Stop</p></td>
<td width="5%"></td>
<td width="78%">


<p>Default action is to stop the process.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>Cont</p></td>
<td width="5%"></td>
<td width="78%">


<p>Default action is to continue the process if it is
currently stopped.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A process can
change the disposition of a signal using <a href="https://man.page/2/sigaction">sigaction(2)</a>
or <a href="https://man.page/2/signal">signal(2)</a>. (The latter is less portable when
establishing a signal handler; see <a href="https://man.page/2/signal">signal(2)</a> for
details.) Using these system calls, a process can elect one
of the following behaviors to occur on delivery of the
signal: perform the default action; ignore the signal; or
catch the signal with a <i>signal handler</i>, a
programmer-defined function that is automatically invoked
when the signal is delivered.</p>

<p style="margin-left:11%; margin-top: 1em">By default, a
signal handler is invoked on the normal process stack. It is
possible to arrange that the signal handler uses an
alternate stack; see <a href="https://man.page/2/sigaltstack">sigaltstack(2)</a> for a discussion
of how to do this and when it might be useful.</p>

<p style="margin-left:11%; margin-top: 1em">The signal
disposition is a per-process attribute: in a multithreaded
application, the disposition of a particular signal is the
same for all threads.</p>

<p style="margin-left:11%; margin-top: 1em">A child created
via <a href="https://man.page/2/fork">fork(2)</a> inherits a copy of its parent&rsquo;s
signal dispositions. During an <a href="https://man.page/2/execve">execve(2)</a>, the
dispositions of handled signals are reset to the default;
the dispositions of ignored signals are left unchanged.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Sending a
signal</b> <br>
The following system calls and library functions allow the
caller to send a signal: <b><br>
raise</b>(3)</p>

<p style="margin-left:22%;">Sends a signal to the calling
thread.</p>

<p style="margin-left:11%;"><a href="https://man.page/2/kill">kill(2)</a></p>

<p style="margin-left:22%;">Sends a signal to a specified
process, to all members of a specified process group, or to
all processes on the system.</p>


<p style="margin-left:11%;"><a href="https://man.page/2/pidfd_send_signal">pidfd_send_signal(2)</a></p>

<p style="margin-left:22%;">Sends a signal to a process
identified by a PID file descriptor.</p>

<p style="margin-left:11%;"><a href="https://man.page/3/killpg">killpg(3)</a></p>

<p style="margin-left:22%;">Sends a signal to all of the
members of a specified process group.</p>

<p style="margin-left:11%;"><a href="https://man.page/3/pthread_kill">pthread_kill(3)</a></p>

<p style="margin-left:22%;">Sends a signal to a specified
POSIX thread in the same process as the caller.</p>

<p style="margin-left:11%;"><a href="https://man.page/2/tgkill">tgkill(2)</a></p>

<p style="margin-left:22%;">Sends a signal to a specified
thread within a specific process. (This is the system call
used to implement <a href="https://man.page/3/pthread_kill">pthread_kill(3)</a>.)</p>

<p style="margin-left:11%;"><a href="https://man.page/3/sigqueue">sigqueue(3)</a></p>

<p style="margin-left:22%;">Sends a real-time signal with
accompanying data to a specified process.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Waiting for
a signal to be caught</b> <br>
The following system calls suspend execution of the calling
thread until a signal is caught (or an unhandled signal
terminates the process): <b><br>
pause</b>(2)</p>

<p style="margin-left:22%;">Suspends execution until any
signal is caught.</p>

<p style="margin-left:11%;"><a href="https://man.page/2/sigsuspend">sigsuspend(2)</a></p>

<p style="margin-left:22%;">Temporarily changes the signal
mask (see below) and suspends execution until one of the
unmasked signals is caught.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Synchronously
accepting a signal</b> <br>
Rather than asynchronously catching a signal via a signal
handler, it is possible to synchronously accept the signal,
that is, to block execution until the signal is delivered,
at which point the kernel returns information about the
signal to the caller. There are two general ways to do
this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/sigwaitinfo">sigwaitinfo(2)</a>, <a href="https://man.page/2/sigtimedwait">sigtimedwait(2)</a>, and
<a href="https://man.page/3/sigwait">sigwait(3)</a> suspend execution until one of the signals
in a specified set is delivered. Each of these calls returns
information about the delivered signal.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/signalfd">signalfd(2)</a> returns a file descriptor that can be
used to read information about signals that are delivered to
the caller. Each <a href="https://man.page/2/read">read(2)</a> from this file descriptor
blocks until one of the signals in the set specified in the
<a href="https://man.page/2/signalfd">signalfd(2)</a> call is delivered to the caller. The
buffer returned by <a href="https://man.page/2/read">read(2)</a> contains a structure
describing the signal.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Signal mask
and pending signals</b> <br>
A signal may be <i>blocked</i>, which means that it will not
be delivered until it is later unblocked. Between the time
when it is generated and when it is delivered a signal is
said to be <i>pending</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Each thread in
a process has an independent <i>signal mask</i>, which
indicates the set of signals that the thread is currently
blocking. A thread can manipulate its signal mask using
<a href="https://man.page/3/pthread_sigmask">pthread_sigmask(3)</a>. In a traditional single-threaded
application, <a href="https://man.page/2/sigprocmask">sigprocmask(2)</a> can be used to manipulate
the signal mask.</p>

<p style="margin-left:11%; margin-top: 1em">A child created
via <a href="https://man.page/2/fork">fork(2)</a> inherits a copy of its parent&rsquo;s
signal mask; the signal mask is preserved across
<a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">A signal may be
process-directed or thread-directed. A process-directed
signal is one that is targeted at (and thus pending for) the
process as a whole. A signal may be process-directed because
it was generated by the kernel for reasons other than a
hardware exception, or because it was sent using
<a href="https://man.page/2/kill">kill(2)</a> or <a href="https://man.page/3/sigqueue">sigqueue(3)</a>. A thread-directed
signal is one that is targeted at a specific thread. A
signal may be thread-directed because it was generated as a
consequence of executing a specific machine-language
instruction that triggered a hardware exception (e.g.,
<b>SIGSEGV</b> for an invalid memory access, or
<b>SIGFPE</b> for a math error), or because it was targeted
at a specific thread using interfaces such as
<a href="https://man.page/2/tgkill">tgkill(2)</a> or <a href="https://man.page/3/pthread_kill">pthread_kill(3)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">A
process-directed signal may be delivered to any one of the
threads that does not currently have the signal blocked. If
more than one of the threads has the signal unblocked, then
the kernel chooses an arbitrary thread to which to deliver
the signal.</p>

<p style="margin-left:11%; margin-top: 1em">A thread can
obtain the set of signals that it currently has pending
using <a href="https://man.page/2/sigpending">sigpending(2)</a>. This set will consist of the
union of the set of pending process-directed signals and the
set of signals pending for the calling thread.</p>

<p style="margin-left:11%; margin-top: 1em">A child created
via <a href="https://man.page/2/fork">fork(2)</a> initially has an empty pending signal
set; the pending signal set is preserved across an
<a href="https://man.page/2/execve">execve(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Execution of
signal handlers</b> <br>
Whenever there is a transition from kernel-mode to user-mode
execution (e.g., on return from a system call or scheduling
of a thread onto the CPU), the kernel checks whether there
is a pending unblocked signal for which the process has
established a signal handler. If there is such a pending
signal, the following steps occur:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">The kernel performs the
necessary preparatory steps for execution of the signal
handler:</p> </td></tr>
</table>

<p style="margin-left:15%;">a)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="3%"></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em">The signal is removed from the
set of pending signals.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="3%">


<p>b)</p></td>
<td width="2%"></td>
<td width="80%">


<p>If the signal handler was installed by a call to
<a href="https://man.page/2/sigaction">sigaction(2)</a> that specified the <b>SA_ONSTACK</b>
flag and the thread has defined an alternate signal stack
(using <a href="https://man.page/2/sigaltstack">sigaltstack(2)</a>), then that stack is
installed.</p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="3%">


<p>c)</p></td>
<td width="2%"></td>
<td width="80%">


<p>Various pieces of signal-related context are saved into
a special frame that is created on the stack. The saved
information includes:</p></td></tr>
</table>

<p style="margin-left:20%;">+</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%"></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">the program counter register
(i.e., the address of the next instruction in the main
program that should be executed when the signal handler
returns);</p> </td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>+</p></td>
<td width="1%"></td>
<td width="77%">


<p>architecture-specific register state required for
resuming the interrupted program;</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>+</p></td>
<td width="1%"></td>
<td width="77%">


<p>the thread&rsquo;s current signal mask;</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>+</p></td>
<td width="1%"></td>
<td width="77%">


<p>the thread&rsquo;s alternate signal stack settings.</p></td></tr>
</table>

<p style="margin-left:20%; margin-top: 1em">(If the signal
handler was installed using the <a href="https://man.page/2/sigaction">sigaction(2)</a>
<b>SA_SIGINFO</b> flag, then the above information is
accessible via the <i>ucontext_t</i> object that is pointed
to by the third argument of the signal handler.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em">d)</p></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em">Any signals specified in
<i>act-&gt;sa_mask</i> when registering the handler with
<a href="https://man.page/2/sigprocmask">sigprocmask(2)</a> are added to the thread&rsquo;s signal
mask. The signal being delivered is also added to the signal
mask, unless <b>SA_NODEFER</b> was specified when
registering the handler. These signals are thus blocked
while the handler executes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>2.</p></td>
<td width="2%"></td>
<td width="80%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">The kernel
constructs a frame for the signal handler on the stack. The
kernel sets the program counter for the thread to point to
the first instruction of the signal handler function, and
configures the return address for that function to point to
a piece of user-space code known as the signal trampoline
(described in <a href="https://man.page/2/sigreturn">sigreturn(2)</a>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">The kernel passes control back
to user-space, where execution commences at the start of the
signal handler function.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="85%">


<p>When the signal handler returns, control passes to the
signal trampoline code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The signal trampoline calls <a href="https://man.page/2/sigreturn">sigreturn(2)</a>, a
system call that uses the information in the stack frame
created in step 1 to restore the thread to its state before
the signal handler was called. The thread&rsquo;s signal
mask and alternate signal stack settings are restored as
part of this procedure. Upon completion of the call to
<a href="https://man.page/2/sigreturn">sigreturn(2)</a>, the kernel transfers control back to
user space, and the thread recommences execution at the
point where it was interrupted by the signal handler.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that if
the signal handler does not return (e.g., control is
transferred out of the handler using <a href="https://man.page/3/siglongjmp">siglongjmp(3)</a>,
or the handler executes a new program with
<a href="https://man.page/2/execve">execve(2)</a>), then the final step is not performed. In
particular, in such scenarios it is the programmer&rsquo;s
responsibility to restore the state of the signal mask
(using <a href="https://man.page/2/sigprocmask">sigprocmask(2)</a>), if it is desired to unblock
the signals that were blocked on entry to the signal
handler. (Note that <a href="https://man.page/3/siglongjmp">siglongjmp(3)</a> may or may not
restore the signal mask, depending on the <i>savesigs</i>
value that was specified in the corresponding call to
<a href="https://man.page/3/sigsetjmp">sigsetjmp(3)</a>.)</p>

<p style="margin-left:11%; margin-top: 1em">From the
kernel&rsquo;s point of view, execution of the signal
handler code is exactly the same as the execution of any
other user-space code. That is to say, the kernel does not
record any special state information indicating that the
thread is currently excuting inside a signal handler. All
necessary state information is maintained in user-space
registers and the user-space stack. The depth to which
nested signal handlers may be invoked is thus limited only
by the user-space stack (and sensible software design!).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Standard
signals</b> <br>
Linux supports the standard signals listed below. The second
column of the table indicates which standard (if any)
specified the signal: &quot;P1990&quot; indicates that the
signal is described in the original POSIX.1-1990 standard;
&quot;P2001&quot; indicates that the signal was added in
SUSv2 and POSIX.1-2001.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3511981.png" alt="Image grohtml-3511981.png"></p>

<p style="margin-left:11%; margin-top: 1em">The signals
<b>SIGKILL</b> and <b>SIGSTOP</b> cannot be caught, blocked,
or ignored.</p>

<p style="margin-left:11%; margin-top: 1em">Up to and
including Linux 2.2, the default behavior for <b>SIGSYS</b>,
<b>SIGXCPU</b>, <b>SIGXFSZ</b>, and (on architectures other
than SPARC and MIPS) <b>SIGBUS</b> was to terminate the
process (without a core dump). (On some other UNIX systems
the default action for <b>SIGXCPU</b> and <b>SIGXFSZ</b> is
to terminate the process without a core dump.) Linux 2.4
conforms to the POSIX.1-2001 requirements for these signals,
terminating the process with a core dump.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SIGEMT</b>
is not specified in POSIX.1-2001, but nevertheless appears
on most other UNIX systems, where its default action is
typically to terminate the process with a core dump.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SIGPWR</b>
(which is not specified in POSIX.1-2001) is typically
ignored by default on those other UNIX systems where it
appears.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SIGIO</b>
(which is not specified in POSIX.1-2001) is ignored by
default on several other UNIX systems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Queueing and
delivery semantics for standard signals</b> <br>
If multiple standard signals are pending for a process, the
order in which the signals are delivered is unspecified.</p>

<p style="margin-left:11%; margin-top: 1em">Standard
signals do not queue. If multiple instances of a standard
signal are generated while that signal is blocked, then only
one instance of the signal is marked as pending (and the
signal will be delivered just once when it is unblocked). In
the case where a standard signal is already pending, the
<i>siginfo_t</i> structure (see <a href="https://man.page/2/sigaction">sigaction(2)</a>)
associated with that signal is not overwritten on arrival of
subsequent instances of the same signal. Thus, the process
will receive the information associated with the first
instance of the signal.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Signal
numbering for standard signals</b> <br>
The numeric value for each signal is given in the table
below. As shown in the table, many signals have different
numeric values on different architectures. The first numeric
value in each table row shows the signal number on x86, ARM,
and most other architectures; the second value is for Alpha
and SPARC; the third is for MIPS; and the last is for
PARISC. A dash (-) denotes that a signal is absent on the
corresponding architecture.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3511982.png" alt="Image grohtml-3511982.png"></p>

<p style="margin-left:11%; margin-top: 1em">Note the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">Where defined, <b>SIGUNUSED</b>
is synonymous with <b>SIGSYS</b>. Since glibc 2.26,
<b>SIGUNUSED</b> is no longer defined on any
architecture.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Signal 29 is <b>SIGINFO</b>/<b>SIGPWR</b> (synonyms for
the same value) on Alpha but <b>SIGLOST</b> on SPARC.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Real-time
signals</b> <br>
Starting with version 2.2, Linux supports real-time signals
as originally defined in the POSIX.1b real-time extensions
(and now included in POSIX.1-2001). The range of supported
real-time signals is defined by the macros <b>SIGRTMIN</b>
and <b>SIGRTMAX</b>. POSIX.1-2001 requires that an
implementation support at least <b>_POSIX_RTSIG_MAX</b> (8)
real-time signals.</p>

<p style="margin-left:11%; margin-top: 1em">The Linux
kernel supports a range of 33 different real-time signals,
numbered 32 to 64. However, the glibc POSIX threads
implementation internally uses two (for NPTL) or three (for
LinuxThreads) real-time signals (see <a href="https://man.page/7/pthreads">pthreads(7)</a>),
and adjusts the value of <b>SIGRTMIN</b> suitably (to 34 or
35). Because the range of available real-time signals varies
according to the glibc threading implementation (and this
variation can occur at run time according to the available
kernel and glibc), and indeed the range of real-time signals
varies across UNIX systems, programs should <i>never refer
to real-time signals using hard-coded numbers</i>, but
instead should always refer to real-time signals using the
notation <b>SIGRTMIN</b>+n, and include suitable (run-time)
checks that <b>SIGRTMIN</b>+n does not exceed
<b>SIGRTMAX</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike standard
signals, real-time signals have no predefined meanings: the
entire set of real-time signals can be used for
application-defined purposes.</p>

<p style="margin-left:11%; margin-top: 1em">The default
action for an unhandled real-time signal is to terminate the
receiving process.</p>

<p style="margin-left:11%; margin-top: 1em">Real-time
signals are distinguished by the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Multiple instances of real-time
signals can be queued. By contrast, if multiple instances of
a standard signal are delivered while that signal is
currently blocked, then only one instance is queued.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the signal is sent using <a href="https://man.page/3/sigqueue">sigqueue(3)</a>, an
accompanying value (either an integer or a pointer) can be
sent with the signal. If the receiving process establishes a
handler for this signal using the <b>SA_SIGINFO</b> flag to
<a href="https://man.page/2/sigaction">sigaction(2)</a>, then it can obtain this data via the
<i>si_value</i> field of the <i>siginfo_t</i> structure
passed as the second argument to the handler. Furthermore,
the <i>si_pid</i> and <i>si_uid</i> fields of this structure
can be used to obtain the PID and real user ID of the
process sending the signal.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Real-time signals are delivered in a guaranteed order.
Multiple real-time signals of the same type are delivered in
the order they were sent. If different real-time signals are
sent to a process, they are delivered starting with the
lowest-numbered signal. (I.e., low-numbered signals have
highest priority.) By contrast, if multiple standard signals
are pending for a process, the order in which they are
delivered is unspecified.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If both
standard and real-time signals are pending for a process,
POSIX leaves it unspecified which is delivered first. Linux,
like many other implementations, gives priority to standard
signals in this case.</p>

<p style="margin-left:11%; margin-top: 1em">According to
POSIX, an implementation should permit at least
<b>_POSIX_SIGQUEUE_MAX</b> (32) real-time signals to be
queued to a process. However, Linux does things differently.
In kernels up to and including 2.6.7, Linux imposes a
system-wide limit on the number of queued real-time signals
for all processes. This limit can be viewed and (with
privilege) changed via the <i>/proc/sys/kernel/rtsig-max</i>
file. A related file, <i>/proc/sys/kernel/rtsig-nr</i>, can
be used to find out how many real-time signals are currently
queued. In Linux 2.6.8, these <i>/proc</i> interfaces were
replaced by the <b>RLIMIT_SIGPENDING</b> resource limit,
which specifies a per-user limit for queued signals; see
<a href="https://man.page/2/setrlimit">setrlimit(2)</a> for further details.</p>

<p style="margin-left:11%; margin-top: 1em">The addition of
real-time signals required the widening of the signal set
structure (<i>sigset_t</i>) from 32 to 64 bits.
Consequently, various system calls were superseded by new
system calls that supported the larger signal sets. The old
and new system calls are as follows:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-3511983.png" alt="Image grohtml-3511983.png"></p>


<p style="margin-left:11%; margin-top: 1em"><b>Interruption
of system calls and library functions by signal handlers</b>
<br>
If a signal handler is invoked while a system call or
library function call is blocked, then either:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">the call is automatically
restarted after the signal handler returns; or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>the call fails with the error <b>EINTR</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Which of these
two behaviors occurs depends on the interface and whether or
not the signal handler was established using the
<b>SA_RESTART</b> flag (see <a href="https://man.page/2/sigaction">sigaction(2)</a>). The
details vary across UNIX systems; below, the details for
Linux.</p>

<p style="margin-left:11%; margin-top: 1em">If a blocked
call to one of the following interfaces is interrupted by a
signal handler, then the call is automatically restarted
after the signal handler returns if the <b>SA_RESTART</b>
flag was used; otherwise the call fails with the error
<b>EINTR</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><a href="https://man.page/2/read">read(2)</a>, <a href="https://man.page/2/readv">readv(2)</a>,
<a href="https://man.page/2/write">write(2)</a>, <a href="https://man.page/2/writev">writev(2)</a>, and <a href="https://man.page/2/ioctl">ioctl(2)</a> calls
on &quot;slow&quot; devices. A &quot;slow&quot; device is
one where the I/O call may block for an indefinite time, for
example, a terminal, pipe, or socket. If an I/O call on a
slow device has already transferred some data by the time it
is interrupted by a signal handler, then the call will
return a success status (normally, the number of bytes
transferred). Note that a (local) disk is not a slow device
according to this definition; I/O operations on disk devices
are not interrupted by signals.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/open">open(2)</a>, if it can block (e.g., when opening a
FIFO; see <a href="https://man.page/7/fifo">fifo(7)</a>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/wait">wait(2)</a>, <a href="https://man.page/2/wait3">wait3(2)</a>, <a href="https://man.page/2/wait4">wait4(2)</a>,
<a href="https://man.page/2/waitid">waitid(2)</a>, and <a href="https://man.page/2/waitpid">waitpid(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Socket interfaces: <a href="https://man.page/2/accept">accept(2)</a>, <a href="https://man.page/2/connect">connect(2)</a>,
<a href="https://man.page/2/recv">recv(2)</a>, <a href="https://man.page/2/recvfrom">recvfrom(2)</a>, <a href="https://man.page/2/recvmmsg">recvmmsg(2)</a>,
<a href="https://man.page/2/recvmsg">recvmsg(2)</a>, <a href="https://man.page/2/send">send(2)</a>, <a href="https://man.page/2/sendto">sendto(2)</a>, and
<a href="https://man.page/2/sendmsg">sendmsg(2)</a>, unless a timeout has been set on the
socket (see below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>File locking interfaces: <a href="https://man.page/2/flock">flock(2)</a> and the
<b>F_SETLKW</b> and <b>F_OFD_SETLKW</b> operations of
<a href="https://man.page/2/fcntl">fcntl(2)</a></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>POSIX message queue interfaces: <a href="https://man.page/3/mq_receive">mq_receive(3)</a>,
<a href="https://man.page/3/mq_timedreceive">mq_timedreceive(3)</a>, <a href="https://man.page/3/mq_send">mq_send(3)</a>, and
<a href="https://man.page/3/mq_timedsend">mq_timedsend(3)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/futex">futex(2)</a> <b>FUTEX_WAIT</b> (since Linux 2.6.22;
beforehand, always failed with <b>EINTR</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/getrandom">getrandom(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/3/pthread_mutex_lock">pthread_mutex_lock(3)</a>,
<a href="https://man.page/3/pthread_cond_wait">pthread_cond_wait(3)</a>, and related APIs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/futex">futex(2)</a> <b>FUTEX_WAIT_BITSET</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>POSIX semaphore interfaces: <a href="https://man.page/3/sem_wait">sem_wait(3)</a> and
<a href="https://man.page/3/sem_timedwait">sem_timedwait(3)</a> (since Linux 2.6.22; beforehand,
always failed with <b>EINTR</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/read">read(2)</a> from an <a href="https://man.page/7/inotify">inotify(7)</a> file descriptor
(since Linux 3.8; beforehand, always failed with
<b>EINTR</b>).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
interfaces are never restarted after being interrupted by a
signal handler, regardless of the use of <b>SA_RESTART</b>;
they always fail with the error <b>EINTR</b> when
interrupted by a signal handler:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">&quot;Input&quot; socket
interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been set
on the socket using <a href="https://man.page/2/setsockopt">setsockopt(2)</a>: <a href="https://man.page/2/accept">accept(2)</a>,
<a href="https://man.page/2/recv">recv(2)</a>, <a href="https://man.page/2/recvfrom">recvfrom(2)</a>, <a href="https://man.page/2/recvmmsg">recvmmsg(2)</a> (also
with a non-NULL <i>timeout</i> argument), and
<a href="https://man.page/2/recvmsg">recvmsg(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>&quot;Output&quot; socket interfaces, when a timeout
(<b>SO_RCVTIMEO</b>) has been set on the socket using
<a href="https://man.page/2/setsockopt">setsockopt(2)</a>: <a href="https://man.page/2/connect">connect(2)</a>, <a href="https://man.page/2/send">send(2)</a>,
<a href="https://man.page/2/sendto">sendto(2)</a>, and <a href="https://man.page/2/sendmsg">sendmsg(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Interfaces used to wait for signals: <a href="https://man.page/2/pause">pause(2)</a>,
<a href="https://man.page/2/sigsuspend">sigsuspend(2)</a>, <a href="https://man.page/2/sigtimedwait">sigtimedwait(2)</a>, and
<a href="https://man.page/2/sigwaitinfo">sigwaitinfo(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>File descriptor multiplexing interfaces:
<a href="https://man.page/2/epoll_wait">epoll_wait(2)</a>, <a href="https://man.page/2/epoll_pwait">epoll_pwait(2)</a>, <a href="https://man.page/2/poll">poll(2)</a>,
<a href="https://man.page/2/ppoll">ppoll(2)</a>, <a href="https://man.page/2/select">select(2)</a>, and
<a href="https://man.page/2/pselect">pselect(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>System V IPC interfaces: <a href="https://man.page/2/msgrcv">msgrcv(2)</a>,
<a href="https://man.page/2/msgsnd">msgsnd(2)</a>, <a href="https://man.page/2/semop">semop(2)</a>, and
<a href="https://man.page/2/semtimedop">semtimedop(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Sleep interfaces: <a href="https://man.page/2/clock_nanosleep">clock_nanosleep(2)</a>,
<a href="https://man.page/2/nanosleep">nanosleep(2)</a>, and <a href="https://man.page/3/usleep">usleep(3)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/io_getevents">io_getevents(2)</a>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<a href="https://man.page/3/sleep">sleep(3)</a> function is also never restarted if
interrupted by a handler, but gives a success return: the
number of seconds remaining to sleep.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Interruption
of system calls and library functions by stop signals</b>
<br>
On Linux, even in the absence of signal handlers, certain
blocking interfaces can fail with the error <b>EINTR</b>
after the process is stopped by one of the stop signals and
then resumed via <b>SIGCONT</b>. This behavior is not
sanctioned by POSIX.1, and doesn&rsquo;t occur on other
systems.</p>

<p style="margin-left:11%; margin-top: 1em">The Linux
interfaces that display this behavior are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">&quot;Input&quot; socket
interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been set
on the socket using <a href="https://man.page/2/setsockopt">setsockopt(2)</a>: <a href="https://man.page/2/accept">accept(2)</a>,
<a href="https://man.page/2/recv">recv(2)</a>, <a href="https://man.page/2/recvfrom">recvfrom(2)</a>, <a href="https://man.page/2/recvmmsg">recvmmsg(2)</a> (also
with a non-NULL <i>timeout</i> argument), and
<a href="https://man.page/2/recvmsg">recvmsg(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>&quot;Output&quot; socket interfaces, when a timeout
(<b>SO_RCVTIMEO</b>) has been set on the socket using
<a href="https://man.page/2/setsockopt">setsockopt(2)</a>: <a href="https://man.page/2/connect">connect(2)</a>, <a href="https://man.page/2/send">send(2)</a>,
<a href="https://man.page/2/sendto">sendto(2)</a>, and <a href="https://man.page/2/sendmsg">sendmsg(2)</a>, if a send timeout
(<b>SO_SNDTIMEO</b>) has been set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/epoll_wait">epoll_wait(2)</a>, <a href="https://man.page/2/epoll_pwait">epoll_pwait(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/semop">semop(2)</a>, <a href="https://man.page/2/semtimedop">semtimedop(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p><a href="https://man.page/2/sigtimedwait">sigtimedwait(2)</a>, <a href="https://man.page/2/sigwaitinfo">sigwaitinfo(2)</a>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Linux 3.7 and earlier: <a href="https://man.page/2/read">read(2)</a> from an
<a href="https://man.page/7/inotify">inotify(7)</a> file descriptor</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Linux 2.6.21 and earlier: <a href="https://man.page/2/futex">futex(2)</a>
<b>FUTEX_WAIT</b>, <a href="https://man.page/3/sem_timedwait">sem_timedwait(3)</a>,
<a href="https://man.page/3/sem_wait">sem_wait(3)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Linux 2.6.8 and earlier: <a href="https://man.page/2/msgrcv">msgrcv(2)</a>,
<a href="https://man.page/2/msgsnd">msgsnd(2)</a>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Linux 2.4 and earlier: <a href="https://man.page/2/nanosleep">nanosleep(2)</a>.</p></td></tr>
</table>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1, except
as noted.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For a
discussion of async-signal-safe functions, see
<a href="https://man.page/7/signal-safety">signal-safety(7)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>/proc/[pid]/task/[tid]/status</i> file contains various
fields that show the signals that a thread is blocking
(<i>SigBlk</i>), catching (<i>SigCgt</i>), or ignoring
(<i>SigIgn</i>). (The set of signals that are caught or
ignored will be the same across all threads in a process.)
Other fields show the set of pending signals that are
directed to the thread (<i>SigPnd</i>) as well as the set of
pending signals that are directed to the process as a whole
(<i>ShdPnd</i>). The corresponding fields in
<i>/proc/[pid]/status</i> show the information for the main
thread. See <a href="https://man.page/5/proc">proc(5)</a> for further details.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are six
signals that can be delivered as a consequence of a hardware
exception: <b>SIGBUS</b>, <b>SIGEMT</b>, <b>SIGFPE</b>,
<b>SIGILL</b>, <b>SIGSEGV</b>, and <b>SIGTRAP</b>. Which of
these signals is delivered, for any given hardware
exception, is not documented and does not always make
sense.</p>

<p style="margin-left:11%; margin-top: 1em">For example, an
invalid memory access that causes delivery of <b>SIGSEGV</b>
on one CPU architecture may cause delivery of <b>SIGBUS</b>
on another architecture, or vice versa.</p>

<p style="margin-left:11%; margin-top: 1em">For another
example, using the x86 <i>int</i> instruction with a
forbidden argument (any number other than 3 or 128) causes
delivery of <b>SIGSEGV</b>, even though <b>SIGILL</b> would
make more sense, because of how the CPU reports the
forbidden operation to the kernel.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/1/kill">kill(1)</a>,
<a href="https://man.page/2/clone">clone(2)</a>, <a href="https://man.page/2/getrlimit">getrlimit(2)</a>, <a href="https://man.page/2/kill">kill(2)</a>,
<a href="https://man.page/2/pidfd_send_signal">pidfd_send_signal(2)</a>, <a href="https://man.page/2/restart_syscall">restart_syscall(2)</a>,
<a href="https://man.page/2/rt_sigqueueinfo">rt_sigqueueinfo(2)</a>, <a href="https://man.page/2/setitimer">setitimer(2)</a>,
<a href="https://man.page/2/setrlimit">setrlimit(2)</a>, <a href="https://man.page/2/sgetmask">sgetmask(2)</a>,
<a href="https://man.page/2/sigaction">sigaction(2)</a>, <a href="https://man.page/2/sigaltstack">sigaltstack(2)</a>,
<a href="https://man.page/2/signal">signal(2)</a>, <a href="https://man.page/2/signalfd">signalfd(2)</a>, <a href="https://man.page/2/sigpending">sigpending(2)</a>,
<a href="https://man.page/2/sigprocmask">sigprocmask(2)</a>, <a href="https://man.page/2/sigreturn">sigreturn(2)</a>,
<a href="https://man.page/2/sigsuspend">sigsuspend(2)</a>, <a href="https://man.page/2/sigwaitinfo">sigwaitinfo(2)</a>,
<a href="https://man.page/3/abort">abort(3)</a>, <a href="https://man.page/3/bsd_signal">bsd_signal(3)</a>, <a href="https://man.page/3/killpg">killpg(3)</a>,
<a href="https://man.page/3/longjmp">longjmp(3)</a>, <a href="https://man.page/3/pthread_sigqueue">pthread_sigqueue(3)</a>,
<a href="https://man.page/3/raise">raise(3)</a>, <a href="https://man.page/3/sigqueue">sigqueue(3)</a>, <a href="https://man.page/3/sigset">sigset(3)</a>,
<a href="https://man.page/3/sigsetops">sigsetops(3)</a>, <a href="https://man.page/3/sigvec">sigvec(3)</a>, <a href="https://man.page/3/sigwait">sigwait(3)</a>,
<a href="https://man.page/3/strsignal">strsignal(3)</a>, <a href="https://man.page/3/swapcontext">swapcontext(3)</a>,
<a href="https://man.page/3/sysv_signal">sysv_signal(3)</a>, <a href="https://man.page/5/core">core(5)</a>, <a href="https://man.page/5/proc">proc(5)</a>,
<a href="https://man.page/7/nptl">nptl(7)</a>, <a href="https://man.page/7/pthreads">pthreads(7)</a>, <a href="https://man.page/7/sigevent">sigevent(7)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
