<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:33 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PCAP-FILTER</title>

</head>
<body>

<h1 align="center">PCAP-FILTER</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#BUGS">BUGS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">pcap-filter -
packet filter syntax</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>pcap_compile</b>()
is used to compile a string into a filter program. The
resulting filter program can then be applied to some stream
of packets to determine which packets will be supplied to
<b>pcap_loop</b>(3PCAP), <b>pcap_dispatch</b>(3PCAP),
<b>pcap_next</b>(3PCAP), or <b>pcap_next_ex</b>(3PCAP).</p>

<p style="margin-left:11%; margin-top: 1em">The <i>filter
expression</i> consists of one or more <i>primitives</i>.
Primitives usually consist of an <i>id</i> (name or number)
preceded by one or more qualifiers. There are three
different kinds of qualifier:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>type</i></p></td>
<td width="4%"></td>
<td width="78%">


<p><i>type</i> qualifiers say what kind of thing the id
name or number refers to. Possible types are <b>host</b>,
<b>net</b>, <b>port</b> and <b>portrange</b>. E.g.,
&rsquo;<b>host</b> foo&rsquo;, &rsquo;<b>net</b>
128.3&rsquo;, &rsquo;<b>port</b> 20&rsquo;,
&rsquo;<b>portrange</b> 6000-6008&rsquo;. If there is no
type qualifier, <b>host</b> is assumed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>dir</i></p></td>
<td width="4%"></td>
<td width="78%">


<p><i>dir</i> qualifiers specify a particular transfer
direction to and/or from <i>id</i>. Possible directions are
<b>src</b>, <b>dst</b>, <b>src or dst</b>, <b>src and
dst</b>, <b>ra</b>, <b>ta</b>, <b>addr1</b>, <b>addr2</b>,
<b>addr3</b>, and <b>addr4</b>. E.g., &rsquo;<b>src</b>
foo&rsquo;, &rsquo;<b>dst net</b> 128.3&rsquo;,
&rsquo;<b>src or dst port</b> ftp-data&rsquo;. If there is
no dir qualifier, &rsquo;<b>src or dst</b>&rsquo; is
assumed. The <b>ra</b>, <b>ta</b>, <b>addr1</b>,
<b>addr2</b>, <b>addr3</b>, and <b>addr4</b> qualifiers are
only valid for IEEE 802.11 Wireless LAN link layers.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>proto</i></p></td>
<td width="4%"></td>
<td width="78%">


<p><i>proto</i> qualifiers restrict the match to a
particular protocol. Possible protos are: <b>ether</b>,
<b>fddi</b>, <b>tr</b>, <b>wlan</b>, <b>ip</b>, <b>ip6</b>,
<b>arp</b>, <b>rarp</b>, <b>decnet</b>, <b>tcp</b> and
<b>udp</b>. E.g., &rsquo;<b>ether src</b> foo&rsquo;,
&rsquo;<b>arp net</b> 128.3&rsquo;, &rsquo;<b>tcp port</b>
21&rsquo;, &rsquo;<b>udp portrange</b> 7000-7009&rsquo;,
&rsquo;<b>wlan addr2</b> 0:2:3:4:5:6&rsquo;. If there is no
proto qualifier, all protocols consistent with the type are
assumed. E.g., &rsquo;<b>src</b> foo&rsquo; means
&rsquo;<b>(ip or arp or rarp) src</b> foo&rsquo; (except the
latter is not legal syntax), &rsquo;<b>net</b> bar&rsquo;
means &rsquo;<b>(ip or arp or rarp) net</b> bar&rsquo; and
&rsquo;<b>port</b> 53&rsquo; means &rsquo;<b>(tcp or udp)
port</b> 53&rsquo;.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">[<b>fddi</b> is
actually an alias for <b>ether</b>; the parser treats them
identically as meaning &rsquo;&rsquo;the data link level
used on the specified network interface&rsquo;&rsquo;. FDDI
headers contain Ethernet-like source and destination
addresses, and often contain Ethernet-like packet types, so
you can filter on these FDDI fields just as with the
analogous Ethernet fields. FDDI headers also contain other
fields, but you cannot name them explicitly in a filter
expression.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
<b>tr</b> and <b>wlan</b> are aliases for <b>ether</b>; the
previous paragraph&rsquo;s statements about FDDI headers
also apply to Token Ring and 802.11 wireless LAN headers.
For 802.11 headers, the destination address is the DA field
and the source address is the SA field; the BSSID, RA, and
TA fields aren&rsquo;t tested.]</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the above, there are some special &rsquo;primitive&rsquo;
keywords that don&rsquo;t follow the pattern:
<b>gateway</b>, <b>broadcast</b>, <b>less</b>,
<b>greater</b> and arithmetic expressions. All of these are
described below.</p>

<p style="margin-left:11%; margin-top: 1em">More complex
filter expressions are built up by using the words
<b>and</b>, <b>or</b> and <b>not</b> (or equivalently:
&rsquo;<b>&amp;&amp;</b>&rsquo;, &rsquo;<b>||</b>&rsquo; and
&rsquo;<b>!</b>&rsquo; respectively) to combine primitives.
E.g., &rsquo;<b>host</b> foo <b>and not port</b> ftp <b>and
not port</b> ftp-data&rsquo;. To save typing, identical
qualifier lists can be omitted. E.g., &rsquo;<b>tcp dst
port</b> ftp <b>or</b> ftp-data <b>or</b> domain&rsquo; is
exactly the same as &rsquo;<b>tcp dst port</b> ftp <b>or tcp
dst port</b> ftp-data <b>or tcp dst port</b>
domain&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">Allowable
primitives are: <b><br>
dst host</b> <i>host</i></p>

<p style="margin-left:22%;">True if the IPv4/v6 destination
field of the packet is <i>host</i>, which may be either an
address or a name.</p>

<p style="margin-left:11%;"><b>src host</b> <i>host</i></p>

<p style="margin-left:22%;">True if the IPv4/v6 source
field of the packet is <i>host</i>.</p>

<p style="margin-left:11%;"><b>host</b> <i>host</i></p>

<p style="margin-left:22%;">True if either the IPv4/v6
source or destination of the packet is <i>host</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Any of the
above host expressions can be prepended with the keywords,
<b>ip</b>, <b>arp</b>, <b>rarp</b>, or <b>ip6</b> as in:</p>

<p style="margin-left:29%;"><b>ip host</b> <i>host</i></p>

<p style="margin-left:22%;">which is equivalent to:</p>

<p style="margin-left:29%;"><b>ether proto \ip and host</b>
<i>host</i></p>

<p style="margin-left:22%;">If <i>host</i> is a name with
multiple IPv4 addresses, each address will be checked for a
match.</p>

<p style="margin-left:11%;"><b>ether dst</b>
<i>ehost</i></p>

<p style="margin-left:22%;">True if the Ethernet
destination address is <i>ehost</i>. <i>Ehost</i> may be
either a name from /etc/ethers or a numerical MAC address of
the form &quot;xx:xx:xx:xx:xx:xx&quot;,
&quot;xx.xx.xx.xx.xx.xx&quot;,
&quot;xx-xx-xx-xx-xx-xx&quot;, &quot;xxxx.xxxx.xxxx&quot;,
&quot;xxxxxxxxxxxx&quot;, or various mixes of
&rsquo;:&rsquo;, &rsquo;.&rsquo;, and &rsquo;-&rsquo;, where
each &quot;x&quot; is a hex digit (0-9, a-f, or A-F).</p>

<p style="margin-left:11%;"><b>ether src</b>
<i>ehost</i></p>

<p style="margin-left:22%;">True if the Ethernet source
address is <i>ehost</i>.</p>

<p style="margin-left:11%;"><b>ether host</b>
<i>ehost</i></p>

<p style="margin-left:22%;">True if either the Ethernet
source or destination address is <i>ehost</i>.</p>

<p style="margin-left:11%;"><b>gateway</b> <i>host</i></p>

<p style="margin-left:22%;">True if the packet used
<i>host</i> as a gateway. I.e., the Ethernet source or
destination address was <i>host</i> but neither the IP
source nor the IP destination was <i>host</i>. <i>Host</i>
must be a name and must be found both by the machine&rsquo;s
host-name-to-IP-address resolution mechanisms (host name
file, DNS, NIS, etc.) and by the machine&rsquo;s
host-name-to-Ethernet-address resolution mechanism
(/etc/ethers, etc.). (An equivalent expression is</p>

<p style="margin-left:29%;"><b>ether host</b> <i>ehost</i>
<b>and not host</b> <i>host</i></p>

<p style="margin-left:22%;">which can be used with either
names or numbers for <i>host / ehost</i>.) This syntax does
not work in IPv6-enabled configuration at this moment.</p>

<p style="margin-left:11%;"><b>dst net</b> <i>net</i></p>

<p style="margin-left:22%;">True if the IPv4/v6 destination
address of the packet has a network number of <i>net</i>.
<i>Net</i> may be either a name from the networks database
(/etc/networks, etc.) or a network number. An IPv4 network
number can be written as a dotted quad (e.g., 192.168.1.0),
dotted triple (e.g., 192.168.1), dotted pair (e.g, 172.16),
or single number (e.g., 10); the netmask is 255.255.255.255
for a dotted quad (which means that it&rsquo;s really a host
match), 255.255.255.0 for a dotted triple, 255.255.0.0 for a
dotted pair, or 255.0.0.0 for a single number. An IPv6
network number must be written out fully; the netmask is
ff:ff:ff:ff:ff:ff:ff:ff, so IPv6 &quot;network&quot; matches
are really always host matches, and a network match requires
a netmask length.</p>

<p style="margin-left:11%;"><b>src net</b> <i>net</i></p>

<p style="margin-left:22%;">True if the IPv4/v6 source
address of the packet has a network number of
<i>net</i>.</p>

<p style="margin-left:11%;"><b>net</b> <i>net</i></p>

<p style="margin-left:22%;">True if either the IPv4/v6
source or destination address of the packet has a network
number of <i>net</i>.</p>

<p style="margin-left:11%;"><b>net</b> <i>net</i>
<b>mask</b> <i>netmask</i></p>

<p style="margin-left:22%;">True if the IPv4 address
matches <i>net</i> with the specific <i>netmask</i>. May be
qualified with <b>src</b> or <b>dst</b>. Note that this
syntax is not valid for IPv6 <i>net</i>.</p>

<p style="margin-left:11%;"><b>net</b>
<i>net</i>/<i>len</i></p>

<p style="margin-left:22%;">True if the IPv4/v6 address
matches <i>net</i> with a netmask <i>len</i> bits wide. May
be qualified with <b>src</b> or <b>dst</b>.</p>

<p style="margin-left:11%;"><b>dst port</b> <i>port</i></p>

<p style="margin-left:22%;">True if the packet is IPv4 TCP,
IPv4 UDP, IPv6 TCP or IPv6 UDP and has a destination port
value of <i>port</i>. The <i>port</i> can be a number or a
name used in /etc/services (see <b>tcp</b>(4P) and
<b>udp</b>(4P)). If a name is used, both the port number and
protocol are checked. If a number or ambiguous name is used,
only the port number is checked (e.g., &rsquo;<b>dst
port</b> 513&rsquo; will print both tcp/login traffic and
udp/who traffic, and &rsquo;<b>port domain</b>&rsquo; will
print both tcp/domain and udp/domain traffic).</p>

<p style="margin-left:11%;"><b>src port</b> <i>port</i></p>

<p style="margin-left:22%;">True if the packet has a source
port value of <i>port</i>.</p>

<p style="margin-left:11%;"><b>port</b> <i>port</i></p>

<p style="margin-left:22%;">True if either the source or
destination port of the packet is <i>port</i>.</p>

<p style="margin-left:11%;"><b>dst portrange</b>
<i>port1-port2</i></p>

<p style="margin-left:22%;">True if the packet is IPv4 TCP,
IPv4 UDP, IPv6 TCP or IPv6 UDP and has a destination port
value between <i>port1</i> and <i>port2</i> (both
inclusive). <i>port1</i> and <i>port2</i> are interpreted in
the same fashion as the <i>port</i> parameter for
<b>port</b>.</p>

<p style="margin-left:11%;"><b>src portrange</b>
<i>port1-port2</i></p>

<p style="margin-left:22%;">True if the packet has a source
port value between <i>port1</i> and <i>port2</i> (both
inclusive).</p>

<p style="margin-left:11%;"><b>portrange</b>
<i>port1-port2</i></p>

<p style="margin-left:22%;">True if either the source or
destination port of the packet is between <i>port1</i> and
<i>port2</i> (both inclusive).</p>

<p style="margin-left:22%; margin-top: 1em">Any of the
above port or port range expressions can be prepended with
the keywords, <b>tcp</b> or <b>udp</b>, as in:</p>

<p style="margin-left:29%;"><b>tcp src port</b>
<i>port</i></p>

<p style="margin-left:22%;">which matches only TCP packets
whose source port is <i>port</i>.</p>

<p style="margin-left:11%;"><b>less</b> <i>length</i></p>

<p style="margin-left:22%;">True if the packet has a length
less than or equal to <i>length</i>. This is equivalent
to:</p>

<p style="margin-left:29%;"><b>len &lt;=</b>
<i>length</i></p>

<p style="margin-left:11%;"><b>greater</b>
<i>length</i></p>

<p style="margin-left:22%;">True if the packet has a length
greater than or equal to <i>length</i>. This is equivalent
to:</p>

<p style="margin-left:29%;"><b>len &gt;=</b>
<i>length</i></p>

<p style="margin-left:11%;"><b>ip proto</b>
<i>protocol</i></p>

<p style="margin-left:22%;">True if the packet is an IPv4
packet (see <b>ip</b>(4P)) of protocol type <i>protocol</i>.
<i>Protocol</i> can be a number or one of the names
<b>icmp</b>, <b>icmp6</b>, <b>igmp</b>, <b>igrp</b>,
<b>pim</b>, <b>ah</b>, <b>esp</b>, <b>vrrp</b>, <b>udp</b>,
or <b>tcp</b>. Note that the identifiers <b>tcp</b>,
<b>udp</b>, and <b>icmp</b> are also keywords and must be
escaped via backslash (\). Note that this primitive does not
chase the protocol header chain.</p>

<p style="margin-left:11%;"><b>ip6 proto</b>
<i>protocol</i></p>

<p style="margin-left:22%;">True if the packet is an IPv6
packet of protocol type <i>protocol</i>. Note that this
primitive does not chase the protocol header chain.</p>

<p style="margin-left:11%;"><b>proto</b>
<i>protocol</i></p>

<p style="margin-left:22%;">True if the packet is an IPv4
or IPv6 packet of protocol type <i>protocol</i>. Note that
this primitive does not chase the protocol header chain.</p>

<p style="margin-left:11%;"><b>tcp</b>, <b>udp</b>,
<b>icmp</b></p>

<p style="margin-left:22%;">Abbreviations for:</p>

<p style="margin-left:29%;"><b>proto
\</b><i>protocol</i></p>

<p style="margin-left:22%;"><b>where</b> <i>protocol</i> is
one of the above protocols.</p>

<p style="margin-left:11%;"><b>ip6 protochain</b>
<i>protocol</i></p>

<p style="margin-left:22%;">True if the packet is IPv6
packet, and contains protocol header with type
<i>protocol</i> in its protocol header chain. For
example,</p>

<p style="margin-left:29%;"><b>ip6 protochain</b> 6</p>

<p style="margin-left:22%;">matches any IPv6 packet with
TCP protocol header in the protocol header chain. The packet
may contain, for example, authentication header, routing
header, or hop-by-hop option header, between IPv6 header and
TCP header. The BPF code emitted by this primitive is
complex and cannot be optimized by the BPF optimizer code,
and is not supported by filter engines in the kernel, so
this can be somewhat slow, and may cause more packets to be
dropped.</p>

<p style="margin-left:11%;"><b>ip protochain</b>
<i>protocol</i></p>

<p style="margin-left:22%;">Equivalent to <b>ip6
protochain</b> <i>protocol</i>, but this is for IPv4.</p>

<p style="margin-left:11%;"><b>protochain</b>
<i>protocol</i></p>

<p style="margin-left:22%;">True if the packet is an IPv4
or IPv6 packet of protocol type <i>protocol</i>. Note that
this primitive chases the protocol header chain.</p>

<p style="margin-left:11%;"><b>ether broadcast</b></p>

<p style="margin-left:22%;">True if the packet is an
Ethernet broadcast packet. The <b>ether</b> keyword is
optional.</p>

<p style="margin-left:11%;"><b>ip broadcast</b></p>

<p style="margin-left:22%;">True if the packet is an IPv4
broadcast packet. It checks for both the all-zeroes and
all-ones broadcast conventions, and looks up the subnet mask
on the interface on which the capture is being done.</p>

<p style="margin-left:22%; margin-top: 1em">If the subnet
mask of the interface on which the capture is being done is
not available, either because the interface on which capture
is being done has no netmask or because the capture is being
done on the Linux &quot;any&quot; interface, which can
capture on more than one interface, this check will not work
correctly.</p>

<p style="margin-left:11%;"><b>ether multicast</b></p>

<p style="margin-left:22%;">True if the packet is an
Ethernet multicast packet. The <b>ether</b> keyword is
optional. This is shorthand for &rsquo;<b>ether[</b>0<b>]
&amp;</b> 1 <b>!=</b> 0&rsquo;.</p>

<p style="margin-left:11%;"><b>ip multicast</b></p>

<p style="margin-left:22%;">True if the packet is an IPv4
multicast packet.</p>

<p style="margin-left:11%;"><b>ip6 multicast</b></p>

<p style="margin-left:22%;">True if the packet is an IPv6
multicast packet.</p>

<p style="margin-left:11%;"><b>ether proto</b>
<i>protocol</i></p>

<p style="margin-left:22%;">True if the packet is of ether
type <i>protocol</i>. <i>Protocol</i> can be a number or one
of the names <b>aarp</b>, <b>arp</b>, <b>atalk</b>,
<b>decnet</b>, <b>ip</b>, <b>ip6</b>, <b>ipx</b>,
<b>iso</b>, <b>lat</b>, <b>loopback</b>, <b>mopdl</b>,
<b>moprc</b>, <b>netbeui</b>, <b>rarp</b>, <b>sca</b> or
<b>stp</b>. Note these identifiers (except <b>loopback</b>)
are also keywords and must be escaped via backslash (\).</p>

<p style="margin-left:22%; margin-top: 1em">[In the case of
FDDI (e.g., &rsquo;<b>fddi proto \arp</b>&rsquo;), Token
Ring (e.g., &rsquo;<b>tr proto \arp</b>&rsquo;), and IEEE
802.11 wireless LANs (e.g., &rsquo;<b>wlan proto
\arp</b>&rsquo;), for most of those protocols, the protocol
identification comes from the 802.2 Logical Link Control
(LLC) header, which is usually layered on top of the FDDI,
Token Ring, or 802.11 header.</p>

<p style="margin-left:22%; margin-top: 1em">When filtering
for most protocol identifiers on FDDI, Token Ring, or
802.11, the filter checks only the protocol ID field of an
LLC header in so-called SNAP format with an Organizational
Unit Identifier (OUI) of 0x000000, for encapsulated
Ethernet; it doesn&rsquo;t check whether the packet is in
SNAP format with an OUI of 0x000000. The exceptions are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p><b>iso</b></p></td>
<td width="6%"></td>
<td width="68%">


<p>the filter checks the DSAP (Destination Service Access
Point) and SSAP (Source Service Access Point) fields of the
LLC header;</p></td></tr>
</table>

<p style="margin-left:22%;"><b>stp</b> and
<b>netbeui</b></p>

<p style="margin-left:32%;">the filter checks the DSAP of
the LLC header;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>atalk</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>the filter checks for a SNAP-format packet with an OUI
of 0x080007 and the AppleTalk etype.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">In the case of
Ethernet, the filter checks the Ethernet type field for most
of those protocols. The exceptions are: <b><br>
iso</b>, <b>stp</b>, and <b>netbeui</b></p>

<p style="margin-left:32%;">the filter checks for an 802.3
frame and then checks the LLC header as it does for FDDI,
Token Ring, and 802.11;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>atalk</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>the filter checks both for the AppleTalk etype in an
Ethernet frame and for a SNAP-format packet as it does for
FDDI, Token Ring, and 802.11;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>aarp</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>the filter checks for the AppleTalk ARP etype in either
an Ethernet frame or an 802.2 SNAP frame with an OUI of
0x000000;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>ipx</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>the filter checks for the IPX etype in an Ethernet
frame, the IPX DSAP in the LLC header, the
802.3-with-no-LLC-header encapsulation of IPX, and the IPX
etype in a SNAP frame.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ip</b>, <b>ip6</b>,
<b>arp</b>, <b>rarp</b>, <b>atalk</b>, <b>aarp</b>,
<b>decnet</b>, <b>iso</b>, <b>stp</b>, <b>ipx</b>,
<b>netbeui</b></p>

<p style="margin-left:22%;">Abbreviations for:</p>

<p style="margin-left:29%;"><b>ether proto
\</b><i>protocol</i></p>

<p style="margin-left:22%;">where <i>protocol</i> is one of
the above protocols.</p>

<p style="margin-left:11%;"><b>lat</b>, <b>moprc</b>,
<b>mopdl</b></p>

<p style="margin-left:22%;">Abbreviations for:</p>

<p style="margin-left:29%;"><b>ether proto
\</b><i>protocol</i></p>

<p style="margin-left:22%;">where <i>protocol</i> is one of
the above protocols. Note that not all applications using
<b>pcap</b>(3PCAP) currently know how to parse these
protocols.</p>

<p style="margin-left:11%;"><b>decnet src</b>
<i>host</i></p>

<p style="margin-left:22%;">True if the DECnet source
address is <i>host</i>, which may be an address of the form
&rsquo;&rsquo;10.123&rsquo;&rsquo;, or a DECnet host name.
[DECnet host name support is only available on ULTRIX
systems that are configured to run DECnet.]</p>

<p style="margin-left:11%;"><b>decnet dst</b>
<i>host</i></p>

<p style="margin-left:22%;">True if the DECnet destination
address is <i>host</i>.</p>

<p style="margin-left:11%;"><b>decnet host</b>
<i>host</i></p>

<p style="margin-left:22%;">True if either the DECnet
source or destination address is <i>host</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>llc</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>True if the packet has an 802.2 LLC header. This
includes:</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Ethernet
packets with a length field rather than a type field that
aren&rsquo;t raw NetWare-over-802.3 packets;</p>

<p style="margin-left:22%; margin-top: 1em">IEEE 802.11
data packets;</p>

<p style="margin-left:22%; margin-top: 1em">Token Ring
packets (no check is done for LLC frames);</p>

<p style="margin-left:22%; margin-top: 1em">FDDI packets
(no check is done for LLC frames);</p>


<p style="margin-left:22%; margin-top: 1em">LLC-encapsulated
ATM packets, for SunATM on Solaris.</p>

<p style="margin-left:11%;"><b>llc</b> <i>type</i></p>

<p style="margin-left:22%;">True if the packet has an 802.2
LLC header and has the specified <i>type</i>. <i>type</i>
can be one of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>i</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Information (I) PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>s</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Supervisory (S) PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>u</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Unnumbered (U) PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>rr</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Receiver Ready (RR) S PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>rnr</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Receiver Not Ready (RNR) S PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>rej</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Reject (REJ) S PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>ui</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Unnumbered Information (UI) U PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>ua</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Unnumbered Acknowledgment (UA) U PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>disc</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Disconnect (DISC) U PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>sabme</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Set Asynchronous Balanced Mode Extended (SABME) U
PDUs</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>test</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Test (TEST) U PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>xid</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Exchange Identification (XID) U PDUs</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>frmr</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Frame Reject (FRMR) U PDUs</p></td></tr>
</table>

<p style="margin-left:11%;"><b>inbound</b></p>

<p style="margin-left:22%;">Packet was received by the host
performing the capture rather than being sent by that host.
This is only supported for certain link-layer types, such as
SLIP and the &rsquo;&rsquo;cooked&rsquo;&rsquo; Linux
capture mode used for the &rsquo;&rsquo;any&rsquo;&rsquo;
device and for some other device types.</p>

<p style="margin-left:11%;"><b>outbound</b></p>

<p style="margin-left:22%;">Packet was sent by the host
performing the capture rather than being received by that
host. This is only supported for certain link-layer types,
such as SLIP and the &rsquo;&rsquo;cooked&rsquo;&rsquo;
Linux capture mode used for the
&rsquo;&rsquo;any&rsquo;&rsquo; device and for some other
device types.</p>

<p style="margin-left:11%;"><b>ifname</b>
<i>interface</i></p>

<p style="margin-left:22%;">True if the packet was logged
as coming from the specified interface (applies only to
packets logged by OpenBSD&rsquo;s or FreeBSD&rsquo;s
<a href="https://man.page/4/pf">pf(4)</a>).</p>

<p style="margin-left:11%;"><b>on</b> <i>interface</i></p>

<p style="margin-left:22%;">Synonymous with the
<b>ifname</b> modifier.</p>

<p style="margin-left:11%;"><b>rnr</b> <i>num</i></p>

<p style="margin-left:22%;">True if the packet was logged
as matching the specified PF rule number (applies only to
packets logged by OpenBSD&rsquo;s or FreeBSD&rsquo;s
<a href="https://man.page/4/pf">pf(4)</a>).</p>

<p style="margin-left:11%;"><b>rulenum</b> <i>num</i></p>

<p style="margin-left:22%;">Synonymous with the <b>rnr</b>
modifier.</p>

<p style="margin-left:11%;"><b>reason</b> <i>code</i></p>

<p style="margin-left:22%;">True if the packet was logged
with the specified PF reason code. The known codes are:
<b>match</b>, <b>bad-offset</b>, <b>fragment</b>,
<b>short</b>, <b>normalize</b>, and <b>memory</b> (applies
only to packets logged by OpenBSD&rsquo;s or FreeBSD&rsquo;s
<a href="https://man.page/4/pf">pf(4)</a>).</p>

<p style="margin-left:11%;"><b>rset</b> <i>name</i></p>

<p style="margin-left:22%;">True if the packet was logged
as matching the specified PF ruleset name of an anchored
ruleset (applies only to packets logged by OpenBSD&rsquo;s
or FreeBSD&rsquo;s <a href="https://man.page/4/pf">pf(4)</a>).</p>

<p style="margin-left:11%;"><b>ruleset</b> <i>name</i></p>

<p style="margin-left:22%;">Synonymous with the <b>rset</b>
modifier.</p>

<p style="margin-left:11%;"><b>srnr</b> <i>num</i></p>

<p style="margin-left:22%;">True if the packet was logged
as matching the specified PF rule number of an anchored
ruleset (applies only to packets logged by OpenBSD&rsquo;s
or FreeBSD&rsquo;s <a href="https://man.page/4/pf">pf(4)</a>).</p>

<p style="margin-left:11%;"><b>subrulenum</b>
<i>num</i></p>

<p style="margin-left:22%;">Synonymous with the <b>srnr</b>
modifier.</p>

<p style="margin-left:11%;"><b>action</b> <i>act</i></p>

<p style="margin-left:22%;">True if PF took the specified
action when the packet was logged. Known actions are:
<b>pass</b> and <b>block</b> and, with later versions of
<a href="https://man.page/4/pf">pf(4)</a>, <b>nat</b>, <b>rdr</b>, <b>binat</b> and
<b>scrub</b> (applies only to packets logged by
OpenBSD&rsquo;s or FreeBSD&rsquo;s <a href="https://man.page/4/pf">pf(4)</a>).</p>

<p style="margin-left:11%;"><b>wlan ra</b> <i>ehost</i></p>

<p style="margin-left:22%;">True if the IEEE 802.11 RA is
<i>ehost</i>. The RA field is used in all frames except for
management frames.</p>

<p style="margin-left:11%;"><b>wlan ta</b> <i>ehost</i></p>

<p style="margin-left:22%;">True if the IEEE 802.11 TA is
<i>ehost</i>. The TA field is used in all frames except for
management frames and CTS (Clear To Send) and ACK
(Acknowledgment) control frames.</p>

<p style="margin-left:11%;"><b>wlan addr1</b>
<i>ehost</i></p>

<p style="margin-left:22%;">True if the first IEEE 802.11
address is <i>ehost</i>.</p>

<p style="margin-left:11%;"><b>wlan addr2</b>
<i>ehost</i></p>

<p style="margin-left:22%;">True if the second IEEE 802.11
address, if present, is <i>ehost</i>. The second address
field is used in all frames except for CTS (Clear To Send)
and ACK (Acknowledgment) control frames.</p>

<p style="margin-left:11%;"><b>wlan addr3</b>
<i>ehost</i></p>

<p style="margin-left:22%;">True if the third IEEE 802.11
address, if present, is <i>ehost</i>. The third address
field is used in management and data frames, but not in
control frames.</p>

<p style="margin-left:11%;"><b>wlan addr4</b>
<i>ehost</i></p>

<p style="margin-left:22%;">True if the fourth IEEE 802.11
address, if present, is <i>ehost</i>. The fourth address
field is only used for WDS (Wireless Distribution System)
frames.</p>

<p style="margin-left:11%;"><b>type</b>
<i>wlan_type</i></p>

<p style="margin-left:22%;">True if the IEEE 802.11 frame
type matches the specified <i>wlan_type</i>. Valid
<i>wlan_type</i>s are: <b>mgt</b>, <b>ctl</b> and
<b>data</b>.</p>

<p style="margin-left:11%;"><b>type</b> <i>wlan_type</i>
<b>subtype</b> <i>wlan_subtype</i></p>

<p style="margin-left:22%;">True if the IEEE 802.11 frame
type matches the specified <i>wlan_type</i> and frame
subtype matches the specified <i>wlan_subtype</i>.</p>

<p style="margin-left:22%; margin-top: 1em">If the
specified <i>wlan_type</i> is <b>mgt</b>, then valid
<i>wlan_subtype</i>s are: <b>assoc-req</b>,
<b>assoc-resp</b>, <b>reassoc-req</b>, <b>reassoc-resp</b>,
<b>probe-req</b>, <b>probe-resp</b>, <b>beacon</b>,
<b>atim</b>, <b>disassoc</b>, <b>auth</b> and
<b>deauth</b>.</p>

<p style="margin-left:22%; margin-top: 1em">If the
specified <i>wlan_type</i> is <b>ctl</b>, then valid
<i>wlan_subtype</i>s are: <b>ps-poll</b>, <b>rts</b>,
<b>cts</b>, <b>ack</b>, <b>cf-end</b> and
<b>cf-end-ack</b>.</p>

<p style="margin-left:22%; margin-top: 1em">If the
specified <i>wlan_type</i> is <b>data</b>, then valid
<i>wlan_subtype</i>s are: <b>data</b>, <b>data-cf-ack</b>,
<b>data-cf-poll</b>, <b>data-cf-ack-poll</b>, <b>null</b>,
<b>cf-ack</b>, <b>cf-poll</b>, <b>cf-ack-poll</b>,
<b>qos-data</b>, <b>qos-data-cf-ack</b>,
<b>qos-data-cf-poll</b>, <b>qos-data-cf-ack-poll</b>,
<b>qos</b>, <b>qos-cf-poll</b> and
<b>qos-cf-ack-poll</b>.</p>

<p style="margin-left:11%;"><b>subtype</b>
<i>wlan_subtype</i></p>

<p style="margin-left:22%;">True if the IEEE 802.11 frame
subtype matches the specified <i>wlan_subtype</i> and frame
has the type to which the specified <i>wlan_subtype</i>
belongs.</p>

<p style="margin-left:11%;"><b>dir</b> <i>dir</i></p>

<p style="margin-left:22%;">True if the IEEE 802.11 frame
direction matches the specified <i>dir</i>. Valid directions
are: <b>nods</b>, <b>tods</b>, <b>fromds</b>, <b>dstods</b>,
or a numeric value.</p>

<p style="margin-left:11%;"><b>vlan</b>
<i>[vlan_id]</i></p>

<p style="margin-left:22%;">True if the packet is an IEEE
802.1Q VLAN packet. If the optional <i>vlan_id</i> is
specified, only true if the packet has the specified
<i>vlan_id</i>. Note that the first <b>vlan</b> keyword
encountered in an expression changes the decoding offsets
for the remainder of the expression on the assumption that
the packet is a VLAN packet. The &rsquo;<b>vlan</b>
<i>[vlan_id]</i>&rsquo; keyword may be used more than once,
to filter on VLAN hierarchies. Each use of that keyword
increments the filter offsets by 4.</p>

<p style="margin-left:22%; margin-top: 1em">For
example:</p>

<p style="margin-left:29%;"><b>vlan</b> 100 <b>&amp;&amp;
vlan</b> 200</p>

<p style="margin-left:22%;">filters on VLAN 200
encapsulated within VLAN 100, and</p>

<p style="margin-left:29%;"><b>vlan &amp;&amp; vlan</b> 300
<b>&amp;&amp; ip</b></p>

<p style="margin-left:22%;">filters IPv4 protocol
encapsulated in VLAN 300 encapsulated within any higher
order VLAN.</p>

<p style="margin-left:11%;"><b>mpls</b>
<i>[label_num]</i></p>

<p style="margin-left:22%;">True if the packet is an MPLS
packet. If the optional <i>label_num</i> is specified, only
true if the packet has the specified <i>label_num</i>. Note
that the first <b>mpls</b> keyword encountered in an
expression changes the decoding offsets for the remainder of
the expression on the assumption that the packet is a
MPLS-encapsulated IP packet. The &rsquo;<b>mpls</b>
<i>[label_num]</i>&rsquo; keyword may be used more than
once, to filter on MPLS hierarchies. Each use of that
keyword increments the filter offsets by 4.</p>

<p style="margin-left:22%; margin-top: 1em">For
example:</p>

<p style="margin-left:29%;"><b>mpls</b> 100000
<b>&amp;&amp; mpls</b> 1024</p>

<p style="margin-left:22%;">filters packets with an outer
label of 100000 and an inner label of 1024, and</p>

<p style="margin-left:29%;"><b>mpls &amp;&amp; mpls</b>
1024 <b>&amp;&amp; host</b> 192.9.200.1</p>

<p style="margin-left:22%;">filters packets to or from
192.9.200.1 with an inner label of 1024 and any outer
label.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>pppoed</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is a PPP-over-Ethernet Discovery
packet (Ethernet type 0x8863).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>pppoes</b>
<i>[session_id]</i></p>

<p style="margin-left:22%;">True if the packet is a
PPP-over-Ethernet Session packet (Ethernet type 0x8864). If
the optional <i>session_id</i> is specified, only true if
the packet has the specified <i>session_id</i>. Note that
the first <b>pppoes</b> keyword encountered in an expression
changes the decoding offsets for the remainder of the
expression on the assumption that the packet is a PPPoE
session packet.</p>

<p style="margin-left:22%; margin-top: 1em">For
example:</p>

<p style="margin-left:29%;"><b>pppoes</b> 0x27
<b>&amp;&amp; ip</b></p>

<p style="margin-left:22%;">filters IPv4 protocol
encapsulated in PPPoE session id 0x27.</p>

<p style="margin-left:11%;"><b>geneve</b> <i>[vni]</i></p>

<p style="margin-left:22%;">True if the packet is a Geneve
packet (UDP port 6081). If the optional <i>vni</i> is
specified, only true if the packet has the specified
<i>vni</i>. Note that when the <b>geneve</b> keyword is
encountered in an expression, it changes the decoding
offsets for the remainder of the expression on the
assumption that the packet is a Geneve packet.</p>

<p style="margin-left:22%; margin-top: 1em">For
example:</p>

<p style="margin-left:29%;"><b>geneve</b> 0xb <b>&amp;&amp;
ip</b></p>

<p style="margin-left:22%;">filters IPv4 protocol
encapsulated in Geneve with VNI 0xb. This will match both
IPv4 directly encapsulated in Geneve as well as IPv4
contained inside an Ethernet frame.</p>

<p style="margin-left:11%;"><b>iso proto</b>
<i>protocol</i></p>

<p style="margin-left:22%;">True if the packet is an OSI
packet of protocol type <i>protocol</i>. <i>Protocol</i> can
be a number or one of the names <b>clnp</b>, <b>esis</b>, or
<b>isis</b>.</p>

<p style="margin-left:11%;"><b>clnp</b>, <b>esis</b>,
<b>isis</b></p>

<p style="margin-left:22%;">Abbreviations for:</p>

<p style="margin-left:29%;"><b>iso proto
\</b><i>protocol</i></p>

<p style="margin-left:22%;">where <i>protocol</i> is one of
the above protocols.</p>

<p style="margin-left:11%;"><b>l1</b>, <b>l2</b>,
<b>iih</b>, <b>lsp</b>, <b>snp</b>, <b>csnp</b>,
<b>psnp</b></p>

<p style="margin-left:22%;">Abbreviations for IS-IS PDU
types.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>vpi</b> <i>n</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, with a virtual path identifier of <i>n</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>vci</b> <i>n</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, with a virtual channel identifier of <i>n</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>lane</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is an ATM LANE packet. Note that the first
<b>lane</b> keyword encountered in an expression changes the
tests done in the remainder of the expression on the
assumption that the packet is either a LANE emulated
Ethernet packet or a LANE LE Control packet. If <b>lane</b>
isn&rsquo;t specified, the tests are done under the
assumption that the packet is an LLC-encapsulated
packet.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>oamf4s</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is a segment OAM F4 flow cell (VPI=0 &amp;
VCI=3).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>oamf4e</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is an end-to-end OAM F4 flow cell (VPI=0 &amp;
VCI=4).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>oamf4</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is a segment or end-to-end OAM F4 flow cell
(VPI=0 &amp; (VCI=3 | VCI=4)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>oam</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is a segment or end-to-end OAM F4 flow cell
(VPI=0 &amp; (VCI=3 | VCI=4)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>metac</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is on a meta signaling circuit (VPI=0 &amp;
VCI=1).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>bcc</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is on a broadcast signaling circuit (VPI=0
&amp; VCI=2).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>sc</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is on a signaling circuit (VPI=0 &amp;
VCI=5).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ilmic</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>True if the packet is an ATM packet, for SunATM on
Solaris, and is on an ILMI circuit (VPI=0 &amp; VCI=16).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>connectmsg</b></p>

<p style="margin-left:22%;">True if the packet is an ATM
packet, for SunATM on Solaris, and is on a signaling circuit
and is a Q.2931 Setup, Call Proceeding, Connect, Connect
Ack, Release, or Release Done message.</p>

<p style="margin-left:11%;"><b>metaconnect</b></p>

<p style="margin-left:22%;">True if the packet is an ATM
packet, for SunATM on Solaris, and is on a meta signaling
circuit and is a Q.2931 Setup, Call Proceeding, Connect,
Release, or Release Done message.</p>

<p style="margin-left:11%;"><i>expr relop expr</i></p>

<p style="margin-left:22%;">True if the relation holds,
where <i>relop</i> is one of &gt;, &lt;, &gt;=, &lt;=, =,
!=, and <i>expr</i> is an arithmetic expression composed of
integer constants (expressed in standard C syntax), the
normal binary operators [+, -, *, /, %, &amp;, |, ^,
&lt;&lt;, &gt;&gt;], a length operator, and special packet
data accessors. Note that all comparisons are unsigned, so
that, for example, 0x80000000 and 0xffffffff are &gt; 0.</p>

<p style="margin-left:22%; margin-top: 1em">The % and ^
operators are currently only supported for filtering in the
kernel on Linux with 3.7 and later kernels; on all other
systems, if those operators are used, filtering will be done
in user mode, which will increase the overhead of capturing
packets and may cause more packets to be dropped.</p>

<p style="margin-left:22%; margin-top: 1em">To access data
inside the packet, use the following syntax:</p>

<p style="margin-left:29%;"><i>proto</i> <b>[</b>
<i>expr</i> <b>:</b> <i>size</i> <b>]</b></p>

<p style="margin-left:22%;"><i>Proto</i> is one of
<b>ether, fddi, tr, wlan, ppp, slip, link, ip, arp, rarp,
tcp, udp, icmp, ip6</b> or <b>radio</b>, and indicates the
protocol layer for the index operation. (<b>ether, fddi,
wlan, tr, ppp, slip</b> and <b>link</b> all refer to the
link layer. <b>radio</b> refers to the &quot;radio
header&quot; added to some 802.11 captures.) Note that
<b>tcp</b>, <b>udp</b> and other upper-layer protocol types
only apply to IPv4, not IPv6 (this will be fixed in the
future). The byte offset, relative to the indicated protocol
layer, is given by <i>expr</i>. <i>Size</i> is optional and
indicates the number of bytes in the field of interest; it
can be either one, two, or four, and defaults to one. The
length operator, indicated by the keyword <b>len</b>, gives
the length of the packet.</p>

<p style="margin-left:22%; margin-top: 1em">For example,
&rsquo;<b>ether[</b>0<b>] &amp;</b> 1 <b>!=</b> 0&rsquo;
catches all multicast traffic. The expression
&rsquo;<b>ip[</b>0<b>] &amp;</b> 0xf <b>!=</b> 5&rsquo;
catches all IPv4 packets with options. The expression
&rsquo;<b>ip[</b>6:2<b>] &amp;</b> 0x1fff <b>=</b> 0&rsquo;
catches only unfragmented IPv4 datagrams and frag zero of
fragmented IPv4 datagrams. This check is implicitly applied
to the <b>tcp</b> and <b>udp</b> index operations. For
instance, <b>tcp[</b>0<b>]</b> always means the first byte
of the TCP <i>header</i>, and never means the first byte of
an intervening fragment.</p>

<p style="margin-left:22%; margin-top: 1em">Some offsets
and field values may be expressed as names rather than as
numeric values. The following protocol header field offsets
are available: <b>icmptype</b> (ICMP type field),
<b>icmp6type</b> (ICMPv6 type field), <b>icmpcode</b> (ICMP
code field), <b>icmp6code</b> (ICMPv6 code field) and
<b>tcpflags</b> (TCP flags field).</p>

<p style="margin-left:22%; margin-top: 1em">The following
ICMP type field values are available: <b>icmp-echoreply</b>,
<b>icmp-unreach</b>, <b>icmp-sourcequench</b>,
<b>icmp-redirect</b>, <b>icmp-echo</b>,
<b>icmp-routeradvert</b>, <b>icmp-routersolicit</b>,
<b>icmp-timxceed</b>, <b>icmp-paramprob</b>,
<b>icmp-tstamp</b>, <b>icmp-tstampreply</b>,
<b>icmp-ireq</b>, <b>icmp-ireqreply</b>,
<b>icmp-maskreq</b>, <b>icmp-maskreply</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The following
ICMPv6 type fields are available:
<b>icmp6-destinationrunreach</b>, <b>icmp6-packettoobig</b>,
<b>icmp6-timeexceeded</b>, <b>icmp6-parameterproblem</b>,
<b>icmp6-echo</b>, <b>icmp6-echoreply</b>,
<b>icmp6-multicastlistenerquery</b>,
<b>icmp6-multicastlistenerreportv1</b>,
<b>icmp6-multicastlistenerdone</b>,
<b>icmp6-routersolicit</b>, <b>icmp6-routeradvert</b>,
<b>icmp6-neighborsolicit</b>, <b>icmp6-neighboradvert</b>,
<b>icmp6-redirect</b>, <b>icmp6-routerrenum</b>,
<b>icmp6-nodeinformationquery</b>,
<b>icmp6-nodeinformationresponse</b>,
<b>icmp6-ineighbordiscoverysolicit</b>,
<b>icmp6-ineighbordiscoveryadvert</b>,
<b>icmp6-multicastlistenerreportv2</b>,
<b>icmp6-homeagentdiscoveryrequest</b>,
<b>icmp6-homeagentdiscoveryreply</b>,
<b>icmp6-mobileprefixsolicit</b>,
<b>icmp6-mobileprefixadvert</b>,
<b>icmp6-certpathsolicit</b>, <b>icmp6-certpathadvert</b>,
<b>icmp6-multicastrouteradvert</b>,
<b>icmp6-multicastroutersolicit</b>,
<b>icmp6-multicastrouterterm</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The following
TCP flags field values are available: <b>tcp-fin</b>,
<b>tcp-syn</b>, <b>tcp-rst</b>, <b>tcp-push</b>,
<b>tcp-ack</b>, <b>tcp-urg</b>, <b>tcp-ece</b>,
<b>tcp-cwr</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Primitives may
be combined using:</p>

<p style="margin-left:22%; margin-top: 1em">A parenthesized
group of primitives and operators.</p>

<p style="margin-left:22%; margin-top: 1em">Negation
(&rsquo;<b>!</b>&rsquo; or &rsquo;<b>not</b>&rsquo;).</p>

<p style="margin-left:22%; margin-top: 1em">Concatenation
(&rsquo;<b>&amp;&amp;</b>&rsquo; or
&rsquo;<b>and</b>&rsquo;).</p>

<p style="margin-left:22%; margin-top: 1em">Alternation
(&rsquo;<b>||</b>&rsquo; or &rsquo;<b>or</b>&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">Negation has
the highest precedence. Alternation and concatenation have
equal precedence and associate left to right. Note that
explicit <b>and</b> tokens, not juxtaposition, are now
required for concatenation.</p>

<p style="margin-left:11%; margin-top: 1em">If an
identifier is given without a keyword, the most recent
keyword is assumed. For example,</p>

<p style="margin-left:18%;"><b>not host</b> vs <b>and</b>
ace</p>

<p style="margin-left:11%;">is short for</p>

<p style="margin-left:18%;"><b>not host</b> vs <b>and
host</b> ace</p>

<p style="margin-left:11%;">which should not be confused
with</p>

<p style="margin-left:18%;"><b>not (host</b> vs <b>or</b>
ace<b>)</b></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To select all
packets arriving at or departing from
&rsquo;sundown&rsquo;:</p>

<p style="margin-left:22%;"><b>host</b> sundown</p>

<p style="margin-left:11%; margin-top: 1em">To select
traffic between &rsquo;helios&rsquo; and either
&rsquo;hot&rsquo; or &rsquo;ace&rsquo;:</p>

<p style="margin-left:22%;"><b>host</b> helios <b>and
(</b>hot <b>or</b> ace<b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">To select all
IPv4 packets between &rsquo;ace&rsquo; and any host except
&rsquo;helios&rsquo;:</p>

<p style="margin-left:22%;"><b>ip host</b> ace <b>and
not</b> helios</p>

<p style="margin-left:11%; margin-top: 1em">To select all
traffic between local hosts and hosts at Berkeley:</p>

<p style="margin-left:22%;"><b>net</b> ucb-ether</p>

<p style="margin-left:11%; margin-top: 1em">To select all
FTP traffic through Internet gateway &rsquo;snup&rsquo;:</p>

<p style="margin-left:22%;"><b>gateway</b> snup <b>and
(port</b> ftp <b>or</b> ftp-data<b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">To select IPv4
traffic neither sourced from nor destined for local hosts
(if you gateway to one other net, this stuff should never
make it onto your local net).</p>

<p style="margin-left:22%;"><b>ip and not net</b>
localnet</p>

<p style="margin-left:11%; margin-top: 1em">To select the
start and end packets (the SYN and FIN packets) of each TCP
conversation that involves a non-local host.</p>

<p style="margin-left:22%;"><b>tcp[tcpflags] &amp;
(tcp-syn|tcp-fin) !=</b> 0 <b>and not src and dst net</b>
localnet</p>

<p style="margin-left:11%; margin-top: 1em">To select the
TCP packets with flags RST and ACK both set. (i.e. select
only the RST and ACK flags in the flags field, and if the
result is &quot;RST and ACK both set&quot;, match)</p>

<p style="margin-left:22%;"><b>tcp[tcpflags] &amp;
(tcp-rst|tcp-ack) == (tcp-rst|tcp-ack)</b></p>

<p style="margin-left:11%; margin-top: 1em">To select all
IPv4 HTTP packets to and from port 80, i.e. print only
packets that contain data, not, for example, SYN and FIN
packets and ACK-only packets. (IPv6 is left as an exercise
for the reader.)</p>

<p style="margin-left:22%;"><b>tcp port</b> 80 <b>and
(((ip[</b>2:2<b>] -
((ip[</b>0<b>]&amp;</b>0xf<b>)&lt;&lt;</b>2<b>)) -
((tcp[</b>12<b>]&amp;</b>0xf0<b>)&gt;&gt;</b>2<b>)) !=</b>
0<b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">To select IPv4
packets longer than 576 bytes sent through gateway
&rsquo;snup&rsquo;:</p>

<p style="margin-left:22%;"><b>gateway</b> snup <b>and
ip[</b>2:2<b>] &gt;</b> 576</p>

<p style="margin-left:11%; margin-top: 1em">To select IPv4
broadcast or multicast packets that were <i>not</i> sent via
Ethernet broadcast or multicast:</p>

<p style="margin-left:22%;"><b>ether[</b>0<b>] &amp;</b> 1
<b>=</b> 0 <b>and ip[</b>16<b>] &gt;=</b> 224</p>

<p style="margin-left:11%; margin-top: 1em">To select all
ICMP packets that are not echo requests/replies (i.e., not
ping packets):</p>

<p style="margin-left:22%;"><b>icmp[icmptype] != icmp-echo
and icmp[icmptype] != icmp-echoreply <br>
icmp6[icmp6type] != icmp6-echo and icmp6[icmp6type] !=
icmp6-echoreply</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>pcap</b>(3PCAP)</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To report a
security issue please send an e-mail to
security@tcpdump.org.</p>

<p style="margin-left:11%; margin-top: 1em">To report bugs
and other problems, contribute patches, request a feature,
provide generic feedback etc please see the file
<i>CONTRIBUTING.md</i> in the libpcap source tree root.</p>

<p style="margin-left:11%; margin-top: 1em">Filter
expressions on fields other than those in Token Ring headers
will not correctly handle source-routed Token Ring
packets.</p>

<p style="margin-left:11%; margin-top: 1em">Filter
expressions on fields other than those in 802.11 headers
will not correctly handle 802.11 data packets with both To
DS and From DS set.</p>

<p style="margin-left:11%; margin-top: 1em">&rsquo;<b>ip6
proto</b>&rsquo; should chase header chain, but at this
moment it does not. &rsquo;<b>ip6 protochain</b>&rsquo; is
supplied for this behavior. For example, to match IPv6
fragments: &rsquo;<b>ip6 protochain</b> 44&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">Arithmetic
expression against transport layer headers, like
<b>tcp[0]</b>, does not work against IPv6 packets. It only
looks at IPv4 packets.</p>
<hr>
</body>
</html>
