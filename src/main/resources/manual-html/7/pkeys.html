<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:40:16 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PKEYS</title>

</head>
<body>

<h1 align="center">PKEYS</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">pkeys -
overview of Memory Protection Keys</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Memory
Protection Keys (pkeys) are an extension to existing
page-based memory permissions. Normal page permissions using
page tables require expensive system calls and TLB
invalidations when changing permissions. Memory Protection
Keys provide a mechanism for changing protections without
requiring modification of the page tables on every
permission change.</p>

<p style="margin-left:11%; margin-top: 1em">To use pkeys,
software must first &quot;tag&quot; a page in the page
tables with a pkey. After this tag is in place, an
application only has to change the contents of a register in
order to remove write access, or all access to a tagged
page.</p>

<p style="margin-left:11%; margin-top: 1em">Protection keys
work in conjunction with the existing <b>PROT_READ</b>/
<b>PROT_WRITE</b>/ <b>PROT_EXEC</b> permissions passed to
system calls such as <a href="https://man.page/2/mprotect">mprotect(2)</a> and <a href="https://man.page/2/mmap">mmap(2)</a>,
but always act to further restrict these traditional
permission mechanisms.</p>

<p style="margin-left:11%; margin-top: 1em">If a process
performs an access that violates pkey restrictions, it
receives a <b>SIGSEGV</b> signal. See <a href="https://man.page/2/sigaction">sigaction(2)</a>
for details of the information available with that
signal.</p>

<p style="margin-left:11%; margin-top: 1em">To use the
pkeys feature, the processor must support it, and the kernel
must contain support for the feature on a given processor.
As of early 2016 only future Intel x86 processors are
supported, and this hardware supports 16 protection keys in
each process. However, pkey 0 is used as the default key, so
a maximum of 15 are available for actual application use.
The default key is assigned to any memory region for which a
pkey has not been explicitly assigned via
<a href="https://man.page/2/pkey_mprotect">pkey_mprotect(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Protection keys
have the potential to add a layer of security and
reliability to applications. But they have not been
primarily designed as a security feature. For instance,
WRPKRU is a completely unprivileged instruction, so pkeys
are useless in any case that an attacker controls the PKRU
register or can execute arbitrary instructions.</p>

<p style="margin-left:11%; margin-top: 1em">Applications
should be very careful to ensure that they do not
&quot;leak&quot; protection keys. For instance, before
calling <a href="https://man.page/2/pkey_free">pkey_free(2)</a>, the application should be sure
that no memory has that pkey assigned. If the application
left the freed pkey assigned, a future user of that pkey
might inadvertently change the permissions of an unrelated
data structure, which could impact security or stability.
The kernel currently allows in-use pkeys to have
<a href="https://man.page/2/pkey_free">pkey_free(2)</a> called on them because it would have
processor or memory performance implications to perform the
additional checks needed to disallow it. Implementation of
the necessary checks is left up to applications.
Applications may implement these checks by searching the
<i>/proc/[pid]/smaps</i> file for memory regions with the
pkey assigned. Further details can be found in
<a href="https://man.page/5/proc">proc(5)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Any application
wanting to use protection keys needs to be able to function
without them. They might be unavailable because the hardware
that the application runs on does not support them, the
kernel code does not contain support, the kernel support has
been disabled, or because the keys have all been allocated,
perhaps by a library the application is using. It is
recommended that applications wanting to use protection keys
should simply call <a href="https://man.page/2/pkey_alloc">pkey_alloc(2)</a> and test whether the
call succeeds, instead of attempting to detect support for
the feature in any other way.</p>

<p style="margin-left:11%; margin-top: 1em">Although
unnecessary, hardware support for protection keys may be
enumerated with the <i>cpuid</i> instruction. Details of how
to do this can be found in the Intel Software Developers
Manual. The kernel performs this enumeration and exposes the
information in <i>/proc/cpuinfo</i> under the
&quot;flags&quot; field. The string &quot;pku&quot; in this
field indicates hardware support for protection keys and the
string &quot;ospke&quot; indicates that the kernel contains
and has enabled protection keys support.</p>

<p style="margin-left:11%; margin-top: 1em">Applications
using threads and protection keys should be especially
careful. Threads inherit the protection key rights of the
parent at the time of the <a href="https://man.page/2/clone">clone(2)</a>, system call.
Applications should either ensure that their own permissions
are appropriate for child threads at the time when
<a href="https://man.page/2/clone">clone(2)</a> is called, or ensure that each child thread
can perform its own initialization of protection key
rights.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Signal
Handler Behavior</b> <br>
Each time a signal handler is invoked (including nested
signals), the thread is temporarily given a new, default set
of protection key rights that override the rights from the
interrupted context. This means that applications must
re-establish their desired protection key rights upon
entering a signal handler if the desired rights differ from
the defaults. The rights of any interrupted context are
restored when the signal handler returns.</p>

<p style="margin-left:11%; margin-top: 1em">This signal
behavior is unusual and is due to the fact that the x86 PKRU
register (which stores protection key access rights) is
managed with the same hardware mechanism (XSAVE) that
manages floating-point registers. The signal behavior is the
same as that of floating-point registers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protection
Keys system calls</b> <br>
The Linux kernel implements the following pkey-related
system calls: <a href="https://man.page/2/pkey_mprotect">pkey_mprotect(2)</a>, <a href="https://man.page/2/pkey_alloc">pkey_alloc(2)</a>,
and <a href="https://man.page/2/pkey_free">pkey_free(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The Linux pkey
system calls are available only if the kernel was configured
and built with the
<b>CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS</b> option.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The program
below allocates a page of memory with read and write
permissions. It then writes some data to the memory and
successfully reads it back. After that, it attempts to
allocate a protection key and disallows access to the page
by using the WRPKRU instruction. It then tries to access the
page, which we now expect to cause a fatal signal to the
application.</p>

<p style="margin-left:17%; margin-top: 1em">$
<b>./a.out</b> <br>
buffer contains: 73 <br>
about to read buffer again... <br>
Segmentation fault (core dumped)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
#define _GNU_SOURCE <br>
#include &lt;unistd.h&gt; <br>
#include &lt;sys/syscall.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;sys/mman.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">static inline
void <br>
wrpkru(unsigned int pkru) <br>
{ <br>
unsigned int eax = pkru; <br>
unsigned int ecx = 0; <br>
unsigned int edx = 0;</p>

<p style="margin-left:11%; margin-top: 1em">asm
volatile(&quot;.byte 0x0f,0x01,0xef\n\t&quot; <br>
: : &quot;a&quot; (eax), &quot;c&quot; (ecx), &quot;d&quot;
(edx)); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
pkey_set(int pkey, unsigned long rights, unsigned long
flags) <br>
{ <br>
unsigned int pkru = (rights &lt;&lt; (2 * pkey)); <br>
return wrpkru(pkru); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
pkey_mprotect(void *ptr, size_t size, unsigned long
orig_prot, <br>
unsigned long pkey) <br>
{ <br>
return syscall(SYS_pkey_mprotect, ptr, size, orig_prot,
pkey); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
pkey_alloc(void) <br>
{ <br>
return syscall(SYS_pkey_alloc, 0, 0); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
pkey_free(unsigned long pkey) <br>
{ <br>
return syscall(SYS_pkey_free, pkey); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">#define
errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \ <br>
} while (0)</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(void) <br>
{ <br>
int status; <br>
int pkey; <br>
int *buffer;</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
*Allocate one page of memory <br>
*/ <br>
buffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,
<br>
MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); <br>
if (buffer == MAP_FAILED) <br>
errExit(&quot;mmap&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* Put some random data into the page (still OK to touch)
<br>
*/ <br>
*buffer = __LINE__; <br>
printf(&quot;buffer contains: %d\n&quot;, *buffer);</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* Allocate a protection key: <br>
*/ <br>
pkey = pkey_alloc(); <br>
if (pkey == -1) <br>
errExit(&quot;pkey_alloc&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* Disable access to any memory with &quot;pkey&quot; set,
<br>
* even though there is none right now <br>
*/ <br>
status = pkey_set(pkey, PKEY_DISABLE_ACCESS, 0); <br>
if (status) <br>
errExit(&quot;pkey_set&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* Set the protection key on &quot;buffer&quot;. <br>
* Note that it is still read/write as far as mprotect() is
<br>
* concerned and the previous pkey_set() overrides it. <br>
*/ <br>
status = pkey_mprotect(buffer, getpagesize(), <br>
PROT_READ | PROT_WRITE, pkey); <br>
if (status == -1) <br>
errExit(&quot;pkey_mprotect&quot;);</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;about
to read buffer again...\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* <br>
* This will crash, because we have disallowed access <br>
*/ <br>
printf(&quot;buffer contains: %d\n&quot;, *buffer);</p>

<p style="margin-left:11%; margin-top: 1em">status =
pkey_free(pkey); <br>
if (status == -1) <br>
errExit(&quot;pkey_free&quot;);</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/2/pkey_alloc">pkey_alloc(2)</a>,
<a href="https://man.page/2/pkey_free">pkey_free(2)</a>, <a href="https://man.page/2/pkey_mprotect">pkey_mprotect(2)</a>,
<a href="https://man.page/2/sigaction">sigaction(2)</a></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
