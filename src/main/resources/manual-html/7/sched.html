<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:53 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SCHED</title>

</head>
<body>

<h1 align="center">SCHED</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">sched -
overview of CPU scheduling</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Since Linux
2.6.23, the default scheduler is CFS, the &quot;Completely
Fair Scheduler&quot;. The CFS scheduler replaced the earlier
&quot;O(1)&quot; scheduler.</p>

<p style="margin-left:11%; margin-top: 1em"><b>API
summary</b> <br>
Linux provides the following system calls for controlling
the CPU scheduling behavior, policy, and priority of
processes (or, more precisely, threads). <b><br>
nice</b>(2)</p>

<p style="margin-left:22%;">Set a new nice value for the
calling thread, and return the new nice value.</p>

<p style="margin-left:11%;"><b>getpriority</b>(2)</p>

<p style="margin-left:22%;">Return the nice value of a
thread, a process group, or the set of threads owned by a
specified user.</p>

<p style="margin-left:11%;"><b>setpriority</b>(2)</p>

<p style="margin-left:22%;">Set the nice value of a thread,
a process group, or the set of threads owned by a specified
user.</p>


<p style="margin-left:11%;"><b>sched_setscheduler</b>(2)</p>

<p style="margin-left:22%;">Set the scheduling policy and
parameters of a specified thread.</p>


<p style="margin-left:11%;"><b>sched_getscheduler</b>(2)</p>

<p style="margin-left:22%;">Return the scheduling policy of
a specified thread.</p>

<p style="margin-left:11%;"><b>sched_setparam</b>(2)</p>

<p style="margin-left:22%;">Set the scheduling parameters
of a specified thread.</p>

<p style="margin-left:11%;"><b>sched_getparam</b>(2)</p>

<p style="margin-left:22%;">Fetch the scheduling parameters
of a specified thread.</p>


<p style="margin-left:11%;"><b>sched_get_priority_max</b>(2)</p>

<p style="margin-left:22%;">Return the maximum priority
available in a specified scheduling policy.</p>


<p style="margin-left:11%;"><b>sched_get_priority_min</b>(2)</p>

<p style="margin-left:22%;">Return the minimum priority
available in a specified scheduling policy.</p>


<p style="margin-left:11%;"><b>sched_rr_get_interval</b>(2)</p>

<p style="margin-left:22%;">Fetch the quantum used for
threads that are scheduled under the &quot;round-robin&quot;
scheduling policy.</p>

<p style="margin-left:11%;"><b>sched_yield</b>(2)</p>

<p style="margin-left:22%;">Cause the caller to relinquish
the CPU, so that some other thread be executed.</p>


<p style="margin-left:11%;"><b>sched_setaffinity</b>(2)</p>

<p style="margin-left:22%;">(Linux-specific) Set the CPU
affinity of a specified thread.</p>


<p style="margin-left:11%;"><b>sched_getaffinity</b>(2)</p>

<p style="margin-left:22%;">(Linux-specific) Get the CPU
affinity of a specified thread.</p>

<p style="margin-left:11%;"><b>sched_setattr</b>(2)</p>

<p style="margin-left:22%;">Set the scheduling policy and
parameters of a specified thread. This (Linux-specific)
system call provides a superset of the functionality of
<b>sched_setscheduler</b>(2) and
<b>sched_setparam</b>(2).</p>

<p style="margin-left:11%;"><b>sched_getattr</b>(2)</p>

<p style="margin-left:22%;">Fetch the scheduling policy and
parameters of a specified thread. This (Linux-specific)
system call provides a superset of the functionality of
<b>sched_getscheduler</b>(2) and
<b>sched_getparam</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Scheduling
policies</b> <br>
The scheduler is the kernel component that decides which
runnable thread will be executed by the CPU next. Each
thread has an associated scheduling policy and a
<i>static</i> scheduling priority, <i>sched_priority</i>.
The scheduler makes its decisions based on knowledge of the
scheduling policy and static priority of all threads on the
system.</p>

<p style="margin-left:11%; margin-top: 1em">For threads
scheduled under one of the normal scheduling policies
(<b>SCHED_OTHER</b>, <b>SCHED_IDLE</b>, <b>SCHED_BATCH</b>),
<i>sched_priority</i> is not used in scheduling decisions
(it must be specified as 0).</p>

<p style="margin-left:11%; margin-top: 1em">Processes
scheduled under one of the real-time policies
(<b>SCHED_FIFO</b>, <b>SCHED_RR</b>) have a
<i>sched_priority</i> value in the range 1 (low) to 99
(high). (As the numbers imply, real-time threads always have
higher priority than normal threads.) Note well: POSIX.1
requires an implementation to support only a minimum 32
distinct priority levels for the real-time policies, and
some systems supply just this minimum. Portable programs
should use <b>sched_get_priority_min</b>(2) and
<b>sched_get_priority_max</b>(2) to find the range of
priorities supported for a particular policy.</p>

<p style="margin-left:11%; margin-top: 1em">Conceptually,
the scheduler maintains a list of runnable threads for each
possible <i>sched_priority</i> value. In order to determine
which thread runs next, the scheduler looks for the nonempty
list with the highest static priority and selects the thread
at the head of this list.</p>

<p style="margin-left:11%; margin-top: 1em">A
thread&rsquo;s scheduling policy determines where it will be
inserted into the list of threads with equal static priority
and how it will move inside this list.</p>

<p style="margin-left:11%; margin-top: 1em">All scheduling
is preemptive: if a thread with a higher static priority
becomes ready to run, the currently running thread will be
preempted and returned to the wait list for its static
priority level. The scheduling policy determines the
ordering only within the list of runnable threads with equal
static priority.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SCHED_FIFO:
First in-first out scheduling <br>
SCHED_FIFO</b> can be used only with static priorities
higher than 0, which means that when a <b>SCHED_FIFO</b>
thread becomes runnable, it will always immediately preempt
any currently running <b>SCHED_OTHER</b>,
<b>SCHED_BATCH</b>, or <b>SCHED_IDLE</b> thread.
<b>SCHED_FIFO</b> is a simple scheduling algorithm without
time slicing. For threads scheduled under the
<b>SCHED_FIFO</b> policy, the following rules apply:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1)</p></td>
<td width="1%"></td>
<td width="85%">


<p>A running <b>SCHED_FIFO</b> thread that has been
preempted by another thread of higher priority will stay at
the head of the list for its priority and will resume
execution as soon as all threads of higher priority are
blocked again.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2)</p></td>
<td width="1%"></td>
<td width="85%">


<p>When a blocked <b>SCHED_FIFO</b> thread becomes
runnable, it will be inserted at the end of the list for its
priority.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3)</p></td>
<td width="1%"></td>
<td width="85%">


<p>If a call to <b>sched_setscheduler</b>(2),
<b>sched_setparam</b>(2), <b>sched_setattr</b>(2),
<b>pthread_setschedparam</b>(3), or
<b>pthread_setschedprio</b>(3) changes the priority of the
running or runnable <b>SCHED_FIFO</b> thread identified by
<i>pid</i> the effect on the thread&rsquo;s position in the
list depends on the direction of the change to threads
priority:</p> </td></tr>
</table>

<p style="margin-left:15%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%"></td>
<td width="3%"></td>
<td width="80%">


<p style="margin-top: 1em">If the thread&rsquo;s priority
is raised, it is placed at the end of the list for its new
priority. As a consequence, it may preempt a currently
running thread with the same priority.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="80%">


<p>If the thread&rsquo;s priority is unchanged, its
position in the run list is unchanged.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="80%">


<p>If the thread&rsquo;s priority is lowered, it is placed
at the front of the list for its new priority.</p></td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">According to
POSIX.1-2008, changes to a thread&rsquo;s priority (or
policy) using any mechanism other than
<b>pthread_setschedprio</b>(3) should result in the thread
being placed at the end of the list for its priority.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4)</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">A thread calling
<b>sched_yield</b>(2) will be put at the end of the
list.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">No other events
will move a thread scheduled under the <b>SCHED_FIFO</b>
policy in the wait list of runnable threads with equal
static priority.</p>

<p style="margin-left:11%; margin-top: 1em">A
<b>SCHED_FIFO</b> thread runs until either it is blocked by
an I/O request, it is preempted by a higher priority thread,
or it calls <b>sched_yield</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>SCHED_RR:
Round-robin scheduling <br>
SCHED_RR</b> is a simple enhancement of <b>SCHED_FIFO</b>.
Everything described above for <b>SCHED_FIFO</b> also
applies to <b>SCHED_RR</b>, except that each thread is
allowed to run only for a maximum time quantum. If a
<b>SCHED_RR</b> thread has been running for a time period
equal to or longer than the time quantum, it will be put at
the end of the list for its priority. A <b>SCHED_RR</b>
thread that has been preempted by a higher priority thread
and subsequently resumes execution as a running thread will
complete the unexpired portion of its round-robin time
quantum. The length of the time quantum can be retrieved
using <b>sched_rr_get_interval</b>(2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>SCHED_DEADLINE:
Sporadic task model deadline scheduling</b> <br>
Since version 3.14, Linux provides a deadline scheduling
policy (<b>SCHED_DEADLINE</b>). This policy is currently
implemented using GEDF (Global Earliest Deadline First) in
conjunction with CBS (Constant Bandwidth Server). To set and
fetch this policy and associated attributes, one must use
the Linux-specific <b>sched_setattr</b>(2) and
<b>sched_getattr</b>(2) system calls.</p>

<p style="margin-left:11%; margin-top: 1em">A sporadic task
is one that has a sequence of jobs, where each job is
activated at most once per period. Each job also has a
<i>relative deadline</i>, before which it should finish
execution, and a <i>computation time</i>, which is the CPU
time necessary for executing the job. The moment when a task
wakes up because a new job has to be executed is called the
<i>arrival time</i> (also referred to as the request time or
release time). The <i>start time</i> is the time at which a
task starts its execution. The <i>absolute deadline</i> is
thus obtained by adding the relative deadline to the arrival
time.</p>

<p style="margin-left:11%; margin-top: 1em">The following
diagram clarifies these terms:</p>

<p style="margin-left:17%; margin-top: 1em">arrival/wakeup
absolute deadline <br>
| start time | <br>
| | | <br>
v v v <br>
-----x--------xooooooooooooooooo--------x--------x--- <br>
|&lt;- comp. time -&gt;| <br>
|&lt;------- relative deadline ------&gt;| <br>
|&lt;-------------- period -------------------&gt;|</p>

<p style="margin-left:11%; margin-top: 1em">When setting a
<b>SCHED_DEADLINE</b> policy for a thread using
<b>sched_setattr</b>(2), one can specify three parameters:
<i>Runtime</i>, <i>Deadline</i>, and <i>Period</i>. These
parameters do not necessarily correspond to the
aforementioned terms: usual practice is to set Runtime to
something bigger than the average computation time (or
worst-case execution time for hard real-time tasks),
Deadline to the relative deadline, and Period to the period
of the task. Thus, for <b>SCHED_DEADLINE</b> scheduling, we
have:</p>

<p style="margin-left:17%; margin-top: 1em">arrival/wakeup
absolute deadline <br>
| start time | <br>
| | | <br>
v v v <br>
-----x--------xooooooooooooooooo--------x--------x--- <br>
|&lt;-- Runtime -------&gt;| <br>
|&lt;----------- Deadline -----------&gt;| <br>
|&lt;-------------- Period -------------------&gt;|</p>

<p style="margin-left:11%; margin-top: 1em">The three
deadline-scheduling parameters correspond to the
<i>sched_runtime</i>, <i>sched_deadline</i>, and
<i>sched_period</i> fields of the <i>sched_attr</i>
structure; see <b>sched_setattr</b>(2). These fields express
values in nanoseconds. If <i>sched_period</i> is specified
as 0, then it is made the same as <i>sched_deadline</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The kernel
requires that:</p>

<p style="margin-left:11%; margin-top: 1em">sched_runtime
&lt;= sched_deadline &lt;= sched_period</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
under the current implementation, all of the parameter
values must be at least 1024 (i.e., just over one
microsecond, which is the resolution of the implementation),
and less than 2^63. If any of these checks fails,
<b>sched_setattr</b>(2) fails with the error
<b>EINVAL</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The CBS
guarantees non-interference between tasks, by throttling
threads that attempt to over-run their specified
Runtime.</p>

<p style="margin-left:11%; margin-top: 1em">To ensure
deadline scheduling guarantees, the kernel must prevent
situations where the set of <b>SCHED_DEADLINE</b> threads is
not feasible (schedulable) within the given constraints. The
kernel thus performs an admittance test when setting or
changing <b>SCHED_DEADLINE</b> policy and attributes. This
admission test calculates whether the change is feasible; if
it is not, <b>sched_setattr</b>(2) fails with the error
<b>EBUSY</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For example, it
is required (but not necessarily sufficient) for the total
utilization to be less than or equal to the total number of
CPUs available, where, since each thread can maximally run
for Runtime per Period, that thread&rsquo;s utilization is
its Runtime divided by its Period.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
fulfill the guarantees that are made when a thread is
admitted to the <b>SCHED_DEADLINE</b> policy,
<b>SCHED_DEADLINE</b> threads are the highest priority (user
controllable) threads in the system; if any
<b>SCHED_DEADLINE</b> thread is runnable, it will preempt
any thread scheduled under one of the other policies.</p>

<p style="margin-left:11%; margin-top: 1em">A call to
<b>fork</b>(2) by a thread scheduled under the
<b>SCHED_DEADLINE</b> policy fails with the error
<b>EAGAIN</b>, unless the thread has its reset-on-fork flag
set (see below).</p>

<p style="margin-left:11%; margin-top: 1em">A
<b>SCHED_DEADLINE</b> thread that calls
<b>sched_yield</b>(2) will yield the current job and wait
for a new period to begin.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SCHED_OTHER:
Default Linux time-sharing scheduling <br>
SCHED_OTHER</b> can be used at only static priority 0 (i.e.,
threads under real-time policies always have priority over
<b>SCHED_OTHER</b> processes). <b>SCHED_OTHER</b> is the
standard Linux time-sharing scheduler that is intended for
all threads that do not require the special real-time
mechanisms.</p>

<p style="margin-left:11%; margin-top: 1em">The thread to
run is chosen from the static priority 0 list based on a
<i>dynamic</i> priority that is determined only inside this
list. The dynamic priority is based on the nice value (see
below) and is increased for each time quantum the thread is
ready to run, but denied to run by the scheduler. This
ensures fair progress among all <b>SCHED_OTHER</b>
threads.</p>

<p style="margin-left:11%; margin-top: 1em">In the Linux
kernel source code, the <b>SCHED_OTHER</b> policy is
actually named <b>SCHED_NORMAL</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The nice
value</b> <br>
The nice value is an attribute that can be used to influence
the CPU scheduler to favor or disfavor a process in
scheduling decisions. It affects the scheduling of
<b>SCHED_OTHER</b> and <b>SCHED_BATCH</b> (see below)
processes. The nice value can be modified using
<b>nice</b>(2), <b>setpriority</b>(2), or
<b>sched_setattr</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">According to
POSIX.1, the nice value is a per-process attribute; that is,
the threads in a process should share a nice value. However,
on Linux, the nice value is a per-thread attribute:
different threads in the same process may have different
nice values.</p>

<p style="margin-left:11%; margin-top: 1em">The range of
the nice value varies across UNIX systems. On modern Linux,
the range is -20 (high priority) to +19 (low priority). On
some other systems, the range is -20..20. Very early Linux
kernels (Before Linux 2.0) had the range -infinity..15.</p>

<p style="margin-left:11%; margin-top: 1em">The degree to
which the nice value affects the relative scheduling of
<b>SCHED_OTHER</b> processes likewise varies across UNIX
systems and across Linux kernel versions.</p>

<p style="margin-left:11%; margin-top: 1em">With the advent
of the CFS scheduler in kernel 2.6.23, Linux adopted an
algorithm that causes relative differences in nice values to
have a much stronger effect. In the current implementation,
each unit of difference in the nice values of two processes
results in a factor of 1.25 in the degree to which the
scheduler favors the higher priority process. This causes
very low nice values (+19) to truly provide little CPU to a
process whenever there is any other higher priority load on
the system, and makes high nice values (-20) deliver most of
the CPU to applications that require it (e.g., some audio
applications).</p>

<p style="margin-left:11%; margin-top: 1em">On Linux, the
<b>RLIMIT_NICE</b> resource limit can be used to define a
limit to which an unprivileged process&rsquo;s nice value
can be raised; see <b>setrlimit</b>(2) for details.</p>

<p style="margin-left:11%; margin-top: 1em">For further
details on the nice value, see the subsections on the
autogroup feature and group scheduling, below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SCHED_BATCH:
Scheduling batch processes</b> <br>
(Since Linux 2.6.16.) <b>SCHED_BATCH</b> can be used only at
static priority 0. This policy is similar to
<b>SCHED_OTHER</b> in that it schedules the thread according
to its dynamic priority (based on the nice value). The
difference is that this policy will cause the scheduler to
always assume that the thread is CPU-intensive.
Consequently, the scheduler will apply a small scheduling
penalty with respect to wakeup behavior, so that this thread
is mildly disfavored in scheduling decisions.</p>

<p style="margin-left:11%; margin-top: 1em">This policy is
useful for workloads that are noninteractive, but do not
want to lower their nice value, and for workloads that want
a deterministic scheduling policy without interactivity
causing extra preemptions (between the workload&rsquo;s
tasks).</p>

<p style="margin-left:11%; margin-top: 1em"><b>SCHED_IDLE:
Scheduling very low priority jobs</b> <br>
(Since Linux 2.6.23.) <b>SCHED_IDLE</b> can be used only at
static priority 0; the process nice value has no influence
for this policy.</p>

<p style="margin-left:11%; margin-top: 1em">This policy is
intended for running jobs at extremely low priority (lower
even than a +19 nice value with the <b>SCHED_OTHER</b> or
<b>SCHED_BATCH</b> policies).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Resetting
scheduling policy for child processes</b> <br>
Each thread has a reset-on-fork scheduling flag. When this
flag is set, children created by <b>fork</b>(2) do not
inherit privileged scheduling policies. The reset-on-fork
flag can be set by either:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">ORing the
<b>SCHED_RESET_ON_FORK</b> flag into the <i>policy</i>
argument when calling <b>sched_setscheduler</b>(2) (since
Linux 2.6.32); or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>specifying the <b>SCHED_FLAG_RESET_ON_FORK</b> flag in
<i>attr.sched_flags</i> when calling
<b>sched_setattr</b>(2).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that the
constants used with these two APIs have different names. The
state of the reset-on-fork flag can analogously be retrieved
using <b>sched_getscheduler</b>(2) and
<b>sched_getattr</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The
reset-on-fork feature is intended for media-playback
applications, and can be used to prevent applications
evading the <b>RLIMIT_RTTIME</b> resource limit (see
<b>getrlimit</b>(2)) by creating multiple child
processes.</p>

<p style="margin-left:11%; margin-top: 1em">More precisely,
if the reset-on-fork flag is set, the following rules apply
for subsequently created children:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">If the calling thread has a
scheduling policy of <b>SCHED_FIFO</b> or <b>SCHED_RR</b>,
the policy is reset to <b>SCHED_OTHER</b> in child
processes.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the calling process has a negative nice value, the
nice value is reset to zero in child processes.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">After the
reset-on-fork flag has been enabled, it can be reset only if
the thread has the <b>CAP_SYS_NICE</b> capability. This flag
is disabled in child processes created by
<b>fork</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Privileges
and resource limits</b> <br>
In Linux kernels before 2.6.12, only privileged
(<b>CAP_SYS_NICE</b>) threads can set a nonzero static
priority (i.e., set a real-time scheduling policy). The only
change that an unprivileged thread can make is to set the
<b>SCHED_OTHER</b> policy, and this can be done only if the
effective user ID of the caller matches the real or
effective user ID of the target thread (i.e., the thread
specified by <i>pid</i>) whose policy is being changed.</p>

<p style="margin-left:11%; margin-top: 1em">A thread must
be privileged (<b>CAP_SYS_NICE</b>) in order to set or
modify a <b>SCHED_DEADLINE</b> policy.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
2.6.12, the <b>RLIMIT_RTPRIO</b> resource limit defines a
ceiling on an unprivileged thread&rsquo;s static priority
for the <b>SCHED_RR</b> and <b>SCHED_FIFO</b> policies. The
rules for changing scheduling policy and priority are as
follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">If an unprivileged thread has a
nonzero <b>RLIMIT_RTPRIO</b> soft limit, then it can change
its scheduling policy and priority, subject to the
restriction that the priority cannot be set to a value
higher than the maximum of its current priority and its
<b>RLIMIT_RTPRIO</b> soft limit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the <b>RLIMIT_RTPRIO</b> soft limit is 0, then the
only permitted changes are to lower the priority, or to
switch to a non-real-time policy.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Subject to the same rules, another unprivileged thread
can also make these changes, as long as the effective user
ID of the thread making the change matches the real or
effective user ID of the target thread.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Special rules apply for the <b>SCHED_IDLE</b> policy. In
Linux kernels before 2.6.39, an unprivileged thread
operating under this policy cannot change its policy,
regardless of the value of its <b>RLIMIT_RTPRIO</b> resource
limit. In Linux kernels since 2.6.39, an unprivileged thread
can switch to either the <b>SCHED_BATCH</b> or the
<b>SCHED_OTHER</b> policy so long as its nice value falls
within the range permitted by its <b>RLIMIT_NICE</b>
resource limit (see <b>getrlimit</b>(2)).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Privileged
(<b>CAP_SYS_NICE</b>) threads ignore the
<b>RLIMIT_RTPRIO</b> limit; as with older kernels, they can
make arbitrary changes to scheduling policy and priority.
See <b>getrlimit</b>(2) for further information on
<b>RLIMIT_RTPRIO</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Limiting the
CPU usage of real-time and deadline processes</b> <br>
A nonblocking infinite loop in a thread scheduled under the
<b>SCHED_FIFO</b>, <b>SCHED_RR</b>, or <b>SCHED_DEADLINE</b>
policy can potentially block all other threads from
accessing the CPU forever. Prior to Linux 2.6.25, the only
way of preventing a runaway real-time process from freezing
the system was to run (at the console) a shell scheduled
under a higher static priority than the tested application.
This allows an emergency kill of tested real-time
applications that do not block or terminate as expected.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
2.6.25, there are other techniques for dealing with runaway
real-time and deadline processes. One of these is to use the
<b>RLIMIT_RTTIME</b> resource limit to set a ceiling on the
CPU time that a real-time process may consume. See
<b>getrlimit</b>(2) for details.</p>

<p style="margin-left:11%; margin-top: 1em">Since version
2.6.25, Linux also provides two <i>/proc</i> files that can
be used to reserve a certain amount of CPU time to be used
by non-real-time processes. Reserving CPU time in this
fashion allows some CPU time to be allocated to (say) a root
shell that can be used to kill a runaway process. Both of
these files specify time values in microseconds: <i><br>
/proc/sys/kernel/sched_rt_period_us</i></p>

<p style="margin-left:22%;">This file specifies a
scheduling period that is equivalent to 100% CPU bandwidth.
The value in this file can range from 1 to <b>INT_MAX</b>,
giving an operating range of 1 microsecond to around 35
minutes. The default value in this file is 1,000,000 (1
second).</p>


<p style="margin-left:11%;"><i>/proc/sys/kernel/sched_rt_runtime_us</i></p>

<p style="margin-left:22%;">The value in this file
specifies how much of the &quot;period&quot; time can be
used by all real-time and deadline scheduled processes on
the system. The value in this file can range from -1 to
<b>INT_MAX</b>-1. Specifying -1 makes the run time the same
as the period; that is, no CPU time is set aside for
non-real-time processes (which was the Linux behavior before
kernel 2.6.25). The default value in this file is 950,000
(0.95 seconds), meaning that 5% of the CPU time is reserved
for processes that don&rsquo;t run under a real-time or
deadline scheduling policy.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Response
time</b> <br>
A blocked high priority thread waiting for I/O has a certain
response time before it is scheduled again. The device
driver writer can greatly reduce this response time by using
a &quot;slow interrupt&quot; interrupt handler.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous</b>
<br>
Child processes inherit the scheduling policy and parameters
across a <b>fork</b>(2). The scheduling policy and
parameters are preserved across <b>execve</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Memory locking
is usually needed for real-time processes to avoid paging
delays; this can be done with <b>mlock</b>(2) or
<b>mlockall</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
autogroup feature</b> <br>
Since Linux 2.6.38, the kernel provides a feature known as
autogrouping to improve interactive desktop performance in
the face of multiprocess, CPU-intensive workloads such as
building the Linux kernel with large numbers of parallel
build processes (i.e., the <b>make</b>(1) <b>-j</b>
flag).</p>

<p style="margin-left:11%; margin-top: 1em">This feature
operates in conjunction with the CFS scheduler and requires
a kernel that is configured with
<b>CONFIG_SCHED_AUTOGROUP</b>. On a running system, this
feature is enabled or disabled via the file
<i>/proc/sys/kernel/sched_autogroup_enabled</i>; a value of
0 disables the feature, while a value of 1 enables it. The
default value in this file is 1, unless the kernel was
booted with the <i>noautogroup</i> parameter.</p>

<p style="margin-left:11%; margin-top: 1em">A new autogroup
is created when a new session is created via
<b>setsid</b>(2); this happens, for example, when a new
terminal window is started. A new process created by
<b>fork</b>(2) inherits its parent&rsquo;s autogroup
membership. Thus, all of the processes in a session are
members of the same autogroup. An autogroup is automatically
destroyed when the last process in the group terminates.</p>

<p style="margin-left:11%; margin-top: 1em">When
autogrouping is enabled, all of the members of an autogroup
are placed in the same kernel scheduler &quot;task
group&quot;. The CFS scheduler employs an algorithm that
equalizes the distribution of CPU cycles across task groups.
The benefits of this for interactive desktop performance can
be described via the following example.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose that
there are two autogroups competing for the same CPU (i.e.,
presume either a single CPU system or the use of
<b>taskset</b>(1) to confine all the processes to the same
CPU on an SMP system). The first group contains ten
CPU-bound processes from a kernel build started with
<i>make&nbsp;-j10</i>. The other contains a single CPU-bound
process: a video player. The effect of autogrouping is that
the two groups will each receive half of the CPU cycles.
That is, the video player will receive 50% of the CPU
cycles, rather than just 9% of the cycles, which would
likely lead to degraded video playback. The situation on an
SMP system is more complex, but the general effect is the
same: the scheduler distributes CPU cycles across task
groups such that an autogroup that contains a large number
of CPU-bound processes does not end up hogging CPU cycles at
the expense of the other jobs on the system.</p>

<p style="margin-left:11%; margin-top: 1em">A
process&rsquo;s autogroup (task group) membership can be
viewed via the file <i>/proc/[pid]/autogroup</i>:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>cat
/proc/1/autogroup</b> <br>
/autogroup-1 nice 0</p>

<p style="margin-left:11%; margin-top: 1em">This file can
also be used to modify the CPU bandwidth allocated to an
autogroup. This is done by writing a number in the
&quot;nice&quot; range to the file to set the
autogroup&rsquo;s nice value. The allowed range is from +19
(low priority) to -20 (high priority). (Writing values
outside of this range causes <b>write</b>(2) to fail with
the error <b>EINVAL</b>.)</p>

<p style="margin-left:11%; margin-top: 1em">The autogroup
nice setting has the same meaning as the process nice value,
but applies to distribution of CPU cycles to the autogroup
as a whole, based on the relative nice values of other
autogroups. For a process inside an autogroup, the CPU
cycles that it receives will be a product of the
autogroup&rsquo;s nice value (compared to other autogroups)
and the process&rsquo;s nice value (compared to other
processes in the same autogroup.</p>

<p style="margin-left:11%; margin-top: 1em">The use of the
<b>cgroups</b>(7) CPU controller to place processes in
cgroups other than the root CPU cgroup overrides the effect
of autogrouping.</p>

<p style="margin-left:11%; margin-top: 1em">The autogroup
feature groups only processes scheduled under non-real-time
policies (<b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, and
<b>SCHED_IDLE</b>). It does not group processes scheduled
under real-time and deadline policies. Those processes are
scheduled according to the rules described earlier.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The nice
value and group scheduling</b> <br>
When scheduling non-real-time processes (i.e., those
scheduled under the <b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>,
and <b>SCHED_IDLE</b> policies), the CFS scheduler employs a
technique known as &quot;group scheduling&quot;, if the
kernel was configured with the
<b>CONFIG_FAIR_GROUP_SCHED</b> option (which is
typical).</p>

<p style="margin-left:11%; margin-top: 1em">Under group
scheduling, threads are scheduled in &quot;task
groups&quot;. Task groups have a hierarchical relationship,
rooted under the initial task group on the system, known as
the &quot;root task group&quot;. Task groups are formed in
the following circumstances:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>All of the threads in a CPU cgroup form a task group.
The parent of this task group is the task group of the
corresponding parent cgroup.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If autogrouping is enabled, then all of the threads that
are (implicitly) placed in an autogroup (i.e., the same
session, as created by <b>setsid</b>(2)) form a task group.
Each new autogroup is thus a separate task group. The root
task group is the parent of all such autogroups.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If autogrouping is enabled, then the root task group
consists of all processes in the root CPU cgroup that were
not otherwise implicitly placed into a new autogroup.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If autogrouping is disabled, then the root task group
consists of all processes in the root CPU cgroup.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If group scheduling was disabled (i.e., the kernel was
configured without <b>CONFIG_FAIR_GROUP_SCHED</b>), then all
of the processes on the system are notionally placed in a
single task group.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Under group
scheduling, a thread&rsquo;s nice value has an effect for
scheduling decisions <i>only relative to other threads in
the same task group</i>. This has some surprising
consequences in terms of the traditional semantics of the
nice value on UNIX systems. In particular, if autogrouping
is enabled (which is the default in various distributions),
then employing <b>setpriority</b>(2) or <b>nice</b>(1) on a
process has an effect only for scheduling relative to other
processes executed in the same session (typically: the same
terminal window).</p>

<p style="margin-left:11%; margin-top: 1em">Conversely, for
two processes that are (for example) the sole CPU-bound
processes in different sessions (e.g., different terminal
windows, each of whose jobs are tied to different
autogroups), <i>modifying the nice value of the process in
one of the sessions has no effect</i> in terms of the
scheduler&rsquo;s decisions relative to the process in the
other session. A possibly useful workaround here is to use a
command such as the following to modify the autogroup nice
value for <i>all</i> of the processes in a terminal
session:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>echo 10
&gt; /proc/self/autogroup</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Real-time
features in the mainline Linux kernel</b> <br>
Since kernel version 2.6.18, Linux is gradually becoming
equipped with real-time capabilities, most of which are
derived from the former <i>realtime-preempt</i> patch set.
Until the patches have been completely merged into the
mainline kernel, they must be installed to achieve the best
real-time performance. These patches are named:</p>


<p style="margin-left:17%; margin-top: 1em">patch-<i>kernelversion</i>-rt<i>patchversion</i></p>

<p style="margin-left:11%; margin-top: 1em">and can be
downloaded from
<a href="http://www.kernel.org/pub/linux/kernel/projects/rt/">http://www.kernel.org/pub/linux/kernel/projects/rt/</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Without the
patches and prior to their full inclusion into the mainline
kernel, the kernel configuration offers only the three
preemption classes <b>CONFIG_PREEMPT_NONE</b>,
<b>CONFIG_PREEMPT_VOLUNTARY</b>, and
<b>CONFIG_PREEMPT_DESKTOP</b> which respectively provide no,
some, and considerable reduction of the worst-case
scheduling latency.</p>

<p style="margin-left:11%; margin-top: 1em">With the
patches applied or after their full inclusion into the
mainline kernel, the additional configuration item
<b>CONFIG_PREEMPT_RT</b> becomes available. If this is
selected, Linux is transformed into a regular real-time
operating system. The FIFO and RR scheduling policies are
then used to run a thread with true real-time priority and a
minimum worst-case scheduling latency.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>cgroups</b>(7) CPU controller can be used to limit the
CPU consumption of groups of processes.</p>

<p style="margin-left:11%; margin-top: 1em">Originally,
Standard Linux was intended as a general-purpose operating
system being able to handle background processes,
interactive applications, and less demanding real-time
applications (applications that need to usually meet timing
deadlines). Although the Linux kernel 2.6 allowed for kernel
preemption and the newly introduced O(1) scheduler ensures
that the time needed to schedule is fixed and deterministic
irrespective of the number of active tasks, true real-time
computing was not possible up to kernel version 2.6.17.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>chcpu</b>(1),
<b>chrt</b>(1), <b>lscpu</b>(1), <b>ps</b>(1),
<b>taskset</b>(1), <b>top</b>(1), <b>getpriority</b>(2),
<b>mlock</b>(2), <b>mlockall</b>(2), <b>munlock</b>(2),
<b>munlockall</b>(2), <b>nice</b>(2),
<b>sched_get_priority_max</b>(2),
<b>sched_get_priority_min</b>(2),
<b>sched_getaffinity</b>(2), <b>sched_getparam</b>(2),
<b>sched_getscheduler</b>(2),
<b>sched_rr_get_interval</b>(2),
<b>sched_setaffinity</b>(2), <b>sched_setparam</b>(2),
<b>sched_setscheduler</b>(2), <b>sched_yield</b>(2),
<b>setpriority</b>(2), <b>pthread_getaffinity_np</b>(3),
<b>pthread_getschedparam</b>(3),
<b>pthread_setaffinity_np</b>(3), <b>sched_getcpu</b>(3),
<b>capabilities</b>(7), <b>cpuset</b>(7)</p>

<p style="margin-left:11%; margin-top: 1em"><i>Programming
for the real world - POSIX.4</i> by Bill O. Gallmeister,
O&rsquo;Reilly &amp; Associates, Inc., ISBN
1-56592-074-0.</p>

<p style="margin-left:11%; margin-top: 1em">The Linux
kernel source files
<i>Documentation/scheduler/sched-deadline.txt</i>,
<i>Documentation/scheduler/sched-rt-group.txt</i>,
<i>Documentation/scheduler/sched-design-CFS.txt</i>, and
<i>Documentation/scheduler/sched-nice-design.txt</i></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
