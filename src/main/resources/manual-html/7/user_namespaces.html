<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:44 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>USER_NAMESPACES</title>

</head>
<body>

<h1 align="center">USER_NAMESPACES</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">user_namespaces
- overview of Linux user namespaces</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For an overview
of namespaces, see <a href="https://man.page/7/namespaces">namespaces(7)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">User namespaces
isolate security-related identifiers and attributes, in
particular, user IDs and group IDs (see
<a href="https://man.page/7/credentials">credentials(7)</a>), the root directory, keys (see
<a href="https://man.page/7/keyrings">keyrings(7)</a>), and capabilities (see
<a href="https://man.page/7/capabilities">capabilities(7)</a>). A process&rsquo;s user and group
IDs can be different inside and outside a user namespace. In
particular, a process can have a normal unprivileged user ID
outside a user namespace while at the same time having a
user ID of 0 inside the namespace; in other words, the
process has full privileges for operations inside the user
namespace, but is unprivileged for operations outside the
namespace.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Nested
namespaces, namespace membership</b> <br>
User namespaces can be nested; that is, each user
namespace&mdash;except the initial (&quot;root&quot;)
namespace&mdash;has a parent user namespace, and can have
zero or more child user namespaces. The parent user
namespace is the user namespace of the process that creates
the user namespace via a call to <a href="https://man.page/2/unshare">unshare(2)</a> or
<a href="https://man.page/2/clone">clone(2)</a> with the <b>CLONE_NEWUSER</b> flag.</p>

<p style="margin-left:11%; margin-top: 1em">The kernel
imposes (since version 3.11) a limit of 32 nested levels of
user namespaces. Calls to <a href="https://man.page/2/unshare">unshare(2)</a> or
<a href="https://man.page/2/clone">clone(2)</a> that would cause this limit to be exceeded
fail with the error <b>EUSERS</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Each process is
a member of exactly one user namespace. A process created
via <a href="https://man.page/2/fork">fork(2)</a> or <a href="https://man.page/2/clone">clone(2)</a> without the
<b>CLONE_NEWUSER</b> flag is a member of the same user
namespace as its parent. A single-threaded process can join
another user namespace with <a href="https://man.page/2/setns">setns(2)</a> if it has the
<b>CAP_SYS_ADMIN</b> in that namespace; upon doing so, it
gains a full set of capabilities in that namespace.</p>

<p style="margin-left:11%; margin-top: 1em">A call to
<a href="https://man.page/2/clone">clone(2)</a> or <a href="https://man.page/2/unshare">unshare(2)</a> with the
<b>CLONE_NEWUSER</b> flag makes the new child process (for
<a href="https://man.page/2/clone">clone(2)</a>) or the caller (for <a href="https://man.page/2/unshare">unshare(2)</a>) a
member of the new user namespace created by the call.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>NS_GET_PARENT ioctl</b>(2) operation can be used to
discover the parental relationship between user namespaces;
see <a href="https://man.page/2/ioctl_ns">ioctl_ns(2)</a>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Capabilities</b>
<br>
The child process created by <a href="https://man.page/2/clone">clone(2)</a> with the
<b>CLONE_NEWUSER</b> flag starts out with a complete set of
capabilities in the new user namespace. Likewise, a process
that creates a new user namespace using <a href="https://man.page/2/unshare">unshare(2)</a> or
joins an existing user namespace using <a href="https://man.page/2/setns">setns(2)</a> gains
a full set of capabilities in that namespace. On the other
hand, that process has no capabilities in the parent (in the
case of <a href="https://man.page/2/clone">clone(2)</a>) or previous (in the case of
<a href="https://man.page/2/unshare">unshare(2)</a> and <a href="https://man.page/2/setns">setns(2)</a>) user namespace, even
if the new namespace is created or joined by the root user
(i.e., a process with user ID 0 in the root namespace).</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
call to <a href="https://man.page/2/execve">execve(2)</a> will cause a process&rsquo;s
capabilities to be recalculated in the usual way (see
<a href="https://man.page/7/capabilities">capabilities(7)</a>). Consequently, unless the process
has a user ID of 0 within the namespace, or the executable
file has a nonempty inheritable capabilities mask, the
process will lose all capabilities. See the discussion of
user and group ID mappings, below.</p>

<p style="margin-left:11%; margin-top: 1em">A call to
<a href="https://man.page/2/clone">clone(2)</a> or <a href="https://man.page/2/unshare">unshare(2)</a> using the
<b>CLONE_NEWUSER</b> flag or a call to <a href="https://man.page/2/setns">setns(2)</a> that
moves the caller into another user namespace sets the
&quot;securebits&quot; flags (see <a href="https://man.page/7/capabilities">capabilities(7)</a>) to
their default values (all flags disabled) in the child (for
<a href="https://man.page/2/clone">clone(2)</a>) or caller (for <a href="https://man.page/2/unshare">unshare(2)</a> or
<a href="https://man.page/2/setns">setns(2)</a>). Note that because the caller no longer has
capabilities in its original user namespace after a call to
<a href="https://man.page/2/setns">setns(2)</a>, it is not possible for a process to reset
its &quot;securebits&quot; flags while retaining its user
namespace membership by using a pair of <a href="https://man.page/2/setns">setns(2)</a>
calls to move to another user namespace and then return to
its original user namespace.</p>

<p style="margin-left:11%; margin-top: 1em">The rules for
determining whether or not a process has a capability in a
particular user namespace are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>A process has a capability inside a user namespace if it
is a member of that namespace and it has the capability in
its effective capability set. A process can gain
capabilities in its effective capability set in various
ways. For example, it may execute a set-user-ID program or
an executable with associated file capabilities. In
addition, a process may gain capabilities via the effect of
<a href="https://man.page/2/clone">clone(2)</a>, <a href="https://man.page/2/unshare">unshare(2)</a>, or <a href="https://man.page/2/setns">setns(2)</a>, as
already described.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If a process has a capability in a user namespace, then
it has that capability in all child (and further removed
descendant) namespaces as well.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>When a user namespace is created, the kernel records the
effective user ID of the creating process as being the
&quot;owner&quot; of the namespace. A process that resides
in the parent of the user namespace and whose effective user
ID matches the owner of the namespace has all capabilities
in the namespace. By virtue of the previous rule, this means
that the process has all capabilities in all further removed
descendant user namespaces as well. The <b>NS_GET_OWNER_UID
ioctl</b>(2) operation can be used to discover the user ID
of the owner of the namespace; see <a href="https://man.page/2/ioctl_ns">ioctl_ns(2)</a>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Effect of
capabilities within a user namespace</b> <br>
Having a capability inside a user namespace permits a
process to perform operations (that require privilege) only
on resources governed by that namespace. In other words,
having a capability in a user namespace permits a process to
perform privileged operations on resources that are governed
by (nonuser) namespaces owned by (associated with) the user
namespace (see the next subsection).</p>

<p style="margin-left:11%; margin-top: 1em">On the other
hand, there are many privileged operations that affect
resources that are not associated with any namespace type,
for example, changing the system (i.e., calendar) time
(governed by <b>CAP_SYS_TIME</b>), loading a kernel module
(governed by <b>CAP_SYS_MODULE</b>), and creating a device
(governed by <b>CAP_MKNOD</b>). Only a process with
privileges in the <i>initial</i> user namespace can perform
such operations.</p>

<p style="margin-left:11%; margin-top: 1em">Holding
<b>CAP_SYS_ADMIN</b> within the user namespace that owns a
process&rsquo;s mount namespace allows that process to
create bind mounts and mount the following types of
filesystems:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><i>/proc</i> (since Linux
3.8)</p> </td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>/sys</i> (since Linux 3.8)</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>devpts</i> (since Linux 3.9)</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="40%">


<p><a href="https://man.page/5/tmpfs">tmpfs(5)</a> (since Linux 3.9)</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>ramfs</i> (since Linux 3.9)</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>mqueue</i> (since Linux 3.9)</p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>bpf</i> (since Linux 4.4)</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Holding
<b>CAP_SYS_ADMIN</b> within the user namespace that owns a
process&rsquo;s cgroup namespace allows (since Linux 4.6)
that process to the mount the cgroup version 2 filesystem
and cgroup version 1 named hierarchies (i.e., cgroup
filesystems mounted with the <i>&quot;none,name=&quot;</i>
option).</p>

<p style="margin-left:11%; margin-top: 1em">Holding
<b>CAP_SYS_ADMIN</b> within the user namespace that owns a
process&rsquo;s PID namespace allows (since Linux 3.8) that
process to mount <i>/proc</i> filesystems.</p>

<p style="margin-left:11%; margin-top: 1em">Note however,
that mounting block-based filesystems can be done only by a
process that holds <b>CAP_SYS_ADMIN</b> in the initial user
namespace.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Interaction
of user namespaces and other types of namespaces</b> <br>
Starting in Linux 3.8, unprivileged processes can create
user namespaces, and the other types of namespaces can be
created with just the <b>CAP_SYS_ADMIN</b> capability in the
caller&rsquo;s user namespace.</p>

<p style="margin-left:11%; margin-top: 1em">When a nonuser
namespace is created, it is owned by the user namespace in
which the creating process was a member at the time of the
creation of the namespace. Privileged operations on
resources governed by the nonuser namespace require that the
process has the necessary capabilities in the user namespace
that owns the nonuser namespace.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>CLONE_NEWUSER</b> is specified along with other
<b>CLONE_NEW*</b> flags in a single <a href="https://man.page/2/clone">clone(2)</a> or
<a href="https://man.page/2/unshare">unshare(2)</a> call, the user namespace is guaranteed to
be created first, giving the child (<a href="https://man.page/2/clone">clone(2)</a>) or
caller (<a href="https://man.page/2/unshare">unshare(2)</a>) privileges over the remaining
namespaces created by the call. Thus, it is possible for an
unprivileged caller to specify this combination of
flags.</p>

<p style="margin-left:11%; margin-top: 1em">When a new
namespace (other than a user namespace) is created via
<a href="https://man.page/2/clone">clone(2)</a> or <a href="https://man.page/2/unshare">unshare(2)</a>, the kernel records the
user namespace of the creating process as the owner of the
new namespace. (This association can&rsquo;t be changed.)
When a process in the new namespace subsequently performs
privileged operations that operate on global resources
isolated by the namespace, the permission checks are
performed according to the process&rsquo;s capabilities in
the user namespace that the kernel associated with the new
namespace. For example, suppose that a process attempts to
change the hostname (<a href="https://man.page/2/sethostname">sethostname(2)</a>), a resource
governed by the UTS namespace. In this case, the kernel will
determine which user namespace owns the process&rsquo;s UTS
namespace, and check whether the process has the required
capability (<b>CAP_SYS_ADMIN</b>) in that user
namespace.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>NS_GET_USERNS ioctl</b>(2) operation can be used to
discover the user namespace that owns a nonuser namespace;
see <a href="https://man.page/2/ioctl_ns">ioctl_ns(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>User and
group ID mappings: uid_map and gid_map</b> <br>
When a user namespace is created, it starts out without a
mapping of user IDs (group IDs) to the parent user
namespace. The <i>/proc/[pid]/uid_map</i> and
<i>/proc/[pid]/gid_map</i> files (available since Linux 3.5)
expose the mappings for user and group IDs inside the user
namespace for the process <i>pid</i>. These files can be
read to view the mappings in a user namespace and written to
(once) to define the mappings.</p>

<p style="margin-left:11%; margin-top: 1em">The description
in the following paragraphs explains the details for
<i>uid_map</i>; <i>gid_map</i> is exactly the same, but each
instance of &quot;user ID&quot; is replaced by &quot;group
ID&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>uid_map</i> file exposes the mapping of user IDs from the
user namespace of the process <i>pid</i> to the user
namespace of the process that opened <i>uid_map</i> (but see
a qualification to this point below). In other words,
processes that are in different user namespaces will
potentially see different values when reading from a
particular <i>uid_map</i> file, depending on the user ID
mappings for the user namespaces of the reading
processes.</p>

<p style="margin-left:11%; margin-top: 1em">Each line in
the <i>uid_map</i> file specifies a 1-to-1 mapping of a
range of contiguous user IDs between two user namespaces.
(When a user namespace is first created, this file is
empty.) The specification in each line takes the form of
three numbers delimited by white space. The first two
numbers specify the starting user ID in each of the two user
namespaces. The third number specifies the length of the
mapped range. In detail, the fields are interpreted as
follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">(1)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The start of the range of user
IDs in the user namespace of the process <i>pid</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(2)</p></td>
<td width="2%"></td>
<td width="83%">


<p>The start of the range of user IDs to which the user IDs
specified by field one map. How field two is interpreted
depends on whether the process that opened <i>uid_map</i>
and the process <i>pid</i> are in the same user namespace,
as follows:</p></td></tr>
</table>

<p style="margin-left:17%;">a)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">If the two processes are in
different user namespaces: field two is the start of a range
of user IDs in the user namespace of the process that opened
<i>uid_map</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>b)</p></td>
<td width="2%"></td>
<td width="78%">


<p>If the two processes are in the same user namespace:
field two is the start of the range of user IDs in the
parent user namespace of the process <i>pid</i>. This case
enables the opener of <i>uid_map</i> (the common case here
is opening <i>/proc/self/uid_map</i>) to see the mapping of
user IDs into the user namespace of the process that created
this user namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>(3)</p></td>
<td width="2%"></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The length of
the range of user IDs that is mapped between the two user
namespaces.</p>

<p style="margin-left:11%; margin-top: 1em">System calls
that return user IDs (group IDs)&mdash;for example,
<a href="https://man.page/2/getuid">getuid(2)</a>, <a href="https://man.page/2/getgid">getgid(2)</a>, and the credential
fields in the structure returned by
<a href="https://man.page/2/stat">stat(2)</a>&mdash;return the user ID (group ID) mapped
into the caller&rsquo;s user namespace.</p>

<p style="margin-left:11%; margin-top: 1em">When a process
accesses a file, its user and group IDs are mapped into the
initial user namespace for the purpose of permission
checking and assigning IDs when creating a file. When a
process retrieves file user and group IDs via
<a href="https://man.page/2/stat">stat(2)</a>, the IDs are mapped in the opposite
direction, to produce values relative to the process user
and group ID mappings.</p>

<p style="margin-left:11%; margin-top: 1em">The initial
user namespace has no parent namespace, but, for
consistency, the kernel provides dummy user and group ID
mapping files for this namespace. Looking at the
<i>uid_map</i> file (<i>gid_map</i> is the same) from a
shell in the initial namespace shows:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>cat
/proc/$$/uid_map</b> <br>
0 0 4294967295</p>

<p style="margin-left:11%; margin-top: 1em">This mapping
tells us that the range starting at user ID 0 in this
namespace maps to a range starting at 0 in the (nonexistent)
parent namespace, and the length of the range is the largest
32-bit unsigned integer. This leaves 4294967295 (the 32-bit
signed -1 value) unmapped. This is deliberate:
<i>(uid_t)&nbsp;-1</i> is used in several interfaces (e.g.,
<a href="https://man.page/2/setreuid">setreuid(2)</a>) as a way to specify &quot;no user
ID&quot;. Leaving <i>(uid_t)&nbsp;-1</i> unmapped and
unusable guarantees that there will be no confusion when
using these interfaces.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Defining
user and group ID mappings: writing to uid_map and
gid_map</b> <br>
After the creation of a new user namespace, the
<i>uid_map</i> file of <i>one</i> of the processes in the
namespace may be written to <i>once</i> to define the
mapping of user IDs in the new user namespace. An attempt to
write more than once to a <i>uid_map</i> file in a user
namespace fails with the error <b>EPERM</b>. Similar rules
apply for <i>gid_map</i> files.</p>

<p style="margin-left:11%; margin-top: 1em">The lines
written to <i>uid_map</i> (<i>gid_map</i>) must conform to
the following rules:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The three fields must be valid
numbers, and the last field must be greater than 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Lines are terminated by newline characters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>There is a limit on the number of lines in the file. In
Linux 4.14 and earlier, this limit was (arbitrarily) set at
5 lines. Since Linux 4.15, the limit is 340 lines. In
addition, the number of bytes written to the file must be
less than the system page size, and the write must be
performed at the start of the file (i.e., <a href="https://man.page/2/lseek">lseek(2)</a>
and <a href="https://man.page/2/pwrite">pwrite(2)</a> can&rsquo;t be used to write to nonzero
offsets in the file).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The range of user IDs (group IDs) specified in each line
cannot overlap with the ranges in any other lines. In the
initial implementation (Linux 3.8), this requirement was
satisfied by a simplistic implementation that imposed the
further requirement that the values in both field 1 and
field 2 of successive lines must be in ascending numerical
order, which prevented some otherwise valid maps from being
created. Linux 3.9 and later fix this limitation, allowing
any valid set of nonoverlapping maps.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>At least one line must be written to the file.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Writes that
violate the above rules fail with the error
<b>EINVAL</b>.</p>

<p style="margin-left:11%; margin-top: 1em">In order for a
process to write to the <i>/proc/[pid]/uid_map</i>
(<i>/proc/[pid]/gid_map</i>) file, all of the following
requirements must be met:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">The writing process must have
the <b>CAP_SETUID</b> (<b>CAP_SETGID</b>) capability in the
user namespace of the process <i>pid</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The writing process must either be in the user namespace
of the process <i>pid</i> or be in the parent user namespace
of the process <i>pid</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The mapped user IDs (group IDs) must in turn have a
mapping in the parent user namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="85%">


<p>One of the following two cases applies:</p></td></tr>
</table>

<p style="margin-left:15%;">*</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="80%">


<p style="margin-top: 1em"><i>Either</i> the writing
process has the <b>CAP_SETUID</b> (<b>CAP_SETGID</b>)
capability in the <i>parent</i> user namespace.</p></td></tr>
</table>

<p style="margin-left:20%;">+</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%"></td>
<td width="3%"></td>
<td width="80%">


<p style="margin-top: 1em">No further restrictions apply:
the process can make mappings to arbitrary user IDs (group
IDs) in the parent user namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>*</p></td>
<td width="3%"></td>
<td width="80%">


<p><i>Or</i> otherwise all of the following restrictions
apply:</p> </td></tr>
</table>

<p style="margin-left:20%;">+</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%"></td>
<td width="3%"></td>
<td width="75%">


<p style="margin-top: 1em">The data written to
<i>uid_map</i> (<i>gid_map</i>) must consist of a single
line that maps the writing process&rsquo;s effective user ID
(group ID) in the parent user namespace to a user ID (group
ID) in the user namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>+</p></td>
<td width="3%"></td>
<td width="75%">


<p>The writing process must have the same effective user ID
as the process that created the user namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>+</p></td>
<td width="3%"></td>
<td width="75%">


<p>In the case of <i>gid_map</i>, use of the
<a href="https://man.page/2/setgroups">setgroups(2)</a> system call must first be denied by
writing &quot;<i>deny</i>&quot; to the
<i>/proc/[pid]/setgroups</i> file (see below) before writing
to <i>gid_map</i>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Writes that
violate the above rules fail with the error
<b>EPERM</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Interaction
with system calls that change process UIDs or GIDs</b> <br>
In a user namespace where the <i>uid_map</i> file has not
been written, the system calls that change user IDs will
fail. Similarly, if the <i>gid_map</i> file has not been
written, the system calls that change group IDs will fail.
After the <i>uid_map</i> and <i>gid_map</i> files have been
written, only the mapped values may be used in system calls
that change user and group IDs.</p>

<p style="margin-left:11%; margin-top: 1em">For user IDs,
the relevant system calls include <a href="https://man.page/2/setuid">setuid(2)</a>,
<a href="https://man.page/2/setfsuid">setfsuid(2)</a>, <a href="https://man.page/2/setreuid">setreuid(2)</a>, and
<a href="https://man.page/2/setresuid">setresuid(2)</a>. For group IDs, the relevant system
calls include <a href="https://man.page/2/setgid">setgid(2)</a>, <a href="https://man.page/2/setfsgid">setfsgid(2)</a>,
<a href="https://man.page/2/setregid">setregid(2)</a>, <a href="https://man.page/2/setresgid">setresgid(2)</a>, and
<a href="https://man.page/2/setgroups">setgroups(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Writing
&quot;<i>deny</i>&quot; to the <i>/proc/[pid]/setgroups</i>
file before writing to <i>/proc/[pid]/gid_map</i> will
permanently disable <a href="https://man.page/2/setgroups">setgroups(2)</a> in a user namespace
and allow writing to <i>/proc/[pid]/gid_map</i> without
having the <b>CAP_SETGID</b> capability in the parent user
namespace.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
/proc/[pid]/setgroups file</b> <br>
The <i>/proc/[pid]/setgroups</i> file displays the string
&quot;<i>allow</i>&quot; if processes in the user namespace
that contains the process <i>pid</i> are permitted to employ
the <a href="https://man.page/2/setgroups">setgroups(2)</a> system call; it displays
&quot;<i>deny</i>&quot; if <a href="https://man.page/2/setgroups">setgroups(2)</a> is not
permitted in that user namespace. Note that regardless of
the value in the <i>/proc/[pid]/setgroups</i> file (and
regardless of the process&rsquo;s capabilities), calls to
<a href="https://man.page/2/setgroups">setgroups(2)</a> are also not permitted if
<i>/proc/[pid]/gid_map</i> has not yet been set.</p>

<p style="margin-left:11%; margin-top: 1em">A privileged
process (one with the <b>CAP_SYS_ADMIN</b> capability in the
namespace) may write either of the strings
&quot;<i>allow</i>&quot; or &quot;<i>deny</i>&quot; to this
file <i>before</i> writing a group ID mapping for this user
namespace to the file <i>/proc/[pid]/gid_map</i>. Writing
the string &quot;<i>deny</i>&quot; prevents any process in
the user namespace from employing <a href="https://man.page/2/setgroups">setgroups(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The essence of
the restrictions described in the preceding paragraph is
that it is permitted to write to
<i>/proc/[pid]/setgroups</i> only so long as calling
<a href="https://man.page/2/setgroups">setgroups(2)</a> is disallowed because
<i>/proc/[pid]/gid_map</i> has not been set. This ensures
that a process cannot transition from a state where
<a href="https://man.page/2/setgroups">setgroups(2)</a> is allowed to a state where
<a href="https://man.page/2/setgroups">setgroups(2)</a> is denied; a process can transition only
from <a href="https://man.page/2/setgroups">setgroups(2)</a> being disallowed to
<a href="https://man.page/2/setgroups">setgroups(2)</a> being allowed.</p>

<p style="margin-left:11%; margin-top: 1em">The default
value of this file in the initial user namespace is
&quot;<i>allow</i>&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Once
<i>/proc/[pid]/gid_map</i> has been written to (which has
the effect of enabling <a href="https://man.page/2/setgroups">setgroups(2)</a> in the user
namespace), it is no longer possible to disallow
<a href="https://man.page/2/setgroups">setgroups(2)</a> by writing &quot;<i>deny</i>&quot; to
<i>/proc/[pid]/setgroups</i> (the write fails with the error
<b>EPERM</b>).</p>

<p style="margin-left:11%; margin-top: 1em">A child user
namespace inherits the <i>/proc/[pid]/setgroups</i> setting
from its parent.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>setgroups</i> file has the value &quot;<i>deny</i>&quot;,
then the <a href="https://man.page/2/setgroups">setgroups(2)</a> system call can&rsquo;t
subsequently be reenabled (by writing
&quot;<i>allow</i>&quot; to the file) in this user
namespace. (Attempts to do so fail with the error
<b>EPERM</b>.) This restriction also propagates down to all
child user namespaces of this user namespace.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>/proc/[pid]/setgroups</i> file was added in Linux 3.19,
but was backported to many earlier stable kernel series,
because it addresses a security issue. The issue concerned
files with permissions such as &quot;rwx---rwx&quot;. Such
files give fewer permissions to &quot;group&quot; than they
do to &quot;other&quot;. This means that dropping groups
using <a href="https://man.page/2/setgroups">setgroups(2)</a> might allow a process file access
that it did not formerly have. Before the existence of user
namespaces this was not a concern, since only a privileged
process (one with the <b>CAP_SETGID</b> capability) could
call <a href="https://man.page/2/setgroups">setgroups(2)</a>. However, with the introduction of
user namespaces, it became possible for an unprivileged
process to create a new namespace in which the user had all
privileges. This then allowed formerly unprivileged users to
drop groups and thus gain file access that they did not
previously have. The <i>/proc/[pid]/setgroups</i> file was
added to address this security issue, by denying any pathway
for an unprivileged process to drop groups with
<a href="https://man.page/2/setgroups">setgroups(2)</a>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unmapped
user and group IDs</b> <br>
There are various places where an unmapped user ID (group
ID) may be exposed to user space. For example, the first
process in a new user namespace may call <a href="https://man.page/2/getuid">getuid(2)</a>
before a user ID mapping has been defined for the namespace.
In most such cases, an unmapped user ID is converted to the
overflow user ID (group ID); the default value for the
overflow user ID (group ID) is 65534. See the descriptions
of <i>/proc/sys/kernel/overflowuid</i> and
<i>/proc/sys/kernel/overflowgid</i> in <a href="https://man.page/5/proc">proc(5)</a>.</p>

<p style="margin-left:11%; margin-top: 1em">The cases where
unmapped IDs are mapped in this fashion include system calls
that return user IDs (<a href="https://man.page/2/getuid">getuid(2)</a>, <a href="https://man.page/2/getgid">getgid(2)</a>,
and similar), credentials passed over a UNIX domain socket,
credentials returned by <a href="https://man.page/2/stat">stat(2)</a>, <a href="https://man.page/2/waitid">waitid(2)</a>,
and the System V IPC &quot;ctl&quot; <b>IPC_STAT</b>
operations, credentials exposed by <i>/proc/[pid]/status</i>
and the files in <i>/proc/sysvipc/*</i>, credentials
returned via the <i>si_uid</i> field in the <i>siginfo_t</i>
received with a signal (see <a href="https://man.page/2/sigaction">sigaction(2)</a>),
credentials written to the process accounting file (see
<a href="https://man.page/5/acct">acct(5)</a>), and credentials returned with POSIX message
queue notifications (see <a href="https://man.page/3/mq_notify">mq_notify(3)</a>).</p>

<p style="margin-left:11%; margin-top: 1em">There is one
notable case where unmapped user and group IDs are
<i>not</i> converted to the corresponding overflow ID value.
When viewing a <i>uid_map</i> or <i>gid_map</i> file in
which there is no mapping for the second field, that field
is displayed as 4294967295 (-1 as an unsigned integer).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Accessing
files</b> <br>
In order to determine permissions when an unprivileged
process accesses a file, the process credentials (UID, GID)
and the file credentials are in effect mapped back to what
they would be in the initial user namespace and then
compared to determine the permissions that the process has
on the file. The same is also of other objects that employ
the credentials plus permissions mask accessibility model,
such as System V IPC objects</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operation of
file-related capabilities</b> <br>
Certain capabilities allow a process to bypass various
kernel-enforced restrictions when performing operations on
files owned by other users or groups. These capabilities
are: <b>CAP_CHOWN</b>, <b>CAP_DAC_OVERRIDE</b>,
<b>CAP_DAC_READ_SEARCH</b>, <b>CAP_FOWNER</b>, and
<b>CAP_FSETID</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Within a user
namespace, these capabilities allow a process to bypass the
rules if the process has the relevant capability over the
file, meaning that:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">the process has the relevant
effective capability in its user namespace; and</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>the file&rsquo;s user ID and group ID both have valid
mappings in the user namespace.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<b>CAP_FOWNER</b> capability is treated somewhat
exceptionally: it allows a process to bypass the
corresponding rules so long as at least the file&rsquo;s
user ID has a mapping in the user namespace (i.e., the
file&rsquo;s group ID does not need to have a valid
mapping).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Set-user-ID
and set-group-ID programs</b> <br>
When a process inside a user namespace executes a
set-user-ID (set-group-ID) program, the process&rsquo;s
effective user (group) ID inside the namespace is changed to
whatever value is mapped for the user (group) ID of the
file. However, if either the user <i>or</i> the group ID of
the file has no mapping inside the namespace, the
set-user-ID (set-group-ID) bit is silently ignored: the new
program is executed, but the process&rsquo;s effective user
(group) ID is left unchanged. (This mirrors the semantics of
executing a set-user-ID or set-group-ID program that resides
on a filesystem that was mounted with the <b>MS_NOSUID</b>
flag, as described in <a href="https://man.page/2/mount">mount(2)</a>.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous</b>
<br>
When a process&rsquo;s user and group IDs are passed over a
UNIX domain socket to a process in a different user
namespace (see the description of <b>SCM_CREDENTIALS</b> in
<a href="https://man.page/7/unix">unix(7)</a>), they are translated into the corresponding
values as per the receiving process&rsquo;s user and group
ID mappings.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Namespaces are
a Linux-specific feature.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Over the years,
there have been a lot of features that have been added to
the Linux kernel that have been made available only to
privileged users because of their potential to confuse
set-user-ID-root applications. In general, it becomes safe
to allow the root user in a user namespace to use those
features because it is impossible, while in a user
namespace, to gain more privilege than the root user of a
user namespace has.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Availability</b>
<br>
Use of user namespaces requires a kernel that is configured
with the <b>CONFIG_USER_NS</b> option. User namespaces
require support in a range of subsystems across the kernel.
When an unsupported subsystem is configured into the kernel,
it is not possible to configure user namespaces support.</p>

<p style="margin-left:11%; margin-top: 1em">As at Linux
3.8, most relevant subsystems supported user namespaces, but
a number of filesystems did not have the infrastructure
needed to map user and group IDs between user namespaces.
Linux 3.9 added the required infrastructure support for many
of the remaining unsupported filesystems (Plan 9 (9P),
Andrew File System (AFS), Ceph, CIFS, CODA, NFS, and OCFS2).
Linux 3.12 added support for the last of the unsupported
major filesystems, XFS.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The program
below is designed to allow experimenting with user
namespaces, as well as other types of namespaces. It creates
namespaces as specified by command-line options and then
executes a command inside those namespaces. The comments and
<i>usage()</i> function inside the program provide a full
explanation of the program. The following shell session
demonstrates its use.</p>

<p style="margin-left:11%; margin-top: 1em">First, we look
at the run-time environment:</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>uname
-rs</b> # Need Linux 3.8 or later <br>
Linux 3.8.0 <br>
$ <b>id -u</b> # Running as unprivileged user <br>
1000 <br>
$ <b>id -g</b> <br>
1000</p>

<p style="margin-left:11%; margin-top: 1em">Now start a new
shell in new user (<i>-U</i>), mount (<i>-m</i>), and PID
(<i>-p</i>) namespaces, with user ID (<i>-M</i>) and group
ID (<i>-G</i>) 1000 mapped to 0 inside the user
namespace:</p>

<p style="margin-left:17%; margin-top: 1em">$
<b>./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1'
bash</b></p>

<p style="margin-left:11%; margin-top: 1em">The shell has
PID 1, because it is the first process in the new PID
namespace:</p>

<p style="margin-left:17%; margin-top: 1em">bash$ <b>echo
$$</b> <br>
1</p>

<p style="margin-left:11%; margin-top: 1em">Mounting a new
<i>/proc</i> filesystem and listing all of the processes
visible in the new PID namespace shows that the shell
can&rsquo;t see any processes outside the PID namespace:</p>

<p style="margin-left:17%; margin-top: 1em">bash$ <b>mount
-t proc proc /proc</b> <br>
bash$ <b>ps ax</b> <br>
PID TTY STAT TIME COMMAND <br>
1 pts/3 S 0:00 bash <br>
22 pts/3 R+ 0:00 ps ax</p>

<p style="margin-left:11%; margin-top: 1em">Inside the user
namespace, the shell has user and group ID 0, and a full set
of permitted and effective capabilities:</p>

<p style="margin-left:17%; margin-top: 1em">bash$ <b>cat
/proc/$$/status | egrep '^[UG]id'</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%">


<p>Uid:</p></td>
<td width="8%">


<p>0</p></td>
<td width="7%">


<p>0</p></td>
<td width="62%">


<p>0</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">


<p>0</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%">


<p>Gid:</p></td>
<td width="8%">


<p>0</p></td>
<td width="7%">


<p>0</p></td>
<td width="62%">


<p>0</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">


<p>0</p></td></tr>
</table>

<p style="margin-left:17%;">bash$ <b>cat /proc/$$/status |
egrep '^Cap(Prm|Inh|Eff)'</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%">


<p>CapInh:</p></td>
<td width="77%">


<p>0000000000000000</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%">


<p>CapPrm:</p></td>
<td width="77%">


<p>0000001fffffffff</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%">


<p>CapEff:</p></td>
<td width="77%">


<p>0000001fffffffff</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
/* userns_child_exec.c</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
GNU General Public License v2 or later</p>

<p style="margin-left:11%; margin-top: 1em">Create a child
process that executes a shell command in new <br>
namespace(s); allow UID and GID mappings to be specified
when <br>
creating a user namespace. <br>
*/ <br>
#define _GNU_SOURCE <br>
#include &lt;sched.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;stdint.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;sys/wait.h&gt; <br>
#include &lt;signal.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;limits.h&gt; <br>
#include &lt;errno.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">/* A simple
error-handling function: print an error message based <br>
on the value in 'errno' and terminate the calling process
*/</p>

<p style="margin-left:11%; margin-top: 1em">#define
errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \ <br>
} while (0)</p>

<p style="margin-left:11%; margin-top: 1em">struct
child_args { <br>
char **argv; /* Command to be executed by child, with args
*/ <br>
int pipe_fd[2]; /* Pipe used to synchronize parent and child
*/ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">static int
verbose;</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
usage(char *pname) <br>
{ <br>
fprintf(stderr, &quot;Usage: %s [options] cmd
[arg...]\n\n&quot;, pname); <br>
fprintf(stderr, &quot;Create a child process that executes a
shell &quot; <br>
&quot;command in a new user namespace,\n&quot; <br>
&quot;and possibly also other new namespace(s).\n\n&quot;);
<br>
fprintf(stderr, &quot;Options can be:\n\n&quot;); <br>
#define fpe(str) fprintf(stderr, &quot; %s&quot;, str); <br>
fpe(&quot;-i New IPC namespace\n&quot;); <br>
fpe(&quot;-m New mount namespace\n&quot;); <br>
fpe(&quot;-n New network namespace\n&quot;); <br>
fpe(&quot;-p New PID namespace\n&quot;); <br>
fpe(&quot;-u New UTS namespace\n&quot;); <br>
fpe(&quot;-U New user namespace\n&quot;); <br>
fpe(&quot;-M uid_map Specify UID map for user
namespace\n&quot;); <br>
fpe(&quot;-G gid_map Specify GID map for user
namespace\n&quot;); <br>
fpe(&quot;-z Map user's UID and GID to 0 in user
namespace\n&quot;); <br>
fpe(&quot; (equivalent to: -M '0 &lt;uid&gt; 1' -G '0
&lt;gid&gt; 1')\n&quot;); <br>
fpe(&quot;-v Display verbose messages\n&quot;); <br>
fpe(&quot;\n&quot;); <br>
fpe(&quot;If -z, -M, or -G is specified, -U is
required.\n&quot;); <br>
fpe(&quot;It is not permitted to specify both -z and either
-M or -G.\n&quot;); <br>
fpe(&quot;\n&quot;); <br>
fpe(&quot;Map strings for -M and -G consist of records of
the form:\n&quot;); <br>
fpe(&quot;\n&quot;); <br>
fpe(&quot; ID-inside-ns ID-outside-ns len\n&quot;); <br>
fpe(&quot;\n&quot;); <br>
fpe(&quot;A map string can contain multiple records,
separated&quot; <br>
&quot; by commas;\n&quot;); <br>
fpe(&quot;the commas are replaced by newlines before
writing&quot; <br>
&quot; to map files.\n&quot;);</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_FAILURE);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Update the
mapping file 'map_file', with the value provided in <br>
'mapping', a string that defines a UID or GID mapping. A UID
or <br>
GID mapping consists of one or more newline-delimited
records <br>
of the form:</p>

<p style="margin-left:11%; margin-top: 1em">ID_inside-ns
ID-outside-ns length</p>

<p style="margin-left:11%; margin-top: 1em">Requiring the
user to supply a string that contains newlines is <br>
of course inconvenient for command-line use. Thus, we permit
the <br>
use of commas to delimit records in this string, and replace
them <br>
with newlines before writing the string to the file. */</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
update_map(char *mapping, char *map_file) <br>
{ <br>
int fd; <br>
size_t map_len; /* Length of 'mapping' */</p>

<p style="margin-left:11%; margin-top: 1em">/* Replace
commas in mapping string with newlines */</p>

<p style="margin-left:11%; margin-top: 1em">map_len =
strlen(mapping); <br>
for (int j = 0; j &lt; map_len; j++) <br>
if (mapping[j] == ',') <br>
mapping[j] = '\n';</p>

<p style="margin-left:11%; margin-top: 1em">fd =
open(map_file, O_RDWR); <br>
if (fd == -1) { <br>
fprintf(stderr, &quot;ERROR: open %s: %s\n&quot;, map_file,
<br>
strerror(errno)); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if (write(fd,
mapping, map_len) != map_len) { <br>
fprintf(stderr, &quot;ERROR: write %s: %s\n&quot;, map_file,
<br>
strerror(errno)); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">close(fd); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Linux 3.19
made a change in the handling of setgroups(2) and the <br>
'gid_map' file to address a security issue. The issue
allowed <br>
*unprivileged* users to employ user namespaces in order to
drop <br>
The upshot of the 3.19 changes is that in order to update
the <br>
'gid_maps' file, use of the setgroups() system call in this
<br>
user namespace must first be disabled by writing
&quot;deny&quot; to one of <br>
the /proc/PID/setgroups files for this namespace. That is
the <br>
purpose of the following function. */</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
proc_setgroups_write(pid_t child_pid, char *str) <br>
{ <br>
char setgroups_path[PATH_MAX]; <br>
int fd;</p>


<p style="margin-left:11%; margin-top: 1em">snprintf(setgroups_path,
PATH_MAX, &quot;/proc/%jd/setgroups&quot;, <br>
(intmax_t) child_pid);</p>

<p style="margin-left:11%; margin-top: 1em">fd =
open(setgroups_path, O_RDWR); <br>
if (fd == -1) {</p>

<p style="margin-left:11%; margin-top: 1em">/* We may be on
a system that doesn't support <br>
/proc/PID/setgroups. In that case, the file won't exist,
<br>
and the system won't impose the restrictions that Linux 3.19
<br>
added. That's fine: we don't need to do anything in order
<br>
to permit 'gid_map' to be updated.</p>

<p style="margin-left:11%; margin-top: 1em">However, if the
error from open() was something other than <br>
the ENOENT error that is expected for that case, let the
<br>
user know. */</p>

<p style="margin-left:11%; margin-top: 1em">if (errno !=
ENOENT) <br>
fprintf(stderr, &quot;ERROR: open %s: %s\n&quot;,
setgroups_path, <br>
strerror(errno)); <br>
return; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if (write(fd,
str, strlen(str)) == -1) <br>
fprintf(stderr, &quot;ERROR: write %s: %s\n&quot;,
setgroups_path, <br>
strerror(errno));</p>

<p style="margin-left:11%; margin-top: 1em">close(fd); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">static int /*
Start function for cloned child */ <br>
childFunc(void *arg) <br>
{ <br>
struct child_args *args = arg; <br>
char ch;</p>

<p style="margin-left:11%; margin-top: 1em">/* Wait until
the parent has updated the UID and GID mappings. <br>
See the comment in main(). We wait for end of file on a <br>
pipe that will be closed by the parent process once it has
<br>
updated the mappings. */</p>


<p style="margin-left:11%; margin-top: 1em">close(args-&gt;pipe_fd[1]);
/* Close our descriptor for the write <br>
end of the pipe so that we see EOF <br>
when parent closes its descriptor */ <br>
if (read(args-&gt;pipe_fd[0], &amp;ch, 1) != 0) { <br>
fprintf(stderr, <br>
&quot;Failure in child: read from pipe returned !=
0\n&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">close(args-&gt;pipe_fd[0]);</p>

<p style="margin-left:11%; margin-top: 1em">/* Execute a
shell command */</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;About
to exec %s\n&quot;, args-&gt;argv[0]); <br>
execvp(args-&gt;argv[0], args-&gt;argv); <br>
errExit(&quot;execvp&quot;); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">#define
STACK_SIZE (1024 * 1024)</p>

<p style="margin-left:11%; margin-top: 1em">static char
child_stack[STACK_SIZE]; /* Space for child's stack */</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
int flags, opt, map_zero; <br>
pid_t child_pid; <br>
struct child_args args; <br>
char *uid_map, *gid_map; <br>
const int MAP_BUF_SIZE = 100; <br>
char map_buf[MAP_BUF_SIZE]; <br>
char map_path[PATH_MAX];</p>

<p style="margin-left:11%; margin-top: 1em">/* Parse
command-line options. The initial '+' character in <br>
the final getopt() argument prevents GNU-style permutation
<br>
of command-line options. That's useful, since sometimes <br>
the 'command' to be executed by this program itself <br>
has command-line options. We don't want getopt() to treat
<br>
those as options to this program. */</p>

<p style="margin-left:11%; margin-top: 1em">flags = 0; <br>
verbose = 0; <br>
gid_map = NULL; <br>
uid_map = NULL; <br>
map_zero = 0; <br>
while ((opt = getopt(argc, argv, &quot;+imnpuUM:G:zv&quot;))
!= -1) { <br>
switch (opt) { <br>
case 'i': flags |= CLONE_NEWIPC; break; <br>
case 'm': flags |= CLONE_NEWNS; break; <br>
case 'n': flags |= CLONE_NEWNET; break; <br>
case 'p': flags |= CLONE_NEWPID; break; <br>
case 'u': flags |= CLONE_NEWUTS; break; <br>
case 'v': verbose = 1; break; <br>
case 'z': map_zero = 1; break; <br>
case 'M': uid_map = optarg; break; <br>
case 'G': gid_map = optarg; break; <br>
case 'U': flags |= CLONE_NEWUSER; break; <br>
default: usage(argv[0]); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* -M or -G
without -U is nonsensical */</p>

<p style="margin-left:11%; margin-top: 1em">if (((uid_map
!= NULL || gid_map != NULL || map_zero) &amp;&amp; <br>
!(flags &amp; CLONE_NEWUSER)) || <br>
(map_zero &amp;&amp; (uid_map != NULL || gid_map != NULL)))
<br>
usage(argv[0]);</p>

<p style="margin-left:11%; margin-top: 1em">args.argv =
&amp;argv[optind];</p>

<p style="margin-left:11%; margin-top: 1em">/* We use a
pipe to synchronize the parent and child, in order to <br>
ensure that the parent sets the UID and GID maps before the
child <br>
calls execve(). This ensures that the child maintains its
<br>
capabilities during the execve() in the common case where we
<br>
want to map the child's effective user ID to 0 in the new
user <br>
namespace. Without this synchronization, the child would
lose <br>
its capabilities if it performed an execve() with nonzero
<br>
user IDs (see the capabilities(7) man page for details of
the <br>
transformation of a process's capabilities during execve()).
*/</p>

<p style="margin-left:11%; margin-top: 1em">if
(pipe(args.pipe_fd) == -1) <br>
errExit(&quot;pipe&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Create the
child in new namespace(s) */</p>

<p style="margin-left:11%; margin-top: 1em">child_pid =
clone(childFunc, child_stack + STACK_SIZE, <br>
flags | SIGCHLD, &amp;args); <br>
if (child_pid == -1) <br>
errExit(&quot;clone&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Parent falls
through to here */</p>

<p style="margin-left:11%; margin-top: 1em">if (verbose)
<br>
printf(&quot;%s: PID of child created by clone() is
%jd\n&quot;, <br>
argv[0], (intmax_t) child_pid);</p>

<p style="margin-left:11%; margin-top: 1em">/* Update the
UID and GID maps in the child */</p>

<p style="margin-left:11%; margin-top: 1em">if (uid_map !=
NULL || map_zero) { <br>
snprintf(map_path, PATH_MAX, &quot;/proc/%jd/uid_map&quot;,
<br>
(intmax_t) child_pid); <br>
if (map_zero) { <br>
snprintf(map_buf, MAP_BUF_SIZE, &quot;0 %jd 1&quot;, <br>
(intmax_t) getuid()); <br>
uid_map = map_buf; <br>
} <br>
update_map(uid_map, map_path); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if (gid_map !=
NULL || map_zero) { <br>
proc_setgroups_write(child_pid, &quot;deny&quot;);</p>


<p style="margin-left:11%; margin-top: 1em">snprintf(map_path,
PATH_MAX, &quot;/proc/%jd/gid_map&quot;, <br>
(intmax_t) child_pid); <br>
if (map_zero) { <br>
snprintf(map_buf, MAP_BUF_SIZE, &quot;0 %ld 1&quot;, <br>
(intmax_t) getgid()); <br>
gid_map = map_buf; <br>
} <br>
update_map(gid_map, map_path); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Close the
write end of the pipe, to signal to the child that we <br>
have updated the UID and GID maps */</p>


<p style="margin-left:11%; margin-top: 1em">close(args.pipe_fd[1]);</p>

<p style="margin-left:11%; margin-top: 1em">if
(waitpid(child_pid, NULL, 0) == -1) /* Wait for child */
<br>
errExit(&quot;waitpid&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">if (verbose)
<br>
printf(&quot;%s: terminating\n&quot;, argv[0]);</p>


<p style="margin-left:11%; margin-top: 1em">exit(EXIT_SUCCESS);
<br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="https://man.page/1/newgidmap">newgidmap(1)</a>,
<a href="https://man.page/1/newuidmap">newuidmap(1)</a>, <a href="https://man.page/2/clone">clone(2)</a>, <a href="https://man.page/2/ptrace">ptrace(2)</a>,
<a href="https://man.page/2/setns">setns(2)</a>, <a href="https://man.page/2/unshare">unshare(2)</a>, <a href="https://man.page/5/proc">proc(5)</a>,
<a href="https://man.page/5/subgid">subgid(5)</a>, <a href="https://man.page/5/subuid">subuid(5)</a>, <a href="https://man.page/7/capabilities">capabilities(7)</a>,
<a href="https://man.page/7/cgroup_namespaces">cgroup_namespaces(7)</a>, <a href="https://man.page/7/credentials">credentials(7)</a>,
<a href="https://man.page/7/namespaces">namespaces(7)</a>, <a href="https://man.page/7/pid_namespaces">pid_namespaces(7)</a></p>

<p style="margin-left:11%; margin-top: 1em">The kernel
source file
<i>Documentation/namespaces/resource-control.txt</i>.</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
