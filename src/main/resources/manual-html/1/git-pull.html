<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon Nov  7 04:40:38 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT-PULL</title>

</head>
<body>

<h1 align="center">GIT-PULL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#GIT URLS">GIT URLS</a><br>
<a href="#REMOTES">REMOTES</a><br>
<a href="#MERGE STRATEGIES">MERGE STRATEGIES</a><br>
<a href="#DEFAULT BEHAVIOUR">DEFAULT BEHAVIOUR</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SECURITY">SECURITY</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">git-pull -
Fetch from and integrate with another repository or a local
branch</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>git pull</i>
[&lt;options&gt;] [&lt;repository&gt;
[&lt;refspec&gt;...]]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Incorporates
changes from a remote repository into the current branch. If
the current branch is behind the remote, then by default it
will fast-forward the current branch to match the remote. If
the current branch and the remote have diverged, the user
needs to specify how to reconcile the divergent branches
with <b>--rebase</b> or <b>--no-rebase</b> (or the
corresponding configuration option in
<b>pull.rebase</b>).</p>

<p style="margin-left:11%; margin-top: 1em">More precisely,
<b>git pull</b> runs <b>git fetch</b> with the given
parameters and then depending on configuration options or
command line flags, will call either <b>git rebase</b> or
<b>git merge</b> to reconcile diverging branches.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;repository&gt;
should be the name of a remote repository as passed to
<a href="https://man.page/1/git-fetch">git-fetch(1)</a>. &lt;refspec&gt; can name an arbitrary
remote ref (for example, the name of a tag) or even a
collection of refs with corresponding remote-tracking
branches (e.g., refs/heads/*:refs/remotes/origin/*), but
usually it is the name of a branch in the remote
repository.</p>

<p style="margin-left:11%; margin-top: 1em">Default values
for &lt;repository&gt; and &lt;branch&gt; are read from the
&quot;remote&quot; and &quot;merge&quot; configuration for
the current branch as set by <a href="https://man.page/1/git-branch">git-branch(1)</a>
<b>--track</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Assume the
following history exists and the current branch is
&quot;<b>master</b>&quot;:</p>

<p style="margin-left:17%; margin-top: 1em">A---B---C
master on origin <br>
/ <br>
D---E---F---G master <br>
^ <br>
origin/master in your repository</p>

<p style="margin-left:11%; margin-top: 1em">Then
&quot;<b>git pull</b>&quot; will fetch and replay the
changes from the remote <b>master</b> branch since it
diverged from the local <b>master</b> (i.e., <b>E</b>) until
its current commit (<b>C</b>) on top of <b>master</b> and
record the result in a new commit along with the names of
the two parent commits and a log message from the user
describing the changes.</p>

<p style="margin-left:17%; margin-top: 1em">A---B---C
origin/master <br>
/ \ <br>
D---E---F---G---H master</p>

<p style="margin-left:11%; margin-top: 1em">See
<a href="https://man.page/1/git-merge">git-merge(1)</a> for details, including how conflicts are
presented and handled.</p>

<p style="margin-left:11%; margin-top: 1em">In Git 1.7.0 or
later, to cancel a conflicting merge, use <b>git reset
--merge</b>. <b>Warning</b>: In older versions of Git,
running <i>git pull</i> with uncommitted changes is
discouraged: while possible, it leaves you in a state that
may be hard to back out of in the case of a conflict.</p>

<p style="margin-left:11%; margin-top: 1em">If any of the
remote changes overlap with local uncommitted changes, the
merge will be automatically canceled and the work tree
untouched. It is generally best to get any local changes in
working order before pulling or stash them away with
<a href="https://man.page/1/git-stash">git-stash(1)</a>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">-q, --quiet</p>

<p style="margin-left:17%;">This is passed to both
underlying git-fetch to squelch reporting of during
transfer, and underlying git-merge to squelch output during
merging.</p>

<p style="margin-left:11%; margin-top: 1em">-v,
--verbose</p>

<p style="margin-left:17%;">Pass --verbose to git-fetch and
git-merge.</p>


<p style="margin-left:11%; margin-top: 1em">--[no-]recurse-submodules[=yes|on-demand|no]</p>

<p style="margin-left:17%;">This option controls if new
commits of populated submodules should be fetched, and if
the working trees of active submodules should be updated,
too (see <a href="https://man.page/1/git-fetch">git-fetch(1)</a>, <a href="https://man.page/1/git-config">git-config(1)</a> and
<a href="https://man.page/5/gitmodules">gitmodules(5)</a>).</p>

<p style="margin-left:17%; margin-top: 1em">If the checkout
is done via rebase, local submodule commits are rebased as
well.</p>

<p style="margin-left:17%; margin-top: 1em">If the update
is done via merge, the submodule conflicts are resolved and
checked out.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options
related to merging</b> <br>
--commit, --no-commit</p>

<p style="margin-left:17%;">Perform the merge and commit
the result. This option can be used to override --no-commit.
Only useful when merging.</p>

<p style="margin-left:17%; margin-top: 1em">With
--no-commit perform the merge and stop just before creating
a merge commit, to give the user a chance to inspect and
further tweak the merge result before committing.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
fast-forward updates do not create a merge commit and
therefore there is no way to stop those merges with
--no-commit. Thus, if you want to ensure your branch is not
changed or updated by the merge command, use --no-ff with
--no-commit.</p>

<p style="margin-left:11%; margin-top: 1em">--edit, -e,
--no-edit</p>

<p style="margin-left:17%;">Invoke an editor before
committing successful mechanical merge to further edit the
auto-generated merge message, so that the user can explain
and justify the merge. The <b>--no-edit</b> option can be
used to accept the auto-generated message (this is generally
discouraged).</p>

<p style="margin-left:17%; margin-top: 1em">Older scripts
may depend on the historical behaviour of not allowing the
user to edit the merge log message. They will see an editor
opened when they run <b>git merge</b>. To make it easier to
adjust such scripts to the updated behaviour, the
environment variable <b>GIT_MERGE_AUTOEDIT</b> can be set to
<b>no</b> at the beginning of them.</p>


<p style="margin-left:11%; margin-top: 1em">--cleanup=&lt;mode&gt;</p>

<p style="margin-left:17%;">This option determines how the
merge message will be cleaned up before committing. See
<a href="https://man.page/1/git-commit">git-commit(1)</a> for more details. In addition, if the
<i>&lt;mode&gt;</i> is given a value of <b>scissors</b>,
scissors will be appended to <b>MERGE_MSG</b> before being
passed on to the commit machinery in the case of a merge
conflict.</p>

<p style="margin-left:11%; margin-top: 1em">--ff-only</p>

<p style="margin-left:17%;">Only update to the new history
if there is no divergent local history. This is the default
when no method for reconciling divergent histories is
provided (via the --rebase=* flags).</p>

<p style="margin-left:11%; margin-top: 1em">--ff,
--no-ff</p>

<p style="margin-left:17%;">When merging rather than
rebasing, specifies how a merge is handled when the
merged-in history is already a descendant of the current
history. If merging is requested, <b>--ff</b> is the default
unless merging an annotated (and possibly signed) tag that
is not stored in its natural place in the <b>refs/tags/</b>
hierarchy, in which case <b>--no-ff</b> is assumed.</p>

<p style="margin-left:17%; margin-top: 1em">With
<b>--ff</b>, when possible resolve the merge as a
fast-forward (only update the branch pointer to match the
merged branch; do not create a merge commit). When not
possible (when the merged-in history is not a descendant of
the current history), create a merge commit.</p>

<p style="margin-left:17%; margin-top: 1em">With
<b>--no-ff</b>, create a merge commit in all cases, even
when the merge could instead be resolved as a
fast-forward.</p>


<p style="margin-left:11%; margin-top: 1em">-S[&lt;keyid&gt;],
--gpg-sign[=&lt;keyid&gt;], --no-gpg-sign</p>

<p style="margin-left:17%;">GPG-sign the resulting merge
commit. The <b>keyid</b> argument is optional and defaults
to the committer identity; if specified, it must be stuck to
the option without a space. <b>--no-gpg-sign</b> is useful
to countermand both <b>commit.gpgSign</b> configuration
variable, and earlier <b>--gpg-sign</b>.</p>


<p style="margin-left:11%; margin-top: 1em">--log[=&lt;n&gt;],
--no-log</p>

<p style="margin-left:17%;">In addition to branch names,
populate the log message with one-line descriptions from at
most &lt;n&gt; actual commits that are being merged. See
also <a href="https://man.page/1/git-fmt-merge-msg">git-fmt-merge-msg(1)</a>. Only useful when
merging.</p>

<p style="margin-left:17%; margin-top: 1em">With --no-log
do not list one-line descriptions from the actual commits
being merged.</p>

<p style="margin-left:11%; margin-top: 1em">--signoff,
--no-signoff</p>

<p style="margin-left:17%;">Add a <b>Signed-off-by</b>
trailer by the committer at the end of the commit log
message. The meaning of a signoff depends on the project to
which you&rsquo;re committing. For example, it may certify
that the committer has the rights to submit the work under
the project&rsquo;s license or agrees to some contributor
representation, such as a Developer Certificate of Origin.
(See
<b><font color="#0000FF">http://developercertificate.org</font></b>
<font color="#000000">for the one used by the Linux kernel
and Git projects.) Consult the documentation or leadership
of the project to which you&rsquo;re contributing to
understand how the signoffs are used in that
project.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
--no-signoff option can be used to countermand an earlier
--signoff option on the command line.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--stat,
-n, --no-stat</font></p>

<p style="margin-left:17%;"><font color="#000000">Show a
diffstat at the end of the merge. The diffstat is also
controlled by the configuration option
merge.stat.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">With
-n or --no-stat do not show a diffstat at the end of the
merge.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--squash,
--no-squash</font></p>

<p style="margin-left:17%;"><font color="#000000">Produce
the working tree and index state as if a real merge happened
(except for the merge information), but do not actually make
a commit, move the <b>HEAD</b>, or record
<b>$GIT_DIR/MERGE_HEAD</b> (to cause the next <b>git
commit</b> command to create a merge commit). This allows
you to create a single commit on top of the current branch
whose effect is the same as merging another branch (or more
in case of an octopus).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">With
--no-squash perform the merge and commit the result. This
option can be used to override --squash.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">With
--squash, --commit is not allowed, and will fail.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Only
useful when merging.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--[no-]verify</font></p>

<p style="margin-left:17%;"><font color="#000000">By
default, the pre-merge and commit-msg hooks are run. When
<b>--no-verify</b> is given, these are bypassed. See also
<a href="https://man.page/5/githooks">githooks(5)</a>. Only useful when merging.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-s
&lt;strategy&gt;, --strategy=&lt;strategy&gt;</font></p>

<p style="margin-left:17%;"><font color="#000000">Use the
given merge strategy; can be supplied more than once to
specify them in the order they should be tried. If there is
no <b>-s</b> option, a built-in list of strategies is used
instead (<b>ort</b> when merging a single head,
<b>octopus</b> otherwise).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-X
&lt;option&gt;, --strategy-option=&lt;option&gt;</font></p>

<p style="margin-left:17%;"><font color="#000000">Pass
merge strategy specific option through to the merge
strategy.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--verify-signatures,
--no-verify-signatures</font></p>

<p style="margin-left:17%;"><font color="#000000">Verify
that the tip commit of the side branch being merged is
signed with a valid key, i.e. a key that has a valid uid: in
the default trust model, this means the signing key has been
signed by a trusted key. If the tip commit of the side
branch is not signed with a valid key, the merge is
aborted.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Only
useful when merging.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--summary,
--no-summary</font></p>

<p style="margin-left:17%;"><font color="#000000">Synonyms
to --stat and --no-stat; these are deprecated and will be
removed in the future.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--autostash,
--no-autostash</font></p>


<p style="margin-left:17%;"><font color="#000000">Automatically
create a temporary stash entry before the operation begins,
record it in the special ref <b>MERGE_AUTOSTASH</b> and
apply it after the operation ends. This means that you can
run the operation on a dirty worktree. However, use with
care: the final stash application after a successful merge
might result in non-trivial conflicts.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--allow-unrelated-histories</font></p>

<p style="margin-left:17%;"><font color="#000000">By
default, <b>git merge</b> command refuses to merge histories
that do not share a common ancestor. This option can be used
to override this safety when merging histories of two
projects that started their lives independently. As that is
a very rare occasion, no configuration variable to enable
this by default exists and will not be added.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Only
useful when merging.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-r,
--rebase[=false|true|merges|interactive]</font></p>

<p style="margin-left:17%;"><font color="#000000">When
true, rebase the current branch on top of the upstream
branch after fetching. If there is a remote-tracking branch
corresponding to the upstream branch and the upstream branch
was rebased since last fetched, the rebase uses that
information to avoid rebasing non-local changes.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
set to <b>merges</b>, rebase using <b>git rebase
--rebase-merges</b> so that the local merge commits are
included in the rebase (see <a href="https://man.page/1/git-rebase">git-rebase(1)</a> for
details).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
false, merge the upstream branch into the current
branch.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
<b>interactive</b>, enable the interactive mode of
rebase.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">See
<b>pull.rebase</b>, <b>branch.&lt;name&gt;.rebase</b> and
<b>branch.autoSetupRebase</b> in <a href="https://man.page/1/git-config">git-config(1)</a> if you
want to make <b>git pull</b> always use <b>--rebase</b>
instead of merging.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b>
<br>
This is a potentially <i>dangerous</i> mode of operation. It
rewrites history, which does not bode well when you
published that history already. Do <b>not</b> use this
option unless you have read <a href="https://man.page/1/git-rebase">git-rebase(1)</a>
carefully.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--no-rebase</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>This
is shorthand for --rebase=false.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><b>Options
related to fetching</b> <br>
--all</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Fetch
all remotes.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-a,
--append</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Append
ref names and object names of fetched refs to the existing
contents of <b>.git/FETCH_HEAD</b>. Without this option old
data in <b>.git/FETCH_HEAD</b> will be
overwritten.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--atomic</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>Use
an atomic transaction to update local refs. Either all refs
are updated, or on error, no refs are
updated.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--depth=&lt;depth&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Limit
fetching to the specified number of commits from the tip of
each remote branch history. If fetching to a <i>shallow</i>
repository created by <b>git clone</b> with
<b>--depth=&lt;depth&gt;</b> option (see
<a href="https://man.page/1/git-clone">git-clone(1)</a>), deepen or shorten the history to the
specified number of commits. Tags for the deepened commits
are not fetched.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--deepen=&lt;depth&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Similar
to --depth, except it specifies the number of commits from
the current shallow boundary instead of from the tip of each
remote branch history.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--shallow-since=&lt;date&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Deepen
or shorten the history of a shallow repository to include
all reachable commits after &lt;date&gt;.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--shallow-exclude=&lt;revision&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Deepen
or shorten the history of a shallow repository to exclude
commits reachable from a specified remote branch or tag.
This option can be specified multiple
times.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--unshallow</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>If
the source repository is complete, convert a shallow
repository to a complete one, removing all the limitations
imposed by shallow repositories.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>If
the source repository is shallow, fetch as much as possible
so that the current repository has the same history as the
source repository.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--update-shallow</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>By
default when fetching from a shallow repository, <b>git
fetch</b> refuses refs that require updating .git/shallow.
This option updates .git/shallow and accept such
refs.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--negotiation-tip=&lt;commit|glob&gt;</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>By
default, Git will report, to the server, commits reachable
from all local refs to find common commits in an attempt to
reduce the size of the to-be-received packfile. If
specified, Git will only report commits reachable from the
given tips. This is useful to speed up fetches when the user
knows which local ref is likely to have commits in common
with the upstream ref being fetched.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>This
option may be specified more than once; if so, Git will
report commits reachable from any of the given
commits.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>The
argument to this option may be a glob on ref names, a ref,
or the (possibly abbreviated) SHA-1 of a commit. Specifying
a glob is equivalent to specifying this option multiple
times, one for each matching ref name.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>See
also the <b>fetch.negotiationAlgorithm</b> and
<b>push.negotiate</b> configuration variables documented in
<a href="https://man.page/1/git-config">git-config(1)</a>, and the <b>--negotiate-only</b> option
below.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--negotiate-only</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>Do
not fetch anything from the server, and instead print the
ancestors of the provided <b>--negotiation-tip=*</b>
arguments, which we have in common with the
server.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Internally
this is used to implement the <b>push.negotiate</b> option,
see <a href="https://man.page/1/git-config">git-config(1)</a>.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--dry-run</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Show
what would be done, without making any
changes.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-f,
--force</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>When
<i>git fetch</i> is used with <b>&lt;src&gt;:&lt;dst&gt;</b>
refspec it may refuse to update the local branch as
discussed in the <b>&lt;refspec&gt;</b> part of the
<a href="https://man.page/1/git-fetch">git-fetch(1)</a> documentation. This option overrides
that check.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-k,
--keep</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Keep
downloaded pack.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--prefetch</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Modify
the configured refspec to place all refs into the
<b>refs/prefetch/</b> namespace. See the <b>prefetch</b>
task in <a href="https://man.page/1/git-maintenance">git-maintenance(1)</a>.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-p,
--prune</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Before
fetching, remove any remote-tracking references that no
longer exist on the remote. Tags are not subject to pruning
if they are fetched only because of the default tag
auto-following or due to a --tags option. However, if tags
are fetched due to an explicit refspec (either on the
command line or in the remote configuration, for example if
the remote was cloned with the --mirror option), then they
are also subject to pruning. Supplying <b>--prune-tags</b>
is a shorthand for providing the tag
refspec.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--no-tags</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>By
default, tags that point at objects that are downloaded from
the remote repository are fetched and stored locally. This
option disables this automatic tag following. The default
behavior for a remote may be specified with the
remote.&lt;name&gt;.tagOpt setting. See
<a href="https://man.page/1/git-config">git-config(1)</a>.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--refmap=&lt;refspec&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>When
fetching refs listed on the command line, use the specified
refspec (can be given more than once) to map the refs to
remote-tracking branches, instead of the values of
<b>remote.*.fetch</b> configuration variables for the remote
repository. Providing an empty <b>&lt;refspec&gt;</b> to the
<b>--refmap</b> option causes Git to ignore the configured
refspecs and rely entirely on the refspecs supplied as
command-line arguments. See section on &quot;Configured
Remote-tracking Branches&quot; for details.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-t,
--tags</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Fetch
all tags from the remote (i.e., fetch remote tags
<b>refs/tags/*</b> into local tags with the same name), in
addition to whatever else would otherwise be fetched. Using
this option alone does not subject tags to pruning, even if
--prune is used (though tags may be pruned anyway if they
are also the destination of an explicit refspec; see
<b>--prune</b>).</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-j,
--jobs=&lt;n&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Number
of parallel children to be used for all forms of
fetching.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>If
the <b>--multiple</b> option was specified, the different
remotes will be fetched in parallel. If multiple submodules
are fetched, they will be fetched in parallel. To control
them independently, use the config settings
<b>fetch.parallel</b> and <b>submodule.fetchJobs</b> (see
<a href="https://man.page/1/git-config">git-config(1)</a>).</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Typically,
parallel recursive and multi-remote fetches will be faster.
By default fetches are performed sequentially, not in
parallel.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--set-upstream</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>If
the remote is fetched successfully, add upstream (tracking)
reference, used by argument-less <a href="https://man.page/1/git-pull">git-pull(1)</a> and
other commands. For more information, see
<b>branch.&lt;name&gt;.merge</b> and
<b>branch.&lt;name&gt;.remote</b> in
<a href="https://man.page/1/git-config">git-config(1)</a>.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--upload-pack
&lt;upload-pack&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>When
given, and the repository to fetch from is handled by <i>git
fetch-pack</i>, <b>--exec=&lt;upload-pack&gt;</b> is passed
to the command to specify non-default path for the command
run on the other end.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--progress</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Progress
status is reported on the standard error stream by default
when it is attached to a terminal, unless -q is specified.
This flag forces progress status even if the standard error
stream is not directed to a terminal.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-o
&lt;option&gt;,
--server-option=&lt;option&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Transmit
the given string to the server when communicating using
protocol version 2. The given string must not contain a NUL
or LF character. The server&rsquo;s handling of server
options, including unknown ones, is server-specific. When
multiple <b>--server-option=&lt;option&gt;</b> are given,
they are all sent to the other side in the order listed on
the command line.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--show-forced-updates</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>By
default, git checks if a branch is force-updated during
fetch. This can be disabled through fetch.showForcedUpdates,
but the --show-forced-updates option guarantees this check
occurs. See <a href="https://man.page/1/git-config">git-config(1)</a>.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>--no-show-forced-updates</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>By
default, git checks if a branch is force-updated during
fetch. Pass --no-show-forced-updates or set
fetch.showForcedUpdates to false to skip this check for
performance reasons. If used during <i>git-pull</i> the
--ff-only option will still check for forced updates before
attempting a fast-forward update. See
<a href="https://man.page/1/git-config">git-config(1)</a>.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-4,
--ipv4</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>Use
IPv4 addresses only, ignoring IPv6
addresses.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>-6,
--ipv6</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>Use
IPv6 addresses only, ignoring IPv4
addresses.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>&lt;repository&gt;</big></font></p>

<p style="margin-left:17%;"><font color="#000000"><big>The
&quot;remote&quot; repository that is the source of a fetch
or pull operation. This parameter can be either a URL (see
the section GIT URLS below) or the name of a remote (see the
section REMOTES below).</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>&lt;refspec&gt;</big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>Specifies
which refs to fetch and which local refs to update. When no
&lt;refspec&gt;s appear on the command line, the refs to
fetch are read from <b>remote.&lt;repository&gt;.fetch</b>
variables instead (see the section &quot;CONFIGURED
REMOTE-TRACKING BRANCHES&quot; in
<a href="https://man.page/1/git-fetch">git-fetch(1)</a>).</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>The
format of a &lt;refspec&gt; parameter is an optional plus
<b>+</b>, followed by the source &lt;src&gt;, followed by a
colon <b>:</b>, followed by the destination ref &lt;dst&gt;.
The colon can be omitted when &lt;dst&gt; is empty.
&lt;src&gt; is typically a ref, but it can also be a fully
spelled hex object name.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>A
&lt;refspec&gt; may contain a <b>*</b> in its &lt;src&gt; to
indicate a simple pattern match. Such a refspec functions
like a glob that matches any ref with the same prefix. A
pattern &lt;refspec&gt; must have a <b>*</b> in both the
&lt;src&gt; and &lt;dst&gt;. It will map refs to the
destination by replacing the <b>*</b> with the contents
matched from the source.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>If
a refspec is prefixed by <b>^</b>, it will be interpreted as
a negative refspec. Rather than specifying which refs to
fetch or which local refs to update, such a refspec will
instead specify refs to exclude. A ref will be considered to
match if it matches at least one positive refspec, and does
not match any negative refspec. Negative refspecs can be
useful to restrict the scope of a pattern refspec so that it
will not include specific refs. Negative refspecs can
themselves be pattern refspecs. However, they may only
contain a &lt;src&gt; and do not specify a &lt;dst&gt;.
Fully spelled out hex object names are also not
supported.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><b>tag
&lt;tag&gt;</b> means the same as
<b>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</b>; it
requests fetching everything up to the given
tag.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>The
remote ref that matches &lt;src&gt; is fetched, and if
&lt;dst&gt; is not an empty string, an attempt is made to
update the local ref that matches it.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Whether
that update is allowed without <b>--force</b> depends on the
ref namespace it&rsquo;s being fetched to, the type of
object being fetched, and whether the update is considered
to be a fast-forward. Generally, the same rules apply for
fetching as when pushing, see the <b>&lt;refspec&gt;...</b>
section of <a href="https://man.page/1/git-push">git-push(1)</a> for what those are. Exceptions
to those rules particular to <i>git fetch</i> are noted
below.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Until
Git version 2.20, and unlike when pushing with
<a href="https://man.page/1/git-push">git-push(1)</a>, any updates to <b>refs/tags/*</b> would
be accepted without <b>+</b> in the refspec (or
<b>--force</b>). When fetching, we promiscuously considered
all tag updates from a remote to be forced fetches. Since
Git version 2.20, fetching to update <b>refs/tags/*</b>
works the same way as when pushing. I.e. any updates will be
rejected without <b>+</b> in the refspec (or
<b>--force</b>).</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Unlike
when pushing with <a href="https://man.page/1/git-push">git-push(1)</a>, any updates outside of
<b>refs/{tags,heads}/*</b> will be accepted without <b>+</b>
in the refspec (or <b>--force</b>), whether that&rsquo;s
swapping e.g. a tree object for a blob, or a commit for
another commit that&rsquo;s doesn&rsquo;t have the previous
commit as an ancestor etc.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Unlike
when pushing with <a href="https://man.page/1/git-push">git-push(1)</a>, there is no
configuration which&rsquo;ll amend these rules, and nothing
like a <b>pre-fetch</b> hook analogous to the
<b>pre-receive</b> hook.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>As
with pushing with <a href="https://man.page/1/git-push">git-push(1)</a>, all of the rules
described above about what&rsquo;s not allowed as an update
can be overridden by adding an the optional leading <b>+</b>
to a refspec (or using <b>--force</b> command line option).
The only exception to this is that no amount of forcing will
make the <b>refs/heads/*</b> namespace accept a non-commit
object.</big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b>
<br>
When the remote branch you want to fetch is known to be
rewound and rebased regularly, it is expected that its new
tip will not be descendant of its previous tip (as stored in
your remote-tracking branch the last time you fetched). You
would want to use the <b>+</b> sign to indicate
non-fast-forward updates will be needed for such branches.
There is no way to determine or declare that a branch will
be made available in a repository with this behavior; the
pulling user simply must know this is the expected usage
pattern for a branch.</big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b>
<br>
There is a difference between listing multiple
&lt;refspec&gt; directly on <i>git pull</i> command line and
having multiple <b>remote.&lt;repository&gt;.fetch</b>
entries in your configuration for a &lt;repository&gt; and
running a <i>git pull</i> command without any explicit
&lt;refspec&gt; parameters. &lt;refspec&gt;s listed
explicitly on the command line are always merged into the
current branch after fetching. In other words, if you list
more than one remote ref, <i>git pull</i> will create an
Octopus merge. On the other hand, if you do not list any
explicit &lt;refspec&gt; parameter on the command line,
<i>git pull</i> will fetch all the &lt;refspec&gt;s it finds
in the <b>remote.&lt;repository&gt;.fetch</b> configuration
and merge only the first &lt;refspec&gt; found into the
current branch. This is because making an Octopus from
remote refs is rarely done, while keeping track of multiple
remote heads in one-go by fetching more than one is often
useful.</big></font></p>

<h2>GIT URLS
<a name="GIT URLS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>In
general, URLs contain information about the transport
protocol, the address of the remote server, and the path to
the repository. Depending on the transport protocol, some of
this information may be absent.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Git
supports ssh, git, http, and https protocols (in addition,
ftp, and ftps can be used for fetching, but this is
inefficient and deprecated; do not use
it).</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
native transport (i.e. git:// URL) does no authentication
and should be used with caution on unsecured
networks.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
following syntaxes may be used with
them:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
ssh://[user@]host.xz[:port]/path/to/repo.git/</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
git://host.xz[:port]/path/to/repo.git/</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
http[s]://host.xz[:port]/path/to/repo.git/</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
ftp[s]://host.xz[:port]/path/to/repo.git/</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>An
alternative scp-like syntax may also be used with the ssh
protocol:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
[user@]host.xz:path/to/repo.git/</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>This
syntax is only recognized if there are no slashes before the
first colon. This helps differentiate a local path that
contains a colon. For example the local path <b>foo:bar</b>
could be specified as an absolute path or <b>./foo:bar</b>
to avoid being misinterpreted as an ssh
url.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
ssh and git protocols additionally support ~username
expansion:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
git://host.xz[:port]/~[user]/path/to/repo.git/</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
[user@]host.xz:/~[user]/path/to/repo.git/</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>For
local repositories, also supported by Git natively, the
following syntaxes may be used:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
/path/to/repo.git/</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
file:///path/to/repo.git/</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>These
two syntaxes are mostly equivalent, except when cloning,
when the former implies --local option. See
<a href="https://man.page/1/git-clone">git-clone(1)</a> for details.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><i>git
clone</i>, <i>git fetch</i> and <i>git pull</i>, but not
<i>git push</i>, will also accept a suitable bundle file.
See <a href="https://man.page/1/git-bundle">git-bundle(1)</a>.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>When
Git doesn&rsquo;t know how to handle a certain transport
protocol, it attempts to use the
<i>remote-&lt;transport&gt;</i> remote helper, if one
exists. To explicitly request a remote helper, the following
syntax may be used:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
&lt;transport&gt;::&lt;address&gt;</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>where
&lt;address&gt; may be a path, a server and path, or an
arbitrary URL-like string recognized by the specific remote
helper being invoked. See <a href="https://man.page/7/gitremote-helpers">gitremote-helpers(7)</a> for
details.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>If
there are a large number of similarly-named remote
repositories and you want to use a different format for them
(such that the URLs you use will be rewritten into URLs that
work), you can create a configuration section of the
form:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>[url
&quot;&lt;actual url base&gt;&quot;] <br>
insteadOf = &lt;other url base&gt;</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>For
example, with this:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>[url
&quot;git://git.host.xz/&quot;] <br>
insteadOf = host.xz:/path/to/ <br>
insteadOf = work:</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>a
URL like &quot;work:repo.git&quot; or like
&quot;host.xz:/path/to/repo.git&quot; will be rewritten in
any context that takes a URL to be
&quot;git://git.host.xz/repo.git&quot;.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>If
you want to rewrite URLs for push only, you can create a
configuration section of the form:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>[url
&quot;&lt;actual url base&gt;&quot;] <br>
pushInsteadOf = &lt;other url
base&gt;</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>For
example, with this:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>[url
&quot;ssh://example.org/&quot;] <br>
pushInsteadOf = git://example.org/</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>a
URL like &quot;git://example.org/path/to/repo.git&quot; will
be rewritten to
&quot;ssh://example.org/path/to/repo.git&quot; for pushes,
but pulls will still use the original
URL.</big></big></font></p>

<h2>REMOTES
<a name="REMOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
name of one of the following can be used instead of a URL as
<b>&lt;repository&gt;</b> argument:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
a remote in the Git configuration file:
<b>$GIT_DIR/config</b>,</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
a file in the <b>$GIT_DIR/remotes</b> directory,
or</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
a file in the <b>$GIT_DIR/branches</b>
directory.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>All
of these also allow you to omit the refspec from the command
line because they each contain a refspec which git will use
by default.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><b>Named
remote in configuration file</b> <br>
You can choose to provide the name of a remote which you had
previously configured using <a href="https://man.page/1/git-remote">git-remote(1)</a>,
<a href="https://man.page/1/git-config">git-config(1)</a> or even by a manual edit to the
<b>$GIT_DIR/config</b> file. The URL of this remote will be
used to access the repository. The refspec of this remote
will be used by default when you do not provide a refspec on
the command line. The entry in the config file would appear
like this:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>[remote
&quot;&lt;name&gt;&quot;] <br>
url = &lt;url&gt; <br>
pushurl = &lt;pushurl&gt; <br>
push = &lt;refspec&gt; <br>
fetch = &lt;refspec&gt;</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
<b>&lt;pushurl&gt;</b> is used for pushes only. It is
optional and defaults to
<b>&lt;url&gt;</b>.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><b>Named
file in $GIT_DIR/remotes</b> <br>
You can choose to provide the name of a file in
<b>$GIT_DIR/remotes</b>. The URL in this file will be used
to access the repository. The refspec in this file will be
used as default when you do not provide a refspec on the
command line. This file should have the following
format:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>URL:
one of the above URL format <br>
Push: &lt;refspec&gt; <br>
Pull: &lt;refspec&gt;</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><b>Push:</b>
lines are used by <i>git push</i> and <b>Pull:</b> lines are
used by <i>git pull</i> and <i>git fetch</i>. Multiple
<b>Push:</b> and <b>Pull:</b> lines may be specified for
additional branch mappings.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><b>Named
file in $GIT_DIR/branches</b> <br>
You can choose to provide the name of a file in
<b>$GIT_DIR/branches</b>. The URL in this file will be used
to access the repository. This file should have the
following format:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&lt;url&gt;#&lt;head&gt;</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><b>&lt;url&gt;</b>
is required; <b>#&lt;head&gt;</b> is
optional.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Depending
on the operation, git will use one of the following
refspecs, if you don&rsquo;t provide one on the command
line. <b>&lt;branch&gt;</b> is the name of this file in
<b>$GIT_DIR/branches</b> and <b>&lt;head&gt;</b> defaults to
<b>master</b>.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>git
fetch uses:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>refs/heads/&lt;head&gt;:refs/heads/&lt;branch&gt;</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>git
push uses:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>HEAD:refs/heads/&lt;head&gt;</big></big></font></p>

<h2>MERGE STRATEGIES
<a name="MERGE STRATEGIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
merge mechanism (<b>git merge</b> and <b>git pull</b>
commands) allows the backend <i>merge strategies</i> to be
chosen with <b>-s</b> option. Some strategies can also take
their own options, which can be passed by giving
<b>-X&lt;option&gt;</b> arguments to <b>git merge</b> and/or
<b>git pull</b>.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>ort</big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big>This
is the default merge strategy when pulling or merging one
branch. This strategy can only resolve two heads using a
3-way merge algorithm. When there is more than one common
ancestor that can be used for 3-way merge, it creates a
merged tree of the common ancestors and uses that as the
reference tree for the 3-way merge. This has been reported
to result in fewer merge conflicts without causing mismerges
by tests done on actual merge commits taken from Linux 2.6
kernel development history. Additionally this strategy can
detect and handle merges involving renames. It does not make
use of detected copies. The name for this algorithm is an
acronym (&quot;Ostensibly Recursive&rsquo;s Twin&quot;) and
came from the fact that it was written as a replacement for
the previous default algorithm,
<b>recursive</b>.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>The
<i>ort</i> strategy can take the following
options:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>ours</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>This
option forces conflicting hunks to be auto-resolved cleanly
by favoring <i>our</i> version. Changes from the other tree
that do not conflict with our side are reflected in the
merge result. For a binary file, the entire contents are
taken from our side.</big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big>This
should not be confused with the <i>ours</i> merge strategy,
which does not even look at what the other tree contains at
all. It discards everything the other tree did, declaring
<i>our</i> history contains all that happened in
it.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>theirs</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>This
is the opposite of <i>ours</i>; note that, unlike
<i>ours</i>, there is no <i>theirs</i> merge strategy to
confuse this merge option with.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>ignore-space-change,
ignore-all-space, ignore-space-at-eol,
ignore-cr-at-eol</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>Treats
lines with the indicated type of whitespace change as
unchanged for the sake of a three-way merge. Whitespace
changes mixed with other changes to a line are not ignored.
See also <a href="https://man.page/1/git-diff">git-diff(1)</a> <b>-b</b>, <b>-w</b>,
<b>--ignore-space-at-eol</b>, and
<b>--ignore-cr-at-eol</b>.</big></big></font></p>


<p style="margin-left:29%; margin-top: 1em"><font color="#000000"><big><big>&bull;
If <i>their</i> version only introduces whitespace changes
to a line, <i>our</i> version is
used;</big></big></font></p>


<p style="margin-left:29%; margin-top: 1em"><font color="#000000"><big><big>&bull;
If <i>our</i> version introduces whitespace changes but
<i>their</i> version includes a substantial change,
<i>their</i> version is used;</big></big></font></p>


<p style="margin-left:29%; margin-top: 1em"><font color="#000000"><big><big>&bull;
Otherwise, the merge proceeds in the usual
way.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>renormalize</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>This
runs a virtual check-out and check-in of all three stages of
a file when resolving a three-way merge. This option is
meant to be used when merging branches with different clean
filters or end-of-line normalization rules. See
&quot;Merging branches with differing checkin/checkout
attributes&quot; in <a href="https://man.page/5/gitattributes">gitattributes(5)</a> for
details.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>no-renormalize</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>Disables
the <b>renormalize</b> option. This overrides the
<b>merge.renormalize</b> configuration
variable.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>find-renames[=&lt;n&gt;]</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>Turn
on rename detection, optionally setting the similarity
threshold. This is the default. This overrides the
<i>merge.renames</i> configuration variable. See also
<a href="https://man.page/1/git-diff">git-diff(1)</a>
<b>--find-renames</b>.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>rename-threshold=&lt;n&gt;</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>Deprecated
synonym for
<b>find-renames=&lt;n&gt;</b>.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>subtree[=&lt;path&gt;]</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>This
option is a more advanced form of <i>subtree</i> strategy,
where the strategy makes a guess on how two trees must be
shifted to match with each other when merging. Instead, the
specified path is prefixed (or stripped from the beginning)
to make the shape of two trees to
match.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>recursive</big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big>This
can only resolve two heads using a 3-way merge algorithm.
When there is more than one common ancestor that can be used
for 3-way merge, it creates a merged tree of the common
ancestors and uses that as the reference tree for the 3-way
merge. This has been reported to result in fewer merge
conflicts without causing mismerges by tests done on actual
merge commits taken from Linux 2.6 kernel development
history. Additionally this can detect and handle merges
involving renames. It does not make use of detected copies.
This was the default strategy for resolving two heads from
Git v0.99.9k until v2.33.0.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>The
<i>recursive</i> strategy takes the same options as
<i>ort</i>. However, there are three additional options that
<i>ort</i> ignores (not documented above) that are
potentially useful with the <i>recursive</i>
strategy:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>patience</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>Deprecated
synonym for
<b>diff-algorithm=patience</b>.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>diff-algorithm=[patience|minimal|histogram|myers]</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>Use
a different diff algorithm while merging, which can help
avoid mismerges that occur due to unimportant matching lines
(such as braces from distinct functions). See also
<a href="https://man.page/1/git-diff">git-diff(1)</a> <b>--diff-algorithm</b>. Note that
<b>ort</b> specifically uses
<b>diff-algorithm=histogram</b>, while <b>recursive</b>
defaults to the <b>diff.algorithm</b> config
setting.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>no-renames</big></big></font></p>


<p style="margin-left:23%;"><font color="#000000"><big><big>Turn
off rename detection. This overrides the
<b>merge.renames</b> configuration variable. See also
<a href="https://man.page/1/git-diff">git-diff(1)</a>
<b>--no-renames</b>.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>resolve</big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big>This
can only resolve two heads (i.e. the current branch and
another branch you pulled from) using a 3-way merge
algorithm. It tries to carefully detect criss-cross merge
ambiguities. It does not handle
renames.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>octopus</big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big>This
resolves cases with more than two heads, but refuses to do a
complex merge that needs manual resolution. It is primarily
meant to be used for bundling topic branch heads together.
This is the default merge strategy when pulling or merging
more than one branch.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>ours</big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big>This
resolves any number of heads, but the resulting tree of the
merge is always that of the current branch head, effectively
ignoring all changes from all other branches. It is meant to
be used to supersede old development history of side
branches. Note that this is different from the -Xours option
to the <i>recursive</i> merge
strategy.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>subtree</big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big>This
is a modified <b>ort</b> strategy. When merging trees A and
B, if B corresponds to a subtree of A, B is first adjusted
to match the tree structure of A, instead of reading the
trees at the same level. This adjustment is also done to the
common ancestor tree.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>With
the strategies that use 3-way merge (including the default,
<i>ort</i>), if a change is made on both branches, but later
reverted on one of the branches, that change will be present
in the merged result; some people find this behavior
confusing. It occurs because only the heads and the merge
base are considered when performing a merge, not the
individual commits. The merge algorithm therefore considers
the reverted change as no change at all, and substitutes the
changed version instead.</big></big></font></p>

<h2>DEFAULT BEHAVIOUR
<a name="DEFAULT BEHAVIOUR"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Often
people use <b>git pull</b> without giving any parameter.
Traditionally, this has been equivalent to saying <b>git
pull origin</b>. However, when configuration
<b>branch.&lt;name&gt;.remote</b> is present while on branch
<b>&lt;name&gt;</b>, that value is used instead of
<b>origin</b>.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>In
order to determine what URL to use to fetch from, the value
of the configuration <b>remote.&lt;origin&gt;.url</b> is
consulted and if there is not any such variable, the value
on the <b>URL:</b> line in
<b>$GIT_DIR/remotes/&lt;origin&gt;</b> is
used.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>In
order to determine what remote branches to fetch (and
optionally store in the remote-tracking branches) when the
command is run without any refspec parameters on the command
line, values of the configuration variable
<b>remote.&lt;origin&gt;.fetch</b> are consulted, and if
there aren&rsquo;t any,
<b>$GIT_DIR/remotes/&lt;origin&gt;</b> is consulted and its
<b>Pull:</b> lines are used. In addition to the refspec
formats described in the OPTIONS section, you can have a
globbing refspec that looks like
this:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>refs/heads/*:refs/remotes/origin/*</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>A
globbing refspec must have a non-empty RHS (i.e. must store
what were fetched in remote-tracking branches), and its LHS
and RHS must end with <b>/*</b>. The above specifies that
all remote branches are tracked using remote-tracking
branches in <b>refs/remotes/origin/</b> hierarchy under the
same name.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
rule to determine which remote branch to merge after
fetching is a bit involved, in order not to break backward
compatibility.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>If
explicit refspecs were given on the command line of <b>git
pull</b>, they are all merged.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>When
no refspec was given on the command line, then <b>git
pull</b> uses the refspec from the configuration or
<b>$GIT_DIR/remotes/&lt;origin&gt;</b>. In such cases, the
following rules apply:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>1.
If <b>branch.&lt;name&gt;.merge</b> configuration for the
current branch <b>&lt;name&gt;</b> exists, that is the name
of the branch at the remote site that is
merged.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>2.
If the refspec is a globbing one, nothing is
merged.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>3.
Otherwise the remote branch of the first refspec is
merged.</big></big></font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
Update the remote-tracking branches for the repository you
cloned from, then merge one of them into your current
branch:</big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big>$
git pull <br>
$ git pull origin</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>Normally
the branch merged in is the HEAD of the remote repository,
but the choice is determined by the
branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge
options; see <a href="https://man.page/1/git-config">git-config(1)</a> for
details.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
Merge into the current branch the remote branch
<b>next</b>:</big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big>$
git pull origin next</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>This
leaves a copy of <b>next</b> temporarily in FETCH_HEAD, and
updates the remote-tracking branch <b>origin/next</b>. The
same can be done by invoking fetch and
merge:</big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big>$
git fetch origin <br>
$ git merge origin/next</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>If
you tried a pull which resulted in complex conflicts and
would want to start over, you can recover with <i>git
reset</i>.</big></big></font></p>

<h2>SECURITY
<a name="SECURITY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
fetch and push protocols are not designed to prevent one
side from stealing data from the other repository that was
not intended to be shared. If you have private data that you
need to protect from a malicious peer, your best option is
to store it in another repository. This applies to both
clients and servers. In particular, namespaces on a server
are not effective for read access control; you should only
grant read access to a namespace to clients that you would
trust with read access to the entire
repository.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
known attack vectors are as follows:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>1.
The victim sends &quot;have&quot; lines advertising the IDs
of objects it has that are not explicitly intended to be
shared but can be used to optimize the transfer if the peer
also has them. The attacker chooses an object ID X to steal
and sends a ref to X, but isn&rsquo;t required to send the
content of X because the victim already has it. Now the
victim believes that the attacker has X, and it sends the
content of X back to the attacker later. (This attack is
most straightforward for a client to perform on a server, by
creating a ref to X in the namespace the client has access
to and then fetching it. The most likely way for a server to
perform it on a client is to &quot;merge&quot; X into a
public branch and hope that the user does additional work on
this branch and pushes it back to the server without
noticing the merge.)</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>2.
As in #1, the attacker chooses an object ID X to steal. The
victim sends an object Y that the attacker already has, and
the attacker falsely claims to have X and not Y, so the
victim sends Y as a delta against X. The delta reveals
regions of X that are similar to Y to the
attacker.</big></big></font></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Using
--recurse-submodules can only fetch new commits in already
checked out submodules right now. When e.g. upstream added a
new submodule in the just fetched commits of the
superproject the submodule itself cannot be fetched, making
it impossible to check out that submodule later without
having to do a fetch again. This is expected to be fixed in
a future Git version.</big></big></font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><a href="https://man.page/1/git-fetch">git-fetch(1)</a>,
<a href="https://man.page/1/git-merge">git-merge(1)</a>,
<a href="https://man.page/1/git-config">git-config(1)</a></big></big></font></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Part
of the <a href="https://man.page/1/git">git(1)</a> suite</big></big></font></p>
<hr>
</body>
</html>
