<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon Nov  7 04:40:09 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DFU-PROGRAMMER</title>

</head>
<body>

<h1 align="center">DFU-PROGRAMMER</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SUPPORTED MICROCONTROLLERS">SUPPORTED MICROCONTROLLERS</a><br>
<a href="#USAGE">USAGE</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#KNOWN ISSUES">KNOWN ISSUES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">dfu-programmer
- USB firmware upgrading for Atmel microcontrollers</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>dfu-programmer</b>
target[:usb-bus,usb-addr] command [options] [parameters]
<b><br>
dfu-programmer</b> --help <b><br>
dfu-programmer</b> --targets <b><br>
dfu-programmer</b> --version</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>dfu-programmer</b>
is a multi-platform command line Device Firmware Upgrade
(DFU) based programmer for the flash memory on Atmel AVR,
AVR32, XMEGA and 8051 based microcontrollers which ship with
a USB boot loader. It supports In System Programming (ISP)
for developers and potentially product updates in the field.
Those boot loaders are patterned after the standard USB DFU
1.0 class specification, but depend on extensions defined by
Atmel to the extent that standard DFU drivers will not
work.</p>

<p style="margin-left:11%; margin-top: 1em">To use it,
first connect the device to be programmed and ensure that it
comes up in DFU mode. The microcontrollers come up in that
mode as shipped by Atmel; or they may reenter that mode
after a special hardware reset. Then invoke this program to
issue one or more DFU commands. You will normally need to
start by issuing the &quot;erase&quot; command; the default
security policies prevent extracting firmware, to prevent
reverse engineering of what is usually proprietary code.</p>

<h2>SUPPORTED MICROCONTROLLERS
<a name="SUPPORTED MICROCONTROLLERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These chip
names are used as the command line &quot;target&quot;
parameter. <br>
8051 based controllers:</p>

<p style="margin-left:22%;">at89c51snd1c, at89c51snd2c,
at89c5130, at89c5131, and at89c5132.</p>

<p style="margin-left:11%;">AVR based controllers:</p>

<p style="margin-left:22%;">at90usb1287, at90usb1286,
at90usb647, at90usb646, at90usb162, at90usb82, atmega32u6,
atmega32u4, atmega32u2, atmega16u4, atmega16u2 and
atmega8u2.</p>

<p style="margin-left:11%;">AVR32 based controllers:</p>

<p style="margin-left:22%;">at32uc3a0128, at32uc3a1128,
at32uc3a0256, at32uc3a1256, at32uc3a0512, at32uc3a1512,
at32uc3a0512es, at32uc3a1512es, at32uc3a364, at32uc3a364s,
at32uc3a3128, at32uc3a3128s, at32uc3a3256, at32uc3a3256s,
at32uc3a4256s, at32uc3b064, at32uc3b164, at32uc3b0128,
at32uc3b1128, at32uc3b0256, at32uc3b1256, at32uc3b0256es,
at32uc3b1256es, at32uc3b1512, at32uc3b0512, at32uc3c064,
at32uc3c0128, at32uc3c0256, at32uc3c0512, at32uc3c164,
at32uc3c1128, at32uc3c1256, at32uc3c1512, at32uc3c264,
at32uc3c2128, at32uc3c2256 and at32uc3c2512.</p>

<p style="margin-left:11%;">XMEGA based controllers:</p>

<p style="margin-left:22%;">atxmega64a1u, atxmega128a1u,
atxmega64a3u, atxmega128a3u, atxmega192a3u, atxmega256a3u,
atxmega16a4u, atxmega32a4u, atxmega64a4u, atxmega128a4u,
atxmega256a3bu, atxmega64b1, atxmega128b1, atxmega64b3,
atxmega128b3, atxmega64c3, atxmega128c3, atxmega256c3,
atxmega384c3</p>

<h2>USAGE
<a name="USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are no
mechanisms to implement gang programming. By default, the
first device that matches the id codes for the given target
is selected. Many targets share the same id codes.
Accordingly, you will usually avoid connecting more than one
device of a given family (AVR, XMEGA, AVR32 or 8051) at a
time.</p>

<p style="margin-left:11%; margin-top: 1em">The target may
be qualified with the USB bus and address number of the
device you wish to program. This allows programming multiple
devices of the same family at the same time.</p>

<p style="margin-left:11%; margin-top: 1em">All of these
commands support the &quot;global options&quot;. Unless you
override it, commands which write to the microcontroller
will perform a validation step that rereads the data which
was written, compares it to the expected result, and reports
any errors.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
unlike Atmel&rsquo;s BatchISP program, dfu-programmer will
only perform a single operation at a time. Erasing and
programming require separate commands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>configure</b></p></td>
<td width="1%"></td>
<td width="57%">


<p style="margin-top: 1em">register [--suppress-validation]
data</p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:22%;">Bootloaders for 8051 based
controllers support writing certain configuration bytes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>dump</b></p></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:22%;">Reads all the available flash
memory, and writes it as binary data to stdout.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p style="margin-top: 1em"><b>dump-eeprom</b></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:22%;">Reads all the available eeprom
memory, and writes it as binary data to stdout.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>dump-user</b></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:22%;">Reads the user space flash on
the AVR32 chips and writes it as binary data to stdout.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>erase</b></p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em">[--suppress-validation]</p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:22%;">Erases all the flash memory.
This is required before the bootloader will perform other
commands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>flash</b></p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">[--suppress-validation]
[--suppress-bootloader-mem] [--serial=hexbytes:offset] file
or STDIN</p></td></tr>
</table>

<p style="margin-left:22%;">Writes flash memory. The input
file (or stdin) must use the &quot;ihex&quot; file format
convention for a memory image. --suppress-bootloader-mem
ignores any data written to the bootloader memory space when
flashing the device. This option is particularly useful for
the AVR32 chips <b>trampoline</b> code.</p>

<p style="margin-left:11%; margin-top: 1em">--serial
provides a way to inject a serial number or other unique
sequence of bytes into the memory image programmed into the
device. This allows using a single .ihex file to program
multiple devices, and still give each device its own unique
serial number. For example, --serial=ABCDEF01:0x6000 would
program the byte at 0x6000 with the hex value AB, the byte
at 0x6001 with the value CD, and so on. There must be an
even number of hex digits, but the sequence can be any
length. The offset is assumed to be given in hex if it
starts with a &quot;0x&quot; prefix, octal if it begins with
a &quot;0&quot;, otherwise is it assumed to be decimal.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p style="margin-top: 1em"><b>flash-user</b></p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">[--suppress-validation]
[--serial=hexbytes:offset] file or</p></td></tr>
</table>

<p style="margin-left:11%;">STDIN</p>

<p style="margin-left:22%;">Writes to user space flash on
the AVR32 chips. This block of flash is out of the normal
range of flash blocks and is designed to contain
configuration parameters. The input file (or stdin) must use
the &quot;ihex&quot; file format convention for a memory
image.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em"><b>flash-eeprom</b></p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em">[--suppress-validation]
[--serial=hexbytes:offset] file or</p></td></tr>
</table>

<p style="margin-left:11%;">STDIN</p>

<p style="margin-left:22%;">Writes to eeprom memory. The
input file (or stdin) must use the &quot;ihex&quot; file
format convention for a memory image.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>setsecure</b></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:22%;">Sets the security bit on AVR32
chips. This prevents the content being read back from the
chip, except in the same session in which it was programmed.
When the security fuse is set, almost nothing will work
without first executing the erase command. The only way to
clear the security fuse once set is to use a JTAG chip
erase, which will also erase the bootloader.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>get</b></p></td>
<td width="2%"></td>
<td width="12%">


<p style="margin-top: 1em">register</p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:22%;">Displays various product
identifier bytes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>reset</b></p></td>
<td width="82%">
</td></tr>
</table>

<p style="margin-left:22%;">Resets microcontroller using
watchdog timer</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>start</b></p></td>
<td width="82%">
</td></tr>
</table>

<p style="margin-left:22%;">Starts the application firmware
by having the microcontroller jump to address zero.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Global
Options</b> <br>
--quiet - minimizes the output</p>

<p style="margin-left:11%; margin-top: 1em">--debug level -
enables verbose output at the specified level</p>

<p style="margin-left:11%; margin-top: 1em"><b>Configure
Registers</b> <br>
The standard bootloader for 8051 based chips supports
writing data bytes which are not relevant for the AVR based
chips.</p>

<p style="margin-left:11%; margin-top: 1em">BSB - boot
status byte <br>
SBV - software boot vector <br>
SSB - software security byte <br>
EB - extra byte <br>
HSB - hardware security byte</p>

<p style="margin-left:11%; margin-top: 1em"><b>Get
Register</b> <br>
bootloader-version - currently flashed bootloader version
<br>
ID1 - device boot identification 1 <br>
ID2 - device boot identification 2 <br>
manufacturer - the hardware manufacturer code <br>
family - the product family code <br>
product-name - the product name <br>
product-revision - the product revision <br>
HSB - same as the configure_register version <br>
BSB - same as the configure_register version <br>
SBV - same as the configure_register version <br>
SSB - same as the configure_register version <br>
EB - same as the configure_register version</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None known.</p>

<h2>KNOWN ISSUES
<a name="KNOWN ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The at90usb
series chips do not make available any read/write protect
flags so the <b>dump</b> or <b>flash</b> command may fail
with a less than helpful error message.</p>

<p style="margin-left:11%; margin-top: 1em">To remove
<b>any</b> write or read protection from any chips, a full
chip erasure is required. For AVR32 chips an erase operation
over USB will remove protection until the device is
rebooted. To remove the protection more permanently requires
a JTAG erase (which will also erase the bootloader).</p>

<p style="margin-left:11%; margin-top: 1em">You may need to
be a member of the <b>uucp</b> group in order to have access
to the device without needing to be root.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Weston Schmidt
&lt;weston_schmidt@alumni.purdue.edu&gt;</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<hr>
</body>
</html>
