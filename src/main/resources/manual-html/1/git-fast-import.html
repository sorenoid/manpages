<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon Nov  7 04:39:19 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT-FAST-IMPORT</title>

</head>
<body>

<h1 align="center">GIT-FAST-IMPORT</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#PERFORMANCE">PERFORMANCE</a><br>
<a href="#DEVELOPMENT COST">DEVELOPMENT COST</a><br>
<a href="#PARALLEL OPERATION">PARALLEL OPERATION</a><br>
<a href="#TECHNICAL DISCUSSION">TECHNICAL DISCUSSION</a><br>
<a href="#INPUT FORMAT">INPUT FORMAT</a><br>
<a href="#RESPONSES TO COMMANDS">RESPONSES TO COMMANDS</a><br>
<a href="#CRASH REPORTS">CRASH REPORTS</a><br>
<a href="#TIPS AND TRICKS">TIPS AND TRICKS</a><br>
<a href="#PACKFILE OPTIMIZATION">PACKFILE OPTIMIZATION</a><br>
<a href="#MEMORY UTILIZATION">MEMORY UTILIZATION</a><br>
<a href="#SIGNALS">SIGNALS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">git-fast-import
- Backend for fast Git data importers</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">frontend |
<i>git fast-import</i> [&lt;options&gt;]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
usually not what the end user wants to run directly. Most
end users want to use one of the existing frontend programs,
which parses a specific type of foreign source and feeds the
contents stored there to <i>git fast-import</i>.</p>

<p style="margin-left:11%; margin-top: 1em">fast-import
reads a mixed command/data stream from standard input and
writes one or more packfiles directly into the current
repository. When EOF is received on standard input, fast
import writes out updated branch and tag refs, fully
updating the current repository with the newly imported
data.</p>

<p style="margin-left:11%; margin-top: 1em">The fast-import
backend itself can import into an empty repository (one that
has already been initialized by <i>git init</i>) or
incrementally update an existing populated repository.
Whether or not incremental imports are supported from a
particular foreign source depends on the frontend program in
use.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">--force</p>

<p style="margin-left:17%;">Force updating modified
existing branches, even if doing so would cause commits to
be lost (as the new commit does not contain the old
commit).</p>

<p style="margin-left:11%; margin-top: 1em">--quiet</p>

<p style="margin-left:17%;">Disable the output shown by
--stats, making fast-import usually be silent when it is
successful. However, if the import stream has directives
intended to show user output (e.g. <b>progress</b>
directives), the corresponding messages will still be
shown.</p>

<p style="margin-left:11%; margin-top: 1em">--stats</p>

<p style="margin-left:17%;">Display some basic statistics
about the objects fast-import has created, the packfiles
they were stored into, and the memory used by fast-import
during this run. Showing this output is currently the
default, but can be disabled with --quiet.</p>


<p style="margin-left:11%; margin-top: 1em">--allow-unsafe-features</p>

<p style="margin-left:17%;">Many command-line options can
be provided as part of the fast-import stream itself by
using the <b>feature</b> or <b>option</b> commands. However,
some of these options are unsafe (e.g., allowing fast-import
to access the filesystem outside of the repository). These
options are disabled by default, but can be allowed by
providing this option on the command line. This currently
impacts only the <b>export-marks</b>, <b>import-marks</b>,
and <b>import-marks-if-exists</b> feature commands.</p>

<p style="margin-left:23%; margin-top: 1em">Only enable
this option if you trust the program generating the <br>
fast-import stream! This option is enabled automatically for
<br>
remote-helpers that use the &rsquo;import&rsquo; capability,
as they are <br>
already trusted to run their own code.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options for
Frontends</b> <br>
--cat-blob-fd=&lt;fd&gt;</p>

<p style="margin-left:17%;">Write responses to
<b>get-mark</b>, <b>cat-blob</b>, and <b>ls</b> queries to
the file descriptor &lt;fd&gt; instead of <b>stdout</b>.
Allows <b>progress</b> output intended for the end-user to
be separated from other output.</p>


<p style="margin-left:11%; margin-top: 1em">--date-format=&lt;fmt&gt;</p>

<p style="margin-left:17%;">Specify the type of dates the
frontend will supply to fast-import within <b>author</b>,
<b>committer</b> and <b>tagger</b> commands. See &ldquo;Date
Formats&rdquo; below for details about which formats are
supported, and their syntax.</p>

<p style="margin-left:11%; margin-top: 1em">--done</p>

<p style="margin-left:17%;">Terminate with error if there
is no <b>done</b> command at the end of the stream. This
option might be useful for detecting errors that cause the
frontend to terminate before it has started to write a
stream.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Locations of
Marks Files</b> <br>
--export-marks=&lt;file&gt;</p>

<p style="margin-left:17%;">Dumps the internal marks table
to &lt;file&gt; when complete. Marks are written one per
line as <b>:markid SHA-1</b>. Frontends can use this file to
validate imports after they have been completed, or to save
the marks table across incremental runs. As &lt;file&gt; is
only opened and truncated at checkpoint (or completion) the
same path can also be safely given to --import-marks.</p>


<p style="margin-left:11%; margin-top: 1em">--import-marks=&lt;file&gt;</p>

<p style="margin-left:17%;">Before processing any input,
load the marks specified in &lt;file&gt;. The input file
must exist, must be readable, and must use the same format
as produced by --export-marks. Multiple options may be
supplied to import more than one set of marks. If a mark is
defined to different values, the last file wins.</p>


<p style="margin-left:11%; margin-top: 1em">--import-marks-if-exists=&lt;file&gt;</p>

<p style="margin-left:17%;">Like --import-marks but instead
of erroring out, silently skips the file if it does not
exist.</p>


<p style="margin-left:11%; margin-top: 1em">--[no-]relative-marks</p>

<p style="margin-left:17%;">After specifying
--relative-marks the paths specified with --import-marks=
and --export-marks= are relative to an internal directory in
the current repository. In git-fast-import this means that
the paths are relative to the .git/info/fast-import
directory. However, other importers may use a different
location.</p>

<p style="margin-left:17%; margin-top: 1em">Relative and
non-relative marks may be combined by interweaving
--(no-)-relative-marks with the --(import|export)-marks=
options.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Submodule
Rewriting</b> <br>
--rewrite-submodules-from=&lt;name&gt;:&lt;file&gt;,
--rewrite-submodules-to=&lt;name&gt;:&lt;file&gt;</p>

<p style="margin-left:17%;">Rewrite the object IDs for the
submodule specified by &lt;name&gt; from the values used in
the from &lt;file&gt; to those used in the to &lt;file&gt;.
The from marks should have been created by <b>git
fast-export</b>, and the to marks should have been created
by <b>git fast-import</b> when importing that same
submodule.</p>

<p style="margin-left:17%; margin-top: 1em">&lt;name&gt;
may be any arbitrary string not containing a colon
character, but the same value must be used with both options
when specifying corresponding marks. Multiple submodules may
be specified with different values for &lt;name&gt;. It is
an error not to use these options in corresponding
pairs.</p>

<p style="margin-left:17%; margin-top: 1em">These options
are primarily useful when converting a repository from one
hash algorithm to another; without them, fast-import will
fail if it encounters a submodule because it has no way of
writing the object ID into the new hash algorithm.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Performance
and Compression Tuning</b> <br>
--active-branches=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum number of branches to
maintain active at once. See &ldquo;Memory
Utilization&rdquo; below for details. Default is 5.</p>


<p style="margin-left:11%; margin-top: 1em">--big-file-threshold=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum size of a blob that
fast-import will attempt to create a delta for, expressed in
bytes. The default is 512m (512 MiB). Some importers may
wish to lower this on systems with constrained memory.</p>


<p style="margin-left:11%; margin-top: 1em">--depth=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum delta depth, for blob
and tree deltification. Default is 50.</p>


<p style="margin-left:11%; margin-top: 1em">--export-pack-edges=&lt;file&gt;</p>

<p style="margin-left:17%;">After creating a packfile,
print a line of data to &lt;file&gt; listing the filename of
the packfile and the last commit on each branch that was
written to that packfile. This information may be useful
after importing projects whose total object set exceeds the
4 GiB packfile limit, as these commits can be used as edge
points during calls to <i>git pack-objects</i>.</p>


<p style="margin-left:11%; margin-top: 1em">--max-pack-size=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum size of each output
packfile. The default is unlimited.</p>


<p style="margin-left:11%; margin-top: 1em">fastimport.unpackLimit</p>

<p style="margin-left:17%;">See <b>git-config</b>(1)</p>

<h2>PERFORMANCE
<a name="PERFORMANCE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The design of
fast-import allows it to import large projects in a minimum
amount of memory usage and processing time. Assuming the
frontend is able to keep up with fast-import and feed it a
constant stream of data, import times for projects holding
10+ years of history and containing 100,000+ individual
commits are generally completed in just 1-2 hours on quite
modest (~$2,000 USD) hardware.</p>

<p style="margin-left:11%; margin-top: 1em">Most
bottlenecks appear to be in foreign source data access (the
source just cannot extract revisions fast enough) or disk IO
(fast-import writes as fast as the disk will take the data).
Imports will run faster if the source data is stored on a
different drive than the destination Git repository (due to
less IO contention).</p>

<h2>DEVELOPMENT COST
<a name="DEVELOPMENT COST"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A typical
frontend for fast-import tends to weigh in at approximately
200 lines of Perl/Python/Ruby code. Most developers have
been able to create working importers in just a couple of
hours, even though it is their first exposure to
fast-import, and sometimes even to Git. This is an ideal
situation, given that most conversion tools are throw-away
(use once, and never look back).</p>

<h2>PARALLEL OPERATION
<a name="PARALLEL OPERATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Like <i>git
push</i> or <i>git fetch</i>, imports handled by fast-import
are safe to run alongside parallel <b>git repack -a -d</b>
or <b>git gc</b> invocations, or any other Git operation
(including <i>git prune</i>, as loose objects are never used
by fast-import).</p>

<p style="margin-left:11%; margin-top: 1em">fast-import
does not lock the branch or tag refs it is actively
importing. After the import, during its ref update phase,
fast-import tests each existing branch ref to verify the
update will be a fast-forward update (the commit stored in
the ref is contained in the new history of the commit to be
written). If the update is not a fast-forward update,
fast-import will skip updating that ref and instead prints a
warning message. fast-import will always attempt to update
all branch refs, and does not stop on the first failure.</p>

<p style="margin-left:11%; margin-top: 1em">Branch updates
can be forced with --force, but it&rsquo;s recommended that
this only be used on an otherwise quiet repository. Using
--force is not necessary for an initial import into an empty
repository.</p>

<h2>TECHNICAL DISCUSSION
<a name="TECHNICAL DISCUSSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">fast-import
tracks a set of branches in memory. Any branch can be
created or modified at any point during the import process
by sending a <b>commit</b> command on the input stream. This
design allows a frontend program to process an unlimited
number of branches simultaneously, generating commits in the
order they are available from the source data. It also
simplifies the frontend programs considerably.</p>

<p style="margin-left:11%; margin-top: 1em">fast-import
does not use or alter the current working directory, or any
file within it. (It does however update the current Git
repository, as referenced by <b>GIT_DIR</b>.) Therefore an
import frontend may use the working directory for its own
purposes, such as extracting file revisions from the foreign
source. This ignorance of the working directory also allows
fast-import to run very quickly, as it does not need to
perform any costly file update operations when switching
between branches.</p>

<h2>INPUT FORMAT
<a name="INPUT FORMAT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">With the
exception of raw file data (which Git does not interpret)
the fast-import input format is text (ASCII) based. This
text based format simplifies development and debugging of
frontend programs, especially when a higher level language
such as Perl, Python or Ruby is being used.</p>

<p style="margin-left:11%; margin-top: 1em">fast-import is
very strict about its input. Where we say SP below we mean
<b>exactly</b> one space. Likewise LF means one (and only
one) linefeed and HT one (and only one) horizontal tab.
Supplying additional whitespace characters will cause
unexpected results, such as branch names or file names with
leading or trailing spaces in their name, or early
termination of fast-import when it encounters unexpected
input.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Stream
Comments</b> <br>
To aid in debugging frontends fast-import ignores any line
that begins with <b>#</b> (ASCII pound/hash) up to and
including the line ending <b>LF</b>. A comment line may
contain any sequence of bytes that does not contain an LF
and therefore may be used to include any detailed debugging
information that might be specific to the frontend and
useful when inspecting a fast-import data stream.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Date
Formats</b> <br>
The following date formats are supported. A frontend should
select the format it will use for this import by passing the
format name in the --date-format=&lt;fmt&gt; command-line
option.</p>

<p style="margin-left:11%; margin-top: 1em"><b>raw</b></p>

<p style="margin-left:17%;">This is the Git native format
and is <b>&lt;time&gt; SP &lt;offutc&gt;</b>. It is also
fast-import&rsquo;s default format, if --date-format was not
specified.</p>

<p style="margin-left:17%; margin-top: 1em">The time of the
event is specified by <b>&lt;time&gt;</b> as the number of
seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC)
and is written as an ASCII decimal integer.</p>

<p style="margin-left:17%; margin-top: 1em">The local
offset is specified by <b>&lt;offutc&gt;</b> as a positive
or negative offset from UTC. For example EST (which is 5
hours behind UTC) would be expressed in <b>&lt;tz&gt;</b> by
&ldquo;-0500&rdquo; while UTC is &ldquo;+0000&rdquo;. The
local offset does not affect <b>&lt;time&gt;</b>; it is used
only as an advisement to help formatting routines display
the timestamp.</p>

<p style="margin-left:17%; margin-top: 1em">If the local
offset is not available in the source material, use
&ldquo;+0000&rdquo;, or the most common local offset. For
example many organizations have a CVS repository which has
only ever been accessed by users who are located in the same
location and time zone. In this case a reasonable offset
from UTC could be assumed.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike the
<b>rfc2822</b> format, this format is very strict. Any
variation in formatting will cause fast-import to reject the
value, and some sanity checks on the numeric values may also
be performed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>raw-permissive</b></p>

<p style="margin-left:17%;">This is the same as <b>raw</b>
except that no sanity checks on the numeric epoch and local
offset are performed. This can be useful when trying to
filter or import an existing history with e.g. bogus
timezone values.</p>


<p style="margin-left:11%; margin-top: 1em"><b>rfc2822</b></p>

<p style="margin-left:17%;">This is the standard email
format as described by RFC 2822.</p>

<p style="margin-left:17%; margin-top: 1em">An example
value is &ldquo;Tue Feb 6 11:22:18 2007 -0500&rdquo;. The
Git parser is accurate, but a little on the lenient side. It
is the same parser used by <i>git am</i> when applying
patches received from email.</p>

<p style="margin-left:17%; margin-top: 1em">Some malformed
strings may be accepted as valid dates. In some of these
cases Git will still be able to obtain the correct date from
the malformed string. There are also some types of malformed
strings which Git will parse wrong, and yet consider valid.
Seriously malformed strings will be rejected.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike the
<b>raw</b> format above, the time zone/UTC offset
information contained in an RFC 2822 date string is used to
adjust the date value to UTC prior to storage. Therefore it
is important that this information be as accurate as
possible.</p>

<p style="margin-left:17%; margin-top: 1em">If the source
material uses RFC 2822 style dates, the frontend should let
fast-import handle the parsing and conversion (rather than
attempting to do it itself) as the Git parser has been well
tested in the wild.</p>

<p style="margin-left:17%; margin-top: 1em">Frontends
should prefer the <b>raw</b> format if the source material
already uses UNIX-epoch format, can be coaxed to give dates
in that format, or its format is easily convertible to it,
as there is no ambiguity in parsing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>now</b></p>

<p style="margin-left:17%;">Always use the current time and
time zone. The literal <b>now</b> must always be supplied
for <b>&lt;when&gt;</b>.</p>

<p style="margin-left:17%; margin-top: 1em">This is a toy
format. The current time and time zone of this system is
always copied into the identity string at the time it is
being created by fast-import. There is no way to specify a
different time or time zone.</p>

<p style="margin-left:17%; margin-top: 1em">This particular
format is supplied as it&rsquo;s short to implement and may
be useful to a process that wants to create a new commit
right now, without needing to use a working directory or
<i>git update-index</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If separate
<b>author</b> and <b>committer</b> commands are used in a
<b>commit</b> the timestamps may not match, as the system
clock will be polled twice (once for each command). The only
way to ensure that both author and committer identity
information has the same timestamp is to omit <b>author</b>
(thus copying from <b>committer</b>) or to use a date format
other than <b>now</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Commands</b>
<br>
fast-import accepts several commands to update the current
repository and control the current import process. More
detailed discussion (with examples) of each command follows
later.</p>


<p style="margin-left:11%; margin-top: 1em"><b>commit</b></p>

<p style="margin-left:17%;">Creates a new branch or updates
an existing branch by creating a new commit and updating the
branch to point at the newly created commit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>tag</b></p>

<p style="margin-left:17%;">Creates an annotated tag object
from an existing commit or branch. Lightweight tags are not
supported by this command, as they are not recommended for
recording meaningful points in time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>reset</b></p>

<p style="margin-left:17%;">Reset an existing branch (or a
new branch) to a specific revision. This command must be
used to change a branch to a specific revision without
making a commit on it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>blob</b></p>

<p style="margin-left:17%;">Convert raw file data into a
blob, for future use in a <b>commit</b> command. This
command is optional and is not needed to perform an
import.</p>


<p style="margin-left:11%; margin-top: 1em"><b>alias</b></p>

<p style="margin-left:17%;">Record that a mark refers to a
given object without first creating any new object. Using
--import-marks and referring to missing marks will cause
fast-import to fail, so aliases can provide a way to set
otherwise pruned commits to a valid value (e.g. the nearest
non-pruned ancestor).</p>


<p style="margin-left:11%; margin-top: 1em"><b>checkpoint</b></p>

<p style="margin-left:17%;">Forces fast-import to close the
current packfile, generate its unique SHA-1 checksum and
index, and start a new packfile. This command is optional
and is not needed to perform an import.</p>


<p style="margin-left:11%; margin-top: 1em"><b>progress</b></p>

<p style="margin-left:17%;">Causes fast-import to echo the
entire line to its own standard output. This command is
optional and is not needed to perform an import.</p>


<p style="margin-left:11%; margin-top: 1em"><b>done</b></p>

<p style="margin-left:17%;">Marks the end of the stream.
This command is optional unless the <b>done</b> feature was
requested using the <b>--done</b> command-line option or
<b>feature done</b> command.</p>


<p style="margin-left:11%; margin-top: 1em"><b>get-mark</b></p>

<p style="margin-left:17%;">Causes fast-import to print the
SHA-1 corresponding to a mark to the file descriptor set
with <b>--cat-blob-fd</b>, or <b>stdout</b> if
unspecified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cat-blob</b></p>

<p style="margin-left:17%;">Causes fast-import to print a
blob in <i>cat-file --batch</i> format to the file
descriptor set with <b>--cat-blob-fd</b> or <b>stdout</b> if
unspecified.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ls</b></p>

<p style="margin-left:17%;">Causes fast-import to print a
line describing a directory entry in <i>ls-tree</i> format
to the file descriptor set with <b>--cat-blob-fd</b> or
<b>stdout</b> if unspecified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>feature</b></p>

<p style="margin-left:17%;">Enable the specified feature.
This requires that fast-import supports the specified
feature, and aborts if it does not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>option</b></p>

<p style="margin-left:17%;">Specify any of the options
listed under OPTIONS that do not change stream semantic to
suit the frontend&rsquo;s needs. This command is optional
and is not needed to perform an import.</p>

<p style="margin-left:11%; margin-top: 1em"><b>commit</b>
<br>
Create or update a branch with a new commit, recording one
logical change to the project.</p>

<p style="margin-left:17%; margin-top: 1em">'commit' SP
&lt;ref&gt; LF <br>
mark? <br>
original-oid? <br>
('author' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP
&lt;when&gt; LF)? <br>
'committer' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP
&lt;when&gt; LF <br>
('encoding' SP &lt;encoding&gt;)? <br>
data <br>
('from' SP &lt;commit-ish&gt; LF)? <br>
('merge' SP &lt;commit-ish&gt; LF)* <br>
(filemodify | filedelete | filecopy | filerename |
filedeleteall | notemodify)* <br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">where
<b>&lt;ref&gt;</b> is the name of the branch to make the
commit on. Typically branch names are prefixed with
<b>refs/heads/</b> in Git, so importing the CVS branch
symbol <b>RELENG-1_0</b> would use
<b>refs/heads/RELENG-1_0</b> for the value of
<b>&lt;ref&gt;</b>. The value of <b>&lt;ref&gt;</b> must be
a valid refname in Git. As <b>LF</b> is not valid in a Git
refname, no quoting or escaping syntax is supported
here.</p>

<p style="margin-left:11%; margin-top: 1em">A <b>mark</b>
command may optionally appear, requesting fast-import to
save a reference to the newly created commit for future use
by the frontend (see below for format). It is very common
for frontends to mark every commit they create, thereby
allowing future branch creation from any imported
commit.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>data</b>
command following <b>committer</b> must supply the commit
message (see below for <b>data</b> command syntax). To
import an empty commit message use a 0 length data. Commit
messages are free-form and are not interpreted by Git.
Currently they must be encoded in UTF-8, as fast-import does
not permit other encodings to be specified.</p>

<p style="margin-left:11%; margin-top: 1em">Zero or more
<b>filemodify</b>, <b>filedelete</b>, <b>filecopy</b>,
<b>filerename</b>, <b>filedeleteall</b> and
<b>notemodify</b> commands may be included to update the
contents of the branch prior to creating the commit. These
commands may be supplied in any order. However it is
recommended that a <b>filedeleteall</b> command precede all
<b>filemodify</b>, <b>filecopy</b>, <b>filerename</b> and
<b>notemodify</b> commands in the same commit, as
<b>filedeleteall</b> wipes the branch clean (see below).</p>

<p style="margin-left:11%; margin-top: 1em">The <b>LF</b>
after the command is optional (it used to be required). Note
that for reasons of backward compatibility, if the commit
ends with a <b>data</b> command (i.e. it has no <b>from</b>,
<b>merge</b>, <b>filemodify</b>, <b>filedelete</b>,
<b>filecopy</b>, <b>filerename</b>, <b>filedeleteall</b> or
<b>notemodify</b> commands) then two <b>LF</b> commands may
appear at the end of the command instead of just one.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>author</big></b></p>

<p style="margin-left:17%;">An <b>author</b> command may
optionally appear, if the author information might differ
from the committer information. If <b>author</b> is omitted
then fast-import will automatically use the
committer&rsquo;s information for the author portion of the
commit. See below for a description of the fields in
<b>author</b>, as they are identical to
<b>committer</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>committer</big></b></p>

<p style="margin-left:17%;">The <b>committer</b> command
indicates who made this commit, and when they made it.</p>

<p style="margin-left:17%; margin-top: 1em">Here
<b>&lt;name&gt;</b> is the person&rsquo;s display name (for
example &ldquo;Com M Itter&rdquo;) and <b>&lt;email&gt;</b>
is the person&rsquo;s email address
(&ldquo;cm@example.com&rdquo;). <b>LT</b> and <b>GT</b> are
the literal less-than (\x3c) and greater-than (\x3e)
symbols. These are required to delimit the email address
from the other fields in the line. Note that
<b>&lt;name&gt;</b> and <b>&lt;email&gt;</b> are free-form
and may contain any sequence of bytes, except <b>LT</b>,
<b>GT</b> and <b>LF</b>. <b>&lt;name&gt;</b> is typically
UTF-8 encoded.</p>

<p style="margin-left:17%; margin-top: 1em">The time of the
change is specified by <b>&lt;when&gt;</b> using the date
format that was selected by the --date-format=&lt;fmt&gt;
command-line option. See &ldquo;Date Formats&rdquo; above
for the set of supported formats, and their syntax.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>encoding</big></b></p>

<p style="margin-left:17%;">The optional <b>encoding</b>
command indicates the encoding of the commit message. Most
commits are UTF-8 and the encoding is omitted, but this
allows importing commit messages into git without first
reencoding them.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>from</big></b></p>

<p style="margin-left:17%;">The <b>from</b> command is used
to specify the commit to initialize this branch from. This
revision will be the first ancestor of the new commit. The
state of the tree built at this commit will begin with the
state at the <b>from</b> commit, and be altered by the
content modifications in this commit.</p>

<p style="margin-left:17%; margin-top: 1em">Omitting the
<b>from</b> command in the first commit of a new branch will
cause fast-import to create that commit with no ancestor.
This tends to be desired only for the initial commit of a
project. If the frontend creates all files from scratch when
making a new branch, a <b>merge</b> command may be used
instead of <b>from</b> to start the commit with an empty
tree. Omitting the <b>from</b> command on existing branches
is usually desired, as the current commit on that branch is
automatically assumed to be the first ancestor of the new
commit.</p>

<p style="margin-left:17%; margin-top: 1em">As <b>LF</b> is
not valid in a Git refname or SHA-1 expression, no quoting
or escaping syntax is supported within
<b>&lt;commit-ish&gt;</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Here
<b>&lt;commit-ish&gt;</b> is any of the following:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; The name
of an existing branch already in fast-import&rsquo;s
internal branch table. If fast-import doesn&rsquo;t know the
name, it&rsquo;s treated as a SHA-1 expression.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; A mark
reference, <b>:&lt;idnum&gt;</b>, where <b>&lt;idnum&gt;</b>
is the mark number.</p>

<p style="margin-left:23%; margin-top: 1em">The reason
fast-import uses <b>:</b> to denote a mark reference is this
character is not legal in a Git branch name. The leading
<b>:</b> makes it easy to distinguish between the mark 42
(<b>:42</b>) and the branch 42 (<b>42</b> or
<b>refs/heads/42</b>), or an abbreviated SHA-1 which
happened to consist only of base-10 digits.</p>

<p style="margin-left:23%; margin-top: 1em">Marks must be
declared (via <b>mark</b>) before they can be used.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; A
complete 40 byte or abbreviated commit SHA-1 in hex.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Any
valid Git SHA-1 expression that resolves to a commit. See
&ldquo;SPECIFYING REVISIONS&rdquo; in <b>gitrevisions</b>(7)
for details.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; The
special null SHA-1 (40 zeros) specifies that the branch is
to be removed.</p>

<p style="margin-left:17%; margin-top: 1em">The special
case of restarting an incremental import from the current
branch value should be written as:</p>

<p style="margin-left:23%; margin-top: 1em">from
refs/heads/branch^0</p>

<p style="margin-left:17%; margin-top: 1em">The <b>^0</b>
suffix is necessary as fast-import does not permit a branch
to start from itself, and the branch is created in memory
before the <b>from</b> command is even read from the input.
Adding <b>^0</b> will force fast-import to resolve the
commit through Git&rsquo;s revision parsing library, rather
than its internal branch table, thereby loading in the
existing value of the branch.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>merge</big></b></p>

<p style="margin-left:17%;">Includes one additional
ancestor commit. The additional ancestry link does not
change the way the tree state is built at this commit. If
the <b>from</b> command is omitted when creating a new
branch, the first <b>merge</b> commit will be the first
ancestor of the current commit, and the branch will start
out with no files. An unlimited number of <b>merge</b>
commands per commit are permitted by fast-import, thereby
establishing an n-way merge.</p>

<p style="margin-left:17%; margin-top: 1em">Here
<b>&lt;commit-ish&gt;</b> is any of the commit specification
expressions also accepted by <b>from</b> (see above).</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filemodify</big></b></p>

<p style="margin-left:17%;">Included in a <b>commit</b>
command to add a new file or change the content of an
existing file. This command has two different means of
specifying the content of the file.</p>

<p style="margin-left:17%; margin-top: 1em">External data
format</p>

<p style="margin-left:23%;">The data content for the file
was already supplied by a prior <b>blob</b> command. The
frontend just needs to connect it.</p>

<p style="margin-left:29%; margin-top: 1em">'M' SP
&lt;mode&gt; SP &lt;dataref&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:23%; margin-top: 1em">Here usually
<b>&lt;dataref&gt;</b> must be either a mark reference
(<b>:&lt;idnum&gt;</b>) set by a prior <b>blob</b> command,
or a full 40-byte SHA-1 of an existing Git blob object. If
<b>&lt;mode&gt;</b> is <b>040000&rsquo;</b> then
<b>&lt;dataref&gt;</b> must be the full 40-byte SHA-1 of an
existing Git tree object or a mark reference set with
<b>--import-marks</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Inline data
format</p>

<p style="margin-left:23%;">The data content for the file
has not been supplied yet. The frontend wants to supply it
as part of this modify command.</p>

<p style="margin-left:29%; margin-top: 1em">'M' SP
&lt;mode&gt; SP 'inline' SP &lt;path&gt; LF <br>
data</p>

<p style="margin-left:23%; margin-top: 1em">See below for a
detailed description of the <b>data</b> command.</p>

<p style="margin-left:17%; margin-top: 1em">In both formats
<b>&lt;mode&gt;</b> is the type of file entry, specified in
octal. Git only supports the following modes:</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>100644</b> or <b>644</b>: A normal (not-executable) file.
The majority of files in most projects use this mode. If in
doubt, this is what you want.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>100755</b> or <b>755</b>: A normal, but executable,
file.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>120000</b>: A symlink, the content of the file will be
the link target.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>160000</b>: A gitlink, SHA-1 of the object refers to a
commit in another repository. Git links can only be
specified by SHA or through a commit mark. They are used to
implement submodules.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>040000</b>: A subdirectory. Subdirectories can only be
specified by SHA or through a tree mark set with
<b>--import-marks</b>.</p>

<p style="margin-left:17%; margin-top: 1em">In both formats
<b>&lt;path&gt;</b> is the complete path of the file to be
added (if not already existing) or modified (if already
existing).</p>

<p style="margin-left:17%; margin-top: 1em">A
<b>&lt;path&gt;</b> string must use UNIX-style directory
separators (forward slash <b>/</b>), may contain any byte
other than <b>LF</b>, and must not start with double quote
(<b>&quot;</b>).</p>

<p style="margin-left:17%; margin-top: 1em">A path can use
C-style string quoting; this is accepted in all cases and
mandatory if the filename starts with double quote or
contains <b>LF</b>. In C-style quoting, the complete name
should be surrounded with double quotes, and any <b>LF</b>,
backslash, or double quote characters must be escaped by
preceding them with a backslash (e.g., <b>&quot;path/with\n,
\\ and \&quot; in it&quot;</b>).</p>

<p style="margin-left:17%; margin-top: 1em">The value of
<b>&lt;path&gt;</b> must be in canonical form. That is it
must not:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; contain
an empty directory component (e.g. <b>foo//bar</b> is
invalid),</p>

<p style="margin-left:23%; margin-top: 1em">&bull; end with
a directory separator (e.g. <b>foo/</b> is invalid),</p>

<p style="margin-left:23%; margin-top: 1em">&bull; start
with a directory separator (e.g. <b>/foo</b> is
invalid),</p>

<p style="margin-left:23%; margin-top: 1em">&bull; contain
the special component <b>.</b> or <b>..</b> (e.g.
<b>foo/./bar</b> and <b>foo/../bar</b> are invalid).</p>

<p style="margin-left:17%; margin-top: 1em">The root of the
tree can be represented by an empty string as
<b>&lt;path&gt;</b>.</p>

<p style="margin-left:17%; margin-top: 1em">It is
recommended that <b>&lt;path&gt;</b> always be encoded using
UTF-8.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filedelete</big></b></p>

<p style="margin-left:17%;">Included in a <b>commit</b>
command to remove a file or recursively delete an entire
directory from the branch. If the file or directory removal
makes its parent directory empty, the parent directory will
be automatically removed too. This cascades up the tree
until the first non-empty directory or the root is
reached.</p>

<p style="margin-left:23%; margin-top: 1em">'D' SP
&lt;path&gt; LF</p>

<p style="margin-left:17%; margin-top: 1em">here
<b>&lt;path&gt;</b> is the complete path of the file or
subdirectory to be removed from the branch. See
<b>filemodify</b> above for a detailed description of
<b>&lt;path&gt;</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filecopy</big></b></p>

<p style="margin-left:17%;">Recursively copies an existing
file or subdirectory to a different location within the
branch. The existing file or directory must exist. If the
destination exists it will be completely replaced by the
content copied from the source.</p>

<p style="margin-left:23%; margin-top: 1em">'C' SP
&lt;path&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:17%; margin-top: 1em">here the first
<b>&lt;path&gt;</b> is the source location and the second
<b>&lt;path&gt;</b> is the destination. See
<b>filemodify</b> above for a detailed description of what
<b>&lt;path&gt;</b> may look like. To use a source path that
contains SP the path must be quoted.</p>

<p style="margin-left:17%; margin-top: 1em">A
<b>filecopy</b> command takes effect immediately. Once the
source location has been copied to the destination any
future commands applied to the source location will not
impact the destination of the copy.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filerename</big></b></p>

<p style="margin-left:17%;">Renames an existing file or
subdirectory to a different location within the branch. The
existing file or directory must exist. If the destination
exists it will be replaced by the source directory.</p>

<p style="margin-left:23%; margin-top: 1em">'R' SP
&lt;path&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:17%; margin-top: 1em">here the first
<b>&lt;path&gt;</b> is the source location and the second
<b>&lt;path&gt;</b> is the destination. See
<b>filemodify</b> above for a detailed description of what
<b>&lt;path&gt;</b> may look like. To use a source path that
contains SP the path must be quoted.</p>

<p style="margin-left:17%; margin-top: 1em">A
<b>filerename</b> command takes effect immediately. Once the
source location has been renamed to the destination any
future commands applied to the source location will create
new files there and not impact the destination of the
rename.</p>

<p style="margin-left:17%; margin-top: 1em">Note that a
<b>filerename</b> is the same as a <b>filecopy</b> followed
by a <b>filedelete</b> of the source location. There is a
slight performance advantage to using <b>filerename</b>, but
the advantage is so small that it is never worth trying to
convert a delete/add pair in source material into a rename
for fast-import. This <b>filerename</b> command is provided
just to simplify frontends that already have rename
information and don&rsquo;t want bother with decomposing it
into a <b>filecopy</b> followed by a <b>filedelete</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filedeleteall</big></b></p>

<p style="margin-left:17%;">Included in a <b>commit</b>
command to remove all files (and also all directories) from
the branch. This command resets the internal branch
structure to have no files in it, allowing the frontend to
subsequently add all interesting files from scratch.</p>

<p style="margin-left:23%; margin-top: 1em">'deleteall'
LF</p>

<p style="margin-left:17%; margin-top: 1em">This command is
extremely useful if the frontend does not know (or does not
care to know) what files are currently on the branch, and
therefore cannot generate the proper <b>filedelete</b>
commands to update the content.</p>

<p style="margin-left:17%; margin-top: 1em">Issuing a
<b>filedeleteall</b> followed by the needed
<b>filemodify</b> commands to set the correct content will
produce the same results as sending only the needed
<b>filemodify</b> and <b>filedelete</b> commands. The
<b>filedeleteall</b> approach may however require
fast-import to use slightly more memory per active branch
(less than 1 MiB for even most large projects); so frontends
that can easily obtain only the affected paths for a commit
are encouraged to do so.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>notemodify</big></b></p>

<p style="margin-left:17%;">Included in a <b>commit
&lt;notes_ref&gt;</b> command to add a new note annotating a
<b>&lt;commit-ish&gt;</b> or change this annotation
contents. Internally it is similar to filemodify 100644 on
<b>&lt;commit-ish&gt;</b> path (maybe split into
subdirectories). It&rsquo;s not advised to use any other
commands to write to the <b>&lt;notes_ref&gt;</b> tree
except <b>filedeleteall</b> to delete all existing notes in
this tree. This command has two different means of
specifying the content of the note.</p>

<p style="margin-left:17%; margin-top: 1em">External data
format</p>

<p style="margin-left:23%;">The data content for the note
was already supplied by a prior <b>blob</b> command. The
frontend just needs to connect it to the commit that is to
be annotated.</p>

<p style="margin-left:29%; margin-top: 1em">'N' SP
&lt;dataref&gt; SP &lt;commit-ish&gt; LF</p>

<p style="margin-left:23%; margin-top: 1em">Here
<b>&lt;dataref&gt;</b> can be either a mark reference
(<b>:&lt;idnum&gt;</b>) set by a prior <b>blob</b> command,
or a full 40-byte SHA-1 of an existing Git blob object.</p>

<p style="margin-left:17%; margin-top: 1em">Inline data
format</p>

<p style="margin-left:23%;">The data content for the note
has not been supplied yet. The frontend wants to supply it
as part of this modify command.</p>

<p style="margin-left:29%; margin-top: 1em">'N' SP 'inline'
SP &lt;commit-ish&gt; LF <br>
data</p>

<p style="margin-left:23%; margin-top: 1em">See below for a
detailed description of the <b>data</b> command.</p>

<p style="margin-left:17%; margin-top: 1em">In both formats
<b>&lt;commit-ish&gt;</b> is any of the commit specification
expressions also accepted by <b>from</b> (see above).</p>

<p style="margin-left:11%; margin-top: 1em"><b>mark</b>
<br>
Arranges for fast-import to save a reference to the current
object, allowing the frontend to recall this object at a
future point in time, without knowing its SHA-1. Here the
current object is the object creation command the
<b>mark</b> command appears within. This can be
<b>commit</b>, <b>tag</b>, and <b>blob</b>, but
<b>commit</b> is the most common usage.</p>

<p style="margin-left:17%; margin-top: 1em">'mark' SP ':'
&lt;idnum&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">where
<b>&lt;idnum&gt;</b> is the number assigned by the frontend
to this mark. The value of <b>&lt;idnum&gt;</b> is expressed
as an ASCII decimal integer. The value 0 is reserved and
cannot be used as a mark. Only values greater than or equal
to 1 may be used as marks.</p>

<p style="margin-left:11%; margin-top: 1em">New marks are
created automatically. Existing marks can be moved to
another object simply by reusing the same
<b>&lt;idnum&gt;</b> in another <b>mark</b> command.</p>


<p style="margin-left:11%; margin-top: 1em"><b>original-oid</b>
<br>
Provides the name of the object in the original source
control system. fast-import will simply ignore this
directive, but filter processes which operate on and modify
the stream before feeding to fast-import may have uses for
this information</p>

<p style="margin-left:17%; margin-top: 1em">'original-oid'
SP &lt;object-identifier&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">where
<b>&lt;object-identifier&gt;</b> is any string not
containing LF.</p>

<p style="margin-left:11%; margin-top: 1em"><b>tag</b> <br>
Creates an annotated tag referring to a specific commit. To
create lightweight (non-annotated) tags see the <b>reset</b>
command below.</p>

<p style="margin-left:17%; margin-top: 1em">'tag' SP
&lt;name&gt; LF <br>
mark? <br>
'from' SP &lt;commit-ish&gt; LF <br>
original-oid? <br>
'tagger' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP
&lt;when&gt; LF <br>
data</p>

<p style="margin-left:11%; margin-top: 1em">where
<b>&lt;name&gt;</b> is the name of the tag to create.</p>

<p style="margin-left:11%; margin-top: 1em">Tag names are
automatically prefixed with <b>refs/tags/</b> when stored in
Git, so importing the CVS branch symbol
<b>RELENG-1_0-FINAL</b> would use just
<b>RELENG-1_0-FINAL</b> for <b>&lt;name&gt;</b>, and
fast-import will write the corresponding ref as
<b>refs/tags/RELENG-1_0-FINAL</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The value of
<b>&lt;name&gt;</b> must be a valid refname in Git and
therefore may contain forward slashes. As <b>LF</b> is not
valid in a Git refname, no quoting or escaping syntax is
supported here.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>from</b>
command is the same as in the <b>commit</b> command; see
above for details.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>tagger</b> command uses the same format as
<b>committer</b> within <b>commit</b>; again see above for
details.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>data</b>
command following <b>tagger</b> must supply the annotated
tag message (see below for <b>data</b> command syntax). To
import an empty tag message use a 0 length data. Tag
messages are free-form and are not interpreted by Git.
Currently they must be encoded in UTF-8, as fast-import does
not permit other encodings to be specified.</p>

<p style="margin-left:11%; margin-top: 1em">Signing
annotated tags during import from within fast-import is not
supported. Trying to include your own PGP/GPG signature is
not recommended, as the frontend does not (easily) have
access to the complete set of bytes which normally goes into
such a signature. If signing is required, create lightweight
tags from within fast-import with <b>reset</b>, then create
the annotated versions of those tags offline with the
standard <i>git tag</i> process.</p>

<p style="margin-left:11%; margin-top: 1em"><b>reset</b>
<br>
Creates (or recreates) the named branch, optionally starting
from a specific revision. The reset command allows a
frontend to issue a new <b>from</b> command for an existing
branch, or to create a new branch from an existing commit
without creating a new commit.</p>

<p style="margin-left:17%; margin-top: 1em">'reset' SP
&lt;ref&gt; LF <br>
('from' SP &lt;commit-ish&gt; LF)? <br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">For a detailed
description of <b>&lt;ref&gt;</b> and
<b>&lt;commit-ish&gt;</b> see above under <b>commit</b> and
<b>from</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>LF</b>
after the command is optional (it used to be required).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>reset</b> command can also be used to create lightweight
(non-annotated) tags. For example:</p>

<p style="margin-left:17%; margin-top: 1em">reset
refs/tags/938 <br>
from :938</p>

<p style="margin-left:11%; margin-top: 1em">would create
the lightweight tag <b>refs/tags/938</b> referring to
whatever commit mark <b>:938</b> references.</p>

<p style="margin-left:11%; margin-top: 1em"><b>blob</b>
<br>
Requests writing one file revision to the packfile. The
revision is not connected to any commit; this connection
must be formed in a subsequent <b>commit</b> command by
referencing the blob through an assigned mark.</p>

<p style="margin-left:17%; margin-top: 1em">'blob' LF <br>
mark? <br>
original-oid? <br>
data</p>

<p style="margin-left:11%; margin-top: 1em">The mark
command is optional here as some frontends have chosen to
generate the Git SHA-1 for the blob on their own, and feed
that directly to <b>commit</b>. This is typically more work
than it&rsquo;s worth however, as marks are inexpensive to
store and easy to use.</p>

<p style="margin-left:11%; margin-top: 1em"><b>data</b>
<br>
Supplies raw data (for use as blob/file content, commit
messages, or annotated tag messages) to fast-import. Data
can be supplied using an exact byte count or delimited with
a terminating line. Real frontends intended for
production-quality conversions should always use the exact
byte count format, as it is more robust and performs better.
The delimited format is intended primarily for testing
fast-import.</p>

<p style="margin-left:11%; margin-top: 1em">Comment lines
appearing within the <b>&lt;raw&gt;</b> part of <b>data</b>
commands are always taken to be part of the body of the data
and are therefore never ignored by fast-import. This makes
it safe to import any file/message content whose lines might
start with <b>#</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Exact byte
count format</p>

<p style="margin-left:17%;">The frontend must specify the
number of bytes of data.</p>

<p style="margin-left:23%; margin-top: 1em">'data' SP
&lt;count&gt; LF <br>
&lt;raw&gt; LF?</p>

<p style="margin-left:17%; margin-top: 1em">where
<b>&lt;count&gt;</b> is the exact number of bytes appearing
within <b>&lt;raw&gt;</b>. The value of <b>&lt;count&gt;</b>
is expressed as an ASCII decimal integer. The <b>LF</b> on
either side of <b>&lt;raw&gt;</b> is not included in
<b>&lt;count&gt;</b> and will not be included in the
imported data.</p>

<p style="margin-left:17%; margin-top: 1em">The <b>LF</b>
after <b>&lt;raw&gt;</b> is optional (it used to be
required) but recommended. Always including it makes
debugging a fast-import stream easier as the next command
always starts in column 0 of the next line, even if
<b>&lt;raw&gt;</b> did not end with an <b>LF</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Delimited
format</p>

<p style="margin-left:17%;">A delimiter string is used to
mark the end of the data. fast-import will compute the
length by searching for the delimiter. This format is
primarily useful for testing and is not recommended for real
data.</p>

<p style="margin-left:23%; margin-top: 1em">'data' SP
'&lt;&lt;' &lt;delim&gt; LF <br>
&lt;raw&gt; LF <br>
&lt;delim&gt; LF <br>
LF?</p>

<p style="margin-left:17%; margin-top: 1em">where
<b>&lt;delim&gt;</b> is the chosen delimiter string. The
string <b>&lt;delim&gt;</b> must not appear on a line by
itself within <b>&lt;raw&gt;</b>, as otherwise fast-import
will think the data ends earlier than it really does. The
<b>LF</b> immediately trailing <b>&lt;raw&gt;</b> is part of
<b>&lt;raw&gt;</b>. This is one of the limitations of the
delimited format, it is impossible to supply a data chunk
which does not have an LF as its last byte.</p>

<p style="margin-left:17%; margin-top: 1em">The <b>LF</b>
after <b>&lt;delim&gt; LF</b> is optional (it used to be
required).</p>

<p style="margin-left:11%; margin-top: 1em"><b>alias</b>
<br>
Record that a mark refers to a given object without first
creating any new object.</p>

<p style="margin-left:17%; margin-top: 1em">'alias' LF <br>
mark <br>
'to' SP &lt;commit-ish&gt; LF <br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">For a detailed
description of <b>&lt;commit-ish&gt;</b> see above under
<b>from</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>checkpoint</b>
<br>
Forces fast-import to close the current packfile, start a
new one, and to save out all current branch refs, tags and
marks.</p>

<p style="margin-left:17%; margin-top: 1em">'checkpoint' LF
<br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">Note that
fast-import automatically switches packfiles when the
current packfile reaches --max-pack-size, or 4 GiB,
whichever limit is smaller. During an automatic packfile
switch fast-import does not update the branch refs, tags or
marks.</p>

<p style="margin-left:11%; margin-top: 1em">As a
<b>checkpoint</b> can require a significant amount of CPU
time and disk IO (to compute the overall pack SHA-1
checksum, generate the corresponding index file, and update
the refs) it can easily take several minutes for a single
<b>checkpoint</b> command to complete.</p>

<p style="margin-left:11%; margin-top: 1em">Frontends may
choose to issue checkpoints during extremely large and long
running imports, or when they need to allow another Git
process access to a branch. However given that a 30 GiB
Subversion repository can be loaded into Git through
fast-import in about 3 hours, explicit checkpointing may not
be necessary.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>LF</b>
after the command is optional (it used to be required).</p>


<p style="margin-left:11%; margin-top: 1em"><b>progress</b>
<br>
Causes fast-import to print the entire <b>progress</b> line
unmodified to its standard output channel (file descriptor
1) when the command is processed from the input stream. The
command otherwise has no impact on the current import, or on
any of fast-import&rsquo;s internal state.</p>

<p style="margin-left:17%; margin-top: 1em">'progress' SP
&lt;any&gt; LF <br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&lt;any&gt;</b> part of the command may contain any
sequence of bytes that does not contain <b>LF</b>. The
<b>LF</b> after the command is optional. Callers may wish to
process the output through a tool such as sed to remove the
leading part of the line, for example:</p>

<p style="margin-left:17%; margin-top: 1em">frontend | git
fast-import | sed 's/^progress //'</p>

<p style="margin-left:11%; margin-top: 1em">Placing a
<b>progress</b> command immediately after a
<b>checkpoint</b> will inform the reader when the
<b>checkpoint</b> has been completed and it can safely
access the refs that fast-import updated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>get-mark</b>
<br>
Causes fast-import to print the SHA-1 corresponding to a
mark to stdout or to the file descriptor previously arranged
with the <b>--cat-blob-fd</b> argument. The command
otherwise has no impact on the current import; its purpose
is to retrieve SHA-1s that later commits might want to refer
to in their commit messages.</p>

<p style="margin-left:17%; margin-top: 1em">'get-mark' SP
':' &lt;idnum&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">See
&ldquo;Responses To Commands&rdquo; below for details about
how to read this output safely.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cat-blob</b>
<br>
Causes fast-import to print a blob to a file descriptor
previously arranged with the <b>--cat-blob-fd</b> argument.
The command otherwise has no impact on the current import;
its main purpose is to retrieve blobs that may be in
fast-import&rsquo;s memory but not accessible from the
target repository.</p>

<p style="margin-left:17%; margin-top: 1em">'cat-blob' SP
&lt;dataref&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&lt;dataref&gt;</b> can be either a mark reference
(<b>:&lt;idnum&gt;</b>) set previously or a full 40-byte
SHA-1 of a Git blob, preexisting or ready to be written.</p>

<p style="margin-left:11%; margin-top: 1em">Output uses the
same format as <b>git cat-file --batch</b>:</p>

<p style="margin-left:17%; margin-top: 1em">&lt;sha1&gt; SP
'blob' SP &lt;size&gt; LF <br>
&lt;contents&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">This command
can be used where a <b>filemodify</b> directive can appear,
allowing it to be used in the middle of a commit. For a
<b>filemodify</b> using an inline directive, it can also
appear right before the <b>data</b> directive.</p>

<p style="margin-left:11%; margin-top: 1em">See
&ldquo;Responses To Commands&rdquo; below for details about
how to read this output safely.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ls</b> <br>
Prints information about the object at a path to a file
descriptor previously arranged with the <b>--cat-blob-fd</b>
argument. This allows printing a blob from the active commit
(with <b>cat-blob</b>) or copying a blob or tree from a
previous commit for use in the current one (with
<b>filemodify</b>).</p>

<p style="margin-left:11%; margin-top: 1em">The <b>ls</b>
command can also be used where a <b>filemodify</b> directive
can appear, allowing it to be used in the middle of a
commit.</p>

<p style="margin-left:11%; margin-top: 1em">Reading from
the active commit</p>

<p style="margin-left:17%;">This form can only be used in
the middle of a <b>commit</b>. The path names a directory
entry within fast-import&rsquo;s active commit. The path
must be quoted in this case.</p>

<p style="margin-left:23%; margin-top: 1em">'ls' SP
&lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">Reading from a
named tree</p>

<p style="margin-left:17%;">The <b>&lt;dataref&gt;</b> can
be a mark reference (<b>:&lt;idnum&gt;</b>) or the full
40-byte SHA-1 of a Git tag, commit, or tree object,
preexisting or waiting to be written. The path is relative
to the top level of the tree named by
<b>&lt;dataref&gt;</b>.</p>

<p style="margin-left:23%; margin-top: 1em">'ls' SP
&lt;dataref&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>filemodify</b> above for a detailed description of
<b>&lt;path&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Output uses the
same format as <b>git ls-tree &lt;tree&gt; --
&lt;path&gt;</b>:</p>

<p style="margin-left:17%; margin-top: 1em">&lt;mode&gt; SP
('blob' | 'tree' | 'commit') SP &lt;dataref&gt; HT
&lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">The
&lt;dataref&gt; represents the blob, tree, or commit object
at &lt;path&gt; and can be used in later <i>get-mark</i>,
<i>cat-blob</i>, <i>filemodify</i>, or <i>ls</i>
commands.</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
file or subtree at that path, <i>git fast-import</i> will
instead report</p>

<p style="margin-left:17%; margin-top: 1em">missing SP
&lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">See
&ldquo;Responses To Commands&rdquo; below for details about
how to read this output safely.</p>

<p style="margin-left:11%; margin-top: 1em"><b>feature</b>
<br>
Require that fast-import supports the specified feature, or
abort if it does not.</p>

<p style="margin-left:17%; margin-top: 1em">'feature' SP
&lt;feature&gt; ('=' &lt;argument&gt;)? LF</p>

<p style="margin-left:11%; margin-top: 1em">The
&lt;feature&gt; part of the command may be any one of the
following:</p>

<p style="margin-left:11%; margin-top: 1em">date-format,
export-marks, relative-marks, no-relative-marks, force</p>

<p style="margin-left:17%;">Act as though the corresponding
command-line option with a leading <b>--</b> was passed on
the command line (see OPTIONS, above).</p>

<p style="margin-left:11%; margin-top: 1em">import-marks,
import-marks-if-exists</p>

<p style="margin-left:17%;">Like --import-marks except in
two respects: first, only one &quot;feature
import-marks&quot; or &quot;feature
import-marks-if-exists&quot; command is allowed per stream;
second, an --import-marks= or --import-marks-if-exists
command-line option overrides any of these
&quot;feature&quot; commands in the stream; third,
&quot;feature import-marks-if-exists&quot; like a
corresponding command-line option silently skips a
nonexistent file.</p>

<p style="margin-left:11%; margin-top: 1em">get-mark,
cat-blob, ls</p>

<p style="margin-left:17%;">Require that the backend
support the <i>get-mark</i>, <i>cat-blob</i>, or <i>ls</i>
command respectively. Versions of fast-import not supporting
the specified command will exit with a message indicating
so. This lets the import error out early with a clear
message, rather than wasting time on the early part of an
import before the unsupported command is detected.</p>

<p style="margin-left:11%; margin-top: 1em">notes</p>

<p style="margin-left:17%;">Require that the backend
support the <i>notemodify</i> (N) subcommand to the
<i>commit</i> command. Versions of fast-import not
supporting notes will exit with a message indicating so.</p>

<p style="margin-left:11%; margin-top: 1em">done</p>

<p style="margin-left:17%;">Error out if the stream ends
without a <i>done</i> command. Without this feature, errors
causing the frontend to end abruptly at a convenient point
in the stream can go undetected. This may occur, for
example, if an import front end dies in mid-operation
without emitting SIGTERM or SIGKILL at its subordinate git
fast-import instance.</p>

<p style="margin-left:11%; margin-top: 1em"><b>option</b>
<br>
Processes the specified option so that git fast-import
behaves in a way that suits the frontend&rsquo;s needs. Note
that options specified by the frontend are overridden by any
options the user may specify to git fast-import itself.</p>

<p style="margin-left:17%; margin-top: 1em">'option' SP
&lt;option&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&lt;option&gt;</b> part of the command may contain any of
the options listed in the OPTIONS section that do not change
import semantics, without the leading <b>--</b> and is
treated in the same way.</p>

<p style="margin-left:11%; margin-top: 1em">Option commands
must be the first commands on the input (not counting
feature commands), to give an option command after any
non-option command is an error.</p>

<p style="margin-left:11%; margin-top: 1em">The following
command-line options change import semantics and may
therefore not be passed as option:</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
date-format</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
import-marks</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
export-marks</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
cat-blob-fd</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
force</p>

<p style="margin-left:11%; margin-top: 1em"><b>done</b>
<br>
If the <b>done</b> feature is not in use, treated as if EOF
was read. This can be used to tell fast-import to finish
early.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>--done</b> command-line option or <b>feature done</b>
command is in use, the <b>done</b> command is mandatory and
marks the end of the stream.</p>

<h2>RESPONSES TO COMMANDS
<a name="RESPONSES TO COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">New objects
written by fast-import are not available immediately. Most
fast-import commands have no visible effect until the next
checkpoint (or completion). The frontend can send commands
to fill fast-import&rsquo;s input pipe without worrying
about how quickly they will take effect, which improves
performance by simplifying scheduling.</p>

<p style="margin-left:11%; margin-top: 1em">For some
frontends, though, it is useful to be able to read back data
from the current repository as it is being updated (for
example when the source material describes objects in terms
of patches to be applied to previously imported objects).
This can be accomplished by connecting the frontend and
fast-import via bidirectional pipes:</p>

<p style="margin-left:17%; margin-top: 1em">mkfifo
fast-import-output <br>
frontend &lt;fast-import-output | <br>
git fast-import &gt;fast-import-output</p>

<p style="margin-left:11%; margin-top: 1em">A frontend set
up this way can use <b>progress</b>, <b>get-mark</b>,
<b>ls</b>, and <b>cat-blob</b> commands to read information
from the import in progress.</p>

<p style="margin-left:11%; margin-top: 1em">To avoid
deadlock, such frontends must completely consume any pending
output from <b>progress</b>, <b>ls</b>, <b>get-mark</b>, and
<b>cat-blob</b> before performing writes to fast-import that
might block.</p>

<h2>CRASH REPORTS
<a name="CRASH REPORTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If fast-import
is supplied invalid input it will terminate with a non-zero
exit status and create a crash report in the top level of
the Git repository it was importing into. Crash reports
contain a snapshot of the internal fast-import state as well
as the most recent commands that lead up to the crash.</p>

<p style="margin-left:11%; margin-top: 1em">All recent
commands (including stream comments, file changes and
progress commands) are shown in the command history within
the crash report, but raw file data and commit messages are
excluded from the crash report. This exclusion saves space
within the report file and reduces the amount of buffering
that fast-import must perform during execution.</p>

<p style="margin-left:11%; margin-top: 1em">After writing a
crash report fast-import will close the current packfile and
export the marks table. This allows the frontend developer
to inspect the repository state and resume the import from
the point where it crashed. The modified branches and tags
are not updated during a crash, as the import did not
complete successfully. Branch and tag information can be
found in the crash report and must be applied manually if
the update is needed.</p>

<p style="margin-left:11%; margin-top: 1em">An example
crash:</p>

<p style="margin-left:17%; margin-top: 1em">$ cat &gt;in
&lt;&lt;END_OF_INPUT <br>
# my very first test commit <br>
commit refs/heads/master <br>
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400 <br>
# who is that guy anyway? <br>
data &lt;&lt;EOF <br>
this is my commit <br>
EOF <br>
M 644 inline .gitignore <br>
data &lt;&lt;EOF <br>
.gitignore <br>
EOF <br>
M 777 inline bob <br>
END_OF_INPUT</p>

<p style="margin-left:17%; margin-top: 1em">$ git
fast-import &lt;in <br>
fatal: Corrupt mode: M 777 inline bob <br>
fast-import: dumping crash report to
.git/fast_import_crash_8434</p>

<p style="margin-left:17%; margin-top: 1em">$ cat
.git/fast_import_crash_8434 <br>
fast-import crash report: <br>
fast-import process: 8434 <br>
parent process : 1391 <br>
at Sat Sep 1 00:58:12 2007</p>

<p style="margin-left:17%; margin-top: 1em">fatal: Corrupt
mode: M 777 inline bob</p>

<p style="margin-left:17%; margin-top: 1em">Most Recent
Commands Before Crash <br>
--------------------------------- <br>
# my very first test commit <br>
commit refs/heads/master <br>
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400 <br>
# who is that guy anyway? <br>
data &lt;&lt;EOF <br>
M 644 inline .gitignore <br>
data &lt;&lt;EOF <br>
* M 777 inline bob</p>

<p style="margin-left:17%; margin-top: 1em">Active Branch
LRU <br>
----------------- <br>
active_branches = 1 cur, 5 max</p>

<p style="margin-left:17%; margin-top: 1em">pos clock name
<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <br>
1) 0 refs/heads/master</p>

<p style="margin-left:17%; margin-top: 1em">Inactive
Branches <br>
----------------- <br>
refs/heads/master: <br>
status : active loaded dirty <br>
tip commit : 0000000000000000000000000000000000000000 <br>
old tree : 0000000000000000000000000000000000000000 <br>
cur tree : 0000000000000000000000000000000000000000 <br>
commit clock: 0 <br>
last pack :</p>


<p style="margin-left:17%; margin-top: 1em">-------------------
<br>
END OF CRASH REPORT</p>

<h2>TIPS AND TRICKS
<a name="TIPS AND TRICKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
tips and tricks have been collected from various users of
fast-import, and are offered here as suggestions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Use One Mark
Per Commit</b> <br>
When doing a repository conversion, use a unique mark per
commit (<b>mark :&lt;n&gt;</b>) and supply the
--export-marks option on the command line. fast-import will
dump a file which lists every mark and the Git object SHA-1
that corresponds to it. If the frontend can tie the marks
back to the source repository, it is easy to verify the
accuracy and completeness of the import by comparing each
Git commit to the corresponding source revision.</p>

<p style="margin-left:11%; margin-top: 1em">Coming from a
system such as Perforce or Subversion this should be quite
simple, as the fast-import mark can also be the Perforce
changeset number or the Subversion revision number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Freely Skip
Around Branches</b> <br>
Don&rsquo;t bother trying to optimize the frontend to stick
to one branch at a time during an import. Although doing so
might be slightly faster for fast-import, it tends to
increase the complexity of the frontend code
considerably.</p>

<p style="margin-left:11%; margin-top: 1em">The branch LRU
builtin to fast-import tends to behave very well, and the
cost of activating an inactive branch is so low that
bouncing around between branches has virtually no impact on
import performance.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Handling
Renames</b> <br>
When importing a renamed file or directory, simply delete
the old name(s) and modify the new name(s) during the
corresponding commit. Git performs rename detection
after-the-fact, rather than explicitly during a commit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Use Tag
Fixup Branches</b> <br>
Some other SCM systems let the user create a tag from
multiple files which are not from the same commit/changeset.
Or to create tags which are a subset of the files available
in the repository.</p>

<p style="margin-left:11%; margin-top: 1em">Importing these
tags as-is in Git is impossible without making at least one
commit which &ldquo;fixes up&rdquo; the files to match the
content of the tag. Use fast-import&rsquo;s <b>reset</b>
command to reset a dummy branch outside of your normal
branch space to the base commit for the tag, then commit one
or more file fixup commits, and finally tag the dummy
branch.</p>

<p style="margin-left:11%; margin-top: 1em">For example
since all normal branches are stored under
<b>refs/heads/</b> name the tag fixup branch
<b>TAG_FIXUP</b>. This way it is impossible for the fixup
branch used by the importer to have namespace conflicts with
real branches imported from the source (the name
<b>TAG_FIXUP</b> is not <b>refs/heads/TAG_FIXUP</b>).</p>

<p style="margin-left:11%; margin-top: 1em">When committing
fixups, consider using <b>merge</b> to connect the commit(s)
which are supplying file revisions to the fixup branch.
Doing so will allow tools such as <i>git blame</i> to track
through the real commit history and properly annotate the
source files.</p>

<p style="margin-left:11%; margin-top: 1em">After
fast-import terminates the frontend will need to do <b>rm
.git/TAG_FIXUP</b> to remove the dummy branch.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Import Now,
Repack Later</b> <br>
As soon as fast-import completes the Git repository is
completely valid and ready for use. Typically this takes
only a very short time, even for considerably large projects
(100,000+ commits).</p>

<p style="margin-left:11%; margin-top: 1em">However
repacking the repository is necessary to improve data
locality and access performance. It can also take hours on
extremely large projects (especially if -f and a large
--window parameter is used). Since repacking is safe to run
alongside readers and writers, run the repack in the
background and let it finish when it finishes. There is no
reason to wait to explore your new Git project!</p>

<p style="margin-left:11%; margin-top: 1em">If you choose
to wait for the repack, don&rsquo;t try to run benchmarks or
performance tests until repacking is completed. fast-import
outputs suboptimal packfiles that are simply never seen in
real use situations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Repacking
Historical Data</b> <br>
If you are repacking very old imported data (e.g. older than
the last year), consider expending some extra CPU time and
supplying --window=50 (or higher) when you run <i>git
repack</i>. This will take longer, but will also produce a
smaller packfile. You only need to expend the effort once,
and everyone using your project will benefit from the
smaller repository.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Include Some
Progress Messages</b> <br>
Every once in a while have your frontend emit a
<b>progress</b> message to fast-import. The contents of the
messages are entirely free-form, so one suggestion would be
to output the current month and year each time the current
commit date moves into the next month. Your users will feel
better knowing how much of the data stream has been
processed.</p>

<h2>PACKFILE OPTIMIZATION
<a name="PACKFILE OPTIMIZATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When packing a
blob fast-import always attempts to deltify against the last
blob written. Unless specifically arranged for by the
frontend, this will probably not be a prior version of the
same file, so the generated delta will not be the smallest
possible. The resulting packfile will be compressed, but
will not be optimal.</p>

<p style="margin-left:11%; margin-top: 1em">Frontends which
have efficient access to all revisions of a single file (for
example reading an RCS/CVS ,v file) can choose to supply all
revisions of that file as a sequence of consecutive
<b>blob</b> commands. This allows fast-import to deltify the
different file revisions against each other, saving space in
the final packfile. Marks can be used to later identify
individual file revisions during a sequence of <b>commit</b>
commands.</p>

<p style="margin-left:11%; margin-top: 1em">The packfile(s)
created by fast-import do not encourage good disk access
patterns. This is caused by fast-import writing the data in
the order it is received on standard input, while Git
typically organizes data within packfiles to make the most
recent (current tip) data appear before historical data. Git
also clusters commits together, speeding up revision
traversal through better cache locality.</p>

<p style="margin-left:11%; margin-top: 1em">For this reason
it is strongly recommended that users repack the repository
with <b>git repack -a -d</b> after fast-import completes,
allowing Git to reorganize the packfiles for faster data
access. If blob deltas are suboptimal (see above) then also
adding the <b>-f</b> option to force recomputation of all
deltas can significantly reduce the final packfile size
(30-50% smaller can be quite typical).</p>

<p style="margin-left:11%; margin-top: 1em">Instead of
running <b>git repack</b> you can also run <b>git gc
--aggressive</b>, which will also optimize other things
after an import (e.g. pack loose refs). As noted in the
&quot;AGGRESSIVE&quot; section in <b>git-gc</b>(1) the
<b>--aggressive</b> option will find new deltas with the
<b>-f</b> option to <b>git-repack</b>(1). For the reasons
elaborated on above using <b>--aggressive</b> after a
fast-import is one of the few cases where it&rsquo;s known
to be worthwhile.</p>

<h2>MEMORY UTILIZATION
<a name="MEMORY UTILIZATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are a
number of factors which affect how much memory fast-import
requires to perform an import. Like critical sections of
core Git, fast-import uses its own memory allocators to
amortize any overheads associated with malloc. In practice
fast-import tends to amortize any malloc overheads to 0, due
to its use of large block allocations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per
object</b> <br>
fast-import maintains an in-memory structure for every
object written in this execution. On a 32 bit system the
structure is 32 bytes, on a 64 bit system the structure is
40 bytes (due to the larger pointer sizes). Objects in the
table are not deallocated until fast-import terminates.
Importing 2 million objects on a 32 bit system will require
approximately 64 MiB of memory.</p>

<p style="margin-left:11%; margin-top: 1em">The object
table is actually a hashtable keyed on the object name (the
unique SHA-1). This storage configuration allows fast-import
to reuse an existing or already written object and avoid
writing duplicates to the output packfile. Duplicate blobs
are surprisingly common in an import, typically due to
branch merges in the source.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per mark</b>
<br>
Marks are stored in a sparse array, using 1 pointer (4 bytes
or 8 bytes, depending on pointer size) per mark. Although
the array is sparse, frontends are still strongly encouraged
to use marks between 1 and n, where n is the total number of
marks required for this import.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per
branch</b> <br>
Branches are classified as active and inactive. The memory
usage of the two classes is significantly different.</p>

<p style="margin-left:11%; margin-top: 1em">Inactive
branches are stored in a structure which uses 96 or 120
bytes (32 bit or 64 bit systems, respectively), plus the
length of the branch name (typically under 200 bytes), per
branch. fast-import will easily handle as many as 10,000
inactive branches in under 2 MiB of memory.</p>

<p style="margin-left:11%; margin-top: 1em">Active branches
have the same overhead as inactive branches, but also
contain copies of every tree that has been recently modified
on that branch. If subtree <b>include</b> has not been
modified since the branch became active, its contents will
not be loaded into memory, but if subtree <b>src</b> has
been modified by a commit since the branch became active,
then its contents will be loaded in memory.</p>

<p style="margin-left:11%; margin-top: 1em">As active
branches store metadata about the files contained on that
branch, their in-memory storage size can grow to a
considerable size (see below).</p>

<p style="margin-left:11%; margin-top: 1em">fast-import
automatically moves active branches to inactive status based
on a simple least-recently-used algorithm. The LRU chain is
updated on each <b>commit</b> command. The maximum number of
active branches can be increased or decreased on the command
line with --active-branches=.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per active
tree</b> <br>
Trees (aka directories) use just 12 bytes of memory on top
of the memory required for their entries (see &ldquo;per
active file&rdquo; below). The cost of a tree is virtually
0, as its overhead amortizes out over the individual file
entries.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per active
file entry</b> <br>
Files (and pointers to subtrees) within active trees require
52 or 64 bytes (32/64 bit platforms) per entry. To conserve
space, file and tree names are pooled in a common string
table, allowing the filename &ldquo;Makefile&rdquo; to use
just 16 bytes (after including the string header overhead)
no matter how many times it occurs within the project.</p>

<p style="margin-left:11%; margin-top: 1em">The active
branch LRU, when coupled with the filename string pool and
lazy loading of subtrees, allows fast-import to efficiently
import projects with 2,000+ branches and 45,114+ files in a
very limited memory footprint (less than 2.7 MiB per active
branch).</p>

<h2>SIGNALS
<a name="SIGNALS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sending
<b>SIGUSR1</b> to the <i>git fast-import</i> process ends
the current packfile early, simulating a <b>checkpoint</b>
command. The impatient operator can use this facility to
peek at the objects and refs from an import in progress, at
the cost of some added running time and worse
compression.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>git-fast-export</b>(1)</p>

<h2>GIT
<a name="GIT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Part of the
<b>git</b>(1) suite</p>
<hr>
</body>
</html>
