<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon Nov  7 04:40:14 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT-COMMIT</title>

</head>
<body>

<h1 align="center">GIT-COMMIT</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#COMMIT INFORMATION">COMMIT INFORMATION</a><br>
<a href="#DATE FORMATS">DATE FORMATS</a><br>
<a href="#DISCUSSION">DISCUSSION</a><br>
<a href="#ENVIRONMENT AND CONFIGURATION VARIABLES">ENVIRONMENT AND CONFIGURATION VARIABLES</a><br>
<a href="#HOOKS">HOOKS</a><br>
<a href="#FILES">FILES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">git-commit -
Record changes to the repository</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>git
commit</i> [-a | --interactive | --patch] [-s] [-v]
[-u&lt;mode&gt;] [--amend] <br>
[--dry-run] [(-c | -C | --squash) &lt;commit&gt; | --fixup
[(amend|reword):]&lt;commit&gt;)] <br>
[-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author]
[--allow-empty] <br>
[--allow-empty-message] [--no-verify] [-e]
[--author=&lt;author&gt;] <br>
[--date=&lt;date&gt;] [--cleanup=&lt;mode&gt;]
[--[no-]status] <br>
[-i | -o] [--pathspec-from-file=&lt;file&gt;
[--pathspec-file-nul]] <br>
[(--trailer &lt;token&gt;[(=|:)&lt;value&gt;])...]
[-S[&lt;keyid&gt;]] <br>
[--] [&lt;pathspec&gt;...]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Create a new
commit containing the current contents of the index and the
given log message describing the changes. The new commit is
a direct child of HEAD, usually the tip of the current
branch, and the branch is updated to point to it (unless no
branch is associated with the working tree, in which case
HEAD is &quot;detached&quot; as described in
<b>git-checkout</b>(1)).</p>

<p style="margin-left:11%; margin-top: 1em">The content to
be committed can be specified in several ways:</p>

<p style="margin-left:17%; margin-top: 1em">1. by using
<b>git-add</b>(1) to incrementally &quot;add&quot; changes
to the index before using the <i>commit</i> command (Note:
even modified files must be &quot;added&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">2. by using
<b>git-rm</b>(1) to remove files from the working tree and
the index, again before using the <i>commit</i> command;</p>

<p style="margin-left:17%; margin-top: 1em">3. by listing
files as arguments to the <i>commit</i> command (without
--interactive or --patch switch), in which case the commit
will ignore changes staged in the index, and instead record
the current content of the listed files (which must already
be known to Git);</p>

<p style="margin-left:17%; margin-top: 1em">4. by using the
-a switch with the <i>commit</i> command to automatically
&quot;add&quot; changes from all known files (i.e. all files
that are already listed in the index) and to automatically
&quot;rm&quot; files in the index that have been removed
from the working tree, and then perform the actual
commit;</p>

<p style="margin-left:17%; margin-top: 1em">5. by using the
--interactive or --patch switches with the <i>commit</i>
command to decide one by one which files or hunks should be
part of the commit in addition to contents in the index,
before finalizing the operation. See the &ldquo;Interactive
Mode&rdquo; section of <b>git-add</b>(1) to learn how to
operate these modes.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>--dry-run</b> option can be used to obtain a summary of
what is included by any of the above for the next commit by
giving the same set of parameters (options and paths).</p>

<p style="margin-left:11%; margin-top: 1em">If you make a
commit and then find a mistake immediately after that, you
can recover from it with <i>git reset</i>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">-a, --all</p>

<p style="margin-left:17%;">Tell the command to
automatically stage files that have been modified and
deleted, but new files you have not told Git about are not
affected.</p>

<p style="margin-left:11%; margin-top: 1em">-p, --patch</p>

<p style="margin-left:17%;">Use the interactive patch
selection interface to choose which changes to commit. See
<b>git-add</b>(1) for details.</p>

<p style="margin-left:11%; margin-top: 1em">-C
&lt;commit&gt;, --reuse-message=&lt;commit&gt;</p>

<p style="margin-left:17%;">Take an existing commit object,
and reuse the log message and the authorship information
(including the timestamp) when creating the commit.</p>

<p style="margin-left:11%; margin-top: 1em">-c
&lt;commit&gt;, --reedit-message=&lt;commit&gt;</p>

<p style="margin-left:17%;">Like <i>-C</i>, but with
<b>-c</b> the editor is invoked, so that the user can
further edit the commit message.</p>


<p style="margin-left:11%; margin-top: 1em">--fixup=[(amend|reword):]&lt;commit&gt;</p>

<p style="margin-left:17%;">Create a new commit which
&quot;fixes up&quot; <b>&lt;commit&gt;</b> when applied with
<b>git rebase --autosquash</b>. Plain
<b>--fixup=&lt;commit&gt;</b> creates a &quot;fixup!&quot;
commit which changes the content of <b>&lt;commit&gt;</b>
but leaves its log message untouched.
<b>--fixup=amend:&lt;commit&gt;</b> is similar but creates
an &quot;amend!&quot; commit which also replaces the log
message of <b>&lt;commit&gt;</b> with the log message of the
&quot;amend!&quot; commit.
<b>--fixup=reword:&lt;commit&gt;</b> creates an
&quot;amend!&quot; commit which replaces the log message of
<b>&lt;commit&gt;</b> with its own log message but makes no
changes to the content of <b>&lt;commit&gt;</b>.</p>

<p style="margin-left:17%; margin-top: 1em">The commit
created by plain <b>--fixup=&lt;commit&gt;</b> has a subject
composed of &quot;fixup!&quot; followed by the subject line
from &lt;commit&gt;, and is recognized specially by <b>git
rebase --autosquash</b>. The <b>-m</b> option may be used to
supplement the log message of the created commit, but the
additional commentary will be thrown away once the
&quot;fixup!&quot; commit is squashed into
<b>&lt;commit&gt;</b> by <b>git rebase --autosquash</b>.</p>

<p style="margin-left:17%; margin-top: 1em">The commit
created by <b>--fixup=amend:&lt;commit&gt;</b> is similar
but its subject is instead prefixed with &quot;amend!&quot;.
The log message of &lt;commit&gt; is copied into the log
message of the &quot;amend!&quot; commit and opened in an
editor so it can be refined. When <b>git rebase
--autosquash</b> squashes the &quot;amend!&quot; commit into
<b>&lt;commit&gt;</b>, the log message of
<b>&lt;commit&gt;</b> is replaced by the refined log message
from the &quot;amend!&quot; commit. It is an error for the
&quot;amend!&quot; commit&rsquo;s log message to be empty
unless <b>--allow-empty-message</b> is specified.</p>


<p style="margin-left:17%; margin-top: 1em"><b>--fixup=reword:&lt;commit&gt;</b>
is shorthand for <b>--fixup=amend:&lt;commit&gt; --only</b>.
It creates an &quot;amend!&quot; commit with only a log
message (ignoring any changes staged in the index). When
squashed by <b>git rebase --autosquash</b>, it replaces the
log message of <b>&lt;commit&gt;</b> without making any
other changes.</p>

<p style="margin-left:17%; margin-top: 1em">Neither
&quot;fixup!&quot; nor &quot;amend!&quot; commits change
authorship of <b>&lt;commit&gt;</b> when applied by <b>git
rebase --autosquash</b>. See <b>git-rebase</b>(1) for
details.</p>


<p style="margin-left:11%; margin-top: 1em">--squash=&lt;commit&gt;</p>

<p style="margin-left:17%;">Construct a commit message for
use with <b>rebase --autosquash</b>. The commit message
subject line is taken from the specified commit with a
prefix of &quot;squash! &quot;. Can be used with additional
commit message options
(<b>-m</b>/<b>-c</b>/<b>-C</b>/<b>-F</b>). See
<b>git-rebase</b>(1) for details.</p>


<p style="margin-left:11%; margin-top: 1em">--reset-author</p>

<p style="margin-left:17%;">When used with -C/-c/--amend
options, or when committing after a conflicting cherry-pick,
declare that the authorship of the resulting commit now
belongs to the committer. This also renews the author
timestamp.</p>

<p style="margin-left:11%; margin-top: 1em">--short</p>

<p style="margin-left:17%;">When doing a dry-run, give the
output in the short-format. See <b>git-status</b>(1) for
details. Implies <b>--dry-run</b>.</p>

<p style="margin-left:11%; margin-top: 1em">--branch</p>

<p style="margin-left:17%;">Show the branch and tracking
info even in short-format.</p>


<p style="margin-left:11%; margin-top: 1em">--porcelain</p>

<p style="margin-left:17%;">When doing a dry-run, give the
output in a porcelain-ready format. See <b>git-status</b>(1)
for details. Implies <b>--dry-run</b>.</p>

<p style="margin-left:11%; margin-top: 1em">--long</p>

<p style="margin-left:17%;">When doing a dry-run, give the
output in the long-format. Implies <b>--dry-run</b>.</p>

<p style="margin-left:11%; margin-top: 1em">-z, --null</p>

<p style="margin-left:17%;">When showing <b>short</b> or
<b>porcelain</b> status output, print the filename verbatim
and terminate the entries with NUL, instead of LF. If no
format is given, implies the <b>--porcelain</b> output
format. Without the <b>-z</b> option, filenames with
&quot;unusual&quot; characters are quoted as explained for
the configuration variable <b>core.quotePath</b> (see
<b>git-config</b>(1)).</p>

<p style="margin-left:11%; margin-top: 1em">-F
&lt;file&gt;, --file=&lt;file&gt;</p>

<p style="margin-left:17%;">Take the commit message from
the given file. Use <i>-</i> to read the message from the
standard input.</p>


<p style="margin-left:11%; margin-top: 1em">--author=&lt;author&gt;</p>

<p style="margin-left:17%;">Override the commit author.
Specify an explicit author using the standard <b>A U Thor
&lt;author@example.com&gt;</b> format. Otherwise
&lt;author&gt; is assumed to be a pattern and is used to
search for an existing commit by that author (i.e. rev-list
--all -i --author=&lt;author&gt;); the commit author is then
copied from the first such commit found.</p>


<p style="margin-left:11%; margin-top: 1em">--date=&lt;date&gt;</p>

<p style="margin-left:17%;">Override the author date used
in the commit.</p>

<p style="margin-left:11%; margin-top: 1em">-m &lt;msg&gt;,
--message=&lt;msg&gt;</p>

<p style="margin-left:17%;">Use the given &lt;msg&gt; as
the commit message. If multiple <b>-m</b> options are given,
their values are concatenated as separate paragraphs.</p>

<p style="margin-left:17%; margin-top: 1em">The <b>-m</b>
option is mutually exclusive with <b>-c</b>, <b>-C</b>, and
<b>-F</b>.</p>

<p style="margin-left:11%; margin-top: 1em">-t
&lt;file&gt;, --template=&lt;file&gt;</p>

<p style="margin-left:17%;">When editing the commit
message, start the editor with the contents in the given
file. The <b>commit.template</b> configuration variable is
often used to give this option implicitly to the command.
This mechanism can be used by projects that want to guide
participants with some hints on what to write in the message
in what order. If the user exits the editor without editing
the message, the commit is aborted. This has no effect when
a message is given by other means, e.g. with the <b>-m</b>
or <b>-F</b> options.</p>

<p style="margin-left:11%; margin-top: 1em">-s, --signoff,
--no-signoff</p>

<p style="margin-left:17%;">Add a <b>Signed-off-by</b>
trailer by the committer at the end of the commit log
message. The meaning of a signoff depends on the project to
which you&rsquo;re committing. For example, it may certify
that the committer has the rights to submit the work under
the project&rsquo;s license or agrees to some contributor
representation, such as a Developer Certificate of Origin.
(See
<b><font color="#0000FF">http://developercertificate.org</font></b>
<font color="#000000">for the one used by the Linux kernel
and Git projects.) Consult the documentation or leadership
of the project to which you&rsquo;re contributing to
understand how the signoffs are used in that
project.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
--no-signoff option can be used to countermand an earlier
--signoff option on the command line.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--trailer
&lt;token&gt;[(=|:)&lt;value&gt;]</font></p>

<p style="margin-left:17%;"><font color="#000000">Specify a
(&lt;token&gt;, &lt;value&gt;) pair that should be applied
as a trailer. (e.g. <b>git commit --trailer
&quot;Signed-off-by:C O Mitter \
&lt;committer@example.com&gt;&quot; --trailer
&quot;Helped-by:C O Mitter \
&lt;committer@example.com&gt;&quot;</b> will add the
&quot;Signed-off-by&quot; trailer and the
&quot;Helped-by&quot; trailer to the commit message.) The
<b>trailer.*</b> configuration variables
(<b>git-interpret-trailers</b>(1)) can be used to define if
a duplicated trailer is omitted, where in the run of
trailers each trailer would appear, and other
details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-n,
--[no-]verify</font></p>

<p style="margin-left:17%;"><font color="#000000">By
default, the pre-commit and commit-msg hooks are run. When
any of <b>--no-verify</b> or <b>-n</b> is given, these are
bypassed. See also <b>githooks</b>(5).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--allow-empty</font></p>

<p style="margin-left:17%;"><font color="#000000">Usually
recording a commit that has the exact same tree as its sole
parent commit is a mistake, and the command prevents you
from making such a commit. This option bypasses the safety,
and is primarily for use by foreign SCM interface
scripts.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--allow-empty-message</font></p>

<p style="margin-left:17%;"><font color="#000000">Like
--allow-empty this command is primarily for use by foreign
SCM interface scripts. It allows you to create a commit with
an empty commit message without using plumbing commands like
<b>git-commit-tree</b>(1).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--cleanup=&lt;mode&gt;</font></p>

<p style="margin-left:17%;"><font color="#000000">This
option determines how the supplied commit message should be
cleaned up before committing. The <i>&lt;mode&gt;</i> can be
<b>strip</b>, <b>whitespace</b>, <b>verbatim</b>,
<b>scissors</b> or <b>default</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">strip</font></p>

<p style="margin-left:23%;"><font color="#000000">Strip
leading and trailing empty lines, trailing whitespace,
commentary and collapse consecutive empty lines.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">whitespace</font></p>

<p style="margin-left:23%;"><font color="#000000">Same as
<b>strip</b> except #commentary is not removed.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">verbatim</font></p>

<p style="margin-left:23%;"><font color="#000000">Do not
change the message at all.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">scissors</font></p>

<p style="margin-left:23%;"><font color="#000000">Same as
<b>whitespace</b> except that everything from (and
including) the line found below is truncated, if the message
is to be edited. &quot;<b>#</b>&quot; can be customized with
core.commentChar.</font></p>


<p style="margin-left:29%; margin-top: 1em"><font color="#000000">#
------------------------ &gt;8
------------------------</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">default</font></p>

<p style="margin-left:23%;"><font color="#000000">Same as
<b>strip</b> if the message is to be edited. Otherwise
<b>whitespace</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
default can be changed by the <b>commit.cleanup</b>
configuration variable (see
<b>git-config</b>(1)).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-e,
--edit</font></p>

<p style="margin-left:17%;"><font color="#000000">The
message taken from file with <b>-F</b>, command line with
<b>-m</b>, and from commit object with <b>-C</b> are usually
used as the commit log message unmodified. This option lets
you further edit the message taken from these
sources.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--no-edit</font></p>

<p style="margin-left:17%;"><font color="#000000">Use the
selected commit message without launching an editor. For
example, <b>git commit --amend --no-edit</b> amends a commit
without changing its commit message.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--amend</font></p>

<p style="margin-left:17%;"><font color="#000000">Replace
the tip of the current branch by creating a new commit. The
recorded tree is prepared as usual (including the effect of
the <b>-i</b> and <b>-o</b> options and explicit pathspec),
and the message from the original commit is used as the
starting point, instead of an empty message, when no other
message is specified from the command line via options such
as <b>-m</b>, <b>-F</b>, <b>-c</b>, etc. The new commit has
the same parents and author as the current one (the
<b>--reset-author</b> option can countermand
this).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">It
is a rough equivalent for:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">$
git reset --soft HEAD^ <br>
$ ... do something else to come up with the right tree ...
<br>
$ git commit -c ORIG_HEAD</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">but
can be used to amend a merge commit.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">You
should understand the implications of rewriting history if
you amend a commit that has already been published. (See the
&quot;RECOVERING FROM UPSTREAM REBASE&quot; section in
<b>git-rebase</b>(1).)</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--no-post-rewrite</font></p>

<p style="margin-left:17%;"><font color="#000000">Bypass
the post-rewrite hook.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-i,
--include</font></p>

<p style="margin-left:17%;"><font color="#000000">Before
making a commit out of staged contents so far, stage the
contents of paths given on the command line as well. This is
usually not what you want unless you are concluding a
conflicted merge.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-o,
--only</font></p>

<p style="margin-left:17%;"><font color="#000000">Make a
commit by taking the updated working tree contents of the
paths specified on the command line, disregarding any
contents that have been staged for other paths. This is the
default mode of operation of <i>git commit</i> if any paths
are given on the command line, in which case this option can
be omitted. If this option is specified together with
<b>--amend</b>, then no paths need to be specified, which
can be used to amend the last commit without committing
changes that have already been staged. If used together with
<b>--allow-empty</b> paths are also not required, and an
empty commit will be created.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--pathspec-from-file=&lt;file&gt;</font></p>

<p style="margin-left:17%;"><font color="#000000">Pathspec
is passed in <b>&lt;file&gt;</b> instead of commandline
args. If <b>&lt;file&gt;</b> is exactly <b>-</b> then
standard input is used. Pathspec elements are separated by
LF or CR/LF. Pathspec elements can be quoted as explained
for the configuration variable <b>core.quotePath</b> (see
<b>git-config</b>(1)). See also <b>--pathspec-file-nul</b>
and global <b>--literal-pathspecs</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--pathspec-file-nul</font></p>

<p style="margin-left:17%;"><font color="#000000">Only
meaningful with <b>--pathspec-from-file</b>. Pathspec
elements are separated with NUL character and all other
characters are taken literally (including newlines and
quotes).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-u[&lt;mode&gt;],
--untracked-files[=&lt;mode&gt;]</font></p>

<p style="margin-left:17%;"><font color="#000000">Show
untracked files.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
mode parameter is optional (defaults to <i>all</i>), and is
used to specify the handling of untracked files; when -u is
not used, the default is <i>normal</i>, i.e. show untracked
files and directories.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
possible options are:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
<i>no</i> - Show no untracked files</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
<i>normal</i> - Shows untracked files and
directories</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
<i>all</i> - Also shows individual files in untracked
directories.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
default can be changed using the status.showUntrackedFiles
configuration variable documented in
<b>git-config</b>(1).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-v,
--verbose</font></p>

<p style="margin-left:17%;"><font color="#000000">Show
unified diff between the HEAD commit and what would be
committed at the bottom of the commit message template to
help the user describe the commit by reminding what changes
the commit has. Note that this diff output doesn&rsquo;t
have its lines prefixed with <i>#</i>. This diff will not be
a part of the commit message. See the <b>commit.verbose</b>
configuration variable in <b>git-config</b>(1).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
specified twice, show in addition the unified diff between
what would be committed and the worktree files, i.e. the
unstaged changes to tracked files.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-q,
--quiet</font></p>

<p style="margin-left:17%;"><font color="#000000">Suppress
commit summary message.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--dry-run</font></p>

<p style="margin-left:17%;"><font color="#000000">Do not
create a commit, but show a list of paths that are to be
committed, paths with local changes that will be left
uncommitted and paths that are untracked.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--status</font></p>

<p style="margin-left:17%;"><font color="#000000">Include
the output of <b>git-status</b>(1) in the commit message
template when using an editor to prepare the commit message.
Defaults to on, but can be used to override configuration
variable commit.status.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--no-status</font></p>

<p style="margin-left:17%;"><font color="#000000">Do not
include the output of <b>git-status</b>(1) in the commit
message template when using an editor to prepare the default
commit message.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">-S[&lt;keyid&gt;],
--gpg-sign[=&lt;keyid&gt;], --no-gpg-sign</font></p>

<p style="margin-left:17%;"><font color="#000000">GPG-sign
commits. The <b>keyid</b> argument is optional and defaults
to the committer identity; if specified, it must be stuck to
the option without a space. <b>--no-gpg-sign</b> is useful
to countermand both <b>commit.gpgSign</b> configuration
variable, and earlier <b>--gpg-sign</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">--</font></p>

<p style="margin-left:17%;"><font color="#000000">Do not
interpret any more arguments as options.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&lt;pathspec&gt;...</font></p>

<p style="margin-left:17%;"><font color="#000000">When
pathspec is given on the command line, commit the contents
of the files that match the pathspec without recording the
changes already added to the index. The contents of these
files are also staged for the next commit on top of what
have been staged before.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">For
more details, see the <i>pathspec</i> entry in
<b>gitglossary</b>(7).</font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">When
recording your own work, the contents of modified files in
your working tree are temporarily stored to a staging area
called the &quot;index&quot; with <i>git add</i>. A file can
be reverted back, only in the index but not in the working
tree, to that of the last commit with <b>git restore
--staged &lt;file&gt;</b>, which effectively reverts <i>git
add</i> and prevents the changes to this file from
participating in the next commit. After building the state
to be committed incrementally with these commands, <b>git
commit</b> (without any pathname parameter) is used to
record what has been staged so far. This is the most basic
form of the command. An example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
edit hello.c <br>
$ git rm goodbye.c <br>
$ git add hello.c <br>
$ git commit</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Instead
of staging files after each individual change, you can tell
<b>git commit</b> to notice the changes to the files whose
contents are tracked in your working tree and do
corresponding <b>git add</b> and <b>git rm</b> for you. That
is, this example does the same as the earlier example if
there is no other change in your working tree:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
edit hello.c <br>
$ rm goodbye.c <br>
$ git commit -a</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command <b>git commit -a</b> first looks at your working
tree, notices that you have modified hello.c and removed
goodbye.c, and performs necessary <b>git add</b> and <b>git
rm</b> for you.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">After
staging changes to many files, you can alter the order the
changes are recorded in, by giving pathnames to <b>git
commit</b>. When pathnames are given, the command makes a
commit that only records the changes made to the named
paths:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
edit hello.c hello.h <br>
$ git add hello.c hello.h <br>
$ edit Makefile <br>
$ git commit Makefile</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
makes a commit that records the modification to
<b>Makefile</b>. The changes staged for <b>hello.c</b> and
<b>hello.h</b> are not included in the resulting commit.
However, their changes are not lost &mdash; they are still
staged and merely held back. After the above sequence, if
you do:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git commit</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">this
second commit would record the changes to <b>hello.c</b> and
<b>hello.h</b> as expected.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">After
a merge (initiated by <i>git merge</i> or <i>git pull</i>)
stops because of conflicts, cleanly merged paths are already
staged to be committed for you, and paths that conflicted
are left in unmerged state. You would have to first check
which paths are conflicting with <i>git status</i> and after
fixing them manually in your working tree, you would stage
the result as usual with <i>git add</i>:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git status | grep unmerged <br>
unmerged: hello.c <br>
$ edit hello.c <br>
$ git add hello.c</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">After
resolving conflicts and staging the result, <b>git ls-files
-u</b> would stop mentioning the conflicted path. When you
are done, run <b>git commit</b> to finally record the
merge:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git commit</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">As
with the case to record your own changes, you can use
<b>-a</b> option to save typing. One difference is that
during a merge resolution, you cannot use <b>git commit</b>
with pathnames to alter the order the changes are committed,
because the merge should be recorded as a single commit. In
fact, the command refuses to run when given pathnames (but
see <b>-i</b> option).</font></p>

<h2>COMMIT INFORMATION
<a name="COMMIT INFORMATION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Author
and committer information is taken from the following
environment variables, if set:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">GIT_AUTHOR_NAME
<br>
GIT_AUTHOR_EMAIL <br>
GIT_AUTHOR_DATE <br>
GIT_COMMITTER_NAME <br>
GIT_COMMITTER_EMAIL <br>
GIT_COMMITTER_DATE</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">(nb
&quot;&lt;&quot;, &quot;&gt;&quot; and &quot;\n&quot;s are
stripped)</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
author and committer names are by convention some form of a
personal name (that is, the name by which other humans refer
to you), although Git does not enforce or require any
particular form. Arbitrary Unicode may be used, subject to
the constraints listed above. This name has no effect on
authentication; for that, see the <b>credential.username</b>
variable in <b>git-config</b>(1).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">In
case (some of) these environment variables are not set, the
information is taken from the configuration items
<b>user.name</b> and <b>user.email</b>, or, if not present,
the environment variable EMAIL, or, if that is not set,
system user name and the hostname used for outgoing mail
(taken from <b>/etc/mailname</b> and falling back to the
fully qualified hostname when that file does not
exist).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>author.name</b> and <b>committer.name</b> and their
corresponding email options override <b>user.name</b> and
<b>user.email</b> if set and are overridden themselves by
the environment variables.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
typical usage is to set just the <b>user.name</b> and
<b>user.email</b> variables; the other options are provided
for more complex use cases.</font></p>

<h2>DATE FORMATS
<a name="DATE FORMATS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>GIT_AUTHOR_DATE</b> and <b>GIT_COMMITTER_DATE</b>
environment variables support the following date
formats:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Git
internal format</font></p>

<p style="margin-left:17%;"><font color="#000000">It is
<b>&lt;unix timestamp&gt; &lt;time zone offset&gt;</b>,
where <b>&lt;unix timestamp&gt;</b> is the number of seconds
since the UNIX epoch. <b>&lt;time zone offset&gt;</b> is a
positive or negative offset from UTC. For example CET (which
is 1 hour ahead of UTC) is <b>+0100</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">RFC
2822</font></p>

<p style="margin-left:17%;"><font color="#000000">The
standard email format as described by RFC 2822, for example
<b>Thu, 07 Apr 2005 22:13:13 +0200</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">ISO
8601</font></p>

<p style="margin-left:17%;"><font color="#000000">Time and
date specified by the ISO 8601 standard, for example
<b>2005-04-07T22:13:13</b>. The parser accepts a space
instead of the <b>T</b> character as well. Fractional parts
of a second will be ignored, for example
<b>2005-04-07T22:13:13.019</b> will be treated as
<b>2005-04-07T22:13:13</b>.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b>
<br>
In addition, the date part is accepted in the following
formats: <b>YYYY.MM.DD</b>, <b>MM/DD/YYYY</b> and
<b>DD.MM.YYYY</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">In
addition to recognizing all date formats above, the
<b>--date</b> option will also try to make sense of other,
more human-centric date formats, such as relative dates like
&quot;yesterday&quot; or &quot;last Friday at
noon&quot;.</font></p>

<h2>DISCUSSION
<a name="DISCUSSION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>Though
not required, it&rsquo;s a good idea to begin the commit
message with a single short (less than 50 character) line
summarizing the change, followed by a blank line and then a
more thorough description. The text up to the first blank
line in a commit message is treated as the commit title, and
that title is used throughout Git. For example,
<b>git-format-patch</b>(1) turns a commit into email, and it
uses the title on the Subject line and the rest of the
commit in the body.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>Git
is to some extent character encoding
agnostic.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>&bull;
The contents of the blob objects are uninterpreted sequences
of bytes. There is no encoding translation at the core
level.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>&bull;
Path names are encoded in UTF-8 normalization form C. This
applies to tree objects, the index file, ref names, as well
as path names in command line arguments, environment
variables and config files (<b>.git/config</b> (see
<b>git-config</b>(1)), <b>gitignore</b>(5),
<b>gitattributes</b>(5) and
<b>gitmodules</b>(5)).</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Note
that Git at the core level treats path names simply as
sequences of non-NUL bytes, there are no path name encoding
conversions (except on Mac and Windows). Therefore, using
non-ASCII path names will mostly work even on platforms and
file systems that use legacy extended ASCII encodings.
However, repositories created on such systems will not work
properly on UTF-8-based systems (e.g. Linux, Mac, Windows)
and vice versa. Additionally, many Git-based tools simply
assume path names to be UTF-8 and will fail to display other
encodings correctly.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>&bull;
Commit log messages are typically encoded in UTF-8, but
other extended ASCII encodings are also supported. This
includes ISO-8859-x, CP125x and many others, but <i>not</i>
UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK,
Shift-JIS, Big5, EUC-x, CP9xx etc.).</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>Although
we encourage that the commit log messages are encoded in
UTF-8, both the core and Git Porcelain are designed not to
force UTF-8 on projects. If all participants of a particular
project find it more convenient to use legacy encodings, Git
does not forbid it. However, there are a few things to keep
in mind.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>1.
<i>git commit</i> and <i>git commit-tree</i> issues a
warning if the commit log message given to it does not look
like a valid UTF-8 string, unless you explicitly say your
project uses a legacy encoding. The way to say this is to
have <b>i18n.commitEncoding</b> in <b>.git/config</b> file,
like this:</big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big>[i18n]
<br>
commitEncoding = ISO-8859-1</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Commit
objects created with the above setting record the value of
<b>i18n.commitEncoding</b> in its <b>encoding</b> header.
This is to help other people who look at them later. Lack of
this header implies that the commit log message is encoded
in UTF-8.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>2.
<i>git log</i>, <i>git show</i>, <i>git blame</i> and
friends look at the <b>encoding</b> header of a commit
object, and try to re-code the log message into UTF-8 unless
otherwise specified. You can specify the desired output
encoding with <b>i18n.logOutputEncoding</b> in
<b>.git/config</b> file, like this:</big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big>[i18n]
<br>
logOutputEncoding = ISO-8859-1</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>If
you do not have this configuration variable, the value of
<b>i18n.commitEncoding</b> is used instead.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>Note
that we deliberately chose not to re-code the commit log
message when a commit is made to force UTF-8 at the commit
object level, because re-coding to UTF-8 is not necessarily
a reversible operation.</big></font></p>

<h2>ENVIRONMENT AND CONFIGURATION VARIABLES
<a name="ENVIRONMENT AND CONFIGURATION VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>The
editor used to edit the commit log message will be chosen
from the <b>GIT_EDITOR</b> environment variable, the
core.editor configuration variable, the <b>VISUAL</b>
environment variable, or the <b>EDITOR</b> environment
variable (in that order). See <b>git-var</b>(1) for
details.</big></font></p>

<h2>HOOKS
<a name="HOOKS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>This
command can run <b>commit-msg</b>,
<b>prepare-commit-msg</b>, <b>pre-commit</b>,
<b>post-commit</b> and <b>post-rewrite</b> hooks. See
<b>githooks</b>(5) for more information.</big></font></p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><b>$GIT_DIR/COMMIT_EDITMSG</b></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big>This
file contains the commit message of a commit in progress. If
<b>git commit</b> exits due to an error before creating a
commit, any commit message that has been provided by the
user (e.g., in an editor session) will be available in this
file, but will be overwritten by the next invocation of
<b>git commit</b>.</big></font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><b>git-add</b>(1),
<b>git-rm</b>(1), <b>git-mv</b>(1), <b>git-merge</b>(1),
<b>git-commit-tree</b>(1)</big></font></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>Part
of the <b>git</b>(1) suite</big></font></p>
<hr>
</body>
</html>
