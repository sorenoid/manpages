<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:00 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GITATTRIBUTES</title>

</head>
<body>

<h1 align="center">GITATTRIBUTES</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EFFECTS">EFFECTS</a><br>
<a href="#USING MACRO ATTRIBUTES">USING MACRO ATTRIBUTES</a><br>
<a href="#DEFINING MACRO ATTRIBUTES">DEFINING MACRO ATTRIBUTES</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">gitattributes -
Defining attributes per path</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">$GIT_DIR/info/attributes,
.gitattributes</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A
<b>gitattributes</b> file is a simple text file that gives
<b>attributes</b> to pathnames.</p>

<p style="margin-left:11%; margin-top: 1em">Each line in
<b>gitattributes</b> file is of form:</p>

<p style="margin-left:17%; margin-top: 1em">pattern attr1
attr2 ...</p>

<p style="margin-left:11%; margin-top: 1em">That is, a
pattern followed by an attributes list, separated by
whitespaces. Leading and trailing whitespaces are ignored.
Lines that begin with <i>#</i> are ignored. Patterns that
begin with a double quote are quoted in C style. When the
pattern matches the path in question, the attributes listed
on the line are given to the path.</p>

<p style="margin-left:11%; margin-top: 1em">Each attribute
can be in one of these states for a given path:</p>

<p style="margin-left:11%; margin-top: 1em">Set</p>

<p style="margin-left:17%;">The path has the attribute with
special value &quot;true&quot;; this is specified by listing
only the name of the attribute in the attribute list.</p>

<p style="margin-left:11%; margin-top: 1em">Unset</p>

<p style="margin-left:17%;">The path has the attribute with
special value &quot;false&quot;; this is specified by
listing the name of the attribute prefixed with a dash
<b>-</b> in the attribute list.</p>

<p style="margin-left:11%; margin-top: 1em">Set to a
value</p>

<p style="margin-left:17%;">The path has the attribute with
specified string value; this is specified by listing the
name of the attribute followed by an equal sign <b>=</b> and
its value in the attribute list.</p>


<p style="margin-left:11%; margin-top: 1em">Unspecified</p>

<p style="margin-left:17%;">No pattern matches the path,
and nothing says if the path has or does not have the
attribute, the attribute for the path is said to be
Unspecified.</p>

<p style="margin-left:11%; margin-top: 1em">When more than
one pattern matches the path, a later line overrides an
earlier line. This overriding is done per attribute.</p>

<p style="margin-left:11%; margin-top: 1em">The rules by
which the pattern matches paths are the same as in
<b>.gitignore</b> files (see <b>gitignore</b>(5)), with a
few exceptions:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; negative
patterns are forbidden</p>

<p style="margin-left:17%; margin-top: 1em">&bull; patterns
that match a directory do not recursively match paths inside
that directory (so using the trailing-slash <b>path/</b>
syntax is pointless in an attributes file; use
<b>path/**</b> instead)</p>

<p style="margin-left:11%; margin-top: 1em">When deciding
what attributes are assigned to a path, Git consults
<b>$GIT_DIR/info/attributes</b> file (which has the highest
precedence), <b>.gitattributes</b> file in the same
directory as the path in question, and its parent
directories up to the toplevel of the work tree (the further
the directory that contains <b>.gitattributes</b> is from
the path in question, the lower its precedence). Finally
global and system-wide files are considered (they have the
lowest precedence).</p>

<p style="margin-left:11%; margin-top: 1em">When the
<b>.gitattributes</b> file is missing from the work tree,
the path in the index is used as a fall-back. During
checkout process, <b>.gitattributes</b> in the index is used
and then the file in the working tree is used as a
fall-back.</p>

<p style="margin-left:11%; margin-top: 1em">If you wish to
affect only a single repository (i.e., to assign attributes
to files that are particular to one user&rsquo;s workflow
for that repository), then attributes should be placed in
the <b>$GIT_DIR/info/attributes</b> file. Attributes which
should be version-controlled and distributed to other
repositories (i.e., attributes of interest to all users)
should go into <b>.gitattributes</b> files. Attributes that
should affect all repositories for a single user should be
placed in a file specified by the <b>core.attributesFile</b>
configuration option (see <b>git-config</b>(1)). Its default
value is $XDG_CONFIG_HOME/git/attributes. If
$XDG_CONFIG_HOME is either not set or empty,
$HOME/.config/git/attributes is used instead. Attributes for
all users on a system should be placed in the
<b>$(prefix)/etc/gitattributes</b> file.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes you
would need to override a setting of an attribute for a path
to <b>Unspecified</b> state. This can be done by listing the
name of the attribute prefixed with an exclamation point
<b>!</b>.</p>

<h2>EFFECTS
<a name="EFFECTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Certain
operations by Git can be influenced by assigning particular
attributes to a path. Currently, the following operations
are attributes-aware.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Checking-out
and checking-in</b> <br>
These attributes affect how the contents stored in the
repository are copied to the working tree files when
commands such as <i>git switch</i>, <i>git checkout</i> and
<i>git merge</i> run. They also affect how Git stores the
contents you prepare in the working tree in the repository
upon <i>git add</i> and <i>git commit</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>text</big></b></p>

<p style="margin-left:17%;">This attribute enables and
controls end-of-line normalization. When a text file is
normalized, its line endings are converted to LF in the
repository. To control what line ending style is used in the
working directory, use the <b>eol</b> attribute for a single
file and the <b>core.eol</b> configuration variable for all
text files. Note that setting <b>core.autocrlf</b> to
<b>true</b> or <b>input</b> overrides <b>core.eol</b> (see
the definitions of those options in
<b>git-config</b>(1)).</p>

<p style="margin-left:17%; margin-top: 1em">Set</p>

<p style="margin-left:23%;">Setting the <b>text</b>
attribute on a path enables end-of-line normalization and
marks the path as a text file. End-of-line conversion takes
place without guessing the content type.</p>

<p style="margin-left:17%; margin-top: 1em">Unset</p>

<p style="margin-left:23%;">Unsetting the <b>text</b>
attribute on a path tells Git not to attempt any end-of-line
conversion upon checkin or checkout.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;auto&quot;</p>

<p style="margin-left:23%;">When <b>text</b> is set to
&quot;auto&quot;, the path is marked for automatic
end-of-line conversion. If Git decides that the content is
text, its line endings are converted to LF on checkin. When
the file has been committed with CRLF, no conversion is
done.</p>


<p style="margin-left:17%; margin-top: 1em">Unspecified</p>

<p style="margin-left:23%;">If the <b>text</b> attribute is
unspecified, Git uses the <b>core.autocrlf</b> configuration
variable to determine if the file should be converted.</p>

<p style="margin-left:17%; margin-top: 1em">Any other value
causes Git to act as if <b>text</b> has been left
unspecified.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>eol</big></b></p>

<p style="margin-left:17%;">This attribute sets a specific
line-ending style to be used in the working directory. It
enables end-of-line conversion without any content checks,
effectively setting the <b>text</b> attribute. Note that
setting this attribute on paths which are in the index with
CRLF line endings may make the paths to be considered dirty.
Adding the path to the index again will normalize the line
endings in the index.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;crlf&quot;</p>

<p style="margin-left:23%;">This setting forces Git to
normalize line endings for this file on checkin and convert
them to CRLF when the file is checked out.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;lf&quot;</p>

<p style="margin-left:23%;">This setting forces Git to
normalize line endings to LF on checkin and prevents
conversion to CRLF when the file is checked out.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>Backwards
compatibility with crlf attribute</big></b></p>

<p style="margin-left:17%;">For backwards compatibility,
the <b>crlf</b> attribute is interpreted as follows:</p>

<p style="margin-left:23%; margin-top: 1em">crlf text <br>
-crlf -text <br>
crlf=input eol=lf</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>End-of-line
conversion</big></b></p>

<p style="margin-left:17%;">While Git normally leaves file
contents alone, it can be configured to normalize line
endings to LF in the repository and, optionally, to convert
them to CRLF when files are checked out.</p>

<p style="margin-left:17%; margin-top: 1em">If you simply
want to have CRLF line endings in your working directory
regardless of the repository you are working with, you can
set the config variable &quot;core.autocrlf&quot; without
using any attributes.</p>

<p style="margin-left:23%; margin-top: 1em">[core] <br>
autocrlf = true</p>

<p style="margin-left:17%; margin-top: 1em">This does not
force normalization of text files, but does ensure that text
files that you introduce to the repository have their line
endings normalized to LF when they are added, and that files
that are already normalized in the repository stay
normalized.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
ensure that text files that any contributor introduces to
the repository have their line endings normalized, you can
set the <b>text</b> attribute to &quot;auto&quot; for
<i>all</i> files.</p>

<p style="margin-left:23%; margin-top: 1em">* text=auto</p>

<p style="margin-left:17%; margin-top: 1em">The attributes
allow a fine-grained control, how the line endings are
converted. Here is an example that will make Git normalize
.txt, .vcproj and .sh files, ensure that .vcproj files have
CRLF and .sh files have LF in the working directory, and
prevent .jpg files from being normalized regardless of their
content.</p>

<p style="margin-left:23%; margin-top: 1em">* text=auto
<br>
*.txt text <br>
*.vcproj text eol=crlf <br>
*.sh text eol=lf <br>
*.jpg -text</p>


<p style="margin-left:23%; margin-top: 1em"><b><big>Note</big></b>
<br>
When <b>text=auto</b> conversion is enabled in a
cross-platform project using push and pull to a central
repository the text files containing CRLFs should be
normalized.</p>

<p style="margin-left:17%; margin-top: 1em">From a clean
working directory:</p>

<p style="margin-left:23%; margin-top: 1em">$ echo &quot;*
text=auto&quot; &gt;.gitattributes <br>
$ git add --renormalize . <br>
$ git status # Show files that will be normalized <br>
$ git commit -m &quot;Introduce end-of-line
normalization&quot;</p>

<p style="margin-left:17%; margin-top: 1em">If any files
that should not be normalized show up in <i>git status</i>,
unset their <b>text</b> attribute before running <i>git add
-u</i>.</p>

<p style="margin-left:23%; margin-top: 1em">manual.pdf
-text</p>

<p style="margin-left:17%; margin-top: 1em">Conversely,
text files that Git does not detect can have normalization
enabled manually.</p>

<p style="margin-left:23%; margin-top: 1em">weirdchars.txt
text</p>

<p style="margin-left:17%; margin-top: 1em">If
<b>core.safecrlf</b> is set to &quot;true&quot; or
&quot;warn&quot;, Git verifies if the conversion is
reversible for the current setting of <b>core.autocrlf</b>.
For &quot;true&quot;, Git rejects irreversible conversions;
for &quot;warn&quot;, Git only prints a warning but accepts
an irreversible conversion. The safety triggers to prevent
such a conversion done to the files in the work tree, but
there are a few exceptions. Even though...</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
add</i> itself does not touch the files in the work tree,
the next checkout would, so the safety triggers;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
apply</i> to update a text file with a patch does touch the
files in the work tree, but the operation is about text
files and CRLF conversion is about fixing the line ending
inconsistencies, so the safety does not trigger;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
diff</i> itself does not touch the files in the work tree,
it is often run to inspect the changes you intend to next
<i>git add</i>. To catch potential problems early, safety
triggers.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>working-tree-encoding</big></b></p>

<p style="margin-left:17%;"><big>Git recognizes files
encoded in ASCII or one of its supersets (e.g. UTF-8,
ISO-8859-1, ...) as text files. Files encoded in certain
other encodings (e.g. UTF-16) are interpreted as binary and
consequently built-in Git text processing tools (e.g. <i>git
diff</i>) as well as most Git web front ends do not
visualize the contents of these files by default.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In these
cases you can tell Git the encoding of a file in the working
directory with the <b>working-tree-encoding</b> attribute.
If a file with this attribute is added to Git, then Git
re-encodes the content from the specified encoding to UTF-8.
Finally, Git stores the UTF-8 encoded content in its
internal data structure (called &quot;the index&quot;). On
checkout the content is re-encoded back to the specified
encoding.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Please
note that using the <b>working-tree-encoding</b> attribute
may have a number of pitfalls:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
Alternative Git implementations (e.g. JGit or libgit2) and
older Git versions (as of March 2018) do not support the
<b>working-tree-encoding</b> attribute. If you decide to use
the <b>working-tree-encoding</b> attribute in your
repository, then it is strongly recommended to ensure that
all clients working with the repository support
it.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>For
example, Microsoft Visual Studio resources files
(<b>*.rc</b>) or PowerShell script files (<b>*.ps1</b>) are
sometimes encoded in UTF-16. If you declare <b>*.ps1</b> as
files as UTF-16 and you add <b>foo.ps1</b> with a
<b>working-tree-encoding</b> enabled Git client, then
<b>foo.ps1</b> will be stored as UTF-8 internally. A client
without <b>working-tree-encoding</b> support will checkout
<b>foo.ps1</b> as UTF-8 encoded file. This will typically
cause trouble for the users of this file.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>If a Git
client that does not support the
<b>working-tree-encoding</b> attribute adds a new file
<b>bar.ps1</b>, then <b>bar.ps1</b> will be stored
&quot;as-is&quot; internally (in this example probably as
UTF-16). A client with <b>working-tree-encoding</b> support
will interpret the internal contents as UTF-8 and try to
convert it to UTF-16 on checkout. That operation will fail
and cause an error.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
Reencoding content to non-UTF encodings can cause errors as
the conversion might not be UTF-8 round trip safe. If you
suspect your encoding to not be round trip safe, then add it
to <b>core.checkRoundtripEncoding</b> to make Git check the
round trip encoding (see <b>git-config</b>(1)). SHIFT-JIS
(Japanese character set) is known to have round trip issues
with UTF-8 and is checked by default.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
Reencoding content requires resources that might slow down
certain Git operations (e.g <i>git checkout</i> or <i>git
add</i>).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Use the
<b>working-tree-encoding</b> attribute only if you cannot
store a file in UTF-8 encoding and if you want Git to be
able to process the content as text.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>As an
example, use the following attributes if your <i>*.ps1</i>
files are UTF-16 encoded with byte order mark (BOM) and you
want Git to perform automatic line ending conversion based
on your platform.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.ps1 text
working-tree-encoding=UTF-16</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Use the
following attributes if your <i>*.ps1</i> files are UTF-16
little endian encoded without BOM and you want Git to use
Windows line endings in the working directory (use
<b>UTF-16LE-BOM</b> instead of <b>UTF-16LE</b> if you want
UTF-16 little endian with BOM). Please note, it is highly
recommended to explicitly define the line endings with
<b>eol</b> if the <b>working-tree-encoding</b> attribute is
used to avoid ambiguity.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.ps1 text
working-tree-encoding=UTF-16LE eol=CRLF</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>You can
get a list of all available encodings on your platform with
the following command:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>iconv
--list</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If you do
not know the encoding of a file, then you can use the
<b>file</b> command to guess the encoding:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>file
foo.ps1</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>ident</big></b></big></p>

<p style="margin-left:17%;"><big>When the attribute
<b>ident</b> is set for a path, Git replaces <b>$Id$</b> in
the blob object with <b>$Id:</b>, followed by the
40-character hexadecimal blob object name, followed by a
dollar sign <b>$</b> upon checkout. Any byte sequence that
begins with <b>$Id:</b> and ends with <b>$</b> in the
worktree file is replaced with <b>$Id$</b> upon
check-in.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>filter</big></b></big></p>

<p style="margin-left:17%;"><big>A <b>filter</b> attribute
can be set to a string value that names a filter driver
specified in the configuration.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>A filter
driver consists of a <b>clean</b> command and a
<b>smudge</b> command, either of which can be left
unspecified. Upon checkout, when the <b>smudge</b> command
is specified, the command is fed the blob object from its
standard input, and its standard output is used to update
the worktree file. Similarly, the <b>clean</b> command is
used to convert the contents of worktree file upon checkin.
By default these commands process only a single blob and
terminate. If a long running <b>process</b> filter is used
in place of <b>clean</b> and/or <b>smudge</b> filters, then
Git can process all blobs with a single filter command
invocation for the entire life of a single Git command, for
example <b>git add --all</b>. If a long running
<b>process</b> filter is configured then it always takes
precedence over a configured single blob filter. See section
below for the description of the protocol used to
communicate with a <b>process</b> filter.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>One use of
the content filtering is to massage the content into a shape
that is more convenient for the platform, filesystem, and
the user to use. For this mode of operation, the key phrase
here is &quot;more convenient&quot; and not &quot;turning
something unusable into usable&quot;. In other words, the
intent is that if someone unsets the filter driver
definition, or does not have the appropriate filter program,
the project should still be usable.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Another
use of the content filtering is to store the content that
cannot be directly used in the repository (e.g. a UUID that
refers to the true content stored outside Git, or an
encrypted content) and turn it into a usable form upon
checkout (e.g. download the external content, or decrypt the
encrypted content).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>These two
filters behave differently, and by default, a filter is
taken as the former, massaging the contents into more
convenient shape. A missing filter driver definition in the
config, or a filter driver that exits with a non-zero
status, is not an error but makes the filter a no-op
passthru.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>You can
declare that a filter turns a content that by itself is
unusable into a usable content by setting the
filter.&lt;driver&gt;.required configuration variable to
<b>true</b>.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note:
Whenever the clean filter is changed, the repo should be
renormalized: $ git add --renormalize .</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For
example, in .gitattributes, you would assign the
<b>filter</b> attribute for paths.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.c
filter=indent</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Then you
would define a &quot;filter.indent.clean&quot; and
&quot;filter.indent.smudge&quot; configuration in your
.git/config to specify a pair of commands to modify the
contents of C programs when the source files are checked in
(&quot;clean&quot; is run) and checked out (no change is
made because the command is &quot;cat&quot;).</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;indent&quot;] <br>
clean = indent <br>
smudge = cat</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For best
results, <b>clean</b> should not alter its output further if
it is run twice (&quot;clean&rarr;clean&quot; should be
equivalent to &quot;clean&quot;), and multiple <b>smudge</b>
commands should not alter <b>clean</b>'s output
(&quot;smudge&rarr;smudge&rarr;clean&quot; should be
equivalent to &quot;clean&quot;). See the section on merging
below.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
&quot;indent&quot; filter is well-behaved in this regard: it
will not modify input that is already correctly indented. In
this case, the lack of a smudge filter means that the clean
filter <i>must</i> accept its own output without modifying
it.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If a
filter <i>must</i> succeed in order to make the stored
contents usable, you can declare that the filter is
<b>required</b>, in the configuration:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;crypt&quot;] <br>
clean = openssl enc ... <br>
smudge = openssl enc -d ... <br>
required</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Sequence
&quot;%f&quot; on the filter command line is replaced with
the name of the file the filter is working on. A filter
might use this in keyword substitution. For
example:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;p4&quot;] <br>
clean = git-p4-filter --clean %f <br>
smudge = git-p4-filter --smudge %f</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note that
&quot;%f&quot; is the name of the path that is being worked
on. Depending on the version that is being filtered, the
corresponding file on disk may not exist, or may have
different contents. So, smudge and clean commands should not
try to access the file on disk, but only act as filters on
the content provided to them on standard input.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Long
Running Filter Process</big></b></big></p>

<p style="margin-left:17%;"><big>If the filter command (a
string value) is defined via
<b>filter.&lt;driver&gt;.process</b> then Git can process
all blobs with a single filter invocation for the entire
life of a single Git command. This is achieved by using the
long-running process protocol (described in
technical/long-running-process-protocol.txt).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>When Git
encounters the first file that needs to be cleaned or
smudged, it starts the filter and performs the handshake. In
the handshake, the welcome message sent by Git is
&quot;git-filter-client&quot;, only version 2 is supported,
and the supported capabilities are &quot;clean&quot;,
&quot;smudge&quot;, and &quot;delay&quot;.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Afterwards
Git sends a list of &quot;key=value&quot; pairs terminated
with a flush packet. The list will contain at least the
filter command (based on the supported capabilities) and the
pathname of the file to filter relative to the repository
root. Right after the flush packet Git sends the content
split in zero or more pkt-line packets and a flush packet to
terminate content. Please note, that the filter must not
send any response before it received the content and the
final flush packet. Also note that the &quot;value&quot; of
a &quot;key=value&quot; pair can contain the &quot;=&quot;
character whereas the key would never contain that
character.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=smudge <br>
packet: git&gt; pathname=path/testfile.dat <br>
packet: git&gt; 0000 <br>
packet: git&gt; CONTENT <br>
packet: git&gt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The filter
is expected to respond with a list of &quot;key=value&quot;
pairs terminated with a flush packet. If the filter does not
experience problems then the list must contain a
&quot;success&quot; status. Right after these packets the
filter is expected to send the content in zero or more
pkt-line packets and a flush packet at the end. Finally, a
second list of &quot;key=value&quot; pairs terminated with a
flush packet is expected. The filter can change the status
in the second list or keep the status as is with an empty
list. Please note that the empty list must be terminated
with a flush packet regardless.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; SMUDGED_CONTENT <br>
packet: git&lt; 0000 <br>
packet: git&lt; 0000 # empty list, keep
&quot;status=success&quot; unchanged!</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
result content is empty then the filter is expected to
respond with a &quot;success&quot; status and a flush packet
to signal the empty content.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; 0000 # empty content! <br>
packet: git&lt; 0000 # empty list, keep
&quot;status=success&quot; unchanged!</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In case
the filter cannot or does not want to process the content,
it is expected to respond with an &quot;error&quot;
status.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=error <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
filter experiences an error during processing, then it can
send the status &quot;error&quot; after the content was
(partially or completely) sent.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; HALF_WRITTEN_ERRONEOUS_CONTENT <br>
packet: git&lt; 0000 <br>
packet: git&lt; status=error <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In case
the filter cannot or does not want to process the content as
well as any future content for the lifetime of the Git
process, then it is expected to respond with an
&quot;abort&quot; status at any point in the
protocol.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=abort <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Git
neither stops nor restarts the filter process in case the
&quot;error&quot;/&quot;abort&quot; status is set. However,
Git sets its exit code according to the
<b>filter.&lt;driver&gt;.required</b> flag, mimicking the
behavior of the <b>filter.&lt;driver&gt;.clean</b> /
<b>filter.&lt;driver&gt;.smudge</b> mechanism.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
filter dies during the communication or does not adhere to
the protocol then Git will stop the filter process and
restart it with the next file that needs to be processed.
Depending on the <b>filter.&lt;driver&gt;.required</b> flag
Git will interpret that as error.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Delay</big></b></big></p>

<p style="margin-left:17%;"><big>If the filter supports the
&quot;delay&quot; capability, then Git can send the flag
&quot;can-delay&quot; after the filter command and pathname.
This flag denotes that the filter can delay filtering the
current blob (e.g. to compensate network latencies) by
responding with no content but with the status
&quot;delayed&quot; and a flush packet.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=smudge <br>
packet: git&gt; pathname=path/testfile.dat <br>
packet: git&gt; can-delay=1 <br>
packet: git&gt; 0000 <br>
packet: git&gt; CONTENT <br>
packet: git&gt; 0000 <br>
packet: git&lt; status=delayed <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
filter supports the &quot;delay&quot; capability then it
must support the &quot;list_available_blobs&quot; command.
If Git sends this command, then the filter is expected to
return a list of pathnames representing blobs that have been
delayed earlier and are now available. The list must be
terminated with a flush packet followed by a
&quot;success&quot; status that is also terminated with a
flush packet. If no blobs for the delayed paths are
available, yet, then the filter is expected to block the
response until at least one blob becomes available. The
filter can tell Git that it has no more delayed blobs by
sending an empty list. As soon as the filter responds with
an empty list, Git stops asking. All blobs that Git has not
received at this point are considered missing and will
result in an error.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=list_available_blobs <br>
packet: git&gt; 0000 <br>
packet: git&lt; pathname=path/testfile.dat <br>
packet: git&lt; pathname=path/otherfile.dat <br>
packet: git&lt; 0000 <br>
packet: git&lt; status=success <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>After Git
received the pathnames, it will request the corresponding
blobs again. These requests contain a pathname and an empty
content section. The filter is expected to respond with the
smudged content in the usual way as explained
above.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=smudge <br>
packet: git&gt; pathname=path/testfile.dat <br>
packet: git&gt; 0000 <br>
packet: git&gt; 0000 # empty content! <br>
packet: git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; SMUDGED_CONTENT <br>
packet: git&lt; 0000 <br>
packet: git&lt; 0000 # empty list, keep
&quot;status=success&quot; unchanged!</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Example</big></b></big></p>

<p style="margin-left:17%;"><big>A long running filter demo
implementation can be found in
<b>contrib/long-running-filter/example.pl</b> located in the
Git core repository. If you develop your own long running
filter process then the <b>GIT_TRACE_PACKET</b> environment
variables can be very helpful for debugging (see
<b>git</b>(1)).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Please
note that you cannot use an existing
<b>filter.&lt;driver&gt;.clean</b> or
<b>filter.&lt;driver&gt;.smudge</b> command with
<b>filter.&lt;driver&gt;.process</b> because the former two
use a different inter process communication protocol than
the latter one.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Interaction
between checkin/checkout attributes</big></b></big></p>

<p style="margin-left:17%;"><big>In the check-in codepath,
the worktree file is first converted with <b>filter</b>
driver (if specified and corresponding driver defined), then
the result is processed with <b>ident</b> (if specified),
and then finally with <b>text</b> (again, if specified and
applicable).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In the
check-out codepath, the blob content is first converted with
<b>text</b>, and then <b>ident</b> and fed to
<b>filter</b>.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Merging
branches with differing checkin/checkout
attributes</big></b></big></p>

<p style="margin-left:17%;"><big>If you have added
attributes to a file that cause the canonical repository
format for that file to change, such as adding a
clean/smudge filter or text/eol/ident attributes, merging
anything where the attribute is not in place would normally
cause merge conflicts.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>To prevent
these unnecessary merge conflicts, Git can be told to run a
virtual check-out and check-in of all three stages of a file
when resolving a three-way merge by setting the
<b>merge.renormalize</b> configuration variable. This
prevents changes caused by check-in conversion from causing
spurious merge conflicts when a converted file is merged
with an unconverted file.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>As long as
a &quot;smudge&rarr;clean&quot; results in the same output
as a &quot;clean&quot; even on files that are already
smudged, this strategy will automatically resolve all
filter-related conflicts. Filters that do not act in this
way may cause additional merge conflicts that must be
resolved manually.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b>Generating
diff text <big><br>
diff</big></b></big></p>

<p style="margin-left:17%;"><big>The attribute <b>diff</b>
affects how Git generates diffs for particular files. It can
tell Git whether to generate a textual patch for the path or
to treat the path as a binary file. It can also affect what
line is shown on the hunk header <b>@@ -k,l +n,m @@</b>
line, tell Git to use an external command to generate the
diff, or ask Git to convert binary files to a text format
before generating the diff.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Set</big></p>

<p style="margin-left:23%;"><big>A path to which the
<b>diff</b> attribute is set is treated as text, even when
they contain byte values that normally never appear in text
files, such as NUL.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Unset</big></p>

<p style="margin-left:23%;"><big>A path to which the
<b>diff</b> attribute is unset will generate <b>Binary files
differ</b> (or a binary patch, if binary patches are
enabled).</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Unspecified</big></p>

<p style="margin-left:23%;"><big>A path to which the
<b>diff</b> attribute is unspecified first gets its contents
inspected, and if it looks like text and is smaller than
core.bigFileThreshold, it is treated as text. Otherwise it
would generate <b>Binary files differ</b>.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>String</big></p>

<p style="margin-left:23%;"><big>Diff is shown using the
specified diff driver. Each driver may specify one or more
options, as described in the following section. The options
for the diff driver &quot;foo&quot; are defined by the
configuration variables in the &quot;diff.foo&quot; section
of the Git config file.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Defining
an external diff driver</big></b></big></p>

<p style="margin-left:17%;"><big>The definition of a diff
driver is done in <b>gitconfig</b>, not <b>gitattributes</b>
file, so strictly speaking this manual page is a wrong place
to talk about it. However...</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>To define
an external diff driver <b>jcdiff</b>, add a section to your
<b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file) like this:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;jcdiff&quot;] <br>
command = j-c-diff</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>When Git
needs to show you a diff for the path with <b>diff</b>
attribute set to <b>jcdiff</b>, it calls the command you
specified with the above configuration, i.e.
<b>j-c-diff</b>, with 7 parameters, just like
<b>GIT_EXTERNAL_DIFF</b> program is called. See
<b>git</b>(1) for details.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Defining
a custom hunk-header</big></b></big></p>

<p style="margin-left:17%;"><big>Each group of changes
(called a &quot;hunk&quot;) in the textual diff output is
prefixed with a line of the form:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>@@ -k,l
+n,m @@ TEXT</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>This is
called a <i>hunk header</i>. The &quot;TEXT&quot; portion is
by default a line that begins with an alphabet, an
underscore or a dollar sign; this matches what GNU <i>diff
-p</i> output uses. This default selection however is not
suited for some contents, and you can use a customized
pattern to make a selection.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>First, in
.gitattributes, you would assign the <b>diff</b> attribute
for paths.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.tex
diff=tex</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Then, you
would define a &quot;diff.tex.xfuncname&quot; configuration
to specify a regular expression that matches a line that you
would want to appear as the hunk header &quot;TEXT&quot;.
Add a section to your <b>$GIT_DIR/config</b> file (or
<b>$HOME/.gitconfig</b> file) like this:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;tex&quot;] <br>
xfuncname = &quot;^(\\\\(sub)*section\\{.*)$&quot;</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note. A
single level of backslashes are eaten by the configuration
file parser, so you would need to double the backslashes;
the pattern above picks a line that begins with a backslash,
and zero or more occurrences of <b>sub</b> followed by
<b>section</b> followed by open brace, to the end of
line.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>There are
a few built-in patterns to make this easier, and <b>tex</b>
is one of them, so you do not have to write the above in
your configuration file (you still need to enable this with
the attribute mechanism, via <b>.gitattributes</b>). The
following built in patterns are available:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>ada</b> suitable for source code in the Ada
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>bash</b> suitable for source code in the Bourne-Again
SHell language. Covers a superset of POSIX shell function
definitions.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>bibtex</b> suitable for files with BibTeX coded
references.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>cpp</b> suitable for source code in the C and C++
languages.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>csharp</b> suitable for source code in the C#
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>css</b> suitable for cascading style sheets.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>dts</b> suitable for devicetree (DTS) files.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>elixir</b> suitable for source code in the Elixir
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>fortran</b> suitable for source code in the Fortran
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>fountain</b> suitable for Fountain documents.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>golang</b> suitable for source code in the Go
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>html</b> suitable for HTML/XHTML documents.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>java</b> suitable for source code in the Java
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>markdown</b> suitable for Markdown documents.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>matlab</b> suitable for source code in the MATLAB and
Octave languages.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>objc</b> suitable for source code in the Objective-C
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>pascal</b> suitable for source code in the Pascal/Delphi
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>perl</b> suitable for source code in the Perl
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>php</b> suitable for source code in the PHP
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>python</b> suitable for source code in the Python
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>ruby</b> suitable for source code in the Ruby
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>rust</b> suitable for source code in the Rust
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>scheme</b> suitable for source code in the Scheme
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
<b>tex</b> suitable for source code for LaTeX
documents.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Customizing
word diff</big></b></big></p>

<p style="margin-left:17%;"><big>You can customize the
rules that <b>git diff --word-diff</b> uses to split words
in a line, by specifying an appropriate regular expression
in the &quot;diff.*.wordRegex&quot; configuration variable.
For example, in TeX a backslash followed by a sequence of
letters forms a command, but several such commands can be
run together without intervening whitespace. To separate
them, use a regular expression in your
<b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file) like this:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;tex&quot;] <br>
wordRegex =
&quot;\\\\[a-zA-Z]+|[{}]|\\\\.|[^\\{}[:space:]]+&quot;</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>A built-in
pattern is provided for all languages listed in the previous
section.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Performing
text diffs of binary files</big></b></big></p>

<p style="margin-left:17%;"><big>Sometimes it is desirable
to see the diff of a text-converted version of some binary
files. For example, a word processor document can be
converted to an ASCII text representation, and the diff of
the text shown. Even though this conversion loses some
information, the resulting diff is useful for human viewing
(but cannot be applied directly).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
<b>textconv</b> config option is used to define a program
for performing such a conversion. The program should take a
single argument, the name of a file to convert, and produce
the resulting text on stdout.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For
example, to show the diff of the exif information of a file
instead of the binary information (assuming you have the
exif tool installed), add the following section to your
<b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file):</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;jpg&quot;] <br>
textconv = exif</big></p>


<p style="margin-left:23%; margin-top: 1em"><big><b><big>Note</big></b>
<br>
The text conversion is generally a one-way conversion; in
this example, we lose the actual image contents and focus
just on the text data. This means that diffs generated by
textconv are <i>not</i> suitable for applying. For this
reason, only <b>git diff</b> and the <b>git log</b> family
of commands (i.e., log, whatchanged, show) will perform text
conversion. <b>git format-patch</b> will never generate this
output. If you want to send somebody a text-converted diff
of a binary file (e.g., because it quickly conveys the
changes you have made), you should generate it separately
and send it as a comment <i>in addition to</i> the usual
binary diff that you might send.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Because
text conversion can be slow, especially when doing a large
number of them with <b>git log -p</b>, Git provides a
mechanism to cache the output and use it in future diffs. To
enable caching, set the &quot;cachetextconv&quot; variable
in your diff driver&rsquo;s config. For example:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;jpg&quot;] <br>
textconv = exif <br>
cachetextconv = true</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>This will
cache the result of running &quot;exif&quot; on each blob
indefinitely. If you change the textconv config variable for
a diff driver, Git will automatically invalidate the cache
entries and re-run the textconv filter. If you want to
invalidate the cache manually (e.g., because your version of
&quot;exif&quot; was updated and now produces better
output), you can remove the cache manually with <b>git
update-ref -d refs/notes/textconv/jpg</b> (where
&quot;jpg&quot; is the name of the diff driver, as in the
example above).</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Choosing
textconv versus external diff</big></b></big></p>

<p style="margin-left:17%;"><big><big>If you want to show
differences between binary or specially-formatted blobs in
your repository, you can choose to use either an external
diff command, or to use textconv to convert them to a
diff-able text format. Which method you choose depends on
your exact situation.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
advantage of using an external diff command is flexibility.
You are not bound to find line-oriented changes, nor is it
necessary for the output to resemble unified diff. You are
free to locate and report changes in the most appropriate
way for your data format.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>A
textconv, by comparison, is much more limiting. You provide
a transformation of the data into a line-oriented text
format, and Git uses its regular diff tools to generate the
output. There are several advantages to choosing this
method:</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>1.
Ease of use. It is often much simpler to write a binary to
text transformation than it is to perform your own diff. In
many cases, existing programs can be used as textconv
filters (e.g., exif, odt2txt).</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>2.
Git diff features. By performing only the transformation
step yourself, you can still utilize many of Git&rsquo;s
diff features, including colorization, word-diff, and
combined diffs for merges.</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>3.
Caching. Textconv caching can speed up repeated diffs, such
as those you might trigger by running <b>git log
-p</b>.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Marking
files as binary</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>Git usually guesses
correctly whether a blob contains text or binary data by
examining the beginning of the contents. However, sometimes
you may want to override its decision, either because a blob
contains binary data later in the file, or because the
content, while technically composed of text characters, is
opaque to a human reader. For example, many postscript files
contain only ASCII characters, but produce noisy and
meaningless diffs.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
simplest way to mark a file as binary is to unset the diff
attribute in the <b>.gitattributes</b> file:</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>*.ps
-diff</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>This
will cause Git to generate <b>Binary files differ</b> (or a
binary patch, if binary patches are enabled) instead of a
regular diff.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>However,
one may also want to specify other diff driver attributes.
For example, you might want to use <b>textconv</b> to
convert postscript files to an ASCII representation for
human viewing, but otherwise treat them as binary files. You
cannot specify both <b>-diff</b> and <b>diff=ps</b>
attributes. The solution is to use the <b>diff.*.binary</b>
config option:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[diff
&quot;ps&quot;] <br>
textconv = ps2ascii <br>
binary = true</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Performing
a three-way merge <big><br>
merge</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The attribute
<b>merge</b> affects how three versions of a file are merged
when a file-level merge is necessary during <b>git
merge</b>, and other commands such as <b>git revert</b> and
<b>git cherry-pick</b>.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Set</big></big></p>

<p style="margin-left:23%;"><big><big>Built-in 3-way merge
driver is used to merge the contents in a way similar to
<i>merge</i> command of <b>RCS</b> suite. This is suitable
for ordinary text files.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unset</big></big></p>

<p style="margin-left:23%;"><big><big>Take the version from
the current branch as the tentative merge result, and
declare that the merge has conflicts. This is suitable for
binary files that do not have a well-defined merge
semantics.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unspecified</big></big></p>

<p style="margin-left:23%;"><big><big>By default, this uses
the same built-in 3-way merge driver as is the case when the
<b>merge</b> attribute is set. However, the
<b>merge.default</b> configuration variable can name
different merge driver to be used with paths for which the
<b>merge</b> attribute is unspecified.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>String</big></big></p>

<p style="margin-left:23%;"><big><big>3-way merge is
performed using the specified custom merge driver. The
built-in 3-way merge driver can be explicitly specified by
asking for &quot;text&quot; driver; the built-in &quot;take
the current branch&quot; driver can be requested with
&quot;binary&quot;.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Built-in
merge drivers</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>There are a few
built-in low-level merge drivers defined that can be asked
for via the <b>merge</b> attribute.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>text</big></big></p>

<p style="margin-left:23%;"><big><big>Usual 3-way file
level merge for text files. Conflicted regions are marked
with conflict markers <b>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</b>,
<b>=======</b> and <b>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</b>. The
version from your branch appears before the <b>=======</b>
marker, and the version from the merged branch appears after
the <b>=======</b> marker.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>binary</big></big></p>

<p style="margin-left:23%;"><big><big>Keep the version from
your branch in the work tree, but leave the path in the
conflicted state for the user to sort out.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>union</big></big></p>

<p style="margin-left:23%;"><big><big>Run 3-way file level
merge for text files, but take lines from both versions,
instead of leaving conflict markers. This tends to leave the
added lines in the resulting file in random order and the
user should verify the result. Do not use this if you do not
understand the implications.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Defining
a custom merge driver</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The definition of a
merge driver is done in the <b>.git/config</b> file, not in
the <b>gitattributes</b> file, so strictly speaking this
manual page is a wrong place to talk about it.
However...</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>To
define a custom merge driver <b>filfre</b>, add a section to
your <b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file) like this:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[merge
&quot;filfre&quot;] <br>
name = feel-free merge driver <br>
driver = filfre %O %A %B %L %P <br>
recursive = binary</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
<b>merge.*.name</b> variable gives the driver a
human-readable name.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
&rsquo;merge.*.driver&rsquo; variable&rsquo;s value is used
to construct a command to run to merge ancestor&rsquo;s
version (<b>%O</b>), current version (<b>%A</b>) and the
other branches&rsquo; version (<b>%B</b>). These three
tokens are replaced with the names of temporary files that
hold the contents of these versions when the command line is
built. Additionally, %L will be replaced with the conflict
marker size (see below).</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
merge driver is expected to leave the result of the merge in
the file named with <b>%A</b> by overwriting it, and exit
with zero status if it managed to merge them cleanly, or
non-zero if there were conflicts.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
<b>merge.*.recursive</b> variable specifies what other merge
driver to use when the merge driver is called for an
internal merge between common ancestors, when there are more
than one. When left unspecified, the driver itself is used
for both internal merge and the final merge.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
merge driver can learn the pathname in which the merged
result will be stored via placeholder
<b>%P</b>.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>conflict-marker-size</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>This attribute
controls the length of conflict markers left in the work
tree file during a conflicted merge. Only setting to the
value to a positive integer has any meaningful
effect.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>For
example, this line in <b>.gitattributes</b> can be used to
tell the merge machinery to leave much longer (instead of
the usual 7-character-long) conflict markers when merging
the file <b>Documentation/git-merge.txt</b> results in a
conflict.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>Documentation/git-merge.txt
conflict-marker-size=32</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Checking
whitespace errors <big><br>
whitespace</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The
<b>core.whitespace</b> configuration variable allows you to
define what <i>diff</i> and <i>apply</i> should consider
whitespace errors for all paths in the project (See
<b>git-config</b>(1)). This attribute gives you finer
control per path.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Set</big></big></p>

<p style="margin-left:23%;"><big><big>Notice all types of
potential whitespace errors known to Git. The tab width is
taken from the value of the <b>core.whitespace</b>
configuration variable.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unset</big></big></p>

<p style="margin-left:23%;"><big><big>Do not notice
anything as error.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unspecified</big></big></p>

<p style="margin-left:23%;"><big><big>Use the value of the
<b>core.whitespace</b> configuration variable to decide what
to notice as error.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>String</big></big></p>

<p style="margin-left:23%;"><big><big>Specify a comma
separate list of common whitespace problems to notice in the
same format as the <b>core.whitespace</b> configuration
variable.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Creating
an archive <big><br>
export-ignore</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>Files and directories
with the attribute <b>export-ignore</b> won&rsquo;t be added
to archive files.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>export-subst</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>If the attribute
<b>export-subst</b> is set for a file then Git will expand
several placeholders when adding this file to an archive.
The expansion depends on the availability of a commit ID,
i.e., if <b>git-archive</b>(1) has been given a tree instead
of a commit or a tag then no replacement will be done. The
placeholders are the same as those for the option
<b>--pretty=format:</b> of <b>git-log</b>(1), except that
they need to be wrapped like this:
<b>$Format:PLACEHOLDERS$</b> in the file. E.g. the string
<b>$Format:%H$</b> will be replaced by the commit hash.
However, only one <b>%(describe)</b> placeholder is expanded
per archive to avoid denial-of-service
attacks.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Packing
objects <big><br>
delta</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>Delta compression
will not be attempted for blobs for paths with the attribute
<b>delta</b> set to false.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Viewing
files in GUI tools <big><br>
encoding</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The value of this
attribute specifies the character encoding that should be
used by GUI tools (e.g. <b>gitk</b>(1) and
<b>git-gui</b>(1)) to display the contents of the relevant
file. Note that due to performance considerations
<b>gitk</b>(1) does not use this attribute unless you
manually enable per-file encodings in its
options.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>If
this attribute is not set or has an invalid value, the value
of the <b>gui.encoding</b> configuration variable is used
instead (See <b>git-config</b>(1)).</big></big></p>

<h2>USING MACRO ATTRIBUTES
<a name="USING MACRO ATTRIBUTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>You
do not want any end-of-line conversions applied to, nor
textual diffs produced for, any binary file you track. You
would need to specify e.g.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>*.jpg
-text -diff</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>but
that may become cumbersome, when you have many attributes.
Using macro attributes, you can define an attribute that,
when set, also sets or unsets a number of other attributes
at the same time. The system knows a built-in macro
attribute, <b>binary</b>:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>*.jpg
binary</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Setting
the &quot;binary&quot; attribute also unsets the
&quot;text&quot; and &quot;diff&quot; attributes as above.
Note that macro attributes can only be &quot;Set&quot;,
though setting one might have the effect of setting or
unsetting other attributes or even returning other
attributes to the &quot;Unspecified&quot;
state.</big></big></p>

<h2>DEFINING MACRO ATTRIBUTES
<a name="DEFINING MACRO ATTRIBUTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big>Custom
macro attributes can be defined only in top-level
gitattributes files (<b>$GIT_DIR/info/attributes</b>, the
<b>.gitattributes</b> file at the top level of the working
tree, or the global or system-wide gitattributes files), not
in <b>.gitattributes</b> files in working tree
subdirectories. The built-in macro attribute
&quot;binary&quot; is equivalent to:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>[attr]binary
-diff -merge -text</big></big></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>Git
does not follow symbolic links when accessing a
<b>.gitattributes</b> file in the working tree. This keeps
behavior consistent when the file is accessed from the index
or a tree versus from the filesystem.</big></big></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>If
you have these three <b>gitattributes</b>
file:</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>(in
$GIT_DIR/info/attributes)</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>a*
foo !bar -baz</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>(in
.gitattributes) <br>
abc foo bar baz</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>(in
t/.gitattributes) <br>
ab* merge=filfre <br>
abc -foo -bar <br>
*.c frotz</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>the
attributes given to path <b>t/abc</b> are computed as
follows:</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>1. By
examining <b>t/.gitattributes</b> (which is in the same
directory as the path in question), Git finds that the first
line matches. <b>merge</b> attribute is set. It also finds
that the second line matches, and attributes <b>foo</b> and
<b>bar</b> are unset.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>2.
Then it examines <b>.gitattributes</b> (which is in the
parent directory), and finds that the first line matches,
but <b>t/.gitattributes</b> file already decided how
<b>merge</b>, <b>foo</b> and <b>bar</b> attributes should be
given to this path, so it leaves <b>foo</b> and <b>bar</b>
unset. Attribute <b>baz</b> is set.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>3.
Finally it examines <b>$GIT_DIR/info/attributes</b>. This
file is used to override the in-tree settings. The first
line is a match, and <b>foo</b> is set, <b>bar</b> is
reverted to unspecified state, and <b>baz</b> is
unset.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>As
the result, the attributes assignment to <b>t/abc</b>
becomes:</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>foo
set to true <br>
bar unspecified <br>
baz set to false <br>
merge set to string value &quot;filfre&quot; <br>
frotz unspecified</big></big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><b>git-check-attr</b>(1).</big></big></p>

<h2>GIT
<a name="GIT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>Part
of the <b>git</b>(1) suite</big></big></p>
<hr>
</body>
</html>
