<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:28 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ORG.FREEDESKTOP.RESOLVE1</title>

</head>
<body>

<h1 align="center">ORG.FREEDESKTOP.RESOLVE1</h1>

<a href="#NAME">NAME</a><br>
<a href="#INTRODUCTION">INTRODUCTION</a><br>
<a href="#THE MANAGER OBJECT">THE MANAGER OBJECT</a><br>
<a href="#LINK OBJECT">LINK OBJECT</a><br>
<a href="#COMMON ERRORS">COMMON ERRORS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#VERSIONING">VERSIONING</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">org.freedesktop.resolve1
- The D-Bus interface of systemd-resolved</p>

<h2>INTRODUCTION
<a name="INTRODUCTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>systemd-resolved.service</b>(8)
is a system service that provides hostname resolution and
caching using DNS, LLMNR, and mDNS. It also does DNSSEC
validation. This page describes the resolve semantics and
the D-Bus interface.</p>

<p style="margin-left:11%; margin-top: 1em">This page
contains an API reference only. If you are looking for a
longer explanation how to use this API, please consult
<b><font color="#0000FF">Writing Network Configuration
Managers</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">and</font>
<b><font color="#0000FF">Writing Resolver Clients</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">.</font></p>

<h2>THE MANAGER OBJECT
<a name="THE MANAGER OBJECT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
service exposes the following interfaces on the Manager
object on the bus:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">node
/org/freedesktop/resolve1 { <br>
interface org.freedesktop.resolve1.Manager { <br>
methods: <br>
ResolveHostname(in i ifindex, <br>
in s name, <br>
in i family, <br>
in t flags, <br>
out a(iiay) addresses, <br>
out s canonical, <br>
out t flags); <br>
ResolveAddress(in i ifindex, <br>
in i family, <br>
in ay address, <br>
in t flags, <br>
out a(is) names, <br>
out t flags); <br>
ResolveRecord(in i ifindex, <br>
in s name, <br>
in q class, <br>
in q type, <br>
in t flags, <br>
out a(iqqay) records, <br>
out t flags); <br>
ResolveService(in i ifindex, <br>
in s name, <br>
in s type, <br>
in s domain, <br>
in i family, <br>
in t flags, <br>
out a(qqqsa(iiay)s) srv_data, <br>
out aay txt_data, <br>
out s canonical_name, <br>
out s canonical_type, <br>
out s canonical_domain, <br>
out t flags); <br>
GetLink(in i ifindex, <br>
out o path); <br>
SetLinkDNS(in i ifindex, <br>
in a(iay) addresses); <br>
SetLinkDNSEx(in i ifindex, <br>
in a(iayqs) addresses); <br>
SetLinkDomains(in i ifindex, <br>
in a(sb) domains); <br>
SetLinkDefaultRoute(in i ifindex, <br>
in b enable); <br>
SetLinkLLMNR(in i ifindex, <br>
in s mode); <br>
SetLinkMulticastDNS(in i ifindex, <br>
in s mode); <br>
SetLinkDNSOverTLS(in i ifindex, <br>
in s mode); <br>
SetLinkDNSSEC(in i ifindex, <br>
in s mode); <br>
SetLinkDNSSECNegativeTrustAnchors(in i ifindex, <br>
in as names); <br>
RevertLink(in i ifindex); <br>
RegisterService(in s name, <br>
in s name_template, <br>
in s type, <br>
in q service_port, <br>
in q service_priority, <br>
in q service_weight, <br>
in aa{say} txt_datas, <br>
out o service_path); <br>
UnregisterService(in o service_path); <br>
ResetStatistics(); <br>
FlushCaches(); <br>
ResetServerFeatures(); <br>
properties: <br>
readonly s LLMNRHostname = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s LLMNR = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s MulticastDNS = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s DNSOverTLS = '...'; <br>
readonly a(iiay) DNS = [...]; <br>
readonly a(iiayqs) DNSEx = [...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
<br>
readonly a(iiay) FallbackDNS = [...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
<br>
readonly a(iiayqs) FallbackDNSEx = [...]; <br>
readonly (iiay) CurrentDNSServer = ...; <br>
readonly (iiayqs) CurrentDNSServerEx = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly a(isb) Domains = [...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly (tt) TransactionStatistics = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly (ttt) CacheStatistics = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s DNSSEC = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly (tttt) DNSSECStatistics = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly b DNSSECSupported = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly as DNSSECNegativeTrustAnchors = ['...', ...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s DNSStubListener = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s ResolvConfMode = '...'; <br>
}; <br>
interface org.freedesktop.DBus.Peer { ... }; <br>
interface org.freedesktop.DBus.Introspectable { ... }; <br>
interface org.freedesktop.DBus.Properties { ... }; <br>
};</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Methods
<br>
ResolveHostname()</b> takes a hostname and resolves it to
one or more IP addresses. As parameters it takes the Linux
network interface index to execute the query on, or 0 if it
may be done on any suitable interface. The <i>name</i>
parameter specifies the hostname to resolve. Note that if
required, IDNA conversion is applied to this name unless it
is resolved via LLMNR or MulticastDNS. The <i>family</i>
parameter limits the results to a specific address family.
It may be <b>AF_INET</b>, <b>AF_INET6</b> or
<b>AF_UNSPEC</b>. If <b>AF_UNSPEC</b> is specified
(recommended), both kinds are retrieved, subject to local
network configuration (i.e. if no local, routable IPv6
address is found, no IPv6 address is retrieved; and
similarly for IPv4). A 64-bit <i>flags</i> field may be used
to alter the behaviour of the resolver operation (see
below). The method returns an array of address records. Each
address record consists of the interface index the address
belongs to, an address family as well as a byte array with
the actual IP address data (which either has 4 or 16
elements, depending on the address family). The returned
address family will be one of <b>AF_INET</b> or
<b>AF_INET6</b>. For IPv6, the returned address interface
index should be used to initialize the .sin6_scope_id field
of a struct&nbsp;sockaddr_in6 instance to permit support for
resolution to link-local IP addresses. The address array is
followed by the canonical name of the host, which may or may
not be identical to the resolved hostname. Finally, a 64-bit
<i>flags</i> field is returned that is defined similarly to
the <i>flags</i> field that was passed in, but contains
information about the resolved data (see below). If the
hostname passed in is an IPv4 or IPv6 address formatted as
string, it is parsed, and the result is returned. In this
case, no network communication is done.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>ResolveAddress()</b>
executes the reverse operation: it takes an IP address and
acquires one or more hostnames for it. As parameters it
takes the interface index to execute the query on, or
<b>0</b> if all suitable interfaces are OK. The
<i>family</i> parameter indicates the address family of the
IP address to resolve. It may be either <b>AF_INET</b> or
<b>AF_INET6</b>. The <i>address</i> parameter takes the raw
IP address data (as either a 4 or 16 byte array). The
<i>flags</i> input parameter may be used to alter the
resolver operation (see below). The method returns an array
of name records, each consisting of an interface index and a
hostname. The <i>flags</i> output field contains additional
information about the resolver operation (see
below).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>ResolveRecord()</b>
takes a DNS resource record (RR) type, class and name, and
retrieves the full resource record set (RRset), including
the RDATA, for it. As parameter it takes the Linux network
interface index to execute the query on, or <b>0</b> if it
may be done on any suitable interface. The <i>name</i>
parameter specifies the RR domain name to look up (no IDNA
conversion is applied), followed by the 16-bit class and
type fields (which may be ANY). Finally, a <i>flags</i>
field may be passed in to alter behaviour of the look-up
(see below). On completion, an array of RR items is
returned. Each array entry consists of the network interface
index the RR was discovered on, the type and class field of
the RR found, and a byte array of the raw RR discovered. The
raw RR data starts with the RR's domain name, in the
original casing, followed by the RR type, class, TTL and
RDATA, in the binary format documented in</font>
<b><font color="#0000FF">RFC&nbsp;1035</font></b>
<small><font color="#000000">[3]</font></small>
<font color="#000000">. For RRs that support name
compression in the payload (such as MX or PTR), the
compression is expanded in the returned data.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that currently, the class field has to be specified as IN or
ANY. Specifying a different class will return an error
indicating that look-ups of this kind are unsupported.
Similarly, some special types are not supported either
(AXFR, OPT, ...). While systemd-resolved parses and
validates resource records of many types, it is crucial that
clients using this API understand that the RR data
originates from the network and should be thoroughly
validated before use.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>ResolveService()</b>
may be used to resolve a DNS <b>SRV</b> service record, as
well as the hostnames referenced in it, and possibly an
accompanying DNS-SD <b>TXT</b> record containing additional
service metadata. The primary benefit of using this method
over <b>ResolveRecord()</b> specifying the <b>SRV</b> type
is that it will resolve the <b>SRV</b> and <b>TXT</b> RRs as
well as the hostnames referenced in the SRV in a single
operation. As parameters it takes a Linux network interface
index, a service name, a service type and a service domain.
This method may be invoked in three different
modes:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">1.
To resolve a DNS-SD service, specify the service name (e.g.
&quot;Lennart's Files&quot;), the service type (e.g.
&quot;_webdav._tcp&quot;) and the domain to search in (e.g.
&quot;local&quot;) as the three service parameters. The
service name must be in UTF-8 format, and no IDNA conversion
is applied to it in this mode (as mandated by the DNS-SD
specifications). However, if necessary, IDNA conversion is
applied to the domain parameter.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">2.
To resolve a plain <b>SRV</b> record, set the service name
parameter to the empty string and set the service type and
domain properly. (IDNA conversion is applied to the domain,
if necessary.)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">3.
Alternatively, leave both the service name and type empty
and specify the full domain name of the <b>SRV</b> record
(i.e. prefixed with the service type) in the domain
parameter. (No IDNA conversion is applied in this
mode.)</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>family</i> parameter of the <b>ResolveService()</b>
method encodes the desired family of the addresses to
resolve (use <b>AF_INET</b>, <b>AF_INET6</b>, or
<b>AF_UNSPEC</b>). If this is enabled (Use the
<b>NO_ADDRESS</b> flag to turn address resolution off, see
below). The <i>flags</i> parameter takes a couple of flags
that may be used to alter the resolver operation.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">On
completion, <b>ResolveService()</b> returns an array of
<b>SRV</b> record structures. Each items consisting of the
priority, weight and port fields as well as the hostname to
contact, as encoded in the <b>SRV</b> record. Immediately
following is an array of the addresses of this hostname,
with each item consisting of the interface index, the
address family and the address data in a byte array. This
address array is followed by the canonicalized hostname.
After this array of <b>SRV</b> record structures an array of
byte arrays follows that encodes the TXT RR strings, in case
DNS-SD look-ups are enabled. The next parameters are the
canonical service name, type and domain. This may or may not
be identical to the parameters passed in. Finally, a
<i>flags</i> field is returned that contains information
about the resolver operation performed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>ResetStatistics()</b> method resets the various
statistics counters that systemd-resolved maintains to zero.
(For details, see the statistics properties
below.)</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>GetLink()</b> method takes a network interface index and
returns the object path to the org.freedesktop.resolve1.Link
object corresponding to it.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>SetLinkDNS()</b> method sets the DNS servers to use on a
specific interface. This method (and the following ones) may
be used by network management software to configure
per-interface DNS settings. It takes a network interface
index as well as an array of DNS server IP address records.
Each array item consists of an address family (either
<b>AF_INET</b> or <b>AF_INET6</b>), followed by a 4-byte or
16-byte array with the raw address data. This method is a
one-step shortcut for retrieving the Link object for a
network interface using <b>GetLink()</b> (see above) and
then invoking the <b>SetDNS()</b> method (see below) on
it.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SetLinkDNSEx()</b>
is similar to <b>SetLinkDNS()</b>, but allows an IP port
(instead of the default 53) and DNS name to be specified for
each DNS server. The server name is used for Server Name
Indication (SNI), which is useful when DNS-over-TLS is used.
C.f. <i>DNS=</i> in <b>resolved.conf</b>(5).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SetLinkDefaultRoute()</b>
specifies whether the link shall be used as the default
route for name queries. See the description of name routing
in <b>systemd-resolved.service</b>(8) for
details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>SetLinkDomains()</b> method sets the search and routing
domains to use on a specific network interface for DNS
look-ups. It takes a network interface index and an array of
domains, each with a boolean parameter indicating whether
the specified domain shall be used as a search domain
(false), or just as a routing domain (true). Search domains
are used for qualifying single-label names into FQDN when
looking up hostnames, as well as for making routing
decisions on which interface to send queries ending in the
domain to. Routing domains are only used for routing
decisions and not used for single-label name qualification.
Pass the search domains in the order they should be
used.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>SetLinkLLMNR()</b> method enables or disables LLMNR
support on a specific network interface. It takes a network
interface index as well as a string that may either be empty
or one of &quot;yes&quot;, &quot;no&quot; or
&quot;resolve&quot;. If empty, the systemd-wide default
LLMNR setting is used. If &quot;yes&quot;, LLMNR is used for
resolution of single-label names and the local hostname is
registered on all local LANs for LLMNR resolution by peers.
If &quot;no&quot;, LLMNR is turned off fully on this
interface. If &quot;resolve&quot;, LLMNR is only enabled for
resolving names, but the local hostname is not registered
for other peers to use.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Similarly,
the <b>SetLinkMulticastDNS()</b> method enables or disables
MulticastDNS support on a specific interface. It takes the
same parameters as <b>SetLinkLLMNR()</b> described
above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>SetLinkDNSSEC()</b> method enables or disables DNSSEC
validation on a specific network interface. It takes a
network interface index as well as a string that may either
be empty or one of &quot;yes&quot;, &quot;no&quot;, or
&quot;allow-downgrade&quot;. When empty, the system-wide
default DNSSEC setting is used. If &quot;yes&quot;, full
DNSSEC validation is done for all look-ups. If the selected
DNS server does not support DNSSEC, look-ups will fail if
this mode is used. If &quot;no&quot;, DNSSEC validation is
fully disabled. If &quot;allow-downgrade&quot;, DNSSEC
validation is enabled, but is turned off automatically if
the selected server does not support it (thus opening up
behaviour to downgrade attacks). Note that DNSSEC only
applies to traditional DNS, not to LLMNR or
MulticastDNS.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>SetLinkDNSSECNegativeTrustAnchors()</b> method may be
used to configure DNSSEC Negative Trust Anchors (NTAs) for a
specific network interface. It takes a network interface
index and a list of domains as arguments.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>SetLinkDNSOverTLS()</b> method enables or disables
DNS-over-TLS. C.f. <i>DNSOverTLS=</i> in
<b>systemd-resolved.service</b>(8) for details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Network
management software integrating with systemd-resolved should
call <b>SetLinkDNS()</b> or <b>SetLinkDNSEx()</b>,
<b>SetLinkDefaultRoute()</b>, <b>SetLinkDomains()</b> and
others after the interface appeared in the kernel (and thus
after a network interface index has been assigned), but
before the network interfaces is activated (<b>IFF_UP</b>
set) so that all settings take effect during the full time
the network interface is up. It is safe to alter settings
while the interface is up, however. Use <b>RevertLink()</b>
(described below) to reset all per-interface
settings.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>RevertLink()</b> method may be used to revert all
per-link settings described above to the
defaults.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b><big>The
Flags Parameter</big></b></font></p>

<p style="margin-left:17%;"><font color="#000000">The four
methods above accept and return a 64-bit flags value. In
most cases passing 0 is sufficient and recommended. However,
the following flags are defined to alter the
look-up:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">#define
SD_RESOLVED_DNS (UINT64_C(1) &lt;&lt; 0) <br>
#define SD_RESOLVED_LLMNR_IPV4 (UINT64_C(1) &lt;&lt; 1) <br>
#define SD_RESOLVED_LLMNR_IPV6 (UINT64_C(1) &lt;&lt; 2) <br>
#define SD_RESOLVED_MDNS_IPV4 (UINT64_C(1) &lt;&lt; 3) <br>
#define SD_RESOLVED_MDNS_IPV6 (UINT64_C(1) &lt;&lt; 4) <br>
#define SD_RESOLVED_NO_CNAME (UINT64_C(1) &lt;&lt; 5) <br>
#define SD_RESOLVED_NO_TXT (UINT64_C(1) &lt;&lt; 6) <br>
#define SD_RESOLVED_NO_ADDRESS (UINT64_C(1) &lt;&lt; 7) <br>
#define SD_RESOLVED_NO_SEARCH (UINT64_C(1) &lt;&lt; 8) <br>
#define SD_RESOLVED_AUTHENTICATED (UINT64_C(1) &lt;&lt; 9)
<br>
#define SD_RESOLVED_NO_VALIDATE (UINT64_C(1) &lt;&lt; 10)
<br>
#define SD_RESOLVED_NO_SYNTHESIZE (UINT64_C(1) &lt;&lt; 11)
<br>
#define SD_RESOLVED_NO_CACHE (UINT64_C(1) &lt;&lt; 12) <br>
#define SD_RESOLVED_NO_ZONE (UINT64_C(1) &lt;&lt; 13) <br>
#define SD_RESOLVED_NO_TRUST_ANCHOR (UINT64_C(1) &lt;&lt;
14) <br>
#define SD_RESOLVED_NO_NETWORK (UINT64_C(1) &lt;&lt; 15)
<br>
#define SD_RESOLVED_REQUIRE_PRIMARY (UINT64_C(1) &lt;&lt;
16) <br>
#define SD_RESOLVED_CLAMP_TTL (UINT64_C(1) &lt;&lt; 17) <br>
#define SD_RESOLVED_CONFIDENTIAL (UINT64_C(1) &lt;&lt; 18)
<br>
#define SD_RESOLVED_SYNTHETIC (UINT64_C(1) &lt;&lt; 19) <br>
#define SD_RESOLVED_FROM_CACHE (UINT64_C(1) &lt;&lt; 20)
<br>
#define SD_RESOLVED_FROM_ZONE (UINT64_C(1) &lt;&lt; 21) <br>
#define SD_RESOLVED_FROM_TRUST_ANCHOR (UINT64_C(1) &lt;&lt;
22) <br>
#define SD_RESOLVED_FROM_NETWORK (UINT64_C(1) &lt;&lt;
23)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">On
input, the first five flags control the protocols to use for
the look-up. They refer to classic unicast DNS, LLMNR via
IPv4/UDP and IPv6/UDP respectively, as well as MulticastDNS
via IPv4/UDP and IPv6/UDP. If all of these five bits are off
on input (which is strongly recommended) the look-up will be
done via all suitable protocols for the specific look-up.
Note that these flags operate as filter only, but cannot
force a look-up to be done via a protocol. Specifically,
systemd-resolved will only route look-ups within the .local
TLD to MulticastDNS (plus some reverse look-up address
domains), and single-label names to LLMNR (plus some reverse
address lookup domains). It will route neither of these to
Unicast DNS servers. Also, it will do LLMNR and Multicast
DNS only on interfaces suitable for multicast.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">On
output, these five flags indicate which protocol was used to
execute the operation, and hence where the data was
found.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
primary use cases for these five flags are follow-up
look-ups based on DNS data retrieved earlier. In this case
it is often a good idea to limit the follow-up look-up to
the protocol that was used to discover the first DNS
result.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
NO_CNAME flag controls whether CNAME/DNAME resource records
shall be followed during the look-up. This flag is only
available at input, none of the functions will return it on
output. If a CNAME/DNAME RR is discovered while resolving a
hostname, an error is returned instead. By default, when the
flag is off, CNAME/DNAME RRs are followed.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
NO_TXT and NO_ADDRESS flags only influence operation of the
<b>ResolveService()</b> method. They are only defined for
input, not output. If NO_TXT is set, the DNS-SD TXT RR
look-up is not done in the same operation. If NO_ADDRESS is
set, the discovered hostnames are not implicitly translated
to their addresses.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
NO_SEARCH flag turns off the search domain logic. It is only
defined for input in <b>ResolveHostname()</b>. When
specified, single-label hostnames are not qualified using
defined search domains, if any are configured. Note that
<b>ResolveRecord()</b> will never qualify single-label
domain names using search domains. Also note that
multi-label hostnames are never subject to search list
expansion.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
AUTHENTICATED bit is defined only in the output flags of the
four functions. If set, the returned data has been fully
authenticated. Specifically, this bit is set for all
DNSSEC-protected data for which a full trust chain may be
established to a trusted domain anchor. It is also set for
locally synthesized data, such as &quot;localhost&quot; or
data from /etc/hosts. Moreover, it is set for all LLMNR or
mDNS RRs which originate from the local host. Applications
that require authenticated RR data for operation should
check this flag before trusting the data. Note that
systemd-resolved will never return invalidated data, hence
this flag simply allows to discern the cases where data is
known to be trusted, or where there is proof that the data
is &quot;rightfully&quot; unauthenticated (which includes
cases where the underlying protocol or server does not
support authenticating data).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">NO_VALIDATE
can be set to disable validation via DNSSEC even if it would
normally be used.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
next four flags allow disabling certain sources during
resolution. NO_SYNTHESIZE disables synthetic records, e.g.
the local host name, see section SYNTHETIC RECORDS in
<b>systemd-resolved.service</b>(8) for more information.
NO_CACHE disables the use of the cache of previously
resolved records. NO_ZONE disables answers using locally
registered public LLMNR/mDNS resource records.
NO_TRUST_ANCHOR disables answers using locally configured
trust anchors. NO_NETWORK requires all answers to be
provided without using the network, i.e. either from local
sources or the cache.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">With
REQUIRE_PRIMARY the request must be answered from a
&quot;primary&quot; answer, i.e. not from resource records
acquired as a side-effect of a previous
transaction.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">With
CLAMP_TTL, if reply is answered from cache, the TTLs will be
adjusted by age of cache entry.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
next six bits flags are used in output and provide
information about the source of the answer. CONFIDENTIAL
means the query was resolved via encrypted channels or never
left this system. FROM_SYNTHETIC means the query was (at
least partially) synthesized. FROM_CACHE means the query was
answered (at least partially) using the cache. FROM_ZONE
means the query was answered (at least partially) using
LLMNR/mDNS. FROM_TRUST_ANCHOR means the query was answered
(at least partially) using local trust anchors. FROM_NETWORK
means the query was answered (at least partially) using the
network.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Properties</b>
<br>
The <i>LLMNR</i> and <i>MulticastDNS</i> properties report
whether LLMNR and MulticastDNS are (globally) enabled. Each
may be one of &quot;yes&quot;, &quot;no&quot;, and
&quot;resolve&quot;. See <b>SetLinkLLMNR()</b> and
<b>SetLinkMulticastDNS()</b> above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>LLMNRHostname</i>
contains the hostname currently exposed on the network via
LLMNR. It usually follows the system hostname as may be
queried via <a href="https://man.page/3/gethostname">gethostname(3)</a>, but may differ if a
conflict is detected on the network.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>DNS</i>
and <i>DNSEx</i> contain arrays of all DNS servers currently
used by systemd-resolved. <i>DNS</i> contains information
similar to the DNS server data in
/run/systemd/resolve/resolv.conf. Each structure in the
array consists of a numeric network interface index, an
address family, and a byte array containing the DNS server
address (either 4 bytes in length for IPv4 or 16 bytes in
lengths for IPv6). <i>DNSEx</i> is similar, but additionally
contains the IP port and server name (used for Server Name
Indication, SNI). Both arrays contain DNS servers configured
system-wide, including those possibly read from a foreign
/etc/resolv.conf or the <i>DNS=</i> setting in
/etc/systemd/resolved.conf, as well as per-interface DNS
server information either retrieved from
<b>systemd-networkd</b>(8), or configured by external
software via <b>SetLinkDNS()</b> or <b>SetLinkDNSEx()</b>
(see above). The network interface index will be 0 for the
system-wide configured services and non-zero for the
per-link servers.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>FallbackDNS</i>
and <i>FallbackDNSEx</i> contain arrays of all DNS servers
configured as fallback servers, if any, using the same
format as <i>DNS</i> and <i>DNSEx</i> described above. See
the description of <i>FallbackDNS=</i> in
<b>resolved.conf</b>(5) for the description of when those
servers are used.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>CurrentDNSServer</i>
and <i>CurrentDNSServerEx</i> specify the server that is
currently used for query resolution, in the same format as a
single entry in the <i>DNS</i> and <i>DNSEx</i> arrays
described above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Similarly,
the <i>Domains</i> property contains an array of all search
and routing domains currently used by systemd-resolved. Each
entry consists of a network interface index (again, 0
encodes system-wide entries), the actual domain name, and
whether the entry is used only for routing (true) or for
both routing and searching (false).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>TransactionStatistics</i> property contains information
about the number of transactions systemd-resolved has
processed. It contains a pair of unsigned 64-bit counters,
the first containing the number of currently ongoing
transactions, the second the number of total transactions
systemd-resolved is processing or has processed. The latter
value may be reset using the <b>ResetStatistics()</b> method
described above. Note that the number of transactions does
not directly map to the number of issued resolver bus method
calls. While simple look-ups usually require a single
transaction only, more complex look-ups might result in
more, for example when CNAMEs or DNSSEC are in
use.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>CacheStatistics</i> property contains information about
the executed cache operations so far. It exposes three
64-bit counters: the first being the total number of current
cache entries (both positive and negative), the second the
number of cache hits, and the third the number of cache
misses. The latter counters may be reset using
<b>ResetStatistics()</b> (see above).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>DNSSEC</i> property specifies current status of DNSSEC
validation. It is one of &quot;yes&quot; (validation is
enforced), &quot;no&quot; (no validation is done),
&quot;allow-downgrade&quot; (validation is done if the
current DNS server supports it). See the description of
<i>DNSSEC=</i> in <b>resolved.conf</b>(5).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>DNSSECStatistics</i> property contains information about
the DNSSEC validations executed so far. It contains four
64-bit counters: the number of secure, insecure, bogus, and
indeterminate DNSSEC validations so far. The counters are
increased for each validated RRset, and each non-existance
proof. The secure counter is increased for each operation
that successfully verified a signed reply, the insecure
counter is increased for each operation that successfully
verified that an unsigned reply is rightfully unsigned. The
bogus counter is increased for each operation where the
validation did not check out and the data is likely to have
been tempered with. Finally the indeterminate counter is
increased for each operation which did not complete because
the necessary keys could not be acquired or the
cryptographic algorithms were unknown.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>DNSSECSupported</i> boolean property reports whether
DNSSEC is enabled and the selected DNS servers support it.
It combines information about system-wide and per-link DNS
settings (see below), and only reports true if DNSSEC is
enabled and supported on every interface for which DNS is
configured and for the system-wide settings if there are
any. Note that systemd-resolved assumes DNSSEC is supported
by DNS servers until it verifies that this is not the case.
Thus, the reported value may initially be true, until the
first transactions are executed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>DNSOverTLS</i> boolean property reports whether
DNS-over-TLS is enabled.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>ResolvConfMode</i> property exposes how /etc/resolv.conf
is managed on the host. Currently, the values
&quot;uplink&quot;, &quot;stub&quot;, &quot;static&quot;
(these three correspond to the three different files
systemd-resolved.service provides), &quot;foreign&quot; (the
file is managed by admin or another service,
systemd-resolved.service just consumes it),
&quot;missing&quot; (/etc/resolv.conf is
missing).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>DNSStubListener</i> property reports whether the stub
listener on port 53 is enabled. Possible values are
&quot;yes&quot; (enabled), &quot;no&quot; (disabled),
&quot;udp&quot; (only the UDP listener is enabled), and
&quot;tcp&quot; (only the TCP listener is
enabled).</font></p>

<h2>LINK OBJECT
<a name="LINK OBJECT"></a>
</h2>



<p style="margin-left:17%; margin-top: 1em"><font color="#000000">node
/org/freedesktop/resolve1/link/_1 { <br>
interface org.freedesktop.resolve1.Link { <br>
methods: <br>
SetDNS(in a(iay) addresses); <br>
SetDNSEx(in a(iayqs) addresses); <br>
SetDomains(in a(sb) domains); <br>
SetDefaultRoute(in b enable); <br>
SetLLMNR(in s mode); <br>
SetMulticastDNS(in s mode); <br>
SetDNSOverTLS(in s mode); <br>
SetDNSSEC(in s mode); <br>
SetDNSSECNegativeTrustAnchors(in as names); <br>
Revert(); <br>
properties: <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly t ScopesMask = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly a(iay) DNS = [...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly a(iayqs) DNSEx = [...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly (iay) CurrentDNSServer = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly (iayqs) CurrentDNSServerEx = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly a(sb) Domains = [...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly b DefaultRoute = ...; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s LLMNR = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s MulticastDNS = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s DNSOverTLS = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly s DNSSEC = '...'; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly as DNSSECNegativeTrustAnchors = ['...', ...]; <br>

@org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
<br>
readonly b DNSSECSupported = ...; <br>
}; <br>
interface org.freedesktop.DBus.Peer { ... }; <br>
interface org.freedesktop.DBus.Introspectable { ... }; <br>
interface org.freedesktop.DBus.Properties { ... }; <br>
};</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
each Linux network interface a &quot;Link&quot; object is
created which exposes per-link DNS configuration and state.
Use <b>GetLink()</b> on the Manager interface to retrieve
the object path for a link object given the network
interface index (see above).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Methods</b>
<br>
The various methods exposed by the Link interface are
equivalent to their similarly named counterparts on the
Manager interface. e.g. <b>SetDNS()</b> on the Link object
maps to <b>SetLinkDNS()</b> on the Manager object, the main
difference being that the later expects an interface index
to be specified. Invoking the methods on the Manager
interface has the benefit of reducing roundtrips, as it is
not necessary to first request the Link object path via
<b>GetLink()</b> before invoking the methods. The same
relationship holds for <b>SetDNSEx()</b>,
<b>SetDomains()</b>, <b>SetDefaultRoute()</b>,
<b>SetLLMNR()</b>, <b>SetMulticastDNS()</b>,
<b>SetDNSOverTLS()</b>, <b>SetDNSSEC()</b>,
<b>SetDNSSECNegativeTrustAnchors()</b>, and <b>Revert()</b>.
For further details on these methods see the Manager
documentation above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Properties</b>
<i><br>
ScopesMask</i> defines which resolver scopes are currently
active on this interface. This 64-bit unsigned integer field
is a bit mask consisting of a subset of the bits of the
flags parameter describe above. Specifically, it may have
the DNS, LLMNR and MDNS bits (the latter in IPv4 and IPv6
flavours) set. Each individual bit is set when the protocol
applies to a specific interface and is enabled for it. It is
unset otherwise. Specifically, a multicast-capable interface
in the &quot;UP&quot; state with an IP address is suitable
for LLMNR or MulticastDNS, and any interface that is UP and
has an IP address is suitable for DNS. Note the relationship
of the bits exposed here with the LLMNR and MulticastDNS
properties also exposed on the Link interface. The latter
expose what is *configured* to be used on the interface, the
former expose what is actually used on the interface, taking
into account the abilities of the interface.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>DNSSECSupported</i>
exposes a boolean field that indicates whether DNSSEC is
currently configured and in use on the interface. Note that
if DNSSEC is enabled on an interface, it is assumed
available until it is detected that the configured server
does not actually support it. Thus, this property may
initially report that DNSSEC is supported on an
interface.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>DefaultRoute</i>
exposes a boolean field that indicates whether the interface
will be used as default route for name queries. See
<b>SetLinkDefaultRoute()</b> above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
other properties reflect the state of the various
configuration settings for the link which may be set with
the various methods calls such as <b>SetDNS()</b> or
<b>SetLLMNR()</b>.</font></p>

<h2>COMMON ERRORS
<a name="COMMON ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Many
bus methods systemd-resolved exposes (in particular the
resolver methods such as <b>ResolveHostname()</b> on the
Manager interface) may return some of the following
errors:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.NoNameServers</b></font></p>

<p style="margin-left:17%;"><font color="#000000">No
suitable DNS servers were found to resolve a
request.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.InvalidReply</b></font></p>

<p style="margin-left:17%;"><font color="#000000">A
response from the selected DNS server was not
understood.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.NoSuchRR</b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
requested name exists, but there is no resource record of
the requested type for it. (This is the DNS NODATA
case).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.CNameLoop</b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
look-up failed because a CNAME or DNAME loop was
detected.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.Aborted</b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
look-up was aborted because the selected protocol became
unavailable while the operation was ongoing.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.NoSuchService</b></font></p>

<p style="margin-left:17%;"><font color="#000000">A service
look-up was successful, but the <b>SRV</b> record reported
that the service is not available.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.DnssecFailed</b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
acquired response did not pass DNSSEC validation.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.NoTrustAnchor</b></font></p>

<p style="margin-left:17%;"><font color="#000000">No chain
of trust could be established for the response to a
configured DNSSEC trust anchor.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.ResourceRecordTypeUnsupported</b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
requested resource record type is not supported on the
selected DNS servers. This error is generated for example
when an RRSIG record is requested from a DNS server that
does not support DNSSEC.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.NoSuchLink</b></font></p>

<p style="margin-left:17%;"><font color="#000000">No
network interface with the specified network interface index
exists.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.LinkBusy</b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
requested configuration change could not be made because
<b>systemd-networkd</b>(8), already took possession of the
interface and supplied configuration data for it.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.NetworkDown</b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
requested look-up failed because the system is currently not
connected to any suitable network.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>org.freedesktop.resolve1.DnsError.NXDOMAIN</b>,
<b>org.freedesktop.resolve1.DnsError.REFUSED</b>,
...</font></p>

<p style="margin-left:17%;"><font color="#000000">The
look-up failed with a DNS return code reporting a failure.
The error names used as suffixes here are defined in by IANA
in</font>
<b><font color="#0000FF">DNS&nbsp;RCODEs</font></b>
<small><font color="#000000">[4]</font></small>
<font color="#000000">.</font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;1.&nbsp;Introspect
org.freedesktop.resolve1.Manager on the bus</b></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
gdbus introspect --system \ <br>
--dest org.freedesktop.resolve1 \ <br>
--object-path /org/freedesktop/resolve1</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;2.&nbsp;Introspect
org.freedesktop.resolve1.Link on the bus</b></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
gdbus introspect --system \ <br>
--dest org.freedesktop.resolve1 \ <br>
--object-path /org/freedesktop/resolve1/link/_11</font></p>

<h2>VERSIONING
<a name="VERSIONING"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">These
D-Bus interfaces follow</font> <b><font color="#0000FF">the
usual interface versioning guidelines</font></b>
<small><font color="#000000">[5]</font></small>
<font color="#000000">.</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><font color="#000000">Writing
Network Configuration Managers</font></p></td>
<td width="25%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://wiki.freedesktop.org/www/Software/systemd/writing-network-configuration-managers</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><font color="#000000">Writing
Resolver Clients</font></p></td>
<td width="46%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://wiki.freedesktop.org/www/Software/systemd/writing-resolver-clients</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">3.</font></p> </td>
<td width="2%"></td>
<td width="12%">



<p style="margin-top: 1em"><font color="#000000">RFC&nbsp;1035</font></p> </td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://www.ietf.org/rfc/rfc1035.txt</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">4.</font></p> </td>
<td width="2%"></td>
<td width="15%">



<p style="margin-top: 1em"><font color="#000000">DNS&nbsp;RCODEs</font></p> </td>
<td width="68%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">5.</font></p> </td>
<td width="2%"></td>
<td width="63%">


<p style="margin-top: 1em"><font color="#000000">the usual
interface versioning guidelines</font></p></td>
<td width="20%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://0pointer.de/blog/projects/versioning-dbus.html</font></p>
<hr>
</body>
</html>
