<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:25 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SYSTEMD.SERVICE</title>

</head>
<body>

<h1 align="center">SYSTEMD.SERVICE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SERVICE TEMPLATES">SERVICE TEMPLATES</a><br>
<a href="#AUTOMATIC DEPENDENCIES">AUTOMATIC DEPENDENCIES</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#COMMAND LINES">COMMAND LINES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">systemd.service
- Service unit configuration</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>service</i>.service</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A unit
configuration file whose name ends in &quot;.service&quot;
encodes information about a process controlled and
supervised by systemd.</p>

<p style="margin-left:11%; margin-top: 1em">This man page
lists the configuration options specific to this unit type.
See <b>systemd.unit</b>(5) for the common options of all
unit configuration files. The common configuration items are
configured in the generic [Unit] and [Install] sections. The
service specific configuration options are configured in the
[Service] section.</p>

<p style="margin-left:11%; margin-top: 1em">Additional
options are listed in <b>systemd.exec</b>(5), which define
the execution environment the commands are executed in, and
in <b>systemd.kill</b>(5), which define the way the
processes of the service are terminated, and in
<b>systemd.resource-control</b>(5), which configure resource
control settings for the processes of the service.</p>

<p style="margin-left:11%; margin-top: 1em">If a service is
requested under a certain name but no unit configuration
file is found, systemd looks for a SysV init script by the
same name (with the .service suffix removed) and dynamically
creates a service unit from that script. This is useful for
compatibility with SysV. Note that this compatibility is
quite comprehensive but not 100%. For details about the
incompatibilities, see the
<b><font color="#0000FF">Incompatibilities with
SysV</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">document.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>systemd-run</b>(1) command allows creating .service and
.scope units dynamically and transiently from the command
line.</font></p>

<h2>SERVICE TEMPLATES
<a name="SERVICE TEMPLATES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">It
is possible for <b>systemd</b> services to take a single
argument via the
&quot;<i>service</i>@<i>argument</i>.service&quot; syntax.
Such services are called &quot;instantiated&quot; services,
while the unit definition without the <i>argument</i>
parameter is called a &quot;template&quot;. An example could
be a dhcpcd@.service service template which takes a network
interface as a parameter to form an instantiated service.
Within the service file, this parameter or &quot;instance
name&quot; can be accessed with %-specifiers. See
<b>systemd.unit</b>(5) for details.</font></p>

<h2>AUTOMATIC DEPENDENCIES
<a name="AUTOMATIC DEPENDENCIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Implicit
Dependencies</b> <br>
The following dependencies are implicitly added:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Services with <i>Type=dbus</i> set automatically acquire
dependencies of type <i>Requires=</i> and <i>After=</i> on
dbus.socket.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Socket activated services are automatically ordered after
their activating .socket units via an automatic
<i>After=</i> dependency. Services also pull in all .socket
units listed in <i>Sockets=</i> via automatic <i>Wants=</i>
and <i>After=</i> dependencies.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Additional
implicit dependencies may be added as result of execution
and resource control parameters as documented in
<b>systemd.exec</b>(5) and
<b>systemd.resource-control</b>(5).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Default
Dependencies</b> <br>
The following dependencies are added unless
<i>DefaultDependencies=no</i> is set:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Service units will have dependencies of type
<i>Requires=</i> and <i>After=</i> on sysinit.target, a
dependency of type <i>After=</i> on basic.target as well as
dependencies of type <i>Conflicts=</i> and <i>Before=</i> on
shutdown.target. These ensure that normal service units pull
in basic system initialization, and are terminated cleanly
prior to system shutdown. Only services involved with early
boot or late system shutdown should disable this
option.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Instanced service units (i.e. service units with an
&quot;@&quot; in their name) are assigned by default a
per-template slice unit (see <b>systemd.slice</b>(5)), named
after the template unit, containing all instances of the
specific template. This slice is normally stopped at
shutdown, together with all template instances. If that is
not desired, set <i>DefaultDependencies=no</i> in the
template unit, and either define your own per-template slice
unit file that also sets <i>DefaultDependencies=no</i>, or
set <i>Slice=system.slice</i> (or another suitable slice) in
the template unit. Also see
<b>systemd.resource-control</b>(5).</font></p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Service
files must include a [Service] section, which carries
information about the service and the process it supervises.
A number of options that may be used in this section are
shared with other unit types. These options are documented
in <b>systemd.exec</b>(5), <b>systemd.kill</b>(5) and
<b>systemd.resource-control</b>(5). The options specific to
the [Service] section of service units are the
following:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the process start-up type for this service unit. One of
<b>simple</b>, <b>exec</b>, <b>forking</b>, <b>oneshot</b>,
<b>dbus</b>, <b>notify</b> or <b>idle</b>:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
If set to <b>simple</b> (the default if <i>ExecStart=</i> is
specified but neither <i>Type=</i> nor <i>BusName=</i> are),
the service manager will consider the unit started
immediately after the main service process has been forked
off. It is expected that the process configured with
<i>ExecStart=</i> is the main process of the service. In
this mode, if the process offers functionality to other
processes on the system, its communication channels should
be installed before the service is started up (e.g. sockets
set up by systemd, via socket activation), as the service
manager will immediately proceed starting follow-up units,
right after creating the main service process, and before
executing the service's binary. Note that this means
<b>systemctl start</b> command lines for <b>simple</b>
services will report success even if the service's binary
cannot be invoked successfully (for example because the
selected <i>User=</i> doesn't exist, or the service binary
is missing).</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
The <b>exec</b> type is similar to <b>simple</b>, but the
service manager will consider the unit started immediately
after the main service binary has been executed. The service
manager will delay starting of follow-up units until that
point. (Or in other words: <b>simple</b> proceeds with
further jobs right after <b>fork()</b> returns, while
<b>exec</b> will not proceed before both <b>fork()</b> and
<b>execve()</b> in the service process succeeded.) Note that
this means <b>systemctl start</b> command lines for
<b>exec</b> services will report failure when the service's
binary cannot be invoked successfully (for example because
the selected <i>User=</i> doesn't exist, or the service
binary is missing).</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
If set to <b>forking</b>, it is expected that the process
configured with <i>ExecStart=</i> will call <b>fork()</b> as
part of its start-up. The parent process is expected to exit
when start-up is complete and all communication channels are
set up. The child continues to run as the main service
process, and the service manager will consider the unit
started when the parent process exits. This is the behavior
of traditional UNIX services. If this setting is used, it is
recommended to also use the <i>PIDFile=</i> option, so that
systemd can reliably identify the main process of the
service. systemd will proceed with starting follow-up units
as soon as the parent process exits.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
Behavior of <b>oneshot</b> is similar to <b>simple</b>;
however, the service manager will consider the unit up after
the main process exits. It will then start follow-up units.
<i>RemainAfterExit=</i> is particularly useful for this type
of service. <i>Type=</i><b>oneshot</b> is the implied
default if neither <i>Type=</i> nor <i>ExecStart=</i> are
specified. Note that if this option is used without
<i>RemainAfterExit=</i> the service will never enter
&quot;active&quot; unit state, but directly transition from
&quot;activating&quot; to &quot;deactivating&quot; or
&quot;dead&quot; since no process is configured that shall
run continuously. In particular this means that after a
service of this type ran (and which has
<i>RemainAfterExit=</i> not set) it will not show up as
started afterwards, but as dead.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
Behavior of <b>dbus</b> is similar to <b>simple</b>;
however, it is expected that the service acquires a name on
the D-Bus bus, as configured by <i>BusName=</i>. systemd
will proceed with starting follow-up units after the D-Bus
bus name has been acquired. Service units with this option
configured implicitly gain dependencies on the dbus.socket
unit. This type is the default if <i>BusName=</i> is
specified. A service unit of this type is considered to be
in the activating state until the specified bus name is
acquired. It is considered activated while the bus name is
taken. Once the bus name is released the service is
considered being no longer functional which has the effect
that the service manager attempts to terminate any remaining
processes belonging to the service. Services that drop their
bus name as part of their shutdown logic thus should be
prepared to receive a <b>SIGTERM</b> (or whichever signal is
configured in <i>KillSignal=</i>) as result.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
Behavior of <b>notify</b> is similar to <b>exec</b>;
however, it is expected that the service sends a
notification message via <b>sd_notify</b>(3) or an
equivalent call when it has finished starting up. systemd
will proceed with starting follow-up units after this
notification message has been sent. If this option is used,
<i>NotifyAccess=</i> (see below) should be set to open
access to the notification socket provided by systemd. If
<i>NotifyAccess=</i> is missing or set to <b>none</b>, it
will be forcibly set to <b>main</b>.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
Behavior of <b>idle</b> is very similar to <b>simple</b>;
however, actual execution of the service program is delayed
until all active jobs are dispatched. This may be used to
avoid interleaving of output of shell services with the
status output on the console. Note that this type is useful
only to improve console output, it is not useful as a
general unit ordering tool, and the effect of this service
type is subject to a 5s timeout, after which the service
program is invoked anyway.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">It
is generally recommended to use <i>Type=</i><b>simple</b>
for long-running services whenever possible, as it is the
simplest and fastest option. However, as this service type
won't propagate service start-up failures and doesn't allow
ordering of other units against completion of initialization
of the service (which for example is useful if clients need
to connect to the service through some form of IPC, and the
IPC channel is only established by the service itself
&mdash; in contrast to doing this ahead of time through
socket or bus activation or similar), it might not be
sufficient for many cases. If so, <b>notify</b> or
<b>dbus</b> (the latter only in case the service provides a
D-Bus interface) are the preferred options as they allow
service program code to precisely schedule when to consider
the service started up successfully and when to proceed with
follow-up units. The <b>notify</b> service type requires
explicit support in the service codebase (as
<b>sd_notify()</b> or an equivalent API needs to be invoked
by the service at the appropriate time) &mdash; if it's not
supported, then <b>forking</b> is an alternative: it
supports the traditional UNIX service start-up protocol.
Finally, <b>exec</b> might be an option for cases where it
is enough to ensure the service binary is invoked, and where
the service binary itself executes no or little
initialization on its own (and its initialization is
unlikely to fail). Note that using any type other than
<b>simple</b> possibly delays the boot process, as the
service manager needs to wait for service initialization to
complete. It is hence recommended not to needlessly use any
types other than <b>simple</b>. (Also note it is generally
not recommended to use <b>idle</b> or <b>oneshot</b> for
long-running services.)</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RemainAfterExit=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean value that specifies whether the service shall be
considered active even when all its processes exited.
Defaults to <b>no</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>GuessMainPID=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean value that specifies whether systemd should try to
guess the main PID of a service if it cannot be determined
reliably. This option is ignored unless <b>Type=forking</b>
is set and <b>PIDFile=</b> is unset because for the other
types or with an explicitly configured PID file, the main
PID is always known. The guessing algorithm might come to
incorrect conclusions if a daemon consists of more than one
process. If the main PID cannot be determined, failure
detection and automatic restarting of a service will not
work reliably. Defaults to <b>yes</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>PIDFile=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
path referring to the PID file of the service. Usage of this
option is recommended for services where <i>Type=</i> is set
to <b>forking</b>. The path specified typically points to a
file below /run/. If a relative path is specified it is
hence prefixed with /run/. The service manager will read the
PID of the main process of the service from this file after
start-up of the service. The service manager will not write
to the file configured here, although it will remove the
file after the service has shut down if it still exists. The
PID file does not need to be owned by a privileged user, but
if it is owned by an unprivileged user additional safety
restrictions are enforced: the file may not be a symlink to
a file owned by a different user (neither directly nor
indirectly), and the PID file must refer to a process
already belonging to the service.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that PID files should be avoided in modern projects. Use
<b>Type=notify</b> or <b>Type=simple</b> where possible,
which does not require use of PID files to determine the
main process of a service and avoids needless
forking.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>BusName=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
D-Bus destination name that this service shall use. This
option is mandatory for services where <i>Type=</i> is set
to <b>dbus</b>. It is recommended to always set this
property if known to make it easy to map the service name to
the D-Bus destination. In particular, <b>systemctl
service-log-level/service-log-target</b> verbs make use of
this.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStart=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Commands
with their arguments that are executed when this service is
started. The value is split into zero or more command lines
according to the rules described below (see section
&quot;Command Lines&quot; below).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Unless
<i>Type=</i> is <b>oneshot</b>, exactly one command must be
given. When <i>Type=oneshot</i> is used, zero or more
commands may be specified. Commands may be specified by
providing multiple command lines in the same directive, or
alternatively, this directive may be specified more than
once with the same effect. If the empty string is assigned
to this option, the list of commands to start is reset,
prior assignments of this option will have no effect. If no
<i>ExecStart=</i> is specified, then the service must have
<i>RemainAfterExit=yes</i> and at least one <i>ExecStop=</i>
line set. (Services lacking both <i>ExecStart=</i> and
<i>ExecStop=</i> are not valid.)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">For
each of the specified commands, the first argument must be
either an absolute path to an executable or a simple file
name without any slashes. Optionally, this filename may be
prefixed with a number of special characters:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><b>Table&nbsp;1.&nbsp;Special
executable prefixes</b></font></p>


<p align="center"><font color="#000000"><b><img src="grohtml-3491401.png" alt="Image grohtml-3491401.png"></b></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&quot;@&quot;,
&quot;-&quot;, &quot;:&quot;, and one of
&quot;+&quot;/&quot;!&quot;/&quot;!!&quot; may be used
together and they can appear in any order. However, only one
of &quot;+&quot;, &quot;!&quot;, &quot;!!&quot; may be used
at a time. Note that these prefixes are also supported for
the other command line settings, i.e. <i>ExecStartPre=</i>,
<i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>
and <i>ExecStopPost=</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
more than one command is specified, the commands are invoked
sequentially in the order they appear in the unit file. If
one of the commands fails (and is not prefixed with
&quot;-&quot;), other lines are not executed, and the unit
is considered failed.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Unless
<i>Type=forking</i> is set, the process started via this
command line will be considered the main process of the
daemon.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStartPre=</i>,
<i>ExecStartPost=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Additional
commands that are executed before or after the command in
<i>ExecStart=</i>, respectively. Syntax is the same as for
<i>ExecStart=</i>, except that multiple command lines are
allowed and the commands are executed one after the other,
serially.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
any of those commands (not prefixed with &quot;-&quot;)
fail, the rest are not executed and the unit is considered
failed.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><i>ExecStart=</i>
commands are only run after all <i>ExecStartPre=</i>
commands that were not prefixed with a &quot;-&quot; exit
successfully.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><i>ExecStartPost=</i>
commands are only run after the commands specified in
<i>ExecStart=</i> have been invoked successfully, as
determined by <i>Type=</i> (i.e. the process has been
started for <i>Type=simple</i> or <i>Type=idle</i>, the last
<i>ExecStart=</i> process exited successfully for
<i>Type=oneshot</i>, the initial process exited successfully
for <i>Type=forking</i>, &quot;READY=1&quot; is sent for
<i>Type=notify</i>, or the <i>BusName=</i> has been taken
for <i>Type=dbus</i>).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that <i>ExecStartPre=</i> may not be used to start
long-running processes. All processes forked off by
processes invoked via <i>ExecStartPre=</i> will be killed
before the next service process is run.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that if any of the commands specified in
<i>ExecStartPre=</i>, <i>ExecStart=</i>, or
<i>ExecStartPost=</i> fail (and are not prefixed with
&quot;-&quot;, see above) or time out before the service is
fully up, execution continues with commands specified in
<i>ExecStopPost=</i>, the commands in <i>ExecStop=</i> are
skipped.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that the execution of <i>ExecStartPost=</i> is taken into
account for the purpose of <i>Before=</i>/<i>After=</i>
ordering constraints.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecCondition=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Optional
commands that are executed before the command(s) in
<i>ExecStartPre=</i>. Syntax is the same as for
<i>ExecStart=</i>, except that multiple command lines are
allowed and the commands are executed one after the other,
serially.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
behavior is like an <i>ExecStartPre=</i> and condition check
hybrid: when an <i>ExecCondition=</i> command exits with
exit code 1 through 254 (inclusive), the remaining commands
are skipped and the unit is <i>not</i> marked as failed.
However, if an <i>ExecCondition=</i> command exits with 255
or abnormally (e.g. timeout, killed by a signal, etc.), the
unit will be considered failed (and remaining commands will
be skipped). Exit code of 0 or those matching
<i>SuccessExitStatus=</i> will continue execution to the
next command(s).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
same recommendations about not running long-running
processes in <i>ExecStartPre=</i> also applies to
<i>ExecCondition=</i>. <i>ExecCondition=</i> will also run
the commands in <i>ExecStopPost=</i>, as part of stopping
the service, in the case of any non-zero or abnormal exits,
like the ones described above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecReload=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Commands
to execute to trigger a configuration reload in the service.
This argument takes multiple command lines, following the
same scheme as described for <i>ExecStart=</i> above. Use of
this setting is optional. Specifier and environment variable
substitution is supported here following the same scheme as
for <i>ExecStart=</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">One
additional, special environment variable is set: if known,
<i>$MAINPID</i> is set to the main process of the daemon,
and may be used for command lines like the
following:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">ExecReload=kill
-HUP $MAINPID</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
however that reloading a daemon by sending a signal (as with
the example line above) is usually not a good choice,
because this is an asynchronous operation and hence not
suitable to order reloads of multiple services against each
other. It is strongly recommended to set <i>ExecReload=</i>
to a command that not only triggers a configuration reload
of the daemon, but also synchronously waits for it to
complete. For example, <b>dbus-broker</b>(1) uses the
following:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">ExecReload=busctl
call org.freedesktop.DBus \ <br>
/org/freedesktop/DBus org.freedesktop.DBus \ <br>
ReloadConfig</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStop=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Commands
to execute to stop the service started via
<i>ExecStart=</i>. This argument takes multiple command
lines, following the same scheme as described for
<i>ExecStart=</i> above. Use of this setting is optional.
After the commands configured in this option are run, it is
implied that the service is stopped, and any processes
remaining for it are terminated according to the
<i>KillMode=</i> setting (see <b>systemd.kill</b>(5)). If
this option is not specified, the process is terminated by
sending the signal specified in <i>KillSignal=</i> or
<i>RestartKillSignal=</i> when service stop is requested.
Specifier and environment variable substitution is supported
(including <i>$MAINPID</i>, see above).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that it is usually not sufficient to specify a command for
this setting that only asks the service to terminate (for
example, by sending some form of termination signal to it),
but does not wait for it to do so. Since the remaining
processes of the services are killed according to
<i>KillMode=</i> and <i>KillSignal=</i> or
<i>RestartKillSignal=</i> as described above immediately
after the command exited, this may not result in a clean
stop. The specified command should hence be a synchronous
operation, not an asynchronous one.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that the commands specified in <i>ExecStop=</i> are only
executed when the service started successfully first. They
are not invoked if the service was never started at all, or
in case its start-up failed, for example because any of the
commands specified in <i>ExecStart=</i>,
<i>ExecStartPre=</i> or <i>ExecStartPost=</i> failed (and
weren't prefixed with &quot;-&quot;, see above) or timed
out. Use <i>ExecStopPost=</i> to invoke commands when a
service failed to start up correctly and is shut down again.
Also note that the stop operation is always performed if the
service started successfully, even if the processes in the
service terminated on their own or were killed. The stop
commands must be prepared to deal with that case.
<i>$MAINPID</i> will be unset if systemd knows that the main
process exited by the time the stop commands are
called.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Service
restart requests are implemented as stop operations followed
by start operations. This means that <i>ExecStop=</i> and
<i>ExecStopPost=</i> are executed during a service restart
operation.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">It
is recommended to use this setting for commands that
communicate with the service requesting clean termination.
For post-mortem clean-up steps use <i>ExecStopPost=</i>
instead.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStopPost=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Additional
commands that are executed after the service is stopped.
This includes cases where the commands configured in
<i>ExecStop=</i> were used, where the service does not have
any <i>ExecStop=</i> defined, or where the service exited
unexpectedly. This argument takes multiple command lines,
following the same scheme as described for
<i>ExecStart=</i>. Use of these settings is optional.
Specifier and environment variable substitution is
supported. Note that &ndash; unlike <i>ExecStop=</i> &ndash;
commands specified with this setting are invoked when a
service failed to start up correctly and is shut down
again.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">It
is recommended to use this setting for clean-up operations
that shall be executed even when the service failed to start
up correctly. Commands configured with this setting need to
be able to operate even if the service failed starting up
half-way and left incompletely initialized data around. As
the service's processes have been terminated already when
the commands specified with this setting are executed they
should not attempt to communicate with them.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that all commands that are configured with this setting are
invoked with the result code of the service, as well as the
main process' exit code and status, set in the
<i>$SERVICE_RESULT</i>, <i>$EXIT_CODE</i> and
<i>$EXIT_STATUS</i> environment variables, see
<b>systemd.exec</b>(5) for details.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that the execution of <i>ExecStopPost=</i> is taken into
account for the purpose of <i>Before=</i>/<i>After=</i>
ordering constraints.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RestartSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the time to sleep before restarting a service (as configured
with <i>Restart=</i>). Takes a unit-less value in seconds,
or a time span value such as &quot;5min 20s&quot;. Defaults
to 100ms.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutStartSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the time to wait for start-up. If a daemon service does not
signal start-up completion within the configured time, the
service will be considered failed and will be shut down
again. The precise action depends on the
<i>TimeoutStartFailureMode=</i> option. Takes a unit-less
value in seconds, or a time span value such as &quot;5min
20s&quot;. Pass &quot;infinity&quot; to disable the timeout
logic. Defaults to <i>DefaultTimeoutStartSec=</i> from the
manager configuration file, except when <i>Type=oneshot</i>
is used, in which case the timeout is disabled by default
(see <b>systemd-system.conf</b>(5)).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
a service of <i>Type=notify</i> sends
&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the
start time to be extended beyond <i>TimeoutStartSec=</i>.
The first receipt of this message must occur before
<i>TimeoutStartSec=</i> is exceeded, and once the start time
has extended beyond <i>TimeoutStartSec=</i>, the service
manager will allow the service to continue to start,
provided the service repeats
&quot;EXTEND_TIMEOUT_USEC=...&quot; within the interval
specified until the service startup status is finished by
&quot;READY=1&quot;. (see <b>sd_notify</b>(3)).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutStopSec=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">This
option serves two purposes. First, it configures the time to
wait for each <i>ExecStop=</i> command. If any of them times
out, subsequent <i>ExecStop=</i> commands are skipped and
the service will be terminated by <b>SIGTERM</b>. If no
<i>ExecStop=</i> commands are specified, the service gets
the <b>SIGTERM</b> immediately. This default behavior can be
changed by the <i>TimeoutStopFailureMode=</i> option.
Second, it configures the time to wait for the service
itself to stop. If it doesn't terminate in the specified
time, it will be forcibly terminated by <b>SIGKILL</b> (see
<i>KillMode=</i> in <b>systemd.kill</b>(5)). Takes a
unit-less value in seconds, or a time span value such as
&quot;5min 20s&quot;. Pass &quot;infinity&quot; to disable
the timeout logic. Defaults to <i>DefaultTimeoutStopSec=</i>
from the manager configuration file (see
<b>systemd-system.conf</b>(5)).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
a service of <i>Type=notify</i> sends
&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the stop
time to be extended beyond <i>TimeoutStopSec=</i>. The first
receipt of this message must occur before
<i>TimeoutStopSec=</i> is exceeded, and once the stop time
has extended beyond <i>TimeoutStopSec=</i>, the service
manager will allow the service to continue to stop, provided
the service repeats &quot;EXTEND_TIMEOUT_USEC=...&quot;
within the interval specified, or terminates itself (see
<b>sd_notify</b>(3)).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutAbortSec=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">This
option configures the time to wait for the service to
terminate when it was aborted due to a watchdog timeout (see
<i>WatchdogSec=</i>). If the service has a short
<i>TimeoutStopSec=</i> this option can be used to give the
system more time to write a core dump of the service. Upon
expiration the service will be forcibly terminated by
<b>SIGKILL</b> (see <i>KillMode=</i> in
<b>systemd.kill</b>(5)). The core file will be truncated in
this case. Use <i>TimeoutAbortSec=</i> to set a sensible
timeout for the core dumping per service that is large
enough to write all expected data while also being short
enough to handle the service failure in due time.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Takes
a unit-less value in seconds, or a time span value such as
&quot;5min 20s&quot;. Pass an empty value to skip the
dedicated watchdog abort timeout handling and fall back
<i>TimeoutStopSec=</i>. Pass &quot;infinity&quot; to disable
the timeout logic. Defaults to
<i>DefaultTimeoutAbortSec=</i> from the manager
configuration file (see
<b>systemd-system.conf</b>(5)).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
a service of <i>Type=notify</i> handles <b>SIGABRT</b>
itself (instead of relying on the kernel to write a core
dump) it can send &quot;EXTEND_TIMEOUT_USEC=...&quot; to
extended the abort time beyond <i>TimeoutAbortSec=</i>. The
first receipt of this message must occur before
<i>TimeoutAbortSec=</i> is exceeded, and once the abort time
has extended beyond <i>TimeoutAbortSec=</i>, the service
manager will allow the service to continue to abort,
provided the service repeats
&quot;EXTEND_TIMEOUT_USEC=...&quot; within the interval
specified, or terminates itself (see
<b>sd_notify</b>(3)).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutSec=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
shorthand for configuring both <i>TimeoutStartSec=</i> and
<i>TimeoutStopSec=</i> to the specified value.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutStartFailureMode=</i>,
<i>TimeoutStopFailureMode=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">These
options configure the action that is taken in case a daemon
service does not signal start-up within its configured
<i>TimeoutStartSec=</i>, respectively if it does not stop
within <i>TimeoutStopSec=</i>. Takes one of
<b>terminate</b>, <b>abort</b> and <b>kill</b>. Both options
default to <b>terminate</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
<b>terminate</b> is set the service will be gracefully
terminated by sending the signal specified in
<i>KillSignal=</i> (defaults to <b>SIGTERM</b>, see
<b>systemd.kill</b>(5)). If the service does not terminate
the <i>FinalKillSignal=</i> is sent after
<i>TimeoutStopSec=</i>. If <b>abort</b> is set,
<i>WatchdogSignal=</i> is sent instead and
<i>TimeoutAbortSec=</i> applies before sending
<i>FinalKillSignal=</i>. This setting may be used to analyze
services that fail to start-up or shut-down intermittently.
By using <b>kill</b> the service is immediately terminated
by sending <i>FinalKillSignal=</i> without any further
timeout. This setting can be used to expedite the shutdown
of failing services.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RuntimeMaxSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
a maximum time for the service to run. If this is used and
the service has been active for longer than the specified
time it is terminated and put into a failure state. Note
that this setting does not have any effect on
<i>Type=oneshot</i> services, as they terminate immediately
after activation completed. Pass &quot;infinity&quot; (the
default) to configure no runtime limit.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
a service of <i>Type=notify</i> sends
&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the
runtime to be extended beyond <i>RuntimeMaxSec=</i>. The
first receipt of this message must occur before
<i>RuntimeMaxSec=</i> is exceeded, and once the runtime has
extended beyond <i>RuntimeMaxSec=</i>, the service manager
will allow the service to continue to run, provided the
service repeats &quot;EXTEND_TIMEOUT_USEC=...&quot; within
the interval specified until the service shutdown is
achieved by &quot;STOPPING=1&quot; (or termination). (see
<b>sd_notify</b>(3)).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>WatchdogSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the watchdog timeout for a service. The watchdog is
activated when the start-up is completed. The service must
call <b>sd_notify</b>(3) regularly with
&quot;WATCHDOG=1&quot; (i.e. the &quot;keep-alive
ping&quot;). If the time between two such calls is larger
than the configured time, then the service is placed in a
failed state and it will be terminated with <b>SIGABRT</b>
(or the signal specified by <i>WatchdogSignal=</i>). By
setting <i>Restart=</i> to <b>on-failure</b>,
<b>on-watchdog</b>, <b>on-abnormal</b> or <b>always</b>, the
service will be automatically restarted. The time configured
here will be passed to the executed service process in the
<i>WATCHDOG_USEC=</i> environment variable. This allows
daemons to automatically enable the keep-alive pinging logic
if watchdog support is enabled for the service. If this
option is used, <i>NotifyAccess=</i> (see below) should be
set to open access to the notification socket provided by
systemd. If <i>NotifyAccess=</i> is not set, it will be
implicitly set to <b>main</b>. Defaults to 0, which disables
this feature. The service can check whether the service
manager expects watchdog keep-alive notifications. See
<b>sd_watchdog_enabled</b>(3) for details.
<b>sd_event_set_watchdog</b>(3) may be used to enable
automatic watchdog notification support.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Restart=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
whether the service shall be restarted when the service
process exits, is killed, or a timeout is reached. The
service process may be the main service process, but it may
also be one of the processes specified with
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecStop=</i>, <i>ExecStopPost=</i>, or
<i>ExecReload=</i>. When the death of the process is a
result of systemd operation (e.g. service stop or restart),
the service will not be restarted. Timeouts include missing
the watchdog &quot;keep-alive ping&quot; deadline and a
service start, reload, and stop operation
timeouts.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Takes
one of <b>no</b>, <b>on-success</b>, <b>on-failure</b>,
<b>on-abnormal</b>, <b>on-watchdog</b>, <b>on-abort</b>, or
<b>always</b>. If set to <b>no</b> (the default), the
service will not be restarted. If set to <b>on-success</b>,
it will be restarted only when the service process exits
cleanly. In this context, a clean exit means any of the
following:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
exit code of 0;</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
for types other than <i>Type=oneshot</i>, one of the signals
<b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM</b>, or
<b>SIGPIPE</b>;</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
exit statuses and signals specified in
<i>SuccessExitStatus=</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
set to <b>on-failure</b>, the service will be restarted when
the process exits with a non-zero exit code, is terminated
by a signal (including on core dump, but excluding the
aforementioned four signals), when an operation (such as
service reload) times out, and when the configured watchdog
timeout is triggered. If set to <b>on-abnormal</b>, the
service will be restarted when the process is terminated by
a signal (including on core dump, excluding the
aforementioned four signals), when an operation times out,
or when the watchdog timeout is triggered. If set to
<b>on-abort</b>, the service will be restarted only if the
service process exits due to an uncaught signal not
specified as a clean exit status. If set to
<b>on-watchdog</b>, the service will be restarted only if
the watchdog timeout for the service expires. If set to
<b>always</b>, the service will be restarted regardless of
whether it exited cleanly or not, got terminated abnormally
by a signal, or hit a timeout.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><b>Table&nbsp;2.&nbsp;Exit
causes and the effect of the</b> <i>Restart=</i> settings
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;</font></p>


<p align="center"><font color="#000000"><img src="grohtml-3491402.png" alt="Image grohtml-3491402.png"></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">As
exceptions to the setting above, the service will not be
restarted if the exit code or signal is specified in
<i>RestartPreventExitStatus=</i> (see below) or the service
is stopped with <b>systemctl stop</b> or an equivalent
operation. Also, the services will always be restarted if
the exit code or signal is specified in
<i>RestartForceExitStatus=</i> (see below).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that service restart is subject to unit start rate limiting
configured with <i>StartLimitIntervalSec=</i> and
<i>StartLimitBurst=</i>, see <b>systemd.unit</b>(5) for
details. A restarted service enters the failed state only
after the start limits are reached.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Setting
this to <b>on-failure</b> is the recommended choice for
long-running services, in order to increase reliability by
attempting automatic recovery from errors. For services that
shall be able to terminate on their own choice (and avoid
immediate restarting), <b>on-abnormal</b> is an alternative
choice.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>SuccessExitStatus=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
list of exit status definitions that, when returned by the
main service process, will be considered successful
termination, in addition to the normal successful exit
status 0 and, except for <i>Type=oneshot</i>, the signals
<b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM</b>, and
<b>SIGPIPE</b>. Exit status definitions can be numeric
termination statuses, termination status names, or
termination signal names, separated by spaces. See the
Process Exit Codes section in <b>systemd.exec</b>(5) for a
list of termination status names (for this setting only the
part without the &quot;EXIT_&quot; or &quot;EX_&quot; prefix
should be used). See <b>signal</b>(7) for a list of signal
names.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that this setting does not change the mapping between
numeric exit statuses and their names, i.e. regardless how
this setting is used 0 will still be mapped to
&quot;SUCCESS&quot; (and thus typically shown as
&quot;0/SUCCESS&quot; in tool outputs) and 1 to
&quot;FAILURE&quot; (and thus typically shown as
&quot;1/FAILURE&quot;), and so on. It only controls what
happens as effect of these exit statuses, and how it
propagates to the state of the service as a
whole.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option may appear more than once, in which case the list of
successful exit statuses is merged. If the empty string is
assigned to this option, the list is reset, all prior
assignments of this option will have no effect.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;1.&nbsp;A
service with the</b> <i>SuccessExitStatus=</i>
setting</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">SuccessExitStatus=TEMPFAIL
250 SIGKILL</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Exit
status 75 (<b>TEMPFAIL</b>), 250, and the termination signal
<b>SIGKILL</b> are considered clean service
terminations.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note:
<b>systemd-analyze exit-status</b> may be used to list exit
statuses and translate between numerical status values and
names.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RestartPreventExitStatus=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
list of exit status definitions that, when returned by the
main service process, will prevent automatic service
restarts, regardless of the restart setting configured with
<i>Restart=</i>. Exit status definitions can either be
numeric exit codes or termination signal names, and are
separated by spaces. Defaults to the empty list, so that, by
default, no exit status is excluded from the configured
restart logic. For example:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">RestartPreventExitStatus=1
6 SIGABRT</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ensures
that exit codes 1 and 6 and the termination signal
<b>SIGABRT</b> will not result in automatic service
restarting. This option may appear more than once, in which
case the list of restart-preventing statuses is merged. If
the empty string is assigned to this option, the list is
reset and all prior assignments of this option will have no
effect.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that this setting has no effect on processes configured via
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecStop=</i>, <i>ExecStopPost=</i> or
<i>ExecReload=</i>, but only on the main service process,
i.e. either the one invoked by <i>ExecStart=</i> or
(depending on <i>Type=</i>, <i>PIDFile=</i>, ...) the
otherwise configured main process.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RestartForceExitStatus=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
list of exit status definitions that, when returned by the
main service process, will force automatic service restarts,
regardless of the restart setting configured with
<i>Restart=</i>. The argument format is similar to
<i>RestartPreventExitStatus=</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RootDirectoryStartOnly=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If true, the root directory, as configured
with the <i>RootDirectory=</i> option (see
<b>systemd.exec</b>(5) for more information), is only
applied to the process started with <i>ExecStart=</i>, and
not to the various other <i>ExecStartPre=</i>,
<i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>,
and <i>ExecStopPost=</i> commands. If false, the setting is
applied to all configured commands the same way. Defaults to
false.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>NonBlocking=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Set the
<b>O_NONBLOCK</b> flag for all file descriptors passed via
socket-based activation. If true, all file descriptors &gt;=
3 (i.e. all except stdin, stdout, stderr), excluding those
passed in via the file descriptor storage logic (see
<i>FileDescriptorStoreMax=</i> for details), will have the
<b>O_NONBLOCK</b> flag set and hence are in non-blocking
mode. This option is only useful in conjunction with a
socket unit, as described in <b>systemd.socket</b>(5) and
has no effect on file descriptors which were previously
saved in the file-descriptor store for example. Defaults to
false.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>NotifyAccess=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Controls
access to the service status notification socket, as
accessible via the <b>sd_notify</b>(3) call. Takes one of
<b>none</b> (the default), <b>main</b>, <b>exec</b> or
<b>all</b>. If <b>none</b>, no daemon status updates are
accepted from the service processes, all status update
messages are ignored. If <b>main</b>, only service updates
sent from the main process of the service are accepted. If
<b>exec</b>, only service updates sent from any of the main
or control processes originating from one of the
<i>Exec*=</i> commands are accepted. If <b>all</b>, all
services updates from all members of the service's control
group are accepted. This option should be set to open access
to the notification socket when using <i>Type=notify</i> or
<i>WatchdogSec=</i> (see above). If those options are used
but <i>NotifyAccess=</i> is not configured, it will be
implicitly set to <b>main</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that <b>sd_notify()</b> notifications may be attributed to
units correctly only if either the sending process is still
around at the time PID 1 processes the message, or if the
sending process is explicitly runtime-tracked by the service
manager. The latter is the case if the service manager
originally forked off the process, i.e. on all processes
that match <b>main</b> or <b>exec</b>. Conversely, if an
auxiliary process of the unit sends an <b>sd_notify()</b>
message and immediately exits, the service manager might not
be able to properly attribute the message to the unit, and
thus will ignore it, even if <i>NotifyAccess=</i><b>all</b>
is set for it.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Hence,
to eliminate all race conditions involving lookup of the
client's unit and attribution of notifications to units
correctly, <b>sd_notify_barrier()</b> may be used. This call
acts as a synchronization point and ensures all
notifications sent before this call have been picked up by
the service manager when it returns successfully. Use of
<b>sd_notify_barrier()</b> is needed for clients which are
not invoked by the service manager, otherwise this
synchronization mechanism is unnecessary for attribution of
notifications to the unit.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Sockets=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Specifies
the name of the socket units this service shall inherit
socket file descriptors from when the service is started.
Normally, it should not be necessary to use this setting, as
all socket file descriptors whose unit shares the same name
as the service (subject to the different unit name suffix of
course) are passed to the spawned process.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that the same socket file descriptors may be passed to
multiple processes simultaneously. Also note that a
different service may be activated on incoming socket
traffic than the one which is ultimately configured to
inherit the socket file descriptors. Or, in other words: the
<i>Service=</i> setting of .socket units does not have to
match the inverse of the <i>Sockets=</i> setting of the
.service it refers to.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option may appear more than once, in which case the list of
socket units is merged. Note that once set, clearing the
list of sockets again (for example, by assigning the empty
string to this option) is not supported.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>FileDescriptorStoreMax=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
how many file descriptors may be stored in the service
manager for the service using
<b>sd_pid_notify_with_fds</b>(3)'s &quot;FDSTORE=1&quot;
messages. This is useful for implementing services that can
restart after an explicit request or a crash without losing
state. Any open sockets and other file descriptors which
should not be closed during the restart may be stored this
way. Application state can either be serialized to a file in
/run/, or better, stored in a <b>memfd_create</b>(2) memory
file descriptor. Defaults to 0, i.e. no file descriptors may
be stored in the service manager. All file descriptors
passed to the service manager from a specific service are
passed back to the service's main process on the next
service restart (see <b>sd_listen_fds</b>(3) for details
about the precise protocol used and the order in which the
file descriptors are passed). Any file descriptors passed to
the service manager are automatically closed when
<b>POLLHUP</b> or <b>POLLERR</b> is seen on them, or when
the service is fully stopped and no job is queued or being
executed for it. If this option is used,
<i>NotifyAccess=</i> (see above) should be set to open
access to the notification socket provided by systemd. If
<i>NotifyAccess=</i> is not set, it will be implicitly set
to <b>main</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>USBFunctionDescriptors=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the location of a file containing</font>
<b><font color="#0000FF">USB FunctionFS</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">descriptors, for implementation of USB
gadget functions. This is used only in conjunction with a
socket unit with <i>ListenUSBFunction=</i> configured. The
contents of this file are written to the ep0 file after it
is opened.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>USBFunctionStrings=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the location of a file containing USB FunctionFS strings.
Behavior is similar to <i>USBFunctionDescriptors=</i>
above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>OOMPolicy=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the Out-Of-Memory (OOM) killer policy. On Linux, when memory
becomes scarce the kernel might decide to kill a running
process in order to free up memory and reduce memory
pressure. This setting takes one of <b>continue</b>,
<b>stop</b> or <b>kill</b>. If set to <b>continue</b> and a
process of the service is killed by the kernel's OOM killer
this is logged but the service continues running. If set to
<b>stop</b> the event is logged but the service is
terminated cleanly by the service manager. If set to
<b>kill</b> and one of the service's processes is killed by
the OOM killer the kernel is instructed to kill all
remaining processes of the service, too. Defaults to the
setting <i>DefaultOOMPolicy=</i> in
<b>systemd-system.conf</b>(5) is set to, except for services
where <i>Delegate=</i> is turned on, where it defaults to
<b>continue</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Use
the <i>OOMScoreAdjust=</i> setting to configure whether
processes of the unit shall be considered preferred or less
preferred candidates for process termination by the Linux
OOM killer logic. See <b>systemd.exec</b>(5) for
details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Check
<b>systemd.exec</b>(5) and <b>systemd.kill</b>(5) for more
settings.</font></p>

<h2>COMMAND LINES
<a name="COMMAND LINES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
section describes command line parsing and variable and
specifier substitutions for <i>ExecStart=</i>,
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecReload=</i>, <i>ExecStop=</i>, and
<i>ExecStopPost=</i> options.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Multiple
command lines may be concatenated in a single directive by
separating them with semicolons (these semicolons must be
passed as separate words). Lone semicolons may be escaped as
&quot;\;&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Each
command line is unquoted using the rules described in
&quot;Quoting&quot; section in <b>systemd.syntax</b>(7). The
first item becomes the command to execute, and the
subsequent items the arguments.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
syntax is inspired by shell syntax, but only the
meta-characters and expansions described in the following
paragraphs are understood, and the expansion of variables is
different. Specifically, redirection using &quot;&lt;&quot;,
&quot;&lt;&lt;&quot;, &quot;&gt;&quot;, and
&quot;&gt;&gt;&quot;, pipes using &quot;|&quot;, running
programs in the background using &quot;&amp;&quot;, and
<i>other elements of shell syntax are not
supported</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command to execute may contain spaces, but control
characters are not allowed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command line accepts &quot;%&quot; specifiers as described
in <b>systemd.unit</b>(5).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Basic
environment variable substitution is supported. Use
&quot;${FOO}&quot; as part of a word, or as a word of its
own, on the command line, in which case it will be erased
and replaced by the exact value of the environment variable
(if any) including all whitespace it contains, always
resulting in exactly a single argument. Use &quot;$FOO&quot;
as a separate word on the command line, in which case it
will be replaced by the value of the environment variable
split at whitespace, resulting in zero or more arguments.
For this type of expansion, quotes are respected when
splitting into words, and afterwards removed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
the command is not a full (absolute) path, it will be
resolved to a full path using a fixed search path determined
at compilation time. Searched directories include
/usr/local/bin/, /usr/bin/, /bin/ on systems using split
/usr/bin/ and /bin/ directories, and their sbin/
counterparts on systems using split bin/ and sbin/. It is
thus safe to use just the executable name in case of
executables located in any of the &quot;standard&quot;
directories, and an absolute path must be used in other
cases. Using an absolute path is recommended to avoid
ambiguity. Hint: this search path may be queried using
<b>systemd-path search-binaries-default</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Environment=&quot;ONE=one&quot;
'TWO=two two' <br>
ExecStart=echo $ONE $TWO ${TWO}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>/bin/echo</b> with four arguments:
&quot;one&quot;, &quot;two&quot;, &quot;two&quot;, and
&quot;two two&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Environment=ONE='one'
&quot;TWO='two&nbsp;two'&nbsp;too&quot; THREE= <br>
ExecStart=/bin/echo ${ONE} ${TWO} ${THREE} <br>
ExecStart=/bin/echo $ONE $TWO $THREE</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
results in /bin/echo being called twice, the first time with
arguments &quot;'one'&quot;,
&quot;'two&nbsp;two'&nbsp;too&quot;, &quot;&quot;, and the
second time with arguments &quot;one&quot;,
&quot;two&nbsp;two&quot;, &quot;too&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">To
pass a literal dollar sign, use &quot;$$&quot;. Variables
whose value is not known at expansion time are treated as
empty strings. Note that the first argument (i.e. the
program to execute) may not be a variable.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Variables
to be used in this fashion may be defined through
<i>Environment=</i> and <i>EnvironmentFile=</i>. In
addition, variables listed in the section &quot;Environment
variables in spawned processes&quot; in
<b>systemd.exec</b>(5), which are considered &quot;static
configuration&quot;, may be used (this includes e.g.
<i>$USER</i>, but not <i>$TERM</i>).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that shell command lines are not directly supported. If
shell command lines are to be used, they need to be passed
explicitly to a shell implementation of some kind.
Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=sh
-c 'dmesg | tac'</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=echo
one ; echo &quot;two two&quot;</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>echo</b> two times, each time with one
argument: &quot;one&quot; and &quot;two two&quot;,
respectively. Because two commands are specified,
<i>Type=oneshot</i> must be used.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=echo
/ &gt;/dev/null &amp; \; \ <br>
ls</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>echo</b> with five arguments: &quot;/&quot;,
&quot;&gt;/dev/null&quot;, &quot;&amp;&quot;, &quot;;&quot;,
and &quot;ls&quot;.</font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;2.&nbsp;Simple
service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following unit file creates a service that will execute
/usr/sbin/foo-daemon. Since no <i>Type=</i> is specified,
the default <i>Type=</i><b>simple</b> will be assumed.
systemd will assume the unit to be started immediately after
the program has begun executing.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Foo</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
ExecStart=/usr/sbin/foo-daemon</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi-user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that systemd assumes here that the process started by
systemd will continue running until the service terminates.
If the program daemonizes itself (i.e. forks), please use
<i>Type=</i><b>forking</b> instead.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Since
no <i>ExecStop=</i> was specified, systemd will send SIGTERM
to all processes started from this service, and after a
timeout also SIGKILL. This behavior can be modified, see
<b>systemd.kill</b>(5) for details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that this unit type does not include any type of
notification when a service has completed initialization.
For this, you should use other unit types, such as
<i>Type=</i><b>notify</b> if the service understands
systemd's notification protocol, <i>Type=</i><b>forking</b>
if the service can background itself or
<i>Type=</i><b>dbus</b> if the unit acquires a DBus name
once initialization is complete. See below.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;3.&nbsp;Oneshot
service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Sometimes,
units should just execute an action without keeping active
processes, such as a filesystem check or a cleanup action on
boot. For this, <i>Type=</i><b>oneshot</b> exists. Units of
this type will wait until the process specified terminates
and then fall back to being inactive. The following unit
will perform a cleanup action:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Cleanup old Foo data</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=oneshot <br>
ExecStart=/usr/sbin/foo-cleanup</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi-user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that systemd will consider the unit to be in the state
&quot;starting&quot; until the program has terminated, so
ordered dependencies will wait for the program to finish
before starting themselves. The unit will revert to the
&quot;inactive&quot; state after the execution is done,
never reaching the &quot;active&quot; state. That means
another request to start the unit will perform the action
again.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i><b>oneshot</b>
are the only service units that may have more than one
<i>ExecStart=</i> specified. For units with multiple
commands (<i>Type=oneshot</i>), all commands will be run
again.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
<i>Type=oneshot</i>, <i>Restart=</i><b>always</b> and
<i>Restart=</i><b>on-success</b> are <i>not</i>
allowed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;4.&nbsp;Stoppable
oneshot service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Similarly
to the oneshot services, there are sometimes units that need
to execute a program to set up something and then execute
another to shut it down, but no process remains active while
they are considered &quot;started&quot;. Network
configuration can sometimes fall into this category. Another
use case is if a oneshot service shall not be executed each
time when they are pulled in as a dependency, but only the
first time.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
this, systemd knows the setting
<i>RemainAfterExit=</i><b>yes</b>, which causes systemd to
consider the unit to be active if the start action exited
successfully. This directive can be used with all types, but
is most useful with <i>Type=</i><b>oneshot</b> and
<i>Type=</i><b>simple</b>. With <i>Type=</i><b>oneshot</b>,
systemd waits until the start action has completed before it
considers the unit to be active, so dependencies start only
after the start action has succeeded. With
<i>Type=</i><b>simple</b>, dependencies will start
immediately after the start action has been dispatched. The
following unit provides an example for a simple static
firewall.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple firewall</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=oneshot <br>
RemainAfterExit=yes <br>
ExecStart=/usr/local/sbin/simple-firewall-start <br>
ExecStop=/usr/local/sbin/simple-firewall-stop</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi-user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Since
the unit is considered to be running after the start action
has exited, invoking <b>systemctl start</b> on that unit
again will cause no action to be taken.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;5.&nbsp;Traditional
forking services</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Many
traditional daemons/services background (i.e. fork,
daemonize) themselves when starting. Set
<i>Type=</i><b>forking</b> in the service's unit file to
support this mode of operation. systemd will consider the
service to be in the process of initialization while the
original program is still running. Once it exits
successfully and at least a process remains (and
<i>RemainAfterExit=</i><b>no</b>), the service is considered
started.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Often,
a traditional daemon only consists of one process.
Therefore, if only one process is left after the original
process terminates, systemd will consider that process the
main process of the service. In that case, the
<i>$MAINPID</i> variable will be available in
<i>ExecReload=</i>, <i>ExecStop=</i>, etc.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">In
case more than one process remains, systemd will be unable
to determine the main process, so it will not assume there
is one. In that case, <i>$MAINPID</i> will not expand to
anything. However, if the process decides to write a
traditional PID file, systemd will be able to read the main
PID from there. Please set <i>PIDFile=</i> accordingly. Note
that the daemon should write that file before finishing with
its initialization. Otherwise, systemd might try to read the
file before it exists.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following example shows a simple daemon that forks and just
starts one process in the background:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Some simple daemon</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=forking <br>
ExecStart=/usr/sbin/my-simple-daemon -d</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi-user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;6.&nbsp;DBus
services</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
services that acquire a name on the DBus system bus, use
<i>Type=</i><b>dbus</b> and set <i>BusName=</i> accordingly.
The service should not fork (daemonize). systemd will
consider the service to be initialized once the name has
been acquired on the system bus. The following example shows
a typical DBus service:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple DBus service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=dbus <br>
BusName=org.example.simple-dbus-service <br>
ExecStart=/usr/sbin/simple-dbus-service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi-user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
<i>bus-activatable</i> services, do not include a [Install]
section in the systemd service file, but use the
<i>SystemdService=</i> option in the corresponding DBus
service file, for example
(/usr/share/dbus-1/system-services/org.example.simple-dbus-service.service):</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[D-BUS
Service] <br>
Name=org.example.simple-dbus-service <br>
Exec=/usr/sbin/simple-dbus-service <br>
User=root <br>
SystemdService=simple-dbus-service.service</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;7.&nbsp;Services
that notify systemd about their
initialization</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i><b>simple</b>
services are really easy to write, but have the major
disadvantage of systemd not being able to tell when
initialization of the given service is complete. For this
reason, systemd supports a simple notification protocol that
allows daemons to make systemd aware that they are done
initializing. Use <i>Type=</i><b>notify</b> for this. A
typical service file for such a daemon would look like
this:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple notifying service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=notify <br>
ExecStart=/usr/sbin/simple-notifying-service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi-user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that the daemon has to support systemd's notification
protocol, else systemd will think the service has not
started yet and kill it after a timeout. For an example of
how to update daemons to support this protocol
transparently, take a look at <b>sd_notify</b>(3). systemd
will consider the unit to be in the 'starting' state until a
readiness notification has arrived.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>systemd</b>(1),
<b>systemctl</b>(1), <b>systemd-system.conf</b>(5),
<b>systemd.unit</b>(5), <b>systemd.exec</b>(5),
<b>systemd.resource-control</b>(5), <b>systemd.kill</b>(5),
<b>systemd.directives</b>(7),
<b>systemd-run</b>(1)</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="41%">



<p style="margin-top: 1em"><font color="#000000">Incompatibilities
with SysV</font></p></td>
<td width="42%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://www.freedesktop.org/wiki/Software/systemd/Incompatibilities</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em"><font color="#000000">USB
FunctionFS</font></p> </td>
<td width="62%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://www.kernel.org/doc/Documentation/usb/functionfs.txt</font></p>
<hr>
</body>
</html>
