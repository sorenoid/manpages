<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 26 20:39:14 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ELF</title>

</head>
<body>

<h1 align="center">ELF</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">elf - format of
Executable and Linking Format (ELF) files</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;elf.h&gt;</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The header file
<i>&lt;elf.h&gt;</i> defines the format of ELF executable
binary files. Amongst these files are normal executable
files, relocatable object files, core files, and shared
objects.</p>

<p style="margin-left:11%; margin-top: 1em">An executable
file using the ELF file format consists of an ELF header,
followed by a program header table or a section header
table, or both. The ELF header is always at offset zero of
the file. The program header table and the section header
table&rsquo;s offset in the file are defined in the ELF
header. The two tables describe the rest of the
particularities of the file.</p>

<p style="margin-left:11%; margin-top: 1em">This header
file describes the above mentioned headers as C structures
and also includes structures for dynamic sections,
relocation sections and symbol tables.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Basic
types</b> <br>
The following types are used for N-bit architectures
(N=32,64, <i>ElfN</i> stands for <i>Elf32</i> or
<i>Elf64</i>, <i>uintN_t</i> stands for <i>uint32_t</i> or
<i>uint64_t</i>):</p>

<p style="margin-left:17%; margin-top: 1em">ElfN_Addr
Unsigned program address, uintN_t <br>
ElfN_Off Unsigned file offset, uintN_t <br>
ElfN_Section Unsigned section index, uint16_t <br>
ElfN_Versym Unsigned version symbol information, uint16_t
<br>
Elf_Byte unsigned char <br>
ElfN_Half uint16_t <br>
ElfN_Sword int32_t <br>
ElfN_Word uint32_t <br>
ElfN_Sxword int64_t <br>
ElfN_Xword uint64_t</p>

<p style="margin-left:11%; margin-top: 1em">(Note: the *BSD
terminology is a bit different. There, <i>Elf64_Half</i> is
twice as large as <i>Elf32_Half</i>, and <i>Elf64Quarter</i>
is used for <i>uint16_t</i>. In order to avoid confusion
these types are replaced by explicit ones in the below.)</p>

<p style="margin-left:11%; margin-top: 1em">All data
structures that the file format defines follow the
&quot;natural&quot; size and alignment guidelines for the
relevant class. If necessary, data structures contain
explicit padding to ensure 4-byte alignment for 4-byte
objects, to force structure sizes to a multiple of 4, and so
on.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ELF header
(Ehdr)</b> <br>
The ELF header is described by the type <i>Elf32_Ehdr</i> or
<i>Elf64_Ehdr</i>:</p>

<p style="margin-left:17%; margin-top: 1em">#define
EI_NIDENT 16</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
unsigned char e_ident[EI_NIDENT]; <br>
uint16_t e_type; <br>
uint16_t e_machine; <br>
uint32_t e_version; <br>
ElfN_Addr e_entry; <br>
ElfN_Off e_phoff; <br>
ElfN_Off e_shoff; <br>
uint32_t e_flags; <br>
uint16_t e_ehsize; <br>
uint16_t e_phentsize; <br>
uint16_t e_phnum; <br>
uint16_t e_shentsize; <br>
uint16_t e_shnum; <br>
uint16_t e_shstrndx; <br>
} ElfN_Ehdr;</p>

<p style="margin-left:11%; margin-top: 1em">The fields have
the following meanings: <i><br>
e_ident</i></p>

<p style="margin-left:22%;">This array of bytes specifies
how to interpret the file, independent of the processor or
the file&rsquo;s remaining contents. Within this array
everything is named by macros, which start with the prefix
<b>EI_</b> and may contain values which start with the
prefix <b>ELF</b>. The following macros are defined: <b><br>
EI_MAG0</b></p>

<p style="margin-left:32%;">The first byte of the magic
number. It must be filled with <b>ELFMAG0</b>. (0: 0x7f)</p>

<p style="margin-left:22%;"><b>EI_MAG1</b></p>

<p style="margin-left:32%;">The second byte of the magic
number. It must be filled with <b>ELFMAG1</b>. (1: 'E')</p>

<p style="margin-left:22%;"><b>EI_MAG2</b></p>

<p style="margin-left:32%;">The third byte of the magic
number. It must be filled with <b>ELFMAG2</b>. (2: 'L')</p>

<p style="margin-left:22%;"><b>EI_MAG3</b></p>

<p style="margin-left:32%;">The fourth byte of the magic
number. It must be filled with <b>ELFMAG3</b>. (3: 'F')</p>

<p style="margin-left:22%;"><b>EI_CLASS</b></p>

<p style="margin-left:32%;">The fifth byte identifies the
architecture for this binary:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="19%">


<p><b>ELFCLASSNONE</b></p></td>
<td width="3%"></td>
<td width="46%">


<p>This class is invalid.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="19%">


<p><b>ELFCLASS32</b></p></td>
<td width="3%"></td>
<td width="46%">


<p>This defines the 32-bit architecture. It supports
machines with files and virtual address spaces up to 4
Gigabytes.</p> </td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="19%">


<p><b>ELFCLASS64</b></p></td>
<td width="3%"></td>
<td width="46%">


<p>This defines the 64-bit architecture.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>EI_DATA</b></p>

<p style="margin-left:32%;">The sixth byte specifies the
data encoding of the processor-specific data in the file.
Currently, these encodings are supported:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="35%"></td>
<td width="17%">


<p><b>ELFDATANONE</b></p></td>
<td width="5%"></td>
<td width="43%">


<p>Unknown data format.</p></td></tr>
<tr valign="top" align="left">
<td width="35%"></td>
<td width="17%">


<p><b>ELFDATA2LSB</b></p></td>
<td width="5%"></td>
<td width="43%">


<p>Two&rsquo;s complement, little-endian.</p></td></tr>
<tr valign="top" align="left">
<td width="35%"></td>
<td width="17%">


<p><b>ELFDATA2MSB</b></p></td>
<td width="5%"></td>
<td width="43%">


<p>Two&rsquo;s complement, big-endian.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>EI_VERSION</b></p>

<p style="margin-left:32%;">The seventh byte is the version
number of the ELF specification:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="16%">


<p><b>EV_NONE</b></p></td>
<td width="6%"></td>
<td width="24%">


<p>Invalid version.</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="16%">


<p><b>EV_CURRENT</b></p></td>
<td width="6%"></td>
<td width="24%">


<p>Current version.</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>EI_OSABI</b></p>

<p style="margin-left:32%;">The eighth byte identifies the
operating system and ABI to which the object is targeted.
Some fields in other ELF structures have flags and values
that have platform-specific meanings; the interpretation of
those fields is determined by the value of this byte. For
example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_NONE</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>Same as ELFOSABI_SYSV</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_SYSV</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>UNIX System V ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_HPUX</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>HP-UX ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_NETBSD</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>NetBSD ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_LINUX</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>Linux ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_SOLARIS</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>Solaris ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_IRIX</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>IRIX ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_FREEBSD</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>FreeBSD ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_TRU64</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>TRU64 UNIX ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_ARM</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>ARM architecture ABI</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="30%">


<p><b>ELFOSABI_STANDALONE</b></p></td>
<td width="3%"></td>
<td width="35%">


<p>Stand-alone (embedded) ABI</p></td></tr>
</table>

<p style="margin-left:22%;"><b>EI_ABIVERSION</b></p>

<p style="margin-left:32%;">The ninth byte identifies the
version of the ABI to which the object is targeted. This
field is used to distinguish among incompatible versions of
an ABI. The interpretation of this version number is
dependent on the ABI identified by the <b>EI_OSABI</b>
field. Applications conforming to this specification use the
value 0.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>EI_PAD</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Start of padding. These bytes are reserved and set to
zero. Programs which read them should ignore them. The value
for <b>EI_PAD</b> will change in the future if currently
unused bytes are given meanings.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>EI_NIDENT</b></p>

<p style="margin-left:32%;">The size of the <i>e_ident</i>
array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>e_type</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This member of the structure identifies the object file
type:</p> </td></tr>
</table>

<p style="margin-left:22%;"><b>ET_NONE</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%"></td>
<td width="14%"></td>
<td width="29%">


<p style="margin-top: 1em">An unknown type.</p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>ET_REL</b></p></td>
<td width="14%"></td>
<td width="29%">


<p>A relocatable file.</p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>ET_EXEC</b></p></td>
<td width="14%"></td>
<td width="29%">


<p>An executable file.</p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>ET_DYN</b></p></td>
<td width="14%"></td>
<td width="29%">


<p>A shared object.</p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>ET_CORE</b></p></td>
<td width="14%"></td>
<td width="29%">


<p>A core file.</p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:11%;"><i>e_machine</i></p>

<p style="margin-left:22%;">This member specifies the
required architecture for an individual file. For
example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_NONE</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>An unknown machine</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_M32</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>AT&amp;T WE 32100</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_SPARC</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Sun Microsystems SPARC</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_386</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Intel 80386</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_68K</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Motorola 68000</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_88K</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Motorola 88000</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_860</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Intel 80860</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_MIPS</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>MIPS RS3000 (big-endian only)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_PARISC</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>HP/PA</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_SPARC32PLUS</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>SPARC with enhanced instruction set</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_PPC</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>PowerPC</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_PPC64</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>PowerPC 64-bit</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_S390</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>IBM S/390</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_ARM</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Advanced RISC Machines</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_SH</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Renesas SuperH</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_SPARCV9</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>SPARC v9 64-bit</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_IA_64</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>Intel Itanium</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_X86_64</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>AMD x86-64</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="21%">


<p><b>EM_VAX</b></p></td>
<td width="3%"></td>
<td width="54%">


<p>DEC Vax</p></td></tr>
</table>

<p style="margin-left:11%;"><i>e_version</i></p>

<p style="margin-left:22%;">This member identifies the file
version:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="15%">


<p><b>EV_NONE</b></p></td>
<td width="9%"></td>
<td width="23%">


<p>Invalid version</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="15%">


<p><b>EV_CURRENT</b></p></td>
<td width="9%"></td>
<td width="23%">


<p>Current version</p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%;"><i>e_entry</i></p>

<p style="margin-left:22%;">This member gives the virtual
address to which the system first transfers control, thus
starting the process. If the file has no associated entry
point, this member holds zero.</p>

<p style="margin-left:11%;"><i>e_phoff</i></p>

<p style="margin-left:22%;">This member holds the program
header table&rsquo;s file offset in bytes. If the file has
no program header table, this member holds zero.</p>

<p style="margin-left:11%;"><i>e_shoff</i></p>

<p style="margin-left:22%;">This member holds the section
header table&rsquo;s file offset in bytes. If the file has
no section header table, this member holds zero.</p>

<p style="margin-left:11%;"><i>e_flags</i></p>

<p style="margin-left:22%;">This member holds
processor-specific flags associated with the file. Flag
names take the form EF_&rsquo;machine_flag&rsquo;.
Currently, no flags have been defined.</p>

<p style="margin-left:11%;"><i>e_ehsize</i></p>

<p style="margin-left:22%;">This member holds the ELF
header&rsquo;s size in bytes.</p>

<p style="margin-left:11%;"><i>e_phentsize</i></p>

<p style="margin-left:22%;">This member holds the size in
bytes of one entry in the file&rsquo;s program header table;
all entries are the same size.</p>

<p style="margin-left:11%;"><i>e_phnum</i></p>

<p style="margin-left:22%;">This member holds the number of
entries in the program header table. Thus the product of
<i>e_phentsize</i> and <i>e_phnum</i> gives the
table&rsquo;s size in bytes. If a file has no program
header, <i>e_phnum</i> holds the value zero.</p>

<p style="margin-left:22%; margin-top: 1em">If the number
of entries in the program header table is larger than or
equal to <b>PN_XNUM</b> (0xffff), this member holds
<b>PN_XNUM</b> (0xffff) and the real number of entries in
the program header table is held in the <i>sh_info</i>
member of the initial entry in section header table.
Otherwise, the <i>sh_info</i> member of the initial entry
contains the value zero. <b><br>
PN_XNUM</b></p>

<p style="margin-left:32%;">This is defined as 0xffff, the
largest number <i>e_phnum</i> can have, specifying where the
actual number of program headers is assigned.</p>

<p style="margin-left:11%;"><i>e_shentsize</i></p>

<p style="margin-left:22%;">This member holds a sections
header&rsquo;s size in bytes. A section header is one entry
in the section header table; all entries are the same
size.</p>

<p style="margin-left:11%;"><i>e_shnum</i></p>

<p style="margin-left:22%;">This member holds the number of
entries in the section header table. Thus the product of
<i>e_shentsize</i> and <i>e_shnum</i> gives the section
header table&rsquo;s size in bytes. If a file has no section
header table, <i>e_shnum</i> holds the value of zero.</p>

<p style="margin-left:22%; margin-top: 1em">If the number
of entries in the section header table is larger than or
equal to <b>SHN_LORESERVE</b> (0xff00), <i>e_shnum</i> holds
the value zero and the real number of entries in the section
header table is held in the <i>sh_size</i> member of the
initial entry in section header table. Otherwise, the
<i>sh_size</i> member of the initial entry in the section
header table holds the value zero.</p>

<p style="margin-left:11%;"><i>e_shstrndx</i></p>

<p style="margin-left:22%;">This member holds the section
header table index of the entry associated with the section
name string table. If the file has no section name string
table, this member holds the value <b>SHN_UNDEF</b>.</p>

<p style="margin-left:22%; margin-top: 1em">If the index of
section name string table section is larger than or equal to
<b>SHN_LORESERVE</b> (0xff00), this member holds
<b>SHN_XINDEX</b> (0xffff) and the real index of the section
name string table section is held in the <i>sh_link</i>
member of the initial entry in section header table.
Otherwise, the <i>sh_link</i> member of the initial entry in
section header table contains the value zero.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
header (Phdr)</b> <br>
An executable or shared object file&rsquo;s program header
table is an array of structures, each describing a segment
or other information the system needs to prepare the program
for execution. An object file <i>segment</i> contains one or
more <i>sections</i>. Program headers are meaningful only
for executable and shared object files. A file specifies its
own program header size with the ELF header&rsquo;s
<i>e_phentsize</i> and <i>e_phnum</i> members. The ELF
program header is described by the type <i>Elf32_Phdr</i> or
<i>Elf64_Phdr</i> depending on the architecture:</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
uint32_t p_type; <br>
Elf32_Off p_offset; <br>
Elf32_Addr p_vaddr; <br>
Elf32_Addr p_paddr; <br>
uint32_t p_filesz; <br>
uint32_t p_memsz; <br>
uint32_t p_flags; <br>
uint32_t p_align; <br>
} Elf32_Phdr;</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
uint32_t p_type; <br>
uint32_t p_flags; <br>
Elf64_Off p_offset; <br>
Elf64_Addr p_vaddr; <br>
Elf64_Addr p_paddr; <br>
uint64_t p_filesz; <br>
uint64_t p_memsz; <br>
uint64_t p_align; <br>
} Elf64_Phdr;</p>

<p style="margin-left:11%; margin-top: 1em">The main
difference between the 32-bit and the 64-bit program header
lies in the location of the <i>p_flags</i> member in the
total struct.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>p_type</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This member of the structure indicates what kind of
segment this array element describes or how to interpret the
array element&rsquo;s information.</p></td></tr>
</table>

<p style="margin-left:26%;"><b>PT_NULL</b></p>

<p style="margin-left:37%;">The array element is unused and
the other members&rsquo; values are undefined. This lets the
program header have ignored entries.</p>

<p style="margin-left:26%;"><b>PT_LOAD</b></p>

<p style="margin-left:37%;">The array element specifies a
loadable segment, described by <i>p_filesz</i> and
<i>p_memsz</i>. The bytes from the file are mapped to the
beginning of the memory segment. If the segment&rsquo;s
memory size <i>p_memsz</i> is larger than the file size
<i>p_filesz</i>, the &quot;extra&quot; bytes are defined to
hold the value 0 and to follow the segment&rsquo;s
initialized area. The file size may not be larger than the
memory size. Loadable segment entries in the program header
table appear in ascending order, sorted on the
<i>p_vaddr</i> member.</p>

<p style="margin-left:26%;"><b>PT_DYNAMIC</b></p>

<p style="margin-left:37%;">The array element specifies
dynamic linking information.</p>

<p style="margin-left:26%;"><b>PT_INTERP</b></p>

<p style="margin-left:37%;">The array element specifies the
location and size of a null-terminated pathname to invoke as
an interpreter. This segment type is meaningful only for
executable files (though it may occur for shared objects).
However it may not occur more than once in a file. If it is
present, it must precede any loadable segment entry.</p>

<p style="margin-left:26%;"><b>PT_NOTE</b></p>

<p style="margin-left:37%;">The array element specifies the
location of notes (ElfN_Nhdr).</p>

<p style="margin-left:26%;"><b>PT_SHLIB</b></p>

<p style="margin-left:37%;">This segment type is reserved
but has unspecified semantics. Programs that contain an
array element of this type do not conform to the ABI.</p>

<p style="margin-left:26%;"><b>PT_PHDR</b></p>

<p style="margin-left:37%;">The array element, if present,
specifies the location and size of the program header table
itself, both in the file and in the memory image of the
program. This segment type may not occur more than once in a
file. Moreover, it may occur only if the program header
table is part of the memory image of the program. If it is
present, it must precede any loadable segment entry.</p>

<p style="margin-left:26%;"><b>PT_LOPROC</b>,
<b>PT_HIPROC</b></p>

<p style="margin-left:37%;">Values in the inclusive range
[<b>PT_LOPROC</b>, <b>PT_HIPROC</b>] are reserved for
processor-specific semantics.</p>

<p style="margin-left:26%;"><b>PT_GNU_STACK</b></p>

<p style="margin-left:37%;">GNU extension which is used by
the Linux kernel to control the state of the stack via the
flags set in the <i>p_flags</i> member.</p>

<p style="margin-left:11%;"><i>p_offset</i></p>

<p style="margin-left:22%;">This member holds the offset
from the beginning of the file at which the first byte of
the segment resides.</p>

<p style="margin-left:11%;"><i>p_vaddr</i></p>

<p style="margin-left:22%;">This member holds the virtual
address at which the first byte of the segment resides in
memory.</p>

<p style="margin-left:11%;"><i>p_paddr</i></p>

<p style="margin-left:22%;">On systems for which physical
addressing is relevant, this member is reserved for the
segment&rsquo;s physical address. Under BSD this member is
not used and must be zero.</p>

<p style="margin-left:11%;"><i>p_filesz</i></p>

<p style="margin-left:22%;">This member holds the number of
bytes in the file image of the segment. It may be zero.</p>

<p style="margin-left:11%;"><i>p_memsz</i></p>

<p style="margin-left:22%;">This member holds the number of
bytes in the memory image of the segment. It may be
zero.</p>

<p style="margin-left:11%;"><i>p_flags</i></p>

<p style="margin-left:22%;">This member holds a bit mask of
flags relevant to the segment:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>PF_X</b></p></td>
<td width="4%"></td>
<td width="34%">


<p>An executable segment.</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>PF_W</b></p></td>
<td width="4%"></td>
<td width="34%">


<p>A writable segment.</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>PF_R</b></p></td>
<td width="4%"></td>
<td width="34%">


<p>A readable segment.</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">A text segment
commonly has the flags <b>PF_X</b> and <b>PF_R</b>. A data
segment commonly has <b>PF_W</b> and <b>PF_R</b>.</p>

<p style="margin-left:11%;"><i>p_align</i></p>

<p style="margin-left:22%;">This member holds the value to
which the segments are aligned in memory and in the file.
Loadable process segments must have congruent values for
<i>p_vaddr</i> and <i>p_offset</i>, modulo the page size.
Values of zero and one mean no alignment is required.
Otherwise, <i>p_align</i> should be a positive, integral
power of two, and <i>p_vaddr</i> should equal
<i>p_offset</i>, modulo <i>p_align</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Section
header (Shdr)</b> <br>
A file&rsquo;s section header table lets one locate all the
file&rsquo;s sections. The section header table is an array
of <i>Elf32_Shdr</i> or <i>Elf64_Shdr</i> structures. The
ELF header&rsquo;s <i>e_shoff</i> member gives the byte
offset from the beginning of the file to the section header
table. <i>e_shnum</i> holds the number of entries the
section header table contains. <i>e_shentsize</i> holds the
size in bytes of each entry.</p>

<p style="margin-left:11%; margin-top: 1em">A section
header table index is a subscript into this array. Some
section header table indices are reserved: the initial entry
and the indices between <b>SHN_LORESERVE</b> and
<b>SHN_HIRESERVE</b>. The initial entry is used in ELF
extensions for <i>e_phnum</i>, <i>e_shnum</i>, and
<i>e_shstrndx</i>; in other cases, each field in the initial
entry is set to zero. An object file does not have sections
for these special indices: <b><br>
SHN_UNDEF</b></p>

<p style="margin-left:22%;">This value marks an undefined,
missing, irrelevant, or otherwise meaningless section
reference.</p>

<p style="margin-left:11%;"><b>SHN_LORESERVE</b></p>

<p style="margin-left:22%;">This value specifies the lower
bound of the range of reserved indices.</p>

<p style="margin-left:11%;"><b>SHN_LOPROC</b>,
<b>SHN_HIPROC</b></p>

<p style="margin-left:22%;">Values greater in the inclusive
range [<b>SHN_LOPROC</b>, <b>SHN_HIPROC</b>] are reserved
for processor-specific semantics.</p>

<p style="margin-left:11%;"><b>SHN_ABS</b></p>

<p style="margin-left:22%;">This value specifies the
absolute value for the corresponding reference. For example,
a symbol defined relative to section number <b>SHN_ABS</b>
has an absolute value and is not affected by relocation.</p>

<p style="margin-left:11%;"><b>SHN_COMMON</b></p>

<p style="margin-left:22%;">Symbols defined relative to
this section are common symbols, such as FORTRAN COMMON or
unallocated C external variables.</p>

<p style="margin-left:11%;"><b>SHN_HIRESERVE</b></p>

<p style="margin-left:22%;">This value specifies the upper
bound of the range of reserved indices. The system reserves
indices between <b>SHN_LORESERVE</b> and
<b>SHN_HIRESERVE</b>, inclusive. The section header table
does not contain entries for the reserved indices.</p>

<p style="margin-left:11%; margin-top: 1em">The section
header has the following structure:</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
uint32_t sh_name; <br>
uint32_t sh_type; <br>
uint32_t sh_flags; <br>
Elf32_Addr sh_addr; <br>
Elf32_Off sh_offset; <br>
uint32_t sh_size; <br>
uint32_t sh_link; <br>
uint32_t sh_info; <br>
uint32_t sh_addralign; <br>
uint32_t sh_entsize; <br>
} Elf32_Shdr;</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
uint32_t sh_name; <br>
uint32_t sh_type; <br>
uint64_t sh_flags; <br>
Elf64_Addr sh_addr; <br>
Elf64_Off sh_offset; <br>
uint64_t sh_size; <br>
uint32_t sh_link; <br>
uint32_t sh_info; <br>
uint64_t sh_addralign; <br>
uint64_t sh_entsize; <br>
} Elf64_Shdr;</p>

<p style="margin-left:11%; margin-top: 1em">No real
differences exist between the 32-bit and 64-bit section
headers. <i><br>
sh_name</i></p>

<p style="margin-left:22%;">This member specifies the name
of the section. Its value is an index into the section
header string table section, giving the location of a
null-terminated string.</p>

<p style="margin-left:11%;"><i>sh_type</i></p>

<p style="margin-left:22%;">This member categorizes the
section&rsquo;s contents and semantics. <b><br>
SHT_NULL</b></p>

<p style="margin-left:32%;">This value marks the section
header as inactive. It does not have an associated section.
Other members of the section header have undefined
values.</p>

<p style="margin-left:22%;"><b>SHT_PROGBITS</b></p>

<p style="margin-left:32%;">This section holds information
defined by the program, whose format and meaning are
determined solely by the program.</p>

<p style="margin-left:22%;"><b>SHT_SYMTAB</b></p>

<p style="margin-left:32%;">This section holds a symbol
table. Typically, <b>SHT_SYMTAB</b> provides symbols for
link editing, though it may also be used for dynamic
linking. As a complete symbol table, it may contain many
symbols unnecessary for dynamic linking. An object file can
also contain a <b>SHT_DYNSYM</b> section.</p>

<p style="margin-left:22%;"><b>SHT_STRTAB</b></p>

<p style="margin-left:32%;">This section holds a string
table. An object file may have multiple string table
sections.</p>

<p style="margin-left:22%;"><b>SHT_RELA</b></p>

<p style="margin-left:32%;">This section holds relocation
entries with explicit addends, such as type
<i>Elf32_Rela</i> for the 32-bit class of object files. An
object may have multiple relocation sections.</p>

<p style="margin-left:22%;"><b>SHT_HASH</b></p>

<p style="margin-left:32%;">This section holds a symbol
hash table. An object participating in dynamic linking must
contain a symbol hash table. An object file may have only
one hash table.</p>

<p style="margin-left:22%;"><b>SHT_DYNAMIC</b></p>

<p style="margin-left:32%;">This section holds information
for dynamic linking. An object file may have only one
dynamic section.</p>

<p style="margin-left:22%;"><b>SHT_NOTE</b></p>

<p style="margin-left:32%;">This section holds notes
(ElfN_Nhdr).</p>

<p style="margin-left:22%;"><b>SHT_NOBITS</b></p>

<p style="margin-left:32%;">A section of this type occupies
no space in the file but otherwise resembles
<b>SHT_PROGBITS</b>. Although this section contains no
bytes, the <i>sh_offset</i> member contains the conceptual
file offset.</p>

<p style="margin-left:22%;"><b>SHT_REL</b></p>

<p style="margin-left:32%;">This section holds relocation
offsets without explicit addends, such as type
<i>Elf32_Rel</i> for the 32-bit class of object files. An
object file may have multiple relocation sections.</p>

<p style="margin-left:22%;"><b>SHT_SHLIB</b></p>

<p style="margin-left:32%;">This section is reserved but
has unspecified semantics.</p>

<p style="margin-left:22%;"><b>SHT_DYNSYM</b></p>

<p style="margin-left:32%;">This section holds a minimal
set of dynamic linking symbols. An object file can also
contain a <b>SHT_SYMTAB</b> section.</p>

<p style="margin-left:22%;"><b>SHT_LOPROC</b>,
<b>SHT_HIPROC</b></p>

<p style="margin-left:32%;">Values in the inclusive range
[<b>SHT_LOPROC</b>, <b>SHT_HIPROC</b>] are reserved for
processor-specific semantics.</p>

<p style="margin-left:22%;"><b>SHT_LOUSER</b></p>

<p style="margin-left:32%;">This value specifies the lower
bound of the range of indices reserved for application
programs.</p>

<p style="margin-left:22%;"><b>SHT_HIUSER</b></p>

<p style="margin-left:32%;">This value specifies the upper
bound of the range of indices reserved for application
programs. Section types between <b>SHT_LOUSER</b> and
<b>SHT_HIUSER</b> may be used by the application, without
conflicting with current or future system-defined section
types.</p>

<p style="margin-left:11%;"><i>sh_flags</i></p>

<p style="margin-left:22%;">Sections support one-bit flags
that describe miscellaneous attributes. If a flag bit is set
in <i>sh_flags</i>, the attribute is &quot;on&quot; for the
section. Otherwise, the attribute is &quot;off&quot; or does
not apply. Undefined attributes are set to zero. <b><br>
SHF_WRITE</b></p>

<p style="margin-left:32%;">This section contains data that
should be writable during process execution.</p>

<p style="margin-left:22%;"><b>SHF_ALLOC</b></p>

<p style="margin-left:32%;">This section occupies memory
during process execution. Some control sections do not
reside in the memory image of an object file. This attribute
is off for those sections.</p>

<p style="margin-left:22%;"><b>SHF_EXECINSTR</b></p>

<p style="margin-left:32%;">This section contains
executable machine instructions.</p>

<p style="margin-left:22%;"><b>SHF_MASKPROC</b></p>

<p style="margin-left:32%;">All bits included in this mask
are reserved for processor-specific semantics.</p>

<p style="margin-left:11%;"><i>sh_addr</i></p>

<p style="margin-left:22%;">If this section appears in the
memory image of a process, this member holds the address at
which the section&rsquo;s first byte should reside.
Otherwise, the member contains zero.</p>

<p style="margin-left:11%;"><i>sh_offset</i></p>

<p style="margin-left:22%;">This member&rsquo;s value holds
the byte offset from the beginning of the file to the first
byte in the section. One section type, <b>SHT_NOBITS</b>,
occupies no space in the file, and its <i>sh_offset</i>
member locates the conceptual placement in the file.</p>

<p style="margin-left:11%;"><i>sh_size</i></p>

<p style="margin-left:22%;">This member holds the
section&rsquo;s size in bytes. Unless the section type is
<b>SHT_NOBITS</b>, the section occupies <i>sh_size</i> bytes
in the file. A section of type <b>SHT_NOBITS</b> may have a
nonzero size, but it occupies no space in the file.</p>

<p style="margin-left:11%;"><i>sh_link</i></p>

<p style="margin-left:22%;">This member holds a section
header table index link, whose interpretation depends on the
section type.</p>

<p style="margin-left:11%;"><i>sh_info</i></p>

<p style="margin-left:22%;">This member holds extra
information, whose interpretation depends on the section
type.</p>

<p style="margin-left:11%;"><i>sh_addralign</i></p>

<p style="margin-left:22%;">Some sections have address
alignment constraints. If a section holds a doubleword, the
system must ensure doubleword alignment for the entire
section. That is, the value of <i>sh_addr</i> must be
congruent to zero, modulo the value of <i>sh_addralign</i>.
Only zero and positive integral powers of two are allowed.
The value 0 or 1 means that the section has no alignment
constraints.</p>

<p style="margin-left:11%;"><i>sh_entsize</i></p>

<p style="margin-left:22%;">Some sections hold a table of
fixed-sized entries, such as a symbol table. For such a
section, this member gives the size in bytes for each entry.
This member contains zero if the section does not hold a
table of fixed-size entries.</p>

<p style="margin-left:11%; margin-top: 1em">Various
sections hold program and control information:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>.bss</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This section holds uninitialized data that contributes
to the program&rsquo;s memory image. By definition, the
system initializes the data with zeros when the program
begins to run. This section is of type <b>SHT_NOBITS</b>.
The attribute types are <b>SHF_ALLOC</b> and
<b>SHF_WRITE</b>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><i>.comment</i></p>

<p style="margin-left:22%;">This section holds version
control information. This section is of type
<b>SHT_PROGBITS</b>. No attribute types are used.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>.ctors</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This section holds initialized pointers to the C++
constructor functions. This section is of type
<b>SHT_PROGBITS</b>. The attribute types are
<b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>.data</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This section holds initialized data that contribute to
the program&rsquo;s memory image. This section is of type
<b>SHT_PROGBITS</b>. The attribute types are
<b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>.data1</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This section holds initialized data that contribute to
the program&rsquo;s memory image. This section is of type
<b>SHT_PROGBITS</b>. The attribute types are
<b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>.debug</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This section holds information for symbolic debugging.
The contents are unspecified. This section is of type
<b>SHT_PROGBITS</b>. No attribute types are used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>.dtors</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This section holds initialized pointers to the C++
destructor functions. This section is of type
<b>SHT_PROGBITS</b>. The attribute types are
<b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>.dynamic</i></p>

<p style="margin-left:22%;">This section holds dynamic
linking information. The section&rsquo;s attributes will
include the <b>SHF_ALLOC</b> bit. Whether the
<b>SHF_WRITE</b> bit is set is processor-specific. This
section is of type <b>SHT_DYNAMIC</b>. See the attributes
above.</p>

<p style="margin-left:11%;"><i>.dynstr</i></p>

<p style="margin-left:22%;">This section holds strings
needed for dynamic linking, most commonly the strings that
represent the names associated with symbol table entries.
This section is of type <b>SHT_STRTAB</b>. The attribute
type used is <b>SHF_ALLOC</b>.</p>

<p style="margin-left:11%;"><i>.dynsym</i></p>

<p style="margin-left:22%;">This section holds the dynamic
linking symbol table. This section is of type
<b>SHT_DYNSYM</b>. The attribute used is
<b>SHF_ALLOC</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>.fini</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This section holds executable instructions that
contribute to the process termination code. When a program
exits normally the system arranges to execute the code in
this section. This section is of type <b>SHT_PROGBITS</b>.
The attributes used are <b>SHF_ALLOC</b> and
<b>SHF_EXECINSTR</b>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><i>.gnu.version</i></p>

<p style="margin-left:22%;">This section holds the version
symbol table, an array of <i>ElfN_Half</i> elements. This
section is of type <b>SHT_GNU_versym</b>. The attribute type
used is <b>SHF_ALLOC</b>.</p>

<p style="margin-left:11%;"><i>.gnu.version_d</i></p>

<p style="margin-left:22%;">This section holds the version
symbol definitions, a table of <i>ElfN_Verdef</i>
structures. This section is of type <b>SHT_GNU_verdef</b>.
The attribute type used is <b>SHF_ALLOC</b>.</p>

<p style="margin-left:11%;"><i>.gnu.version_r</i></p>

<p style="margin-left:22%;">This section holds the version
symbol needed elements, a table of <i>ElfN_Verneed</i>
structures. This section is of type <b>SHT_GNU_versym</b>.
The attribute type used is <b>SHF_ALLOC</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>.got</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This section holds the global offset table. This section
is of type <b>SHT_PROGBITS</b>. The attributes are
processor-specific.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>.hash</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This section holds a symbol hash table. This section is
of type <b>SHT_HASH</b>. The attribute used is
<b>SHF_ALLOC</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>.init</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This section holds executable instructions that
contribute to the process initialization code. When a
program starts to run the system arranges to execute the
code in this section before calling the main program entry
point. This section is of type <b>SHT_PROGBITS</b>. The
attributes used are <b>SHF_ALLOC</b> and
<b>SHF_EXECINSTR</b>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><i>.interp</i></p>

<p style="margin-left:22%;">This section holds the pathname
of a program interpreter. If the file has a loadable segment
that includes the section, the section&rsquo;s attributes
will include the <b>SHF_ALLOC</b> bit. Otherwise, that bit
will be off. This section is of type
<b>SHT_PROGBITS</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>.line</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This section holds line number information for symbolic
debugging, which describes the correspondence between the
program source and the machine code. The contents are
unspecified. This section is of type <b>SHT_PROGBITS</b>. No
attribute types are used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>.note</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This section holds various notes. This section is of
type <b>SHT_NOTE</b>. No attribute types are used.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>.note.ABI-tag</i></p>

<p style="margin-left:22%;">This section is used to declare
the expected run-time ABI of the ELF image. It may include
the operating system name and its run-time versions. This
section is of type <b>SHT_NOTE</b>. The only attribute used
is <b>SHF_ALLOC</b>.</p>

<p style="margin-left:11%;"><i>.note.gnu.build-id</i></p>

<p style="margin-left:22%;">This section is used to hold an
ID that uniquely identifies the contents of the ELF image.
Different files with the same build ID should contain the
same executable content. See the <b>--build-id</b> option to
the GNU linker (<b>ld</b> (1)) for more details. This
section is of type <b>SHT_NOTE</b>. The only attribute used
is <b>SHF_ALLOC</b>.</p>

<p style="margin-left:11%;"><i>.note.GNU-stack</i></p>

<p style="margin-left:22%;">This section is used in Linux
object files for declaring stack attributes. This section is
of type <b>SHT_PROGBITS</b>. The only attribute used is
<b>SHF_EXECINSTR</b>. This indicates to the GNU linker that
the object file requires an executable stack.</p>

<p style="margin-left:11%;"><i>.note.openbsd.ident</i></p>

<p style="margin-left:22%;">OpenBSD native executables
usually contain this section to identify themselves so the
kernel can bypass any compatibility ELF binary emulation
tests when loading the file.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>.plt</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This section holds the procedure linkage table. This
section is of type <b>SHT_PROGBITS</b>. The attributes are
processor-specific.</p> </td></tr>
</table>

<p style="margin-left:11%;"><i>.relNAME</i></p>

<p style="margin-left:22%;">This section holds relocation
information as described below. If the file has a loadable
segment that includes relocation, the section&rsquo;s
attributes will include the <b>SHF_ALLOC</b> bit. Otherwise,
the bit will be off. By convention, &quot;NAME&quot; is
supplied by the section to which the relocations apply. Thus
a relocation section for <b>.text</b> normally would have
the name <b>.rel.text</b>. This section is of type
<b>SHT_REL</b>.</p>

<p style="margin-left:11%;"><i>.relaNAME</i></p>

<p style="margin-left:22%;">This section holds relocation
information as described below. If the file has a loadable
segment that includes relocation, the section&rsquo;s
attributes will include the <b>SHF_ALLOC</b> bit. Otherwise,
the bit will be off. By convention, &quot;NAME&quot; is
supplied by the section to which the relocations apply. Thus
a relocation section for <b>.text</b> normally would have
the name <b>.rela.text</b>. This section is of type
<b>SHT_RELA</b>.</p>

<p style="margin-left:11%;"><i>.rodata</i></p>

<p style="margin-left:22%;">This section holds read-only
data that typically contributes to a nonwritable segment in
the process image. This section is of type
<b>SHT_PROGBITS</b>. The attribute used is
<b>SHF_ALLOC</b>.</p>

<p style="margin-left:11%;"><i>.rodata1</i></p>

<p style="margin-left:22%;">This section holds read-only
data that typically contributes to a nonwritable segment in
the process image. This section is of type
<b>SHT_PROGBITS</b>. The attribute used is
<b>SHF_ALLOC</b>.</p>

<p style="margin-left:11%;"><i>.shstrtab</i></p>

<p style="margin-left:22%;">This section holds section
names. This section is of type <b>SHT_STRTAB</b>. No
attribute types are used.</p>

<p style="margin-left:11%;"><i>.strtab</i></p>

<p style="margin-left:22%;">This section holds strings,
most commonly the strings that represent the names
associated with symbol table entries. If the file has a
loadable segment that includes the symbol string table, the
section&rsquo;s attributes will include the <b>SHF_ALLOC</b>
bit. Otherwise, the bit will be off. This section is of type
<b>SHT_STRTAB</b>.</p>

<p style="margin-left:11%;"><i>.symtab</i></p>

<p style="margin-left:22%;">This section holds a symbol
table. If the file has a loadable segment that includes the
symbol table, the section&rsquo;s attributes will include
the <b>SHF_ALLOC</b> bit. Otherwise, the bit will be off.
This section is of type <b>SHT_SYMTAB</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>.text</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This section holds the &quot;text&quot;, or executable
instructions, of a program. This section is of type
<b>SHT_PROGBITS</b>. The attributes used are
<b>SHF_ALLOC</b> and <b>SHF_EXECINSTR</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>String and
symbol tables</b> <br>
String table sections hold null-terminated character
sequences, commonly called strings. The object file uses
these strings to represent symbol and section names. One
references a string as an index into the string table
section. The first byte, which is index zero, is defined to
hold a null byte ('\0'). Similarly, a string table&rsquo;s
last byte is defined to hold a null byte, ensuring null
termination for all strings.</p>

<p style="margin-left:11%; margin-top: 1em">An object
file&rsquo;s symbol table holds information needed to locate
and relocate a program&rsquo;s symbolic definitions and
references. A symbol table index is a subscript into this
array.</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
uint32_t st_name; <br>
Elf32_Addr st_value; <br>
uint32_t st_size; <br>
unsigned char st_info; <br>
unsigned char st_other; <br>
uint16_t st_shndx; <br>
} Elf32_Sym;</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
uint32_t st_name; <br>
unsigned char st_info; <br>
unsigned char st_other; <br>
uint16_t st_shndx; <br>
Elf64_Addr st_value; <br>
uint64_t st_size; <br>
} Elf64_Sym;</p>

<p style="margin-left:11%; margin-top: 1em">The 32-bit and
64-bit versions have the same members, just in a different
order. <i><br>
st_name</i></p>

<p style="margin-left:22%;">This member holds an index into
the object file&rsquo;s symbol string table, which holds
character representations of the symbol names. If the value
is nonzero, it represents a string table index that gives
the symbol name. Otherwise, the symbol has no name.</p>

<p style="margin-left:11%;"><i>st_value</i></p>

<p style="margin-left:22%;">This member gives the value of
the associated symbol.</p>

<p style="margin-left:11%;"><i>st_size</i></p>

<p style="margin-left:22%;">Many symbols have associated
sizes. This member holds zero if the symbol has no size or
an unknown size.</p>

<p style="margin-left:11%;"><i>st_info</i></p>

<p style="margin-left:22%;">This member specifies the
symbol&rsquo;s type and binding attributes: <b><br>
STT_NOTYPE</b></p>

<p style="margin-left:32%;">The symbol&rsquo;s type is not
defined.</p>

<p style="margin-left:22%;"><b>STT_OBJECT</b></p>

<p style="margin-left:32%;">The symbol is associated with a
data object.</p>

<p style="margin-left:22%;"><b>STT_FUNC</b></p>

<p style="margin-left:32%;">The symbol is associated with a
function or other executable code.</p>

<p style="margin-left:22%;"><b>STT_SECTION</b></p>

<p style="margin-left:32%;">The symbol is associated with a
section. Symbol table entries of this type exist primarily
for relocation and normally have <b>STB_LOCAL</b>
bindings.</p>

<p style="margin-left:22%;"><b>STT_FILE</b></p>

<p style="margin-left:32%;">By convention, the
symbol&rsquo;s name gives the name of the source file
associated with the object file. A file symbol has
<b>STB_LOCAL</b> bindings, its section index is
<b>SHN_ABS</b>, and it precedes the other <b>STB_LOCAL</b>
symbols of the file, if it is present.</p>

<p style="margin-left:22%;"><b>STT_LOPROC</b>,
<b>STT_HIPROC</b></p>

<p style="margin-left:32%;">Values in the inclusive range
[<b>STT_LOPROC</b>, <b>STT_HIPROC</b>] are reserved for
processor-specific semantics.</p>

<p style="margin-left:22%;"><b>STB_LOCAL</b></p>

<p style="margin-left:32%;">Local symbols are not visible
outside the object file containing their definition. Local
symbols of the same name may exist in multiple files without
interfering with each other.</p>

<p style="margin-left:22%;"><b>STB_GLOBAL</b></p>

<p style="margin-left:32%;">Global symbols are visible to
all object files being combined. One file&rsquo;s definition
of a global symbol will satisfy another file&rsquo;s
undefined reference to the same symbol.</p>

<p style="margin-left:22%;"><b>STB_WEAK</b></p>

<p style="margin-left:32%;">Weak symbols resemble global
symbols, but their definitions have lower precedence.</p>

<p style="margin-left:22%;"><b>STB_LOPROC</b>,
<b>STB_HIPROC</b></p>

<p style="margin-left:32%;">Values in the inclusive range
[<b>STB_LOPROC</b>, <b>STB_HIPROC</b>] are reserved for
processor-specific semantics.</p>

<p style="margin-left:22%; margin-top: 1em">There are
macros for packing and unpacking the binding and type
fields: <b><br>
ELF32_ST_BIND(</b><i>info</i><b>)</b>,
<b>ELF64_ST_BIND(</b><i>info</i><b>)</b></p>

<p style="margin-left:32%;">Extract a binding from an
<i>st_info</i> value.</p>


<p style="margin-left:22%;"><b>ELF32_ST_TYPE(</b><i>info</i><b>)</b>,
<b>ELF64_ST_TYPE(</b><i>info</i><b>)</b></p>

<p style="margin-left:32%;">Extract a type from an
<i>st_info</i> value.</p>


<p style="margin-left:22%;"><b>ELF32_ST_INFO(</b><i>bind</i><b>,</b>
<i>type</i><b>)</b>,
<b>ELF64_ST_INFO(</b><i>bind</i><b>,</b>
<i>type</i><b>)</b></p>

<p style="margin-left:32%;">Convert a binding and a type
into an <i>st_info</i> value.</p>

<p style="margin-left:11%;"><i>st_other</i></p>

<p style="margin-left:22%;">This member defines the symbol
visibility. <b><br>
STV_DEFAULT</b></p>

<p style="margin-left:32%;">Default symbol visibility
rules. Global and weak symbols are available to other
modules; references in the local module can be interposed by
definitions in other modules.</p>

<p style="margin-left:22%;"><b>STV_INTERNAL</b></p>

<p style="margin-left:32%;">Processor-specific hidden
class.</p>

<p style="margin-left:22%;"><b>STV_HIDDEN</b></p>

<p style="margin-left:32%;">Symbol is unavailable to other
modules; references in the local module always resolve to
the local symbol (i.e., the symbol can&rsquo;t be interposed
by definitions in other modules).</p>

<p style="margin-left:22%;"><b>STV_PROTECTED</b></p>

<p style="margin-left:32%;">Symbol is available to other
modules, but references in the local module always resolve
to the local symbol.</p>

<p style="margin-left:22%; margin-top: 1em">There are
macros for extracting the visibility type:</p>


<p style="margin-left:22%; margin-top: 1em"><b>ELF32_ST_VISIBILITY</b>(other)
or <b>ELF64_ST_VISIBILITY</b>(other)</p>

<p style="margin-left:11%;"><i>st_shndx</i></p>

<p style="margin-left:22%;">Every symbol table entry is
&quot;defined&quot; in relation to some section. This member
holds the relevant section header table index.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Relocation
entries (Rel &amp; Rela)</b> <br>
Relocation is the process of connecting symbolic references
with symbolic definitions. Relocatable files must have
information that describes how to modify their section
contents, thus allowing executable and shared object files
to hold the right information for a process&rsquo;s program
image. Relocation entries are these data.</p>

<p style="margin-left:11%; margin-top: 1em">Relocation
structures that do not need an addend:</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf32_Addr r_offset; <br>
uint32_t r_info; <br>
} Elf32_Rel;</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf64_Addr r_offset; <br>
uint64_t r_info; <br>
} Elf64_Rel;</p>

<p style="margin-left:11%; margin-top: 1em">Relocation
structures that need an addend:</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf32_Addr r_offset; <br>
uint32_t r_info; <br>
int32_t r_addend; <br>
} Elf32_Rela;</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf64_Addr r_offset; <br>
uint64_t r_info; <br>
int64_t r_addend; <br>
} Elf64_Rela;</p>

<p style="margin-left:11%;"><i>r_offset</i></p>

<p style="margin-left:22%;">This member gives the location
at which to apply the relocation action. For a relocatable
file, the value is the byte offset from the beginning of the
section to the storage unit affected by the relocation. For
an executable file or shared object, the value is the
virtual address of the storage unit affected by the
relocation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>r_info</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This member gives both the symbol table index with
respect to which the relocation must be made and the type of
relocation to apply. Relocation types are
processor-specific. When the text refers to a relocation
entry&rsquo;s relocation type or symbol table index, it
means the result of applying <b>ELF[32|64]_R_TYPE</b> or
<b>ELF[32|64]_R_SYM</b>, respectively, to the entry&rsquo;s
<i>r_info</i> member.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>r_addend</i></p>

<p style="margin-left:22%;">This member specifies a
constant addend used to compute the value to be stored into
the relocatable field.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Dynamic tags
(Dyn)</b> <br>
The <i>.dynamic</i> section contains a series of structures
that hold relevant dynamic linking information. The
<i>d_tag</i> member controls the interpretation of
<i>d_un</i>.</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf32_Sword d_tag; <br>
union { <br>
Elf32_Word d_val; <br>
Elf32_Addr d_ptr; <br>
} d_un; <br>
} Elf32_Dyn; <br>
extern Elf32_Dyn _DYNAMIC[];</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf64_Sxword d_tag; <br>
union { <br>
Elf64_Xword d_val; <br>
Elf64_Addr d_ptr; <br>
} d_un; <br>
} Elf64_Dyn; <br>
extern Elf64_Dyn _DYNAMIC[];</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>d_tag</i></p></td>
<td width="4%"></td>
<td width="75%">


<p>This member may have any of the following values:</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>DT_NULL</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%"></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em">Marks end of dynamic section</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_NEEDED</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>String table offset to name of a needed library</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_PLTRELSZ</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Size in bytes of PLT relocation entries</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_PLTGOT</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of PLT and/or GOT</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_HASH</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of symbol hash table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_STRTAB</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of string table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_SYMTAB</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of symbol table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_RELA</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of Rela relocation table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_RELASZ</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Size in bytes of the Rela relocation table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_RELAENT</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Size in bytes of a Rela relocation table entry</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_STRSZ</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Size in bytes of string table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_SYMENT</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Size in bytes of a symbol table entry</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_INIT</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of the initialization function</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_FINI</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of the termination function</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_SONAME</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>String table offset to name of shared object</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_RPATH</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>String table offset to library search path
(deprecated)</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_SYMBOLIC</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Alert linker to search this shared object before the
executable for symbols</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_REL</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of Rel relocation table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_RELSZ</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Size in bytes of Rel relocation table</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_RELENT</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Size in bytes of a Rel table entry</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_PLTREL</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Type of relocation entry to which the PLT refers (Rela
or Rel)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_DEBUG</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Undefined use for debugging</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_TEXTREL</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Absence of this entry indicates that no relocation
entries should apply to a nonwritable segment</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_JMPREL</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Address of relocation entries associated solely with the
PLT</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_BIND_NOW</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>Instruct dynamic linker to process all relocations
before transferring control to the executable</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="16%">


<p><b>DT_RUNPATH</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>String table offset to library search path</p></td></tr>
</table>

<p style="margin-left:22%;"><b>DT_LOPROC</b>,
<b>DT_HIPROC</b></p>

<p style="margin-left:40%;">Values in the inclusive range
[<b>DT_LOPROC</b>, <b>DT_HIPROC</b>] are reserved for
processor-specific semantics</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>d_val</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This member represents integer values with various
interpretations.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>d_ptr</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This member represents program virtual addresses. When
interpreting these addresses, the actual address should be
computed based on the original file value and memory base
address. Files do not contain relocation entries to fixup
these addresses.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>_DYNAMIC</i></p>

<p style="margin-left:22%;">Array containing all the
dynamic structures in the <i>.dynamic</i> section. This is
automatically populated by the linker.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Notes
(Nhdr)</b> <br>
ELF notes allow for appending arbitrary information for the
system to use. They are largely used by core files
(<i>e_type</i> of <b>ET_CORE</b>), but many projects define
their own set of extensions. For example, the GNU tool chain
uses ELF notes to pass information from the linker to the C
library.</p>

<p style="margin-left:11%; margin-top: 1em">Note sections
contain a series of notes (see the <i>struct</i> definitions
below). Each note is followed by the name field (whose
length is defined in <i>n_namesz</i>) and then by the
descriptor field (whose length is defined in
<i>n_descsz</i>) and whose starting address has a 4 byte
alignment. Neither field is defined in the note struct due
to their arbitrary lengths.</p>

<p style="margin-left:11%; margin-top: 1em">An example for
parsing out two consecutive notes should clarify their
layout in memory:</p>

<p style="margin-left:17%; margin-top: 1em">void *memory,
*name, *desc; <br>
Elf64_Nhdr *note, *next_note;</p>

<p style="margin-left:17%; margin-top: 1em">/* The buffer
is pointing to the start of the section/segment */ <br>
note = memory;</p>

<p style="margin-left:17%; margin-top: 1em">/* If the name
is defined, it follows the note */ <br>
name = note-&gt;n_namesz == 0 ? NULL : memory +
sizeof(*note);</p>

<p style="margin-left:17%; margin-top: 1em">/* If the
descriptor is defined, it follows the name <br>
(with alignment) */</p>

<p style="margin-left:17%; margin-top: 1em">desc =
note-&gt;n_descsz == 0 ? NULL : <br>
memory + sizeof(*note) + ALIGN_UP(note-&gt;n_namesz, 4);</p>

<p style="margin-left:17%; margin-top: 1em">/* The next
note follows both (with alignment) */ <br>
next_note = memory + sizeof(*note) + <br>
ALIGN_UP(note-&gt;n_namesz, 4) + <br>
ALIGN_UP(note-&gt;n_descsz, 4);</p>

<p style="margin-left:11%; margin-top: 1em">Keep in mind
that the interpretation of <i>n_type</i> depends on the
namespace defined by the <i>n_namesz</i> field. If the
<i>n_namesz</i> field is not set (e.g., is 0), then there
are two sets of notes: one for core files and one for all
other ELF types. If the namespace is unknown, then tools
will usually fallback to these sets of notes as well.</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf32_Word n_namesz; <br>
Elf32_Word n_descsz; <br>
Elf32_Word n_type; <br>
} Elf32_Nhdr;</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
{ <br>
Elf64_Word n_namesz; <br>
Elf64_Word n_descsz; <br>
Elf64_Word n_type; <br>
} Elf64_Nhdr;</p>

<p style="margin-left:11%;"><i>n_namesz</i></p>

<p style="margin-left:22%;">The length of the name field in
bytes. The contents will immediately follow this note in
memory. The name is null terminated. For example, if the
name is &quot;GNU&quot;, then <i>n_namesz</i> will be set to
4.</p>

<p style="margin-left:11%;"><i>n_descsz</i></p>

<p style="margin-left:22%;">The length of the descriptor
field in bytes. The contents will immediately follow the
name field in memory.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>n_type</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>Depending on the value of the name field, this member
may have any of the following values:</p></td></tr>
</table>

<p style="margin-left:22%;"><b>Core files (e_type =
ET_CORE)</b></p>

<p style="margin-left:29%;">Notes used by all core files.
These are highly operating system or architecture specific
and often require close coordination with kernels, C
libraries, and debuggers. These are used when the namespace
is the default (i.e., <i>n_namesz</i> will be set to 0), or
a fallback when the namespace is unknown.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PRSTATUS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>prstatus struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_FPREGSET</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>fpregset struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PRPSINFO</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>prpsinfo struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PRXREG</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>prxregset struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_TASKSTRUCT</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>task structure</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PLATFORM</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>String from sysinfo(SI_PLATFORM)</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_AUXV</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>auxv array</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_GWINDOWS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>gwindows struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_ASRS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>asrset struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PSTATUS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>pstatus struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PSINFO</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>psinfo struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PRCRED</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>prcred struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_UTSNAME</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>utsname struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_LWPSTATUS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>lwpstatus struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_LWPSINFO</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>lwpinfo struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PRFPXREG</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>fprxregset struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_SIGINFO</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>siginfo_t (size might increase over time)</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_FILE</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>Contains information about mapped files</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PRXFPREG</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>user_fxsr_struct</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PPC_VMX</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>PowerPC Altivec/VMX registers</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PPC_SPE</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>PowerPC SPE/EVR registers</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_PPC_VSX</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>PowerPC VSX registers</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_386_TLS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>i386 TLS slots (struct user_desc)</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_386_IOPERM</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>x86 io permission bitmap (1=deny)</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_X86_XSTATE</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>x86 extended state using xsave</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_HIGH_GPRS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 upper register halves</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_TIMER</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 timer register</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_TODCMP</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 time-of-day (TOD) clock comparator register</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_TODPREG</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 time-of-day (TOD) programmable register</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_CTRS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 control registers</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_PREFIX</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 prefix register</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_LAST_BREAK</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 breaking event address</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_SYSTEM_CALL</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 system call restart data</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_S390_TDB</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>s390 transaction diagnostic block</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_ARM_VFP</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>ARM VFP/NEON registers</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_ARM_TLS</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>ARM TLS register</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_ARM_HW_BREAK</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>ARM hardware breakpoint registers</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_ARM_HW_WATCH</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>ARM hardware watchpoint registers</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="29%">


<p><b>NT_ARM_SYSTEM_CALL</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>ARM system call number</p></td></tr>
</table>

<p style="margin-left:22%;"><b>n_name = GNU</b></p>

<p style="margin-left:29%;">Extensions used by the GNU tool
chain. <b><br>
NT_GNU_ABI_TAG</b></p>

<p style="margin-left:40%;">Operating system (OS) ABI
information. The desc field will be 4 words:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>word 0: OS descriptor (<b>ELF_NOTE_OS_LINUX</b>,
<b>ELF_NOTE_OS_GNU</b>, and so on)&rsquo;</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>word 1: major version of the ABI</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>word 2: minor version of the ABI</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>word 3: subminor version of the ABI</p></td></tr>
</table>

<p style="margin-left:29%;"><b>NT_GNU_HWCAP</b></p>

<p style="margin-left:40%;">Synthetic hwcap information.
The desc field begins with two words:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>word 0: number of entries</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>word 1: bit mask of enabled entries</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:40%; margin-top: 1em">Then follow
variable-length entries, one byte followed by a
null-terminated hwcap name string. The byte gives the bit
number to test if enabled, (1U &lt;&lt; bit) &amp; bit
mask.</p>

<p style="margin-left:29%;"><b>NT_GNU_BUILD_ID</b></p>

<p style="margin-left:40%;">Unique build ID as generated by
the GNU <b>ld</b>(1) <b>--build-id</b> option. The desc
consists of any nonzero number of bytes.</p>

<p style="margin-left:29%;"><b>NT_GNU_GOLD_VERSION</b></p>

<p style="margin-left:40%;">The desc contains the GNU Gold
linker version used.</p>

<p style="margin-left:22%;"><b>Default/unknown namespace
(e_type != ET_CORE)</b></p>

<p style="margin-left:29%;">These are used when the
namespace is the default (i.e., <i>n_namesz</i> will be set
to 0), or a fallback when the namespace is unknown.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="29%"></td>
<td width="16%">


<p><b>NT_VERSION</b></p></td>
<td width="3%"></td>
<td width="46%">


<p>A version string of some sort.</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="16%">


<p><b>NT_ARCH</b></p></td>
<td width="3%"></td>
<td width="46%">


<p>Architecture information.</p></td>
<td width="6%">
</td></tr>
</table>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ELF first
appeared in System V. The ELF format is an adopted
standard.</p>

<p style="margin-left:11%; margin-top: 1em">The extensions
for <i>e_phnum</i>, <i>e_shnum</i>, and <i>e_shstrndx</i>
respectively are Linux extensions. Sun, BSD and AMD64 also
support them; for further information, look under SEE
ALSO.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>as</b>(1),
<b>elfedit</b>(1), <b>gdb</b>(1), <b>ld</b>(1),
<b>nm</b>(1), <b>objcopy</b>(1), <b>objdump</b>(1),
<b>patchelf</b>(1), <b>readelf</b>(1), <b>size</b>(1),
<b>strings</b>(1), <b>strip</b>(1), <b>execve</b>(2),
<b>dl_iterate_phdr</b>(3), <b>core</b>(5),
<b>ld.so</b>(8)</p>


<p style="margin-left:11%; margin-top: 1em">Hewlett-Packard,
<i>Elf-64 Object File Format</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Santa Cruz
Operation, <i>System V Application Binary Interface</i>.</p>

<p style="margin-left:11%; margin-top: 1em">UNIX System
Laboratories, &quot;Object Files&quot;, <i>Executable and
Linking Format (ELF)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Sun
Microsystems, <i>Linker and Libraries Guide</i>.</p>

<p style="margin-left:11%; margin-top: 1em">AMD64 ABI
Draft, <i>System V Application Binary Interface AMD64
Architecture Processor Supplement</i>.</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 5.10 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
https://www.kernel.org/doc/man-pages/.</p>
<hr>
</body>
</html>
